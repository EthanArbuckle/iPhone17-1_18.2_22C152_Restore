void *CLMicroLocationLoiManager::VisitEntry@<X0>(CLMicroLocationLoiManager *this@<X0>, id *a2@<X1>, std::string *a3@<X8>)
{
  NSObject *v6;
  double v7;
  double v8;
  double v9;
  NSObject *v10;
  uint64_t v11;
  long long v12;
  NSObject *v13;
  NSObject *v14;
  void *result;
  BOOL v16;
  BOOL v20;
  std::string v21;
  uint64_t v22;

  v22 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v21.__r_.__value_.__r.__words[0] = 68289026;
    LOWORD(v21.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v21.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager: handleVisitEntry\"}", (uint8_t *)&v21, 0x12u);
  }
  [a2[4] coordinate];
  v8 = v7;
  [a2[4] coordinate];
  if (CLMicroLocationLoiManager::refreshRoutineStateAtLocation((ULDatabase **)this, v8, v9))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v10 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEFAULT, "LOI Manager, requested LOI for current visit location", (uint8_t *)&v21, 2u);
    }
    v11 = *((void *)this + 2);
    if (*(char *)(v11 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)(v11 + 8), *(void *)(v11 + 16));
    }
    else
    {
      v12 = *(_OWORD *)(v11 + 8);
      v21.__r_.__value_.__r.__words[2] = *(void *)(v11 + 24);
      *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v12;
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v21.__r_.__value_.__l.__size_ != 17)
      {
        operator delete(v21.__r_.__value_.__l.__data_);
        goto LABEL_46;
      }
      v20 = *(void *)v21.__r_.__value_.__l.__data_ != 0x20656D6F48206E49
         || *(void *)(v21.__r_.__value_.__r.__words[0] + 8) != 0x7461745320494F4CLL
         || *(unsigned char *)(v21.__r_.__value_.__r.__words[0] + 16) != 101;
      operator delete(v21.__r_.__value_.__l.__data_);
      if (v20) {
        goto LABEL_46;
      }
    }
    else
    {
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) != 17) {
        goto LABEL_46;
      }
      v16 = v21.__r_.__value_.__r.__words[0] == 0x20656D6F48206E49
         && v21.__r_.__value_.__l.__size_ == 0x7461745320494F4CLL;
      if (!v16 || v21.__r_.__value_.__s.__data_[16] != 101) {
        goto LABEL_46;
      }
    }
    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 1);
LABEL_46:
    result = std::string::basic_string[abi:ne180100]<0>(&v21, "In the process of entering Home LOI");
    goto LABEL_47;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  v13 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    v21.__r_.__value_.__r.__words[0] = 68289026;
    LOWORD(v21.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v21.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    _os_log_impl(&dword_25631F000, v13, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", (uint8_t *)&v21, 0x12u);
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  v14 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    v21.__r_.__value_.__r.__words[0] = 68289026;
    LOWORD(v21.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v21.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Failed To request LOI for current visit location", "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", (uint8_t *)&v21, 0x12u);
  }
  CLMicroLocationLoiManager::resetLoiVariables(this);
  result = std::string::basic_string[abi:ne180100]<0>(&v21, "Not in Active Location State");
LABEL_47:
  *a3 = v21;
  a3[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

double CLMicroLocationLoiManager::CustomLoiVisitEntry@<D0>(CLMicroLocationLoiManager *this@<X0>, uuid *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  v6 = a2 + 2;
  if (CLMicroLocationLoiManager::isValidGeofence(this, a2[2]))
  {
    CLMicroLocationLoiManager::handleCustomLoiVisitEntry(this, a2[2], buf);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v15);
        v15.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v15);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v9 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v9))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v15);
        v15.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v15);
      }
      v10 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_GenericFailure.isa, &cfstr_InvalidGeofenc.isa);
    uint64_t v11 = *((void *)this + 2);
    if (*(char *)(v11 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v11 + 8), *(void *)(v11 + 16));
    }
    else
    {
      long long v12 = *(_OWORD *)(v11 + 8);
      *(void *)&buf[16] = *(void *)(v11 + 24);
      *(_OWORD *)buf = v12;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563BE9CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  std::exception::~exception(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::RefreshLocationOnInterval@<D0>(CLMicroLocationLoiManager *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 488))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v10.__r_.__value_.__r.__words[0] = 68289026;
      LOWORD(v10.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v10.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, refreshing location on XPC trigger\"}", (uint8_t *)&v10, 0x12u);
    }
    *((_DWORD *)this + 124) = 5;
    *((unsigned char *)this + 500) = 1;
    CLMicroLocationLoiManager::refreshRoutineStateAtLocation((ULDatabase **)this, *((double *)this + 44), *((double *)this + 45));
    std::string::basic_string[abi:ne180100]<0>(&v10, "In the process of entering Home LOI");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v10.__r_.__value_.__r.__words[0] = 68289026;
      LOWORD(v10.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v10.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"refreshRoutineStateAtLastLocation, won't run, last location not set\"}", (uint8_t *)&v10, 0x12u);
    }
    uint64_t v7 = *((void *)this + 2);
    if (*(char *)(v7 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)(v7 + 8), *(void *)(v7 + 16));
    }
    else
    {
      long long v8 = *(_OWORD *)(v7 + 8);
      v10.__r_.__value_.__r.__words[2] = *(void *)(v7 + 24);
      *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v8;
    }
  }
  double result = *(double *)&v10.__r_.__value_.__l.__data_;
  *a2 = v10;
  a2[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

double CLMicroLocationLoiManager::FetchPlaceInference@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFetchPlaceInferenceForReason *a2@<X1>, std::string *a3@<X8>)
{
  *((_DWORD *)this + 124) = *((_DWORD *)a2 + 8);
  *((unsigned char *)this + 500) = 1;
  if (CLMicroLocationLoiManager::fetchPlaceInference(this))
  {
    std::string::basic_string[abi:ne180100]<0>(&v8, "In the process of entering Home LOI");
    double result = *(double *)&v8.__r_.__value_.__l.__data_;
    *a3 = v8;
    a3[1].__r_.__value_.__s.__data_[0] = 1;
  }
  else
  {
    if (*((unsigned char *)this + 500)) {
      *((unsigned char *)this + 500) = 0;
    }
    uint64_t v6 = *((void *)this + 2);
    if (*(char *)(v6 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v8, *(const std::string::value_type **)(v6 + 8), *(void *)(v6 + 16));
    }
    else
    {
      long long v7 = *(_OWORD *)(v6 + 8);
      v8.__r_.__value_.__r.__words[2] = *(void *)(v6 + 24);
      *(_OWORD *)&v8.__r_.__value_.__l.__data_ = v7;
    }
    double result = *(double *)&v8.__r_.__value_.__l.__data_;
    *a3 = v8;
    a3[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return result;
}

double CLMicroLocationLoiManager::VisitExit@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerLoiVisitExitEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v6 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = p_p;
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager:\", \"Handling Event\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 2);
  std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563BEE1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi@<D0>(id *this@<X0>, uuid *a2@<X1>, uint64_t a3@<X8>)
{
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "#LOI Manager, In Home LOI, exit it before creating custom LOI process", (uint8_t *)&v8, 2u);
  }
  CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 9);
  CLMicroLocationLoiManager::handleEnableCustomLoi(this, a2[2], &v8);
  double result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(void *)(a3 + 16) = v9;
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInHomeLoi@<D0>(CLMicroLocationLoiManager *this@<X0>, uuid *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v6 = a2 + 2;
  if (CLMicroLocationLoiManager::isValidGeofence(this, a2[2]))
  {
    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 10);
    CLMicroLocationLoiManager::handleCustomLoiVisitEntry(this, a2[2], buf);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v15);
        v15.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v15);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v9 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v9))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v15);
        v15.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v15);
      }
      std::string v10 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_GenericFailure.isa, &cfstr_InvalidGeofenc.isa);
    uint64_t v11 = *((void *)this + 2);
    if (*(char *)(v11 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v11 + 8), *(void *)(v11 + 16));
    }
    else
    {
      long long v12 = *(_OWORD *)(v11 + 8);
      *(void *)&buf[16] = *(void *)(v11 + 24);
      *(_OWORD *)buf = v12;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563BF248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  std::exception::~exception(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::FetchPlaceInferenceWhileInHomeLoi@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFetchPlaceInferenceForReason *a2@<X1>, std::string *a3@<X8>)
{
  int v5 = *((_DWORD *)a2 + 8);
  if (v5 == 12 || v5 == 3)
  {
    *((_DWORD *)this + 124) = v5;
    *((unsigned char *)this + 500) = 1;
    if (CLMicroLocationLoiManager::fetchPlaceInference(this))
    {
      std::string::basic_string[abi:ne180100]<0>(&v10, "In the process of entering Home LOI");
      double result = *(double *)&v10.__r_.__value_.__l.__data_;
      *a3 = v10;
      a3[1].__r_.__value_.__s.__data_[0] = 1;
      return result;
    }
    if (*((unsigned char *)this + 500)) {
      *((unsigned char *)this + 500) = 0;
    }
  }
  uint64_t v8 = *((void *)this + 2);
  if (*(char *)(v8 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
  }
  else
  {
    long long v9 = *(_OWORD *)(v8 + 8);
    v10.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
    *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v9;
  }
  double result = *(double *)&v10.__r_.__value_.__l.__data_;
  *a3 = v10;
  a3[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

double CLMicroLocationLoiManager::CustomLoiVisitExit@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerGeofenceExitEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uuid v24 = (uuid)*((_OWORD *)a2 + 2);
  if ((CLMicroLocationLoiManager::isValidGeofence(this, v24) & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v11 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl(&dword_25631F000, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v13 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v13))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v14 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v14;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_GenericFailure.isa, &cfstr_InvalidGeofenc_0.isa);
    uint64_t v10 = *((void *)this + 2);
    if (*(char *)(v10 + 31) < 0) {
      goto LABEL_51;
    }
LABEL_41:
    long long v15 = *(_OWORD *)(v10 + 8);
    *(void *)&buf[16] = *(void *)(v10 + 24);
    *(_OWORD *)buf = v15;
    goto LABEL_52;
  }
  if (*((void *)this + 51) != *(void *)v24.var0 || *((void *)this + 52) != *(void *)&v24.var0[8])
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      long long v7 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v7;
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v8 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      long long v9 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v9;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first", "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v10 = *((void *)this + 2);
    if (*(char *)(v10 + 31) < 0)
    {
LABEL_51:
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v10 + 8), *(void *)(v10 + 16));
      goto LABEL_52;
    }
    goto LABEL_41;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  v16 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v20);
      v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
    }
    v17 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 68289283;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(void *)&buf[20] = v17;
    _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for active LOI\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 11);
  std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
LABEL_52:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563BFA2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  std::exception::~exception(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInCustomLoi@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerGeofenceEntryEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uuid v24 = (uuid)*((_OWORD *)a2 + 2);
  if ((CLMicroLocationLoiManager::isValidGeofence(this, v24) & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    int v5 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v7 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v7))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      uint64_t v8 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v8;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_GenericFailure.isa, &cfstr_InvalidGeofenc.isa);
  }
  if (*((void *)this + 51) == *(void *)v24.var0 && *((void *)this + 52) == *(void *)&v24.var0[8])
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v12 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v13 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v13;
      _os_log_impl(&dword_25631F000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v14 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v14))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      long long v15 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v15;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v10 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      uint64_t v11 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v11;
      _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for different valid LOI, entering it\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 11);
    CLMicroLocationLoiManager::enterCustomLoi(this, *(uint64_t *)v24.var0, *(uint64_t *)&v24.var0[8], 10);
  }
  uint64_t v16 = *((void *)this + 2);
  if (*(char *)(v16 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v16 + 8), *(void *)(v16 + 16));
  }
  else
  {
    long long v17 = *(_OWORD *)(v16 + 8);
    *(void *)&buf[16] = *(void *)(v16 + 24);
    *(_OWORD *)buf = v17;
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C012C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  std::exception::~exception(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::EnableCustomLoiWhileInCustomLoi@<D0>(CLMicroLocationLoiManager *this@<X0>, uuid *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  CLMicroLocationLoiManager::handleDisableCustomLoiForAllServices(this, *(uuid *)((char *)this + 408));
  if (CLMicroLocationLoiManager::noMoreServicesMonitoringThisLoi(this, *(uuid *)((char *)this + 408)))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t v8 = 68289026;
      *(_WORD *)&v8[8] = 2082;
      *(void *)&v8[10] = "";
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, No more services interested in this active LOI, exiting\"}", v8, 0x12u);
    }
    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 9);
  }
  CLMicroLocationLoiManager::handleEnableCustomLoi((id *)this, a2[2], v8);
  double result = *(double *)v8;
  *(_OWORD *)a3 = *(_OWORD *)v8;
  *(void *)(a3 + 16) = *(void *)&v8[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

double CLMicroLocationLoiManager::CustomLoiDisableWhileInCustomLoi@<D0>(id *this@<X0>, uuid *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  CLMicroLocationLoiManager::handleDisableCustomLoi(this, a2[2], a2[3], &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  BOOL v6 = this[51] == *(id *)a2[2].var0 && this[52] == *(id *)&a2[2].var0[8];
  if (v6 && CLMicroLocationLoiManager::noMoreServicesMonitoringThisLoi((CLMicroLocationLoiManager *)this, a2[2]))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v7 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      buf.__r_.__value_.__r.__words[0] = 68289026;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, Since we are in the LOI exit LOI\"}", (uint8_t *)&buf, 0x12u);
    }
    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 9);
    std::string::basic_string[abi:ne180100]<0>(&buf, "Not in Active Location State");
  }
  else
  {
    uint64_t v8 = (char *)this[2];
    if (v8[31] < 0)
    {
      std::string::__init_copy_ctor_external(&buf, *((const std::string::value_type **)v8 + 1), *((void *)v8 + 2));
    }
    else
    {
      long long v9 = *(_OWORD *)(v8 + 8);
      buf.__r_.__value_.__r.__words[2] = *((void *)v8 + 3);
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v9;
    }
  }
  double result = *(double *)&buf.__r_.__value_.__l.__data_;
  *a3 = buf;
  a3[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

double CLMicroLocationLoiManager::LoiFetchFailure@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToFetchLoiForLocationEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 504))
  {
    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_HomeLoiEntryFa.isa, &cfstr_LoiFetchFailur.isa);
    CLMicroLocationLoiManager::resetLoiVariables(this);
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    BOOL v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *((void *)this + 2);
      if (*(char *)(v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v7 + 8), *(void *)(v7 + 16));
      }
      else
      {
        long long v8 = *(_OWORD *)(v7 + 8);
        v24.__r_.__value_.__r.__words[2] = *(void *)(v7 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v8;
      }
      int v9 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      std::string::size_type v10 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      uint64_t v11 = &v24;
      if (v9 < 0) {
        uint64_t v11 = (std::string *)v10;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v11;
      __int16 v26 = 2081;
      v27 = p_p;
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v24.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v13 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v13))
    {
      uint64_t v14 = *((void *)this + 2);
      if (*(char *)(v14 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v14 + 8), *(void *)(v14 + 16));
      }
      else
      {
        long long v15 = *(_OWORD *)(v14 + 8);
        v24.__r_.__value_.__r.__words[2] = *(void *)(v14 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
      }
      int v16 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      std::string::size_type v17 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v18 = &v24;
      if (v16 < 0) {
        v18 = (std::string *)v17;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v19 = &__p;
      }
      else {
        uint64_t v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v18;
      __int16 v26 = 2081;
      v27 = v19;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v24.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v20 = *((void *)this + 2);
    if (*(char *)(v20 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v20 + 8), *(void *)(v20 + 16));
    }
    else
    {
      long long v21 = *(_OWORD *)(v20 + 8);
      *(void *)&buf[16] = *(void *)(v20 + 24);
      *(_OWORD *)std::string buf = v21;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C07A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(std::string *this@<X0>, id *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  if (!this[21].__r_.__value_.__s.__data_[0])
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v25 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      std::string::size_type v26 = this->__r_.__value_.__r.__words[2];
      if (*(char *)(v26 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)(v26 + 8), *(void *)(v26 + 16));
      }
      else
      {
        long long v27 = *(_OWORD *)(v26 + 8);
        __str.__r_.__value_.__r.__words[2] = *(void *)(v26 + 24);
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v27;
      }
      int v43 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
      std::string::size_type v44 = __str.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)a2, &__p);
      p_str = &__str;
      if (v43 < 0) {
        p_str = (std::string *)v44;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = p_str;
      __int16 v60 = 2081;
      v61 = p_p;
      _os_log_impl(&dword_25631F000, v25, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v47 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v47))
    {
      std::string::size_type v48 = this->__r_.__value_.__r.__words[2];
      if (*(char *)(v48 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)(v48 + 8), *(void *)(v48 + 16));
      }
      else
      {
        long long v49 = *(_OWORD *)(v48 + 8);
        __str.__r_.__value_.__r.__words[2] = *(void *)(v48 + 24);
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v49;
      }
      int v50 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
      std::string::size_type v51 = __str.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)a2, &__p);
      v52 = &__str;
      if (v50 < 0) {
        v52 = (std::string *)v51;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v53 = &__p;
      }
      else {
        v53 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v52;
      __int16 v60 = 2081;
      v61 = v53;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v47, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v54 = this->__r_.__value_.__r.__words[2];
    if (*(char *)(v54 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v54 + 8), *(void *)(v54 + 16));
    }
    else
    {
      long long v55 = *(_OWORD *)(v54 + 8);
      *(void *)&buf[16] = *(void *)(v54 + 24);
      *(_OWORD *)std::string buf = v55;
    }
    goto LABEL_94;
  }
  BOOL v6 = [a2[4] _loiIdentifier];

  if (!v6)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v28 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl(&dword_25631F000, v28, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}", buf, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v29 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v29, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update", "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}", buf, 0x12u);
    }
    CLMicroLocationLoiManager::resetLoiVariables((CLMicroLocationLoiManager *)this);
    [this[14].__r_.__value_.__l.__data_ startLeechingLocationUpdates];
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
LABEL_94:
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = *(void *)&buf[16];
    *(unsigned char *)(a3 + 24) = 1;
    return;
  }
  uint64_t v7 = [a2[4] referenceLocation];
  [v7 coordinate];
  double v9 = v8;
  std::string::size_type v10 = [a2[4] referenceLocation];
  [v10 coordinate];
  CLMicroLocationLoiManager::initializeStateAtLocation((CLMicroLocationLoiManager *)this, v9, v11);

  CLMicroLocationLoiManager::convertPlaceInferenceUserPlaceTypeToString([a2[4] userType], buf);
  p_data = (void **)&this[16].__r_.__value_.__l.__data_;
  if (SHIBYTE(this[16].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(*p_data);
  }
  *(_OWORD *)p_data = *(_OWORD *)buf;
  this[16].__r_.__value_.__r.__words[2] = *(void *)&buf[16];
  uint64_t v13 = [a2[4] _loiIdentifier];
  id v14 = [v13 UUIDString];
  long long v15 = (char *)[v14 UTF8String];
  size_t v16 = strlen(v15);
  this[17].__r_.__value_.__r.__words[2] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)buf, (unsigned __int8 *)v15, (unsigned __int8 *)&v15[v16]);
  this[18].__r_.__value_.__r.__words[0] = v17;

  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  v18 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    uint64_t v19 = [a2[4] _loiIdentifier];
    id v20 = [v19 UUIDString];
    uint64_t v21 = [v20 UTF8String];
    v22 = this + 16;
    if (SHIBYTE(this[16].__r_.__value_.__r.__words[2]) < 0) {
      v22 = (std::string *)*p_data;
    }
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(void *)&buf[20] = v21;
    __int16 v60 = 2081;
    v61 = v22;
    _os_log_impl(&dword_25631F000, v18, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Retrieved place infernce\", \"LOI ID\":%{private, location:escape_only}s, \"LOI TYPE\":%{private, location:escape_only}s}", buf, 0x26u);
  }
  ULSettings::get<ULSettings::OverrideCurrentRTLOIType>((uint64_t)&__str);
  int v23 = HIBYTE(this[16].__r_.__value_.__r.__words[2]);
  if ((SHIBYTE(this[16].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string v24 = this + 16;
    if (v23 != 4) {
      goto LABEL_31;
    }
LABEL_30:
    if (LODWORD(v24->__r_.__value_.__l.__data_) == 1701670760) {
      goto LABEL_41;
    }
    goto LABEL_31;
  }
  if (this[16].__r_.__value_.__l.__size_ == 4)
  {
    std::string v24 = (std::string *)*p_data;
    goto LABEL_30;
  }
LABEL_31:
  std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    std::string::operator=(this + 16, &__str);
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v31 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v32 = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        v32 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v32;
      _os_log_impl(&dword_25631F000, v31, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, forcing LOI type\", \"LOI Override\":%{private, location:escape_only}s}", buf, 0x1Cu);
    }
    int v23 = HIBYTE(this[16].__r_.__value_.__r.__words[2]);
  }
LABEL_41:
  if ((v23 & 0x80) != 0)
  {
    if (this[16].__r_.__value_.__l.__size_ != 4)
    {
LABEL_47:
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
      }
      uint64_t v33 = logObject_MicroLocation_Default;
      if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO)) {
        goto LABEL_52;
      }
      *(_WORD *)std::string buf = 0;
      v34 = "LOI Manager, Not a Home LOI";
      v35 = v33;
      os_log_type_t v36 = OS_LOG_TYPE_INFO;
LABEL_51:
      _os_log_impl(&dword_25631F000, v35, v36, v34, buf, 2u);
LABEL_52:
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
      }
      v37 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_25631F000, v37, OS_LOG_TYPE_INFO, "LOI Manager, Returning to Inactive Location State and starting leeching", buf, 2u);
      }
      CLMicroLocationLoiManager::resetLoiVariables((CLMicroLocationLoiManager *)this);
      [this[14].__r_.__value_.__l.__data_ startLeechingLocationUpdates];
      std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
      goto LABEL_57;
    }
    p_data = (void **)*p_data;
  }
  else if (v23 != 4)
  {
    goto LABEL_47;
  }
  if (*(_DWORD *)p_data != 1701670760) {
    goto LABEL_47;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  v38 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_25631F000, v38, OS_LOG_TYPE_INFO, "LOI Manager, fetching related LOIs for LOI", buf, 2u);
  }
  v39 = [a2[4] _loiIdentifier];
  BOOL LoiIdsForLoi = CLMicroLocationLoiManager::fetchLoiIdsForLoi((CLMicroLocationLoiManager *)this, v39);

  if (!LoiIdsForLoi)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v56 = logObject_MicroLocation_Default;
    if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR)) {
      goto LABEL_52;
    }
    *(_WORD *)std::string buf = 0;
    v34 = "LOI Manager, Failed To request related LOIs";
    v35 = v56;
    os_log_type_t v36 = OS_LOG_TYPE_ERROR;
    goto LABEL_51;
  }
  LOWORD(this[21].__r_.__value_.__l.__data_) = 256;
  std::string::size_type v41 = this->__r_.__value_.__r.__words[2];
  if (*(char *)(v41 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v41 + 8), *(void *)(v41 + 16));
  }
  else
  {
    long long v42 = *(_OWORD *)(v41 + 8);
    *(void *)&buf[16] = *(void *)(v41 + 24);
    *(_OWORD *)std::string buf = v42;
  }
LABEL_57:
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_2563C1160(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double CLMicroLocationLoiManager::FailedToFetchedPlaceInference@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToFetchPlaceInference *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  BOOL v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_INFO, "LOI Manager, Failed To fetch place inferences, starting leeching", buf, 2u);
  }
  if (*((unsigned char *)this + 504))
  {
    ULSettings::get<ULSettings::OverrideCurrentRTLOIType>((uint64_t)buf);
    uint64_t v7 = buf[23];
    char v8 = buf[23];
    if (buf[23] < 0) {
      uint64_t v7 = *(void *)&buf[8];
    }
    if (!v7)
    {
      CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_HomeLoiEntryFa.isa, &cfstr_PlaceInference.isa);
      CLMicroLocationLoiManager::resetLoiVariables(this);
      [*((id *)this + 42) startLeechingLocationUpdates];
      std::string::basic_string[abi:ne180100]<0>(&v29, "Not in Active Location State");
      double result = *(double *)&v29.__r_.__value_.__l.__data_;
      *a3 = v29;
      a3[1].__r_.__value_.__s.__data_[0] = 1;
      if ((v8 & 0x80) == 0) {
        return result;
      }
      goto LABEL_19;
    }
    std::string::operator=((std::string *)this + 16, (const std::string *)buf);
    *((void *)this + 53) = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v29, "{FFFFFFFF-AAAA-1111-EEEE-DDDDDDDDDDDD}", (unsigned __int8 *)"");
    *((void *)this + 54) = v9;
    *((unsigned char *)this + 504) = 0;
    memset(&v29, 0, sizeof(v29));
    CLMicroLocationLoiManager::tryToEnterHomeLoi((uint64_t)this, (uint64_t)this + 384, (long long *)((char *)this + 424), (uint64_t)&v29, &__p);
    double result = *(double *)&__p.__r_.__value_.__l.__data_;
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    double v11 = (void *)v29.__r_.__value_.__r.__words[0];
    a3->__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[2];
    a3[1].__r_.__value_.__s.__data_[0] = 1;
    if (v11)
    {
      v29.__r_.__value_.__l.__size_ = (std::string::size_type)v11;
      operator delete(v11);
    }
    if ((buf[23] & 0x80) != 0) {
LABEL_19:
    }
      operator delete(*(void **)buf);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v12 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = *((void *)this + 2);
      if (*(char *)(v13 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v29, *(const std::string::value_type **)(v13 + 8), *(void *)(v13 + 16));
      }
      else
      {
        long long v14 = *(_OWORD *)(v13 + 8);
        v29.__r_.__value_.__r.__words[2] = *(void *)(v13 + 24);
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v14;
      }
      int v15 = SHIBYTE(v29.__r_.__value_.__r.__words[2]);
      std::string::size_type v16 = v29.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      std::string::size_type v17 = &v29;
      if (v15 < 0) {
        std::string::size_type v17 = (std::string *)v16;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v17;
      __int16 v31 = 2081;
      v32 = p_p;
      _os_log_impl(&dword_25631F000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v19 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v19))
    {
      uint64_t v20 = *((void *)this + 2);
      if (*(char *)(v20 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v29, *(const std::string::value_type **)(v20 + 8), *(void *)(v20 + 16));
      }
      else
      {
        long long v21 = *(_OWORD *)(v20 + 8);
        v29.__r_.__value_.__r.__words[2] = *(void *)(v20 + 24);
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v21;
      }
      int v22 = SHIBYTE(v29.__r_.__value_.__r.__words[2]);
      std::string::size_type v23 = v29.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      std::string v24 = &v29;
      if (v22 < 0) {
        std::string v24 = (std::string *)v23;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v25 = &__p;
      }
      else {
        uint64_t v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v24;
      __int16 v31 = 2081;
      v32 = v25;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v26 = *((void *)this + 2);
    if (*(char *)(v26 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v26 + 8), *(void *)(v26 + 16));
    }
    else
    {
      long long v27 = *(_OWORD *)(v26 + 8);
      *(void *)&buf[16] = *(void *)(v26 + 24);
      *(_OWORD *)std::string buf = v27;
    }
    double result = *(double *)buf;
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)buf;
    a3->__r_.__value_.__r.__words[2] = *(void *)&buf[16];
    a3[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return result;
}

void sub_2563C16B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::RelatedLois@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerReceivedRelatedLoisEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 505))
  {
    CLMicroLocationLoiManager::tryToEnterHomeLoi((uint64_t)this, (uint64_t)this + 384, (long long *)((char *)this + 424), (uint64_t)a2 + 32, buf);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    BOOL v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *((void *)this + 2);
      if (*(char *)(v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v7 + 8), *(void *)(v7 + 16));
      }
      else
      {
        long long v8 = *(_OWORD *)(v7 + 8);
        v24.__r_.__value_.__r.__words[2] = *(void *)(v7 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v8;
      }
      int v9 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      std::string::size_type v10 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      double v11 = &v24;
      if (v9 < 0) {
        double v11 = (std::string *)v10;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v11;
      __int16 v26 = 2081;
      long long v27 = p_p;
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v24.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v13 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v13))
    {
      uint64_t v14 = *((void *)this + 2);
      if (*(char *)(v14 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v14 + 8), *(void *)(v14 + 16));
      }
      else
      {
        long long v15 = *(_OWORD *)(v14 + 8);
        v24.__r_.__value_.__r.__words[2] = *(void *)(v14 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
      }
      int v16 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      std::string::size_type v17 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v18 = &v24;
      if (v16 < 0) {
        v18 = (std::string *)v17;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v19 = &__p;
      }
      else {
        uint64_t v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v18;
      __int16 v26 = 2081;
      long long v27 = v19;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v24.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v20 = *((void *)this + 2);
    if (*(char *)(v20 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v20 + 8), *(void *)(v20 + 16));
    }
    else
    {
      long long v21 = *(_OWORD *)(v20 + 8);
      *(void *)&buf[16] = *(void *)(v20 + 24);
      *(_OWORD *)std::string buf = v21;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C1A70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::FailureToFetchRelatedLois@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToFetchRelatedLois *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 505))
  {
    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_HomeLoiEntryFa.isa, &cfstr_RelatedLoiFetc.isa);
    CLMicroLocationLoiManager::resetLoiVariables(this);
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    BOOL v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *((void *)this + 2);
      if (*(char *)(v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v7 + 8), *(void *)(v7 + 16));
      }
      else
      {
        long long v8 = *(_OWORD *)(v7 + 8);
        v24.__r_.__value_.__r.__words[2] = *(void *)(v7 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v8;
      }
      int v9 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      std::string::size_type v10 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      double v11 = &v24;
      if (v9 < 0) {
        double v11 = (std::string *)v10;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v11;
      __int16 v26 = 2081;
      long long v27 = p_p;
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v24.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v13 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v13))
    {
      uint64_t v14 = *((void *)this + 2);
      if (*(char *)(v14 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v14 + 8), *(void *)(v14 + 16));
      }
      else
      {
        long long v15 = *(_OWORD *)(v14 + 8);
        v24.__r_.__value_.__r.__words[2] = *(void *)(v14 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
      }
      int v16 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      std::string::size_type v17 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v18 = &v24;
      if (v16 < 0) {
        v18 = (std::string *)v17;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v19 = &__p;
      }
      else {
        uint64_t v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v18;
      __int16 v26 = 2081;
      long long v27 = v19;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v24.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v20 = *((void *)this + 2);
    if (*(char *)(v20 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v20 + 8), *(void *)(v20 + 16));
    }
    else
    {
      long long v21 = *(_OWORD *)(v20 + 8);
      *(void *)&buf[16] = *(void *)(v20 + 24);
      *(_OWORD *)std::string buf = v21;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C1DF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::EnableCustomLoiWhileEnabling@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerEnableCustomLoiEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  BOOL v6 = (long long *)*((void *)this + 57);
  uint64_t v7 = (long long *)*((void *)this + 58);
  if (v6 == v7)
  {
LABEL_8:
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    std::string::size_type v10 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)a2 + 32, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v34);
        v34.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v34);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Adding new service to list of servies that have requested to enable custom LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    long long v12 = (_OWORD *)((char *)a2 + 32);
    uint64_t v14 = (_OWORD *)*((void *)this + 58);
    unint64_t v13 = *((void *)this + 59);
    if ((unint64_t)v14 >= v13)
    {
      uint64_t v16 = *((void *)this + 57);
      uint64_t v17 = ((uint64_t)v14 - v16) >> 4;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 60) {
        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v19 = v13 - v16;
      if (v19 >> 3 > v18) {
        unint64_t v18 = v19 >> 3;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v20 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20) {
        long long v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)this + 472, v20);
      }
      else {
        long long v21 = 0;
      }
      long long v27 = &v21[16 * v17];
      uint64_t v28 = &v21[16 * v20];
      *(_OWORD *)long long v27 = *v12;
      long long v15 = v27 + 16;
      v30 = (char *)*((void *)this + 57);
      std::string v29 = (char *)*((void *)this + 58);
      if (v29 != v30)
      {
        do
        {
          *((_OWORD *)v27 - 1) = *((_OWORD *)v29 - 1);
          v27 -= 16;
          v29 -= 16;
        }
        while (v29 != v30);
        std::string v29 = (char *)*((void *)this + 57);
      }
      *((void *)this + 57) = v27;
      *((void *)this + 58) = v15;
      *((void *)this + 59) = v28;
      if (v29) {
        operator delete(v29);
      }
    }
    else
    {
      _OWORD *v14 = *v12;
      long long v15 = v14 + 1;
    }
    *((void *)this + 58) = v15;
    uint64_t v26 = *((void *)this + 2);
    if (*(char *)(v26 + 31) < 0)
    {
LABEL_52:
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v26 + 8), *(void *)(v26 + 16));
      goto LABEL_53;
    }
  }
  else
  {
    long long v8 = (void *)((char *)a2 + 32);
    while (1)
    {
      long long v38 = *v6;
      if ((void)v38 == *v8 && *((void *)&v38 + 1) == *((void *)a2 + 5)) {
        break;
      }
      if (++v6 == v7) {
        goto LABEL_8;
      }
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    int v22 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v34);
        v34.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v34);
      }
      std::string::size_type v23 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v23;
      _os_log_impl(&dword_25631F000, v22, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    std::string v24 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v24))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v34);
        v34.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v34);
      }
      uint64_t v25 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        uint64_t v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v25;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got enable custom LOI request from the same service, ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v26 = *((void *)this + 2);
    if (*(char *)(v26 + 31) < 0) {
      goto LABEL_52;
    }
  }
  long long v31 = *(_OWORD *)(v26 + 8);
  *(void *)&buf[16] = *(void *)(v26 + 24);
  *(_OWORD *)std::string buf = v31;
LABEL_53:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C2368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  std::exception::~exception(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::CustomLoiEntryWhileEnabling@<D0>(id *this@<X0>, const CLMiLoLoiManagerGeofenceEntryEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  *(_OWORD *)uint64_t v26 = *((_OWORD *)a2 + 2);
  if (v26[0] == this[53] && v26[1] == this[54])
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v12 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      memset(&v23, 0, sizeof(v23));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v26, &v23) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)&__p);
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&__p);
      }
      unint64_t v13 = &v23;
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unint64_t v13 = (std::string *)v23.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v13;
      _os_log_impl(&dword_25631F000, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v23.__r_.__value_.__l.__data_);
      }
    }

    CLMicroLocationLoiManager::sendCustomLoiCreationEvent((CLMicroLocationLoiManager *)this);
    uint64_t v14 = this[57];
    long long v15 = this[58];
    while (v14 != v15)
    {
      *(_OWORD *)std::string buf = *v14;
      CLMicroLocationLoiManager::addLoiAndServiceMapping((CLMicroLocationLoiManager *)this, *(uuid *)v26, (const uuid *)buf);
      ++v14;
    }
    uint64_t v16 = -1;
  }
  else
  {
    BOOL v6 = (char *)(this + 53);
    if (*((unsigned char *)this + 424))
    {
LABEL_6:
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)std::string buf = &unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)buf);
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      long long v8 = [NSString stringWithUTF8String:p_p];
      int v9 = [v8 uppercaseString];

      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
      }
      std::string::size_type v10 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        double v11 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          double v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 68289283;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(void *)&buf[20] = v11;
        _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, Disabling geofence that we were trying to enable for custom LOI since we are failing the request\", \"loiID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      }
      [this[42] removeGeofenceWithRegionId:v9];

      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      unint64_t v17 = 0;
      while (v17 != 15)
      {
        unint64_t v18 = v17;
        if (*((unsigned __int8 *)this + v17++ + 425))
        {
          if (v18 <= 0xE) {
            goto LABEL_6;
          }
          break;
        }
      }
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    unint64_t v20 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl(&dword_25631F000, v20, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}", buf, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v21 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)std::string buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v21, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, Error: tried to enable custom LOI at an active custom LOI", "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}", buf, 0x12u);
    }
    uint64_t v16 = 34;
  }
  CLMicroLocationLoiManager::resetLoiVariables((CLMicroLocationLoiManager *)this);
  CLMicroLocationLoiManager::enterCustomLoi((CLMicroLocationLoiManager *)this, (uint64_t)v26[0], (uint64_t)v26[1], 10);
  (**(void (***)(id, uint64_t))this[43])(this[43], v16);
  std::string::basic_string[abi:ne180100]<0>(buf, "In Custom LOI State");
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C28C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::exception a21)
{
  std::exception::~exception(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::LocationUpdate@<D0>(uint64_t a1@<X0>, id *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 506))
  {
    id v6 = a2[4];
    [v6 coordinate];
    *(void *)(a1 + 352) = v7;
    [v6 coordinate];
    *(void *)(a1 + 360) = v8;
    objc_msgSend(*(id *)(a1 + 336), "removeGeofencesNearLocationWithLatitude:andLongitude:", *(double *)(a1 + 352));
    [v6 horizontalAccuracy];
    *(void *)(a1 + 368) = v9;
    [v6 verticalAccuracy];
    *(void *)(a1 + 376) = v10;
    *(void *)(a1 + 424) = 0;
    *(void *)(a1 + 432) = 0;
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    double v11 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 352);
      unint64_t v13 = *(std::string **)(a1 + 360);
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2049;
      *(void *)&buf[20] = v12;
      __int16 v36 = 2049;
      v37 = v13;
      _os_log_impl(&dword_25631F000, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got location update to enable custom geofence\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}", buf, 0x26u);
    }
    [*(id *)(a1 + 336) setGeofenceAtLocation:v6];
    *(_WORD *)(a1 + 506) = 256;
    uint64_t v14 = *(void *)(a1 + 16);
    if (*(char *)(v14 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v14 + 8), *(void *)(v14 + 16));
    }
    else
    {
      long long v15 = *(_OWORD *)(v14 + 8);
      *(void *)&buf[16] = *(void *)(v14 + 24);
      *(_OWORD *)std::string buf = v15;
    }
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = *(void *)&buf[16];
    *(unsigned char *)(a3 + 24) = 1;
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v16 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = *(void *)(a1 + 16);
      if (*(char *)(v17 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)(v17 + 8), *(void *)(v17 + 16));
      }
      else
      {
        long long v18 = *(_OWORD *)(v17 + 8);
        v34.__r_.__value_.__r.__words[2] = *(void *)(v17 + 24);
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v18;
      }
      int v20 = SHIBYTE(v34.__r_.__value_.__r.__words[2]);
      std::string::size_type v21 = v34.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)a2, &__p);
      int v22 = &v34;
      if (v20 < 0) {
        int v22 = (std::string *)v21;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v22;
      __int16 v36 = 2081;
      v37 = p_p;
      _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    std::string v24 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v24))
    {
      uint64_t v25 = *(void *)(a1 + 16);
      if (*(char *)(v25 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)(v25 + 8), *(void *)(v25 + 16));
      }
      else
      {
        long long v26 = *(_OWORD *)(v25 + 8);
        v34.__r_.__value_.__r.__words[2] = *(void *)(v25 + 24);
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v26;
      }
      int v27 = SHIBYTE(v34.__r_.__value_.__r.__words[2]);
      std::string::size_type v28 = v34.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)a2, &__p);
      std::string v29 = &v34;
      if (v27 < 0) {
        std::string v29 = (std::string *)v28;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        v30 = &__p;
      }
      else {
        v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v29;
      __int16 v36 = 2081;
      v37 = v30;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v31 = *(void *)(a1 + 16);
    if (*(char *)(v31 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v31 + 8), *(void *)(v31 + 16));
    }
    else
    {
      long long v32 = *(_OWORD *)(v31 + 8);
      *(void *)&buf[16] = *(void *)(v31 + 24);
      *(_OWORD *)std::string buf = v32;
    }
    double result = *(double *)buf;
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = *(void *)&buf[16];
    *(unsigned char *)(a3 + 24) = 1;
  }
  return result;
}

void sub_2563C2DA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::FailureToGetLocationUpdate@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToGetLocationUpdateEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  id v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}", buf, 0x12u);
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v7 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl(&dword_25631F000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to get current location to enable MiLo... aborting request", "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}", buf, 0x12u);
  }
  if (*((unsigned char *)this + 506))
  {
    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_CustomLoiEntry.isa, &cfstr_FailedToGetCur.isa);
    (***((void (****)(void, uint64_t))this + 43))(*((void *)this + 43), 34);
    CLMicroLocationLoiManager::resetLoiVariables(this);
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v8 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *((void *)this + 2);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v9 + 8), *(void *)(v9 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 8);
        v26.__r_.__value_.__r.__words[2] = *(void *)(v9 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v10;
      }
      int v11 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      std::string::size_type v12 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      unint64_t v13 = &v26;
      if (v11 < 0) {
        unint64_t v13 = (std::string *)v12;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v28 = 2081;
      std::string v29 = p_p;
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v26.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v15 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v15))
    {
      uint64_t v16 = *((void *)this + 2);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        v26.__r_.__value_.__r.__words[2] = *(void *)(v16 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v17;
      }
      int v18 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      std::string::size_type v19 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      int v20 = &v26;
      if (v18 < 0) {
        int v20 = (std::string *)v19;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v21 = &__p;
      }
      else {
        std::string::size_type v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v28 = 2081;
      std::string v29 = v21;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v26.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v22 = *((void *)this + 2);
    if (*(char *)(v22 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
    }
    else
    {
      long long v23 = *(_OWORD *)(v22 + 8);
      *(void *)&buf[16] = *(void *)(v22 + 24);
      *(_OWORD *)std::string buf = v23;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C3270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::GeofenceActivationStarted@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerStartedActivatingGeofenceEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 507))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v9 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *((void *)this + 2);
      if (*(char *)(v10 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v10 + 8), *(void *)(v10 + 16));
      }
      else
      {
        long long v11 = *(_OWORD *)(v10 + 8);
        v26.__r_.__value_.__r.__words[2] = *(void *)(v10 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v11;
      }
      int v12 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      std::string::size_type v13 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      uint64_t v14 = &v26;
      if (v12 < 0) {
        uint64_t v14 = (std::string *)v13;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v14;
      __int16 v28 = 2081;
      std::string v29 = p_p;
      _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v26.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v16 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v16))
    {
      uint64_t v17 = *((void *)this + 2);
      if (*(char *)(v17 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v17 + 8), *(void *)(v17 + 16));
      }
      else
      {
        long long v18 = *(_OWORD *)(v17 + 8);
        v26.__r_.__value_.__r.__words[2] = *(void *)(v17 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v18;
      }
      int v19 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      std::string::size_type v20 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      std::string::size_type v21 = &v26;
      if (v19 < 0) {
        std::string::size_type v21 = (std::string *)v20;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v22 = &__p;
      }
      else {
        uint64_t v22 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v21;
      __int16 v28 = 2081;
      std::string v29 = v22;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v26.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v8 = *((void *)this + 2);
    if (*(char *)(v8 + 31) < 0) {
      goto LABEL_11;
    }
LABEL_43:
    long long v23 = *(_OWORD *)(v8 + 8);
    *(void *)&buf[16] = *(void *)(v8 + 24);
    *(_OWORD *)std::string buf = v23;
    goto LABEL_44;
  }
  *(_OWORD *)((char *)this + 424) = *((_OWORD *)a2 + 2);
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  id v6 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)this + 424, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v26);
      v26.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_2704DAAD0;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v26);
    }
    uint64_t v7 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289283;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(void *)&buf[20] = v7;
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, successfully set geofence, now waiting on fence entry update\", \"geofenceId\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  uint64_t v8 = *((void *)this + 2);
  if ((*(char *)(v8 + 31) & 0x80000000) == 0) {
    goto LABEL_43;
  }
LABEL_11:
  std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
LABEL_44:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C3708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::FailureToActivateGeofenceAtCurrentLocation@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToSetGeofenceEvent *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  id v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}", buf, 0x12u);
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v7 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    *(_DWORD *)std::string buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl(&dword_25631F000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request", "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}", buf, 0x12u);
  }
  if (*((unsigned char *)this + 507))
  {
    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_CustomLoiEntry.isa, &cfstr_FailedToSetGeo.isa);
    (***((void (****)(void, uint64_t))this + 43))(*((void *)this + 43), 34);
    CLMicroLocationLoiManager::resetLoiVariables(this);
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v8 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *((void *)this + 2);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v9 + 8), *(void *)(v9 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 8);
        v26.__r_.__value_.__r.__words[2] = *(void *)(v9 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v10;
      }
      int v11 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      std::string::size_type v12 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      std::string::size_type v13 = &v26;
      if (v11 < 0) {
        std::string::size_type v13 = (std::string *)v12;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v28 = 2081;
      std::string v29 = p_p;
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v26.__r_.__value_.__l.__data_);
      }
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    long long v15 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v15))
    {
      uint64_t v16 = *((void *)this + 2);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        v26.__r_.__value_.__r.__words[2] = *(void *)(v16 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v17;
      }
      int v18 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      std::string::size_type v19 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      std::string::size_type v20 = &v26;
      if (v18 < 0) {
        std::string::size_type v20 = (std::string *)v19;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v21 = &__p;
      }
      else {
        std::string::size_type v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v28 = 2081;
      std::string v29 = v21;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v26.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v22 = *((void *)this + 2);
    if (*(char *)(v22 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
    }
    else
    {
      long long v23 = *(_OWORD *)(v22 + 8);
      *(void *)&buf[16] = *(void *)(v22 + 24);
      *(_OWORD *)std::string buf = v23;
    }
  }
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(unsigned char *)(a3 + 24) = 1;
  return result;
}

void sub_2563C3BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::EnteringCustomLoiTimeoutHandler@<D0>(CLMicroLocationLoiManager *this@<X0>, uint64_t a2@<X8>)
{
  CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, &cfstr_CustomLoiEntry.isa, &cfstr_CustomLoiEntry_0.isa);
  (***((void (****)(void))this + 43))();
  CLMicroLocationLoiManager::resetLoiVariables(this);
  std::string::basic_string[abi:ne180100]<0>(&v6, "Not in Active Location State");
  double result = *(double *)&v6;
  *(_OWORD *)a2 = v6;
  *(void *)(a2 + 16) = v7;
  *(unsigned char *)(a2 + 24) = 1;
  return result;
}

void CLMicroLocationLoiManager::setupWhenNotInAnActiveLocationState(CLMicroLocationLoiManager *this)
{
}

void sub_2563C3FB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    CLMiLoCustomLoiRecordingManager::setupIdleState();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLoiManager::setupWhenInAHomeLoiState(CLMicroLocationLoiManager *this)
{
}

void sub_2563C4314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    CLMiLoCustomLoiRecordingManager::setupIdleState();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLoiManager::setupInCustomLoiState(CLMicroLocationLoiManager *this)
{
}

void sub_2563C458C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    CLMiLoCustomLoiRecordingManager::setupIdleState();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLoiManager::setupEnteringHomeLoiState(CLMicroLocationLoiManager *this)
{
}

void sub_2563C4930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    CLMiLoCustomLoiRecordingManager::setupIdleState();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_2563C498C()
{
  MEMORY[0x25A2A6340](v0, 0x10B3C40A3150B78);
  JUMPOUT(0x2563C4984);
}

void CLMicroLocationLoiManager::setupEnteringCustomLoiState(CLMicroLocationLoiManager *this)
{
}

void sub_2563C4CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10) {
    CLMiLoCustomLoiRecordingManager::setupIdleState();
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLoiManager::~CLMicroLocationLoiManager(CLMicroLocationLoiManager *this)
{
  *(void *)this = &unk_2704DC708;
  v2 = (CLMicroLocationLoiManager *)((char *)this + 8);
  *((void *)this + 1) = &unk_2704DC778;

  v3 = (void *)*((void *)this + 57);
  if (v3)
  {
    *((void *)this + 58) = v3;
    operator delete(v3);
  }
  if (*((char *)this + 407) < 0) {
    operator delete(*((void **)this + 48));
  }

  CLMacAddress::newFromUint64((CLMacAddress *)this + 40, v4);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 39, v5);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 38, v6);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 37, v7);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 36, v8);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 35, v9);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 34, v10);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 33, v11);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 32, v12);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 31, v13);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 30, v14);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 29, v15);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 28, v16);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 27, v17);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 26, v18);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 25, v19);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 24, v20);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 23, v21);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 22, v22);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 21, v23);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 20, v24);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 19, v25);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 18, v26);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 17, v27);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 16, v28);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 15, v29);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 14, v30);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 13, v31);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 12, v32);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 11, v33);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 10, v34);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 9, v35);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 8, v36);
  CLMicroLocationStateMachine::StateMachineBase::~StateMachineBase(v2);
}

{
  uint64_t vars8;

  CLMicroLocationLoiManager::~CLMicroLocationLoiManager(this);
  JUMPOUT(0x25A2A6340);
}

void non-virtual thunk to'CLMicroLocationLoiManager::~CLMicroLocationLoiManager(CLMicroLocationLoiManager *this)
{
}

{
  uint64_t vars8;

  CLMicroLocationLoiManager::~CLMicroLocationLoiManager((CLMicroLocationLoiManager *)((char *)this - 8));
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::setupWithLoiBridge(id *a1, void *a2)
{
  id v4 = a2;
  if (!v4)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    unint64_t v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)unint64_t v6 = 0;
      _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_FAULT, "FAULT: Tried to initialize LOI Manager with a nil LOI Bridge Object", v6, 2u);
    }
  }
  objc_storeStrong(a1 + 42, a2);
  [a1[42] setMicroLocationLoiClient:a1];
  CLMicroLocationLoiManager::setupStartTimer((CLMicroLocationLoiManager *)a1);
}

void sub_2563C509C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::setupStartTimer(CLMicroLocationLoiManager *this)
{
  v2 = +[ULDefaultsSingleton shared];
  v3 = [v2 defaultsDictionary];

  id v4 = [NSString stringWithUTF8String:"ULInitialDelayForFetchPlaceInference"];
  unint64_t v5 = [v3 objectForKey:v4];
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    unsigned int v6 = [v5 unsignedIntValue];
  }
  else {
    unsigned int v6 = [&unk_2704F1968 unsignedIntValue];
  }
  unsigned int v7 = v6;

  v10[0] = MEMORY[0x263EF8330];
  v10[1] = 3221225472;
  v10[2] = ___ZN25CLMicroLocationLoiManager15setupStartTimerEv_block_invoke;
  v10[3] = &__block_descriptor_40_e5_v8__0l;
  v10[4] = this;
  uint64_t v8 = +[ULTimerFactory timerOnPrimaryQueueWithInterval:0 repeats:v10 block:(double)v7];
  unint64_t v9 = (void *)*((void *)this + 64);
  *((void *)this + 64) = v8;
}

void sub_2563C5248(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLoiManager::setupRegionMonitoring(CLMicroLocationLoiManager *this)
{
  v2 = (void *)*((void *)this + 42);
  if (!v2)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    v3 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)unint64_t v5 = 0;
      _os_log_impl(&dword_25631F000, v3, OS_LOG_TYPE_FAULT, "FAULT: Tried to setup Region Monitoring with a nil LOI Bridge Object", v5, 2u);
    }
    v2 = (void *)*((void *)this + 42);
  }
  return [v2 setupRegionMonitoring];
}

void CLMicroLocationLoiManager::enableMicroLocationAtCurrentLocationForService(CLMicroLocationLoiManager *this, const uuid *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v5 = (void (**)(CLMiLoLoiManagerEnableCustomLoiEvent *__hidden))&unk_2704DC488;
  id v4 = std::string::basic_string[abi:ne180100]<0>(&__p, "No Name Given");
  unint64_t v5 = off_2704DD290;
  long long v8 = (__int128)*a2;
  MEMORY[0x25A2A6080](v4, "Enable Custom LOI");
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)&v5);
  unint64_t v5 = (void (**)(CLMiLoLoiManagerEnableCustomLoiEvent *__hidden))&unk_2704DC488;
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_2563C5404(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerEnableCustomLoiEvent::~CLMiLoLoiManagerEnableCustomLoiEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::disableMicroLocationAtLocationForService(CLMicroLocationLoiManager *this, uuid a2, const uuid *a3)
{
  uint64_t v4 = *(void *)&a2.var0[8];
  uint64_t v5 = *(void *)a2.var0;
  uint64_t v14 = *MEMORY[0x263EF8340];
  long long v8 = (void (**)(CLMiLoLoiManagerDisableCustomLoiEvent *__hidden))&unk_2704DC488;
  char v7 = std::string::basic_string[abi:ne180100]<0>(&__p, "No Name Given");
  long long v8 = off_2704DD2B0;
  uint64_t v11 = v5;
  uint64_t v12 = v4;
  long long v13 = (__int128)*a3;
  MEMORY[0x25A2A6080](v7, "Disable Custom LOI");
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)&v8);
  long long v8 = (void (**)(CLMiLoLoiManagerDisableCustomLoiEvent *__hidden))&unk_2704DC488;
  if (v10 < 0) {
    operator delete(__p);
  }
}

void sub_2563C5574(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerDisableCustomLoiEvent::~CLMiLoLoiManagerDisableCustomLoiEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::fetchPlaceInferenceForReason(uint64_t a1, int a2)
{
  uint64_t v5 = &unk_2704DC488;
  uint64_t v4 = std::string::basic_string[abi:ne180100]<0>(&__p, "No Name Given");
  uint64_t v5 = &unk_2704DD2D0;
  int v8 = a2;
  MEMORY[0x25A2A6080](v4, "Fetch Place Inference For Reason");
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationStateMachine::StateMachineBase *)(a1 + 8), (CLMicroLocationStateMachine::EventBase *)&v5);
  uint64_t v5 = &unk_2704DC488;
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_2563C56A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerFetchPlaceInferenceForReason::~CLMiLoLoiManagerFetchPlaceInferenceForReason(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::handleRefreshLocationIntervalNotificaion(CLMicroLocationLoiManager *this)
{
  CLMiLoLoiManagerRefreshLocationOnEvent::CLMiLoLoiManagerRefreshLocationOnEvent((CLMiLoLoiManagerRefreshLocationOnEvent *)v2);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)v2);
  v2[0] = &unk_2704DC488;
  if (v3 < 0) {
    operator delete((void *)v2[1]);
  }
}

void sub_2563C5784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerRefreshLocationOnEvent::~CLMiLoLoiManagerRefreshLocationOnEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void *CLMicroLocationLoiManager::handleCustomLoiVisitEntry@<X0>(CLMicroLocationLoiManager *this@<X0>, uuid a2@<0:X1, 8:X2>, void *a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uuid v18 = a2;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v5 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v18, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v9);
      v9.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v9);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289283;
    int v13 = 0;
    __int16 v14 = 2082;
    unint64_t v15 = "";
    __int16 v16 = 2081;
    unint64_t v17 = p_p;
    _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry event for valid LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  CLMicroLocationLoiManager::enterCustomLoi(this, *(uint64_t *)v18.var0, *(uint64_t *)&v18.var0[8], 10);
  return std::string::basic_string[abi:ne180100]<0>(a3, "In Custom LOI State");
}

void sub_2563C59B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  std::exception::~exception(&a15);
  if (a14 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::enterCustomLoi(CLMicroLocationLoiManager *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CLMicroLocationLoiManager::sendCustomLoiVisitEvent(a1, &cfstr_CustomLoi.isa, &cfstr_Entry.isa);
  std::string::basic_string[abi:ne180100]<0>(&__p, "custom");
  CLMicroLocationLoiManager::enterLoi((uint64_t)a1, a2, a3, &__p, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  *(void *)v9.var0 = a2;
  *(void *)&v9.var0[8] = a3;
  CLMicroLocationLoiManager::updateDbCustomLoiWasLastSeenNow(a1, v9);
}

void sub_2563C5A80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *CLMicroLocationLoiManager::handleEnableCustomLoi@<X0>(id *this@<X0>, uuid a2@<0:X1, 8:X2>, void *a3@<X8>)
{
  uint64_t v3 = *(void *)&a2.var0[8];
  uint64_t v4 = *(void *)a2.var0;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  char v7 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v22[0] = 0;
    _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_DEFAULT, "#LOI Manager, kick off creating custom LOI process", (uint8_t *)v22, 2u);
  }
  [this[42] getCurrentLocation];
  uuid v9 = this[58];
  int v8 = this[59];
  if (v9 >= (void *)v8)
  {
    uint64_t v11 = this[57];
    uint64_t v12 = ((char *)v9 - v11) >> 4;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v14 = v8 - v11;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      __int16 v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)(this + 59), v15);
    }
    else {
      __int16 v16 = 0;
    }
    unint64_t v17 = &v16[16 * v12];
    uuid v18 = &v16[16 * v15];
    *(void *)unint64_t v17 = v4;
    *((void *)v17 + 1) = v3;
    char v10 = v17 + 16;
    unint64_t v20 = (char *)this[57];
    uint64_t v19 = (char *)this[58];
    if (v19 != v20)
    {
      do
      {
        *((_OWORD *)v17 - 1) = *((_OWORD *)v19 - 1);
        v17 -= 16;
        v19 -= 16;
      }
      while (v19 != v20);
      uint64_t v19 = (char *)this[57];
    }
    this[57] = v17;
    this[58] = v10;
    this[59] = v18;
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    void *v9 = v4;
    v9[1] = v3;
    char v10 = v9 + 2;
  }
  this[58] = v10;
  this[53] = 0;
  this[54] = 0;
  return std::string::basic_string[abi:ne180100]<0>(a3, "In the process of entering Custom LOI");
}

void CLMicroLocationLoiManager::handleDisableCustomLoi(id *this@<X0>, uuid a2@<0:X1, 8:X2>, uuid a3@<0:X3, 8:X4>, std::string *a4@<X8>)
{
  CLMicroLocationLoiManager::disableCustomLoiForService(this, a2, a3);
  (*(void (**)(id, uint64_t))(*(void *)this[43] + 8))(this[43], -1);
  unsigned int v6 = (char *)this[2];
  if (v6[31] < 0)
  {
    int v8 = (const std::string::value_type *)*((void *)v6 + 1);
    std::string::size_type v9 = *((void *)v6 + 2);
    std::string::__init_copy_ctor_external(a4, v8, v9);
  }
  else
  {
    long long v7 = *(_OWORD *)(v6 + 8);
    a4->__r_.__value_.__r.__words[2] = *((void *)v6 + 3);
    *(_OWORD *)&a4->__r_.__value_.__l.__data_ = v7;
  }
}

void CLMicroLocationLoiManager::disableCustomLoiForService(id *this, uuid a2, uuid a3)
{
  uint64_t v3 = *(void *)&a2.var0[8];
  uint64_t v4 = *(void *)a2.var0;
  uint64_t v20 = *MEMORY[0x263EF8340];
  uuid v19 = a2;
  uuid v18 = a3;
  CLMicroLocationLoiManager::removeLoiAndServiceMapping((CLMicroLocationLoiManager *)this, a2, &v18);
  *(void *)v21.var0 = v4;
  *(void *)&v21.var0[8] = v3;
  if (CLMicroLocationLoiManager::noMoreServicesMonitoringThisLoi((CLMicroLocationLoiManager *)this, v21))
  {
    memset(&v13, 0, sizeof(v13));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v19, &v13) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)std::string buf = &unk_2704DAAD0;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)buf);
    }
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v18, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)std::string buf = &unk_2704DAAD0;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)buf);
    }
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v6 = &v13;
    }
    else {
      unsigned int v6 = (std::string *)v13.__r_.__value_.__r.__words[0];
    }
    long long v7 = [NSString stringWithUTF8String:v6];
    int v8 = [v7 uppercaseString];

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    std::string::size_type v9 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      char v10 = &v13;
      if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        char v10 = (std::string *)v13.__r_.__value_.__r.__words[0];
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)unint64_t v15 = 2082;
      *(void *)&v15[2] = "";
      *(_WORD *)&v15[10] = 2081;
      *(void *)&v15[12] = v10;
      __int16 v16 = 2081;
      unint64_t v17 = p_p;
      _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, No More services monitoring this LOI, disable geofence for LOI\", \"loiID\":%{private, location:escape_only}s, \"Service Id\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    [this[42] removeGeofenceWithRegionId:v8];

    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v13.__r_.__value_.__l.__data_);
    }
  }
}

void sub_2563C5F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::exception a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::removeLoiAndServiceMapping(CLMicroLocationLoiManager *this, uuid a2, const uuid *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uuid v17 = a2;
  memset(&v9, 0, sizeof(v9));
  if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)a3, &v9) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(void *)std::string buf = &unk_2704DAAD0;
    boost::throw_exception<boost::bad_lexical_cast>((uint64_t)buf);
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v5 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v17, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v10);
      v10.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v10);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    long long v7 = &v9;
    if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      long long v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v14 = 2082;
    *(void *)&v14[2] = "";
    *(_WORD *)&v14[10] = 2081;
    *(void *)&v14[12] = p_p;
    __int16 v15 = 2081;
    __int16 v16 = v7;
    _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, Removing LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  [*(id *)(*((void *)this + 41) + 104) removeServiceToCustomLoiMapping:a3 loiId:&v17];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_2563C61C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::exception a22,uint64_t a23,uint64_t a24,std::exception a25)
{
  std::exception::~exception(&a22);
  if (a15 < 0) {
    operator delete(__p);
  }

  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

BOOL CLMicroLocationLoiManager::noMoreServicesMonitoringThisLoi(CLMicroLocationLoiManager *this, uuid a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uuid v7 = a2;
  id v2 = *(id *)(*((void *)this + 41) + 104);
  uint64_t v3 = v2;
  if (v2)
  {
    [v2 getAllServicesEnabledAtCustomLoiId:&v7];
  }
  else
  {
    uint64_t v5 = 0;
    unsigned int v6 = 0;
  }

  if (v5) {
    operator delete(v5);
  }
  return v6 == v5;
}

void sub_2563C62D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::handleDisableCustomLoiForAllServices(CLMicroLocationLoiManager *this, uuid a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uuid v8 = a2;
  id v3 = *(id *)(*((void *)this + 41) + 104);
  uint64_t v4 = v3;
  if (v3)
  {
    [v3 getAllServicesEnabledAtCustomLoiId:&v8];
  }
  else
  {
    unsigned int v6 = 0;
    uuid v7 = 0;
  }

  uint64_t v5 = v6;
  if (v6 != v7)
  {
    do
      CLMicroLocationLoiManager::disableCustomLoiForService((id *)this, v8, *v5++);
    while (v5 != v7);
    uint64_t v5 = v6;
  }
  if (v5) {
    operator delete(v5);
  }
}

void sub_2563C63B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  _Unwind_Resume(a1);
}

void *CLMicroLocationLoiManager::tryToEnterHomeLoi@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, long long *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 408) = CLMicroLocationLoiManager::getLoiGroupId(a1, a2, a3, a4);
  *(void *)(a1 + 416) = v7;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uuid v8 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>(a1 + 408, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v18);
      v18.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v18);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289283;
    int v22 = 0;
    __int16 v23 = 2082;
    unint64_t v24 = "";
    __int16 v25 = 2081;
    unint64_t v26 = p_p;
    _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Fetched LOI Group ID\", \"LOI Group ID \":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  if (*(unsigned char *)(a1 + 408))
  {
LABEL_10:
    [*(id *)(a1 + 336) stopLeechingLocationUpdates];
    if (*(unsigned char *)(a1 + 500))
    {
      uint64_t v10 = *(unsigned int *)(a1 + 496);
      *(unsigned char *)(a1 + 500) = 0;
    }
    else
    {
      uint64_t v10 = 1;
    }
    uint64_t v14 = *(void *)(a1 + 344);
    if (*(char *)(a1 + 407) < 0) {
      std::string::__init_copy_ctor_external(&v16, *(const std::string::value_type **)(a1 + 384), *(void *)(a1 + 392));
    }
    else {
      std::string v16 = *(std::string *)(a1 + 384);
    }
    (*(void (**)(uint64_t, std::string *, void, void, uint64_t))(*(void *)v14 + 16))(v14, &v16, *(void *)(a1 + 408), *(void *)(a1 + 416), v10);
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
    std::string v13 = "In Home LOI State";
  }
  else
  {
    uint64_t v11 = 409;
    while (v11 != 424)
    {
      if (*(unsigned __int8 *)(a1 + v11++))
      {
        if ((unint64_t)(v11 - 410) < 0xF) {
          goto LABEL_10;
        }
        break;
      }
    }
    CLMicroLocationLoiManager::resetLoiVariables((CLMicroLocationLoiManager *)a1);
    std::string v13 = "Not in Active Location State";
  }
  return std::string::basic_string[abi:ne180100]<0>(a5, v13);
}

void sub_2563C6658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::exception a22)
{
  std::exception::~exception(&a22);
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLoiManager::getLoiGroupId(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  long long v46 = 0uLL;
  id v8 = *(id *)(*(void *)(a1 + 328) + 56);
  uint64_t v9 = v8;
  if (v8)
  {
    [v8 getLoiGroupIdForLoi:a3];
  }
  else
  {
    long long v44 = 0uLL;
    char v45 = 0;
  }

  if (v45)
  {
    if (v44 == 0)
    {
      long long v44 = *a3;
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
      }
      uint64_t v10 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEBUG, "#LOI Manager, Overwriting stored LOI group ID because nil uuid was retrieved", buf, 2u);
      }
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v11 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      if (!v45) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      memset(&v36, 0, sizeof(v36));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v44, &v36) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)v37);
        *(void *)v37 = &unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)v37);
      }
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v12 = &v36;
      }
      else {
        uint64_t v12 = (std::string *)v36.__r_.__value_.__r.__words[0];
      }
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)a3, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)v37);
        *(void *)v37 = &unk_2704DAAD0;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)v37);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string::size_type v41 = 2082;
      *(void *)&v41[2] = "";
      *(_WORD *)&v41[10] = 2082;
      *(void *)&v41[12] = v12;
      __int16 v42 = 2082;
      int v43 = p_p;
      _os_log_impl(&dword_25631F000, v11, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, got previously stored LOI Group ID for LOI ID\", \"LOI Group Id\":%{public, location:escape_only}s, \"LOI ID\":%{public, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v36.__r_.__value_.__l.__data_);
      }
    }

    if (!v45) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    long long v46 = v44;
    goto LABEL_47;
  }
  id v14 = *(id *)(*(void *)(a1 + 328) + 56);
  __int16 v15 = v14;
  if (v14)
  {
    [v14 getLoiGroupIdsForLois:a4];
  }
  else
  {
    *(void *)std::string buf = 0;
    *(void *)std::string::size_type v41 = 0;
    *(void *)&v41[8] = 0;
  }

  if (*(void *)v41 != *(void *)buf)
  {
    if (*(void *)v41 - *(void *)buf >= 0x11uLL)
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
      }
      std::string v16 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v37 = 0;
        _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_ERROR, "#LOI Manager, received multiple Loi Group IDs for LOI -- this should never happen", v37, 2u);
      }
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uuid v17 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v37 = 0;
      _os_log_impl(&dword_25631F000, v17, OS_LOG_TYPE_INFO, "#LOI Manager, got previously stored LOI Group ID for list of LOI IDs", v37, 2u);
    }
    std::bad_cast v18 = *(long long **)buf;
    long long v46 = **(_OWORD **)buf;
LABEL_46:
    *(void *)std::string::size_type v41 = v18;
    operator delete(v18);
    goto LABEL_47;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uuid v19 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v37 = 0;
    _os_log_impl(&dword_25631F000, v19, OS_LOG_TYPE_INFO, "#LOI Manager, never before seen LOI, so starting with this LOI ID as the group ID", v37, 2u);
  }
  long long v46 = *a3;
  std::bad_cast v18 = *(long long **)buf;
  if (*(void *)buf) {
    goto LABEL_46;
  }
LABEL_47:
  uint64_t v20 = *(const void **)a4;
  uint64_t v21 = *(void *)(a4 + 8);
  unint64_t v22 = (v21 - *(void *)a4) >> 4;
  *(void *)std::string::size_type v41 = 0;
  *(void *)&v41[8] = 0;
  *(void *)std::string buf = 0;
  std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<std::__wrap_iter<boost::uuids::uuid const*>,std::__wrap_iter<boost::uuids::uuid const*>>(buf, v20, v21, v22);
  uint64_t v23 = *(void *)v41;
  if (*(void *)v41 >= *(void *)&v41[8])
  {
    uint64_t v25 = (uint64_t)(*(void *)v41 - *(void *)buf) >> 4;
    unint64_t v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 60) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v27 = *(void *)&v41[8] - *(void *)buf;
    if ((uint64_t)(*(void *)&v41[8] - *(void *)buf) >> 3 > v26) {
      unint64_t v26 = v27 >> 3;
    }
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v28 = v26;
    }
    if (v28) {
      unint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)&v41[8], v28);
    }
    else {
      unint64_t v29 = 0;
    }
    unint64_t v30 = &v29[16 * v25];
    unint64_t v31 = &v29[16 * v28];
    *(_OWORD *)unint64_t v30 = *a3;
    unint64_t v24 = v30 + 16;
    unint64_t v33 = *(long long **)buf;
    unint64_t v32 = *(long long **)v41;
    if (*(void *)v41 != *(void *)buf)
    {
      do
      {
        *((_OWORD *)v30 - 1) = *(v32 - 1);
        v30 -= 16;
        --v32;
      }
      while (v32 != v33);
      unint64_t v32 = *(long long **)buf;
    }
    *(void *)std::string buf = v30;
    *(void *)std::string::size_type v41 = v24;
    *(void *)&v41[8] = v31;
    if (v32) {
      operator delete(v32);
    }
  }
  else
  {
    **(_OWORD **)std::string::size_type v41 = *a3;
    unint64_t v24 = (_OWORD *)(v23 + 16);
  }
  *(void *)std::string::size_type v41 = v24;
  [*(id *)(*(void *)(a1 + 328) + 56) updateLoiIds:buf withLoiGroupId:&v46 andLoiType:a2];
  if (*(void *)buf)
  {
    *(void *)std::string::size_type v41 = *(void *)buf;
    operator delete(*(void **)buf);
  }
  return v46;
}

void sub_2563C6C64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::exception a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::exitCurrentLoi(uint64_t a1, uint64_t a2)
{
  CLMicroLocationLoiManager::resetLoiVariables((CLMicroLocationLoiManager *)a1);
  uint64_t v4 = *(void *)(a1 + 344);
  if (*(char *)(a1 + 407) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 384), *(void *)(a1 + 392));
  }
  else {
    std::string __p = *(std::string *)(a1 + 384);
  }
  (*(void (**)(uint64_t, std::string *, void, void, uint64_t))(*(void *)v4 + 16))(v4, &__p, *(void *)(a1 + 408), *(void *)(a1 + 416), a2);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2563C6DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationLoiManager::isValidGeofence(CLMicroLocationLoiManager *this, uuid a2)
{
  id v2 = *(id *)(*((void *)this + 41) + 104);
  id v3 = v2;
  if (!v2)
  {

    return v3 & 1;
  }
  [v2 getAllDistinctCustomLoiIds];

  if (v10 == v11)
  {
    LOBYTE(v3) = 0;
    if (!v10) {
      return v3 & 1;
    }
LABEL_15:
    operator delete(v10);
    return v3 & 1;
  }
  LOBYTE(v3) = 0;
  uint64_t v4 = v10;
  do
  {
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    v4 += 2;
    BOOL v8 = *(void *)a2.var0 == v5 && *(void *)&a2.var0[8] == v6;
    LOBYTE(v3) = v8 | v3;
  }
  while (v4 != v11);
  if (v10) {
    goto LABEL_15;
  }
  return v3 & 1;
}

void sub_2563C6EA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(CLMicroLocationLoiManager *this, NSString *a2, NSString *a3)
{
  v12[4] = *MEMORY[0x263EF8340];
  uint64_t v5 = a2;
  uint64_t v6 = a3;
  v11[0] = @"loiRelatedFailureOccurred";
  v11[1] = @"failureType";
  v12[0] = &unk_2704F1950;
  v12[1] = v5;
  v12[2] = v6;
  v11[2] = @"failureReason";
  v11[3] = @"fsmStateDuringFailure";
  uint64_t v7 = *((void *)this + 2);
  BOOL v8 = (void *)(v7 + 8);
  if (*(char *)(v7 + 31) < 0) {
    BOOL v8 = (void *)*v8;
  }
  uint64_t v9 = [NSString stringWithUTF8String:v8];
  v12[3] = v9;
  uint64_t v10 = [NSDictionary dictionaryWithObjects:v12 forKeys:v11 count:4];
  CLMicroLocationLoiManager::sendCoreAnalyticsEvent(v10, &cfstr_ComAppleMicrol_11.isa, (NSDictionary *)v10);
}

void sub_2563C6FD4(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

BOOL CLMicroLocationLoiManager::fetchPlaceInference(CLMicroLocationLoiManager *this)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  id v2 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (!*((unsigned char *)this + 500)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    CLMicroLocationProtobufHelper::convertChangedLoiReasonToMessage(*((_DWORD *)this + 124), __p);
    if (v11 >= 0) {
      id v3 = __p;
    }
    else {
      id v3 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 68289283;
    int v13 = 0;
    __int16 v14 = 2082;
    __int16 v15 = "";
    __int16 v16 = 2081;
    uuid v17 = v3;
    _os_log_impl(&dword_25631F000, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager, Attempting to fetch place inference\", \"Reason:\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v4 = *((void *)this + 42);
  if (v4)
  {
    [*((id *)this + 42) stopLeechingLocationUpdates];
    if ((*((_DWORD *)this + 124) & 0xFFFFFFFE) != 6 || *((unsigned char *)this + 500) == 0) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = 2;
    }
    [*((id *)this + 42) fetchPlaceInferenceAtCurrentLocationWithPolicy:v6];
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v7 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", buf, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    BOOL v8 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Warning LOI Bridge not setup.", "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", buf, 0x12u);
    }
  }
  return v4 != 0;
}

void sub_2563C729C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CLMicroLocationLoiManager::convertRTLocationOfInterestTypeToString@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  switch(a1)
  {
    case -1:
      id v3 = "other";
      goto LABEL_12;
    case 0:
      id v3 = "home";
      goto LABEL_12;
    case 1:
      id v3 = "work";
      goto LABEL_12;
    case 2:
      id v3 = "school";
      goto LABEL_12;
    case 3:
      id v3 = "gym";
LABEL_12:
      double result = std::string::basic_string[abi:ne180100]<0>(a2, v3);
      break;
    default:
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
      }
      uint64_t v4 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v6 = 0;
        _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "#Warning Please update this switch statement.", v6, 2u);
      }
      double result = std::string::basic_string[abi:ne180100]<0>(a2, "none");
      break;
  }
  return result;
}

BOOL CLMicroLocationLoiManager::fetchLoiIdsForLoi(CLMicroLocationLoiManager *this, NSUUID *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  id v3 = a2;
  uint64_t v4 = (void *)*((void *)this + 42);
  if (v4)
  {
    [v4 fetchRelatedLoisForLoi:v3];
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v7[0] = 68289026;
      v7[1] = 0;
      __int16 v8 = 2082;
      uint64_t v9 = "";
      _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#Warning LOI Bridge not setup.\"}", (uint8_t *)v7, 0x12u);
    }
  }

  return v4 != 0;
}

void sub_2563C7504(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CLMicroLocationLoiManager::convertPlaceInferenceUserPlaceTypeToString@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  switch(a1)
  {
    case 0:
      id v3 = "other";
      goto LABEL_12;
    case 1:
      id v3 = "home";
      goto LABEL_12;
    case 2:
      id v3 = "work";
      goto LABEL_12;
    case 3:
      id v3 = "school";
      goto LABEL_12;
    case 4:
      id v3 = "gym";
LABEL_12:
      double result = std::string::basic_string[abi:ne180100]<0>(a2, v3);
      break;
    default:
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
      }
      uint64_t v4 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v6 = 0;
        _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "#Warning Please update this switch statement.", v6, 2u);
      }
      double result = std::string::basic_string[abi:ne180100]<0>(a2, "none");
      break;
  }
  return result;
}

void CLMicroLocationLoiManager::startCustomLoiEntryTimer(id *this)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  [this[65] invalidate];
  id v2 = this[65];
  this[65] = 0;

  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  id v3 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 68289026;
    int v14 = 0;
    __int16 v15 = 2082;
    __int16 v16 = "";
    _os_log_impl(&dword_25631F000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager, startCustomLoiEntryTimer\"}", buf, 0x12u);
  }
  uint64_t v4 = +[ULDefaultsSingleton shared];
  uint64_t v5 = [v4 defaultsDictionary];

  uint64_t v6 = [NSString stringWithUTF8String:"ULCustomLoiEntryTimeout"];
  uint64_t v7 = [v5 objectForKey:v6];
  if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    [v7 doubleValue];
  }
  else {
    [&unk_2704F1980 doubleValue];
  }
  double v9 = v8;

  v12[0] = MEMORY[0x263EF8330];
  v12[1] = 3221225472;
  v12[2] = ___ZN25CLMicroLocationLoiManager24startCustomLoiEntryTimerEv_block_invoke;
  v12[3] = &__block_descriptor_40_e5_v8__0l;
  v12[4] = this;
  uint64_t v10 = +[ULTimerFactory timerOnPrimaryQueueWithInterval:0 repeats:v12 block:v9];
  id v11 = this[65];
  this[65] = (id)v10;
}

void sub_2563C7870(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::sendCustomLoiCreationEvent(CLMicroLocationLoiManager *this)
{
  v6[3] = *MEMORY[0x263EF8340];
  v6[0] = &unk_2704F1950;
  v5[0] = @"createdCustomLoi";
  v5[1] = @"geofenceLocationHorizontalAccuracy";
  id v2 = [NSNumber numberWithDouble:*((double *)this + 46)];
  v6[1] = v2;
  v5[2] = @"geofenceLocationVerticalAccuracy";
  id v3 = [NSNumber numberWithDouble:*((double *)this + 47)];
  v6[2] = v3;
  uint64_t v4 = [NSDictionary dictionaryWithObjects:v6 forKeys:v5 count:3];
  CLMicroLocationLoiManager::sendCoreAnalyticsEvent(v4, &cfstr_ComAppleMicrol_9.isa, (NSDictionary *)v4);
}

void sub_2563C79B0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::addLoiAndServiceMapping(CLMicroLocationLoiManager *this, uuid a2, const uuid *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uuid v17 = a2;
  memset(&v9, 0, sizeof(v9));
  if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)a3, &v9) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(void *)std::string buf = &unk_2704DAAD0;
    boost::throw_exception<boost::bad_lexical_cast>((uint64_t)buf);
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v5 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v17, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v10);
      v10.__vftable = (std::bad_cast_vtbl *)&unk_2704DAAD0;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v10);
    }
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    uint64_t v7 = &v9;
    if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)int v14 = 2082;
    *(void *)&v14[2] = "";
    *(_WORD *)&v14[10] = 2081;
    *(void *)&v14[12] = p_p;
    __int16 v15 = 2081;
    __int16 v16 = v7;
    _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, Adding LOI to Service ID mapping\", \"Location ID\":%{private, location:escape_only}s, \"Service ID\":%{private, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }

  [*(id *)(*((void *)this + 41) + 104) addServiceToCustomLoiMapping:a3 loiId:&v17];
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_2563C7C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::exception a22,uint64_t a23,uint64_t a24,std::exception a25)
{
  std::exception::~exception(&a22);
  if (a15 < 0) {
    operator delete(__p);
  }

  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::enterLoi(uint64_t a1, uint64_t a2, uint64_t a3, std::string *__str, uint64_t a5)
{
  *(void *)(a1 + 408) = a2;
  *(void *)(a1 + 416) = a3;
  uint64_t v7 = (std::string *)(a1 + 384);
  std::string::operator=((std::string *)(a1 + 384), __str);
  uint64_t v8 = *(void *)(a1 + 344);
  if (*(char *)(a1 + 407) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 384), *(void *)(a1 + 392));
  }
  else {
    std::string __p = *v7;
  }
  (*(void (**)(uint64_t, std::string *, void, void, uint64_t))(*(void *)v8 + 16))(v8, &__p, *(void *)(a1 + 408), *(void *)(a1 + 416), a5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2563C7D24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLoiManager::sendCustomLoiVisitEvent(CLMicroLocationLoiManager *this, NSString *a2, NSString *a3)
{
  v8[3] = *MEMORY[0x263EF8340];
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  v7[0] = @"customLoiVisitOccurred";
  v7[1] = @"loiType";
  v8[0] = &unk_2704F1950;
  v8[1] = v4;
  _DWORD v7[2] = @"visitEventType";
  v8[2] = v5;
  uint64_t v6 = [NSDictionary dictionaryWithObjects:v8 forKeys:v7 count:3];
  CLMicroLocationLoiManager::sendCoreAnalyticsEvent(v6, &cfstr_ComAppleMicrol_10.isa, (NSDictionary *)v6);
}

void sub_2563C7E18(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::updateDbCustomLoiWasLastSeenNow(CLMicroLocationLoiManager *this, uuid a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uuid v15 = a2;
  uint64_t v12 = 0;
  int v13 = 0;
  int v14 = 0;
  id v3 = (uuid *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)&v14, 1uLL);
  uint64_t v5 = &v3[v4];
  uuid *v3 = v15;
  uint64_t v6 = v3 + 1;
  uint64_t v8 = (uuid *)v12;
  uint64_t v7 = v13;
  if (v13 != v12)
  {
    do
    {
      v3[-1] = v7[-1];
      --v3;
      --v7;
    }
    while (v7 != v8);
    uint64_t v7 = (uuid *)v12;
  }
  uint64_t v12 = v3;
  int v13 = v6;
  int v14 = v5;
  if (v7) {
    operator delete(v7);
  }
  int v13 = v6;
  id v9 = *(id *)(*((void *)this + 41) + 56);
  std::string::basic_string[abi:ne180100]<0>(__p, "custom");
  [v9 updateLoiIds:&v12 withLoiGroupId:&v15 andLoiType:__p];
  if (v11 < 0) {
    operator delete(__p[0]);
  }

  if (v12)
  {
    int v13 = (uuid *)v12;
    operator delete(v12);
  }
}

void sub_2563C7F60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

void ___ZN25CLMicroLocationLoiManager15setupStartTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  [*(id *)(v1 + 512) invalidate];
  id v2 = *(void **)(v1 + 512);
  *(void *)(v1 + 512) = 0;

  if ((*(unsigned int (**)(void))(**(void **)(v1 + 328) + 16))(*(void *)(v1 + 328)))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    id v3 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_25631F000, v3, OS_LOG_TYPE_DEFAULT, "#LOI Manager -- Fetching Place inference on Start up", buf, 2u);
    }
    CLMicroLocationLoiManager::fetchPlaceInferenceForReason(v1, 7);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "#LOI Manager -- Skipping place inference on Start up - database not available", v5, 2u);
    }
  }
}

void CLMicroLocationLoiManager::sendCoreAnalyticsEvent(CLMicroLocationLoiManager *this, NSString *a2, NSDictionary *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  uint64_t v6 = +[ULDefaultsSingleton shared];
  uint64_t v7 = [v6 defaultsDictionary];

  uint64_t v8 = [NSString stringWithUTF8String:"ULAnalyticsSendEventEnabled"];
  id v9 = [v7 objectForKey:v8];
  if (v9 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    int v10 = [v9 BOOLValue];
  }
  else {
    int v10 = [MEMORY[0x263EFFA88] BOOLValue];
  }
  int v11 = v10;

  if (v11)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v12 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v14[0] = 68289539;
      v14[1] = 0;
      __int16 v15 = 2082;
      uint64_t v16 = "";
      __int16 v17 = 2081;
      uint64_t v18 = [(NSString *)v4 UTF8String];
      __int16 v19 = 2113;
      uint64_t v20 = v5;
      _os_log_impl(&dword_25631F000, v12, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LOI Manager, sending core analytics\", \"event\":%{private, location:escape_only}s, \"eventFields\":%{private, location:escape_only}@}", (uint8_t *)v14, 0x26u);
    }

    AnalyticsSendEvent();
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    int v13 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14[0]) = 0;
      _os_log_impl(&dword_25631F000, v13, OS_LOG_TYPE_DEFAULT, "#LOI Manager, CoreAnalytics Disabled", (uint8_t *)v14, 2u);
    }
  }
}

void sub_2563C8320(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::handleVisitNotification(CLMicroLocationLoiManager *this, CLVisit *a2)
{
  id v3 = a2;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7[0]) = 0;
    _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "LOI Manager, handleVisitNotification", (uint8_t *)v7, 2u);
  }
  if ([(CLVisit *)v3 hasDepartureDate])
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_DEFAULT, "LOI Manager, Received visit exit", (uint8_t *)v7, 2u);
    }
    CLMiLoLoiManagerLoiVisitExitEvent::CLMiLoLoiManagerLoiVisitExitEvent((CLMiLoLoiManagerLoiVisitExitEvent *)v7, v3);
    CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)v7);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "LOI Manager, Received visit entry", (uint8_t *)v7, 2u);
    }
    CLMiLoLoiManagerLoiVisitEntryEvent::CLMiLoLoiManagerLoiVisitEntryEvent((CLMiLoLoiManagerLoiVisitEntryEvent *)v7, v3);
    CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)v7);
  }

  v7[0] = &unk_2704DC488;
  if (v8 < 0) {
    operator delete((void *)v7[1]);
  }
}

void sub_2563C8558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  CLMiLoLoiManagerLoiVisitEntryEvent::~CLMiLoLoiManagerLoiVisitEntryEvent(&a9);

  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerLoiVisitExitEvent::~CLMiLoLoiManagerLoiVisitExitEvent(id *this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMiLoLoiManagerLoiVisitEntryEvent::~CLMiLoLoiManagerLoiVisitEntryEvent(id *this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::handleFetchedPlaceInferences(uint64_t a1, void *a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v8 = [v6 description];
      uint64_t v17 = 68289283;
      *(_WORD *)std::string __p = 2082;
      *(void *)&__p[2] = "";
      __int16 v19 = 2081;
      uint64_t v20 = [v8 UTF8String];
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Bridge, Failed To fetch place inferences\", \"Error:\":%{private, location:escape_only}s}", (uint8_t *)&v17, 0x1Cu);
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    id v9 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v9))
    {
      id v10 = [v6 description];
      uint64_t v11 = [v10 UTF8String];
      uint64_t v17 = 68289283;
      *(_WORD *)std::string __p = 2082;
      *(void *)&__p[2] = "";
      __int16 v19 = 2081;
      uint64_t v20 = v11;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Bridge, Failed To fetch place inferences", "{\"msg%{public}.0s\":\"LOI Bridge, Failed To fetch place inferences\", \"Error:\":%{private, location:escape_only}s}", (uint8_t *)&v17, 0x1Cu);
    }
  }
  if ([v5 count])
  {
    uint64_t v12 = [v5 objectAtIndexedSubscript:0];
    int v13 = [v12 _loiIdentifier];
    BOOL v14 = v13 == 0;

    if (!v14)
    {
      CLMiLoLoiManagerFetchedPlaceInference::CLMiLoLoiManagerFetchedPlaceInference((uint64_t)&v17, v12);
      CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationStateMachine::StateMachineBase *)(a1 + 8), (CLMicroLocationStateMachine::EventBase *)&v17);
      CLMiLoLoiManagerFetchedPlaceInference::~CLMiLoLoiManagerFetchedPlaceInference((id *)&v17);
      goto LABEL_25;
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v16 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v17) = 0;
      _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_ERROR, "LOI Bridge, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update", (uint8_t *)&v17, 2u);
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    __int16 v15 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl(&dword_25631F000, v15, OS_LOG_TYPE_DEFAULT, "LOI Bridge, received no place inferences, we will start leeching and wait for next location update", (uint8_t *)&v17, 2u);
    }
    uint64_t v12 = 0;
  }
  CLMiLoLoiManagerFailedToFetchPlaceInference::CLMiLoLoiManagerFailedToFetchPlaceInference((CLMiLoLoiManagerFailedToFetchPlaceInference *)&v17);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationStateMachine::StateMachineBase *)(a1 + 8), (CLMicroLocationStateMachine::EventBase *)&v17);
  uint64_t v17 = (uint64_t)&unk_2704DC488;
  if (v21 < 0) {
    operator delete(*(void **)__p);
  }
LABEL_25:
}

void sub_2563C89CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerFailedToFetchPlaceInference::~CLMiLoLoiManagerFailedToFetchPlaceInference(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMiLoLoiManagerFailedToFetchLoiForLocationEvent::~CLMiLoLoiManagerFailedToFetchLoiForLocationEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMiLoLoiManagerReceivedLoiForLocationEvent::~CLMiLoLoiManagerReceivedLoiForLocationEvent(id *this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::handleRelatedLoisForLoi(CLMicroLocationLoiManager *this, NSArray *a2, NSError *a3)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2;
  unint64_t v31 = v4;
  unint64_t v32 = a3;
  if (v32)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    id v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string::size_type v41 = 2082;
      *(void *)&v41[2] = "";
      __int16 v42 = 2113;
      int v43 = v32;
      _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#Warning LOI Manager, Error retrieving related LOIs for Loi\", \"error\":%{private, location:escape_only}@}", buf, 0x1Cu);
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    id v6 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)std::string buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string::size_type v41 = 2082;
      *(void *)&v41[2] = "";
      __int16 v42 = 2113;
      int v43 = v32;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Warning LOI Manager, Error retrieving related LOIs for Loi", "{\"msg%{public}.0s\":\"#Warning LOI Manager, Error retrieving related LOIs for Loi\", \"error\":%{private, location:escape_only}@}", buf, 0x1Cu);
    }
    CLMiLoLoiManagerFailedToFetchRelatedLois::CLMiLoLoiManagerFailedToFetchRelatedLois((CLMiLoLoiManagerFailedToFetchRelatedLois *)buf);
    CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)buf);
    *(void *)std::string buf = &unk_2704DC488;
    if (v44 < 0)
    {
      uint64_t v7 = *(void **)v41;
LABEL_37:
      operator delete(v7);
    }
  }
  else
  {
    std::string __p = 0;
    uint64_t v38 = 0;
    unint64_t v39 = 0;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    id v8 = v4;
    uint64_t v9 = [(NSArray *)v8 countByEnumeratingWithState:&v33 objects:v46 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v34;
      do
      {
        for (uint64_t i = 0; i != v9; ++i)
        {
          if (*(void *)v34 != v10) {
            objc_enumerationMutation(v8);
          }
          id v12 = [*(id *)(*((void *)&v33 + 1) + 8 * i) UUIDString];
          int v13 = (char *)[v12 UTF8String];
          size_t v14 = strlen(v13);
          uint64_t v15 = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)buf, (unsigned __int8 *)v13, (unsigned __int8 *)&v13[v14]);
          uint64_t v17 = v15;
          uint64_t v18 = v16;
          __int16 v19 = v38;
          if ((unint64_t)v38 >= v39)
          {
            uint64_t v21 = ((char *)v38 - (unsigned char *)__p) >> 4;
            unint64_t v22 = v21 + 1;
            if ((unint64_t)(v21 + 1) >> 60) {
              std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v23 = v39 - (void)__p;
            if ((uint64_t)(v39 - (void)__p) >> 3 > v22) {
              unint64_t v22 = v23 >> 3;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v22;
            }
            if (v24) {
              uint64_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)&v39, v24);
            }
            else {
              uint64_t v25 = 0;
            }
            unint64_t v26 = (uint64_t *)&v25[16 * v21];
            *unint64_t v26 = v17;
            v26[1] = v18;
            unint64_t v28 = __p;
            uint64_t v27 = v38;
            unint64_t v29 = (char *)v26;
            if (v38 != __p)
            {
              do
              {
                *((_OWORD *)v29 - 1) = *((_OWORD *)v27 - 1);
                v29 -= 16;
                v27 -= 2;
              }
              while (v27 != v28);
              uint64_t v27 = __p;
            }
            uint64_t v20 = v26 + 2;
            std::string __p = v29;
            uint64_t v38 = v26 + 2;
            unint64_t v39 = (unint64_t)&v25[16 * v24];
            if (v27) {
              operator delete(v27);
            }
          }
          else
          {
            uint64_t *v38 = v15;
            v19[1] = v16;
            uint64_t v20 = v19 + 2;
          }
          uint64_t v38 = v20;
        }
        uint64_t v9 = [(NSArray *)v8 countByEnumeratingWithState:&v33 objects:v46 count:16];
      }
      while (v9);
    }

    *(void *)std::string buf = &unk_2704DC488;
    std::string::basic_string[abi:ne180100]<0>(v41, "No Name Given");
    *(void *)std::string buf = &unk_2704DD3F0;
    memset(v45, 0, 24);
    std::vector<boost::uuids::uuid>::__assign_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>((char *)v45, (char *)__p, (uint64_t)v38, ((char *)v38 - (unsigned char *)__p) >> 4);
    MEMORY[0x25A2A6080](v41, "Got Related LOIs");
    CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)buf);
    CLMiLoLoiManagerReceivedRelatedLoisEvent::~CLMiLoLoiManagerReceivedRelatedLoisEvent((CLMiLoLoiManagerReceivedRelatedLoisEvent *)buf);
    uint64_t v7 = __p;
    if (__p)
    {
      uint64_t v38 = (uint64_t *)__p;
      goto LABEL_37;
    }
  }
}

void sub_2563C8FC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerFailedToFetchRelatedLois::~CLMiLoLoiManagerFailedToFetchRelatedLois(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMiLoLoiManagerFailedToGetLocationUpdateEvent::~CLMiLoLoiManagerFailedToGetLocationUpdateEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::didCompleteSettingGeofenceAtLocation(CLMicroLocationLoiManager *this, CLLocation *a2, uuid a3, NSError *a4)
{
  uint64_t v4 = *(void *)&a3.var0[8];
  uint64_t v5 = *(void *)a3.var0;
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v7 = a4;
  if (v7)
  {
    CLMiLoLoiManagerFailedToSetGeofenceEvent::CLMiLoLoiManagerFailedToSetGeofenceEvent((CLMiLoLoiManagerFailedToSetGeofenceEvent *)&v11);
    CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)&v11);
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    id v8 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289282;
      int v17 = 0;
      __int16 v18 = 2082;
      __int16 v19 = "";
      __int16 v20 = 2114;
      uint64_t v21 = v7;
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v9 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)std::string buf = 68289282;
      int v17 = 0;
      __int16 v18 = 2082;
      __int16 v19 = "";
      __int16 v20 = 2114;
      uint64_t v21 = v7;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to set geofence at current location to enable MiLo", "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo\", \"Error\":%{public, location:escape_only}@}", buf, 0x1Cu);
    }
    uint64_t v11 = &unk_2704DC488;
  }
  else
  {
    uint64_t v11 = &unk_2704DC488;
    uint64_t v10 = std::string::basic_string[abi:ne180100]<0>(&__p, "No Name Given");
    uint64_t v11 = &unk_2704DD490;
    uint64_t v14 = v5;
    uint64_t v15 = v4;
    MEMORY[0x25A2A6080](v10, "Started Process of Activaing Geofence");
    CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationLoiManager *)((char *)this + 8), (CLMicroLocationStateMachine::EventBase *)&v11);
    uint64_t v11 = &unk_2704DC488;
  }
  if (v13 < 0) {
    operator delete(__p);
  }
}

void sub_2563C93A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerFailedToSetGeofenceEvent::~CLMiLoLoiManagerFailedToSetGeofenceEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMiLoLoiManagerStartedActivatingGeofenceEvent::~CLMiLoLoiManagerStartedActivatingGeofenceEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::handleGeofenceUpdate(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  id v5 = a2;
  id v6 = (char *)[v5 UTF8String];
  size_t v7 = strlen(v6);
  uint64_t v8 = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v14, (unsigned __int8 *)v6, (unsigned __int8 *)&v6[v7]);
  uint64_t v10 = v9;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
  }
  uint64_t v11 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = [v5 UTF8String];
    uint64_t v14 = 68289539;
    *(_WORD *)std::string __p = 2082;
    *(void *)&__p[2] = "";
    __int16 v16 = 2081;
    uint64_t v17 = v12;
    __int16 v18 = 1025;
    *(_DWORD *)__int16 v19 = a3;
    _os_log_impl(&dword_25631F000, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager, Got Geofence update\", \"Geofence Id\":%{private, location:escape_only}s, \"State\":%{private}d}", (uint8_t *)&v14, 0x22u);
  }

  uint64_t v14 = (uint64_t)&unk_2704DC488;
  char v13 = std::string::basic_string[abi:ne180100]<0>(__p, "No Name Given");
  if (a3 == 1)
  {
    uint64_t v14 = (uint64_t)&unk_2704DD4B0;
    *(void *)&v19[2] = v8;
    uint64_t v20 = v10;
    MEMORY[0x25A2A6080](v13, "Geofence Entry");
  }
  else
  {
    uint64_t v14 = (uint64_t)&unk_2704DD4D0;
    *(void *)&v19[2] = v8;
    uint64_t v20 = v10;
    MEMORY[0x25A2A6080](v13, "Geofence Exit");
  }
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationStateMachine::StateMachineBase *)(a1 + 8), (CLMicroLocationStateMachine::EventBase *)&v14);
  uint64_t v14 = (uint64_t)&unk_2704DC488;
  if ((v19[1] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
}

void sub_2563C96E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerGeofenceEntryEvent::~CLMiLoLoiManagerGeofenceEntryEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMiLoLoiManagerGeofenceExitEvent::~CLMiLoLoiManagerGeofenceExitEvent(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationLoiManager::didRemoveGeofenceWithId(CLMicroLocationLoiManager *this, NSString *a2, NSError *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2;
  id v5 = a3;
  if (v5)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    id v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      int v9 = 68289539;
      int v10 = 0;
      __int16 v11 = 2082;
      uint64_t v12 = "";
      __int16 v13 = 2113;
      uint64_t v14 = v4;
      __int16 v15 = 2113;
      __int16 v16 = v5;
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, Failed to RemoveGeofence\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v9, 0x26u);
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    size_t v7 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      int v9 = 68289539;
      int v10 = 0;
      __int16 v11 = 2082;
      uint64_t v12 = "";
      __int16 v13 = 2113;
      uint64_t v14 = v4;
      __int16 v15 = 2113;
      __int16 v16 = v5;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, Failed to RemoveGeofence", "{\"msg%{public}.0s\":\"#LOI Manager, Failed to RemoveGeofence\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v9, 0x26u);
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_49);
    }
    uint64_t v8 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 68289539;
      int v10 = 0;
      __int16 v11 = 2082;
      uint64_t v12 = "";
      __int16 v13 = 2113;
      uint64_t v14 = v4;
      __int16 v15 = 2113;
      __int16 v16 = 0;
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, didRemoveGeofenceWithId\", \"regionId\":%{private, location:escape_only}@, \"error\":%{private, location:escape_only}@}", (uint8_t *)&v9, 0x26u);
    }
  }
}

void ___ZN25CLMicroLocationLoiManager24startCustomLoiEntryTimerEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  [*(id *)(v1 + 520) invalidate];
  id v2 = *(void **)(v1 + 520);
  *(void *)(v1 + 520) = 0;

  CLMiLoLoiManagerEnteringCustomLoiTimeout::CLMiLoLoiManagerEnteringCustomLoiTimeout((CLMiLoLoiManagerEnteringCustomLoiTimeout *)v3);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationStateMachine::StateMachineBase *)(v1 + 8), (CLMicroLocationStateMachine::EventBase *)v3);
  v3[0] = &unk_2704DC488;
  if (v4 < 0) {
    operator delete((void *)v3[1]);
  }
}

void sub_2563C9AAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerEnteringCustomLoiTimeout::~CLMiLoLoiManagerEnteringCustomLoiTimeout(void **this)
{
  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x25A2A6340);
}

void *CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerLoiVisitEntryEvent,&CLMicroLocationLoiManager::VisitEntry>::stateFunction@<X0>(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (a2) {
    id v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    id v5 = 0;
  }
  if (lpsrc
  {
    return CLMicroLocationLoiManager::VisitEntry(v5, v6, a3);
  }
  else
  {
    unint64_t v29 = lpsrc;
    uint64_t v8 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v9 = *((void *)v5 + 2);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v9 + 8), *(void *)(v9 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 8);
        v31.__r_.__value_.__r.__words[2] = *(void *)(v9 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v10;
      }
      int v11 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      std::string::size_type v12 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      __int16 v13 = &v31;
      if (v11 < 0) {
        __int16 v13 = (std::string *)v12;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v33 = 0;
      __int16 v34 = 2082;
      long long v35 = "";
      __int16 v36 = 2081;
      v37 = v13;
      __int16 v38 = 2081;
      unint64_t v39 = p_p;
      __int16 v40 = 2082;
      std::string::size_type v41 = "assert";
      __int16 v42 = 2081;
      int v43 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
    }

    __int16 v15 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v15))
    {
      uint64_t v16 = *((void *)v5 + 2);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        v31.__r_.__value_.__r.__words[2] = *(void *)(v16 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
      }
      int v18 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      std::string::size_type v19 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      uint64_t v20 = &v31;
      if (v18 < 0) {
        uint64_t v20 = (std::string *)v19;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v21 = &__p;
      }
      else {
        uint64_t v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v33 = 0;
      __int16 v34 = 2082;
      long long v35 = "";
      __int16 v36 = 2081;
      v37 = v20;
      __int16 v38 = 2081;
      unint64_t v39 = v21;
      __int16 v40 = 2082;
      std::string::size_type v41 = "assert";
      __int16 v42 = 2081;
      int v43 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v22 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      uint64_t v23 = *((void *)v5 + 2);
      if (*(char *)(v23 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v23 + 8), *(void *)(v23 + 16));
      }
      else
      {
        long long v24 = *(_OWORD *)(v23 + 8);
        v31.__r_.__value_.__r.__words[2] = *(void *)(v23 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v24;
      }
      int v25 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      std::string::size_type v26 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v29, &__p);
      uint64_t v27 = &v31;
      if (v25 < 0) {
        uint64_t v27 = (std::string *)v26;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v28 = &__p;
      }
      else {
        unint64_t v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v33 = 0;
      __int16 v34 = 2082;
      long long v35 = "";
      __int16 v36 = 2081;
      v37 = v27;
      __int16 v38 = 2081;
      unint64_t v39 = v28;
      __int16 v40 = 2082;
      std::string::size_type v41 = "assert";
      __int16 v42 = 2081;
      int v43 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
    }

    double result = (void *)abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_2563C9F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerLoiVisitEntryEvent,&CLMicroLocationLoiManager::VisitEntry>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoi>::stateFunction@<X0>(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = a2 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    uint64_t result = (uint64_t)CLMicroLocationLoiManager::handleEnableCustomLoi((id *)v5, v6[2], buf);
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = *(void *)&buf[16];
    *(unsigned char *)(a3 + 24) = 1;
  }
  else
  {
    uint64_t v8 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v9 = *(void *)(v5 + 16);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v9 + 8), *(void *)(v9 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v9 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v10;
      }
      int v11 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v12 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      __int16 v13 = &v30;
      if (v11 < 0) {
        __int16 v13 = (std::string *)v12;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v32 = 2081;
      int v33 = p_p;
      __int16 v34 = 2082;
      long long v35 = "assert";
      __int16 v36 = 2081;
      v37 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    __int16 v15 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v15))
    {
      uint64_t v16 = *(void *)(v5 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v16 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v17;
      }
      int v18 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v19 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      uint64_t v20 = &v30;
      if (v18 < 0) {
        uint64_t v20 = (std::string *)v19;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v21 = &__p;
      }
      else {
        uint64_t v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v32 = 2081;
      int v33 = v21;
      __int16 v34 = 2082;
      long long v35 = "assert";
      __int16 v36 = 2081;
      v37 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v22 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      uint64_t v23 = *(void *)(v5 + 16);
      if (*(char *)(v23 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v23 + 8), *(void *)(v23 + 16));
      }
      else
      {
        long long v24 = *(_OWORD *)(v23 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v23 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v24;
      }
      int v25 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v26 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      uint64_t v27 = &v30;
      if (v25 < 0) {
        uint64_t v27 = (std::string *)v26;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v28 = &__p;
      }
      else {
        unint64_t v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v27;
      __int16 v32 = 2081;
      int v33 = v28;
      __int16 v34 = 2082;
      long long v35 = "assert";
      __int16 v36 = 2081;
      v37 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_2563CA484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoi>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerDisableCustomLoiEvent,&CLMicroLocationLoiManager::DisableCustomLoi>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = a2 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::handleDisableCustomLoi((id *)v5, v6[2], v6[3], (std::string *)buf);
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = *(void *)&buf[16];
    *(unsigned char *)(a3 + 24) = 1;
  }
  else
  {
    unint64_t v28 = lpsrc;
    size_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *(void *)(v5 + 16);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v12;
      __int16 v32 = 2081;
      int v33 = p_p;
      __int16 v34 = 2082;
      long long v35 = "assert";
      __int16 v36 = 2081;
      v37 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *(void *)(v5 + 16);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v19;
      __int16 v32 = 2081;
      int v33 = v20;
      __int16 v34 = 2082;
      long long v35 = "assert";
      __int16 v36 = 2081;
      v37 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *(void *)(v5 + 16);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v26;
      __int16 v32 = 2081;
      int v33 = v27;
      __int16 v34 = 2082;
      long long v35 = "assert";
      __int16 v36 = 2081;
      v37 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CA970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerDisableCustomLoiEvent,&CLMicroLocationLoiManager::DisableCustomLoi>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiVisitEntry>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::CustomLoiVisitEntry(v5, v6, a3);
  }
  else
  {
    unint64_t v28 = lpsrc;
    size_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CAE4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiVisitEntry>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerLeechedLocationEvent,&CLMicroLocationLoiManager::HandleLeechedLocation>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerRefreshLocationOnEvent,&CLMicroLocationLoiManager::RefreshLocationOnInterval>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::RefreshLocationOnInterval(v5, a3);
  }
  else
  {
    id v6 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      uint64_t v7 = *((void *)v5 + 2);
      if (*(char *)(v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(v7 + 8), *(void *)(v7 + 16));
      }
      else
      {
        long long v8 = *(_OWORD *)(v7 + 8);
        v28.__r_.__value_.__r.__words[2] = *(void *)(v7 + 24);
        *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v8;
      }
      int v9 = SHIBYTE(v28.__r_.__value_.__r.__words[2]);
      std::string::size_type v10 = v28.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v11 = &v28;
      if (v9 < 0) {
        std::string::size_type v11 = (std::string *)v10;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v30 = 0;
      __int16 v31 = 2082;
      int v32 = "";
      __int16 v33 = 2081;
      __int16 v34 = v11;
      __int16 v35 = 2081;
      __int16 v36 = p_p;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }

    __int16 v13 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v13))
    {
      uint64_t v14 = *((void *)v5 + 2);
      if (*(char *)(v14 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(v14 + 8), *(void *)(v14 + 16));
      }
      else
      {
        long long v15 = *(_OWORD *)(v14 + 8);
        v28.__r_.__value_.__r.__words[2] = *(void *)(v14 + 24);
        *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v15;
      }
      int v16 = SHIBYTE(v28.__r_.__value_.__r.__words[2]);
      std::string::size_type v17 = v28.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v18 = &v28;
      if (v16 < 0) {
        std::string::size_type v18 = (std::string *)v17;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v19 = &__p;
      }
      else {
        std::string::size_type v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v30 = 0;
      __int16 v31 = 2082;
      int v32 = "";
      __int16 v33 = 2081;
      __int16 v34 = v18;
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v20 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = *((void *)v5 + 2);
      if (*(char *)(v21 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(v21 + 8), *(void *)(v21 + 16));
      }
      else
      {
        long long v22 = *(_OWORD *)(v21 + 8);
        v28.__r_.__value_.__r.__words[2] = *(void *)(v21 + 24);
        *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v22;
      }
      int v23 = SHIBYTE(v28.__r_.__value_.__r.__words[2]);
      std::string::size_type v24 = v28.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v25 = &v28;
      if (v23 < 0) {
        std::string::size_type v25 = (std::string *)v24;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v26 = &__p;
      }
      else {
        std::string::size_type v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v30 = 0;
      __int16 v31 = 2082;
      int v32 = "";
      __int16 v33 = 2081;
      __int16 v34 = v25;
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v20, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CB35C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerRefreshLocationOnEvent,&CLMicroLocationLoiManager::RefreshLocationOnInterval>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFetchPlaceInferenceForReason,&CLMicroLocationLoiManager::FetchPlaceInference>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::FetchPlaceInference(v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CB838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFetchPlaceInferenceForReason,&CLMicroLocationLoiManager::FetchPlaceInference>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerLoiVisitExitEvent,&CLMicroLocationLoiManager::VisitExit>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::VisitExit(v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CBD14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerLoiVisitExitEvent,&CLMicroLocationLoiManager::VisitExit>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = a2 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi((id *)v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *(void *)(v5 + 16);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *(void *)(v5 + 16);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *(void *)(v5 + 16);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CC1F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInHomeLoi>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInHomeLoi(v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CC6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInHomeLoi>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFetchPlaceInferenceForReason,&CLMicroLocationLoiManager::FetchPlaceInferenceWhileInHomeLoi>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::FetchPlaceInferenceWhileInHomeLoi(v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CCBA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFetchPlaceInferenceForReason,&CLMicroLocationLoiManager::FetchPlaceInferenceWhileInHomeLoi>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceExitEvent,&CLMicroLocationLoiManager::CustomLoiVisitExit>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::CustomLoiVisitExit(v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CD084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceExitEvent,&CLMicroLocationLoiManager::CustomLoiVisitExit>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInCustomLoi>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInCustomLoi(v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CD560(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInCustomLoi>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoiWhileInCustomLoi>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::EnableCustomLoiWhileInCustomLoi(v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CDA3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoiWhileInCustomLoi>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerDisableCustomLoiEvent,&CLMicroLocationLoiManager::CustomLoiDisableWhileInCustomLoi>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = a2 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::CustomLoiDisableWhileInCustomLoi((id *)v5, v6, a3);
  }
  else
  {
    std::string v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *(void *)(v5 + 16);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *(void *)(v5 + 16);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &__p;
      }
      else {
        uint64_t v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *(void *)(v5 + 16);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      __int16 v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CDF18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerDisableCustomLoiEvent,&CLMicroLocationLoiManager::CustomLoiDisableWhileInCustomLoi>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMicroLocationLoiManager,&CLMicroLocationLoiManager::entryFunctionEnteringHomeLoiState>::~EventHandlerWrapperWithNoData(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoiDuringLoiEntry>::stateFunction@<X0>(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    uint64_t v7 = v6[4];
    uint64_t v8 = v6[5];
    CLMicroLocationLoiManager::resetLoiVariables(v5);
    *(void *)v42.var0 = v7;
    *(void *)&v42.var0[8] = v8;
    uint64_t result = (uint64_t)CLMicroLocationLoiManager::handleEnableCustomLoi((id *)v5, v42, buf);
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = *(void *)&buf[16];
    *(unsigned char *)(a3 + 24) = 1;
  }
  else
  {
    __int16 v31 = lpsrc;
    int v10 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
    {
      uint64_t v11 = *((void *)v5 + 2);
      if (*(char *)(v11 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v33, *(const std::string::value_type **)(v11 + 8), *(void *)(v11 + 16));
      }
      else
      {
        long long v12 = *(_OWORD *)(v11 + 8);
        v33.__r_.__value_.__r.__words[2] = *(void *)(v11 + 24);
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v12;
      }
      int v13 = SHIBYTE(v33.__r_.__value_.__r.__words[2]);
      std::string::size_type v14 = v33.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      uint64_t v15 = &v33;
      if (v13 < 0) {
        uint64_t v15 = (std::string *)v14;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v15;
      __int16 v35 = 2081;
      __int16 v36 = p_p;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v33.__r_.__value_.__l.__data_);
      }
    }

    int v17 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v17))
    {
      uint64_t v18 = *((void *)v5 + 2);
      if (*(char *)(v18 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v33, *(const std::string::value_type **)(v18 + 8), *(void *)(v18 + 16));
      }
      else
      {
        long long v19 = *(_OWORD *)(v18 + 8);
        v33.__r_.__value_.__r.__words[2] = *(void *)(v18 + 24);
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v19;
      }
      int v20 = SHIBYTE(v33.__r_.__value_.__r.__words[2]);
      std::string::size_type v21 = v33.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      uint64_t v22 = &v33;
      if (v20 < 0) {
        uint64_t v22 = (std::string *)v21;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v23 = &__p;
      }
      else {
        long long v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v22;
      __int16 v35 = 2081;
      __int16 v36 = v23;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v17, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v33.__r_.__value_.__l.__data_);
      }
    }

    int v24 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      uint64_t v25 = *((void *)v5 + 2);
      if (*(char *)(v25 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v33, *(const std::string::value_type **)(v25 + 8), *(void *)(v25 + 16));
      }
      else
      {
        long long v26 = *(_OWORD *)(v25 + 8);
        v33.__r_.__value_.__r.__words[2] = *(void *)(v25 + 24);
        *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v26;
      }
      int v27 = SHIBYTE(v33.__r_.__value_.__r.__words[2]);
      std::string::size_type v28 = v33.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v31, &__p);
      unint64_t v29 = &v33;
      if (v27 < 0) {
        unint64_t v29 = (std::string *)v28;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v30 = &__p;
      }
      else {
        std::string v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v29;
      __int16 v35 = 2081;
      __int16 v36 = v30;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v24, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v33.__r_.__value_.__l.__data_);
      }
    }

    uint64_t result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_2563CE448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoiDuringLoiEntry>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiEntryDuringLoiEntry>::stateFunction@<X0>(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    uint64_t result = (uint64_t)CLMicroLocationLoiManager::handleCustomLoiVisitEntry(v5, v6[2], buf);
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = *(void *)&buf[16];
    *(unsigned char *)(a3 + 24) = 1;
  }
  else
  {
    uint64_t v8 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v9 = *((void *)v5 + 2);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v9 + 8), *(void *)(v9 + 16));
      }
      else
      {
        long long v10 = *(_OWORD *)(v9 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v9 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v10;
      }
      int v11 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v12 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      int v13 = &v30;
      if (v11 < 0) {
        int v13 = (std::string *)v12;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v32 = 2081;
      std::string v33 = p_p;
      __int16 v34 = 2082;
      __int16 v35 = "assert";
      __int16 v36 = 2081;
      __int16 v37 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v15 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v15))
    {
      uint64_t v16 = *((void *)v5 + 2);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v16 + 8), *(void *)(v16 + 16));
      }
      else
      {
        long long v17 = *(_OWORD *)(v16 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v16 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v17;
      }
      int v18 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v19 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      int v20 = &v30;
      if (v18 < 0) {
        int v20 = (std::string *)v19;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v21 = &__p;
      }
      else {
        std::string::size_type v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v32 = 2081;
      std::string v33 = v21;
      __int16 v34 = 2082;
      __int16 v35 = "assert";
      __int16 v36 = 2081;
      __int16 v37 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v22 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      uint64_t v23 = *((void *)v5 + 2);
      if (*(char *)(v23 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v23 + 8), *(void *)(v23 + 16));
      }
      else
      {
        long long v24 = *(_OWORD *)(v23 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v23 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v24;
      }
      int v25 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v26 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      int v27 = &v30;
      if (v25 < 0) {
        int v27 = (std::string *)v26;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v28 = &__p;
      }
      else {
        std::string::size_type v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(void *)&buf[20] = v27;
      __int16 v32 = 2081;
      std::string v33 = v28;
      __int16 v34 = 2082;
      __int16 v35 = "assert";
      __int16 v36 = 2081;
      __int16 v37 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    uint64_t result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_2563CE930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiEntryDuringLoiEntry>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerReceivedLoiForLocationEvent,&CLMicroLocationLoiManager::LoiForGivenLocation>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToFetchLoiForLocationEvent,&CLMicroLocationLoiManager::LoiFetchFailure>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::LoiFetchFailure(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CEE44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToFetchLoiForLocationEvent,&CLMicroLocationLoiManager::LoiFetchFailure>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFetchedPlaceInference,&CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (std::string *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      std::string::size_type v8 = v5->__r_.__value_.__r.__words[2];
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      std::string::size_type v15 = v5->__r_.__value_.__r.__words[2];
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      std::string::size_type v22 = v5->__r_.__value_.__r.__words[2];
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CF320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFetchedPlaceInference,&CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToFetchPlaceInference,&CLMicroLocationLoiManager::FailedToFetchedPlaceInference>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::FailedToFetchedPlaceInference(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CF7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToFetchPlaceInference,&CLMicroLocationLoiManager::FailedToFetchedPlaceInference>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerReceivedRelatedLoisEvent,&CLMicroLocationLoiManager::RelatedLois>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::RelatedLois(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563CFCD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerReceivedRelatedLoisEvent,&CLMicroLocationLoiManager::RelatedLois>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToFetchRelatedLois,&CLMicroLocationLoiManager::FailureToFetchRelatedLois>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::FailureToFetchRelatedLois(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563D01B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToFetchRelatedLois,&CLMicroLocationLoiManager::FailureToFetchRelatedLois>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMicroLocationLoiManager,&CLMicroLocationLoiManager::entryFunctionEnteringCustomLoiState>::stateFunction(uint64_t a1, uint64_t a2)
{
  if (a2) {
    uint64_t v2 = a2 - 8;
  }
  else {
    uint64_t v2 = 0;
  }
  *(_WORD *)(v2 + 506) = 1;
  CLMicroLocationLoiManager::startCustomLoiEntryTimer((id *)v2);
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMicroLocationLoiManager,&CLMicroLocationLoiManager::entryFunctionEnteringCustomLoiState>::~EventHandlerWrapperWithNoData(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoiWhileEnabling>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::EnableCustomLoiWhileEnabling(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563D06E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnableCustomLoiEvent,&CLMicroLocationLoiManager::EnableCustomLoiWhileEnabling>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiEntryWhileEnabling>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = a2 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::CustomLoiEntryWhileEnabling((id *)v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *(void *)(v5 + 16);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *(void *)(v5 + 16);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *(void *)(v5 + 16);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563D0BBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGeofenceEntryEvent,&CLMicroLocationLoiManager::CustomLoiEntryWhileEnabling>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGotLocationUpdateEvent,&CLMicroLocationLoiManager::LocationUpdate>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = a2 - 8;
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::LocationUpdate(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *(void *)(v5 + 16);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *(void *)(v5 + 16);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *(void *)(v5 + 16);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563D1098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerGotLocationUpdateEvent,&CLMicroLocationLoiManager::LocationUpdate>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToGetLocationUpdateEvent,&CLMicroLocationLoiManager::FailureToGetLocationUpdate>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::FailureToGetLocationUpdate(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563D1574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToGetLocationUpdateEvent,&CLMicroLocationLoiManager::FailureToGetLocationUpdate>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerStartedActivatingGeofenceEvent,&CLMicroLocationLoiManager::GeofenceActivationStarted>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::GeofenceActivationStarted(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563D1A50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerStartedActivatingGeofenceEvent,&CLMicroLocationLoiManager::GeofenceActivationStarted>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToSetGeofenceEvent,&CLMicroLocationLoiManager::FailureToActivateGeofenceAtCurrentLocation>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::FailureToActivateGeofenceAtCurrentLocation(v5, v6, a3);
  }
  else
  {
    std::string::size_type v28 = lpsrc;
    uint64_t v7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = *((void *)v5 + 2);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(void *)(v8 + 16));
      }
      else
      {
        long long v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      int v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v12 = &v30;
      if (v10 < 0) {
        std::string::size_type v12 = (std::string *)v11;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v12;
      __int16 v37 = 2081;
      uint64_t v38 = p_p;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v14 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v14))
    {
      uint64_t v15 = *((void *)v5 + 2);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(void *)(v15 + 16));
      }
      else
      {
        long long v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      int v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v19 = &v30;
      if (v17 < 0) {
        std::string::size_type v19 = (std::string *)v18;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v20 = &__p;
      }
      else {
        int v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2081;
      uint64_t v38 = v20;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    std::string::size_type v21 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      uint64_t v22 = *((void *)v5 + 2);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(void *)(v22 + 16));
      }
      else
      {
        long long v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(void *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      int v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      std::string::size_type v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      std::string::size_type v26 = &v30;
      if (v24 < 0) {
        std::string::size_type v26 = (std::string *)v25;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = &__p;
      }
      else {
        int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v32 = 0;
      __int16 v33 = 2082;
      __int16 v34 = "";
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2081;
      uint64_t v38 = v27;
      __int16 v39 = 2082;
      __int16 v40 = "assert";
      __int16 v41 = 2081;
      uuid v42 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563D1F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerFailedToSetGeofenceEvent,&CLMicroLocationLoiManager::FailureToActivateGeofenceAtCurrentLocation>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnteringCustomLoiTimeout,&CLMicroLocationLoiManager::EnteringCustomLoiTimeoutHandler>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v5 = (CLMicroLocationLoiManager *)(a2 - 8);
  }
  else {
    uint64_t v5 = 0;
  }
  if (lpsrc
  {
    CLMicroLocationLoiManager::EnteringCustomLoiTimeoutHandler(v5, a3);
  }
  else
  {
    id v6 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      uint64_t v7 = *((void *)v5 + 2);
      if (*(char *)(v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(v7 + 8), *(void *)(v7 + 16));
      }
      else
      {
        long long v8 = *(_OWORD *)(v7 + 8);
        v28.__r_.__value_.__r.__words[2] = *(void *)(v7 + 24);
        *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v8;
      }
      int v9 = SHIBYTE(v28.__r_.__value_.__r.__words[2]);
      std::string::size_type v10 = v28.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v11 = &v28;
      if (v9 < 0) {
        std::string::size_type v11 = (std::string *)v10;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v30 = 0;
      __int16 v31 = 2082;
      int v32 = "";
      __int16 v33 = 2081;
      __int16 v34 = v11;
      __int16 v35 = 2081;
      __int16 v36 = p_p;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }

    int v13 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v13))
    {
      uint64_t v14 = *((void *)v5 + 2);
      if (*(char *)(v14 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(v14 + 8), *(void *)(v14 + 16));
      }
      else
      {
        long long v15 = *(_OWORD *)(v14 + 8);
        v28.__r_.__value_.__r.__words[2] = *(void *)(v14 + 24);
        *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v15;
      }
      int v16 = SHIBYTE(v28.__r_.__value_.__r.__words[2]);
      std::string::size_type v17 = v28.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v18 = &v28;
      if (v16 < 0) {
        std::string::size_type v18 = (std::string *)v17;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v19 = &__p;
      }
      else {
        std::string::size_type v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v30 = 0;
      __int16 v31 = 2082;
      int v32 = "";
      __int16 v33 = 2081;
      __int16 v34 = v18;
      __int16 v35 = 2081;
      __int16 v36 = v19;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }

    int v20 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      uint64_t v21 = *((void *)v5 + 2);
      if (*(char *)(v21 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v28, *(const std::string::value_type **)(v21 + 8), *(void *)(v21 + 16));
      }
      else
      {
        long long v22 = *(_OWORD *)(v21 + 8);
        v28.__r_.__value_.__r.__words[2] = *(void *)(v21 + 24);
        *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v22;
      }
      int v23 = SHIBYTE(v28.__r_.__value_.__r.__words[2]);
      std::string::size_type v24 = v28.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      std::string::size_type v25 = &v28;
      if (v23 < 0) {
        std::string::size_type v25 = (std::string *)v24;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v26 = &__p;
      }
      else {
        std::string::size_type v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 68290051;
      int v30 = 0;
      __int16 v31 = 2082;
      int v32 = "";
      __int16 v33 = 2081;
      __int16 v34 = v25;
      __int16 v35 = 2081;
      __int16 v36 = v26;
      __int16 v37 = 2082;
      uint64_t v38 = "assert";
      __int16 v39 = 2081;
      __int16 v40 = "derivedEventData != __null";
      _os_log_impl(&dword_25631F000, v20, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_2563D2404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMicroLocationLoiManager,CLMiLoLoiManagerEnteringCustomLoiTimeout,&CLMicroLocationLoiManager::EnteringCustomLoiTimeoutHandler>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMicroLocationLoiManager,&CLMicroLocationLoiManager::exitFunctionEnteringCustomLoiState>::stateFunction(uint64_t a1, uint64_t a2)
{
  if (a2) {
    uint64_t v2 = a2 - 8;
  }
  else {
    uint64_t v2 = 0;
  }
  [*(id *)(v2 + 520) invalidate];
  id v3 = *(void **)(v2 + 520);
  *(void *)(v2 + 520) = 0;
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMicroLocationLoiManager,&CLMicroLocationLoiManager::exitFunctionEnteringCustomLoiState>::~EventHandlerWrapperWithNoData(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x25A2A6340);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_41()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void CLMiLoLoiManagerRefreshLocationOnEvent::CLMiLoLoiManagerRefreshLocationOnEvent(CLMiLoLoiManagerRefreshLocationOnEvent *this)
{
  *(void *)this = &unk_2704DC488;
  uint64_t v2 = std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD2F0;
  MEMORY[0x25A2A6080](v2, "Refresh Location on regular interval");
}

void sub_2563D2718(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerLoiVisitExitEvent::CLMiLoLoiManagerLoiVisitExitEvent(CLMiLoLoiManagerLoiVisitExitEvent *this, CLVisit *a2)
{
  char v4 = a2;
  *(void *)this = &unk_2704DC488;
  std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD310;
  *((void *)this + 4) = 0;
  objc_storeStrong((id *)this + 4, a2);
  MEMORY[0x25A2A6080]((char *)this + 8, "LOI Visit Exit");
}

void sub_2563D285C(_Unwind_Exception *a1)
{
  *(void *)uint64_t v2 = v4;
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v3);
  }

  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerLoiVisitEntryEvent::CLMiLoLoiManagerLoiVisitEntryEvent(CLMiLoLoiManagerLoiVisitEntryEvent *this, CLVisit *a2)
{
  uint64_t v4 = a2;
  *(void *)this = &unk_2704DC488;
  std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD330;
  *((void *)this + 4) = 0;
  objc_storeStrong((id *)this + 4, a2);
  MEMORY[0x25A2A6080]((char *)this + 8, "LOI Visit Entry");
}

void sub_2563D29BC(_Unwind_Exception *a1)
{
  *(void *)uint64_t v2 = v4;
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v3);
  }

  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerFailedToFetchPlaceInference::CLMiLoLoiManagerFailedToFetchPlaceInference(CLMiLoLoiManagerFailedToFetchPlaceInference *this)
{
  *(void *)this = &unk_2704DC488;
  uint64_t v2 = std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD350;
  MEMORY[0x25A2A6080](v2, "Failed To Fetched Place Inference");
}

void sub_2563D2AF0(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMiLoLoiManagerFetchedPlaceInference::CLMiLoLoiManagerFetchedPlaceInference(uint64_t a1, void *a2)
{
  id v4 = a2;
  *(void *)a1 = &unk_2704DC488;
  std::string::basic_string[abi:ne180100]<0>((void *)(a1 + 8), "No Name Given");
  *(void *)a1 = &unk_2704DD370;
  *(void *)(a1 + 32) = 0;
  objc_storeStrong((id *)(a1 + 32), a2);
  MEMORY[0x25A2A6080](a1 + 8, "Fetched Place Inference For Current Location");

  return a1;
}

void sub_2563D2C34(_Unwind_Exception *a1)
{
  *(void *)uint64_t v2 = v4;
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v3);
  }

  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerFailedToFetchLoiForLocationEvent::CLMiLoLoiManagerFailedToFetchLoiForLocationEvent(CLMiLoLoiManagerFailedToFetchLoiForLocationEvent *this)
{
  *(void *)this = &unk_2704DC488;
  uint64_t v2 = std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD390;
  MEMORY[0x25A2A6080](v2, "Failed to Get LOI Event");
}

void sub_2563D2D28(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerFailedToFetchRelatedLois::CLMiLoLoiManagerFailedToFetchRelatedLois(CLMiLoLoiManagerFailedToFetchRelatedLois *this)
{
  *(void *)this = &unk_2704DC488;
  uint64_t v2 = std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD3D0;
  MEMORY[0x25A2A6080](v2, "Failed to Get Related LOIs");
}

void sub_2563D2EB8(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerReceivedRelatedLoisEvent::~CLMiLoLoiManagerReceivedRelatedLoisEvent(CLMiLoLoiManagerReceivedRelatedLoisEvent *this)
{
  CLMiLoLoiManagerReceivedRelatedLoisEvent::~CLMiLoLoiManagerReceivedRelatedLoisEvent(this);
  JUMPOUT(0x25A2A6340);
}

{
  void *v2;

  *(void *)this = &unk_2704DD3F0;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_2704DC488;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

void CLMiLoLoiManagerFailedToGetLocationUpdateEvent::CLMiLoLoiManagerFailedToGetLocationUpdateEvent(CLMiLoLoiManagerFailedToGetLocationUpdateEvent *this)
{
  *(void *)this = &unk_2704DC488;
  uint64_t v2 = std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD410;
  MEMORY[0x25A2A6080](v2, "Failed To Get Location Update");
}

void sub_2563D3084(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerGotLocationUpdateEvent::CLMiLoLoiManagerGotLocationUpdateEvent(CLMiLoLoiManagerGotLocationUpdateEvent *this, CLLocation *a2)
{
  uint64_t v4 = a2;
  *(void *)this = &unk_2704DC488;
  std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD430;
  *((void *)this + 4) = 0;
  objc_storeStrong((id *)this + 4, a2);
  MEMORY[0x25A2A6080]((char *)this + 8, "Got Location Update");
}

void sub_2563D31C8(_Unwind_Exception *a1)
{
  *(void *)uint64_t v2 = v4;
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v3);
  }

  _Unwind_Resume(a1);
}

void CLMiLoLoiManagerGotLocationUpdateEvent::~CLMiLoLoiManagerGotLocationUpdateEvent(id *this)
{
  CLMiLoLoiManagerFetchedPlaceInference::~CLMiLoLoiManagerFetchedPlaceInference(this);
  JUMPOUT(0x25A2A6340);
}

void CLMiLoLoiManagerLeechedLocationEvent::~CLMiLoLoiManagerLeechedLocationEvent(id *this)
{
  CLMiLoLoiManagerFetchedPlaceInference::~CLMiLoLoiManagerFetchedPlaceInference(this);
  JUMPOUT(0x25A2A6340);
}

void CLMiLoLoiManagerFailedToSetGeofenceEvent::CLMiLoLoiManagerFailedToSetGeofenceEvent(CLMiLoLoiManagerFailedToSetGeofenceEvent *this)
{
  *(void *)this = &unk_2704DC488;
  uint64_t v2 = std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD470;
  MEMORY[0x25A2A6080](v2, "Failed To Set Geofence");
}

void sub_2563D32F4(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoLoiManagerEnteringCustomLoiTimeout::CLMiLoLoiManagerEnteringCustomLoiTimeout(CLMiLoLoiManagerEnteringCustomLoiTimeout *this)
{
  *(void *)this = &unk_2704DC488;
  uint64_t v2 = std::string::basic_string[abi:ne180100]<0>((void *)this + 1, "No Name Given");
  *(void *)this = &unk_2704DD4F0;
  MEMORY[0x25A2A6080](v2, "Entering Custom LOI Timeout");
}

void sub_2563D355C(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<std::__wrap_iter<boost::uuids::uuid const*>,std::__wrap_iter<boost::uuids::uuid const*>>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    id v6 = result;
    uint64_t result = std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2563D364C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLocalizer::localize(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  std::to_string(&v3, *(_DWORD *)(a2 + 4));
  uint64_t v2 = std::string::insert(&v3, 0, "LocalizationProcessing_modelType_");
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  operator new();
}

void sub_2563D3CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,CLMicroLocationTimeUtils::TimeProfile *a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__value_func[abi:ne180100]((void *)(v35 - 176));
  if (a33) {
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&__p);
  }

  if (*(unsigned char *)(v35 - 112)) {
    std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__value_func[abi:ne180100]((void *)(v35 - 144));
  }
  if (a21) {
    (*(void (**)(uint64_t))(*(void *)a21 + 8))(a21);
  }
  CLMicroLocationAlgorithms::LocalizerResults::~LocalizerResults(v33);
  std::unique_ptr<CLMicroLocationTimeUtils::TimeProfile>::reset[abi:ne180100](&a22, 0);
  _Unwind_Resume(a1);
}

void std::vector<CLMicroLocationResultInternal>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 5)
  {
    if (a2 >> 59) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    id v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>(v3, a2);
    uint64_t v7 = &v6[v5];
    int v9 = &v6[32 * v8];
    std::string::size_type v11 = (char *)*a1;
    std::string::size_type v10 = (char *)a1[1];
    std::string::size_type v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        long long v13 = *((_OWORD *)v10 - 2);
        *(_OWORD *)(v12 - 20) = *(_OWORD *)(v10 - 20);
        *((_OWORD *)v12 - 2) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      std::string::size_type v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t ULSettings::get<ULSettings::AdaptiveSensorsEnable>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  uint64_t v2 = [NSString stringWithUTF8String:"ULAdaptiveSensorsEnable"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 BOOLValue];
  }
  else {
    uint64_t v4 = [MEMORY[0x263EFFA88] BOOLValue];
  }
  uint64_t v5 = v4;

  return v5;
}

void sub_2563D4024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::function<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>>::operator=[abi:ne180100]<std::function<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>,void>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 32))
  {
    std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator=[abi:ne180100]((void *)a1, a2);
  }
  else
  {
    std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__value_func[abi:ne180100](a1, a2);
    *(unsigned char *)(a1 + 32) = 1;
  }
  return a1;
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_42()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void *std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator=[abi:ne180100](void *a1, uint64_t a2)
{
  std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator=[abi:ne180100](a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator=[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void _ULRequireInitializer(uint64_t a1, SEL aSelector)
{
  uint64_t v3 = NSString;
  uint64_t v4 = NSStringFromSelector(aSelector);
  uint64_t v5 = [v3 stringWithFormat:@"%@ requires the use of the initializer: %@", a1, v4];

  id v6 = [MEMORY[0x263EFF940] exceptionWithName:*MEMORY[0x263EFF498] reason:v5 userInfo:0];
  objc_exception_throw(v6);
}

void sub_2563D43F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2563D45D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_43()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

uint64_t CLMiLoCustomLoiTable::Entry::Entry(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  *(void *)(result + 24) = a5;
  *(double *)(result + 32) = a6;
  return result;
}

uint64_t CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings(uint64_t a1, void *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v88 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 24) = ULSettings::get<ULSettings::NullSpaceKernelFunction>();
  v84[0] = 0;
  v84[1] = 0;
  v83 = v84;
  int v8 = *((unsigned __int8 *)a2 + 23);
  if ((v8 & 0x80) != 0)
  {
    uint64_t v12 = a2[1];
    if (v12 == 24)
    {
      if (*(void *)*a2 == 0x6C7070612E6D6F63
        && *(void *)(*a2 + 8) == 0x61636967616D2E65
        && *(void *)(*a2 + 16) == 0x73746E656D6F6D6CLL)
      {
        goto LABEL_81;
      }
      uint64_t v12 = a2[1];
    }
    else if (v12 == 38 && !memcmp((const void *)*a2, "com.apple.microlocation.semisupervised", 0x26uLL))
    {
      goto LABEL_46;
    }
    if (v12 == 31)
    {
      if (*(void *)*a2 == 0x6C7070612E6D6F63
        && *(void *)(*a2 + 8) == 0x6C6F7263696D2E65
        && *(void *)(*a2 + 16) == 0x2E6E6F697461636FLL
        && *(void *)(*a2 + 23) == 0x696F6C656D6F682ELL)
      {
LABEL_63:
        std::string::size_type v26 = +[ULDefaultsSingleton shared];
        int v27 = [v26 defaultsDictionary];

        std::string v28 = [NSString stringWithUTF8String:"ULLocalizerAlgorithm_HomeLOI"];
        unint64_t v29 = [v27 objectForKey:v28];
        if (v29 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          int v30 = [v29 unsignedIntValue];
        }
        else {
          int v30 = [&unk_2704F19F8 unsignedIntValue];
        }
        int v31 = v30;

        *(_DWORD *)(a1 + 32) = v31;
        int v32 = +[ULDefaultsSingleton shared];
        __int16 v33 = [v32 defaultsDictionary];

        __int16 v34 = [NSString stringWithUTF8String:"ULNullSpaceDistanceReductionFunctionMinPercentile_HomeLOI"];
        uint64_t v35 = [v33 objectForKey:v34];
        if (v35 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          [v35 doubleValue];
        }
        else {
          [&unk_2704F0EC0 doubleValue];
        }
        __int16 v37 = v36;

        int v82 = 0;
        *(void *)std::string buf = &v82;
        std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)a1, &v82, (uint64_t)&std::piecewise_construct, (_DWORD **)buf)[5] = v37;
        uint64_t v38 = +[ULDefaultsSingleton shared];
        __int16 v39 = [v38 defaultsDictionary];

        __int16 v40 = [NSString stringWithUTF8String:"ULNullSpaceDistanceReductionFunctionMaxPercentile_HomeLOI"];
        uint64_t v41 = [v39 objectForKey:v40];
        if (v41 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          [v41 doubleValue];
        }
        else {
          [&unk_2704F0E90 doubleValue];
        }
        uint64_t v43 = v42;

        int v82 = 1;
        *(void *)std::string buf = &v82;
        std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)a1, &v82, (uint64_t)&std::piecewise_construct, (_DWORD **)buf)[5] = v43;
        uint64_t v44 = +[ULDefaultsSingleton shared];
        char v45 = [v44 defaultsDictionary];

        long long v46 = [NSString stringWithUTF8String:"ULNullSpaceKernelFunction_HomeLOI"];
        uint64_t v47 = [v45 objectForKey:v46];
        if (v47 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          id v48 = v47;
        }
        else {
          id v48 = &unk_2704F2538;
        }

        long long v49 = *(void **)(a1 + 24);
        *(void *)(a1 + 24) = v48;

        int v23 = ULSettings::get<ULSettings::HomeLoiLocalizerFingerprintDistanceFunctionType>();
        goto LABEL_120;
      }
      uint64_t v12 = a2[1];
    }
    if (v12 != 34) {
      goto LABEL_121;
    }
    a2 = (void *)*a2;
LABEL_51:
    if (memcmp(a2, "com.apple.microlocation.similarity", 0x22uLL)) {
      goto LABEL_121;
    }
    if (a3 != 5)
    {
      *(_DWORD *)(a1 + 32) = 4;
      goto LABEL_121;
    }
    *(_DWORD *)(a1 + 32) = 5;
    int v23 = ULSettings::get<ULSettings::HomeLoiLocalizerFingerprintDistanceFunctionType>();
LABEL_120:
    *(_DWORD *)(a1 + 36) = v23;
    goto LABEL_121;
  }
  if (*((unsigned __int8 *)a2 + 23) > 0x21u)
  {
    if (v8 != 34)
    {
      if (v8 != 38 || memcmp(a2, "com.apple.microlocation.semisupervised", 0x26uLL)) {
        goto LABEL_121;
      }
LABEL_46:
      if (a3 != 3)
      {
        if (a3 != 4)
        {
          if (onceToken_MicroLocation_Default != -1) {
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_53);
          }
          std::string::size_type v54 = logObject_MicroLocation_Default;
          if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)std::string buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            __int16 v86 = 2050;
            uint64_t v87 = a3;
            _os_log_impl(&dword_25631F000, v54, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Unexpected generation algorithm for kMicroLocationSemisupervisedDomain!\", \"Generation Algorithm\":%{public}lu}", buf, 0x1Cu);
          }
          if (onceToken_MicroLocation_Default != -1) {
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_53);
          }
          long long v55 = logObject_MicroLocation_Default;
          if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
          {
            *(_DWORD *)std::string buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            __int16 v86 = 2050;
            uint64_t v87 = a3;
            _os_signpost_emit_with_name_impl(&dword_25631F000, v55, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Unexpected generation algorithm for kMicroLocationSemisupervisedDomain!", "{\"msg%{public}.0s\":\"Unexpected generation algorithm for kMicroLocationSemisupervisedDomain!\", \"Generation Algorithm\":%{public}lu}", buf, 0x1Cu);
          }
          goto LABEL_121;
        }
        *(_DWORD *)(a1 + 32) = 2;
        std::string::size_type v18 = +[ULDefaultsSingleton shared];
        std::string::size_type v19 = [v18 defaultsDictionary];

        int v20 = [NSString stringWithUTF8String:"ULBinaryModelRoiReductionPercentile"];
        uint64_t v21 = [v19 objectForKey:v20];
        if (v21 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          [v21 doubleValue];
        }
        else {
          [&unk_2704F0E50 doubleValue];
        }
        uint64_t v56 = v22;

        int v82 = 2;
        *(void *)std::string buf = &v82;
        std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)a1, &v82, (uint64_t)&std::piecewise_construct, (_DWORD **)buf)[5] = v56;
        v57 = +[ULDefaultsSingleton shared];
        v58 = [v57 defaultsDictionary];

        v59 = [NSString stringWithUTF8String:"ULBinaryModelNotRoiReductionPercentile"];
        __int16 v60 = [v58 objectForKey:v59];
        if (v60 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          [v60 doubleValue];
        }
        else {
          [&unk_2704F0E60 doubleValue];
        }
        uint64_t v62 = v61;

        int v82 = 3;
        *(void *)std::string buf = &v82;
        std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)a1, &v82, (uint64_t)&std::piecewise_construct, (_DWORD **)buf)[5] = v62;
        std::optional<std::string>::value_or[abi:ne180100]<char const(&)[1]>(a4, "", (std::string *)buf);
        if (SBYTE3(v87) < 0)
        {
          if (*(void *)&buf[8] != 14)
          {
            operator delete(*(void **)buf);
            goto LABEL_115;
          }
          BOOL v65 = **(void **)buf != 0x6F2D726F6F646E69 || *(void *)(*(void *)buf + 6) != 0x726F6F6474756F2DLL;
          operator delete(*(void **)buf);
          if (v65)
          {
LABEL_115:
            uint64_t v71 = ULSettings::get<ULSettings::NullSpaceKernelFunction>();
            v72 = *(void **)(a1 + 24);
            *(void *)(a1 + 24) = v71;

            v73 = +[ULDefaultsSingleton shared];
            v74 = [v73 defaultsDictionary];

            v75 = [NSString stringWithUTF8String:"ULBinaryModelDetectionThreshold"];
            v76 = [v74 objectForKey:v75];
            if (!v76 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
            {
              [&unk_2704F0E70 doubleValue];
              goto LABEL_119;
            }
LABEL_117:
            [v76 doubleValue];
LABEL_119:
            v78 = v77;

            int v82 = 4;
            *(void *)std::string buf = &v82;
            std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)a1, &v82, (uint64_t)&std::piecewise_construct, (_DWORD **)buf)[5] = v78;
            int v23 = ULSettings::get<ULSettings::FingerprintDistanceFunctionType>();
            goto LABEL_120;
          }
        }
        else
        {
          if (SBYTE3(v87) != 14) {
            goto LABEL_115;
          }
          if (*(void *)buf != 0x6F2D726F6F646E69 || *(void *)&buf[6] != 0x726F6F6474756F2DLL) {
            goto LABEL_115;
          }
        }
        v66 = +[ULDefaultsSingleton shared];
        v67 = [v66 defaultsDictionary];

        v68 = [NSString stringWithUTF8String:"ULNullSpaceKernelFunction_IndoorOutdoor"];
        v69 = [v67 objectForKey:v68];
        if (v69 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
          id v70 = v69;
        }
        else {
          id v70 = &unk_2704F2510;
        }

        v80 = *(void **)(a1 + 24);
        *(void *)(a1 + 24) = v70;

        v81 = +[ULDefaultsSingleton shared];
        v74 = [v81 defaultsDictionary];

        v75 = [NSString stringWithUTF8String:"ULBinaryModelDetectionThreshold_IndoorOutdoor"];
        v76 = [v74 objectForKey:v75];
        if (!v76 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          [&unk_2704F0E80 doubleValue];
          goto LABEL_119;
        }
        goto LABEL_117;
      }
LABEL_81:
      *(_DWORD *)(a1 + 32) = ULSettings::get<ULSettings::LocalizerAlgorithm>();
      double v50 = ULSettings::get<ULSettings::NullSpaceDistanceReductionFunctionMinPercentile>();
      int v82 = 0;
      *(void *)std::string buf = &v82;
      *((double *)std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)a1, &v82, (uint64_t)&std::piecewise_construct, (_DWORD **)buf)+ 5) = v50;
      double v51 = ULSettings::get<ULSettings::NullSpaceDistanceReductionFunctionMaxPercentile>();
      int v82 = 1;
      *(void *)std::string buf = &v82;
      *((double *)std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)a1, &v82, (uint64_t)&std::piecewise_construct, (_DWORD **)buf)+ 5) = v51;
      uint64_t v52 = ULSettings::get<ULSettings::NullSpaceKernelFunction>();
      v53 = *(void **)(a1 + 24);
      *(void *)(a1 + 24) = v52;

      int v23 = ULSettings::get<ULSettings::FingerprintDistanceFunctionType>();
      goto LABEL_120;
    }
    goto LABEL_51;
  }
  if (v8 != 24)
  {
    if (v8 != 31) {
      goto LABEL_121;
    }
    BOOL v9 = *a2 == 0x6C7070612E6D6F63 && a2[1] == 0x6C6F7263696D2E65;
    BOOL v10 = v9 && a2[2] == 0x2E6E6F697461636FLL;
    if (!v10 || *(void *)((char *)a2 + 23) != 0x696F6C656D6F682ELL) {
      goto LABEL_121;
    }
    goto LABEL_63;
  }
  if (*a2 == 0x6C7070612E6D6F63 && a2[1] == 0x61636967616D2E65 && a2[2] == 0x73746E656D6F6D6CLL) {
    goto LABEL_81;
  }
LABEL_121:
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v83, v84[0]);
  return a1;
}

void sub_2563D57D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, void *a12)
{
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a11, a12);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(v12, *(void **)(v12 + 8));
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings(uint64_t a1, void *a2)
{
  LOBYTE(__p) = 0;
  char v6 = 0;
  CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings(a1, a2, 0, (uint64_t)&__p);
  if (v6 && v5 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_2563D5A80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings(uint64_t a1, void *a2, unsigned int a3)
{
  LOBYTE(__p) = 0;
  char v7 = 0;
  CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings(a1, a2, a3, (uint64_t)&__p);
  if (v7 && v6 < 0) {
    operator delete(__p);
  }
  return a1;
}

void sub_2563D5AF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }
  _Unwind_Resume(exception_object);
}

id ULSettings::get<ULSettings::NullSpaceKernelFunction>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  uint64_t v2 = [NSString stringWithUTF8String:"ULNullSpaceKernelFunction"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    id v4 = v3;
  }
  else {
    id v4 = &unk_2704F24E8;
  }

  return v4;
}

void sub_2563D5BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::LocalizerAlgorithm>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  uint64_t v2 = [NSString stringWithUTF8String:"ULLocalizerAlgorithm"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 unsignedIntValue];
  }
  else {
    uint64_t v4 = [&unk_2704F19E0 unsignedIntValue];
  }
  uint64_t v5 = v4;

  return v5;
}

void sub_2563D5CE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double ULSettings::get<ULSettings::NullSpaceDistanceReductionFunctionMinPercentile>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  uint64_t v2 = [NSString stringWithUTF8String:"ULNullSpaceDistanceReductionFunctionMinPercentile"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    [v3 doubleValue];
  }
  else {
    [&unk_2704F0E90 doubleValue];
  }
  double v5 = v4;

  return v5;
}

void sub_2563D5DE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double ULSettings::get<ULSettings::NullSpaceDistanceReductionFunctionMaxPercentile>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  uint64_t v2 = [NSString stringWithUTF8String:"ULNullSpaceDistanceReductionFunctionMaxPercentile"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    [v3 doubleValue];
  }
  else {
    [&unk_2704F0ED0 doubleValue];
  }
  double v5 = v4;

  return v5;
}

void sub_2563D5EF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::FingerprintDistanceFunctionType>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  uint64_t v2 = [NSString stringWithUTF8String:"ULFingerprintDistanceFunctionType"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 unsignedIntValue];
  }
  else {
    uint64_t v4 = [&unk_2704F19C8 unsignedIntValue];
  }
  uint64_t v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  uint64_t v2 = [NSString stringWithUTF8String:"ULFingerprintDistanceFunctionType"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 unsignedIntValue];
  }
  else {
    uint64_t v4 = [&unk_2704F21D8 unsignedIntValue];
  }
  uint64_t v5 = v4;

  return v5;
}

void sub_2563D5FF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::HomeLoiLocalizerFingerprintDistanceFunctionType>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  uint64_t v2 = [NSString stringWithUTF8String:"ULHomeLoiLocalizerFingerprintDistanceFunctionType"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 unsignedIntValue];
  }
  else {
    uint64_t v4 = [&unk_2704F19B0 unsignedIntValue];
  }
  uint64_t v5 = v4;

  return v5;
}

void sub_2563D60F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLocalizationSettings::getLocalizerAlgorithm(CLMicroLocationLocalizationSettings *this)
{
  return *((unsigned int *)this + 8);
}

double CLMicroLocationLocalizationSettings::getMinPercentileForReducerFunction(CLMicroLocationLocalizationSettings *this)
{
  int v2 = 0;
  return *(double *)std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::at((uint64_t)this, &v2);
}

uint64_t *std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::at(uint64_t a1, int *a2)
{
  int v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 8);
      if (v3 >= v4) {
        break;
      }
      int v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 5;
    }
    int v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

double CLMicroLocationLocalizationSettings::getMaxPercentileForReducerFunction(CLMicroLocationLocalizationSettings *this)
{
  int v2 = 1;
  return *(double *)std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::at((uint64_t)this, &v2);
}

id CLMicroLocationLocalizationSettings::getKernelFuncSettings(id *this)
{
  return this[3];
}

uint64_t CLMicroLocationLocalizationSettings::getFingerprintDistanceFunctionType(CLMicroLocationLocalizationSettings *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t CLMicroLocationLocalizationSettings::getDetectionThresholdForBinaryROI(CLMicroLocationLocalizationSettings *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!v1) {
    return 0;
  }
  int v2 = (int *)((char *)this + 8);
  do
  {
    int v3 = *(_DWORD *)(v1 + 32);
    BOOL v4 = v3 < 4;
    if (v3 >= 4) {
      uint64_t v5 = (uint64_t *)v1;
    }
    else {
      uint64_t v5 = (uint64_t *)(v1 + 8);
    }
    if (!v4) {
      int v2 = (int *)v1;
    }
    uint64_t v1 = *v5;
  }
  while (*v5);
  if (v2 == (int *)((char *)this + 8) || v2[8] > 4) {
    return 0;
  }
  int v7 = 4;
  return *std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::at((uint64_t)this, &v7);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_44()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void sub_2563D6494(_Unwind_Exception *a1)
{
  MEMORY[0x25A2A6320](v3, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_2563D6764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v9 + 32));
  CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)&a9);
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_45()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void sub_2563D6924(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2563D6C20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_46()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

uint64_t CLMicroLocationLearner::CLMicroLocationLearner(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  v7[0] = &unk_2704DD650;
  v7[1] = a1;
  void v7[3] = v7;
  v8[0] = &unk_2704DD6E0;
  v8[1] = a1;
  v8[3] = v8;
  v9[0] = &unk_2704DD760;
  v9[1] = a1;
  v9[3] = v9;
  v10[0] = &unk_2704DD7E0;
  v10[1] = a1;
  v10[3] = v10;
  v11[0] = &unk_2704DD860;
  v11[1] = a1;
  v11[3] = v11;
  v12[0] = &unk_2704DD8E0;
  v12[1] = a1;
  v12[3] = v12;
  v13[0] = &unk_2704DD960;
  v13[1] = a1;
  v13[3] = v13;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  BOOL v4 = (char *)operator new(0xE0uLL);
  *(void *)(a1 + 56) = v4 + 224;
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 48) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::function<void ()(std::function<BOOL ()(void)>)>>,std::function<void ()(std::function<BOOL ()(void)>)> const*,std::function<void ()(std::function<BOOL ()(void)>)> const*,std::function<void ()(std::function<BOOL ()(void)>)>*>(a1 + 56, (uint64_t)v7, (uint64_t)&v14, (uint64_t)v4);
  for (uint64_t i = 24; i != -4; i -= 4)
    std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::~__value_func[abi:ne180100](&v7[i]);
  return a1;
}

void sub_2563D6EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v14 = v13;
  *(void *)(v12 + 48) = v14;
  std::vector<std::function<void ()(std::function<BOOL ()(void)>)>>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (uint64_t i = 192; i != -32; i -= 32)
    std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::~__value_func[abi:ne180100](&a12 + i);

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLearner::getAnchorAppearanceMapForLoi@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  CLMicroLocationAnchorAppearanceMap::CLMicroLocationAnchorAppearanceMap((CLMicroLocationAnchorAppearanceMap *)a3);
  uint64_t result = ULSettings::get<ULSettings::AdaptiveAnchorsEnable>();
  if (result)
  {
    id v7 = *(id *)(*(void *)(a1 + 32) + 32);
    int v8 = v7;
    if (v7)
    {
      [v7 fetchMostRecentAnchorAppearancesAtLoi:a2];
    }
    else
    {
      uint64_t v22 = 0;
      long long v20 = 0u;
      long long v21 = 0u;
      memset(v19, 0, sizeof(v19));
    }

    if ((_BYTE)v22) {
      goto LABEL_6;
    }
    if (*a2 != 0)
    {
      id v12 = *(id *)(*(void *)(a1 + 32) + 32);
      uint64_t v13 = v12;
      v14[0] = 0;
      v14[1] = 0;
      if (v12)
      {
        [v12 fetchMostRecentAnchorAppearancesAtLoi:v14];
      }
      else
      {
        uint64_t v18 = 0;
        long long v16 = 0u;
        memset(v17, 0, sizeof(v17));
        long long v15 = 0u;
      }
      std::__optional_storage_base<CLMicroLocationConfigurationTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationConfigurationTable::Entry,false>>((uint64_t)v19, (uint64_t)&v15);
      std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v15);

      if ((_BYTE)v22)
      {
LABEL_6:
        uint64_t v10 = v20;
        if (!(void)v20)
        {
          uint64_t v9 = (CLMicroLocationProto::Configuration *)CLMicroLocationProto::Configuration::default_instance(v9);
          uint64_t v10 = *((void *)v9 + 3);
        }
        std::string::size_type v11 = *(const CLMicroLocationProto::anchorAppearancesVector **)(v10 + 8);
        if (!v11) {
          std::string::size_type v11 = *(const CLMicroLocationProto::anchorAppearancesVector **)(CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance(v9)
        }
                                                                        + 8);
        CLMicroLocationAnchorAppearanceMap::CLMicroLocationAnchorAppearanceMap((CLMicroLocationAnchorAppearanceMap *)&v15, v11);
        if (&v15 != (long long *)a3)
        {
          *(_DWORD *)(a3 + 32) = v17[0];
          std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,void *> *>>((void *)a3, (uint64_t *)v16, 0);
        }
        *(_OWORD *)(a3 + 40) = *(_OWORD *)((char *)v17 + 8);
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v15);
      }
    }
    return std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v19);
  }
  return result;
}

void sub_2563D709C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a27);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v27);
  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::AdaptiveAnchorsEnable>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  int v2 = [NSString stringWithUTF8String:"ULAdaptiveAnchorsEnable"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 BOOLValue];
  }
  else {
    uint64_t v4 = [MEMORY[0x263EFFA88] BOOLValue];
  }
  uint64_t v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  int v2 = [NSString stringWithUTF8String:"ULAdaptiveAnchorsEnable"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 BOOLValue];
  }
  else {
    uint64_t v4 = [MEMORY[0x263EFFA88] BOOLValue];
  }
  uint64_t v5 = v4;

  return v5;
}

void sub_2563D71C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::getServiceLabelsAndLabeledRecordingEventsForLoi(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v24[2] = *MEMORY[0x263EF8340];
  v24[0] = a5;
  v24[1] = a6;
  if (a3[1] != *a3)
  {
    CLMicroLocationLearner::getServiceLabelsAndLabeledRecordingEventsForLoi();
    goto LABEL_17;
  }
  if (*(void *)(a4 + 8) != *(void *)a4)
  {
    CLMicroLocationLearner::getServiceLabelsAndLabeledRecordingEventsForLoi();
LABEL_17:
    __break(1u);
  }
  id v13 = *(id *)(*(void *)(a1 + 32) + 40);
  uint64_t v14 = v13;
  long long v21 = 0;
  if (v13)
  {
    [v13 fetchRecordingLabelsForServiceUuid:a2 atLoiGroupID:v24 fromTime:&v21 limit:a8];
  }
  else
  {
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v20 = 0;
  }
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__vdeallocate(a3);
  *(_OWORD *)a3 = *(_OWORD *)__p;
  a3[2] = v20;
  __p[1] = 0;
  uint64_t v20 = 0;
  __p[0] = 0;
  *(void *)&long long v22 = __p;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&v22);

  __p[0] = 0;
  __p[1] = 0;
  uint64_t v20 = 0;
  long long v21 = __p;
  long long v16 = (long long *)*a3;
  long long v15 = (long long *)a3[1];
  while (v16 != v15)
  {
    long long v22 = *v16;
    std::back_insert_iterator<std::vector<boost::uuids::uuid>>::operator=[abi:ne180100](&v21, &v22);
    v16 += 4;
  }
  id v17 = *(id *)(*(void *)(a1 + 32) + 88);
  uint64_t v18 = v17;
  if (v17)
  {
    [v17 fetchRecordingEventsFromTriggerUUIDs:__p];
  }
  else
  {
    long long v22 = 0uLL;
    uint64_t v23 = 0;
  }
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__vdeallocate((void **)a4);
  *(_OWORD *)a4 = v22;
  *(void *)(a4 + 16) = v23;
  uint64_t v23 = 0;
  long long v21 = (void **)&v22;
  long long v22 = 0uLL;
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v21);

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_2563D73B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(CLMicroLocationLearner *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  id v4 = *(id *)(*((void *)this + 4) + 56);
  uint64_t v5 = v4;
  if (v4)
  {
    [v4 fetchAllDistinctLoiGroups];
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }

  uint64_t v6 = *(void *)a2;
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v8 = v7 - *(void *)a2;
  if (v7 == *(void *)a2)
  {
LABEL_12:
    uint64_t v12 = v7;
  }
  else
  {
    while (1)
    {
      uint64_t v9 = CLMiLoServiceManager::rtLoiStringToLocationType((uint64_t *)(v6 + 40)) | 2;
      BOOL v11 = v10 && v9 == 2;
      if (!v11
        || ![*(id *)(*((void *)this + 4) + 88) countRecordingEventsForLoiGroupId:v6 + 24])
      {
        break;
      }
      v6 += 64;
      if (v6 == v7) {
        goto LABEL_12;
      }
    }
    uint64_t v12 = v7;
    if (v6 != v7)
    {
      if (v6 + 64 == v7)
      {
        uint64_t v12 = v6;
      }
      else
      {
        id v13 = (unsigned char *)(v6 + 127);
        uint64_t v12 = v6;
        do
        {
          uint64_t v14 = CLMiLoServiceManager::rtLoiStringToLocationType((uint64_t *)(v13 - 23)) | 2;
          if (v15) {
            BOOL v16 = v14 == 2;
          }
          else {
            BOOL v16 = 0;
          }
          if (v16
            && [*(id *)(*((void *)this + 4) + 88) countRecordingEventsForLoiGroupId:v13 - 39])
          {
            long long v17 = *(_OWORD *)(v13 - 63);
            long long v18 = *(_OWORD *)(v13 - 47);
            *(void *)(v12 + 32) = *(void *)(v13 - 31);
            *(_OWORD *)uint64_t v12 = v17;
            *(_OWORD *)(v12 + 16) = v18;
            std::string::size_type v19 = (void **)(v12 + 40);
            if (*(char *)(v12 + 63) < 0) {
              operator delete(*v19);
            }
            long long v20 = *(_OWORD *)(v13 - 23);
            *(void *)(v12 + 56) = *(void *)(v13 - 7);
            *(_OWORD *)std::string::size_type v19 = v20;
            unsigned char *v13 = 0;
            *(v13 - 23) = 0;
            v12 += 64;
          }
          long long v21 = v13 + 1;
          v13 += 64;
        }
        while (v21 != (unsigned char *)v7);
      }
    }
  }
  std::vector<CLMiLoLoiTable::Entry>::erase(a2, v12, *(long long **)(a2 + 8));
  long long v22 = *(__n128 **)(a2 + 8);
  unint64_t v23 = 126 - 2 * __clz(((uint64_t)v22 - *(void *)a2) >> 6);
  if (v22 == *(__n128 **)a2) {
    uint64_t v24 = 0;
  }
  else {
    uint64_t v24 = v23;
  }
  std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *,false>(*(void *)a2, v22, v24, 1);
  std::string::size_type v25 = +[ULDefaultsSingleton shared];
  std::string::size_type v26 = [v25 defaultsDictionary];

  uint64_t v27 = [NSString stringWithUTF8String:"ULMaxDistinctLOIGroupUUIDsForLearning"];
  std::string v28 = [v26 objectForKey:v27];
  if (v28 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    unsigned int v29 = [v28 unsignedIntValue];
  }
  else {
    unsigned int v29 = [&unk_2704F1A40 unsignedIntValue];
  }
  unsigned int v30 = v29;

  int v31 = *(long long **)(a2 + 8);
  if (v30 < (unint64_t)(((uint64_t)v31 - *(void *)a2) >> 6)) {
    std::vector<CLMiLoLoiTable::Entry>::erase(a2, *(void *)a2 + ((unint64_t)v30 << 6), v31);
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  int v32 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 6;
    v34[0] = 68289538;
    v34[1] = 0;
    __int16 v35 = 2082;
    __int16 v36 = "";
    __int16 v37 = 2050;
    uint64_t v38 = v8 >> 6;
    __int16 v39 = 2050;
    uint64_t v40 = v33;
    _os_log_impl(&dword_25631F000, v32, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Filtered Unique LOI Groups\", \"Count before filter\":%{public}lu, \"Count after filter\":%{public}lu}", (uint8_t *)v34, 0x26u);
  }
}

void sub_2563D7784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMiLoLoiTable::Entry>::erase(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoLoiTable::Entry *,CLMiLoLoiTable::Entry *,CLMiLoLoiTable::Entry *>((uint64_t)&v9, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        if (*(char *)(v7 - 1) < 0) {
          operator delete(*(void **)(v7 - 24));
        }
        v7 -= 64;
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

void CLMicroLocationLearner::learnFromModelType(ULDatabase **a1, uint64_t a2, unsigned int a3)
{
  uint64_t v176 = *MEMORY[0x263EF8340];
  unsigned int v138 = a3;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  v108 = (CLMicroLocationLearner *)a1;
  uint64_t v5 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::string buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)v148 = 2082;
    *(void *)&v148[2] = "";
    *(_WORD *)&v148[10] = 2050;
    *(void *)&v148[12] = a3;
    _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"start learn model\", \"model-type\":%{public}lu}", buf, 0x1Cu);
  }

  if (ULSettings::get<ULSettings::EnableLearning>())
  {
    ULSettings::get<ULSettings::EnabledModelTypes>((uint64_t)buf);
    if (*(void *)v148 <= (unint64_t)v138) {
      std::vector<unsigned long>::__throw_out_of_range[abi:ne180100]();
    }
    unint64_t v6 = *(void *)(*(void *)buf + (((unint64_t)v138 >> 3) & 0x1FFFFFF8));
    operator delete(*(void **)buf);
    if ((v6 >> v138))
    {
      ULDatabase::connectIfNecessary(a1[4]);
      if ((*((uint64_t (**)(void))a1[4]->var0 + 2))())
      {
        double v7 = cl::chrono::CFAbsoluteTimeClock::now();
        if (![MEMORY[0x263F55810] isInternalInstall]) {
          goto LABEL_30;
        }
        uint64_t v8 = +[ULDefaultsSingleton shared];
        char v9 = [v8 defaultsDictionary];

        char v10 = [NSString stringWithUTF8String:"ULEnableSamplingForLearningAnalyticsOnInternal"];
        BOOL v11 = [v9 objectForKey:v10];
        if (!v11) {
          goto LABEL_28;
        }
        objc_opt_class();
        if (objc_opt_isKindOfClass()) {
          int v12 = [v11 BOOLValue];
        }
        else {
LABEL_28:
        }
          int v12 = [MEMORY[0x263EFFA80] BOOLValue];
        int v19 = v12;

        if (!v19)
        {
          BOOL v26 = 1;
        }
        else
        {
LABEL_30:
          long long v20 = +[ULDefaultsSingleton shared];
          long long v21 = [v20 defaultsDictionary];

          long long v22 = [NSString stringWithUTF8String:"ULSamplingRateForLearningAnalytics"];
          unint64_t v23 = [v21 objectForKey:v22];
          if (v23 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
            [v23 doubleValue];
          }
          else {
            [&unk_2704F0F10 doubleValue];
          }
          double v25 = v24;

          BOOL v26 = (double)arc4random_uniform(0xF4241u) / 1000000.0 <= v25;
        }
        int v27 = ULSettings::get<ULSettings::AnalyticsSendEventEnabled>();
        char v137 = v27;
        int v28 = v26 & v27;
        unsigned __int8 v136 = v26 & v27;
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
        }
        unsigned int v29 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          CLMicroLocationProtobufHelper::ModelTypeToDomain(v138, __p);
          unsigned int v30 = v174 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)std::string buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)v148 = 2082;
          *(void *)&v148[2] = "";
          *(_WORD *)&v148[10] = 2082;
          *(void *)&v148[12] = v30;
          *(_WORD *)&v148[20] = 1026;
          *(_DWORD *)&v148[22] = v28;
          _os_log_impl(&dword_25631F000, v29, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Analytics events for learning\", \"model type\":%{public, location:escape_only}s, \"enabled\":%{public}hhd}", buf, 0x22u);
          if (v174 < 0) {
            operator delete(__p[0]);
          }
        }

        ULSettings::getRecordingEventsForModelType((char **)&v134);
        if (v134 == v135)
        {
          if (onceToken_MicroLocation_Default != -1) {
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
          }
          v69 = logObject_MicroLocation_Default;
          if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 67240192;
            *(_DWORD *)&uint8_t buf[4] = v138;
            _os_log_impl(&dword_25631F000, v69, OS_LOG_TYPE_DEFAULT, "#Warning No recording events for model type %{public}d", buf, 8u);
          }
          goto LABEL_200;
        }
        LOBYTE(__p[0]) = 0;
        char v175 = 0;
        v172[0] = 0;
        v172[112] = 0;
        LOBYTE(v132) = 0;
        unsigned __int8 v133 = 0;
        memset(v130, 0, sizeof(v130));
        int v131 = 1065353216;
        int v31 = v108;
        v129[0] = (uint64_t)v108;
        v129[1] = (uint64_t)&v138;
        v129[2] = (uint64_t)&v137;
        v129[3] = (uint64_t)__p;
        v129[4] = (uint64_t)v172;
        v129[5] = (uint64_t)&v132;
        CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(v108, (uint64_t)&v127);
        if (v138)
        {
          if (v138 == 1)
          {
            CLMicroLocationLearner::getAllClientsAndSupportedLocationTypes((uint64_t)v108, 3, 1, (uint64_t *)v155);
            CLMicroLocationLearner::getAllClientsAndSupportedLocationTypes((uint64_t)v108, 2, 1, (uint64_t *)&v141);
            *(void *)std::string buf = v108;
            *(void *)v148 = v129;
            *(void *)&v148[8] = &v138;
            *(void *)&v148[16] = &v136;
            *(void *)&v148[24] = &v132;
            v149 = &v134;
            uint64_t v150 = a2;
            v151 = v130;
            v152 = __p;
            v153 = &v127;
            CLMicroLocationLearner::learnFromModelType(std::function<BOOL ()(void)>,CLMicroLocationProto::Model_ModelType)::$_1::operator()((uint64_t)buf, (uint64_t *)v155, 3);
            CLMicroLocationLearner::learnFromModelType(std::function<BOOL ()(void)>,CLMicroLocationProto::Model_ModelType)::$_1::operator()((uint64_t)buf, (uint64_t *)&v141, 4);
            *(void *)std::string buf = &v141;
            std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
            *(void *)std::string buf = v155;
            std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
LABEL_197:
            (*(void (**)(void, void))(**((void **)v31 + 3) + 32))(*((void *)v31 + 3), v138);
            *(void *)std::string buf = &v127;
            std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
            std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::~__hash_table((uint64_t)v130);
            if (v133) {

            }
            std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v172);
            std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__p);
LABEL_200:
            double v101 = cl::chrono::CFAbsoluteTimeClock::now();
            if (onceToken_MicroLocationQE_Default != -1) {
              dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_523);
            }
            v102 = (id)logObject_MicroLocationQE_Default;
            if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 68289538;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)v148 = 2082;
              *(void *)&v148[2] = "";
              *(_WORD *)&v148[10] = 2050;
              *(void *)&v148[12] = v138;
              *(_WORD *)&v148[20] = 2050;
              *(double *)&v148[22] = v101 - v7;
              _os_log_impl(&dword_25631F000, v102, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning, completed\", \"model-type\":%{public}lu, \"Total Time (sec)\":\"%{public}.4f\"}", buf, 0x26u);
            }

            if (v134)
            {
              v135 = v134;
              operator delete(v134);
            }
            return;
          }
          if (v138 == 2)
          {
            CLMicroLocationLearner::getAllClientsAndSupportedLocationTypes((uint64_t)v108, 4, 0, &v122);
            uint64_t v32 = v122;
            uint64_t v33 = v123;
            log = _CLLogObjectForCategory_MicroLocation_Default();
            BOOL v34 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
            if (v32 == v33)
            {
              if (v34)
              {
                *(_DWORD *)std::string buf = 68289026;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)v148 = 2082;
                *(void *)&v148[2] = "";
                _os_log_impl(&dword_25631F000, log, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location Similarity List model learning, no such clients\"}", buf, 0x12u);
              }
            }
            else
            {
              if (v34)
              {
                *(_DWORD *)std::string buf = 68289538;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)v148 = 2082;
                *(void *)&v148[2] = "";
                *(_WORD *)&v148[10] = 2050;
                *(void *)&v148[12] = 0xAAAAAAAAAAAAAAABLL * ((v123 - v122) >> 4);
                *(_WORD *)&v148[20] = 2050;
                *(void *)&v148[22] = (v128 - v127) >> 6;
                _os_log_impl(&dword_25631F000, log, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning Location Similarity List models for clients\", \"Num Clients\":%{public}lu, \"Num LOIs\":%{public}lu}", buf, 0x26u);
              }

              buf[0] = 0;
              v148[16] = 0;
              log = CLMicroLocationCoreAnalyticsPublishHelper::initializeModelLearningEventMetricsDict(v28, v138, (const std::string *)buf);
              uint64_t v35 = (uint64_t)v108;
              if (v148[16] && (v148[15] & 0x80000000) != 0) {
                operator delete(*(void **)buf);
              }
              uint64_t v36 = v127;
              for (uint64_t i = v128; v36 != i; v36 += 64)
              {
                v104 = (uint64_t *)(v36 + 40);
                uint64_t v37 = CLMiLoServiceManager::rtLoiStringToLocationType((uint64_t *)(v36 + 40));
                if (v38)
                {
                  unint64_t v39 = v37;
                  v119 = 0;
                  uint64_t v120 = 0;
                  v118 = 0;
                  std::vector<CLMicroLocationProto::EventType>::__init_with_size[abi:ne180100]<CLMicroLocationProto::EventType*,CLMicroLocationProto::EventType*>(&v118, v134, (uint64_t)v135, (v135 - (unsigned char *)v134) >> 2);
                  CLMicroLocationLearner::selectRecordingEventTriggersForLearningMeasurementsWithTransition(v35, (uint64_t)&v118, *(void *)(v36 + 24), *(void *)(v36 + 32), (uint64_t)v121);
                  if (v118)
                  {
                    v119 = v118;
                    operator delete(v118);
                  }
                  CLMicroLocationLearner::getAnchorAppearanceMapForLoi(v35, (_OWORD *)(v36 + 24), (uint64_t)&v115);
                  if (onceToken_MicroLocation_Default != -1) {
                    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
                  }
                  uint64_t v40 = (id)logObject_MicroLocation_Default;
                  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v41 = (char *)operator new(0x28uLL);
                    *(void *)v155 = v41;
                    *(_OWORD *)&v155[8] = xmmword_256514540;
                    *(_OWORD *)uint64_t v41 = 0u;
                    *((_OWORD *)v41 + 1) = 0u;
                    *(void *)(v41 + 29) = 0;
                    boost::uuids::to_chars<char *>(v36 + 24, v41);
                    uuid v42 = v155;
                    if ((v155[23] & 0x80u) != 0) {
                      uuid v42 = *(uint8_t **)v155;
                    }
                    *(_DWORD *)std::string buf = 68289282;
                    *(_DWORD *)&uint8_t buf[4] = 0;
                    *(_WORD *)v148 = 2082;
                    *(void *)&v148[2] = "";
                    *(_WORD *)&v148[10] = 2082;
                    *(void *)&v148[12] = v42;
                    _os_log_impl(&dword_25631F000, v40, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"learning internal model for LOI\", \"loiGroupId\":%{public, location:escape_only}s}", buf, 0x1Cu);
                    if ((char)v155[23] < 0) {
                      operator delete(*(void **)v155);
                    }
                  }

                  v155[0] = 0;
                  BYTE8(v171[1]) = 0;
                  uint64_t v35 = (uint64_t)v108;
                  CLMicroLocationLearner::learnMagicalMomentsModelInternal((uint64_t)v108, log, (uint64_t)v121, a2, (const CLMicroLocationProto::Model *)v130, v36 + 24, (uint64_t)v155, buf, v7, v138);
                  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v155);
                  if (v154 && CLMicroLocationModel::isValid((CLMicroLocationModel *)buf))
                  {
                    if (!v154) {
                      std::__throw_bad_optional_access[abi:ne180100]();
                    }
                    v113[0] = 0;
                    char v114 = 0;
                    uint64_t v43 = +[ULDefaultsSingleton shared];
                    uint64_t v44 = [v43 defaultsDictionary];

                    char v45 = [NSString stringWithUTF8String:"ULClusterAnchorValueStatisticsEnabled"];
                    long long v46 = [v44 objectForKey:v45];
                    if (v46 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
                      int v47 = [v46 BOOLValue];
                    }
                    else {
                      int v47 = [MEMORY[0x263EFFA88] BOOLValue];
                    }
                    int v53 = v47;

                    if (v53) {
                      std::optional<CLMicroLocationAnchorValueStatisticsMap>::emplace[abi:ne180100]<CLMicroLocationModel &,CLMicroLocationFingerprintPool &,void>((CLMicroLocationAnchorValueStatisticsMap *)v113, (CLMicroLocationModel *)buf, (CLMicroLocationFingerprintPool *)v130);
                    }
                    uint64_t v54 = v122;
                    for (uint64_t j = v123; v54 != j; v54 += 48)
                    {
                      unint64_t v56 = CLMiLoService::uint64ToLocationTypesBitset(*(void *)(v54 + 40));
                      if (v39 >= 0x20) {
                        std::__throw_out_of_range[abi:ne180100]("bitset test argument out of range");
                      }
                      if ((v56 & (1 << v39)) != 0)
                      {
                        if (onceToken_MicroLocation_Default != -1) {
                          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
                        }
                        v57 = (id)logObject_MicroLocation_Default;
                        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v58 = v54;
                          if (*(char *)(v54 + 23) < 0) {
                            uint64_t v58 = *(void *)v54;
                          }
                          v59 = operator new(0x28uLL);
                          v141 = (void **)v59;
                          uuid v142 = (uuid)xmmword_256514540;
                          _OWORD *v59 = 0u;
                          v59[1] = 0u;
                          *(void *)((char *)v59 + 29) = 0;
                          boost::uuids::to_chars<char *>(v54 + 24, v59);
                          if ((v142.var0[15] & 0x80u) == 0) {
                            __int16 v60 = (void **)&v141;
                          }
                          else {
                            __int16 v60 = v141;
                          }
                          v61 = (char *)operator new(0x28uLL);
                          *(void *)v139 = v61;
                          long long v140 = xmmword_256514540;
                          *(_OWORD *)v61 = 0u;
                          *((_OWORD *)v61 + 1) = 0u;
                          *(void *)(v61 + 29) = 0;
                          boost::uuids::to_chars<char *>(v36 + 24, v61);
                          uint64_t v62 = v139;
                          if (v140 < 0) {
                            uint64_t v62 = *(uint8_t **)v139;
                          }
                          uint64_t v63 = v36 + 40;
                          if (*(char *)(v36 + 63) < 0) {
                            uint64_t v63 = *v104;
                          }
                          *(_DWORD *)v155 = 68290050;
                          *(_DWORD *)&v155[4] = 0;
                          *(_WORD *)&v155[8] = 2082;
                          *(void *)&v155[10] = "";
                          *(_WORD *)&v155[18] = 2082;
                          *(void *)&v155[20] = v58;
                          *(_WORD *)&v155[28] = 2082;
                          *(void *)&v155[30] = v60;
                          *(_WORD *)&v155[38] = 2082;
                          *(void *)&v155[40] = v62;
                          LOWORD(v156) = 2082;
                          *(void *)((char *)&v156 + 2) = v63;
                          _os_log_impl(&dword_25631F000, v57, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"learning a Location Similarity List model for client\", \"ClientId\":%{public, location:escape_only}s, \"serviceUUID\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", v155, 0x3Au);
                          if (SHIBYTE(v140) < 0) {
                            operator delete(*(void **)v139);
                          }
                          if ((char)v142.var0[15] < 0) {
                            operator delete(v141);
                          }
                        }

                        if (log)
                        {
                          v64 = [MEMORY[0x263EFF9A0] dictionaryWithDictionary:log];
                          uint64_t v65 = v54;
                          if (*(char *)(v54 + 23) < 0) {
                            uint64_t v65 = *(void *)v54;
                          }
                          v66 = [NSString stringWithUTF8String:v65];
                          [v64 setObject:v66 forKeyedSubscript:@"clientIdentifier"];
                        }
                        else
                        {
                          v64 = 0;
                        }
                        id v67 = *(id *)(*((void *)v108 + 4) + 72);
                        v68 = v67;
                        long long v145 = *(_OWORD *)(v54 + 24);
                        char v146 = 1;
                        long long v143 = *(_OWORD *)(v36 + 24);
                        char v144 = 1;
                        if (v67)
                        {
                          [v67 fetchMostRecentModelOfModelType:2 ForService:&v145 atLoiGroupId:&v143];
                        }
                        else
                        {
                          memset(v171, 0, sizeof(v171));
                          long long v170 = 0u;
                          long long v169 = 0u;
                          long long v168 = 0u;
                          long long v167 = 0u;
                          long long v166 = 0u;
                          long long v165 = 0u;
                          long long v164 = 0u;
                          long long v163 = 0u;
                          long long v162 = 0u;
                          long long v161 = 0u;
                          long long v160 = 0u;
                          long long v159 = 0u;
                          long long v158 = 0u;
                          long long v157 = 0u;
                          long long v156 = 0u;
                          memset(v155, 0, sizeof(v155));
                        }

                        LOBYTE(v110) = 0;
                        char v112 = 0;
                        if (BYTE8(v171[1]))
                        {
                          unint64_t v110 = HIDWORD(v161) | ((unint64_t)BYTE8(v161) << 32);
                          uint64_t v111 = *(void *)&v155[16];
                          char v112 = 1;
                        }
                        std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::reset[abi:ne180100]((uint64_t)v155);
                        memset(v109, 0, sizeof(v109));
                        std::vector<CLMicroLocationProto::EventType>::__init_with_size[abi:ne180100]<CLMicroLocationProto::EventType*,CLMicroLocationProto::EventType*>(v109, v134, (uint64_t)v135, (v135 - (unsigned char *)v134) >> 2);
                        CLMicroLocationLearner::learnLocationSimilarityListModel((uint64_t)v108, v64, v7, a2, (uint64_t *)v54, (uint64_t)buf, (uint64_t *)(v36 + 24), (uint64_t)v109);
                      }
                    }
                    if (v114) {
                      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::~__hash_table((uint64_t)v113);
                    }
                    uint64_t v35 = (uint64_t)v108;
                  }
                  else
                  {
                    if (onceToken_MicroLocation_Default != -1) {
                      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
                    }
                    id v48 = logObject_MicroLocation_Default;
                    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)v155 = 68289026;
                      *(_DWORD *)&v155[4] = 0;
                      *(_WORD *)&v155[8] = 2082;
                      *(void *)&v155[10] = "";
                      _os_log_impl(&dword_25631F000, v48, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, unsupervised model not created or is invalid so learning is skipped\"}", v155, 0x12u);
                    }
                  }
                  std::__optional_destruct_base<CLMicroLocationModel,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
                  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v115);
                  *(void *)std::string buf = v121;
                  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
                }
                else
                {
                  if (onceToken_MicroLocation_Default != -1) {
                    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
                  }
                  long long v49 = (id)logObject_MicroLocation_Default;
                  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
                  {
                    double v50 = (char *)operator new(0x28uLL);
                    *(void *)v155 = v50;
                    *(_OWORD *)&v155[8] = xmmword_256514540;
                    *(_OWORD *)double v50 = 0u;
                    *((_OWORD *)v50 + 1) = 0u;
                    *(void *)(v50 + 29) = 0;
                    boost::uuids::to_chars<char *>(v36 + 24, v50);
                    double v51 = v155;
                    if ((v155[23] & 0x80u) != 0) {
                      double v51 = *(uint8_t **)v155;
                    }
                    uint64_t v52 = v36 + 40;
                    if (*(char *)(v36 + 63) < 0) {
                      uint64_t v52 = *v104;
                    }
                    *(_DWORD *)std::string buf = 68289538;
                    *(_DWORD *)&uint8_t buf[4] = 0;
                    *(_WORD *)v148 = 2082;
                    *(void *)&v148[2] = "";
                    *(_WORD *)&v148[10] = 2082;
                    *(void *)&v148[12] = v51;
                    *(_WORD *)&v148[20] = 2082;
                    *(void *)&v148[22] = v52;
                    _os_log_impl(&dword_25631F000, v49, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location Similarity List model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
                    if ((char)v155[23] < 0) {
                      operator delete(*(void **)v155);
                    }
                  }

                  uint64_t v35 = (uint64_t)v108;
                }
              }
            }

            *(void *)std::string buf = &v122;
            std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
          }
          else
          {
            v72 = _CLLogObjectForCategory_MicroLocation_Default();
            if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)std::string buf = 68289282;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)v148 = 2082;
              *(void *)&v148[2] = "";
              *(_WORD *)&v148[10] = 2050;
              *(void *)&v148[12] = v138;
              _os_log_impl(&dword_25631F000, v72, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"invalid model type\", \"model type\":%{public}lu}", buf, 0x1Cu);
            }

            v73 = _CLLogObjectForCategory_MicroLocation_Default();
            if (os_signpost_enabled(v73))
            {
              *(_DWORD *)std::string buf = 68289282;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)v148 = 2082;
              *(void *)&v148[2] = "";
              *(_WORD *)&v148[10] = 2050;
              *(void *)&v148[12] = v138;
              _os_signpost_emit_with_name_impl(&dword_25631F000, v73, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "invalid model type", "{\"msg%{public}.0s\":\"invalid model type\", \"model type\":%{public}lu}", buf, 0x1Cu);
            }
          }
        }
        else
        {
          id v70 = *(id *)(*((void *)v108 + 4) + 96);
          uint64_t v71 = v70;
          if (v70)
          {
            [v70 fetchAllServicesForServiceType:1];
          }
          else
          {
            long long v140 = 0uLL;
            *(void *)v139 = 0;
          }

          v74 = (uint64_t *)&v116;
          v116 = 0;
          uint64_t v117 = 0;
          v115 = (uint64_t *)&v116;
          v75 = *(uint64_t **)v139;
          v76 = (uint64_t *)v140;
          while (v75 != v76)
          {
            uint64_t v78 = *v75;
            uint64_t v77 = (uint64_t)(v75 + 4);
            CLMiLoService::modelClientIdentifierStringForServiceTypeAndClientId(v78, v77, (std::string *)buf);
            std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(&v115, (const void **)buf, (uint64_t)buf);
            if ((v148[15] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            v75 = (uint64_t *)(v77 + 56);
          }
          v79 = _CLLogObjectForCategory_MicroLocation_Default();
          if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 68289538;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)v148 = 2082;
            *(void *)&v148[2] = "";
            *(_WORD *)&v148[10] = 2050;
            *(void *)&v148[12] = v117;
            *(_WORD *)&v148[20] = 2050;
            *(void *)&v148[22] = (v128 - v127) >> 6;
            _os_log_impl(&dword_25631F000, v79, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning Unsupervised Model for clients\", \"Num Clients\":%{public}lu, \"Num LOIs\":%{public}lu}", buf, 0x26u);
          }

          uint64_t v80 = v127;
          for (uint64_t k = v128; v80 != k; v80 += 64)
          {
            v81 = (void ***)(v80 + 40);
            uint64_t v82 = CLMiLoServiceManager::rtLoiStringToLocationType((uint64_t *)(v80 + 40));
            if (v83) {
              BOOL v84 = v82 == 0;
            }
            else {
              BOOL v84 = 0;
            }
            if (v84)
            {
              v125 = 0;
              uint64_t v126 = 0;
              v124 = 0;
              std::vector<CLMicroLocationProto::EventType>::__init_with_size[abi:ne180100]<CLMicroLocationProto::EventType*,CLMicroLocationProto::EventType*>(&v124, v134, (uint64_t)v135, (v135 - (unsigned char *)v134) >> 2);
              CLMicroLocationLearner::selectRecordingEventTriggersForLearningMeasurementsWithTransition((uint64_t)v108, (uint64_t)&v124, *(void *)(v80 + 24), *(void *)(v80 + 32), (uint64_t)v113);
              if (v124)
              {
                v125 = v124;
                operator delete(v124);
              }
              CLMicroLocationLearner::getAnchorAppearanceMapForLoi((uint64_t)v108, (_OWORD *)(v80 + 24), (uint64_t)&v141);
              uint64_t v88 = v115;
              if (v115 != v74)
              {
                do
                {
                  buf[0] = 0;
                  v148[16] = 0;
                  v89 = CLMicroLocationCoreAnalyticsPublishHelper::initializeModelLearningEventMetricsDict(v136, v138, (const std::string *)buf);
                  if (v148[16] && (v148[15] & 0x80000000) != 0) {
                    operator delete(*(void **)buf);
                  }
                  if (onceToken_MicroLocation_Default != -1) {
                    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
                  }
                  v90 = (id)logObject_MicroLocation_Default;
                  if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
                  {
                    v91 = v74;
                    v92 = v88 + 4;
                    if (*((char *)v88 + 55) < 0) {
                      v92 = (uint64_t *)v88[4];
                    }
                    v93 = (char *)operator new(0x28uLL);
                    *(void *)v155 = v93;
                    *(_OWORD *)&v155[8] = xmmword_256514540;
                    *(_OWORD *)v93 = 0u;
                    *((_OWORD *)v93 + 1) = 0u;
                    *(void *)(v93 + 29) = 0;
                    boost::uuids::to_chars<char *>(v80 + 24, v93);
                    v94 = v155;
                    if ((v155[23] & 0x80u) != 0) {
                      v94 = *(uint8_t **)v155;
                    }
                    v95 = (void **)(v80 + 40);
                    if (*(char *)(v80 + 63) < 0) {
                      v95 = *v81;
                    }
                    *(_DWORD *)std::string buf = 68289794;
                    *(_DWORD *)&uint8_t buf[4] = 0;
                    *(_WORD *)v148 = 2082;
                    *(void *)&v148[2] = "";
                    *(_WORD *)&v148[10] = 2082;
                    *(void *)&v148[12] = v92;
                    *(_WORD *)&v148[20] = 2082;
                    *(void *)&v148[22] = v94;
                    *(_WORD *)&v148[30] = 2082;
                    v149 = v95;
                    _os_log_impl(&dword_25631F000, v90, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning Unsupervised Model for client\", \"Client ID\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x30u);
                    if ((char)v155[23] < 0) {
                      operator delete(*(void **)v155);
                    }
                    v74 = v91;
                  }

                  CLMicroLocationLearner::getMostRecentMagicalMomentsModelForClientAtLoi((uint64_t)v108, (uint64_t)(v88 + 4), *(void *)(v80 + 24), *(void *)(v80 + 32), buf);
                  CLMicroLocationLearner::learnMagicalMomentsModel((uint64_t)v108, v89, (uint64_t)v113, a2, (const CLMicroLocationProto::Model *)v130, (uint64_t)(v88 + 4), (void *)(v80 + 24), v155, (uint64_t)buf);
                  if (BYTE8(v171[1]))
                  {
                    *(_OWORD *)((char *)v171 + 1) = *(_OWORD *)(v80 + 24);
                    std::optional<CLMicroLocationModelTable::Entry>::operator=[abi:ne180100]<CLMicroLocationModelTable::Entry,void>((uint64_t)__p, (uint64_t)v155);
                    std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::reset[abi:ne180100]((uint64_t)v155);
                  }
                  if (v89)
                  {
                    int v96 = v133;
                    id v97 = v89;
                    if (v96)
                    {
                      id v98 = v132;
                      id v132 = v97;
                    }
                    else
                    {
                      id v132 = v97;
                      unsigned __int8 v133 = 1;
                    }
                  }
                  CLMicroLocationLearner::learnFromModelType(std::function<BOOL ()(void)>,CLMicroLocationProto::Model_ModelType)::$_0::operator()(v129);
                  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v155);
                  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);

                  v99 = (uint64_t *)v88[1];
                  if (v99)
                  {
                    do
                    {
                      v100 = v99;
                      v99 = (uint64_t *)*v99;
                    }
                    while (v99);
                  }
                  else
                  {
                    do
                    {
                      v100 = (uint64_t *)v88[2];
                      BOOL v84 = *v100 == (void)v88;
                      uint64_t v88 = v100;
                    }
                    while (!v84);
                  }
                  uint64_t v88 = v100;
                }
                while (v100 != v74);
              }
              std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v141);
              *(void *)std::string buf = v113;
              std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
            }
            else
            {
              if (onceToken_MicroLocation_Default != -1) {
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
              }
              v85 = (id)logObject_MicroLocation_Default;
              if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
              {
                __int16 v86 = (char *)operator new(0x28uLL);
                *(void *)v155 = v86;
                *(_OWORD *)&v155[8] = xmmword_256514540;
                *(_OWORD *)__int16 v86 = 0u;
                *((_OWORD *)v86 + 1) = 0u;
                *(void *)(v86 + 29) = 0;
                boost::uuids::to_chars<char *>(v80 + 24, v86);
                uint64_t v87 = v155;
                if ((v155[23] & 0x80u) != 0) {
                  uint64_t v87 = *(uint8_t **)v155;
                }
                if (*(char *)(v80 + 63) < 0) {
                  v81 = (void ***)*v81;
                }
                *(_DWORD *)std::string buf = 68289538;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)v148 = 2082;
                *(void *)&v148[2] = "";
                *(_WORD *)&v148[10] = 2082;
                *(void *)&v148[12] = v87;
                *(_WORD *)&v148[20] = 2082;
                *(void *)&v148[22] = v81;
                _os_log_impl(&dword_25631F000, v85, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location Unsupervised model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
                if ((char)v155[23] < 0) {
                  operator delete(*(void **)v155);
                }
              }
            }
          }
          std::__tree<std::string>::destroy((uint64_t)&v115, v116);
          *(void *)std::string buf = v139;
          std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
        }
        int v31 = v108;
        goto LABEL_197;
      }
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      uint64_t v13 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v14 = "#Warning Tried to run learning, but database is not valid";
        goto LABEL_25;
      }
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      uint64_t v15 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::string buf = 67174657;
        *(_DWORD *)&uint8_t buf[4] = v138;
        uint64_t v14 = "Model Type %{private}d disabled in settings";
        BOOL v16 = v15;
        os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
        uint32_t v18 = 8;
LABEL_26:
        _os_log_impl(&dword_25631F000, v16, v17, v14, buf, v18);
      }
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v13 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v14 = "#Warning Tried to run learning, but learning is disabled";
LABEL_25:
      BOOL v16 = v13;
      os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
      uint32_t v18 = 2;
      goto LABEL_26;
    }
  }
}

void sub_2563D932C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (LOBYTE(STACK[0x4A8]) && SLOBYTE(STACK[0x4A7]) < 0) {
    operator delete((void *)STACK[0x490]);
  }
  STACK[0x490] = (unint64_t)&a66;
  std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x490]);
  STACK[0x490] = (unint64_t)&a72;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x490]);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::~__hash_table((uint64_t)&STACK[0x240]);
  if (LOBYTE(STACK[0x278])) {

  }
  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&STACK[0x7A0]);
  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&STACK[0x818]);
  v73 = (void *)STACK[0x280];
  if (STACK[0x280])
  {
    STACK[0x288] = (unint64_t)v73;
    operator delete(v73);
  }
  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::EnableLearning>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  int v2 = [NSString stringWithUTF8String:"ULEnableLearning"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 BOOLValue];
  }
  else {
    uint64_t v4 = [MEMORY[0x263EFFA88] BOOLValue];
  }
  uint64_t v5 = v4;

  return v5;
}

void sub_2563D9844(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ULSettings::get<ULSettings::EnabledModelTypes>(uint64_t a1@<X8>)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v2 = +[ULDefaultsSingleton shared];
  uint64_t v3 = [v2 defaultsDictionary];

  uint64_t v4 = [NSString stringWithUTF8String:"ULEnabledModelTypes"];
  uint64_t v5 = [v3 objectForKey:v4];
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    id v6 = v5;
    long long v14 = 0uLL;
    uint64_t v13 = 0;
    std::vector<BOOL>::reserve(&v13, [v6 count]);
    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    id v7 = v6;
    uint64_t v8 = [v7 countByEnumeratingWithState:&v16 objects:&v20 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v17;
      do
      {
        uint64_t v10 = 0;
        do
        {
          if (*(void *)v17 != v9) {
            objc_enumerationMutation(v7);
          }
          char v15 = [*(id *)(*((void *)&v16 + 1) + 8 * v10) BOOLValue];
          std::vector<BOOL>::push_back((uint64_t)&v13, &v15);
          ++v10;
        }
        while (v8 != v10);
        uint64_t v8 = [v7 countByEnumeratingWithState:&v16 objects:&v20 count:16];
      }
      while (v8);
    }

    *(void *)a1 = v13;
    *(_OWORD *)(a1 + 8) = v14;
  }
  else
  {
    long long v20 = 0;
    long long v21 = 0uLL;
    std::vector<BOOL>::reserve(&v20, 4uLL);
    for (uint64_t i = 0; i != 4; ++i)
    {
      LOBYTE(v16) = _ZGRN10ULSettings14SettingsTraitsINS_17EnabledModelTypesEE12defaultValueE_[i];
      std::vector<BOOL>::push_back((uint64_t)&v20, &v16);
    }
    long long v12 = v21;
    *(void *)a1 = v20;
    *(_OWORD *)(a1 + 8) = v12;
  }
}

void sub_2563D9A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_2563D9BE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::selectRecordingEventTriggersForLearningMeasurementsWithTransition(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  *(void *)&long long v16 = a3;
  *((void *)&v16 + 1) = a4;
  id v8 = *(id *)(*(void *)(a1 + 32) + 88);
  uint64_t v9 = v8;
  long long v14 = v16;
  LOBYTE(v15) = 1;
  if (v8)
  {
    [v8 fetchRecordingEventTriggersForLearningMeasurements:a2 atLoiGroupId:&v14];
  }
  else
  {
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
  }

  if (v16 != 0)
  {
    id v10 = *(id *)(*(void *)(a1 + 32) + 88);
    BOOL v11 = v10;
    v12[0] = 0;
    v12[1] = 0;
    char v13 = 1;
    if (v10)
    {
      [v10 fetchRecordingEventTriggersForLearningMeasurements:a2 atLoiGroupId:v12];
    }
    else
    {
      long long v14 = 0uLL;
      uint64_t v15 = 0;
    }

    std::vector<CLMicroLocationRecordingEventsTable::Entry>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationRecordingEventsTable::Entry*>,std::__wrap_iter<CLMicroLocationRecordingEventsTable::Entry*>>((uint64_t *)a5, *(long long **)(a5 + 8), (long long *)v14, *((long long **)&v14 + 1), 0xEF7BDEF7BDEF7BDFLL * ((uint64_t)(*((void *)&v14 + 1) - v14) >> 3));
    v12[0] = (void **)&v14;
    std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](v12);
  }
}

void sub_2563D9D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);

  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::getMostRecentMagicalMomentsModelForClientAtLoi(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  id v9 = *(id *)(*(void *)(a1 + 32) + 72);
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  if (v9)
  {
    objc_msgSend(v9, "fetchMostRecentMagicalMomentsModelForClient:atLoiGroupId:", &__p, a3, a4);
  }
  else
  {
    a5[18] = 0u;
    a5[19] = 0u;
    a5[16] = 0u;
    a5[17] = 0u;
    a5[14] = 0u;
    a5[15] = 0u;
    a5[12] = 0u;
    a5[13] = 0u;
    a5[10] = 0u;
    a5[11] = 0u;
    a5[8] = 0u;
    a5[9] = 0u;
    a5[6] = 0u;
    a5[7] = 0u;
    a5[4] = 0u;
    a5[5] = 0u;
    a5[2] = 0u;
    a5[3] = 0u;
    *a5 = 0u;
    a5[1] = 0u;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2563D9E84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::learnMagicalMomentsModel(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const CLMicroLocationProto::Model *a5@<X5>, uint64_t a6@<X6>, void *a7@<X7>, unsigned char *a8@<X8>, uint64_t a9)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  id v16 = a2;
  *a8 = 0;
  a8[312] = 0;
  double v17 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationLearner::learnMagicalMomentsModelInternal(a1, v16, a3, a4, a5, (uint64_t)a7, a9, v31, v17, 0);
  if (v43 && CLMicroLocationModel::isValid((CLMicroLocationModel *)v31))
  {
    if (onceToken_MicroLocationQE_Default != -1) {
      dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_523);
    }
    long long v18 = (id)logObject_MicroLocationQE_Default;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = CLMicroLocationModel::numRecordingsBeforePruning((CLMicroLocationModel *)v31);
      uint64_t v20 = v42;
      uint64_t v21 = v41;
      uint64_t v22 = CLMicroLocationModel::numClusters((CLMicroLocationModel *)v31);
      *(_DWORD *)std::string buf = 68292098;
      int v46 = 0;
      __int16 v47 = 2082;
      id v48 = "";
      __int16 v49 = 2050;
      uint64_t v50 = v19;
      __int16 v51 = 2050;
      uint64_t v52 = (v20 - v21) >> 5;
      __int16 v53 = 2050;
      uint64_t v54 = v22;
      __int16 v55 = 1026;
      int v56 = v32;
      __int16 v57 = 2050;
      uint64_t v58 = v33;
      __int16 v59 = 1026;
      int v60 = v34;
      __int16 v61 = 1026;
      int v62 = v35;
      __int16 v63 = 1026;
      int v64 = v37;
      __int16 v65 = 1026;
      int v66 = v36;
      __int16 v67 = 1026;
      int v68 = v38;
      __int16 v69 = 1026;
      int v70 = v39;
      __int16 v71 = 1026;
      int v72 = v40;
      _os_log_impl(&dword_25631F000, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Microlocation model learned\", \"numFingerprints before pruning\":%{public}lu, \"numFingerprints after pruning\":%{public}lu, \"numClusters\":%{public}lu, \"type\":%{public}d, \"numAnchors\":%{public}lu, \"Number of Recording triggers at current LOI\":%{public}u, \"Number of Input Valid Fingerprints\":%{public}u, \"Number of Input Valid Fingerprints Labeled\":%{public}u, \"Number of Input Valid Fingerprints Unlabeled\":%{public}u, \"Number of WiFi Access Points\":%{public}u, \"Number of Ble Sources\":%{public}u, \"Number of Uwb Sources\":%{public}u}", buf, 0x6Au);
    }

    int v30 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v30);
    uint64_t v23 = boost::uuids::random_generator_pure::operator()((uint64_t)&v30);
    uint64_t v25 = v24;
    CLMicroLocationModel::toProtobuf((CLMicroLocationModel *)v31, (uint64_t)v29);
    if (*(char *)(a6 + 23) < 0) {
      std::string::__init_copy_ctor_external(&v27, *(const std::string::value_type **)a6, *(void *)(a6 + 8));
    }
    else {
      std::string v27 = *(std::string *)a6;
    }
    char v28 = 1;
    v44[0] = 0;
    v44[16] = 0;
    CLMicroLocationModelTable::Entry::Entry(buf, v23, v25, v29, &v27, v44, *a7, a7[1], v17);
    std::optional<CLMicroLocationModelTable::Entry>::operator=[abi:ne180100]<CLMicroLocationModelTable::Entry,void>((uint64_t)a8, (uint64_t)buf);
    if (v75 && v74 < 0) {
      operator delete(__p);
    }
    CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)((char *)&v52 + 2));
    if (v28 && SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v27.__r_.__value_.__l.__data_);
    }
    CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)v29);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v30);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    BOOL v26 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67240192;
      int v46 = 0;
      _os_log_impl(&dword_25631F000, v26, OS_LOG_TYPE_DEFAULT, "No models were generated for model type %{public}d", buf, 8u);
    }
  }
  std::__optional_destruct_base<CLMicroLocationModel,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v31);
}

void sub_2563DA240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,int a42,char a43,__int16 a44,char a45)
{
  CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)&a16);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a43);
  std::__optional_destruct_base<CLMicroLocationModel,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a45);
  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100](v46);

  _Unwind_Resume(a1);
}

uint64_t std::optional<CLMicroLocationModelTable::Entry>::operator=[abi:ne180100]<CLMicroLocationModelTable::Entry,void>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 312))
  {
    CLMicroLocationModelTable::Entry::operator=(a1, a2);
  }
  else
  {
    CLMicroLocationModelTable::Entry::Entry(a1, a2);
    *(unsigned char *)(a1 + 312) = 1;
  }
  return a1;
}

uint64_t std::optional<NSMutableDictionary * {__strong}>::operator=[abi:ne180100]<NSMutableDictionary * {__strong}&,void>(uint64_t a1, id *a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 8);
  id v4 = *a2;
  if (v3)
  {
    uint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
  }
  else
  {
    *(void *)a1 = v4;
    *(unsigned char *)(a1 + 8) = 1;
  }
  return a1;
}

void CLMicroLocationLearner::learnFromModelType(std::function<BOOL ()(void)>,CLMicroLocationProto::Model_ModelType)::$_0::operator()(uint64_t *a1)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v2 = *a1;
  if (!*(unsigned char *)(a1[3] + 312)) {
    goto LABEL_10;
  }
  ++*(_DWORD *)v2;
  id v3 = *(id *)(*(void *)(v2 + 32) + 72);
  id v4 = (const CLMicroLocationModelTable::Entry *)a1[3];
  if (!*((unsigned char *)v4 + 312)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  CLMicroLocationModelTable::Entry::Entry((CLMicroLocationModelTable::Entry *)buf, v4);
  int v35 = 0;
  long long v36 = 0uLL;
  LOBYTE(v34) = 0;
  int v35 = operator new(0x138uLL);
  *(void *)&long long v36 = v35;
  *((void *)&v36 + 1) = (char *)v35 + 312;
  *(void *)&long long v36 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry*>((uint64_t)&v36 + 8, (CLMicroLocationModelTable::Entry *)buf, (CLMicroLocationModelTable::Entry *)&v45, (CLMicroLocationModelTable::Entry *)v35);
  char v5 = objc_msgSend(v3, "insertEntries:", &v35, &v35, (void)v34);
  uint64_t v33 = &v35;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&v33);
  if (v44 && v43 < 0) {
    operator delete(__p);
  }
  CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)&v38[24]);

  if (v5)
  {
    uint64_t v6 = a1[3];
    if (!*(unsigned char *)(v6 + 312)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    if (*(unsigned char *)(v6 + 288))
    {
      id v7 = operator new(0x28uLL);
      int v35 = v7;
      long long v36 = xmmword_256514540;
      _OWORD *v7 = 0u;
      v7[1] = 0u;
      *(void *)((char *)v7 + 29) = 0;
      boost::uuids::to_chars<char *>(v6 + 272, v7);
    }
    else
    {
      int v35 = 0;
      long long v36 = 0uLL;
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    id v9 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = a1[3];
      if (!*(unsigned char *)(v10 + 312)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      int v11 = *(_DWORD *)a1[1];
      long long v12 = operator new(0x28uLL);
      uint64_t v33 = v12;
      long long v34 = xmmword_256514540;
      *long long v12 = 0u;
      v12[1] = 0u;
      *(void *)((char *)v12 + 29) = 0;
      boost::uuids::to_chars<char *>(v10, v12);
      char v13 = &v33;
      if (v34 < 0) {
        char v13 = v33;
      }
      long long v14 = &v35;
      if (v36 < 0) {
        long long v14 = v35;
      }
      *(_DWORD *)std::string buf = 67240707;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)int v38 = 2081;
      *(void *)&v38[2] = v13;
      *(_WORD *)&v38[10] = 2081;
      *(void *)&v38[12] = v14;
      _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_DEFAULT, "Model generated successfully for model type %{public}d, with model ID %{private}s， for service ID %{private}s", buf, 0x1Cu);
      if (SHIBYTE(v34) < 0) {
        operator delete(v33);
      }
    }

    if (SHIBYTE(v36) < 0) {
      operator delete(v35);
    }
  }
  else
  {
LABEL_10:
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    id v8 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = 0;
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_DEFAULT, "#Warning Model was not generated properly. Inserted: %{public,BOOL}d", buf, 8u);
    }
  }
  if (*(unsigned char *)(a1[4] + 112))
  {
    id v15 = *(id *)(*(void *)(v2 + 32) + 32);
    uint64_t v16 = a1[4];
    if (!*(unsigned char *)(v16 + 112)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    *(void *)std::string buf = *(void *)v16;
    if (*(char *)(v16 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)v38, *(const std::string::value_type **)(v16 + 8), *(void *)(v16 + 16));
    }
    else
    {
      long long v17 = *(_OWORD *)(v16 + 8);
      *(void *)&v38[16] = *(void *)(v16 + 24);
      *(_OWORD *)int v38 = v17;
    }
    long long v18 = *(_OWORD *)(v16 + 32);
    int v39 = *(_DWORD *)(v16 + 48);
    *(_OWORD *)&v38[24] = v18;
    CLMicroLocationProto::Configuration::Configuration((CLMicroLocationProto::Configuration *)v40, (const CLMicroLocationProto::Configuration *)(v16 + 56));
    int v35 = 0;
    long long v36 = 0uLL;
    uint64_t v33 = &v35;
    LOBYTE(v34) = 0;
    int v35 = operator new(0x70uLL);
    *(void *)&long long v36 = v35;
    *((void *)&v36 + 1) = (char *)v35 + 112;
    *(void *)&long long v36 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry const*,CLMicroLocationConfigurationTable::Entry const*,CLMicroLocationConfigurationTable::Entry*>((uint64_t)&v36 + 8, (uint64_t)buf, (uint64_t)&v41, (uint64_t)v35);
    int v19 = [v15 insertEntries:&v35];
    uint64_t v33 = &v35;
    std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&v33);
    CLMicroLocationProto::Configuration::~Configuration((CLMicroLocationProto::Configuration *)v40);
    if ((v38[23] & 0x80000000) != 0) {
      operator delete(*(void **)v38);
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v20 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = *(unsigned int *)a1[1];
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)int v38 = 2082;
      *(void *)&v38[2] = "";
      *(_WORD *)&v38[10] = 2050;
      *(void *)&v38[12] = v21;
      *(_WORD *)&v38[20] = 1026;
      *(_DWORD *)&v38[22] = v19;
      _os_log_impl(&dword_25631F000, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Configuration generated\", \"ModelType\":%{public}lu, \"Inserted\":%{public}hhd}", buf, 0x22u);
    }
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  uint64_t v22 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = *(unsigned __int8 *)a1[2];
    uint64_t v24 = *(unsigned int *)a1[1];
    uint64_t v25 = *(unsigned __int8 *)(a1[5] + 8);
    *(_DWORD *)std::string buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)int v38 = 2082;
    *(void *)&v38[2] = "";
    *(_WORD *)&v38[10] = 1026;
    *(_DWORD *)&v38[12] = v23;
    *(_WORD *)&v38[16] = 2050;
    *(void *)&v38[18] = v24;
    *(_WORD *)&v38[26] = 2050;
    *(void *)&v38[28] = v25;
    _os_log_impl(&dword_25631F000, v22, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"sending CoreAnalytics com.apple.MicroLocation.ModelLearning\", \"sending enabled\":%{public}hhd, \"model type\":%{public}lu, \"has_value\":%{public}lu}", buf, 0x2Cu);
  }
  if (*(unsigned char *)a1[2])
  {
    uint64_t v26 = a1[5];
    if (*(unsigned char *)(v26 + 8)) {
      +[ULSendEvent sendEvent:*(void *)v26 withEventName:@"com.apple.MicroLocation.ModelLearning"];
    }
  }
  uint64_t v27 = *(void *)(v2 + 24);
  uint64_t v28 = *(unsigned int *)a1[1];
  uint64_t v29 = a1[3];
  uint64_t v30 = a1[5];
  *(void *)std::string buf = 0;
  int v31 = std::optional<NSMutableDictionary * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v30);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v27 + 24))(v27, v28, v29, v31);

  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::reset[abi:ne180100](a1[3]);
  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::reset[abi:ne180100](a1[4]);
  uint64_t v32 = a1[5];
  if (*(unsigned char *)(v32 + 8))
  {

    *(unsigned char *)(v32 + 8) = 0;
  }
}

void sub_2563DA9CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  operator delete(v25);

  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::getAllClientsAndSupportedLocationTypes(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t *a4@<X8>)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  id v8 = *(id *)(*(void *)(a1 + 32) + 40);
  id v9 = v8;
  if (v8)
  {
    [v8 getAllRecordingLabelsClientIds];
  }
  else
  {
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
  }

  id v10 = *(id *)(*(void *)(a1 + 32) + 96);
  int v11 = v10;
  if (v10)
  {
    [v10 fetchAllServicesForServiceType:a2];
  }
  else
  {
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    uint64_t v30 = 0;
  }

  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  long long v12 = v29;
  if (v28 != v29)
  {
    char v13 = a3 ^ 1;
    long long v14 = v28 + 16;
    do
    {
      CLMicroLocationClientUtils::getClientIdAndServiceUuid((const void **)v14, (uint64_t)(v14 - 12), &__p);
      uint64_t v15 = std::__find_impl[abi:ne180100]<std::string const*,std::string const*,std::string,std::__identity>(v31, v32, (unsigned __int8 **)&__p);
      uint64_t v16 = v32;
      int v17 = *((char *)v14 + 23);
      if (v17 < 0)
      {
        if (*((void *)v14 + 1) != 10) {
          goto LABEL_18;
        }
        long long v18 = *(unsigned __int16 **)v14;
      }
      else
      {
        long long v18 = v14;
        if (v17 != 10) {
          goto LABEL_18;
        }
      }
      uint64_t v19 = *(void *)v18;
      int v20 = v18[4];
      if (v19 == 0x6F6D2D7375636F66 && v20 == 25956)
      {
        uint64_t v25 = std::__find_impl[abi:ne180100]<std::string const*,std::string const*,std::string,std::__identity>(v31, v32, (unsigned __int8 **)v14);
        BOOL v22 = v25 != v32;
        goto LABEL_19;
      }
LABEL_18:
      BOOL v22 = 0;
LABEL_19:
      if (v15 == v16) {
        char v23 = v13;
      }
      else {
        char v23 = 1;
      }
      if ((v23 & 1) != 0 || v22)
      {
        if (*((char *)v14 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v37, *(const std::string::value_type **)v14, *((void *)v14 + 1));
        }
        else
        {
          long long v24 = *(_OWORD *)v14;
          v37.__r_.__value_.__r.__words[2] = *((void *)v14 + 2);
          *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v24;
        }
        long long v38 = *(_OWORD *)(v14 - 12);
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external(&v34, v37.__r_.__value_.__l.__data_, v37.__r_.__value_.__l.__size_);
        }
        else {
          std::string v34 = v37;
        }
        long long v35 = v38;
        uint64_t v36 = *((void *)v14 + 3);
        std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::emplace_back<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>(a4, (long long *)&v34);
        if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v34.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v37.__r_.__value_.__l.__data_);
        }
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      uint64_t v26 = v14 + 28;
      v14 += 44;
    }
    while (v26 != v12);
  }
  v34.__r_.__value_.__r.__words[0] = (std::string::size_type)&v28;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&v34);
  v34.__r_.__value_.__r.__words[0] = (std::string::size_type)&v31;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v34);
}

void sub_2563DAD44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,char *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  a22 = &a19;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a22);
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::learnFromModelType(std::function<BOOL ()(void)>,CLMicroLocationProto::Model_ModelType)::$_1::operator()(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)a1;
  p_superclass = &OBJC_METACLASS___CLMicroLocationLoiBridge.superclass;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  id v7 = &OBJC_METACLASS___CLMicroLocationLoiBridge.superclass;
  id v8 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4);
    uint64_t v10 = (uint64_t)(*(void *)(*(void *)(a1 + 72) + 8) - **(void **)(a1 + 72)) >> 6;
    *(_DWORD *)std::string buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&unsigned char buf[18] = 1026;
    *(_DWORD *)&buf[20] = a3;
    *(_WORD *)&buf[24] = 2050;
    *(void *)&buf[26] = v9;
    *(_WORD *)&buf[34] = 2050;
    *(void *)&buf[36] = v10;
    _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning semi-supervised models for clients\", \"Model Generation Algo Type\":%{public}d, \"Num Clients\":%{public}lu, \"Num LOIs\":%{public}lu}", buf, 0x2Cu);
  }
  int v11 = *(uint64_t **)(a1 + 72);
  uint64_t v12 = *v11;
  uint64_t v37 = v11[1];
  if (*v11 != v37)
  {
    do
    {
      long long v38 = (void *)(v12 + 40);
      uint64_t v39 = v12;
      unint64_t v42 = CLMiLoServiceManager::rtLoiStringToLocationType((uint64_t *)(v12 + 40));
      uint64_t v40 = v39 + 24;
      if (v13)
      {
        uint64_t v14 = *a2;
        uint64_t v41 = a2[1];
        if (*a2 != v41)
        {
          do
          {
            unint64_t v15 = CLMiLoService::uint64ToLocationTypesBitset(*(void *)(v14 + 40));
            if (v42 > 0x1F) {
              std::__throw_out_of_range[abi:ne180100]("bitset test argument out of range");
            }
            if ((v15 & (1 << v42)) != 0)
            {
              if (p_superclass[429] != (__objc2_class *)-1) {
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
              }
              uint64_t v16 = v7[427];
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
              {
                int v17 = v7;
                long long v18 = p_superclass;
                uint64_t v19 = v5;
                uint64_t v20 = a3;
                uint64_t v21 = (const std::string::value_type *)v14;
                if (*(char *)(v14 + 23) < 0) {
                  uint64_t v21 = *(const std::string::value_type **)v14;
                }
                BOOL v22 = operator new(0x28uLL);
                uint64_t v45 = v22;
                long long v46 = xmmword_256514540;
                _OWORD *v22 = 0u;
                v22[1] = 0u;
                *(void *)((char *)v22 + 29) = 0;
                boost::uuids::to_chars<char *>(v14 + 24, v22);
                if (v46 >= 0) {
                  char v23 = &v45;
                }
                else {
                  char v23 = v45;
                }
                long long v24 = operator new(0x28uLL);
                std::string __p = v24;
                long long v44 = xmmword_256514540;
                *long long v24 = 0u;
                v24[1] = 0u;
                *(void *)((char *)v24 + 29) = 0;
                boost::uuids::to_chars<char *>(v40, v24);
                p_p = &__p;
                if (v44 < 0) {
                  p_p = __p;
                }
                uint64_t v26 = v38;
                if (*(char *)(v39 + 63) < 0) {
                  uint64_t v26 = (void *)*v38;
                }
                *(_DWORD *)std::string buf = 68290050;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)&uint8_t buf[8] = 2082;
                *(void *)&buf[10] = "";
                *(_WORD *)&unsigned char buf[18] = 2082;
                *(void *)&buf[20] = v21;
                *(_WORD *)&unsigned char buf[28] = 2082;
                *(void *)&buf[30] = v23;
                *(_WORD *)&buf[38] = 2082;
                *(void *)&buf[40] = p_p;
                __int16 v49 = 2082;
                uint64_t v50 = v26;
                _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"learning a semi-supervised model for client\", \"ClientId\":%{public, location:escape_only}s, \"serviceUUID\":%{public, location:escape_only}s, \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x3Au);
                if (SHIBYTE(v44) < 0) {
                  operator delete(__p);
                }
                a3 = v20;
                if (SHIBYTE(v46) < 0) {
                  operator delete(v45);
                }
                uint64_t v5 = v19;
                p_superclass = v18;
                id v7 = v17;
              }

              int v27 = **(unsigned __int8 **)(a1 + 24);
              int v28 = **(_DWORD **)(a1 + 16);
              if (*(char *)(v14 + 23) < 0)
              {
                std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)v14, *(void *)(v14 + 8));
              }
              else
              {
                long long v29 = *(_OWORD *)v14;
                *(void *)&uint8_t buf[16] = *(void *)(v14 + 16);
                *(_OWORD *)std::string buf = v29;
              }
              buf[24] = 1;
              uint64_t v30 = CLMicroLocationCoreAnalyticsPublishHelper::initializeModelLearningEventMetricsDict(v27 != 0, v28, (const std::string *)buf);
              uint64_t v45 = v30;
              if (buf[24] && (buf[23] & 0x80000000) != 0)
              {
                operator delete(*(void **)buf);
                uint64_t v30 = v45;
              }
              uint64_t v31 = *(void *)(a1 + 40);
              std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v47, *(void *)(a1 + 48));
              CLMicroLocationLearner::semiSupervisedLearnWrapper(v5, v14, v31, a3, v30, (uint64_t)v47, *(CLMicroLocationFingerprintPool **)(a1 + 56), buf, v40);
              std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v47);
              if (v51) {
                std::optional<CLMicroLocationModelTable::Entry>::operator=[abi:ne180100]<CLMicroLocationModelTable::Entry,void>(*(void *)(a1 + 64), (uint64_t)buf);
              }
              if (v45) {
                std::optional<NSMutableDictionary * {__strong}>::operator=[abi:ne180100]<NSMutableDictionary * {__strong}&,void>(*(void *)(a1 + 32), &v45);
              }
              CLMicroLocationLearner::learnFromModelType(std::function<BOOL ()(void)>,CLMicroLocationProto::Model_ModelType)::$_0::operator()(*(uint64_t **)(a1 + 8));
              std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
            }
            v14 += 48;
          }
          while (v14 != v41);
        }
      }
      else
      {
        if (p_superclass[429] != (__objc2_class *)-1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
        }
        uint64_t v32 = v7[427];
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = operator new(0x28uLL);
          uint64_t v45 = v33;
          long long v46 = xmmword_256514540;
          *uint64_t v33 = 0u;
          v33[1] = 0u;
          *(void *)((char *)v33 + 29) = 0;
          boost::uuids::to_chars<char *>(v40, v33);
          std::string v34 = &v45;
          if (v46 < 0) {
            std::string v34 = v45;
          }
          long long v35 = v38;
          if (*(char *)(v39 + 63) < 0) {
            long long v35 = (void *)*v38;
          }
          *(_DWORD *)std::string buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&unsigned char buf[18] = 2082;
          *(void *)&buf[20] = v34;
          *(_WORD *)&unsigned char buf[28] = 2082;
          *(void *)&buf[30] = v35;
          _os_log_impl(&dword_25631F000, v32, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"skipping Location semi-supervised model learning because of LOI\", \"loiGroupId\":%{public, location:escape_only}s, \"loiType\":%{public, location:escape_only}s}", buf, 0x26u);
          if (SHIBYTE(v46) < 0) {
            operator delete(v45);
          }
        }
      }
      uint64_t v12 = v39 + 64;
    }
    while (v39 + 64 != v37);
  }
}

void sub_2563DB39C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,char a44)
{
  operator delete(v45);

  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::learnMagicalMomentsModelInternal(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, const CLMicroLocationProto::Model *a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, unsigned char *a8@<X8>, double a9@<D0>, int a10)
{
  uint64_t v189 = *MEMORY[0x263EF8340];
  double v144 = a9;
  v116 = a2;
  int v11 = +[ULDefaultsSingleton shared];
  uint64_t v12 = [v11 defaultsDictionary];

  char v13 = [NSString stringWithUTF8String:"ULLearnerAlgorithm"];
  uint64_t v14 = [v12 objectForKey:v13];
  if (v14 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    unsigned int v15 = [v14 unsignedIntValue];
  }
  else {
    unsigned int v15 = [&unk_2704F1AE8 unsignedIntValue];
  }
  unsigned int v16 = v15;

  CLMicroLocationAlgorithms::createLearner(v16, &v143);
  int v17 = +[ULDefaultsSingleton shared];
  long long v18 = [v17 defaultsDictionary];

  uint64_t v19 = [NSString stringWithUTF8String:"ULNumberOfModelIterations"];
  uint64_t v20 = [v18 objectForKey:v19];
  if (v20 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    unsigned int v110 = [v20 unsignedIntValue];
  }
  else {
    unsigned int v110 = [&unk_2704F1A70 unsignedIntValue];
  }

  BOOL v22 = *(unint64_t **)a3;
  uint64_t v21 = *(void *)(a3 + 8);
  char v23 = +[ULDefaultsSingleton shared];
  long long v24 = [v23 defaultsDictionary];

  uint64_t v25 = [NSString stringWithUTF8String:"ULMinimumNumberOfRecordingsInStableModel"];
  uint64_t v26 = [v24 objectForKey:v25];
  if (v26 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    unint64_t v105 = [v26 unsignedLongValue];
  }
  else {
    unint64_t v105 = [&unk_2704F1AB8 unsignedLongValue];
  }

  v141 = 0;
  long long v140 = 0;
  uuid v142 = 0;
  std::vector<unsigned long>::reserve(&v140, v110);
  p_superclass = &OBJC_METACLASS___CLMicroLocationLoiBridge.superclass;
  if (onceToken_MicroLocationQE_Default != -1) {
    dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_523);
  }
  int v28 = (id)logObject_MicroLocationQE_Default;
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v29 = 0xEF7BDEF7BDEF7BDFLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
    uint64_t buf = 68290050;
    __int16 v171 = 2082;
    v172 = "";
    __int16 v173 = 1026;
    int v174 = a10;
    __int16 v175 = 1026;
    unsigned int v176 = v16;
    __int16 v177 = 1026;
    unsigned int v178 = v110;
    __int16 v179 = 2050;
    unint64_t v180 = v29;
    _os_log_impl(&dword_25631F000, v28, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning started\", \"modelType\":%{public}d, \"algorithmType\":%{public}d, \"numModelIters\":%{public}d, \"numRecordingTriggers\":%{public}lu}", (uint8_t *)&buf, 0x2Eu);
  }

  CLMicroLocationModel::CLMicroLocationModel((CLMicroLocationModel *)&buf);
  unint64_t v104 = 0xEF7BDEF7BDEF7BDFLL * ((v21 - (uint64_t)v22) >> 3);
  v167[0] = 0;
  char v169 = 0;
  if (!*(unsigned char *)(a7 + 312)) {
    goto LABEL_23;
  }
  CLMicroLocationModel::fromProtobuf((const CLMicroLocationProto::Fingerprint ***)(a7 + 32), a5, (uint64_t)v124);
  CLMicroLocationModel::operator=((uint64_t)&buf, (uint64_t)v124);
  if (v139 < 0) {
    operator delete(__p);
  }
  if (v136)
  {
    char v137 = v136;
    operator delete(v136);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)v134);
  *(void *)v147 = &v132;
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)v147);
  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v129);
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v128);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v127);
  if (CLMicroLocationModel::isStable((CLMicroLocationModel *)&buf)
    || v104 < v105
    && (unint64_t v30 = *(unsigned int *)((char *)&v172 + 2),
        ULSettings::get<ULSettings::MinimumNumberOfDaysWithRecordingsInStableModel>() - 1 > v30))
  {
LABEL_23:
    int v113 = 0;
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v31 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v124 = 0;
      _os_log_impl(&dword_25631F000, v31, OS_LOG_TYPE_DEFAULT, "got sufficient recording triggers, will ignore prior cluster number in learning", v124, 2u);
    }

    int v113 = 1;
  }
  v166[0] = &unk_2704DD9E0;
  v166[1] = CLMicroLocationFingerprintConfiguration::getRecordingConfigurationFromSettings;
  v166[3] = v166;
  CLMicroLocationModel::CLMicroLocationModel((CLMicroLocationModel *)v124);
  uint64_t v32 = *(unint64_t **)(a3 + 8);
  unint64_t v102 = 0xEF7BDEF7BDEF7BDFLL * (((uint64_t)v32 - *(void *)a3) >> 3);
  unint64_t v33 = 126 - 2 * __clz(v102);
  if (v32 == *(unint64_t **)a3) {
    uint64_t v34 = 0;
  }
  else {
    uint64_t v34 = v33;
  }
  std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *,std::vector<CLMicroLocationRecordingEventsTable::Entry> &,std::function<BOOL ()(void)> const&,CLMicroLocationAnchorAppearanceMap const&,CLMicroLocationFingerprintPool &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::optional<CLMicroLocationModelTable::Entry> const&,CLMicroLocationProto::Model_ModelType)::$_0 &,CLMicroLocationRecordingEventsTable::Entry*,false>(*(unint64_t **)a3, v32, v34, 1);
  if (v110)
  {
    int v112 = 0;
    int v111 = 0;
    uint64_t v35 = 0;
    int v107 = 0;
    while (1)
    {
      if (CLMicroLocationModel::isValid((CLMicroLocationModel *)v124))
      {
        memset(v147, 0, 32);
        *(_DWORD *)&v147[32] = 1065353216;
        for (uint64_t i = v135; i; uint64_t i = (void *)*i)
        {
          uint64_t v37 = (void *)i[4];
          long long v38 = (void *)i[5];
          while (v37 != v38)
          {
            std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&>((uint64_t)v147, v37, v37);
            v37 += 2;
          }
        }
        uint64_t v40 = *(unint64_t **)a3;
        uint64_t v39 = *(unint64_t **)(a3 + 8);
        if (*(unint64_t **)a3 != v39)
        {
          while (std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v147, v40))
          {
            v40 += 31;
            if (v40 == v39)
            {
              uint64_t v40 = v39;
              goto LABEL_54;
            }
          }
          if (v40 != v39)
          {
            for (uint64_t j = v40 + 31; j != v39; j += 31)
            {
              if (std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v147, j))
              {
                long long v42 = *(_OWORD *)j;
                v40[2] = j[2];
                *(_OWORD *)uint64_t v40 = v42;
                char v43 = (void **)(v40 + 3);
                if (*((char *)v40 + 47) < 0) {
                  operator delete(*v43);
                }
                long long v44 = *(_OWORD *)(j + 3);
                v40[5] = j[5];
                *(_OWORD *)char v43 = v44;
                *((unsigned char *)j + 47) = 0;
                *((unsigned char *)j + 24) = 0;
                long long v45 = *((_OWORD *)j + 3);
                *(_OWORD *)((char *)v40 + 60) = *(_OWORD *)((char *)j + 60);
                *((_OWORD *)v40 + 3) = v45;
                CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v40 + 10), (const CLMicroLocationProto::RecordingEvent *)(j + 10));
                long long v46 = *((_OWORD *)j + 14);
                *((unsigned char *)v40 + 240) = *((unsigned char *)j + 240);
                *((_OWORD *)v40 + 14) = v46;
                v40 += 31;
              }
            }
          }
        }
LABEL_54:
        std::vector<CLMicroLocationRecordingEventsTable::Entry>::erase(a3, (uint64_t)v40, *(long long **)(a3 + 8));
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v147);
      }
      __int16 v47 = +[ULDefaultsSingleton shared];
      id v48 = [v47 defaultsDictionary];

      __int16 v49 = [NSString stringWithUTF8String:"ULFingerprintDataSource"];
      uint64_t v50 = [v48 objectForKey:v49];
      if (v50 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
        unsigned int v51 = [v50 unsignedIntValue];
      }
      else {
        unsigned int v51 = [&unk_2704F1AA0 unsignedIntValue];
      }
      unsigned int v52 = v51;

      std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v165, a4);
      std::__function::__value_func<CLMicroLocationFingerprintConfiguration ()(void)>::__value_func[abi:ne180100]((uint64_t)v164, (uint64_t)v166);
      CLMicroLocationFingerprintDataSources::create(v52);
      CLMicroLocationFingerprintVector::CLMicroLocationFingerprintVector(&v123, &v122);
      uint64_t v53 = v122;
      uint64_t v122 = 0;
      if (v53) {
        (*(void (**)(uint64_t))(*(void *)v53 + 8))(v53);
      }
      std::__function::__value_func<CLMicroLocationFingerprintConfiguration ()(void)>::~__value_func[abi:ne180100](v164);
      std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v165);
      if (!v35)
      {
        int v55 = CLMicroLocationFingerprintVector::size((CLMicroLocationFingerprintVector *)&v123);
        int v107 = CLMicroLocationFingerprintVector::size((CLMicroLocationFingerprintVector *)&v123);
        int v112 = v55;
      }
      if (!v111) {
        int v111 = CLMicroLocationQualityEstimationAlgorithms::evaluateQualityWithNumFingerprints((CLMicroLocationQualityEstimationAlgorithms *)&v123, v54);
      }
      uint64_t v56 = CLMicroLocationFingerprintVector::size((CLMicroLocationFingerprintVector *)&v123);
      uint64_t v57 = v56;
      uint64_t v58 = v141;
      if (v141 >= v142)
      {
        int v60 = (char *)v140;
        uint64_t v61 = (v141 - (unsigned char *)v140) >> 3;
        unint64_t v62 = v61 + 1;
        if ((unint64_t)(v61 + 1) >> 61) {
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v63 = v142 - (unsigned char *)v140;
        if ((v142 - (unsigned char *)v140) >> 2 > v62) {
          unint64_t v62 = v63 >> 2;
        }
        if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v64 = v62;
        }
        if (v64)
        {
          __int16 v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)&v142, v64);
          uint64_t v58 = v141;
          int v60 = (char *)v140;
        }
        else
        {
          __int16 v65 = 0;
        }
        int v66 = (uint64_t *)&v65[8 * v61];
        uint64_t *v66 = v57;
        __int16 v59 = (char *)(v66 + 1);
        while (v58 != v60)
        {
          uint64_t v67 = *((void *)v58 - 1);
          v58 -= 8;
          *--int v66 = v67;
        }
        long long v140 = v66;
        v141 = v59;
        uuid v142 = &v65[8 * v64];
        if (v60) {
          operator delete(v60);
        }
      }
      else
      {
        *(void *)v141 = v56;
        __int16 v59 = v58 + 8;
      }
      v141 = v59;
      uint64_t v68 = *(void *)(a4 + 24);
      if (!v68) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v68 + 48))(v68)) {
        break;
      }
      if (CLMicroLocationFingerprintVector::empty((CLMicroLocationFingerprintVector *)&v123))
      {
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
        }
        v99 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v147 = 67109376;
          *(_DWORD *)&v147[4] = a10;
          *(_WORD *)&v147[8] = 1024;
          *(_DWORD *)&v147[10] = v35;
          _os_log_impl(&dword_25631F000, v99, OS_LOG_TYPE_DEFAULT, "#Warning Fingerprint vector empty for model type %d at iteration %d", v147, 0xEu);
        }
        goto LABEL_170;
      }
      if (v116)
      {
        if (v35) {
          CLMicroLocationCoreAnalyticsPublishHelper::updateMagicalMomentsNumPrunedFingerprints(v116, (uint64_t *)&v140, v35);
        }
        else {
          CLMicroLocationCoreAnalyticsPublishHelper::updateModelRfCharacteristics(v116, (CLMicroLocationFingerprintVector *)&v123, 0, 0, v144);
        }
      }
      if (CLMicroLocationModel::isValid((CLMicroLocationModel *)&buf))
      {
        if ((v113 & 1) == 0) {
          CLMicroLocationModel::numClusters((CLMicroLocationModel *)&buf);
        }
        (*(void (**)(unsigned char *__return_ptr))(*(void *)v143 + 16))(v147);
        CLMicroLocationModel::operator=((uint64_t)v124, (uint64_t)v147);
        if (v163 < 0) {
          operator delete(v162);
        }
        if (v160)
        {
          long long v161 = v160;
          operator delete(v160);
        }
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)v159);
        uint64_t v117 = v158;
        std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v117);
        std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v157);
        std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v156);
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v147[16]);
        __int16 v69 = (const CLMicroLocationModel *)CLMicroLocationModel::numClusters((CLMicroLocationModel *)v124);
        *(void *)v147 = &buf;
        v147[8] = 1;
        CLMicroLocationModel::mapIdentifiersFromOldModelAndPruneNoiseClusters((CLMicroLocationModel *)v124, (uint64_t)v147, v113, v116);
        CLMicroLocationModel::getIdentifiers(v124, (uint64_t)&v117);
        CLMicroLocationModel::getIdentifiers(&buf, (uint64_t)v147);
        int v70 = *(void **)&v147[16];
        if (*(void *)&v147[16])
        {
          while (std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(&v117, v70 + 2))
          {
            int v70 = (void *)*v70;
            if (!v70) {
              goto LABEL_104;
            }
          }
          std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v147);
          if ((v113 & 1) == 0)
          {
            (*(void (**)(unsigned char *__return_ptr))(*(void *)v143 + 16))(v147);
            CLMicroLocationModel::operator=((uint64_t)v124, (uint64_t)v147);
            if (v163 < 0) {
              operator delete(v162);
            }
            if (v160)
            {
              long long v161 = v160;
              operator delete(v160);
            }
            std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)v159);
            uint64_t v120 = v158;
            std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v120);
            std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v157);
            std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v156);
            std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v147[16]);
            __int16 v69 = (const CLMicroLocationModel *)CLMicroLocationModel::numClusters((CLMicroLocationModel *)v124);
            *(void *)v147 = &buf;
            v147[8] = 1;
            CLMicroLocationModel::mapIdentifiersFromOldModelAndPruneNoiseClusters((CLMicroLocationModel *)v124, (uint64_t)v147, 0, v116);
          }
        }
        else
        {
LABEL_104:
          std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v147);
        }
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v117);
      }
      else
      {
        (*(void (**)(unsigned char *__return_ptr))(*(void *)v143 + 16))(v147);
        CLMicroLocationModel::operator=((uint64_t)v124, (uint64_t)v147);
        if (v163 < 0) {
          operator delete(v162);
        }
        if (v160)
        {
          long long v161 = v160;
          operator delete(v160);
        }
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)v159);
        uint64_t v117 = v158;
        std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v117);
        std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v157);
        std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v156);
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v147[16]);
        __int16 v69 = (const CLMicroLocationModel *)CLMicroLocationModel::numClusters((CLMicroLocationModel *)v124);
        v147[0] = 0;
        v147[8] = 0;
        CLMicroLocationModel::mapIdentifiersFromOldModelAndPruneNoiseClusters((CLMicroLocationModel *)v124, (uint64_t)v147, v113, v116);
      }
      CLMicroLocationCoreAnalyticsPublishHelper::updateMagicalMomentsNumPrunedClusters(v116, (NSMutableDictionary *)v124, v69, v35);
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      __int16 v71 = (id)logObject_MicroLocation_Default;
      BOOL v72 = os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG);

      if (v72)
      {
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
        }
        v73 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
        {
          char v74 = v133;
          char v75 = v132;
          uint64_t v76 = CLMicroLocationModel::numClusters((CLMicroLocationModel *)v124);
          *(_DWORD *)v147 = 68289795;
          *(_DWORD *)&v147[4] = 0;
          *(_WORD *)&v147[8] = 2082;
          *(void *)&v147[10] = "";
          *(_WORD *)&v147[18] = 2049;
          *(void *)&v147[20] = ((char *)v74 - v75) >> 5;
          *(_WORD *)&v147[28] = 2049;
          *(void *)&v147[30] = v76;
          __int16 v148 = 1025;
          LODWORD(v149) = *(_DWORD *)&v124[4];
          _os_log_impl(&dword_25631F000, v73, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"model\", \"size\":%{private}lu, \"numClusters\":%{private}lu, \"type\":%{private}d}", v147, 0x2Cu);
        }

        uint64_t v77 = (uint64_t *)v132;
        uint64_t v78 = v133;
        while (v77 != v78)
        {
          if (p_superclass[428] != (__objc2_class *)-1) {
            dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_523);
          }
          v79 = (id)logObject_MicroLocationQE_Default;
          if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v80 = *v77;
            v81 = operator new(0x28uLL);
            uint64_t v117 = v81;
            *(_OWORD *)v118 = xmmword_256514540;
            _OWORD *v81 = 0u;
            v81[1] = 0u;
            *(void *)((char *)v81 + 29) = 0;
            boost::uuids::to_chars<char *>(v80 + 40, v81);
            uint64_t v82 = p_superclass;
            if (SHIBYTE(v118[1]) >= 0) {
              char v83 = &v117;
            }
            else {
              char v83 = v117;
            }
            BOOL v84 = operator new(0x28uLL);
            uint64_t v85 = a7;
            uint64_t v120 = v84;
            long long v121 = xmmword_256514540;
            *BOOL v84 = 0u;
            v84[1] = 0u;
            *(void *)((char *)v84 + 29) = 0;
            boost::uuids::to_chars<char *>((uint64_t)(v77 + 2), v84);
            if (v121 >= 0) {
              __int16 v86 = &v120;
            }
            else {
              __int16 v86 = v120;
            }
            uint64_t v87 = *v77;
            uint64_t v88 = *(void *)(*v77 + 24);
            unsigned int v145 = 1;
            v89 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((void *)(v87 + 104), &v145);
            if (v89) {
              double v90 = *((double *)v89 + 4) - *((double *)v89 + 3);
            }
            else {
              double v90 = 0.0;
            }
            double v91 = *(double *)(*v77 + 152);
            int v92 = (int)*(double *)(*v77 + 144);
            *(_DWORD *)v147 = 68290563;
            *(_DWORD *)&v147[4] = 0;
            *(_WORD *)&v147[8] = 2082;
            *(void *)&v147[10] = "";
            *(_WORD *)&v147[18] = 2081;
            *(void *)&v147[20] = v83;
            *(_WORD *)&v147[28] = 2081;
            *(void *)&v147[30] = v86;
            __int16 v148 = 2049;
            uint64_t v149 = v88;
            __int16 v150 = 1025;
            int v151 = (int)v90;
            __int16 v152 = 1025;
            int v153 = v92;
            __int16 v154 = 1025;
            int v155 = (int)v91;
            _os_log_impl(&dword_25631F000, v79, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"modelFingerprint\", \"recordingUUID\":%{private, location:escape_only}s, \"clusterUUID\":%{private, location:escape_only}s, \"size\":%{private}lu, \"duration\":%{private}d, \"start\":%{private}d, \"end\":%{private}d}", v147, 0x42u);
            if (SHIBYTE(v121) < 0) {
              operator delete(v120);
            }
            a7 = v85;
            if (SHIBYTE(v118[1]) < 0) {
              operator delete(v117);
            }
            p_superclass = v82;
          }

          v77 += 4;
        }
      }
      uint64_t v93 = v123;
      uint64_t v123 = 0;
      if (v93) {
        (*(void (**)(uint64_t))(*(void *)v93 + 8))(v93);
      }
      uint64_t v35 = (v35 + 1);
      if (v35 == v110) {
        goto LABEL_144;
      }
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    v99 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v147 = 68289282;
      *(_DWORD *)&v147[4] = 0;
      *(_WORD *)&v147[8] = 2082;
      *(void *)&v147[10] = "";
      *(_WORD *)&v147[18] = 2082;
      *(void *)&v147[20] = "MicroLocationLearning";
      _os_log_impl(&dword_25631F000, v99, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"operation cancelled\", \"Activity\":%{public, location:escape_only}s}", v147, 0x1Cu);
    }
LABEL_170:

    *a8 = 0;
    a8[448] = 0;
    uint64_t v100 = v123;
    uint64_t v123 = 0;
    if (v100) {
      (*(void (**)(uint64_t))(*(void *)v100 + 8))(v100);
    }
  }
  else
  {
    int v111 = 0;
    int v107 = 0;
    int v112 = 0;
LABEL_144:
    LOBYTE(v120) = 0;
    BYTE8(v121) = 0;
    if (*(unsigned char *)(a7 + 312))
    {
      uint64_t v94 = *(void *)(a7 + 16);
      uint64_t v120 = (void *)(*(unsigned int *)(a7 + 140) | ((unint64_t)*(unsigned __int8 *)(a7 + 136) << 32));
      *(void *)&long long v121 = v94;
      BYTE8(v121) = 1;
    }
    CLMicroLocationLearner::updateModelDaysWithRecordings(a1, (uint64_t)v124, &v144, (uint64_t)&v120, a6);
    if (a10 != 2)
    {
      if (v104 >= v105
        || (unint64_t v95 = v126, ULSettings::get<ULSettings::MinimumNumberOfDaysWithRecordingsInStableModel>() <= v95))
      {
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
        }
        int v96 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)v147 = 0;
          _os_log_impl(&dword_25631F000, v96, OS_LOG_TYPE_DEBUG, "set model to stable", v147, 2u);
        }

        char v125 = 1;
      }
    }
    CLMicroLocationModel::setQualityIndicator((uint64_t)v124, v111);
    CLMicroLocationQualityEstimationAlgorithms::evaluateQualityTreeBased((CLMicroLocationQualityEstimationAlgorithms *)v124, (uint64_t)&v117);
    CLMicroLocationModel::setCandidateQualityIndicator((uint64_t)v124, (int)v117);
    CLMicroLocationModel::setCandidateQualityReasons((uint64_t)v124, (uint64_t)v118);
    v130 = v118[3];
    int v131 = v119;
    CLMicroLocationModel::toProtobuf((CLMicroLocationModel *)v124, (uint64_t)v147);
    double v97 = v144;
    CLMicroLocationCoreAnalyticsPublishHelper::updateLearnEventSummary(v116, (CLMicroLocationModel *)v124, (const CLMicroLocationModel *)v147, v144);
    if (*(unsigned char *)(a7 + 312))
    {
      if (v169) {
        uint64_t v98 = v168;
      }
      else {
        uint64_t v98 = 0;
      }
      CLMicroLocationCoreAnalyticsPublishHelper::updateMagicalMomentOldModelMetrics(v116, (CLMicroLocationModel *)v124, (CLMicroLocationModel *)&buf, v98, v169, v97);
    }
    v146[0] = CLMicroLocationModel::isStable((CLMicroLocationModel *)&buf);
    v146[1] = 1;
    CLMicroLocationCoreAnalyticsPublishHelper::updateModelStabilityMetrics(v116, (unsigned int *)v124, v146);
    v129[24] = v102;
    v129[25] = v112;
    v129[26] = v107;
    v129[27] = 0;
    std::__optional_destruct_base<CLMicroLocationModel,false>::__optional_destruct_base[abi:ne180100]<CLMicroLocationModel>((uint64_t)a8, (uint64_t)v124);
    CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)v147);
    if (v118[0])
    {
      v118[1] = v118[0];
      operator delete(v118[0]);
    }
  }
  if (v139 < 0) {
    operator delete(__p);
  }
  if (v136)
  {
    char v137 = v136;
    operator delete(v136);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)v134);
  uint64_t v120 = &v132;
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v120);
  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v129);
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v128);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v127);
  std::__function::__value_func<CLMicroLocationFingerprintConfiguration ()(void)>::~__value_func[abi:ne180100](v166);
  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v167);
  if (v188 < 0) {
    operator delete(v187);
  }
  if (v185)
  {
    v186 = v185;
    operator delete(v185);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)&v184);
  *(void *)v124 = &v183;
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)v124);
  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v182);
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v181);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v172 + 6);
  if (v140)
  {
    v141 = (char *)v140;
    operator delete(v140);
  }
  uint64_t v101 = v143;
  uint64_t v143 = 0;
  if (v101) {
    (*(void (**)(uint64_t))(*(void *)v101 + 8))(v101);
  }
}

void sub_2563DC894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{
  unint64_t v38 = STACK[0x328];
  STACK[0x328] = 0;
  if (v38) {
    (*(void (**)(unint64_t))(*(void *)v38 + 8))(v38);
  }

  _Unwind_Resume(a1);
}

CLMicroLocationAnchorValueStatisticsMap *std::optional<CLMicroLocationAnchorValueStatisticsMap>::emplace[abi:ne180100]<CLMicroLocationModel &,CLMicroLocationFingerprintPool &,void>(CLMicroLocationAnchorValueStatisticsMap *a1, CLMicroLocationModel *a2, CLMicroLocationFingerprintPool *a3)
{
  if (*((unsigned char *)a1 + 40))
  {
    a1 = (CLMicroLocationAnchorValueStatisticsMap *)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::~__hash_table((uint64_t)a1);
    *((unsigned char *)a1 + 40) = 0;
  }
  uint64_t result = CLMicroLocationAnchorValueStatisticsMap::CLMicroLocationAnchorValueStatisticsMap(a1, a2, a3);
  *((unsigned char *)result + 40) = 1;
  return result;
}

void CLMicroLocationLearner::learnLocationSimilarityListModel(uint64_t a1, void *a2, double a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  double v70 = a3;
  a2;
  uint64_t v68 = 0;
  uint64_t v67 = 0;
  uint64_t v69 = 0;
  uint64_t v65 = 0;
  uint64_t v64 = 0;
  uint64_t v66 = 0;
  uint64_t v10 = ULSettings::get<ULSettings::SimilarityListMaxNumberOfItems>();
  uint64_t v11 = *a7;
  uint64_t v12 = a7[1];
  uint64_t v63 = 0;
  std::string __p = 0;
  unint64_t v62 = 0;
  std::vector<CLMicroLocationProto::EventType>::__init_with_size[abi:ne180100]<CLMicroLocationProto::EventType*,CLMicroLocationProto::EventType*>(&__p, *(const void **)a8, *(void *)(a8 + 8), (uint64_t)(*(void *)(a8 + 8) - *(void *)a8) >> 2);
  long long v46 = (boost::uuids *)(a5 + 3);
  CLMicroLocationLearner::getServiceLabelsAndLabeledRecordingEventsForLoi(a1, (uint64_t)(a5 + 3), (uint64_t *)&v67, (uint64_t)&v64, v11, v12, v13, v10);
  if (__p)
  {
    unint64_t v62 = __p;
    operator delete(__p);
  }
  memset(v59, 0, sizeof(v59));
  int v60 = 1065353216;
  uint64_t v14 = v64;
  for (uint64_t i = v65; v14 != i; v14 += 248)
  {
    if (!*(unsigned char *)(v14 + 240))
    {
      int v28 = _CLLogObjectForCategory_MicroLocation_Default();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
      {
        if (*((char *)a5 + 23) >= 0) {
          unint64_t v29 = a5;
        }
        else {
          unint64_t v29 = (uint64_t *)*a5;
        }
        boost::uuids::to_string(v46, (uint64_t)&v78);
        int v30 = SHIBYTE(v79);
        uint64_t v31 = (void **)v78;
        boost::uuids::to_string((boost::uuids *)v14, (uint64_t)v49);
        uint64_t v32 = &v78;
        if (v30 < 0) {
          uint64_t v32 = v31;
        }
        if (SHIBYTE(v50[0]) >= 0) {
          unint64_t v33 = v49;
        }
        else {
          unint64_t v33 = (void **)v49[0];
        }
        *(_DWORD *)uint64_t buf = 68290307;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = v29;
        *(_WORD *)&unsigned char buf[28] = 2082;
        *(void *)&buf[30] = v32;
        __int16 v72 = 2082;
        unint64_t v73 = (unint64_t)v33;
        __int16 v74 = 2082;
        char v75 = "assert";
        __int16 v76 = 2081;
        uint64_t v77 = "recordingEntry.fTriggerUUID.has_value()";
        _os_log_impl(&dword_25631F000, v28, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Service UUID\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x44u);
        if (SHIBYTE(v50[0]) < 0) {
          operator delete(v49[0]);
        }
        if (SHIBYTE(v79) < 0) {
          operator delete(v78);
        }
      }

      uint64_t v34 = _CLLogObjectForCategory_MicroLocation_Default();
      if (os_signpost_enabled(v34))
      {
        if (*((char *)a5 + 23) >= 0) {
          uint64_t v35 = a5;
        }
        else {
          uint64_t v35 = (uint64_t *)*a5;
        }
        boost::uuids::to_string(v46, (uint64_t)&v78);
        int v36 = SHIBYTE(v79);
        uint64_t v37 = (void **)v78;
        boost::uuids::to_string((boost::uuids *)v14, (uint64_t)v49);
        unint64_t v38 = &v78;
        if (v36 < 0) {
          unint64_t v38 = v37;
        }
        if (SHIBYTE(v50[0]) >= 0) {
          uint64_t v39 = v49;
        }
        else {
          uint64_t v39 = (void **)v49[0];
        }
        *(_DWORD *)uint64_t buf = 68290307;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = v35;
        *(_WORD *)&unsigned char buf[28] = 2082;
        *(void *)&buf[30] = v38;
        __int16 v72 = 2082;
        unint64_t v73 = (unint64_t)v39;
        __int16 v74 = 2082;
        char v75 = "assert";
        __int16 v76 = 2081;
        uint64_t v77 = "recordingEntry.fTriggerUUID.has_value()";
        _os_signpost_emit_with_name_impl(&dword_25631F000, v34, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List Model Learning, labeled recording entry without trigger UUID", "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Service UUID\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x44u);
        if (SHIBYTE(v50[0]) < 0) {
          operator delete(v49[0]);
        }
        if (SHIBYTE(v79) < 0) {
          operator delete(v78);
        }
      }

      uint64_t v40 = _CLLogObjectForCategory_MicroLocation_Default();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
      {
        if (*((char *)a5 + 23) >= 0) {
          uint64_t v41 = a5;
        }
        else {
          uint64_t v41 = (uint64_t *)*a5;
        }
        boost::uuids::to_string(v46, (uint64_t)&v78);
        int v42 = SHIBYTE(v79);
        char v43 = (void **)v78;
        boost::uuids::to_string((boost::uuids *)v14, (uint64_t)v49);
        long long v44 = &v78;
        if (v42 < 0) {
          long long v44 = v43;
        }
        if (SHIBYTE(v50[0]) >= 0) {
          long long v45 = v49;
        }
        else {
          long long v45 = (void **)v49[0];
        }
        *(_DWORD *)uint64_t buf = 68290307;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = v41;
        *(_WORD *)&unsigned char buf[28] = 2082;
        *(void *)&buf[30] = v44;
        __int16 v72 = 2082;
        unint64_t v73 = (unint64_t)v45;
        __int16 v74 = 2082;
        char v75 = "assert";
        __int16 v76 = 2081;
        uint64_t v77 = "recordingEntry.fTriggerUUID.has_value()";
        _os_log_impl(&dword_25631F000, v40, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Similarity List Model Learning, labeled recording entry without trigger UUID\", \"Client Id\":%{public, location:escape_only}s, \"Service UUID\":%{public, location:escape_only}s, \"Recording UUID\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x44u);
        if (SHIBYTE(v50[0]) < 0) {
          operator delete(v49[0]);
        }
        if (SHIBYTE(v79) < 0) {
          operator delete(v78);
        }
      }

      abort_report_np();
      __break(1u);
    }
    *(_OWORD *)uint64_t buf = *(_OWORD *)v14;
    *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)(v14 + 224);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>((uint64_t)v59, buf, buf);
  }
  memset(v57, 0, sizeof(v57));
  int v58 = 1065353216;
  unsigned int v16 = v67;
  for (uint64_t j = v68; v16 != j; v16 += 4)
  {
    *(_OWORD *)uint64_t buf = *v16;
    *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)((char *)v16 + 40);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__emplace_multi<std::pair<boost::uuids::uuid const,boost::uuids::uuid>>(v57, buf);
  }
  uint64_t v18 = v64;
  uint64_t v19 = v65;
  if (v64 == v65)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v20 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a5 + 23) >= 0) {
        uint64_t v21 = a5;
      }
      else {
        uint64_t v21 = (uint64_t *)*a5;
      }
      BOOL v22 = operator new(0x28uLL);
      uint64_t v78 = v22;
      long long v79 = xmmword_256514540;
      _OWORD *v22 = 0u;
      v22[1] = 0u;
      *(void *)((char *)v22 + 29) = 0;
      boost::uuids::to_chars<char *>((uint64_t)v46, v22);
      char v23 = &v78;
      if (v79 < 0) {
        char v23 = v78;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2082;
      *(void *)&buf[20] = v21;
      *(_WORD *)&unsigned char buf[28] = 2082;
      *(void *)&buf[30] = v23;
      _os_log_impl(&dword_25631F000, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Similarity List Model Learning, no labeled recording triggers\", \"Client ID\":%{public, location:escape_only}s, \"Service UUID\":%{public, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(v79) < 0) {
        operator delete(v78);
      }
    }

    uint64_t v18 = v64;
    uint64_t v19 = v65;
  }
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  *(void *)uint64_t buf = &v54;
  if (v18 == v19) {
    goto LABEL_29;
  }
  do
  {
    if (*(_DWORD *)(v18 + 72) == 13) {
      std::back_insert_iterator<std::vector<CLMicroLocationRecordingEventsTable::Entry>>::operator=[abi:ne180100]((uint64_t **)buf, (long long *)v18);
    }
    v18 += 248;
  }
  while (v18 != v19);
  uint64_t v24 = v64;
  uint64_t v19 = v65;
  *(void *)uint64_t buf = &v51;
  if (v64 == v65)
  {
LABEL_29:
    uint64_t v25 = v19;
  }
  else
  {
    do
    {
      if (*(_DWORD *)(v24 + 72) == 1) {
        std::back_insert_iterator<std::vector<CLMicroLocationRecordingEventsTable::Entry>>::operator=[abi:ne180100]((uint64_t **)buf, (long long *)v24);
      }
      v24 += 248;
    }
    while (v24 != v19);
    uint64_t v25 = v65;
    uint64_t v19 = v64;
  }
  if (0xEF7BDEF7BDEF7BDFLL * ((v25 - v19) >> 3) != 0xEF7BDEF7BDEF7BDFLL * ((v55 - v54) >> 3)
                                                  - 0x1084210842108421 * ((v52 - v51) >> 3))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v26 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2050;
      *(void *)&buf[20] = 0xEF7BDEF7BDEF7BDFLL * ((v65 - v64) >> 3);
      *(_WORD *)&unsigned char buf[28] = 2050;
      *(void *)&buf[30] = 0xEF7BDEF7BDEF7BDFLL * ((v55 - v54) >> 3);
      __int16 v72 = 2050;
      unint64_t v73 = 0xEF7BDEF7BDEF7BDFLL * ((v52 - v51) >> 3);
      _os_log_impl(&dword_25631F000, v26, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization\", \"Num labeled triggers\":%{public}lu, \"Num inferred recordings\":%{public}lu, \"Num inferred localizations\":%{public}lu}", buf, 0x30u);
    }

    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    int v27 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v27))
    {
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&unsigned char buf[18] = 2050;
      *(void *)&buf[20] = 0xEF7BDEF7BDEF7BDFLL * ((v65 - v64) >> 3);
      *(_WORD *)&unsigned char buf[28] = 2050;
      *(void *)&buf[30] = 0xEF7BDEF7BDEF7BDFLL * ((v55 - v54) >> 3);
      __int16 v72 = 2050;
      unint64_t v73 = 0xEF7BDEF7BDEF7BDFLL * ((v52 - v51) >> 3);
      _os_signpost_emit_with_name_impl(&dword_25631F000, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization", "{\"msg%{public}.0s\":\"learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization\", \"Num labeled triggers\":%{public}lu, \"Num inferred recordings\":%{public}lu, \"Num inferred localizations\":%{public}lu}", buf, 0x30u);
    }
  }
  operator new();
}

void sub_2563DE3CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *__p,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  operator delete(v70);

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a69);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&STACK[0x210]);
  a33 = (uint64_t)&STACK[0x258];
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a33);
  a33 = (uint64_t)&STACK[0x270];
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a33);

  _Unwind_Resume(a1);
}

uint64_t std::optional<CLMicroLocationConfigurationTable::Entry>::operator=[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,void>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 112))
  {
    *(void *)a1 = *(void *)a2;
    id v4 = (void **)(a1 + 8);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v4);
    }
    long long v5 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)id v4 = v5;
    *(unsigned char *)(a2 + 31) = 0;
    *(unsigned char *)(a2 + 8) = 0;
    long long v6 = *(_OWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v6;
    CLMicroLocationProto::Configuration::CopyFrom((CLMicroLocationProto::Configuration *)(a1 + 56), (const CLMicroLocationProto::Configuration *)(a2 + 56));
  }
  else
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry*>(a1, a2);
    *(unsigned char *)(a1 + 112) = 1;
  }
  return a1;
}

void CLMicroLocationLearner::semiSupervisedLearnWrapper(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, void *a5@<X4>, uint64_t a6@<X5>, CLMicroLocationFingerprintPool *a7@<X6>, unsigned char *a8@<X8>, uint64_t a9)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  id v51 = a5;
  CLMicroLocationLearner::getAnchorAppearanceMapForLoi(a1, (_OWORD *)a9, (uint64_t)v64);
  uint64_t v62 = 0;
  memset(v63, 0, sizeof(v63));
  int v60 = 0;
  uint64_t v61 = 0;
  uint64_t v13 = +[ULDefaultsSingleton shared];
  uint64_t v14 = [v13 defaultsDictionary];

  unsigned int v15 = [NSString stringWithUTF8String:"ULLearningLabeledRecordingTriggersLimit"];
  unsigned int v16 = [v14 objectForKey:v15];
  if (v16 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v17 = [v16 unsignedIntValue];
  }
  else {
    uint64_t v17 = [&unk_2704F1AD0 unsignedIntValue];
  }
  uint64_t v18 = v17;

  uint64_t v19 = *(void *)a9;
  uint64_t v20 = *(void *)(a9 + 8);
  int v58 = 0;
  uint64_t v59 = 0;
  std::string __p = 0;
  std::vector<CLMicroLocationProto::EventType>::__init_with_size[abi:ne180100]<CLMicroLocationProto::EventType*,CLMicroLocationProto::EventType*>(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  CLMicroLocationLearner::getServiceLabelsAndLabeledRecordingEventsForLoi(a1, a2 + 24, v63, (uint64_t)&v60, v19, v20, v21, v18);
  if (__p)
  {
    int v58 = __p;
    operator delete(__p);
  }
  memset(v55, 0, sizeof(v55));
  int v56 = 1065353216;
  BOOL v22 = v60;
  char v23 = v61;
  while (v22 != v23)
  {
    *(_OWORD *)uint64_t buf = *v22;
    std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid>((uint64_t)v55, buf, buf);
    BOOL v22 = (long long *)((char *)v22 + 248);
  }
  CLMicroLocationLearner::selectRecordingEventTriggersForLearningMeasurementsOrderedByTimestamp(a1, a3, *(void *)a9, *(void *)(a9 + 8), (uint64_t)&v53);
  uint64_t v25 = (long long *)v53;
  uint64_t v24 = (long long *)v54;
  if (v53 != v54)
  {
    while (!std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v55, v25))
    {
      uint64_t v25 = (long long *)((char *)v25 + 248);
      if (v25 == v24)
      {
        uint64_t v25 = v24;
        goto LABEL_22;
      }
    }
    if (v25 != v24)
    {
      for (uint64_t i = (long long *)((char *)v25 + 248); i != v24; uint64_t i = (long long *)((char *)i + 248))
      {
        if (!std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v55, i))
        {
          long long v27 = *i;
          *((void *)v25 + 2) = *((void *)i + 2);
          *uint64_t v25 = v27;
          int v28 = (void **)v25 + 3;
          if (*((char *)v25 + 47) < 0) {
            operator delete(*v28);
          }
          long long v29 = *(long long *)((char *)i + 24);
          *((void *)v25 + 5) = *((void *)i + 5);
          *(_OWORD *)int v28 = v29;
          *((unsigned char *)i + 47) = 0;
          *((unsigned char *)i + 24) = 0;
          long long v30 = i[3];
          *(long long *)((char *)v25 + 60) = *(long long *)((char *)i + 60);
          v25[3] = v30;
          CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v25 + 5), (const CLMicroLocationProto::RecordingEvent *)(i + 5));
          long long v31 = i[14];
          *((unsigned char *)v25 + 240) = *((unsigned char *)i + 240);
          v25[14] = v31;
          uint64_t v25 = (long long *)((char *)v25 + 248);
        }
      }
    }
  }
LABEL_22:
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::erase((uint64_t)&v53, (uint64_t)v25, (long long *)v54);
  uint64_t v32 = +[ULDefaultsSingleton shared];
  unint64_t v33 = [v32 defaultsDictionary];

  uint64_t v34 = [NSString stringWithUTF8String:"ULLearningRecordingLimit"];
  uint64_t v35 = [v33 objectForKey:v34];
  if (v35 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    unsigned int v36 = [v35 unsignedIntValue];
  }
  else {
    unsigned int v36 = [&unk_2704F1A58 unsignedIntValue];
  }
  unsigned int v37 = v36;

  unint64_t v38 = 0xEF7BDEF7BDEF7BDFLL * (((char *)v61 - (char *)v60) >> 3);
  if (v37 >= v38) {
    unint64_t v39 = v37 - v38;
  }
  else {
    unint64_t v39 = 0;
  }
  uint64_t v41 = (unint64_t *)v53;
  uint64_t v40 = (unint64_t *)v54;
  unint64_t v42 = 0xEF7BDEF7BDEF7BDFLL * ((v54 - v53) >> 3);
  if (v42 > v39)
  {
    std::vector<CLMicroLocationRecordingEventsTable::Entry>::erase((uint64_t)&v53, (uint64_t)v53, (long long *)&v54[-248 * v39]);
    uint64_t v41 = (unint64_t *)v53;
    uint64_t v40 = (unint64_t *)v54;
    unint64_t v42 = 0xEF7BDEF7BDEF7BDFLL * ((v54 - v53) >> 3);
  }
  unint64_t v43 = 126 - 2 * __clz(v42);
  if (v40 == v41) {
    uint64_t v44 = 0;
  }
  else {
    uint64_t v44 = v43;
  }
  std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *,false>(v41, v40, v44, 1);
  *a8 = 0;
  a8[312] = 0;
  if (a4 == 4)
  {
    std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v65, a6);
    long long v45 = v51;
    CLMicroLocationSemiSupervisedAlgorithm::learnBinaryRoiSemiSupervisedModel(v51, (uint64_t)v65, v63, &v60, (long long **)&v53, (uint64_t)v64, buf, a2, a7, *(void *)a9, *(void *)(a9 + 8));
    std::__optional_storage_base<CLMicroLocationModelTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModelTable::Entry,false>>((uint64_t)a8, (uint64_t)buf);
    std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
    long long v46 = v65;
    goto LABEL_38;
  }
  if (a4 == 3)
  {
    std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v66, a6);
    long long v45 = v51;
    CLMicroLocationSemiSupervisedAlgorithm::learnSelfTrainingSemiSupervisedModel(v51, (uint64_t)v66, v63, &v60, (uint64_t)&v53, (uint64_t)v64, buf, a2, a7, *(void *)a9, *(void *)(a9 + 8));
    std::__optional_storage_base<CLMicroLocationModelTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModelTable::Entry,false>>((uint64_t)a8, (uint64_t)buf);
    std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
    long long v46 = v66;
LABEL_38:
    std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v46);
    goto LABEL_47;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  long long v45 = v51;
  __int16 v47 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    *(void *)uint64_t buf = 68289282;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    __int16 v68 = 2050;
    uint64_t v69 = a4;
    _os_log_impl(&dword_25631F000, v47, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"invalid generation algorithm\", \"generation algorithm\":%{public}lu}", buf, 0x1Cu);
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  id v48 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    *(void *)uint64_t buf = 68289282;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    __int16 v68 = 2050;
    uint64_t v69 = a4;
    _os_signpost_emit_with_name_impl(&dword_25631F000, v48, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "invalid generation algorithm", "{\"msg%{public}.0s\":\"invalid generation algorithm\", \"generation algorithm\":%{public}lu}", buf, 0x1Cu);
  }
LABEL_47:
  *(void *)uint64_t buf = &v53;
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v55);
  *(void *)uint64_t buf = &v60;
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  *(void *)uint64_t buf = v63;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v64);
}

void sub_2563DEE8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,void **a51)
{
  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a51);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](&a43);
  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100](v51);
  *(void *)(v52 + 144) = &a18;
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a51);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a21);
  a21 = &a30;
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  a21 = &a33;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a36);

  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::selectRecordingEventTriggersForLearningMeasurementsOrderedByTimestamp(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  char v5 = a3;
  uint64_t v20 = *MEMORY[0x263EF8340];
  *(void *)&long long v19 = a3;
  *((void *)&v19 + 1) = a4;
  id v9 = *(id *)(*(void *)(a1 + 32) + 88);
  uint64_t v10 = v9;
  long long v17 = v19;
  LOBYTE(v18) = 1;
  if (v9)
  {
    [v9 fetchRecordingEventTriggersForLearningMeasurements:a2 atLoiGroupId:&v17];
  }
  else
  {
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
  }

  if (v5)
  {
LABEL_5:
    id v11 = *(id *)(*(void *)(a1 + 32) + 88);
    uint64_t v12 = v11;
    v15[0] = 0;
    v15[1] = 0;
    char v16 = 1;
    if (v11)
    {
      [v11 fetchRecordingEventTriggersForLearningMeasurements:a2 atLoiGroupId:v15];
    }
    else
    {
      long long v17 = 0uLL;
      uint64_t v18 = 0;
    }

    std::vector<CLMicroLocationRecordingEventsTable::Entry>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationRecordingEventsTable::Entry*>,std::__wrap_iter<CLMicroLocationRecordingEventsTable::Entry*>>((uint64_t *)a5, *(long long **)(a5 + 8), (long long *)v17, *((long long **)&v17 + 1), 0xEF7BDEF7BDEF7BDFLL * ((uint64_t)(*((void *)&v17 + 1) - v17) >> 3));
    v15[0] = (void **)&v17;
    std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](v15);
  }
  else
  {
    uint64_t v13 = 1;
    while (v13 != 16)
    {
      if (*((unsigned __int8 *)&v19 + v13++))
      {
        if ((unint64_t)(v13 - 2) <= 0xE) {
          goto LABEL_5;
        }
        return;
      }
    }
  }
}

void sub_2563DF158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);

  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationRecordingEventsTable::Entry>::erase(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *>((uint64_t)&v9, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v7 -= 248;
        std::allocator<CLMicroLocationRecordingEventsTable::Entry>::destroy[abi:ne180100](a1 + 16, v7);
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::emplace_back<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    unint64_t v11 = v10 + 1;
    if (v10 + 1 > 0x555555555555555) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v13 = 0x555555555555555;
    }
    else {
      unint64_t v13 = v11;
    }
    v19[4] = v4;
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>>(v4, v13);
    unsigned int v15 = &v14[48 * v10];
    v19[0] = v14;
    v19[1] = v15;
    v19[3] = &v14[48 * v16];
    uint64_t v17 = *((void *)a2 + 2);
    *(_OWORD *)unsigned int v15 = *a2;
    *((void *)v15 + 2) = v17;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(_OWORD *)(v15 + 24) = *(long long *)((char *)a2 + 24);
    *((void *)v15 + 5) = *((void *)a2 + 5);
    v19[2] = v15 + 48;
    std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__swap_out_circular_buffer(a1, v19);
    uint64_t v9 = a1[1];
    std::__split_buffer<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::~__split_buffer((uint64_t)v19);
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    *(_OWORD *)(v7 + 24) = *(long long *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    uint64_t v9 = v7 + 48;
    a1[1] = v7 + 48;
  }
  a1[1] = v9;
  return v9 - 48;
}

void sub_2563DF370(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLearner::updateAnchorAppearanceMapFromRapportAndRecordings(uint64_t a1, uint64_t a2, long long **a3, uint64_t a4, double a5)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  long long v26 = 0u;
  long long v27 = 0u;
  int v28 = 1065353216;
  unint64_t v10 = *(void **)a4;
  unint64_t v11 = *(void **)(a4 + 8);
  while (v10 != v11)
  {
    std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&>((uint64_t)&v26, v10, v10);
    v10 += 10;
  }
  unint64_t v12 = *a3;
  unint64_t v13 = a3[1];
  if (*a3 != v13)
  {
    while (1)
    {
      id v14 = *(id *)(*(void *)(a1 + 32) + 64);
      long long v37 = *v12;
      unsigned int v15 = (void **)operator new(0x10uLL);
      uint64_t v24 = v15 + 2;
      uint64_t v25 = v15 + 2;
      *(_OWORD *)unsigned int v15 = v37;
      char v23 = (uint8_t *)v15;
      if (v14)
      {
        [v14 fetchMeasurementsForRecordingUUIDs:&v23];
        unsigned int v15 = (void **)v23;
        if (!v23) {
          goto LABEL_10;
        }
      }
      else
      {
        *(void *)uint64_t buf = 0;
        *(void *)long long v30 = 0;
        *(void *)&v30[8] = 0;
      }
      uint64_t v24 = v15;
      operator delete(v15);
LABEL_10:

      CLMicroLocationAnchorAppearanceMap::updateAnchorIdSetFromMeasurements((CLMicroLocationProto::Measurement *)&v26, (uint64_t *)buf);
      char v23 = buf;
      std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&v23);
      if (++v12 == v13)
      {
        unint64_t v12 = *a3;
        uint64_t v16 = a3[1];
        goto LABEL_13;
      }
    }
  }
  uint64_t v16 = *a3;
LABEL_13:
  double v17 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationAnchorAppearanceMap::updateSeenAnchors(a2, &v26, v16 != v12, a5, v17);
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  uint64_t v18 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v19 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 4);
    uint64_t v20 = a3[1] - *a3;
    uint64_t v21 = *(void *)(a2 + 24);
    *(_DWORD *)uint64_t buf = 68290050;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)long long v30 = 2082;
    *(void *)&v30[2] = "";
    *(_WORD *)&v30[10] = 2050;
    *(void *)&v30[12] = v19;
    __int16 v31 = 2050;
    uint64_t v32 = *((void *)&v27 + 1);
    __int16 v33 = 2050;
    uint64_t v34 = v20;
    __int16 v35 = 2050;
    uint64_t v36 = v21;
    _os_log_impl(&dword_25631F000, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Updating Anchor ID Set\", \"Num. Rapport Anchor Devices\":%{public}lu, \"Num Rapport and Measured Anchor Devices\":%{public}lu, \"Number of recordings since last model\":%{public}lu, \"Anchor Appearance Map size\":%{public}lu}", buf, 0x3Au);
  }
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v26);
}

void sub_2563DF5F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void CLMicroLocationLearner::getMostRecentAnchorAppearancEntryForLoi(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v8 = *(id *)(*(void *)(a1 + 32) + 32);
  uint64_t v9 = v8;
  if (v8)
  {
    [v8 fetchMostRecentAnchorAppearancesAtLoi:a3];
  }
  else
  {
    *(void *)(a4 + 112) = 0;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)a4 = 0u;
  }

  if (!*(unsigned char *)(a4 + 112))
  {
    id v10 = *(id *)(*(void *)(a1 + 32) + 32);
    unint64_t v11 = v10;
    v15[0] = 0;
    v15[1] = 0;
    if (v10)
    {
      [v10 fetchMostRecentAnchorAppearancesAtLoi:v15];
    }
    else
    {
      uint64_t v21 = 0;
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      memset(buf, 0, sizeof(buf));
    }
    std::__optional_storage_base<CLMicroLocationConfigurationTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationConfigurationTable::Entry,false>>(a4, (uint64_t)buf);
    std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);

    if (*(unsigned char *)(a4 + 112))
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      unint64_t v12 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        unint64_t v13 = (char *)operator new(0x28uLL);
        *(void *)(v13 + 29) = 0;
        *(_OWORD *)unint64_t v13 = 0u;
        *((_OWORD *)v13 + 1) = 0u;
        boost::uuids::to_chars<char *>(a3, v13);
        if (*((char *)a2 + 23) >= 0) {
          id v14 = a2;
        }
        else {
          id v14 = (uint64_t *)*a2;
        }
        *(_DWORD *)uint64_t buf = 68289539;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = v13;
        *(_WORD *)&unsigned char buf[28] = 2081;
        *(void *)&buf[30] = v14;
        _os_log_impl(&dword_25631F000, v12, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Previous anchor appearance not found for LOI ID. Using anchor appearance map for null uuid and loi type\", \"loi id\":%{public, location:escape_only}s, \"loi type\":%{private, location:escape_only}s}", buf, 0x26u);
        operator delete(v13);
      }
    }
  }
}

void sub_2563DF84C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  operator delete(v13);

  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100](v11);
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::getRecordingUUIDsBetweenAnchorsTimestampsForLoi(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  id v10 = +[ULDefaultsSingleton shared];
  id v16 = [v10 defaultsDictionary];

  uint64_t v11 = [NSString stringWithUTF8String:"ULMaxNewRecordingsForAnchorAppearanceMap"];
  unint64_t v12 = [v16 objectForKey:v11];
  if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v13 = [v12 unsignedIntValue];
  }
  else {
    uint64_t v13 = [&unk_2704F1A58 unsignedIntValue];
  }
  uint64_t v14 = v13;

  id v15 = *(id *)(*(void *)(a1 + 32) + 88);
  id v17 = v15;
  if (v15)
  {
    [v15 fetchDistinctRecordingEventsFromTime:a2 toTime:v14 atLoiGroupId:a4 withLimit:a5];
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
}

void sub_2563DF9E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLearner::generateAnchorAppearanceMapConfigurationForLoi@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  id v8 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v9 = operator new(0x28uLL);
    std::string __p = v9;
    long long v35 = xmmword_256514540;
    _OWORD *v9 = 0u;
    v9[1] = 0u;
    *(void *)((char *)v9 + 29) = 0;
    boost::uuids::to_chars<char *>(a3, v9);
    p_p = &__p;
    if (v35 < 0) {
      p_p = __p;
    }
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *(void *)a2;
    }
    *(_DWORD *)uint64_t buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v43 = 2082;
    uint64_t v44 = "";
    __int16 v45 = 2082;
    long long v46 = p_p;
    __int16 v47 = 2082;
    uint64_t v48 = v11;
    _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"generating anchor appearance map for LOI\", \"LOI Id\":%{public, location:escape_only}s, \"LOI Type\":%{public, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(v35) < 0) {
      operator delete(__p);
    }
  }

  CLMicroLocationAnchorAppearanceMap::CLMicroLocationAnchorAppearanceMap((CLMicroLocationAnchorAppearanceMap *)&__p);
  CLMicroLocationLearner::getMostRecentAnchorAppearancEntryForLoi(a1, (uint64_t *)a2, a3, (uint64_t)buf);
  if (v50)
  {
    uint64_t v13 = v49;
    if (!v49)
    {
      unint64_t v12 = (CLMicroLocationProto::Configuration *)CLMicroLocationProto::Configuration::default_instance(v12);
      uint64_t v13 = *((void *)v12 + 3);
    }
    uint64_t v14 = *(const CLMicroLocationProto::anchorAppearancesVector **)(v13 + 8);
    if (!v14) {
      uint64_t v14 = *(const CLMicroLocationProto::anchorAppearancesVector **)(CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance(v12)
    }
                                                                    + 8);
    CLMicroLocationAnchorAppearanceMap::CLMicroLocationAnchorAppearanceMap((CLMicroLocationAnchorAppearanceMap *)v38, v14);
    int v36 = *(_DWORD *)&v40[2];
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,void *> *>>(&__p, *(uint64_t **)&v38[16], 0);
    long long v37 = v41;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v38);
    double v15 = *(double *)buf;
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    id v16 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      id v17 = operator new(0x28uLL);
      int v28 = v17;
      long long v29 = xmmword_256514540;
      _OWORD *v17 = 0u;
      v17[1] = 0u;
      *(void *)((char *)v17 + 29) = 0;
      boost::uuids::to_chars<char *>(a3, v17);
      long long v18 = &v28;
      if (v29 < 0) {
        long long v18 = v28;
      }
      *(_DWORD *)uint64_t v38 = 68289538;
      *(_DWORD *)&v38[4] = 0;
      *(_WORD *)&v38[8] = 2082;
      *(void *)&v38[10] = "";
      *(_WORD *)&v38[18] = 2082;
      *(void *)&v38[20] = v18;
      __int16 v39 = 1026;
      *(_DWORD *)uint64_t v40 = (int)v15;
      _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Relying on previous anchor appearance map from configuration table\", \"loiGroupId\":%{public, location:escape_only}s, \"timestamp\":%{public}d}", v38, 0x22u);
      if (SHIBYTE(v29) < 0) {
        operator delete(v28);
      }
    }
  }
  else
  {
    double v15 = 0.0;
  }
  double v19 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationLearner::getRecordingUUIDsBetweenAnchorsTimestampsForLoi(a1, a3, v33, v15, v19);
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  long long v20 = +[ULDefaultsSingleton shared];
  uint64_t v21 = [v20 defaultsDictionary];

  uint64_t v22 = [NSString stringWithUTF8String:"ULRapportUsageEnabled"];
  char v23 = [v21 objectForKey:v22];
  if (v23 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    int v24 = [v23 BOOLValue];
  }
  else {
    int v24 = objc_msgSend(MEMORY[0x263EFFA88], "BOOLValue", v28);
  }
  int v25 = v24;

  if (v25)
  {
    (*(void (**)(unsigned char *__return_ptr, double))(**(void **)(a1 + 24) + 40))(v38, v15);
    std::vector<CLMicroLocationRapportMonitor::Item>::__vdeallocate((void **)&v31);
    long long v31 = *(_OWORD *)v38;
    uint64_t v32 = *(void *)&v38[16];
    memset(v38, 0, 24);
    int v28 = v38;
    std::vector<CLMicroLocationRapportMonitor::Item>::__destroy_vector::operator()[abi:ne180100]((void ***)&v28);
  }
  CLMicroLocationLearner::updateAnchorAppearanceMapFromRapportAndRecordings(a1, (uint64_t)&__p, (long long **)v33, (uint64_t)&v31, v15);
  CLMicroLocationProto::AnchorAppearanceConfiguration::AnchorAppearanceConfiguration((CLMicroLocationProto::AnchorAppearanceConfiguration *)&v28);
  v30 |= 2u;
  long long v26 = (CLMicroLocationProto::anchorAppearancesVector *)v29;
  if (!(void)v29) {
    operator new();
  }
  CLMicroLocationAnchorAppearanceMap::toProtobuf((CLMicroLocationAnchorAppearanceMap *)&__p, (int *)v38);
  CLMicroLocationProto::anchorAppearancesVector::CopyFrom(v26, (const CLMicroLocationProto::anchorAppearancesVector *)v38);
  CLMicroLocationProto::anchorAppearancesVector::~anchorAppearancesVector((CLMicroLocationProto::anchorAppearancesVector *)v38);
  CLMicroLocationProtobufHelper::createConfiguration<CLMicroLocationProto::AnchorAppearanceConfiguration>((CLMicroLocationProto::Configuration *)&v28, a4, v19);
  CLMicroLocationProto::AnchorAppearanceConfiguration::~AnchorAppearanceConfiguration((CLMicroLocationProto::AnchorAppearanceConfiguration *)&v28);
  *(void *)uint64_t v38 = &v31;
  std::vector<CLMicroLocationRapportMonitor::Item>::__destroy_vector::operator()[abi:ne180100]((void ***)v38);
  if (v33[0])
  {
    v33[1] = v33[0];
    operator delete(v33[0]);
  }
  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&__p);
}

void sub_2563DFF20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  a27 = &a13;
  std::vector<CLMicroLocationRapportMonitor::Item>::__destroy_vector::operator()[abi:ne180100]((void ***)&a27);
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a35);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createConfiguration<CLMicroLocationProto::AnchorAppearanceConfiguration>(CLMicroLocationProto::Configuration *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  CLMicroLocationProto::Configuration::Configuration((CLMicroLocationProto::Configuration *)a2);
  unsigned int v6 = *((_DWORD *)a1 + 4);
  if (!CLMicroLocationProto::ConfigurationType_IsValid((CLMicroLocationProto *)v6)) {
    __assert_rtn("set_type", "microlocation.pb.h", 22117, "::CLMicroLocationProto::ConfigurationType_IsValid(value)");
  }
  int v8 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 40) = v6;
  *(_DWORD *)(a2 + 48) = v8 | 3;
  *(double *)(a2 + 8) = a3;
  CLMicroLocationProtobufHelper::setSpecificConfiguration((CLMicroLocationProtobufHelper *)a2, a1, v7);
}

void sub_2563E00DC(_Unwind_Exception *a1)
{
  CLMicroLocationProto::Configuration::~Configuration(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::generateAnchorAppearanceMap(CLMicroLocationLearner *a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (ULSettings::get<ULSettings::AdaptiveAnchorsEnable>())
  {
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    unint64_t v16 = 0;
    CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(a1, (uint64_t)&v12);
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v18 = 2082;
      double v19 = "";
      __int16 v20 = 2050;
      uint64_t v21 = (v13 - v12) >> 6;
      _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Generating anchor appearance maps\", \"LOI count\":%{public}ld}", buf, 0x1Cu);
    }
    uint64_t v5 = v12;
    uint64_t v6 = v13;
    if (v12 == v13)
    {
LABEL_13:
      if ([*(id *)(*((void *)a1 + 4) + 32) insertEntries:&v14]) {
        goto LABEL_23;
      }
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      id v10 = logObject_MicroLocation_Default;
      if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
      *(_WORD *)uint64_t buf = 0;
      uint64_t v11 = "#Warning failed to insert Anchor Appearances Map to MicroLocation DB";
    }
    else
    {
      while (1)
      {
        uint64_t v7 = *(void *)(a2 + 24);
        if (!v7) {
          std::__throw_bad_function_call[abi:ne180100]();
        }
        if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 48))(v7)) {
          break;
        }
        CLMicroLocationLearner::generateAnchorAppearanceMapConfigurationForLoi((uint64_t)a1, v5 + 40, v5 + 24, (uint64_t)buf);
        unint64_t v8 = v15;
        if (v15 >= v16)
        {
          uint64_t v9 = std::vector<CLMicroLocationConfigurationTable::Entry>::__emplace_back_slow_path<std::string const&,CLMicroLocationProto::Configuration &,boost::uuids::uuid const&>(&v14, v5 + 40, (uint64_t)buf, (void *)(v5 + 24));
        }
        else
        {
          std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,std::string const&,CLMicroLocationProto::Configuration &,boost::uuids::uuid const&>((uint64_t)&v16, v15, v5 + 40, (uint64_t)buf, (void *)(v5 + 24));
          uint64_t v9 = v8 + 112;
        }
        unint64_t v15 = v9;
        CLMicroLocationProto::Configuration::~Configuration((CLMicroLocationProto::Configuration *)buf);
        v5 += 64;
        if (v5 == v6) {
          goto LABEL_13;
        }
      }
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      id v10 = logObject_MicroLocation_Default;
      if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_23;
      }
      *(_WORD *)uint64_t buf = 0;
      uint64_t v11 = "Cancelled, skipping generation of anchor appearance maps";
    }
    _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 2u);
LABEL_23:
    *(void *)uint64_t buf = &v12;
    std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
    *(void *)uint64_t buf = &v14;
    std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  }
}

void sub_2563E03C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void **a15)
{
  a15 = (void **)&a9;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a15);
  a15 = (void **)&a12;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::onLearningBegin(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = [MEMORY[0x263EFF910] date];
  uint64_t v5 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = v4;

  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  uint64_t v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "Learning activity started", buf, 2u);
  }
  uint64_t v7 = *(void *)(a2 + 24);
  if (!v7) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 48))(v7))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    unint64_t v8 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_DEFAULT, "Learning cancelled before onLearningBegin event", v9, 2u);
    }
  }
  else
  {
    (*(void (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  }
}

uint64_t CLMicroLocationLearner::onLearningCompleted(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  [*(id *)(a1 + 16) timeIntervalSinceNow];
  double v5 = v4;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  double v6 = -v5;
  uint64_t v7 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = 68289283;
    int v22 = 0;
    __int16 v23 = 2082;
    int v24 = "";
    __int16 v25 = 2049;
    double v26 = v6;
    _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Learning activity completed\", \"duration [s]\":\"%{private}f\"}", (uint8_t *)&v21, 0x1Cu);
  }
  uint64_t v8 = *(void *)(a2 + 24);
  if (!v8) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 48))(v8))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v9 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21) = 0;
      _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_DEFAULT, "Learning cancelled before onLearningCompleted event", (uint8_t *)&v21, 2u);
    }
  }
  else
  {
    id v10 = +[ULDefaultsSingleton shared];
    uint64_t v11 = [v10 defaultsDictionary];

    uint64_t v12 = [NSString stringWithUTF8String:"ULLearningActivityMaxAllowedDuration"];
    uint64_t v13 = [v11 objectForKey:v12];
    if (v13 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      int v14 = [v13 intValue];
    }
    else {
      int v14 = [&unk_2704F1B00 intValue];
    }
    int v15 = v14;

    if ((double)v15 < v6)
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      unint64_t v16 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
      {
        int v21 = 68289539;
        int v22 = 0;
        __int16 v23 = 2082;
        int v24 = "";
        __int16 v25 = 2049;
        double v26 = v6;
        __int16 v27 = 2049;
        double v28 = (double)v15;
        _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Learning activity passed max allowed duration\", \"duration [s]\":\"%{private}f\", \"max allowed duration [s]\":\"%{private}f\"}", (uint8_t *)&v21, 0x26u);
      }
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      id v17 = logObject_MicroLocation_Default;
      if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
      {
        int v21 = 68289539;
        int v22 = 0;
        __int16 v23 = 2082;
        int v24 = "";
        __int16 v25 = 2049;
        double v26 = v6;
        __int16 v27 = 2049;
        double v28 = (double)v15;
        _os_signpost_emit_with_name_impl(&dword_25631F000, v17, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Learning activity passed max allowed duration", "{\"msg%{public}.0s\":\"Learning activity passed max allowed duration\", \"duration [s]\":\"%{private}f\", \"max allowed duration [s]\":\"%{private}f\"}", (uint8_t *)&v21, 0x26u);
      }
    }
    id v18 = CLMicroLocationLearner::sendLearningTaskAnalytics((id *)a1);
    double v19 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24));
}

void sub_2563E0980(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CLMicroLocationLearner::sendLearningTaskAnalytics(id *this)
{
  [this[2] timeIntervalSinceNow];
  double v3 = v2;
  id v4 = *((id *)this[4] + 7);
  std::string::basic_string[abi:ne180100]<0>(v18, "custom");
  int v5 = [v4 countDistinctLoiTypes:v18];
  id v6 = *((id *)this[4] + 7);
  std::string::basic_string[abi:ne180100]<0>(__p, "home");
  int v7 = [v6 countDistinctLoiTypes:__p];
  if (v17 < 0) {
    operator delete(__p[0]);
  }
  unsigned int v8 = v7 + v5;

  if (v19 < 0) {
    operator delete(v18[0]);
  }

  CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups((CLMicroLocationLearner *)this, (uint64_t)v18);
  unint64_t v9 = ((char *)v18[1] - (char *)v18[0]) >> 6;
  *((_DWORD *)this + 1) = v9;
  if (v9 < v8) {
    *((unsigned char *)this + 8) = 1;
  }
  id v10 = objc_alloc_init(MEMORY[0x263EFF9A0]);
  uint64_t v11 = [NSNumber numberWithDouble:-v3];
  [v10 setObject:v11 forKeyedSubscript:@"learningTaskRuntime"];

  uint64_t v12 = [NSNumber numberWithInt:*(unsigned int *)this];
  [v10 setObject:v12 forKeyedSubscript:@"numberOfModelsLearned"];

  uint64_t v13 = [NSNumber numberWithInt:*((unsigned int *)this + 1)];
  [v10 setObject:v13 forKeyedSubscript:@"numberOfValidLOIsForLearning"];

  int v14 = [NSNumber numberWithBool:*((unsigned __int8 *)this + 8)];
  [v10 setObject:v14 forKeyedSubscript:@"wereLOIsRemoved"];

  if (ULSettings::get<ULSettings::AnalyticsSendEventEnabled>()) {
    +[ULSendEvent sendEvent:v10 withEventName:@"com.apple.MicroLocation.LearningTask"];
  }
  __p[0] = v18;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  return v10;
}

void sub_2563E0BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  std::string __p = &a15;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](&__p);
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::learnBlueAtlasModelWorkItem(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 48))(v3))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      int v5 = "Learning cancelled before onLearningCompleted event";
LABEL_18:
      unsigned int v8 = v4;
      os_log_type_t v9 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_19;
    }
  }
  else if (ULSettings::get<ULSettings::EnableLearning>())
  {
    ULSettings::get<ULSettings::EnabledModelTypes>((uint64_t)&__p);
    if ((unint64_t)v17 <= 3) {
      std::vector<unsigned long>::__throw_out_of_range[abi:ne180100]();
    }
    uint64_t v6 = *(void *)__p;
    operator delete(__p);
    if ((v6 & 8) != 0)
    {
      ULDatabase::connectIfNecessary(*(ULDatabase **)(a1 + 32));
      if ((*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32)))
      {
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
        }
        id v10 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          std::string __p = (void *)68289026;
          LOWORD(v17) = 2082;
          *(void *)((char *)&v17 + 2) = "";
          _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MicrolocationLearner: kicking off Learning for Blue Atlas models\"}", (uint8_t *)&__p, 0x12u);
        }
        id v11 = *(id *)(*(void *)(a1 + 32) + 104);
        uint64_t v12 = v11;
        if (v11)
        {
          [v11 getAllDistinctCustomLoiIds];
        }
        else
        {
          std::string __p = 0;
          long long v17 = 0uLL;
        }

        uint64_t v13 = (uuid *)__p;
        int v14 = (uuid *)v17;
        if (__p != (void *)v17)
        {
          int v15 = 0;
          do
            v15 |= CLMicroLocationLearner::learnBlueAtlasModelInternal((CLMicroLocationLearner *)a1, v13++);
          while (v13 != v14);
          if (v15) {
            (*(void (**)(void, uint64_t))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24), 3);
          }
          uint64_t v13 = (uuid *)__p;
        }
        if (v13)
        {
          *(void *)&long long v17 = v13;
          operator delete(v13);
        }
      }
      else
      {
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
        }
        uint64_t v4 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p) = 0;
          int v5 = "#Warning Tried to run learning, but database is not valid";
          goto LABEL_18;
        }
      }
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
      }
      uint64_t v7 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(__p) = 0;
        int v5 = "Model Type BlueAtlas disabled in settings";
        unsigned int v8 = v7;
        os_log_type_t v9 = OS_LOG_TYPE_DEBUG;
LABEL_19:
        _os_log_impl(&dword_25631F000, v8, v9, v5, (uint8_t *)&__p, 2u);
      }
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p) = 0;
      int v5 = "#Warning Tried to run learning, but learning is disabled";
      goto LABEL_18;
    }
  }
}

void sub_2563E0FF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL CLMicroLocationLearner::learnBlueAtlasModelInternal(CLMicroLocationLearner *this, uuid *a2)
{
  uint64_t v95 = *MEMORY[0x263EF8340];
  double v4 = cl::chrono::CFAbsoluteTimeClock::now();
  memset(v61, 0, sizeof(v61));
  int v62 = 1065353216;
  CLMicroLocationLearner::getAllClientsAndSupportedLocationTypes((uint64_t)this, 4, 0, &v59);
  uint64_t v5 = v59;
  uint64_t v49 = v60;
  if (v59 == v60)
  {
    int v6 = 0;
  }
  else
  {
    int v6 = 0;
    *((void *)&v7 + 1) = 0x8000000000000028;
    *(void *)&long long v7 = 68289794;
    long long v47 = v7;
    uint64_t v48 = this;
    do
    {
      if ((CLMiLoService::uint64ToLocationTypesBitset(*(void *)(v5 + 40)) & 4) != 0)
      {
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
        }
        unsigned int v8 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          os_log_type_t v9 = (const std::string::value_type *)v5;
          if (*(char *)(v5 + 23) < 0) {
            os_log_type_t v9 = *(const std::string::value_type **)v5;
          }
          id v10 = operator new(0x28uLL);
          uint64_t v67 = v10;
          long long v68 = xmmword_256514540;
          _OWORD *v10 = 0u;
          v10[1] = 0u;
          *(void *)((char *)v10 + 29) = 0;
          boost::uuids::to_chars<char *>(v5 + 24, v10);
          if (v68 >= 0) {
            id v11 = &v67;
          }
          else {
            id v11 = v67;
          }
          uint64_t v12 = operator new(0x28uLL);
          std::string __p = v12;
          long long v77 = xmmword_256514540;
          *uint64_t v12 = 0u;
          v12[1] = 0u;
          *(void *)((char *)v12 + 29) = 0;
          boost::uuids::to_chars<char *>((uint64_t)a2, v12);
          p_p = &__p;
          if (v77 < 0) {
            p_p = __p;
          }
          *(_DWORD *)uint64_t buf = v47;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&unsigned char buf[18] = 2082;
          *(void *)&buf[20] = v9;
          __int16 v83 = 2082;
          BOOL v84 = v11;
          __int16 v85 = 2082;
          __int16 v86 = p_p;
          _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Start learning Blue Atlas model\", \"client\":%{public, location:escape_only}s, \"Service UUID\":%{public, location:escape_only}s, \"LOI\":%{public, location:escape_only}s}", buf, 0x30u);
          if (SHIBYTE(v77) < 0) {
            operator delete(__p);
          }
          this = v48;
          if (SHIBYTE(v68) < 0) {
            operator delete(v67);
          }
        }

        long long v57 = 0uLL;
        uint64_t v58 = 0;
        memset(v56, 0, sizeof(v56));
        uint64_t v14 = ULSettings::get<ULSettings::SimilarityListMaxNumberOfItems>();
        id v15 = *(id *)(*((void *)this + 4) + 40);
        unint64_t v16 = v15;
        std::string __p = 0;
        if (v15) {
          [v15 fetchRecordingLabelsForServiceUuid:v5 + 24 atLoiGroupID:a2 fromTime:&__p limit:v14];
        }
        else {
          memset(buf, 0, 24);
        }
        std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__vdeallocate((uint64_t *)&v57);
        long long v57 = *(_OWORD *)buf;
        uint64_t v58 = *(void *)&buf[16];
        memset(buf, 0, 24);
        uint64_t v67 = buf;
        std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&v67);

        CLMicroLocationBlueAtlasAlgorithms::learnBlueAtlasModel(*((void *)this + 4), (CLMicroLocationFingerprintPool *)v61, a2, (uint64_t *)&v57, (uint64_t)buf);
        CLMicroLocationModel::toProtobuf((CLMicroLocationModel *)buf, (uint64_t)v55);
        LODWORD(v67) = 0;
        boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v67);
        uint64_t v17 = boost::uuids::random_generator_pure::operator()((uint64_t)&v67);
        uint64_t v19 = v18;
        if (*(char *)(v5 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v53, *(const std::string::value_type **)v5, *(void *)(v5 + 8));
        }
        else
        {
          long long v20 = *(_OWORD *)v5;
          v53.__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
          *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v20;
        }
        char v54 = 1;
        long long v74 = *(_OWORD *)(v5 + 24);
        char v75 = 1;
        CLMicroLocationModelTable::Entry::Entry(&__p, v17, v19, v55, &v53, &v74, *(void *)a2->var0, *(void *)&a2->var0[8], v4);
        if (v54 && SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v53.__r_.__value_.__l.__data_);
        }
        boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v67);
        id v21 = *(id *)(*((void *)this + 4) + 72);
        CLMicroLocationModelTable::Entry::Entry((CLMicroLocationModelTable::Entry *)&v67, (const CLMicroLocationModelTable::Entry *)&__p);
        char v50 = 0;
        uint64_t v51 = 0;
        uint64_t v52 = 0;
        uint64_t v63 = &v50;
        char v64 = 0;
        char v50 = (CLMicroLocationModelTable::Entry *)operator new(0x138uLL);
        uint64_t v51 = v50;
        uint64_t v52 = (char *)v50 + 312;
        uint64_t v51 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry*>((uint64_t)&v52, (CLMicroLocationModelTable::Entry *)&v67, (CLMicroLocationModelTable::Entry *)v73, v50);
        int v22 = [v21 insertEntries:&v50];
        uint64_t v63 = &v50;
        std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&v63);
        if (v72 && v71 < 0) {
          operator delete(v70);
        }
        CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)&v69);

        if (v22)
        {
          CandidateQualityReasons = (int **)CLMicroLocationModel::getCandidateQualityReasons((CLMicroLocationModel *)buf);
          int v24 = *CandidateQualityReasons;
          __int16 v25 = CandidateQualityReasons[1];
          if (*CandidateQualityReasons == v25)
          {
            LOBYTE(v28) = 0;
            LOBYTE(v27) = 0;
            char v26 = 0;
          }
          else
          {
            char v26 = 0;
            int v27 = 0;
            int v28 = 0;
            do
            {
              int v30 = *v24++;
              int v29 = v30;
              if (v30 == 1) {
                int v31 = 1;
              }
              else {
                int v31 = v27;
              }
              if (v29 == 3) {
                int v32 = 1;
              }
              else {
                int v32 = v28;
              }
              if (v29 == 3) {
                int v31 = v27;
              }
              if (v29 == 8)
              {
                char v26 = 1;
              }
              else
              {
                int v28 = v32;
                int v27 = v31;
              }
            }
            while (v24 != v25);
          }
          uint64_t v33 = *((void *)this + 3);
          CLMicroLocationModelTable::Entry::Entry((CLMicroLocationModelTable::Entry *)&v67, (const CLMicroLocationModelTable::Entry *)&__p);
          v73[0] = 1;
          (*(void (**)(uint64_t, uint64_t, void **, void))(*(void *)v33 + 24))(v33, 3, &v67, 0);
          std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v67);
          unsigned int v34 = CLMicroLocationModel::getQualityIndicator((CLMicroLocationModel *)buf) - 1;
          long long v35 = @"modelQualityUnknown";
          if (v34 <= 2) {
            long long v35 = (__CFString *)*((void *)&off_2653F9AC0 + (int)v34);
          }
          unsigned int v36 = CLMicroLocationModel::getCandidateQualityIndicator((CLMicroLocationModel *)buf) - 1;
          long long v37 = @"modelQualityUnknown";
          if (v36 <= 2) {
            long long v37 = (__CFString *)*((void *)&off_2653F9AC0 + (int)v36);
          }
          v66[0] = &unk_2704F1A10;
          v65[0] = @"learningOccurred";
          v65[1] = @"numAccessPoints";
          uint64_t v38 = objc_msgSend(NSNumber, "numberWithUnsignedInt:", v88[28], v47);
          __int16 v39 = (void *)v38;
          uint64_t v40 = @"modelIsStable";
          if (!buf[8]) {
            uint64_t v40 = @"modelNotStable";
          }
          v66[1] = v38;
          v66[2] = v40;
          v65[2] = @"isModelStable";
          v65[3] = @"modelQuality";
          v66[3] = v35;
          v66[4] = v37;
          v65[4] = @"candidateModelQuality";
          v65[5] = @"qualityReasonLowNumberOfObservations";
          if (v28) {
            uint64_t v41 = MEMORY[0x263EFFA88];
          }
          else {
            uint64_t v41 = MEMORY[0x263EFFA80];
          }
          if (v27) {
            uint64_t v42 = MEMORY[0x263EFFA88];
          }
          else {
            uint64_t v42 = MEMORY[0x263EFFA80];
          }
          v66[5] = v41;
          v66[6] = v42;
          v65[6] = @"qualityReasonLowNumberOfWiFiAnchors";
          v65[7] = @"candidateQualityReasonLowNumberRobustWiFiSources";
          if (v26) {
            uint64_t v43 = MEMORY[0x263EFFA88];
          }
          else {
            uint64_t v43 = MEMORY[0x263EFFA80];
          }
          v66[7] = v43;
          uint64_t v44 = [NSDictionary dictionaryWithObjects:v66 forKeys:v65 count:8];

          this = v48;
          CLMicroLocationLearner::sendBlueAtlasLearningAnalytics(v45, v44);

          ++v6;
        }
        if (v81 && v80 < 0) {
          operator delete(v79);
        }
        CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)&v78);
        CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)v55);
        if (v94 < 0) {
          operator delete(v93);
        }
        if (v91)
        {
          int v92 = v91;
          operator delete(v91);
        }
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)&v90);
        uint64_t v67 = &v89;
        std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v67);
        std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v88);
        std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v87);
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&buf[16]);
        *(void *)uint64_t buf = v56;
        std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
        *(void *)uint64_t buf = &v57;
        std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      }
      v5 += 48;
    }
    while (v5 != v49);
  }
  *(void *)uint64_t buf = &v59;
  std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::~__hash_table((uint64_t)v61);
  return v6 > 0;
}

void sub_2563E17C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::~__hash_table((uint64_t)&a67);
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::updateModelDaysWithRecordings(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a4 + 16))
  {
    if ([*(id *)(*(void *)(a1 + 32) + 88) countRecordingEventsFromTime:a5 toTime:*(double *)(a4 + 8) atLoiGroupId:*a3])int v7 = *(_DWORD *)a4 + 1; {
    else
    }
      int v7 = *(_DWORD *)a4;
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    unsigned int v8 = logObject_MicroLocation_Default;
    int v7 = 1;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      int v11 = 67109120;
      int v12 = 1;
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_DEBUG, "Learning model without old model. Setting number of days with recordings to %d", (uint8_t *)&v11, 8u);
    }
  }
  *(_DWORD *)(a2 + 12) = v7;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
  }
  os_log_type_t v9 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(_DWORD *)(a2 + 12);
    int v11 = 68289283;
    int v12 = 0;
    __int16 v13 = 2082;
    uint64_t v14 = "";
    __int16 v15 = 1025;
    int v16 = v10;
    _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Setting model number of days with recordings\", \"numDaysWithRecordings\":%{private}u}", (uint8_t *)&v11, 0x18u);
  }
}

void std::vector<unsigned long>::reserve(void **a1, unint64_t a2)
{
  double v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(v3, a2);
    int v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    os_log_type_t v9 = &v6[8 * v8];
    int v10 = (char *)*a1;
    int v11 = (char *)a1[1];
    int v12 = v7;
    if (v11 != *a1)
    {
      int v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t CLMicroLocationModel::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  if (a1 != a2)
  {
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,void *> *>>((void *)(a1 + 16), *(uint64_t **)(a2 + 32), 0);
  }
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  std::__optional_storage_base<CLMicroLocationModel::SimilarityListData,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModel::SimilarityListData,false>>(a1 + 72, a2 + 72);
  std::__optional_storage_base<CLMicroLocationModel::BlueAtlasData,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModel::BlueAtlasData,false>>(a1 + 200, a2 + 200);
  long long v4 = *(_OWORD *)(a2 + 296);
  *(_OWORD *)(a1 + 308) = *(_OWORD *)(a2 + 308);
  *(_OWORD *)(a1 + 296) = v4;
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__vdeallocate((uint64_t *)(a1 + 328));
  uint64_t v5 = *(void *)(a2 + 336);
  *(void *)(a1 + 328) = *(void *)(a2 + 328);
  *(void *)(a1 + 336) = v5;
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  *(void *)(a2 + 328) = 0;
  *(void *)(a2 + 336) = 0;
  *(void *)(a2 + 344) = 0;
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__move_assign(a1 + 352, (uint64_t *)(a2 + 352));
  *(void *)(a1 + 392) = *(void *)(a2 + 392);
  std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 400, (__n128 *)(a2 + 400));
  int v6 = (void **)(a1 + 424);
  if (*(char *)(a1 + 447) < 0) {
    operator delete(*v6);
  }
  long long v7 = *(_OWORD *)(a2 + 424);
  *(void *)(a1 + 440) = *(void *)(a2 + 440);
  *(_OWORD *)int v6 = v7;
  *(unsigned char *)(a2 + 447) = 0;
  *(unsigned char *)(a2 + 424) = 0;
  return a1;
}

uint64_t ULSettings::get<ULSettings::MinimumNumberOfDaysWithRecordingsInStableModel>()
{
  os_log_t v0 = +[ULDefaultsSingleton shared];
  uint64_t v1 = [v0 defaultsDictionary];

  double v2 = [NSString stringWithUTF8String:"ULMinimumNumberOfDaysWithRecordingsInStableModel"];
  uint64_t v3 = [v1 objectForKey:v2];
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v4 = [v3 unsignedLongValue];
  }
  else {
    uint64_t v4 = [&unk_2704F1A88 unsignedLongValue];
  }
  uint64_t v5 = v4;

  return v5;
}

void sub_2563E1D60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2563E1E64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLearner::sendBlueAtlasLearningAnalytics(CLMicroLocationLearner *this, NSDictionary *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  double v2 = a2;
  if (ULSettings::get<ULSettings::AnalyticsSendEventEnabled>())
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v3 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      v5[0] = 68289539;
      v5[1] = 0;
      __int16 v6 = 2082;
      long long v7 = "";
      __int16 v8 = 2081;
      uint64_t v9 = [@"com.apple.MicroLocation.CustomLoiModelLearn" UTF8String];
      __int16 v10 = 2113;
      int v11 = v2;
      _os_log_impl(&dword_25631F000, v3, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#MiLoLearner, sending core analytics\", \"event\":%{private, location:escape_only}s, \"eventFields\":%{private, location:escape_only}@}", (uint8_t *)v5, 0x26u);
    }

    +[ULSendEvent sendEvent:v2 withEventName:@"com.apple.MicroLocation.CustomLoiModelLearn"];
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    }
    uint64_t v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5[0]) = 0;
      _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "#MiLoLearner, CoreAnalytics Disabled", (uint8_t *)v5, 2u);
    }
  }
}

void sub_2563E2038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLearner::learnBlueAtlasModel(CLMicroLocationLearner *this, uuid *a2)
{
  (*(void (**)(void))(**((void **)this + 3) + 16))(*((void *)this + 3));
  if (CLMicroLocationLearner::learnBlueAtlasModelInternal(this, a2)) {
    (*(void (**)(void, uint64_t))(**((void **)this + 3) + 32))(*((void *)this + 3), 3);
  }
  uint64_t v4 = *(uint64_t (**)(void))(**((void **)this + 3) + 48);
  return v4();
}

void *CLMicroLocationLearner::executeWorkItems(void *result, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = result[5];
  for (uint64_t i = result[6]; v2 != i; v2 += 32)
  {
    std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
    uint64_t v5 = *(void *)(v2 + 24);
    if (!v5) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 48))(v5, v6);
    uint64_t result = std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  }
  return result;
}

void sub_2563E21D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_47()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void std::vector<BOOL>::reserve(char **a1, unint64_t a2)
{
  if (a2 > (void)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    __int16 v10 = 0;
    long long v11 = 0uLL;
    std::vector<BOOL>::__vallocate[abi:ne180100](&v10, a2);
    unint64_t v3 = (unint64_t)a1[1];
    __int16 v8 = *a1;
    int v9 = 0;
    __int16 v6 = &v8[8 * (v3 >> 6)];
    int v7 = v3 & 0x3F;
    std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    uint64_t v4 = *a1;
    *a1 = v10;
    __int16 v10 = v4;
    long long v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    long long v11 = v5;
    if (v4) {
      operator delete(v4);
    }
  }
}

void sub_2563E22E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<BOOL>::push_back(uint64_t a1, unsigned char *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64) {
      unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    }
    if (v4 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    std::vector<BOOL>::reserve((char **)a1, v7);
    unint64_t v4 = *(void *)(a1 + 8);
  }
  *(void *)(a1 + 8) = v4 + 1;
  __int16 v8 = *(char **)a1;
  unint64_t v9 = v4 >> 6;
  uint64_t v10 = 1 << v4;
  if (*a2) {
    uint64_t v11 = *(void *)&v8[8 * v9] | v10;
  }
  else {
    uint64_t v11 = *(void *)&v8[8 * v9] & ~v10;
  }
  *(void *)&v8[8 * v9] = v11;
}

void *std::vector<BOOL>::__vallocate[abi:ne180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a1[1];
  unint64_t v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0;
    }
    *(void *)(*a1 + 8 * v6) = 0;
  }
  int v7 = *(_DWORD *)(a2 + 8);
  uint64_t v8 = *(void *)a3;
  int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *a1 + 8 * (v4 >> 6);
  uint64_t v16 = *(void *)a2;
  int v17 = v7;
  uint64_t v14 = v8;
  int v15 = v9;
  uint64_t v12 = v10;
  int v13 = v4 & 0x3F;
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(&v16, &v14, &v12, (uint64_t)&v11);
}

void std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5 = *((_DWORD *)a1 + 2);
  uint64_t v6 = *a2;
  int v7 = *((_DWORD *)a2 + 2);
  uint64_t v16 = *a1;
  int v17 = v5;
  uint64_t v14 = v6;
  int v15 = v7;
  int v8 = *((_DWORD *)a3 + 2);
  uint64_t v12 = *a3;
  int v13 = v8;
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  int v9 = v19;
  uint64_t v10 = v20;
  int v11 = v21;
  *(void *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(void *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v4 = *(void **)a1;
  int v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(void *)a1 != *(void *)a2 || v5 != *(_DWORD *)(a2 + 8); int v5 = *(_DWORD *)(a1 + 8))
  {
    int v8 = *(uint64_t **)a3;
    uint64_t v9 = 1 << i;
    if ((*v4 >> v5)) {
      uint64_t v10 = *v8 | v9;
    }
    else {
      uint64_t v10 = *v8 & ~v9;
    }
    *int v8 = v10;
    if (v5 == 63)
    {
      int v11 = 0;
      *(void *)a1 = v4 + 1;
    }
    else
    {
      int v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      int i = 0;
      *(void *)a3 += 8;
    }
    else
    {
      int i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    unint64_t v4 = *(void **)a1;
  }
  *(void *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(void *)(a4 + 16) = *(void *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

id std::optional<NSMutableDictionary * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return *(id *)a1;
  }
  else {
    return 0;
  }
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry const*,CLMicroLocationConfigurationTable::Entry const*,CLMicroLocationConfigurationTable::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry const&>(a1, v4, v6);
      v6 += 112;
      uint64_t v4 = v12 + 112;
      v12 += 112;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_2563E26A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__optional_destruct_base<CLMicroLocationModel,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 448))
  {
    if (*(char *)(a1 + 447) < 0) {
      operator delete(*(void **)(a1 + 424));
    }
    uint64_t v2 = *(void **)(a1 + 400);
    if (v2)
    {
      *(void *)(a1 + 408) = v2;
      operator delete(v2);
    }
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table(a1 + 352);
    uint64_t v4 = (void **)(a1 + 328);
    std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100](&v4);
    std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100](a1 + 200);
    std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100](a1 + 72);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 16);
  }
  return a1;
}

void ___ZL47_CLLogObjectForCategory_MicroLocationQE_Defaultv_block_invoke_0()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocationQE");
  uint64_t v1 = (void *)logObject_MicroLocationQE_Default;
  logObject_MicroLocationQE_Default = (uint64_t)v0;
}

void std::__optional_storage_base<CLMicroLocationModel::SimilarityListData,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModel::SimilarityListData,false>>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 120) == *(unsigned __int8 *)(a2 + 120))
  {
    if (*(unsigned char *)(a1 + 120))
    {
      std::vector<CLMicroLocationResultInternal>::__move_assign(a1, (__n128 *)a2);
      std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 24, (__n128 *)(a2 + 24));
      std::__optional_storage_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationUtils::ProbabilityMatrix,false>>((uint64_t *)(a1 + 48), a2 + 48);
      std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 80, (__n128 *)(a2 + 80));
      uint64_t v4 = *(void *)(a2 + 104);
      *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
      *(void *)(a1 + 104) = v4;
    }
  }
  else if (*(unsigned char *)(a1 + 120))
  {
    std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::reset[abi:ne180100](a1);
  }
  else
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationModel::SimilarityListData,CLMicroLocationModel::SimilarityListData,CLMicroLocationModel::SimilarityListData*>(a1, a2);
    *(unsigned char *)(a1 + 120) = 1;
  }
}

void std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 120))
  {
    uint64_t v2 = *(void **)(a1 + 80);
    if (v2)
    {
      *(void *)(a1 + 88) = v2;
      operator delete(v2);
    }
    if (*(unsigned char *)(a1 + 72))
    {
      uint64_t v3 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = 0;
      if (v3) {
        MEMORY[0x25A2A6320](v3, 0x1000C8000313F17);
      }
    }
    uint64_t v4 = *(void **)(a1 + 24);
    if (v4)
    {
      *(void *)(a1 + 32) = v4;
      operator delete(v4);
    }
    int v5 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v5;
      operator delete(v5);
    }
    *(unsigned char *)(a1 + 120) = 0;
  }
}

__n128 std::__optional_storage_base<CLMicroLocationModel::BlueAtlasData,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModel::BlueAtlasData,false>>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a2 + 88))
  {
    if (*(unsigned char *)(a1 + 88))
    {
      std::vector<CLMicroLocationResultInternal>::__move_assign(a1, (__n128 *)a2);
      std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 24, (__n128 *)(a2 + 24));
      __n128 result = *(__n128 *)(a2 + 48);
      long long v5 = *(_OWORD *)(a2 + 64);
      *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
      *(__n128 *)(a1 + 48) = result;
      *(_OWORD *)(a1 + 64) = v5;
    }
  }
  else if (*(unsigned char *)(a1 + 88))
  {
    std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::reset[abi:ne180100](a1);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    __n128 result = *(__n128 *)(a2 + 48);
    long long v6 = *(_OWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
    *(__n128 *)(a1 + 48) = result;
    *(_OWORD *)(a1 + 64) = v6;
    *(unsigned char *)(a1 + 88) = 1;
  }
  return result;
}

void std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(void *)(a1 + 32) = v2;
      operator delete(v2);
    }
    uint64_t v3 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v3;
      operator delete(v3);
    }
    *(unsigned char *)(a1 + 88) = 0;
  }
}

void std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::clear(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  long long v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  int v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    void *v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void CLMicroLocationFingerprintDataSources::IInterruptibleDataSource::CancelledException::~CancelledException(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x25A2A6340);
}

uint64_t std::__optional_destruct_base<CLMicroLocationModel,false>::__optional_destruct_base[abi:ne180100]<CLMicroLocationModel>(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  std::unordered_map<boost::uuids::uuid,CLMicroLocationAnchorAppearance>::unordered_map(a1 + 16, a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  std::__optional_move_base<CLMicroLocationModel::SimilarityListData,false>::__optional_move_base[abi:ne180100]((unsigned char *)(a1 + 72), a2 + 72);
  std::__optional_move_base<CLMicroLocationModel::BlueAtlasData,false>::__optional_move_base[abi:ne180100]((unsigned char *)(a1 + 200), a2 + 200);
  long long v4 = *(_OWORD *)(a2 + 296);
  *(_OWORD *)(a1 + 308) = *(_OWORD *)(a2 + 308);
  *(_OWORD *)(a1 + 296) = v4;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 328) = 0;
  uint64_t v5 = *(void *)(a2 + 336);
  *(void *)(a1 + 328) = *(void *)(a2 + 328);
  *(void *)(a1 + 336) = v5;
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  *(void *)(a2 + 328) = 0;
  *(void *)(a2 + 336) = 0;
  *(void *)(a2 + 344) = 0;
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a1 + 352, (uint64_t *)(a2 + 352));
  *(void *)(a1 + 392) = *(void *)(a2 + 392);
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 400);
  *(void *)(a1 + 416) = *(void *)(a2 + 416);
  *(void *)(a2 + 400) = 0;
  *(void *)(a2 + 408) = 0;
  *(void *)(a2 + 416) = 0;
  long long v6 = *(_OWORD *)(a2 + 424);
  *(void *)(a1 + 440) = *(void *)(a2 + 440);
  *(_OWORD *)(a1 + 424) = v6;
  *(void *)(a2 + 432) = 0;
  *(void *)(a2 + 440) = 0;
  *(void *)(a2 + 424) = 0;
  *(unsigned char *)(a1 + 448) = 1;
  return a1;
}

void sub_2563E2C44(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned char *std::__optional_move_base<CLMicroLocationModel::SimilarityListData,false>::__optional_move_base[abi:ne180100](unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[120] = 0;
  if (*(unsigned char *)(a2 + 120))
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationModel::SimilarityListData,CLMicroLocationModel::SimilarityListData,CLMicroLocationModel::SimilarityListData*>((uint64_t)a1, a2);
    a1[120] = 1;
  }
  return a1;
}

void sub_2563E2C9C(_Unwind_Exception *a1)
{
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

unsigned char *std::__optional_move_base<CLMicroLocationModel::BlueAtlasData,false>::__optional_move_base[abi:ne180100](unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  a1[88] = 0;
  std::__optional_storage_base<CLMicroLocationModel::BlueAtlasData,false>::__construct_from[abi:ne180100]<std::__optional_move_base<CLMicroLocationModel::BlueAtlasData,false>>((uint64_t)a1, a2);
  return a1;
}

__n128 std::__optional_storage_base<CLMicroLocationModel::BlueAtlasData,false>::__construct_from[abi:ne180100]<std::__optional_move_base<CLMicroLocationModel::BlueAtlasData,false>>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 88))
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    *(void *)(a2 + 24) = 0;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    __n128 result = *(__n128 *)(a2 + 48);
    long long v3 = *(_OWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
    *(__n128 *)(a1 + 48) = result;
    *(_OWORD *)(a1 + 64) = v3;
    *(unsigned char *)(a1 + 88) = 1;
  }
  return result;
}

void *std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0>,void ()(std::function<BOOL ()(void)>)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_2704DD650;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DD650;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0>,void ()(std::function<BOOL ()(void)>)>::operator()(uint64_t a1, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v5);
  CLMicroLocationLearner::onLearningBegin(v3, (uint64_t)v6);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  return std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v5);
}

void sub_2563E2EE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0>,void ()(std::function<BOOL ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_0>,void ()(std::function<BOOL ()(void)>)>::target_type()
{
}

void std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1>,void ()(std::function<BOOL ()(void)>)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_2704DD6E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DD6E0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1>,void ()(std::function<BOOL ()(void)>)>::operator()(uint64_t a1, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  uint64_t v3 = *(CLMicroLocationLearner **)(a1 + 8);
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v5);
  CLMicroLocationLearner::generateAnchorAppearanceMap(v3, (uint64_t)v6);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  return std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v5);
}

void sub_2563E30E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1>,void ()(std::function<BOOL ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_1>,void ()(std::function<BOOL ()(void)>)>::target_type()
{
}

void std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2>,void ()(std::function<BOOL ()(void)>)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_2704DD760;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DD760;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2>,void ()(std::function<BOOL ()(void)>)>::operator()(uint64_t a1, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  uint64_t v3 = *(ULDatabase ***)(a1 + 8);
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v5);
  CLMicroLocationLearner::learnFromModelType(v3, (uint64_t)v6, 0);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  return std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v5);
}

void sub_2563E326C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2>,void ()(std::function<BOOL ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_2>,void ()(std::function<BOOL ()(void)>)>::target_type()
{
}

void std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3>,void ()(std::function<BOOL ()(void)>)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_2704DD7E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DD7E0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3>,void ()(std::function<BOOL ()(void)>)>::operator()(uint64_t a1, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  uint64_t v3 = *(ULDatabase ***)(a1 + 8);
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v5);
  CLMicroLocationLearner::learnFromModelType(v3, (uint64_t)v6, 1u);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  return std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v5);
}

void sub_2563E33F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3>,void ()(std::function<BOOL ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_3>,void ()(std::function<BOOL ()(void)>)>::target_type()
{
}

void std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4>,void ()(std::function<BOOL ()(void)>)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_2704DD860;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DD860;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4>,void ()(std::function<BOOL ()(void)>)>::operator()(uint64_t a1, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  uint64_t v3 = *(ULDatabase ***)(a1 + 8);
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v5);
  CLMicroLocationLearner::learnFromModelType(v3, (uint64_t)v6, 2u);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  return std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v5);
}

void sub_2563E357C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4>,void ()(std::function<BOOL ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_4>,void ()(std::function<BOOL ()(void)>)>::target_type()
{
}

void std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5>,void ()(std::function<BOOL ()(void)>)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_2704DD8E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DD8E0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5>,void ()(std::function<BOOL ()(void)>)>::operator()(uint64_t a1, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v5);
  CLMicroLocationLearner::learnBlueAtlasModelWorkItem(v3, (uint64_t)v6);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  return std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v5);
}

void sub_2563E3700(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5>,void ()(std::function<BOOL ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_5>,void ()(std::function<BOOL ()(void)>)>::target_type()
{
}

void std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6>,void ()(std::function<BOOL ()(void)>)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_2704DD960;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DD960;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6>,void ()(std::function<BOOL ()(void)>)>::operator()(uint64_t a1, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v5);
  CLMicroLocationLearner::onLearningCompleted(v3, (uint64_t)v6);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  return std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v5);
}

void sub_2563E3884(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6>,void ()(std::function<BOOL ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6,std::allocator<CLMicroLocationLearner::CLMicroLocationLearner(CLMicroLocationLearner::ILearnerDelegate &,ULDatabase &)::$_6>,void ()(std::function<BOOL ()(void)>)>::target_type()
{
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::function<void ()(std::function<BOOL ()(void)>)>>,std::function<void ()(std::function<BOOL ()(void)>)> const*,std::function<void ()(std::function<BOOL ()(void)>)> const*,std::function<void ()(std::function<BOOL ()(void)>)>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::__value_func[abi:ne180100](a4 + v7, a2 + v7);
      v7 += 32;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_2563E3954(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 32;
    do
    {
      std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::~__value_func[abi:ne180100]((void *)(v4 + v2));
      v2 -= 32;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void std::vector<std::function<void ()(std::function<BOOL ()(void)>)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::~__value_func[abi:ne180100](v4 - 4);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<CLMicroLocationRecordingEventsTable::Entry>::__vdeallocate(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 248;
        std::allocator<CLMicroLocationRecordingEventsTable::Entry>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

long long *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoLoiTable::Entry *,CLMiLoLoiTable::Entry *,CLMiLoLoiTable::Entry *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      long long v8 = v5[1];
      *(void *)(a4 + 32) = *((void *)v5 + 4);
      *(_OWORD *)a4 = v7;
      *(_OWORD *)(a4 + 16) = v8;
      uint64_t v9 = (void **)(a4 + 40);
      if (*(char *)(a4 + 63) < 0) {
        operator delete(*v9);
      }
      long long v10 = *(long long *)((char *)v5 + 40);
      *(void *)(a4 + 56) = *((void *)v5 + 7);
      *(_OWORD *)uint64_t v9 = v10;
      *((unsigned char *)v5 + 63) = 0;
      *((unsigned char *)v5 + 40) = 0;
      a4 += 64;
      v5 += 4;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *,false>(unint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unsigned __int8 v133 = a2 - 4;
    unint64_t v9 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v9;
          uint64_t v10 = (uint64_t)a2 - v9;
          unint64_t v11 = (uint64_t)((uint64_t)a2 - v9) >> 6;
          if (v5 || !v4)
          {
            switch(v11)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v60 = a2 - 4;
                if (*(double *)v9 < a2[-4].n128_f64[0])
                {
                  unint64_t v61 = *(void *)(v9 + 40);
                  unint64_t v171 = *(void *)(v9 + 32);
                  __n128 v155 = *(__n128 *)v9;
                  __n128 v163 = *(__n128 *)(v9 + 16);
                  *(void *)&long long v141 = *(void *)(v9 + 48);
                  *(void *)((char *)&v141 + 7) = *(void *)(v9 + 55);
                  unsigned __int8 v62 = *(unsigned char *)(v9 + 63);
                  *(void *)(v9 + 40) = 0;
                  *(void *)(v9 + 48) = 0;
                  *(void *)(v9 + 56) = 0;
                  __n128 v63 = *v60;
                  __n128 v64 = a2[-3];
                  *(void *)(v9 + 32) = a2[-2].n128_u64[0];
                  *(__n128 *)unint64_t v9 = v63;
                  *(__n128 *)(v9 + 16) = v64;
                  long long v65 = *(long long *)((char *)&a2[-2] + 8);
                  *(void *)(v9 + 56) = a2[-1].n128_u64[1];
                  *(_OWORD *)(v9 + 40) = v65;
                  a2[-2].n128_u64[0] = v171;
                  *uint64_t v60 = v155;
                  a2[-3] = v163;
                  a2[-2].n128_u64[1] = v61;
                  *(unint64_t *)((char *)a2[-1].n128_u64 + 7) = *(void *)((char *)&v141 + 7);
                  a2[-1].n128_u64[0] = v141;
                  a2[-1].n128_u8[15] = v62;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(v9, (__n128 *)(v9 + 64), v133);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(v9, v9 + 64, v9 + 128, (uint64_t)v133);
                break;
              case 5uLL:
                std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *,0>(v9, v9 + 64, v9 + 128, v9 + 192, (long long *)v133);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v10 <= 1535)
          {
            uint64_t v66 = (__n128 *)(v9 + 64);
            BOOL v68 = (__n128 *)v9 == a2 || v66 == a2;
            if (a4)
            {
              if (!v68)
              {
                uint64_t v69 = 0;
                unint64_t v70 = v9;
                do
                {
                  char v71 = v66;
                  double v72 = *(double *)(v70 + 64);
                  if (*(double *)v70 < v72)
                  {
                    long long v156 = *(_OWORD *)(v70 + 72);
                    long long v164 = *(_OWORD *)(v70 + 88);
                    uint64_t v73 = *(void *)(v70 + 104);
                    *(void *)uuid v142 = *(void *)(v70 + 112);
                    *(void *)&v142[7] = *(void *)(v70 + 119);
                    char v74 = *(unsigned char *)(v70 + 127);
                    *(void *)(v70 + 112) = 0;
                    *(void *)(v70 + 120) = 0;
                    *(void *)(v70 + 104) = 0;
                    uint64_t v75 = v69;
                    unsigned __int8 v76 = v66[3].n128_u8[15];
                    while (1)
                    {
                      uint64_t v77 = v75;
                      uint64_t v78 = a1 + v75;
                      long long v79 = *(_OWORD *)(a1 + v75 + 16);
                      *(_OWORD *)(v78 + 64) = *(_OWORD *)(a1 + v75);
                      *(_OWORD *)(v78 + 80) = v79;
                      *(void *)(v78 + 96) = *(void *)(a1 + v75 + 32);
                      char v80 = (void **)(a1 + v75 + 104);
                      if ((v76 & 0x80) != 0) {
                        operator delete(*v80);
                      }
                      *(_OWORD *)char v80 = *(_OWORD *)(v78 + 40);
                      *(void *)(v78 + 120) = *(void *)(v78 + 56);
                      *(unsigned char *)(v78 + 63) = 0;
                      *(unsigned char *)(v78 + 40) = 0;
                      if (!v77) {
                        break;
                      }
                      unsigned __int8 v76 = 0;
                      uint64_t v75 = v77 - 64;
                      if (*(double *)(a1 + v77 - 64) >= v72)
                      {
                        unint64_t v81 = a1 + v77;
                        goto LABEL_88;
                      }
                    }
                    unint64_t v81 = a1;
LABEL_88:
                    *(double *)unint64_t v81 = v72;
                    *(_OWORD *)(v81 + 24) = v164;
                    *(_OWORD *)(v81 + 8) = v156;
                    *(void *)(a1 + v77 + 40) = v73;
                    *(void *)(v81 + 48) = *(void *)v142;
                    *(void *)(v81 + 55) = *(void *)&v142[7];
                    *(unsigned char *)(v81 + 63) = v74;
                  }
                  uint64_t v66 = v71 + 4;
                  v69 += 64;
                  unint64_t v70 = (unint64_t)v71;
                }
                while (&v71[4] != a2);
              }
            }
            else if (!v68)
            {
              unint64_t v124 = v9 + 40;
              do
              {
                unint64_t v125 = (unint64_t)v66;
                double v126 = *(double *)(a1 + 64);
                if (*(double *)a1 < v126)
                {
                  long long v159 = *(_OWORD *)(a1 + 72);
                  long long v167 = *(_OWORD *)(a1 + 88);
                  uint64_t v127 = *(void *)(a1 + 104);
                  *(void *)unsigned int v145 = *(void *)(a1 + 112);
                  *(void *)&v145[7] = *(void *)(a1 + 119);
                  char v128 = *(unsigned char *)(a1 + 127);
                  *(void *)(a1 + 112) = 0;
                  *(void *)(a1 + 120) = 0;
                  *(void *)(a1 + 104) = 0;
                  unint64_t v129 = v124;
                  unsigned __int8 v130 = v66[3].n128_u8[15];
                  do
                  {
                    *(_OWORD *)(v129 + 24) = *(_OWORD *)(v129 - 40);
                    *(_OWORD *)(v129 + 40) = *(_OWORD *)(v129 - 24);
                    *(void *)(v129 + 56) = *(void *)(v129 - 8);
                    int v131 = (void **)(v129 + 64);
                    if ((v130 & 0x80) != 0) {
                      operator delete(*v131);
                    }
                    unsigned __int8 v130 = 0;
                    *(_OWORD *)int v131 = *(_OWORD *)v129;
                    *(void *)(v129 + 80) = *(void *)(v129 + 16);
                    *(unsigned char *)(v129 + 23) = 0;
                    *(unsigned char *)unint64_t v129 = 0;
                    double v132 = *(double *)(v129 - 104);
                    v129 -= 64;
                  }
                  while (v132 < v126);
                  *(double *)(v129 + 24) = v126;
                  *(_OWORD *)(v129 + 32) = v159;
                  *(_OWORD *)(v129 + 48) = v167;
                  *(void *)(v129 + 64) = v127;
                  *(void *)(v129 + 79) = *(void *)&v145[7];
                  *(void *)(v129 + 72) = *(void *)v145;
                  *(unsigned char *)(v129 + 87) = v128;
                }
                uint64_t v66 = (__n128 *)(v125 + 64);
                v124 += 64;
                a1 = v125;
              }
              while ((__n128 *)(v125 + 64) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((__n128 *)v9 != a2)
            {
              int64_t v82 = (v11 - 2) >> 1;
              int64_t v83 = v82;
              do
              {
                int64_t v84 = v83;
                if (v82 >= v83)
                {
                  uint64_t v85 = (2 * v83) | 1;
                  unint64_t v86 = v9 + (v85 << 6);
                  if (2 * v84 + 2 < (uint64_t)v11 && *(double *)(v86 + 64) < *(double *)v86)
                  {
                    v86 += 64;
                    uint64_t v85 = 2 * v84 + 2;
                  }
                  unint64_t v87 = v9 + (v84 << 6);
                  double v88 = *(double *)v87;
                  if (*(double *)v87 >= *(double *)v86)
                  {
                    long long v157 = *(_OWORD *)(v87 + 8);
                    long long v165 = *(_OWORD *)(v87 + 24);
                    uint64_t v89 = (void *)(v9 + (v84 << 6));
                    uint64_t v90 = v89[5];
                    *(void *)&v143[7] = *(void *)((char *)v89 + 55);
                    *(void *)uint64_t v143 = v89[6];
                    char v91 = *(unsigned char *)(v87 + 63);
                    v89[5] = 0;
                    v89[6] = 0;
                    v89[7] = 0;
                    do
                    {
                      unint64_t v92 = v87;
                      unint64_t v87 = v86;
                      long long v93 = *(_OWORD *)v86;
                      long long v94 = *(_OWORD *)(v86 + 16);
                      *(void *)(v92 + 32) = *(void *)(v86 + 32);
                      *(_OWORD *)unint64_t v92 = v93;
                      *(_OWORD *)(v92 + 16) = v94;
                      long long v95 = *(_OWORD *)(v86 + 40);
                      *(void *)(v92 + 56) = *(void *)(v86 + 56);
                      *(_OWORD *)(v92 + 40) = v95;
                      *(unsigned char *)(v86 + 63) = 0;
                      *(unsigned char *)(v86 + 40) = 0;
                      if (v82 < v85) {
                        break;
                      }
                      uint64_t v96 = 2 * v85;
                      uint64_t v85 = (2 * v85) | 1;
                      unint64_t v86 = v9 + (v85 << 6);
                      uint64_t v97 = v96 + 2;
                      if (v97 < (uint64_t)v11 && *(double *)(v86 + 64) < *(double *)v86)
                      {
                        v86 += 64;
                        uint64_t v85 = v97;
                      }
                    }
                    while (v88 >= *(double *)v86);
                    *(double *)unint64_t v87 = v88;
                    *(_OWORD *)(v87 + 8) = v157;
                    *(_OWORD *)(v87 + 24) = v165;
                    *(void *)(v87 + 40) = v90;
                    *(void *)(v87 + 48) = *(void *)v143;
                    *(void *)(v87 + 55) = *(void *)&v143[7];
                    *(unsigned char *)(v87 + 63) = v91;
                  }
                }
                int64_t v83 = v84 - 1;
              }
              while (v84);
              uint64_t v98 = (unint64_t)v10 >> 6;
              do
              {
                uint64_t v99 = 0;
                uint64_t v100 = a2;
                unint64_t v101 = *(void *)(v9 + 40);
                unint64_t v172 = *(void *)(v9 + 32);
                __n128 v158 = *(__n128 *)v9;
                __n128 v166 = *(__n128 *)(v9 + 16);
                *(void *)char v137 = *(void *)(v9 + 48);
                *(void *)&v137[7] = *(void *)(v9 + 55);
                unsigned __int8 v102 = *(unsigned char *)(v9 + 63);
                *(void *)(v9 + 48) = 0;
                *(void *)(v9 + 56) = 0;
                unint64_t v103 = v9;
                *(void *)(v9 + 40) = 0;
                do
                {
                  unint64_t v104 = v103;
                  v103 += (v99 << 6) + 64;
                  uint64_t v105 = 2 * v99;
                  uint64_t v99 = (2 * v99) | 1;
                  uint64_t v106 = v105 + 2;
                  if (v106 < v98 && *(double *)(v103 + 64) < *(double *)v103)
                  {
                    v103 += 64;
                    uint64_t v99 = v106;
                  }
                  long long v107 = *(_OWORD *)v103;
                  long long v108 = *(_OWORD *)(v103 + 16);
                  *(void *)(v104 + 32) = *(void *)(v103 + 32);
                  *(_OWORD *)unint64_t v104 = v107;
                  *(_OWORD *)(v104 + 16) = v108;
                  long long v109 = *(_OWORD *)(v103 + 40);
                  *(void *)(v104 + 56) = *(void *)(v103 + 56);
                  *(_OWORD *)(v104 + 40) = v109;
                  *(unsigned char *)(v103 + 63) = 0;
                  *(unsigned char *)(v103 + 40) = 0;
                }
                while (v99 <= (uint64_t)((unint64_t)(v98 - 2) >> 1));
                a2 -= 4;
                if ((__n128 *)v103 == &v100[-4])
                {
                  *(__n128 *)unint64_t v103 = v158;
                  *(__n128 *)(v103 + 16) = v166;
                  *(void *)(v103 + 32) = v172;
                  *(void *)(v103 + 40) = v101;
                  *(void *)(v103 + 48) = *(void *)v137;
                  *(void *)(v103 + 55) = *(void *)&v137[7];
                  *(unsigned char *)(v103 + 63) = v102;
                }
                else
                {
                  __n128 v110 = *a2;
                  __n128 v111 = v100[-3];
                  *(void *)(v103 + 32) = v100[-2].n128_u64[0];
                  *(__n128 *)unint64_t v103 = v110;
                  *(__n128 *)(v103 + 16) = v111;
                  long long v112 = *(long long *)((char *)&v100[-2] + 8);
                  *(void *)(v103 + 56) = v100[-1].n128_u64[1];
                  *(_OWORD *)(v103 + 40) = v112;
                  v100[-2].n128_u64[0] = v172;
                  *a2 = v158;
                  v100[-3] = v166;
                  v100[-2].n128_u64[1] = v101;
                  *(unint64_t *)((char *)v100[-1].n128_u64 + 7) = *(void *)&v137[7];
                  v100[-1].n128_u64[0] = *(void *)v137;
                  v100[-1].n128_u8[15] = v102;
                  uint64_t v113 = v103 - v9 + 64;
                  if (v113 >= 65)
                  {
                    unint64_t v114 = (((unint64_t)v113 >> 6) - 2) >> 1;
                    unint64_t v115 = v9 + (v114 << 6);
                    double v116 = *(double *)v103;
                    if (*(double *)v103 < *(double *)v115)
                    {
                      long long v144 = *(_OWORD *)(v103 + 8);
                      long long v148 = *(_OWORD *)(v103 + 24);
                      uint64_t v117 = *(void *)(v103 + 40);
                      *(void *)&v151[7] = *(void *)(v103 + 55);
                      *(void *)int v151 = *(void *)(v103 + 48);
                      char v118 = *(unsigned char *)(v103 + 63);
                      *(void *)(v103 + 40) = 0;
                      *(void *)(v103 + 48) = 0;
                      *(void *)(v103 + 56) = 0;
                      do
                      {
                        unint64_t v119 = v103;
                        unint64_t v103 = v115;
                        long long v120 = *(_OWORD *)v115;
                        long long v121 = *(_OWORD *)(v115 + 16);
                        *(void *)(v119 + 32) = *(void *)(v115 + 32);
                        *(_OWORD *)unint64_t v119 = v120;
                        *(_OWORD *)(v119 + 16) = v121;
                        long long v122 = *(_OWORD *)(v115 + 40);
                        *(void *)(v119 + 56) = *(void *)(v115 + 56);
                        *(_OWORD *)(v119 + 40) = v122;
                        *(unsigned char *)(v115 + 63) = 0;
                        *(unsigned char *)(v115 + 40) = 0;
                        if (!v114) {
                          break;
                        }
                        unint64_t v114 = (v114 - 1) >> 1;
                        unint64_t v115 = v9 + (v114 << 6);
                      }
                      while (v116 < *(double *)v115);
                      *(double *)unint64_t v103 = v116;
                      *(_OWORD *)(v103 + 8) = v144;
                      *(_OWORD *)(v103 + 24) = v148;
                      *(void *)(v103 + 40) = v117;
                      *(void *)(v103 + 48) = *(void *)v151;
                      *(void *)(v103 + 55) = *(void *)&v151[7];
                      *(unsigned char *)(v103 + 63) = v118;
                    }
                  }
                }
              }
              while (v98-- > 2);
            }
            return;
          }
          unint64_t v12 = v11 >> 1;
          unint64_t v13 = v9 + (v11 >> 1 << 6);
          if ((unint64_t)v10 > 0x2000)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, (__n128 *)(a1 + (v11 >> 1 << 6)), v133);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1 + 64, (__n128 *)(v13 - 64), a2 - 8);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1 + 128, (__n128 *)(a1 + 64 + (v12 << 6)), a2 - 12);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(v13 - 64, (__n128 *)v13, (__n128 *)(a1 + 64 + (v12 << 6)));
            uint64_t v14 = *(void *)(a1 + 40);
            uint64_t v168 = *(void *)(a1 + 32);
            long long v152 = *(_OWORD *)a1;
            long long v160 = *(_OWORD *)(a1 + 16);
            *(void *)((char *)&v138 + 7) = *(void *)(a1 + 55);
            *(void *)&long long v138 = *(void *)(a1 + 48);
            char v15 = *(unsigned char *)(a1 + 63);
            *(void *)(a1 + 48) = 0;
            *(void *)(a1 + 56) = 0;
            __n128 v17 = *(__n128 *)v13;
            long long v16 = *(_OWORD *)(v13 + 16);
            *(void *)(a1 + 32) = *(void *)(v13 + 32);
            *(void *)(a1 + 40) = 0;
            *(__n128 *)a1 = v17;
            *(_OWORD *)(a1 + 16) = v16;
            uint64_t v18 = *(void *)(v13 + 56);
            *(_OWORD *)(a1 + 40) = *(_OWORD *)(v13 + 40);
            *(void *)(a1 + 56) = v18;
            *(_OWORD *)unint64_t v13 = v152;
            *(_OWORD *)(v13 + 16) = v160;
            *(void *)(v13 + 32) = v168;
            *(void *)(v13 + 40) = v14;
            *(void *)(v13 + 55) = *(void *)((char *)&v138 + 7);
            *(void *)(v13 + 48) = v138;
            *(unsigned char *)(v13 + 63) = v15;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1 + (v11 >> 1 << 6), (__n128 *)a1, v133);
          }
          --a3;
          double v19 = *(double *)a1;
          if ((a4 & 1) != 0 || v19 < *(double *)(a1 - 64)) {
            break;
          }
          uint64_t v42 = (void **)(a1 + 40);
          uint64_t v43 = *(void *)(a1 + 40);
          long long v140 = *(_OWORD *)(a1 + 8);
          long long v147 = *(_OWORD *)(a1 + 24);
          *(void *)unsigned __int8 v136 = *(void *)(a1 + 48);
          *(void *)&v136[7] = *(void *)(a1 + 55);
          char v44 = *(unsigned char *)(a1 + 63);
          *(void *)(a1 + 48) = 0;
          *(void *)(a1 + 56) = 0;
          *(void *)(a1 + 40) = 0;
          if (v133->n128_f64[0] >= v19)
          {
            unint64_t v46 = a1 + 64;
            do
            {
              unint64_t v9 = v46;
              if (v46 >= (unint64_t)a2) {
                break;
              }
              v46 += 64;
            }
            while (*(double *)v9 >= v19);
          }
          else
          {
            unint64_t v9 = a1;
            do
            {
              double v45 = *(double *)(v9 + 64);
              v9 += 64;
            }
            while (v45 >= v19);
          }
          long long v47 = a2;
          if (v9 < (unint64_t)a2)
          {
            long long v47 = a2;
            do
            {
              double v48 = v47[-4].n128_f64[0];
              v47 -= 4;
            }
            while (v48 < v19);
          }
          while (v9 < (unint64_t)v47)
          {
            unint64_t v49 = *(void *)(v9 + 40);
            unint64_t v170 = *(void *)(v9 + 32);
            __n128 v154 = *(__n128 *)v9;
            __n128 v162 = *(__n128 *)(v9 + 16);
            *(void *)&long long v150 = *(void *)(v9 + 48);
            *(void *)((char *)&v150 + 7) = *(void *)(v9 + 55);
            unsigned __int8 v50 = *(unsigned char *)(v9 + 63);
            *(void *)(v9 + 40) = 0;
            *(void *)(v9 + 48) = 0;
            *(void *)(v9 + 56) = 0;
            __n128 v51 = *v47;
            __n128 v52 = v47[1];
            *(void *)(v9 + 32) = v47[2].n128_u64[0];
            *(__n128 *)unint64_t v9 = v51;
            *(__n128 *)(v9 + 16) = v52;
            long long v53 = *(long long *)((char *)&v47[2] + 8);
            *(void *)(v9 + 56) = v47[3].n128_u64[1];
            *(_OWORD *)(v9 + 40) = v53;
            __n128 *v47 = v154;
            v47[1] = v162;
            v47[2].n128_u64[0] = v170;
            v47[2].n128_u64[1] = v49;
            v47[3].n128_u64[0] = v150;
            *(unint64_t *)((char *)v47[3].n128_u64 + 7) = *(void *)((char *)&v150 + 7);
            v47[3].n128_u8[15] = v50;
            do
            {
              double v54 = *(double *)(v9 + 64);
              v9 += 64;
            }
            while (v54 >= v19);
            do
            {
              double v55 = v47[-4].n128_f64[0];
              v47 -= 4;
            }
            while (v55 < v19);
          }
          BOOL v4 = v9 - 64 >= a1;
          BOOL v5 = v9 - 64 == a1;
          if (v9 - 64 == a1)
          {
            int v59 = *(char *)(v9 - 1);
            *(double *)a1 = v19;
            *(_OWORD *)(v9 - 40) = v147;
            *(_OWORD *)(v9 - 56) = v140;
            if (v59 < 0) {
              operator delete(*(void **)(v9 - 24));
            }
          }
          else
          {
            long long v56 = *(_OWORD *)(v9 - 64);
            long long v57 = *(_OWORD *)(v9 - 48);
            *(void *)(a1 + 32) = *(void *)(v9 - 32);
            *(_OWORD *)a1 = v56;
            *(_OWORD *)(a1 + 16) = v57;
            if (*(char *)(a1 + 63) < 0) {
              operator delete(*v42);
            }
            long long v58 = *(_OWORD *)(v9 - 24);
            *(void *)(a1 + 56) = *(void *)(v9 - 8);
            *(_OWORD *)uint64_t v42 = v58;
            *(unsigned char *)(v9 - 1) = 0;
            *(unsigned char *)(v9 - 24) = 0;
            *(double *)(v9 - 64) = v19;
            *(_OWORD *)(v9 - 40) = v147;
            *(_OWORD *)(v9 - 56) = v140;
          }
          a4 = 0;
          *(void *)(v9 - 24) = v43;
          *(void *)(v9 - 9) = *(void *)&v136[7];
          *(void *)(v9 - 16) = *(void *)v136;
          *(unsigned char *)(v9 - 1) = v44;
        }
        uint64_t v20 = 0;
        int v21 = (void **)(a1 + 40);
        uint64_t v22 = *(void *)(a1 + 40);
        long long v139 = *(_OWORD *)(a1 + 8);
        long long v146 = *(_OWORD *)(a1 + 24);
        *(void *)v135 = *(void *)(a1 + 48);
        *(void *)&v135[7] = *(void *)(a1 + 55);
        char v23 = *(unsigned char *)(a1 + 63);
        *(void *)(a1 + 48) = 0;
        *(void *)(a1 + 56) = 0;
        *(void *)(a1 + 40) = 0;
        do
        {
          double v24 = *(double *)(a1 + v20 + 64);
          v20 += 64;
        }
        while (v19 < v24);
        unint64_t v25 = a1 + v20;
        char v26 = a2;
        if (v20 == 64)
        {
          char v26 = a2;
          do
          {
            if (v25 >= (unint64_t)v26) {
              break;
            }
            double v28 = v26[-4].n128_f64[0];
            v26 -= 4;
          }
          while (v19 >= v28);
        }
        else
        {
          do
          {
            double v27 = v26[-4].n128_f64[0];
            v26 -= 4;
          }
          while (v19 >= v27);
        }
        unint64_t v9 = a1 + v20;
        if (v25 < (unint64_t)v26)
        {
          unint64_t v29 = (unint64_t)v26;
          do
          {
            uint64_t v30 = *(void *)(v9 + 40);
            uint64_t v169 = *(void *)(v9 + 32);
            __n128 v153 = *(__n128 *)v9;
            long long v161 = *(_OWORD *)(v9 + 16);
            *(void *)&long long v149 = *(void *)(v9 + 48);
            *(void *)((char *)&v149 + 7) = *(void *)(v9 + 55);
            char v31 = *(unsigned char *)(v9 + 63);
            *(void *)(v9 + 40) = 0;
            *(void *)(v9 + 48) = 0;
            *(void *)(v9 + 56) = 0;
            long long v32 = *(_OWORD *)v29;
            long long v33 = *(_OWORD *)(v29 + 16);
            *(void *)(v9 + 32) = *(void *)(v29 + 32);
            *(_OWORD *)unint64_t v9 = v32;
            *(_OWORD *)(v9 + 16) = v33;
            long long v34 = *(_OWORD *)(v29 + 40);
            *(void *)(v9 + 56) = *(void *)(v29 + 56);
            *(_OWORD *)(v9 + 40) = v34;
            *(__n128 *)unint64_t v29 = v153;
            *(_OWORD *)(v29 + 16) = v161;
            *(void *)(v29 + 32) = v169;
            *(void *)(v29 + 40) = v30;
            *(void *)(v29 + 48) = v149;
            *(void *)(v29 + 55) = *(void *)((char *)&v149 + 7);
            *(unsigned char *)(v29 + 63) = v31;
            do
            {
              double v35 = *(double *)(v9 + 64);
              v9 += 64;
            }
            while (v19 < v35);
            do
            {
              double v36 = *(double *)(v29 - 64);
              v29 -= 64;
            }
            while (v19 >= v36);
          }
          while (v9 < v29);
        }
        if (v9 - 64 == a1)
        {
          int v40 = *(char *)(v9 - 1);
          *(double *)a1 = v19;
          *(_OWORD *)(v9 - 40) = v146;
          *(_OWORD *)(v9 - 56) = v139;
          if (v40 < 0) {
            operator delete(*(void **)(v9 - 24));
          }
        }
        else
        {
          long long v37 = *(_OWORD *)(v9 - 64);
          long long v38 = *(_OWORD *)(v9 - 48);
          *(void *)(a1 + 32) = *(void *)(v9 - 32);
          *(_OWORD *)a1 = v37;
          *(_OWORD *)(a1 + 16) = v38;
          if (*(char *)(a1 + 63) < 0) {
            operator delete(*v21);
          }
          long long v39 = *(_OWORD *)(v9 - 24);
          *(void *)(a1 + 56) = *(void *)(v9 - 8);
          *(_OWORD *)int v21 = v39;
          *(unsigned char *)(v9 - 1) = 0;
          *(unsigned char *)(v9 - 24) = 0;
          *(double *)(v9 - 64) = v19;
          *(_OWORD *)(v9 - 40) = v146;
          *(_OWORD *)(v9 - 56) = v139;
        }
        *(void *)(v9 - 24) = v22;
        *(void *)(v9 - 9) = *(void *)&v135[7];
        *(void *)(v9 - 16) = *(void *)v135;
        *(unsigned char *)(v9 - 1) = v23;
        if (v25 >= (unint64_t)v26) {
          break;
        }
LABEL_34:
        std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *,false>(a1, v9 - 64, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v41 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, v9 - 64);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(v9, (uint64_t)a2))
      {
        break;
      }
      if (!v41) {
        goto LABEL_34;
      }
    }
    a2 = (__n128 *)(v9 - 64);
    if (!v41) {
      continue;
    }
    break;
  }
}

void std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5)
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, a2, a3, a4);
  if (*(double *)a4 < *(double *)a5)
  {
    long long v34 = *(_OWORD *)a4;
    long long v38 = *(_OWORD *)(a4 + 16);
    uint64_t v10 = *(void *)(a4 + 40);
    uint64_t v42 = *(void *)(a4 + 32);
    *(void *)&long long v30 = *(void *)(a4 + 48);
    *(void *)((char *)&v30 + 7) = *(void *)(a4 + 55);
    char v11 = *(unsigned char *)(a4 + 63);
    *(void *)(a4 + 40) = 0;
    *(void *)(a4 + 56) = 0;
    *(void *)(a4 + 48) = 0;
    long long v12 = *a5;
    long long v13 = a5[1];
    *(void *)(a4 + 32) = *((void *)a5 + 4);
    *(_OWORD *)a4 = v12;
    *(_OWORD *)(a4 + 16) = v13;
    long long v14 = *(long long *)((char *)a5 + 40);
    *(void *)(a4 + 56) = *((void *)a5 + 7);
    *(_OWORD *)(a4 + 40) = v14;
    *a5 = v34;
    a5[1] = v38;
    *((void *)a5 + 4) = v42;
    *((void *)a5 + 5) = v10;
    *((void *)a5 + 6) = v30;
    *(void *)((char *)a5 + 55) = *(void *)((char *)&v30 + 7);
    *((unsigned char *)a5 + 63) = v11;
    if (*(double *)a3 < *(double *)a4)
    {
      long long v35 = *(_OWORD *)a3;
      long long v39 = *(_OWORD *)(a3 + 16);
      uint64_t v15 = *(void *)(a3 + 40);
      uint64_t v43 = *(void *)(a3 + 32);
      *(void *)&long long v31 = *(void *)(a3 + 48);
      *(void *)((char *)&v31 + 7) = *(void *)(a3 + 55);
      char v16 = *(unsigned char *)(a3 + 63);
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 56) = 0;
      *(void *)(a3 + 48) = 0;
      long long v17 = *(_OWORD *)a4;
      long long v18 = *(_OWORD *)(a4 + 16);
      *(void *)(a3 + 32) = *(void *)(a4 + 32);
      *(_OWORD *)a3 = v17;
      *(_OWORD *)(a3 + 16) = v18;
      long long v19 = *(_OWORD *)(a4 + 40);
      *(void *)(a3 + 56) = *(void *)(a4 + 56);
      *(_OWORD *)(a3 + 40) = v19;
      *(_OWORD *)a4 = v35;
      *(_OWORD *)(a4 + 16) = v39;
      *(void *)(a4 + 32) = v43;
      *(void *)(a4 + 40) = v15;
      *(void *)(a4 + 48) = v31;
      *(void *)(a4 + 55) = *(void *)((char *)&v31 + 7);
      *(unsigned char *)(a4 + 63) = v16;
      if (*(double *)a2 < *(double *)a3)
      {
        long long v36 = *(_OWORD *)a2;
        long long v40 = *(_OWORD *)(a2 + 16);
        uint64_t v20 = *(void *)(a2 + 40);
        uint64_t v44 = *(void *)(a2 + 32);
        *(void *)&long long v32 = *(void *)(a2 + 48);
        *(void *)((char *)&v32 + 7) = *(void *)(a2 + 55);
        char v21 = *(unsigned char *)(a2 + 63);
        *(void *)(a2 + 40) = 0;
        *(void *)(a2 + 56) = 0;
        *(void *)(a2 + 48) = 0;
        long long v22 = *(_OWORD *)a3;
        long long v23 = *(_OWORD *)(a3 + 16);
        *(void *)(a2 + 32) = *(void *)(a3 + 32);
        *(_OWORD *)a2 = v22;
        *(_OWORD *)(a2 + 16) = v23;
        long long v24 = *(_OWORD *)(a3 + 40);
        *(void *)(a2 + 56) = *(void *)(a3 + 56);
        *(_OWORD *)(a2 + 40) = v24;
        *(_OWORD *)a3 = v36;
        *(_OWORD *)(a3 + 16) = v40;
        *(void *)(a3 + 32) = v44;
        *(void *)(a3 + 40) = v20;
        *(void *)(a3 + 48) = v32;
        *(void *)(a3 + 55) = *(void *)((char *)&v32 + 7);
        *(unsigned char *)(a3 + 63) = v21;
        if (*(double *)a1 < *(double *)a2)
        {
          long long v37 = *(_OWORD *)a1;
          long long v41 = *(_OWORD *)(a1 + 16);
          uint64_t v25 = *(void *)(a1 + 40);
          uint64_t v45 = *(void *)(a1 + 32);
          *(void *)&long long v33 = *(void *)(a1 + 48);
          *(void *)((char *)&v33 + 7) = *(void *)(a1 + 55);
          char v26 = *(unsigned char *)(a1 + 63);
          *(void *)(a1 + 48) = 0;
          *(void *)(a1 + 56) = 0;
          *(void *)(a1 + 40) = 0;
          long long v27 = *(_OWORD *)a2;
          long long v28 = *(_OWORD *)(a2 + 16);
          *(void *)(a1 + 32) = *(void *)(a2 + 32);
          *(_OWORD *)a1 = v27;
          *(_OWORD *)(a1 + 16) = v28;
          long long v29 = *(_OWORD *)(a2 + 40);
          *(void *)(a1 + 56) = *(void *)(a2 + 56);
          *(_OWORD *)(a1 + 40) = v29;
          *(_OWORD *)a2 = v37;
          *(_OWORD *)(a2 + 16) = v41;
          *(void *)(a2 + 32) = v45;
          *(void *)(a2 + 40) = v25;
          *(void *)(a2 + 48) = v33;
          *(void *)(a2 + 55) = *(void *)((char *)&v33 + 7);
          *(unsigned char *)(a2 + 63) = v26;
        }
      }
    }
  }
}

__n128 std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  result.n128_u64[0] = a2->n128_u64[0];
  double v4 = a3->n128_f64[0];
  if (*(double *)a1 >= a2->n128_f64[0])
  {
    if (result.n128_f64[0] < v4)
    {
      __n128 v36 = *a2;
      __n128 v41 = a2[1];
      uint64_t v12 = a2[2].n128_i64[1];
      uint64_t v46 = a2[2].n128_i64[0];
      *(void *)&long long v31 = a2[3].n128_u64[0];
      *(void *)((char *)&v31 + 7) = *(unint64_t *)((char *)a2[3].n128_u64 + 7);
      char v13 = a2[3].n128_i8[15];
      a2[2].n128_u64[1] = 0;
      a2[3].n128_u64[1] = 0;
      a2[3].n128_u64[0] = 0;
      __n128 v14 = *a3;
      __n128 v15 = a3[1];
      a2[2].n128_u64[0] = a3[2].n128_u64[0];
      *a2 = v14;
      a2[1] = v15;
      __n128 v16 = *(__n128 *)((char *)a3 + 40);
      a2[3].n128_u64[1] = a3[3].n128_u64[1];
      *(__n128 *)((char *)a2 + 40) = v16;
      result.n128_u64[1] = v36.n128_u64[1];
      *a3 = v36;
      a3[1] = v41;
      a3[2].n128_u64[0] = v46;
      a3[2].n128_u64[1] = v12;
      a3[3].n128_u64[0] = v31;
      *(unint64_t *)((char *)a3[3].n128_u64 + 7) = *(void *)((char *)&v31 + 7);
      a3[3].n128_u8[15] = v13;
      result.n128_u64[0] = *(void *)a1;
      if (*(double *)a1 < a2->n128_f64[0])
      {
        __n128 v37 = *(__n128 *)a1;
        __n128 v42 = *(__n128 *)(a1 + 16);
        unint64_t v17 = *(void *)(a1 + 40);
        unint64_t v47 = *(void *)(a1 + 32);
        *(void *)&long long v32 = *(void *)(a1 + 48);
        *(void *)((char *)&v32 + 7) = *(void *)(a1 + 55);
        unsigned __int8 v18 = *(unsigned char *)(a1 + 63);
        *(void *)(a1 + 48) = 0;
        *(void *)(a1 + 56) = 0;
        *(void *)(a1 + 40) = 0;
        __n128 v19 = *a2;
        __n128 v20 = a2[1];
        *(void *)(a1 + 32) = a2[2].n128_u64[0];
        *(__n128 *)a1 = v19;
        *(__n128 *)(a1 + 16) = v20;
        long long v21 = *(long long *)((char *)&a2[2] + 8);
        *(void *)(a1 + 56) = a2[3].n128_u64[1];
        *(_OWORD *)(a1 + 40) = v21;
        __n128 result = v37;
        *a2 = v37;
        a2[1] = v42;
        a2[2].n128_u64[0] = v47;
        a2[2].n128_u64[1] = v17;
        a2[3].n128_u64[0] = v32;
        *(unint64_t *)((char *)a2[3].n128_u64 + 7) = *(void *)((char *)&v32 + 7);
        a2[3].n128_u8[15] = v18;
      }
    }
  }
  else
  {
    BOOL v5 = (void *)(a1 + 40);
    uint64_t v6 = (void *)(a1 + 48);
    if (result.n128_f64[0] >= v4)
    {
      __n128 v38 = *(__n128 *)a1;
      __n128 v43 = *(__n128 *)(a1 + 16);
      unint64_t v22 = *(void *)(a1 + 40);
      unint64_t v48 = *(void *)(a1 + 32);
      *(void *)&long long v33 = *v6;
      *(void *)((char *)&v33 + 7) = *(void *)(a1 + 55);
      unsigned __int8 v23 = *(unsigned char *)(a1 + 63);
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = 0;
      void *v5 = 0;
      __n128 v24 = *a2;
      __n128 v25 = a2[1];
      *(void *)(a1 + 32) = a2[2].n128_u64[0];
      *(__n128 *)a1 = v24;
      *(__n128 *)(a1 + 16) = v25;
      long long v26 = *(long long *)((char *)&a2[2] + 8);
      *(void *)(a1 + 56) = a2[3].n128_u64[1];
      *(_OWORD *)BOOL v5 = v26;
      result.n128_u64[1] = v38.n128_u64[1];
      *a2 = v38;
      a2[1] = v43;
      a2[2].n128_u64[0] = v48;
      a2[2].n128_u64[1] = v22;
      a2[3].n128_u64[0] = v33;
      *(unint64_t *)((char *)a2[3].n128_u64 + 7) = *(void *)((char *)&v33 + 7);
      a2[3].n128_u8[15] = v23;
      result.n128_u64[0] = a2->n128_u64[0];
      if (a2->n128_f64[0] < a3->n128_f64[0])
      {
        __n128 v39 = *a2;
        __n128 v44 = a2[1];
        uint64_t v49 = a2[2].n128_i64[0];
        *(void *)&long long v34 = a2[3].n128_u64[0];
        *(void *)((char *)&v34 + 7) = *(unint64_t *)((char *)a2[3].n128_u64 + 7);
        a2[3].n128_u64[0] = 0;
        a2[3].n128_u64[1] = 0;
        a2[2].n128_u64[1] = 0;
        __n128 v28 = *a3;
        __n128 v27 = a3[1];
        a2[2].n128_u64[0] = a3[2].n128_u64[0];
        *a2 = v28;
        a2[1] = v27;
        __n128 v29 = *(__n128 *)((char *)a3 + 40);
        a2[3].n128_u64[1] = a3[3].n128_u64[1];
        *(__n128 *)((char *)a2 + 40) = v29;
        __n128 result = v39;
        *a3 = v39;
        a3[1] = v44;
        a3[2].n128_u64[0] = v49;
        a3[2].n128_u64[1] = v22;
        a3[3].n128_u64[0] = v34;
        *(unint64_t *)((char *)a3[3].n128_u64 + 7) = *(void *)((char *)&v34 + 7);
        a3[3].n128_u8[15] = v23;
      }
    }
    else
    {
      __n128 v35 = *(__n128 *)a1;
      __n128 v40 = *(__n128 *)(a1 + 16);
      unint64_t v7 = *(void *)(a1 + 40);
      unint64_t v45 = *(void *)(a1 + 32);
      *(void *)&long long v30 = *v6;
      *(void *)((char *)&v30 + 7) = *(void *)(a1 + 55);
      unsigned __int8 v8 = *(unsigned char *)(a1 + 63);
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = 0;
      void *v5 = 0;
      __n128 v9 = *a3;
      __n128 v10 = a3[1];
      *(void *)(a1 + 32) = a3[2].n128_u64[0];
      *(__n128 *)a1 = v9;
      *(__n128 *)(a1 + 16) = v10;
      long long v11 = *(long long *)((char *)&a3[2] + 8);
      *(void *)(a1 + 56) = a3[3].n128_u64[1];
      *(_OWORD *)BOOL v5 = v11;
      __n128 result = v35;
      *a3 = v35;
      a3[1] = v40;
      a3[2].n128_u64[0] = v45;
      a3[2].n128_u64[1] = v7;
      a3[3].n128_u64[0] = v30;
      *(unint64_t *)((char *)a3[3].n128_u64 + 7) = *(void *)((char *)&v30 + 7);
      a3[3].n128_u8[15] = v8;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 6;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = (long long *)(a2 - 64);
      if (*(double *)a1 < *(double *)(a2 - 64))
      {
        long long v25 = *(_OWORD *)a1;
        long long v27 = *(_OWORD *)(a1 + 16);
        uint64_t v7 = *(void *)(a1 + 40);
        uint64_t v29 = *(void *)(a1 + 32);
        *(void *)&long long v23 = *(void *)(a1 + 48);
        *(void *)((char *)&v23 + 7) = *(void *)(a1 + 55);
        char v8 = *(unsigned char *)(a1 + 63);
        *(void *)(a1 + 48) = 0;
        *(void *)(a1 + 56) = 0;
        *(void *)(a1 + 40) = 0;
        long long v9 = *v6;
        long long v10 = *(_OWORD *)(a2 - 48);
        *(void *)(a1 + 32) = *(void *)(a2 - 32);
        *(_OWORD *)a1 = v9;
        *(_OWORD *)(a1 + 16) = v10;
        long long v11 = *(_OWORD *)(a2 - 24);
        *(void *)(a1 + 56) = *(void *)(a2 - 8);
        *(_OWORD *)(a1 + 40) = v11;
        long long *v6 = v25;
        *(_OWORD *)(a2 - 48) = v27;
        *(void *)(a2 - 32) = v29;
        *(void *)(a2 - 24) = v7;
        *(void *)(a2 - 16) = v23;
        *(void *)(a2 - 9) = *(void *)((char *)&v23 + 7);
        *(unsigned char *)(a2 - 1) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, (__n128 *)(a1 + 64), (__n128 *)(a2 - 64));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, a1 + 64, a1 + 128, a2 - 64);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *,0>(a1, a1 + 64, a1 + 128, a1 + 192, (long long *)(a2 - 64));
      return 1;
    default:
      uint64_t v12 = (double *)(a1 + 128);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, (__n128 *)(a1 + 64), (__n128 *)(a1 + 128));
      uint64_t v13 = a1 + 192;
      if (a1 + 192 == a2) {
        return 1;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      break;
  }
  while (1)
  {
    double v16 = *(double *)v13;
    if (*v12 < *(double *)v13)
    {
      long long v26 = *(_OWORD *)(v13 + 8);
      long long v28 = *(_OWORD *)(v13 + 24);
      uint64_t v17 = *(void *)(v13 + 40);
      *(void *)__n128 v24 = *(void *)(v13 + 48);
      *(void *)&v24[7] = *(void *)(v13 + 55);
      char v18 = *(unsigned char *)(v13 + 63);
      *(void *)(v13 + 48) = 0;
      *(void *)(v13 + 56) = 0;
      uint64_t v19 = v14;
      *(void *)(v13 + 40) = 0;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        long long v21 = *(_OWORD *)(a1 + v19 + 144);
        *(_OWORD *)(v20 + 192) = *(_OWORD *)(a1 + v19 + 128);
        *(_OWORD *)(v20 + 208) = v21;
        *(void *)(v20 + 224) = *(void *)(a1 + v19 + 160);
        *(_OWORD *)(v20 + 232) = *(_OWORD *)(a1 + v19 + 168);
        *(void *)(v20 + 248) = *(void *)(a1 + v19 + 184);
        *(unsigned char *)(v20 + 191) = 0;
        *(unsigned char *)(v20 + 168) = 0;
        if (v19 == -128) {
          break;
        }
        v19 -= 64;
        if (*(double *)(v20 + 64) >= v16)
        {
          uint64_t v22 = a1 + v19 + 192;
          goto LABEL_12;
        }
      }
      uint64_t v22 = a1;
LABEL_12:
      *(double *)uint64_t v22 = v16;
      *(_OWORD *)(v22 + 8) = v26;
      *(_OWORD *)(v22 + 24) = v28;
      *(void *)(v20 + 168) = v17;
      *(void *)(v22 + 55) = *(void *)&v24[7];
      *(void *)(v22 + 48) = *(void *)v24;
      ++v15;
      *(unsigned char *)(v22 + 63) = v18;
      if (v15 == 8) {
        return v13 + 64 == a2;
      }
    }
    uint64_t v12 = (double *)v13;
    v14 += 64;
    v13 += 64;
    if (v13 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, (__n128 *)a2, (__n128 *)a3);
  result.n128_u64[0] = *(void *)a3;
  if (*(double *)a3 < *(double *)a4)
  {
    __n128 v27 = *(__n128 *)a3;
    long long v30 = *(_OWORD *)(a3 + 16);
    uint64_t v9 = *(void *)(a3 + 40);
    uint64_t v33 = *(void *)(a3 + 32);
    *(void *)&long long v24 = *(void *)(a3 + 48);
    *(void *)((char *)&v24 + 7) = *(void *)(a3 + 55);
    char v10 = *(unsigned char *)(a3 + 63);
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 56) = 0;
    *(void *)(a3 + 48) = 0;
    __n128 v11 = *(__n128 *)a4;
    long long v12 = *(_OWORD *)(a4 + 16);
    *(void *)(a3 + 32) = *(void *)(a4 + 32);
    *(__n128 *)a3 = v11;
    *(_OWORD *)(a3 + 16) = v12;
    long long v13 = *(_OWORD *)(a4 + 40);
    *(void *)(a3 + 56) = *(void *)(a4 + 56);
    *(_OWORD *)(a3 + 40) = v13;
    result.n128_u64[1] = v27.n128_u64[1];
    *(__n128 *)a4 = v27;
    *(_OWORD *)(a4 + 16) = v30;
    *(void *)(a4 + 32) = v33;
    *(void *)(a4 + 40) = v9;
    *(void *)(a4 + 48) = v24;
    *(void *)(a4 + 55) = *(void *)((char *)&v24 + 7);
    *(unsigned char *)(a4 + 63) = v10;
    result.n128_u64[0] = *(void *)a2;
    if (*(double *)a2 < *(double *)a3)
    {
      __n128 v28 = *(__n128 *)a2;
      long long v31 = *(_OWORD *)(a2 + 16);
      uint64_t v14 = *(void *)(a2 + 40);
      uint64_t v34 = *(void *)(a2 + 32);
      *(void *)&long long v25 = *(void *)(a2 + 48);
      *(void *)((char *)&v25 + 7) = *(void *)(a2 + 55);
      char v15 = *(unsigned char *)(a2 + 63);
      *(void *)(a2 + 40) = 0;
      *(void *)(a2 + 56) = 0;
      *(void *)(a2 + 48) = 0;
      __n128 v16 = *(__n128 *)a3;
      long long v17 = *(_OWORD *)(a3 + 16);
      *(void *)(a2 + 32) = *(void *)(a3 + 32);
      *(__n128 *)a2 = v16;
      *(_OWORD *)(a2 + 16) = v17;
      long long v18 = *(_OWORD *)(a3 + 40);
      *(void *)(a2 + 56) = *(void *)(a3 + 56);
      *(_OWORD *)(a2 + 40) = v18;
      result.n128_u64[1] = v28.n128_u64[1];
      *(__n128 *)a3 = v28;
      *(_OWORD *)(a3 + 16) = v31;
      *(void *)(a3 + 32) = v34;
      *(void *)(a3 + 40) = v14;
      *(void *)(a3 + 48) = v25;
      *(void *)(a3 + 55) = *(void *)((char *)&v25 + 7);
      *(unsigned char *)(a3 + 63) = v15;
      result.n128_u64[0] = *(void *)a1;
      if (*(double *)a1 < *(double *)a2)
      {
        __n128 v29 = *(__n128 *)a1;
        long long v32 = *(_OWORD *)(a1 + 16);
        uint64_t v19 = *(void *)(a1 + 40);
        uint64_t v35 = *(void *)(a1 + 32);
        *(void *)&long long v26 = *(void *)(a1 + 48);
        *(void *)((char *)&v26 + 7) = *(void *)(a1 + 55);
        char v20 = *(unsigned char *)(a1 + 63);
        *(void *)(a1 + 48) = 0;
        *(void *)(a1 + 56) = 0;
        *(void *)(a1 + 40) = 0;
        __n128 v21 = *(__n128 *)a2;
        long long v22 = *(_OWORD *)(a2 + 16);
        *(void *)(a1 + 32) = *(void *)(a2 + 32);
        *(__n128 *)a1 = v21;
        *(_OWORD *)(a1 + 16) = v22;
        long long v23 = *(_OWORD *)(a2 + 40);
        *(void *)(a1 + 56) = *(void *)(a2 + 56);
        *(_OWORD *)(a1 + 40) = v23;
        __n128 result = v29;
        *(__n128 *)a2 = v29;
        *(_OWORD *)(a2 + 16) = v32;
        *(void *)(a2 + 32) = v35;
        *(void *)(a2 + 40) = v19;
        *(void *)(a2 + 48) = v26;
        *(void *)(a2 + 55) = *(void *)((char *)&v26 + 7);
        *(unsigned char *)(a2 + 63) = v20;
      }
    }
  }
  return result;
}

void std::__tree<std::string>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::string>::destroy(a1, *(void *)a2);
    std::__tree<std::string>::destroy(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t **a1, const void **a2, uint64_t a3)
{
  BOOL v5 = (uint64_t **)std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  __n128 result = *v5;
  if (!*v5)
  {
    std::__tree<std::string>::__construct_node<std::string const&>((uint64_t)a1, a3, (uint64_t)&v7);
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

void std::__tree<std::string>::__construct_node<std::string const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x38uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v7->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
  *(unsigned char *)(a3 + 16) = 1;
}

void sub_2563E53C0(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::string,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::string,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void *std::vector<CLMicroLocationProto::EventType>::__init_with_size[abi:ne180100]<CLMicroLocationProto::EventType*,CLMicroLocationProto::EventType*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<CLMicroLocationProto::ConfidenceLevel>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2563E549C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 48)
  {
    if (*(char *)(i - 25) < 0) {
      operator delete(*(void **)(i - 48));
    }
  }
  a1[1] = v2;
}

void *std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid>(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
    char v10 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == *a2 && i[3] == a2[1]) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v7;
  *((_OWORD *)i + 1) = *a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
      else {
        unint64_t v3 = v7;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  __n128 v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *uint64_t i = *v21;
LABEL_44:
    void *v21 = i;
    goto LABEL_45;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    __n128 v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_2563E579C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

long long *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)(a4 + 16) = *((void *)v5 + 2);
      *(_OWORD *)a4 = v7;
      unint64_t v8 = (void **)(a4 + 24);
      if (*(char *)(a4 + 47) < 0) {
        operator delete(*v8);
      }
      long long v9 = *(long long *)((char *)v5 + 24);
      *(void *)(a4 + 40) = *((void *)v5 + 5);
      *(_OWORD *)unint64_t v8 = v9;
      *((unsigned char *)v5 + 47) = 0;
      *((unsigned char *)v5 + 24) = 0;
      long long v10 = v5[3];
      *(_OWORD *)(a4 + 60) = *(long long *)((char *)v5 + 60);
      *(_OWORD *)(a4 + 48) = v10;
      CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a4 + 80), (const CLMicroLocationProto::RecordingEvent *)(v5 + 5));
      long long v11 = v5[14];
      *(unsigned char *)(a4 + 240) = *((unsigned char *)v5 + 240);
      *(_OWORD *)(a4 + 224) = v11;
      a4 += 248;
      uint64_t v5 = (long long *)((char *)v5 + 248);
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *,false>(unint64_t *a1, unint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v251 = *MEMORY[0x263EF8340];
LABEL_2:
  unint64_t v8 = (long long *)a2;
  long long v9 = a2 - 31;
  long long v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = (char *)v8 - (char *)v10;
    unint64_t v12 = 0xEF7BDEF7BDEF7BDFLL * (((char *)v8 - (char *)v10) >> 3);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v102 = bswap64(*(a2 - 31));
          unint64_t v103 = bswap64(*a1);
          if (v102 != v103 || (unint64_t v102 = bswap64(*(a2 - 30)), v103 = bswap64(a1[1]), v102 != v103))
          {
            if (v102 < v103) {
              int v212 = -1;
            }
            else {
              int v212 = 1;
            }
            if (v212 < 0) {
              std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)(a2 - 31));
            }
          }
          break;
        case 3uLL:
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, v9);
          break;
        case 4uLL:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, a1 + 62, v9);
          break;
        case 5uLL:
          std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *,0>(a1, a1 + 31, a1 + 62, a1 + 93, v9);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 5951) {
      break;
    }
    if (!a3)
    {
      if (a1 != (unint64_t *)v8)
      {
        int64_t v127 = (v12 - 2) >> 1;
        int64_t v128 = v127;
        do
        {
          int64_t v129 = v128;
          if (v127 >= v128)
          {
            uint64_t v130 = (2 * v128) | 1;
            int v131 = &a1[31 * v130];
            if (2 * v128 + 2 < (uint64_t)v12)
            {
              unint64_t v132 = bswap64(*v131);
              unint64_t v133 = bswap64(v131[31]);
              if (v132 == v133 && (unint64_t v132 = bswap64(v131[1]), v133 = bswap64(v131[32]), v132 == v133)) {
                int v134 = 0;
              }
              else {
                int v134 = v132 < v133 ? -1 : 1;
              }
              if (v134 < 0)
              {
                v131 += 31;
                uint64_t v130 = 2 * v128 + 2;
              }
            }
            v135 = &a1[31 * v128];
            unint64_t v136 = bswap64(*v131);
            unint64_t v137 = bswap64(*v135);
            if (v136 == v137 && (unint64_t v136 = bswap64(v131[1]), v137 = bswap64(v135[1]), v136 == v137)
              || (v136 < v137 ? (int v138 = -1) : (int v138 = 1), (v138 & 0x80000000) == 0))
            {
              long long v139 = *(_OWORD *)v135;
              unint64_t v244 = v135[2];
              long long v243 = v139;
              long long v140 = &a1[31 * v129];
              long long v141 = *(_OWORD *)(v140 + 3);
              unint64_t v246 = v140[5];
              long long __p = v141;
              v140[4] = 0;
              v140[5] = 0;
              v140[3] = 0;
              long long v142 = *((_OWORD *)v140 + 3);
              *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)v140 + 60);
              v247[0] = v142;
              CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(v140 + 10));
              uint64_t v143 = &a1[31 * v129];
              long long v144 = *((_OWORD *)v143 + 14);
              char v250 = *((unsigned char *)v143 + 240);
              long long v249 = v144;
              do
              {
                unsigned int v145 = v131;
                long long v146 = *(_OWORD *)v131;
                v135[2] = v131[2];
                *(_OWORD *)v135 = v146;
                long long v147 = (void **)(v135 + 3);
                if (*((char *)v135 + 47) < 0) {
                  operator delete(*v147);
                }
                long long v148 = *(_OWORD *)(v145 + 3);
                v135[5] = v145[5];
                *(_OWORD *)long long v147 = v148;
                *((unsigned char *)v145 + 47) = 0;
                *((unsigned char *)v145 + 24) = 0;
                long long v149 = *((_OWORD *)v145 + 3);
                *(_OWORD *)((char *)v135 + 60) = *(_OWORD *)((char *)v145 + 60);
                *((_OWORD *)v135 + 3) = v149;
                CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v135 + 10), (const CLMicroLocationProto::RecordingEvent *)(v145 + 10));
                long long v150 = *((_OWORD *)v145 + 14);
                *((unsigned char *)v135 + 240) = *((unsigned char *)v145 + 240);
                *((_OWORD *)v135 + 14) = v150;
                if (v127 < v130) {
                  break;
                }
                int v131 = &a1[31 * ((2 * v130) | 1)];
                if (2 * v130 + 2 < (uint64_t)v12)
                {
                  unint64_t v151 = bswap64(*v131);
                  unint64_t v152 = bswap64(v131[31]);
                  if (v151 == v152 && (unint64_t v151 = bswap64(v131[1]), v152 = bswap64(v131[32]), v151 == v152)) {
                    int v153 = 0;
                  }
                  else {
                    int v153 = v151 < v152 ? -1 : 1;
                  }
                  if (v153 >= 0)
                  {
                    uint64_t v130 = (2 * v130) | 1;
                  }
                  else
                  {
                    v131 += 31;
                    uint64_t v130 = 2 * v130 + 2;
                  }
                }
                else
                {
                  uint64_t v130 = (2 * v130) | 1;
                }
                unint64_t v154 = bswap64(*v131);
                unint64_t v155 = bswap64(v243);
                if (v154 == v155
                  && (unint64_t v154 = bswap64(v131[1]), v155 = bswap64(*((unint64_t *)&v243 + 1)), v154 == v155))
                {
                  int v156 = 0;
                }
                else
                {
                  int v156 = v154 < v155 ? -1 : 1;
                }
                v135 = v145;
              }
              while ((v156 & 0x80000000) == 0);
              long long v157 = (void **)(v145 + 3);
              long long v158 = v243;
              v145[2] = v244;
              *(_OWORD *)unsigned int v145 = v158;
              if (*((char *)v145 + 47) < 0) {
                operator delete(*v157);
              }
              long long v159 = __p;
              v145[5] = v246;
              *(_OWORD *)long long v157 = v159;
              HIBYTE(v246) = 0;
              LOBYTE(__p) = 0;
              long long v160 = *(_OWORD *)((char *)v247 + 12);
              *((_OWORD *)v145 + 3) = v247[0];
              *(_OWORD *)((char *)v145 + 60) = v160;
              CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v145 + 10), (const CLMicroLocationProto::RecordingEvent *)v248);
              long long v161 = v249;
              *((unsigned char *)v145 + 240) = v250;
              *((_OWORD *)v145 + 14) = v161;
              CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
              if (SHIBYTE(v246) < 0) {
                operator delete((void *)__p);
              }
            }
          }
          int64_t v128 = v129 - 1;
        }
        while (v129);
        int64_t v162 = v11 / 0xF8uLL;
        v231 = (CLMicroLocationProto::RecordingEvent *)(a1 + 3);
        do
        {
          unint64_t v236 = a1[2];
          long long v235 = *(_OWORD *)a1;
          long long v237 = *(_OWORD *)v231;
          unint64_t v238 = a1[5];
          a1[4] = 0;
          a1[5] = 0;
          *(void *)v231 = 0;
          *(_OWORD *)v239 = *((_OWORD *)a1 + 3);
          *(_OWORD *)&v239[12] = *(_OWORD *)((char *)a1 + 60);
          CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v240, (const CLMicroLocationProto::RecordingEvent *)(a1 + 10));
          uint64_t v163 = 0;
          long long v164 = *((_OWORD *)a1 + 14);
          char v242 = *((unsigned char *)a1 + 240);
          long long v241 = v164;
          uint64_t v165 = (uint64_t)a1;
          do
          {
            uint64_t v166 = v165 + 248 * v163 + 248;
            uint64_t v167 = 2 * v163;
            uint64_t v163 = (2 * v163) | 1;
            if (v167 + 2 < v162)
            {
              unint64_t v168 = bswap64(*(void *)v166);
              unint64_t v169 = bswap64(*(void *)(v166 + 248));
              if (v168 == v169
                && (unint64_t v168 = bswap64(*(void *)(v166 + 8)), v169 = bswap64(*(void *)(v166 + 256)), v168 == v169))
              {
                int v170 = 0;
              }
              else
              {
                int v170 = v168 < v169 ? -1 : 1;
              }
              if (v170 < 0)
              {
                v166 += 248;
                uint64_t v163 = v167 + 2;
              }
            }
            long long v171 = *(_OWORD *)v166;
            *(void *)(v165 + 16) = *(void *)(v166 + 16);
            *(_OWORD *)uint64_t v165 = v171;
            unint64_t v172 = (void **)(v165 + 24);
            if (*(char *)(v165 + 47) < 0) {
              operator delete(*v172);
            }
            long long v173 = *(_OWORD *)(v166 + 24);
            *(void *)(v165 + 40) = *(void *)(v166 + 40);
            *(_OWORD *)unint64_t v172 = v173;
            *(unsigned char *)(v166 + 47) = 0;
            *(unsigned char *)(v166 + 24) = 0;
            long long v174 = *(_OWORD *)(v166 + 48);
            *(_OWORD *)(v165 + 60) = *(_OWORD *)(v166 + 60);
            *(_OWORD *)(v165 + 48) = v174;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v165 + 80), (const CLMicroLocationProto::RecordingEvent *)(v166 + 80));
            long long v175 = *(_OWORD *)(v166 + 224);
            *(unsigned char *)(v165 + 240) = *(unsigned char *)(v166 + 240);
            *(_OWORD *)(v165 + 224) = v175;
            uint64_t v165 = v166;
          }
          while (v163 <= (uint64_t)((unint64_t)(v162 - 2) >> 1));
          unsigned int v176 = (void **)(v166 + 24);
          __int16 v177 = (long long *)(v166 + 48);
          v233 = (CLMicroLocationProto::RecordingEvent *)(v166 + 224);
          if ((unint64_t *)v166 == a2 - 31)
          {
            *(void *)(v166 + 16) = v236;
            *(_OWORD *)uint64_t v166 = v235;
            if (*(char *)(v166 + 47) < 0) {
              operator delete(*v176);
            }
            *(void *)(v166 + 40) = v238;
            *(_OWORD *)unsigned int v176 = v237;
            *(_OWORD *)(v166 + 60) = *(_OWORD *)&v239[12];
            *__int16 v177 = *(_OWORD *)v239;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v166 + 80), (const CLMicroLocationProto::RecordingEvent *)v240);
            long long v191 = v241;
            *(unsigned char *)(v166 + 240) = v242;
            *(_OWORD *)v233 = v191;
          }
          else
          {
            long long v178 = *(_OWORD *)(a2 - 31);
            *(void *)(v166 + 16) = *(a2 - 29);
            *(_OWORD *)uint64_t v166 = v178;
            if (*(char *)(v166 + 47) < 0) {
              operator delete(*v176);
            }
            long long v179 = *((_OWORD *)a2 - 14);
            *(void *)(v166 + 40) = *(a2 - 26);
            *(_OWORD *)unsigned int v176 = v179;
            *((unsigned char *)a2 - 201) = 0;
            *((unsigned char *)a2 - 224) = 0;
            long long v180 = *(_OWORD *)(a2 - 25);
            *(_OWORD *)(v166 + 60) = *(_OWORD *)((char *)a2 - 188);
            *__int16 v177 = v180;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v166 + 80), (const CLMicroLocationProto::RecordingEvent *)(a2 - 21));
            uint64_t v181 = (void **)(a2 - 28);
            long long v182 = *(_OWORD *)(a2 - 3);
            *(unsigned char *)(v166 + 240) = *((unsigned char *)a2 - 8);
            *(_OWORD *)v233 = v182;
            *(a2 - 29) = v236;
            *(_OWORD *)(a2 - 31) = v235;
            if (*((char *)a2 - 201) < 0) {
              operator delete(*v181);
            }
            uint64_t v183 = a2 - 25;
            *(a2 - 26) = v238;
            *(_OWORD *)uint64_t v181 = v237;
            *(_OWORD *)((char *)v183 + 12) = *(_OWORD *)&v239[12];
            *(_OWORD *)uint64_t v183 = *(_OWORD *)v239;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a2 - 21), (const CLMicroLocationProto::RecordingEvent *)v240);
            uint64_t v184 = a2 - 3;
            long long v185 = v241;
            *((unsigned char *)v184 + 16) = v242;
            *(_OWORD *)uint64_t v184 = v185;
            uint64_t v186 = v166 - (void)a1 + 248;
            if (v186 >= 249)
            {
              unint64_t v187 = (v186 / 0xF8uLL - 2) >> 1;
              char v188 = &a1[31 * v187];
              unint64_t v189 = bswap64(*v188);
              unint64_t v190 = bswap64(*(void *)v166);
              if (v189 != v190 || (unint64_t v189 = bswap64(v188[1]), v190 = bswap64(*(void *)(v166 + 8)), v189 != v190))
              {
                int v192 = v189 < v190 ? -1 : 1;
                if (v192 < 0)
                {
                  long long v193 = *(_OWORD *)v166;
                  unint64_t v244 = *(void *)(v166 + 16);
                  long long v243 = v193;
                  long long v194 = *(_OWORD *)v176;
                  unint64_t v246 = *(void *)(v166 + 40);
                  long long __p = v194;
                  *(void *)(v166 + 32) = 0;
                  *(void *)(v166 + 40) = 0;
                  *unsigned int v176 = 0;
                  long long v195 = *v177;
                  *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)(v166 + 60);
                  v247[0] = v195;
                  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(v166 + 80));
                  long long v196 = *(_OWORD *)v233;
                  char v250 = *(unsigned char *)(v166 + 240);
                  long long v249 = v196;
                  do
                  {
                    uint64_t v197 = (uint64_t)v188;
                    long long v198 = *(_OWORD *)v188;
                    *(void *)(v166 + 16) = v188[2];
                    *(_OWORD *)uint64_t v166 = v198;
                    v199 = (void **)(v166 + 24);
                    if (*(char *)(v166 + 47) < 0) {
                      operator delete(*v199);
                    }
                    long long v200 = *(_OWORD *)(v188 + 3);
                    *(void *)(v166 + 40) = v188[5];
                    *(_OWORD *)v199 = v200;
                    *((unsigned char *)v188 + 47) = 0;
                    *((unsigned char *)v188 + 24) = 0;
                    long long v201 = *((_OWORD *)v188 + 3);
                    *(_OWORD *)(v166 + 60) = *(_OWORD *)((char *)v188 + 60);
                    *(_OWORD *)(v166 + 48) = v201;
                    CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v166 + 80), (const CLMicroLocationProto::RecordingEvent *)(v188 + 10));
                    long long v202 = *((_OWORD *)v188 + 14);
                    *(unsigned char *)(v166 + 240) = *((unsigned char *)v188 + 240);
                    *(_OWORD *)(v166 + 224) = v202;
                    if (!v187) {
                      break;
                    }
                    unint64_t v187 = (v187 - 1) >> 1;
                    char v188 = &a1[31 * v187];
                    unint64_t v203 = bswap64(*v188);
                    unint64_t v204 = bswap64(v243);
                    if (v203 == v204
                      && (unint64_t v203 = bswap64(v188[1]), v204 = bswap64(*((unint64_t *)&v243 + 1)), v203 == v204))
                    {
                      int v205 = 0;
                    }
                    else
                    {
                      int v205 = v203 < v204 ? -1 : 1;
                    }
                    uint64_t v166 = v197;
                  }
                  while (v205 < 0);
                  v206 = (void **)(v197 + 24);
                  long long v207 = v243;
                  *(void *)(v197 + 16) = v244;
                  *(_OWORD *)uint64_t v197 = v207;
                  if (*(char *)(v197 + 47) < 0) {
                    operator delete(*v206);
                  }
                  long long v208 = __p;
                  *(void *)(v197 + 40) = v246;
                  *(_OWORD *)v206 = v208;
                  HIBYTE(v246) = 0;
                  LOBYTE(__p) = 0;
                  long long v209 = *(_OWORD *)((char *)v247 + 12);
                  *(_OWORD *)(v197 + 48) = v247[0];
                  *(_OWORD *)(v197 + 60) = v209;
                  CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v197 + 80), (const CLMicroLocationProto::RecordingEvent *)v248);
                  long long v210 = v249;
                  *(unsigned char *)(v197 + 240) = v250;
                  *(_OWORD *)(v197 + 224) = v210;
                  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
                  if (SHIBYTE(v246) < 0) {
                    operator delete((void *)__p);
                  }
                }
              }
            }
          }
          CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v240);
          a2 -= 31;
        }
        while (v162-- > 2);
      }
      return;
    }
    unint64_t v13 = v12 >> 1;
    float v14 = &a1[31 * (v12 >> 1)];
    if ((unint64_t)v11 >= 0x7C01)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, &a1[31 * (v12 >> 1)], v9);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1 + 31, &a1[31 * v13 - 31], a2 - 62);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1 + 62, &a1[31 * v13 + 31], a2 - 93);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(&a1[31 * v13 - 31], v14, &a1[31 * v13 + 31]);
      std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)v14);
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(&a1[31 * (v12 >> 1)], a1, v9);
    }
    --a3;
    if ((a4 & 1) == 0
      && ((unint64_t v15 = bswap64(*(a1 - 31)), v16 = bswap64(*a1), v15 == v16)
       && (unint64_t v15 = bswap64(*(a1 - 30)), v16 = bswap64(a1[1]), v15 == v16)
       || (v15 < v16 ? (int v24 = -1) : (int v24 = 1), (v24 & 0x80000000) == 0)))
    {
      long long v17 = *(_OWORD *)a1;
      unint64_t v244 = a1[2];
      long long v243 = v17;
      unint64_t v18 = a1[5];
      long long __p = *(_OWORD *)(a1 + 3);
      unint64_t v246 = v18;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      long long v19 = *(_OWORD *)((char *)a1 + 60);
      v247[0] = *((_OWORD *)a1 + 3);
      *(_OWORD *)((char *)v247 + 12) = v19;
      CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(a1 + 10));
      long long v20 = *((_OWORD *)a1 + 14);
      char v250 = *((unsigned char *)a1 + 240);
      long long v249 = v20;
      unint64_t v21 = bswap64(v243);
      unint64_t v22 = bswap64(*v9);
      if (v21 == v22 && (unint64_t v21 = bswap64(*((unint64_t *)&v243 + 1)), v22 = bswap64(*(a2 - 30)), v21 == v22))
      {
        int v23 = 0;
      }
      else if (v21 < v22)
      {
        int v23 = -1;
      }
      else
      {
        int v23 = 1;
      }
      if (v23 < 0)
      {
        unint64_t v70 = a1;
        long long v10 = a1;
        do
        {
          unint64_t v71 = v10[31];
          v10 += 31;
          unint64_t v72 = bswap64(v243);
          unint64_t v73 = bswap64(v71);
          if (v72 == v73 && (unint64_t v72 = bswap64(*((unint64_t *)&v243 + 1)), v73 = bswap64(v70[32]), v72 == v73))
          {
            int v74 = 0;
          }
          else if (v72 < v73)
          {
            int v74 = -1;
          }
          else
          {
            int v74 = 1;
          }
          unint64_t v70 = v10;
        }
        while ((v74 & 0x80000000) == 0);
      }
      else
      {
        uint64_t v66 = a1 + 31;
        do
        {
          long long v10 = v66;
          if (v66 >= (unint64_t *)v8) {
            break;
          }
          unint64_t v67 = bswap64(v243);
          unint64_t v68 = bswap64(*v10);
          if (v67 == v68 && (unint64_t v67 = bswap64(*((unint64_t *)&v243 + 1)), v68 = bswap64(v10[1]), v67 == v68)) {
            int v69 = 0;
          }
          else {
            int v69 = v67 < v68 ? -1 : 1;
          }
          uint64_t v66 = v10 + 31;
        }
        while ((v69 & 0x80000000) == 0);
      }
      uint64_t v75 = v8;
      if (v10 < (unint64_t *)v8)
      {
        unsigned __int8 v76 = v8;
        uint64_t v75 = v8;
        do
        {
          unint64_t v77 = *((void *)v75 - 31);
          uint64_t v75 = (long long *)((char *)v75 - 248);
          unint64_t v78 = bswap64(v243);
          unint64_t v79 = bswap64(v77);
          if (v78 == v79
            && (unint64_t v78 = bswap64(*((unint64_t *)&v243 + 1)), v79 = bswap64(*((void *)v76 - 30)), v78 == v79))
          {
            int v80 = 0;
          }
          else if (v78 < v79)
          {
            int v80 = -1;
          }
          else
          {
            int v80 = 1;
          }
          unsigned __int8 v76 = v75;
        }
        while (v80 < 0);
      }
      while (v10 < (unint64_t *)v75)
      {
        std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)v10, v75);
        unint64_t v81 = v10;
        do
        {
          unint64_t v82 = v10[31];
          v10 += 31;
          unint64_t v83 = bswap64(v243);
          unint64_t v84 = bswap64(v82);
          if (v83 == v84 && (unint64_t v83 = bswap64(*((unint64_t *)&v243 + 1)), v84 = bswap64(v81[32]), v83 == v84))
          {
            int v85 = 0;
          }
          else if (v83 < v84)
          {
            int v85 = -1;
          }
          else
          {
            int v85 = 1;
          }
          unint64_t v81 = v10;
        }
        while ((v85 & 0x80000000) == 0);
        unint64_t v86 = v75;
        do
        {
          unint64_t v87 = *((void *)v75 - 31);
          uint64_t v75 = (long long *)((char *)v75 - 248);
          unint64_t v88 = bswap64(v243);
          unint64_t v89 = bswap64(v87);
          if (v88 == v89
            && (unint64_t v88 = bswap64(*((unint64_t *)&v243 + 1)), v89 = bswap64(*((void *)v86 - 30)), v88 == v89))
          {
            int v90 = 0;
          }
          else if (v88 < v89)
          {
            int v90 = -1;
          }
          else
          {
            int v90 = 1;
          }
          unint64_t v86 = v75;
        }
        while (v90 < 0);
      }
      char v91 = v10 - 31;
      if (v10 - 31 != a1)
      {
        unint64_t v92 = (void **)(a1 + 3);
        long long v93 = *(_OWORD *)v91;
        a1[2] = *(v10 - 29);
        *(_OWORD *)a1 = v93;
        if (*((char *)a1 + 47) < 0) {
          operator delete(*v92);
        }
        long long v94 = *((_OWORD *)v10 - 14);
        a1[5] = *(v10 - 26);
        *(_OWORD *)unint64_t v92 = v94;
        *((unsigned char *)v10 - 201) = 0;
        *((unsigned char *)v10 - 224) = 0;
        long long v95 = *(_OWORD *)(v10 - 25);
        *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v10 - 188);
        *((_OWORD *)a1 + 3) = v95;
        CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a1 + 10), (const CLMicroLocationProto::RecordingEvent *)(v10 - 21));
        long long v96 = *(_OWORD *)(v10 - 3);
        *((unsigned char *)a1 + 240) = *((unsigned char *)v10 - 8);
        *((_OWORD *)a1 + 14) = v96;
      }
      long long v97 = v243;
      *(v10 - 29) = v244;
      *(_OWORD *)char v91 = v97;
      uint64_t v98 = (void **)(v10 - 28);
      if (*((char *)v10 - 201) < 0) {
        operator delete(*v98);
      }
      long long v99 = __p;
      *(v10 - 26) = v246;
      *(_OWORD *)uint64_t v98 = v99;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      long long v100 = v247[0];
      *(_OWORD *)((char *)v10 - 188) = *(_OWORD *)((char *)v247 + 12);
      *(_OWORD *)(v10 - 25) = v100;
      CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v10 - 21), (const CLMicroLocationProto::RecordingEvent *)v248);
      long long v101 = v249;
      *((unsigned char *)v10 - 8) = v250;
      *(_OWORD *)(v10 - 3) = v101;
      CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
LABEL_79:
      a4 = 0;
    }
    else
    {
      long long v25 = *(_OWORD *)a1;
      unint64_t v244 = a1[2];
      long long v243 = v25;
      unint64_t v26 = a1[5];
      long long __p = *(_OWORD *)(a1 + 3);
      unint64_t v246 = v26;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      long long v27 = *(_OWORD *)((char *)a1 + 60);
      v247[0] = *((_OWORD *)a1 + 3);
      *(_OWORD *)((char *)v247 + 12) = v27;
      CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(a1 + 10));
      uint64_t v28 = 0;
      __n128 v29 = (void **)(a1 + 3);
      long long v30 = *((_OWORD *)a1 + 14);
      char v250 = *((unsigned char *)a1 + 240);
      long long v249 = v30;
      do
      {
        unint64_t v31 = bswap64(a1[v28 + 31]);
        unint64_t v32 = bswap64(v243);
        if (v31 == v32 && (unint64_t v31 = bswap64(a1[v28 + 32]), v32 = bswap64(*((unint64_t *)&v243 + 1)), v31 == v32))
        {
          int v33 = 0;
        }
        else if (v31 < v32)
        {
          int v33 = -1;
        }
        else
        {
          int v33 = 1;
        }
        v28 += 31;
      }
      while (v33 < 0);
      uint64_t v34 = &a1[v28];
      uint64_t v35 = v8;
      if (v28 == 31)
      {
        __n128 v40 = a2;
        while (v34 < v40)
        {
          __n128 v36 = (long long *)(v40 - 31);
          unint64_t v41 = bswap64(*(v40 - 31));
          unint64_t v42 = bswap64(v243);
          if (v41 == v42 && (unint64_t v41 = bswap64(*(v40 - 30)), v42 = bswap64(*((unint64_t *)&v243 + 1)), v41 == v42))
          {
            int v43 = 0;
          }
          else if (v41 < v42)
          {
            int v43 = -1;
          }
          else
          {
            int v43 = 1;
          }
          v40 -= 31;
          if (v43 < 0) {
            goto LABEL_47;
          }
        }
        __n128 v36 = (long long *)v40;
      }
      else
      {
        do
        {
          __n128 v36 = (long long *)((char *)v35 - 248);
          unint64_t v37 = bswap64(*((void *)v35 - 31));
          unint64_t v38 = bswap64(v243);
          if (v37 == v38
            && (v37 = bswap64(*((void *)v35 - 30)), unint64_t v38 = bswap64(*((unint64_t *)&v243 + 1)), v37 == v38))
          {
            int v39 = 0;
          }
          else if (v37 < v38)
          {
            int v39 = -1;
          }
          else
          {
            int v39 = 1;
          }
          uint64_t v35 = (long long *)((char *)v35 - 248);
        }
        while ((v39 & 0x80000000) == 0);
      }
LABEL_47:
      long long v10 = v34;
      if (v34 < (unint64_t *)v36)
      {
        __n128 v44 = v36;
        do
        {
          std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)v10, v44);
          unint64_t v45 = v10;
          do
          {
            unint64_t v46 = v10[31];
            v10 += 31;
            unint64_t v47 = bswap64(v46);
            unint64_t v48 = bswap64(v243);
            if (v47 == v48 && (v47 = bswap64(v45[32]), unint64_t v48 = bswap64(*((unint64_t *)&v243 + 1)), v47 == v48))
            {
              int v49 = 0;
            }
            else if (v47 < v48)
            {
              int v49 = -1;
            }
            else
            {
              int v49 = 1;
            }
            unint64_t v45 = v10;
          }
          while (v49 < 0);
          unsigned __int8 v50 = v44;
          do
          {
            unint64_t v51 = *((void *)v44 - 31);
            __n128 v44 = (long long *)((char *)v44 - 248);
            unint64_t v52 = bswap64(v51);
            unint64_t v53 = bswap64(v243);
            if (v52 == v53
              && (unint64_t v52 = bswap64(*((void *)v50 - 30)), v53 = bswap64(*((unint64_t *)&v243 + 1)), v52 == v53))
            {
              int v54 = 0;
            }
            else if (v52 < v53)
            {
              int v54 = -1;
            }
            else
            {
              int v54 = 1;
            }
            unsigned __int8 v50 = v44;
          }
          while ((v54 & 0x80000000) == 0);
        }
        while (v10 < (unint64_t *)v44);
      }
      double v55 = v10 - 31;
      if (v10 - 31 != a1)
      {
        long long v56 = *(_OWORD *)v55;
        a1[2] = *(v10 - 29);
        *(_OWORD *)a1 = v56;
        if (*((char *)a1 + 47) < 0) {
          operator delete(*v29);
        }
        long long v57 = *((_OWORD *)v10 - 14);
        a1[5] = *(v10 - 26);
        *(_OWORD *)__n128 v29 = v57;
        *((unsigned char *)v10 - 201) = 0;
        *((unsigned char *)v10 - 224) = 0;
        long long v58 = *(_OWORD *)(v10 - 25);
        *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v10 - 188);
        *((_OWORD *)a1 + 3) = v58;
        CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a1 + 10), (const CLMicroLocationProto::RecordingEvent *)(v10 - 21));
        long long v59 = *(_OWORD *)(v10 - 3);
        *((unsigned char *)a1 + 240) = *((unsigned char *)v10 - 8);
        *((_OWORD *)a1 + 14) = v59;
      }
      long long v60 = v243;
      *(v10 - 29) = v244;
      *(_OWORD *)double v55 = v60;
      unint64_t v61 = (void **)(v10 - 28);
      if (*((char *)v10 - 201) < 0) {
        operator delete(*v61);
      }
      long long v62 = __p;
      *(v10 - 26) = v246;
      *(_OWORD *)unint64_t v61 = v62;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      long long v63 = v247[0];
      *(_OWORD *)((char *)v10 - 188) = *(_OWORD *)((char *)v247 + 12);
      *(_OWORD *)(v10 - 25) = v63;
      CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v10 - 21), (const CLMicroLocationProto::RecordingEvent *)v248);
      long long v64 = v249;
      *((unsigned char *)v10 - 8) = v250;
      *(_OWORD *)(v10 - 3) = v64;
      CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
      BOOL v4 = v34 >= (unint64_t *)v36;
      unint64_t v8 = (long long *)a2;
      if (!v4) {
        goto LABEL_78;
      }
      BOOL v65 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, v10 - 31);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(v10, a2))
      {
        a2 = v10 - 31;
        if (v65) {
          return;
        }
        goto LABEL_2;
      }
      if (!v65)
      {
LABEL_78:
        std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *,false>(a1, v10 - 31, a3, a4 & 1);
        goto LABEL_79;
      }
    }
  }
  if ((a4 & 1) == 0)
  {
    if (a1 == (unint64_t *)v8) {
      return;
    }
    v213 = a1 + 31;
    if (a1 + 31 == a2) {
      return;
    }
    for (uint64_t i = a1 - 31; ; i += 31)
    {
      v215 = v213;
      unint64_t v216 = bswap64(a1[31]);
      unint64_t v217 = bswap64(*a1);
      if (v216 != v217) {
        break;
      }
      unint64_t v216 = bswap64(v215[1]);
      unint64_t v217 = bswap64(a1[1]);
      v218 = a2;
      if (v216 != v217) {
        goto LABEL_280;
      }
LABEL_298:
      v213 = v215 + 31;
      a1 = v215;
      if (v215 + 31 == v218) {
        return;
      }
    }
    v218 = a2;
LABEL_280:
    if (v216 < v217) {
      int v219 = -1;
    }
    else {
      int v219 = 1;
    }
    if (v219 < 0)
    {
      long long v220 = *(_OWORD *)v215;
      unint64_t v244 = v215[2];
      long long v243 = v220;
      long long __p = *((_OWORD *)a1 + 17);
      unint64_t v246 = a1[36];
      a1[34] = 0;
      a1[35] = 0;
      a1[36] = 0;
      v247[0] = *(_OWORD *)(a1 + 37);
      *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)a1 + 308);
      CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(a1 + 41));
      char v250 = *((unsigned char *)a1 + 488);
      long long v249 = *(_OWORD *)(a1 + 59);
      v221 = i;
      do
      {
        *((_OWORD *)v221 + 31) = *(_OWORD *)(v221 + 31);
        v221[64] = v221[33];
        v222 = (void **)(v221 + 65);
        if (*((char *)v221 + 543) < 0) {
          operator delete(*v222);
        }
        *(_OWORD *)v222 = *((_OWORD *)v221 + 17);
        v221[67] = v221[36];
        *((unsigned char *)v221 + 295) = 0;
        *((unsigned char *)v221 + 272) = 0;
        *((_OWORD *)v221 + 34) = *(_OWORD *)(v221 + 37);
        *(_OWORD *)((char *)v221 + 556) = *(_OWORD *)((char *)v221 + 308);
        CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v221 + 72), (const CLMicroLocationProto::RecordingEvent *)(v221 + 41));
        *((unsigned char *)v221 + 736) = *((unsigned char *)v221 + 488);
        *((_OWORD *)v221 + 45) = *(_OWORD *)(v221 + 59);
        unint64_t v223 = bswap64(v243);
        unint64_t v224 = bswap64(*v221);
        if (v223 == v224 && (unint64_t v223 = bswap64(*((unint64_t *)&v243 + 1)), v224 = bswap64(v221[1]), v223 == v224))
        {
          int v225 = 0;
        }
        else if (v223 < v224)
        {
          int v225 = -1;
        }
        else
        {
          int v225 = 1;
        }
        v221 -= 31;
      }
      while (v225 < 0);
      long long v226 = v243;
      v221[64] = v244;
      *((_OWORD *)v221 + 31) = v226;
      v227 = (void **)(v221 + 65);
      if (*((char *)v221 + 543) < 0) {
        operator delete(*v227);
      }
      long long v228 = __p;
      v221[67] = v246;
      *(_OWORD *)v227 = v228;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      long long v229 = v247[0];
      *(_OWORD *)((char *)v221 + 556) = *(_OWORD *)((char *)v247 + 12);
      *((_OWORD *)v221 + 34) = v229;
      CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v221 + 72), (const CLMicroLocationProto::RecordingEvent *)v248);
      long long v230 = v249;
      *((unsigned char *)v221 + 736) = v250;
      *((_OWORD *)v221 + 45) = v230;
      CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
      v218 = a2;
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
    }
    goto LABEL_298;
  }
  if (a1 != (unint64_t *)v8)
  {
    unint64_t v104 = a1 + 31;
    if (a1 + 31 != a2)
    {
      uint64_t v105 = 0;
      uint64_t v106 = (CLMicroLocationProto::RecordingEvent *)v248;
      long long v107 = a1;
      do
      {
        long long v108 = v104;
        unint64_t v109 = bswap64(v107[31]);
        unint64_t v110 = bswap64(*v107);
        if (v109 != v110 || (v109 = bswap64(v108[1]), unint64_t v110 = bswap64(v107[1]), v109 != v110))
        {
          int v111 = v109 < v110 ? -1 : 1;
          if (v111 < 0)
          {
            long long v112 = *(_OWORD *)v108;
            unint64_t v244 = v108[2];
            long long v243 = v112;
            long long __p = *((_OWORD *)v107 + 17);
            unint64_t v246 = v107[36];
            v107[34] = 0;
            v107[35] = 0;
            v107[36] = 0;
            v247[0] = *(_OWORD *)(v107 + 37);
            *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)v107 + 308);
            uint64_t v113 = v106;
            CLMicroLocationProto::RecordingEvent::RecordingEvent(v106, (const CLMicroLocationProto::RecordingEvent *)(v107 + 41));
            char v250 = *((unsigned char *)v107 + 488);
            long long v249 = *(_OWORD *)(v107 + 59);
            uint64_t v114 = v105;
            while (1)
            {
              unint64_t v115 = (char *)a1 + v114;
              *(_OWORD *)(v115 + 248) = *(_OWORD *)((char *)a1 + v114);
              *((void *)v115 + 33) = *(unint64_t *)((char *)a1 + v114 + 16);
              double v116 = (void **)((char *)a1 + v114 + 272);
              if (*((char *)a1 + v114 + 295) < 0) {
                operator delete(*v116);
              }
              *(_OWORD *)double v116 = *(_OWORD *)(v115 + 24);
              *(unint64_t *)((char *)a1 + v114 + 288) = *((void *)v115 + 5);
              v115[47] = 0;
              v115[24] = 0;
              *(_OWORD *)(v115 + 296) = *((_OWORD *)v115 + 3);
              *(_OWORD *)(v115 + 308) = *(_OWORD *)(v115 + 60);
              CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v115 + 328), (const CLMicroLocationProto::RecordingEvent *)(v115 + 80));
              uint64_t v117 = (char *)a1 + v114;
              *(_OWORD *)((char *)a1 + v114 + 472) = *(_OWORD *)((char *)a1 + v114 + 224);
              *((unsigned char *)a1 + v114 + 488) = *((unsigned char *)a1 + v114 + 240);
              if (!v114) {
                break;
              }
              unint64_t v118 = bswap64(v243);
              unint64_t v119 = bswap64(*((void *)v117 - 31));
              if (v118 == v119
                && (unint64_t v118 = bswap64(*((unint64_t *)&v243 + 1)),
                    unint64_t v119 = bswap64(*((void *)v117 - 30)),
                    v118 == v119))
              {
                int v120 = 0;
              }
              else if (v118 < v119)
              {
                int v120 = -1;
              }
              else
              {
                int v120 = 1;
              }
              v114 -= 248;
              if ((v120 & 0x80000000) == 0)
              {
                uint64_t v121 = (uint64_t)a1 + v114 + 248;
                goto LABEL_169;
              }
            }
            uint64_t v121 = (uint64_t)a1;
LABEL_169:
            long long v122 = v243;
            *(void *)(v121 + 16) = v244;
            *(_OWORD *)uint64_t v121 = v122;
            uint64_t v123 = (void **)(v117 + 24);
            if (*(char *)(v121 + 47) < 0) {
              operator delete(*v123);
            }
            long long v124 = __p;
            *((void *)v117 + 5) = v246;
            *(_OWORD *)uint64_t v123 = v124;
            HIBYTE(v246) = 0;
            LOBYTE(__p) = 0;
            long long v125 = v247[0];
            *(_OWORD *)(v117 + 60) = *(_OWORD *)((char *)v247 + 12);
            *((_OWORD *)v117 + 3) = v125;
            uint64_t v106 = v113;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v117 + 80), v113);
            long long v126 = v249;
            v117[240] = v250;
            *((_OWORD *)v117 + 14) = v126;
            CLMicroLocationProto::RecordingEvent::~RecordingEvent(v113);
            if (SHIBYTE(v246) < 0) {
              operator delete((void *)__p);
            }
          }
        }
        unint64_t v104 = v108 + 31;
        v105 += 248;
        long long v107 = v108;
      }
      while (v108 + 31 != a2);
    }
  }
}

void sub_2563E7008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, CLMicroLocationProto::RecordingEvent *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CLMicroLocationProto::RecordingEvent *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CLMicroLocationProto::RecordingEvent *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *__p,uint64_t a61,int a62,__int16 a63)
{
  if (a65 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *,0>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a2, a3, a4);
  unint64_t v10 = bswap64(*a5);
  unint64_t v11 = bswap64(*a4);
  if (v10 != v11 || (v10 = bswap64(a5[1]), unint64_t v11 = bswap64(a4[1]), v10 != v11))
  {
    int v12 = v10 < v11 ? -1 : 1;
    if (v12 < 0)
    {
      std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a4, (long long *)a5);
      unint64_t v13 = bswap64(*a4);
      unint64_t v14 = bswap64(*a3);
      if (v13 != v14 || (unint64_t v13 = bswap64(a4[1]), v14 = bswap64(a3[1]), v13 != v14))
      {
        int v15 = v13 < v14 ? -1 : 1;
        if (v15 < 0)
        {
          std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a3, (long long *)a4);
          unint64_t v16 = bswap64(*a3);
          unint64_t v17 = bswap64(*a2);
          if (v16 != v17 || (unint64_t v16 = bswap64(a3[1]), v17 = bswap64(a2[1]), v16 != v17))
          {
            int v18 = v16 < v17 ? -1 : 1;
            if (v18 < 0)
            {
              std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a2, (long long *)a3);
              unint64_t v19 = bswap64(*a2);
              unint64_t v20 = bswap64(*a1);
              if (v19 == v20 && (unint64_t v19 = bswap64(a2[1]), v20 = bswap64(a1[1]), v19 == v20))
              {
                int v21 = 0;
              }
              else if (v19 < v20)
              {
                int v21 = -1;
              }
              else
              {
                int v21 = 1;
              }
              if (v21 < 0)
              {
                std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)a2);
              }
            }
          }
        }
      }
    }
  }
}

void std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  char v5 = a1;
  unint64_t v6 = bswap64(*a2);
  unint64_t v7 = bswap64(*a1);
  if (v6 == v7 && (v6 = bswap64(a2[1]), unint64_t v7 = bswap64(a1[1]), v6 == v7))
  {
    int v8 = 0;
  }
  else if (v6 < v7)
  {
    int v8 = -1;
  }
  else
  {
    int v8 = 1;
  }
  unint64_t v9 = bswap64(*a3);
  unint64_t v10 = bswap64(*a2);
  if (v9 != v10 || (v9 = bswap64(a3[1]), unint64_t v10 = bswap64(a2[1]), v9 != v10))
  {
    if (v9 < v10) {
      int v11 = -1;
    }
    else {
      int v11 = 1;
    }
    if (v8 < 0) {
      goto LABEL_10;
    }
LABEL_18:
    if (v11 < 0)
    {
      std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a2, (long long *)a3);
      unint64_t v14 = bswap64(*a2);
      unint64_t v15 = bswap64(*v5);
      if (v14 != v15 || (v14 = bswap64(a2[1]), unint64_t v15 = bswap64(v5[1]), v14 != v15))
      {
        int v18 = v14 < v15 ? -1 : 1;
        if (v18 < 0)
        {
          a1 = v5;
          unint64_t v17 = (long long *)a2;
          goto LABEL_34;
        }
      }
    }
    return;
  }
  int v11 = 0;
  if ((v8 & 0x80000000) == 0) {
    goto LABEL_18;
  }
LABEL_10:
  if (v11 < 0)
  {
LABEL_27:
    unint64_t v17 = (long long *)a3;
LABEL_34:
    std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, v17);
    return;
  }
  std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)a2);
  unint64_t v12 = bswap64(*a3);
  unint64_t v13 = bswap64(*a2);
  if (v12 != v13 || (unint64_t v12 = bswap64(a3[1]), v13 = bswap64(a2[1]), v12 != v13))
  {
    int v16 = v12 < v13 ? -1 : 1;
    if (v16 < 0)
    {
      a1 = a2;
      goto LABEL_27;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = a2;
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0xEF7BDEF7BDEF7BDFLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = bswap64(*(a2 - 31));
      unint64_t v7 = bswap64(*a1);
      if (v6 != v7 || (v6 = bswap64(*(a2 - 30)), unint64_t v7 = bswap64(a1[1]), v6 != v7))
      {
        int v28 = v6 < v7 ? -1 : 1;
        if (v28 < 0)
        {
          std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)(a2 - 31));
          return 1;
        }
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, a2 - 31);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, a1 + 62, a2 - 31);
      return 1;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *,0>(a1, a1 + 31, a1 + 62, a1 + 93, a2 - 31);
      return 1;
    default:
      int v8 = a1 + 62;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, a1 + 62);
      unint64_t v9 = a1 + 93;
      if (a1 + 93 == v2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      unint64_t v12 = &v34;
      unint64_t v13 = (CLMicroLocationProto::RecordingEvent *)&v35;
      __n128 v29 = v2;
      break;
  }
  while (1)
  {
    unint64_t v14 = bswap64(*v9);
    unint64_t v15 = bswap64(*v8);
    if (v14 != v15 || (v14 = bswap64(v9[1]), unint64_t v15 = bswap64(v8[1]), v14 != v15))
    {
      int v16 = v14 < v15 ? -1 : 1;
      if (v16 < 0)
      {
        long long v30 = *(_OWORD *)v9;
        unint64_t v31 = v9[2];
        long long __p = *(_OWORD *)(v9 + 3);
        unint64_t v33 = v9[5];
        void v9[3] = 0;
        void v9[4] = 0;
        v9[5] = 0;
        *(_OWORD *)unint64_t v12 = *((_OWORD *)v9 + 3);
        unint64_t v17 = v12;
        *(_OWORD *)((char *)v12 + 12) = *(_OWORD *)((char *)v9 + 60);
        int v18 = v13;
        CLMicroLocationProto::RecordingEvent::RecordingEvent(v13, (const CLMicroLocationProto::RecordingEvent *)(v9 + 10));
        long long v36 = *((_OWORD *)v9 + 14);
        char v37 = *((unsigned char *)v9 + 240);
        uint64_t v19 = v10;
        while (1)
        {
          unint64_t v20 = (char *)a1 + v19;
          *(_OWORD *)((char *)a1 + v19 + 744) = *(_OWORD *)((char *)a1 + v19 + 496);
          *(unint64_t *)((char *)a1 + v19 + 760) = *(unint64_t *)((char *)a1 + v19 + 512);
          int v21 = (void **)((char *)a1 + v19 + 768);
          if (*((char *)a1 + v19 + 791) < 0) {
            operator delete(*v21);
          }
          *(unint64_t *)((char *)a1 + v19 + 784) = *((void *)v20 + 67);
          *(_OWORD *)int v21 = *(_OWORD *)(v20 + 520);
          v20[543] = 0;
          v20[520] = 0;
          *(_OWORD *)(v20 + 792) = *((_OWORD *)v20 + 34);
          *(_OWORD *)(v20 + 804) = *(_OWORD *)(v20 + 556);
          CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v20 + 824), (const CLMicroLocationProto::RecordingEvent *)(v20 + 576));
          unint64_t v22 = (char *)a1 + v19;
          *(_OWORD *)((char *)a1 + v19 + 968) = *(_OWORD *)((char *)a1 + v19 + 720);
          *((unsigned char *)a1 + v19 + 984) = *((unsigned char *)a1 + v19 + 736);
          if (v19 == -496) {
            break;
          }
          unint64_t v23 = bswap64(v30);
          unint64_t v24 = bswap64(*((void *)v22 + 31));
          if (v23 == v24
            && (v23 = bswap64(*((unint64_t *)&v30 + 1)), unint64_t v24 = bswap64(*((void *)v22 + 32)), v23 == v24))
          {
            int v25 = 0;
          }
          else if (v23 < v24)
          {
            int v25 = -1;
          }
          else
          {
            int v25 = 1;
          }
          v19 -= 248;
          if ((v25 & 0x80000000) == 0)
          {
            uint64_t v26 = (uint64_t)a1 + v19 + 744;
            goto LABEL_26;
          }
        }
        uint64_t v26 = (uint64_t)a1;
LABEL_26:
        *(_OWORD *)uint64_t v26 = v30;
        *(void *)(v26 + 16) = v31;
        long long v27 = (void **)(v22 + 520);
        if (*(char *)(v26 + 47) < 0) {
          operator delete(*v27);
        }
        *(_OWORD *)long long v27 = __p;
        *((void *)v22 + 67) = v33;
        unint64_t v12 = v17;
        *((_OWORD *)v22 + 34) = *(_OWORD *)v17;
        *(_OWORD *)(v22 + 556) = *(_OWORD *)((char *)v17 + 12);
        unint64_t v13 = v18;
        CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v22 + 576), v18);
        *((_OWORD *)v22 + 45) = v36;
        v22[736] = v37;
        CLMicroLocationProto::RecordingEvent::~RecordingEvent(v18);
        uint64_t v2 = v29;
        if (++v11 == 8) {
          return v9 + 31 == v29;
        }
      }
    }
    int v8 = v9;
    v10 += 248;
    v9 += 31;
    if (v9 == v2) {
      return 1;
    }
  }
}

void sub_2563E7870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

void std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>(long long *a1, long long *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  long long v11 = *a1;
  uint64_t v12 = *((void *)a1 + 2);
  *(_OWORD *)long long __p = *(long long *)((char *)a1 + 24);
  uint64_t v14 = *((void *)a1 + 5);
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 5) = 0;
  *(_OWORD *)unint64_t v15 = a1[3];
  *(_OWORD *)&v15[12] = *(long long *)((char *)a1 + 60);
  uint64_t v4 = (CLMicroLocationProto::RecordingEvent *)(a1 + 5);
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v16, (const CLMicroLocationProto::RecordingEvent *)(a1 + 5));
  char v5 = (void **)a1 + 3;
  long long v17 = a1[14];
  char v18 = *((unsigned char *)a1 + 240);
  uint64_t v6 = *((void *)a2 + 2);
  *a1 = *a2;
  *((void *)a1 + 2) = v6;
  if (*((char *)a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v7 = *(long long *)((char *)a2 + 24);
  *((void *)a1 + 5) = *((void *)a2 + 5);
  *(_OWORD *)char v5 = v7;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  long long v8 = a2[3];
  *(long long *)((char *)a1 + 60) = *(long long *)((char *)a2 + 60);
  a1[3] = v8;
  CLMicroLocationProto::RecordingEvent::CopyFrom(v4, (const CLMicroLocationProto::RecordingEvent *)(a2 + 5));
  unint64_t v9 = (void **)a2 + 3;
  long long v10 = a2[14];
  *((unsigned char *)a1 + 240) = *((unsigned char *)a2 + 240);
  a1[14] = v10;
  *a2 = v11;
  *((void *)a2 + 2) = v12;
  if (*((char *)a2 + 47) < 0) {
    operator delete(*v9);
  }
  *(_OWORD *)unint64_t v9 = *(_OWORD *)__p;
  *((void *)a2 + 5) = v14;
  a2[3] = *(_OWORD *)v15;
  *(long long *)((char *)a2 + 60) = *(_OWORD *)&v15[12];
  CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a2 + 5), (const CLMicroLocationProto::RecordingEvent *)v16);
  a2[14] = v17;
  *((unsigned char *)a2 + 240) = v18;
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v16);
}

void sub_2563E7A98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a2, a3);
  unint64_t v8 = bswap64(*a4);
  unint64_t v9 = bswap64(*a3);
  if (v8 != v9 || (unint64_t v8 = bswap64(a4[1]), v9 = bswap64(a3[1]), v8 != v9))
  {
    int v10 = v8 < v9 ? -1 : 1;
    if (v10 < 0)
    {
      std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a3, (long long *)a4);
      unint64_t v11 = bswap64(*a3);
      unint64_t v12 = bswap64(*a2);
      if (v11 != v12 || (unint64_t v11 = bswap64(a3[1]), v12 = bswap64(a2[1]), v11 != v12))
      {
        int v13 = v11 < v12 ? -1 : 1;
        if (v13 < 0)
        {
          std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a2, (long long *)a3);
          unint64_t v14 = bswap64(*a2);
          unint64_t v15 = bswap64(*a1);
          if (v14 != v15 || (v14 = bswap64(a2[1]), unint64_t v15 = bswap64(a1[1]), v14 != v15))
          {
            int v16 = v14 < v15 ? -1 : 1;
            if (v16 < 0)
            {
              std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)a2);
            }
          }
        }
      }
    }
  }
}

uint64_t std::vector<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(48 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 48);
      *(void *)(v7 - 32) = *(void *)(a3 - 32);
      *(_OWORD *)(v7 - 48) = v8;
      *(void *)(a3 - 40) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(a3 - 48) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 - 24);
      *(void *)(v7 - 8) = *(void *)(a3 - 8);
      uint64_t v7 = *((void *)&v14 + 1) - 48;
      *((void *)&v14 + 1) -= 48;
      a3 -= 48;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>,std::reverse_iterator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 48;
  }
}

uint64_t std::__split_buffer<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 6;
      *(void *)(a1 + 16) = v2 - 6;
      if (*((char *)v2 - 25) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<CLMicroLocationRapportMonitor::Item>::__vdeallocate(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 80;
        std::allocator<CLMicroLocationRapportMonitor::Item>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::vector<CLMicroLocationConfigurationTable::Entry>::__emplace_back_slow_path<std::string const&,CLMicroLocationProto::Configuration &,boost::uuids::uuid const&>(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x249249249249249) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4) > v6) {
    unint64_t v6 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 4)) >= 0x124924924924924) {
    unint64_t v10 = 0x249249249249249;
  }
  else {
    unint64_t v10 = v6;
  }
  char v18 = a1 + 2;
  if (v10) {
    unint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>>((uint64_t)(a1 + 2), v10);
  }
  else {
    unint64_t v11 = 0;
  }
  long long v14 = v11;
  unint64_t v15 = &v11[112 * v5];
  long long v17 = &v11[112 * v10];
  std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,std::string const&,CLMicroLocationProto::Configuration &,boost::uuids::uuid const&>((uint64_t)(a1 + 2), (uint64_t)v15, a2, a3, a4);
  int v16 = v15 + 112;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__swap_out_circular_buffer(a1, &v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer(&v14);
  return v12;
}

void sub_2563E803C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,std::string const&,CLMicroLocationProto::Configuration &,boost::uuids::uuid const&>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string __p = *(std::string *)a3;
  }
  CLMicroLocationConfigurationTable::Entry::Entry(a2, &__p, a4, *a5, a5[1]);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2563E80D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<CLMicroLocationFingerprintConfiguration (*)(void),std::allocator<CLMicroLocationFingerprintConfiguration (*)(void)>,CLMicroLocationFingerprintConfiguration ()(void)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationFingerprintConfiguration (*)(void),std::allocator<CLMicroLocationFingerprintConfiguration (*)(void)>,CLMicroLocationFingerprintConfiguration ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_2704DD9E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationFingerprintConfiguration (*)(void),std::allocator<CLMicroLocationFingerprintConfiguration (*)(void)>,CLMicroLocationFingerprintConfiguration ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DD9E0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationFingerprintConfiguration (*)(void),std::allocator<CLMicroLocationFingerprintConfiguration (*)(void)>,CLMicroLocationFingerprintConfiguration ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 8))();
}

uint64_t std::__function::__func<CLMicroLocationFingerprintConfiguration (*)(void),std::allocator<CLMicroLocationFingerprintConfiguration (*)(void)>,CLMicroLocationFingerprintConfiguration ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationFingerprintConfiguration (*)(void),std::allocator<CLMicroLocationFingerprintConfiguration (*)(void)>,CLMicroLocationFingerprintConfiguration ()(void)>::target_type()
{
}

void *std::__function::__value_func<CLMicroLocationFingerprintConfiguration ()(void)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *,std::vector<CLMicroLocationRecordingEventsTable::Entry> &,std::function<BOOL ()(void)> const&,CLMicroLocationAnchorAppearanceMap const&,CLMicroLocationFingerprintPool &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::optional<CLMicroLocationModelTable::Entry> const&,CLMicroLocationProto::Model_ModelType)::$_0 &,CLMicroLocationRecordingEventsTable::Entry*,false>(unint64_t *a1, unint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v251 = *MEMORY[0x263EF8340];
LABEL_2:
  long long v8 = (long long *)a2;
  uint64_t v9 = a2 - 31;
  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = (char *)v8 - (char *)v10;
    unint64_t v12 = 0xEF7BDEF7BDEF7BDFLL * (((char *)v8 - (char *)v10) >> 3);
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unint64_t v102 = bswap64(*(a2 - 31));
          unint64_t v103 = bswap64(*a1);
          if (v102 != v103 || (unint64_t v102 = bswap64(*(a2 - 30)), v103 = bswap64(a1[1]), v102 != v103))
          {
            if (v102 < v103) {
              int v212 = -1;
            }
            else {
              int v212 = 1;
            }
            if (v212 < 0) {
              std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)(a2 - 31));
            }
          }
          break;
        case 3uLL:
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, v9);
          break;
        case 4uLL:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, a1 + 62, v9);
          break;
        case 5uLL:
          std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *,0>(a1, a1 + 31, a1 + 62, a1 + 93, v9);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 5951) {
      break;
    }
    if (!a3)
    {
      if (a1 != (unint64_t *)v8)
      {
        int64_t v127 = (v12 - 2) >> 1;
        int64_t v128 = v127;
        do
        {
          int64_t v129 = v128;
          if (v127 >= v128)
          {
            uint64_t v130 = (2 * v128) | 1;
            int v131 = &a1[31 * v130];
            if (2 * v128 + 2 < (uint64_t)v12)
            {
              unint64_t v132 = bswap64(*v131);
              unint64_t v133 = bswap64(v131[31]);
              if (v132 == v133 && (unint64_t v132 = bswap64(v131[1]), v133 = bswap64(v131[32]), v132 == v133)) {
                int v134 = 0;
              }
              else {
                int v134 = v132 < v133 ? -1 : 1;
              }
              if (v134 < 0)
              {
                v131 += 31;
                uint64_t v130 = 2 * v128 + 2;
              }
            }
            v135 = &a1[31 * v128];
            unint64_t v136 = bswap64(*v131);
            unint64_t v137 = bswap64(*v135);
            if (v136 == v137 && (unint64_t v136 = bswap64(v131[1]), v137 = bswap64(v135[1]), v136 == v137)
              || (v136 < v137 ? (int v138 = -1) : (int v138 = 1), (v138 & 0x80000000) == 0))
            {
              long long v139 = *(_OWORD *)v135;
              unint64_t v244 = v135[2];
              long long v243 = v139;
              long long v140 = &a1[31 * v129];
              long long v141 = *(_OWORD *)(v140 + 3);
              unint64_t v246 = v140[5];
              long long __p = v141;
              v140[4] = 0;
              v140[5] = 0;
              v140[3] = 0;
              long long v142 = *((_OWORD *)v140 + 3);
              *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)v140 + 60);
              v247[0] = v142;
              CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(v140 + 10));
              uint64_t v143 = &a1[31 * v129];
              long long v144 = *((_OWORD *)v143 + 14);
              char v250 = *((unsigned char *)v143 + 240);
              long long v249 = v144;
              do
              {
                unsigned int v145 = v131;
                long long v146 = *(_OWORD *)v131;
                v135[2] = v131[2];
                *(_OWORD *)v135 = v146;
                long long v147 = (void **)(v135 + 3);
                if (*((char *)v135 + 47) < 0) {
                  operator delete(*v147);
                }
                long long v148 = *(_OWORD *)(v145 + 3);
                v135[5] = v145[5];
                *(_OWORD *)long long v147 = v148;
                *((unsigned char *)v145 + 47) = 0;
                *((unsigned char *)v145 + 24) = 0;
                long long v149 = *((_OWORD *)v145 + 3);
                *(_OWORD *)((char *)v135 + 60) = *(_OWORD *)((char *)v145 + 60);
                *((_OWORD *)v135 + 3) = v149;
                CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v135 + 10), (const CLMicroLocationProto::RecordingEvent *)(v145 + 10));
                long long v150 = *((_OWORD *)v145 + 14);
                *((unsigned char *)v135 + 240) = *((unsigned char *)v145 + 240);
                *((_OWORD *)v135 + 14) = v150;
                if (v127 < v130) {
                  break;
                }
                int v131 = &a1[31 * ((2 * v130) | 1)];
                if (2 * v130 + 2 < (uint64_t)v12)
                {
                  unint64_t v151 = bswap64(*v131);
                  unint64_t v152 = bswap64(v131[31]);
                  if (v151 == v152 && (unint64_t v151 = bswap64(v131[1]), v152 = bswap64(v131[32]), v151 == v152)) {
                    int v153 = 0;
                  }
                  else {
                    int v153 = v151 < v152 ? -1 : 1;
                  }
                  if (v153 >= 0)
                  {
                    uint64_t v130 = (2 * v130) | 1;
                  }
                  else
                  {
                    v131 += 31;
                    uint64_t v130 = 2 * v130 + 2;
                  }
                }
                else
                {
                  uint64_t v130 = (2 * v130) | 1;
                }
                unint64_t v154 = bswap64(*v131);
                unint64_t v155 = bswap64(v243);
                if (v154 == v155
                  && (unint64_t v154 = bswap64(v131[1]), v155 = bswap64(*((unint64_t *)&v243 + 1)), v154 == v155))
                {
                  int v156 = 0;
                }
                else
                {
                  int v156 = v154 < v155 ? -1 : 1;
                }
                v135 = v145;
              }
              while ((v156 & 0x80000000) == 0);
              long long v157 = (void **)(v145 + 3);
              long long v158 = v243;
              v145[2] = v244;
              *(_OWORD *)unsigned int v145 = v158;
              if (*((char *)v145 + 47) < 0) {
                operator delete(*v157);
              }
              long long v159 = __p;
              v145[5] = v246;
              *(_OWORD *)long long v157 = v159;
              HIBYTE(v246) = 0;
              LOBYTE(__p) = 0;
              long long v160 = *(_OWORD *)((char *)v247 + 12);
              *((_OWORD *)v145 + 3) = v247[0];
              *(_OWORD *)((char *)v145 + 60) = v160;
              CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v145 + 10), (const CLMicroLocationProto::RecordingEvent *)v248);
              long long v161 = v249;
              *((unsigned char *)v145 + 240) = v250;
              *((_OWORD *)v145 + 14) = v161;
              CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
              if (SHIBYTE(v246) < 0) {
                operator delete((void *)__p);
              }
            }
          }
          int64_t v128 = v129 - 1;
        }
        while (v129);
        int64_t v162 = v11 / 0xF8uLL;
        v231 = (CLMicroLocationProto::RecordingEvent *)(a1 + 3);
        do
        {
          unint64_t v236 = a1[2];
          long long v235 = *(_OWORD *)a1;
          long long v237 = *(_OWORD *)v231;
          unint64_t v238 = a1[5];
          a1[4] = 0;
          a1[5] = 0;
          *(void *)v231 = 0;
          *(_OWORD *)v239 = *((_OWORD *)a1 + 3);
          *(_OWORD *)&v239[12] = *(_OWORD *)((char *)a1 + 60);
          CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v240, (const CLMicroLocationProto::RecordingEvent *)(a1 + 10));
          uint64_t v163 = 0;
          long long v164 = *((_OWORD *)a1 + 14);
          char v242 = *((unsigned char *)a1 + 240);
          long long v241 = v164;
          uint64_t v165 = (uint64_t)a1;
          do
          {
            uint64_t v166 = v165 + 248 * v163 + 248;
            uint64_t v167 = 2 * v163;
            uint64_t v163 = (2 * v163) | 1;
            if (v167 + 2 < v162)
            {
              unint64_t v168 = bswap64(*(void *)v166);
              unint64_t v169 = bswap64(*(void *)(v166 + 248));
              if (v168 == v169
                && (unint64_t v168 = bswap64(*(void *)(v166 + 8)), v169 = bswap64(*(void *)(v166 + 256)), v168 == v169))
              {
                int v170 = 0;
              }
              else
              {
                int v170 = v168 < v169 ? -1 : 1;
              }
              if (v170 < 0)
              {
                v166 += 248;
                uint64_t v163 = v167 + 2;
              }
            }
            long long v171 = *(_OWORD *)v166;
            *(void *)(v165 + 16) = *(void *)(v166 + 16);
            *(_OWORD *)uint64_t v165 = v171;
            unint64_t v172 = (void **)(v165 + 24);
            if (*(char *)(v165 + 47) < 0) {
              operator delete(*v172);
            }
            long long v173 = *(_OWORD *)(v166 + 24);
            *(void *)(v165 + 40) = *(void *)(v166 + 40);
            *(_OWORD *)unint64_t v172 = v173;
            *(unsigned char *)(v166 + 47) = 0;
            *(unsigned char *)(v166 + 24) = 0;
            long long v174 = *(_OWORD *)(v166 + 48);
            *(_OWORD *)(v165 + 60) = *(_OWORD *)(v166 + 60);
            *(_OWORD *)(v165 + 48) = v174;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v165 + 80), (const CLMicroLocationProto::RecordingEvent *)(v166 + 80));
            long long v175 = *(_OWORD *)(v166 + 224);
            *(unsigned char *)(v165 + 240) = *(unsigned char *)(v166 + 240);
            *(_OWORD *)(v165 + 224) = v175;
            uint64_t v165 = v166;
          }
          while (v163 <= (uint64_t)((unint64_t)(v162 - 2) >> 1));
          unsigned int v176 = (void **)(v166 + 24);
          __int16 v177 = (long long *)(v166 + 48);
          v233 = (CLMicroLocationProto::RecordingEvent *)(v166 + 224);
          if ((unint64_t *)v166 == a2 - 31)
          {
            *(void *)(v166 + 16) = v236;
            *(_OWORD *)uint64_t v166 = v235;
            if (*(char *)(v166 + 47) < 0) {
              operator delete(*v176);
            }
            *(void *)(v166 + 40) = v238;
            *(_OWORD *)unsigned int v176 = v237;
            *(_OWORD *)(v166 + 60) = *(_OWORD *)&v239[12];
            *__int16 v177 = *(_OWORD *)v239;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v166 + 80), (const CLMicroLocationProto::RecordingEvent *)v240);
            long long v191 = v241;
            *(unsigned char *)(v166 + 240) = v242;
            *(_OWORD *)v233 = v191;
          }
          else
          {
            long long v178 = *(_OWORD *)(a2 - 31);
            *(void *)(v166 + 16) = *(a2 - 29);
            *(_OWORD *)uint64_t v166 = v178;
            if (*(char *)(v166 + 47) < 0) {
              operator delete(*v176);
            }
            long long v179 = *((_OWORD *)a2 - 14);
            *(void *)(v166 + 40) = *(a2 - 26);
            *(_OWORD *)unsigned int v176 = v179;
            *((unsigned char *)a2 - 201) = 0;
            *((unsigned char *)a2 - 224) = 0;
            long long v180 = *(_OWORD *)(a2 - 25);
            *(_OWORD *)(v166 + 60) = *(_OWORD *)((char *)a2 - 188);
            *__int16 v177 = v180;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v166 + 80), (const CLMicroLocationProto::RecordingEvent *)(a2 - 21));
            uint64_t v181 = (void **)(a2 - 28);
            long long v182 = *(_OWORD *)(a2 - 3);
            *(unsigned char *)(v166 + 240) = *((unsigned char *)a2 - 8);
            *(_OWORD *)v233 = v182;
            *(a2 - 29) = v236;
            *(_OWORD *)(a2 - 31) = v235;
            if (*((char *)a2 - 201) < 0) {
              operator delete(*v181);
            }
            uint64_t v183 = a2 - 25;
            *(a2 - 26) = v238;
            *(_OWORD *)uint64_t v181 = v237;
            *(_OWORD *)((char *)v183 + 12) = *(_OWORD *)&v239[12];
            *(_OWORD *)uint64_t v183 = *(_OWORD *)v239;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a2 - 21), (const CLMicroLocationProto::RecordingEvent *)v240);
            uint64_t v184 = a2 - 3;
            long long v185 = v241;
            *((unsigned char *)v184 + 16) = v242;
            *(_OWORD *)uint64_t v184 = v185;
            uint64_t v186 = v166 - (void)a1 + 248;
            if (v186 >= 249)
            {
              unint64_t v187 = (v186 / 0xF8uLL - 2) >> 1;
              char v188 = &a1[31 * v187];
              unint64_t v189 = bswap64(*v188);
              unint64_t v190 = bswap64(*(void *)v166);
              if (v189 != v190 || (unint64_t v189 = bswap64(v188[1]), v190 = bswap64(*(void *)(v166 + 8)), v189 != v190))
              {
                int v192 = v189 < v190 ? -1 : 1;
                if (v192 < 0)
                {
                  long long v193 = *(_OWORD *)v166;
                  unint64_t v244 = *(void *)(v166 + 16);
                  long long v243 = v193;
                  long long v194 = *(_OWORD *)v176;
                  unint64_t v246 = *(void *)(v166 + 40);
                  long long __p = v194;
                  *(void *)(v166 + 32) = 0;
                  *(void *)(v166 + 40) = 0;
                  *unsigned int v176 = 0;
                  long long v195 = *v177;
                  *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)(v166 + 60);
                  v247[0] = v195;
                  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(v166 + 80));
                  long long v196 = *(_OWORD *)v233;
                  char v250 = *(unsigned char *)(v166 + 240);
                  long long v249 = v196;
                  do
                  {
                    uint64_t v197 = (uint64_t)v188;
                    long long v198 = *(_OWORD *)v188;
                    *(void *)(v166 + 16) = v188[2];
                    *(_OWORD *)uint64_t v166 = v198;
                    v199 = (void **)(v166 + 24);
                    if (*(char *)(v166 + 47) < 0) {
                      operator delete(*v199);
                    }
                    long long v200 = *(_OWORD *)(v188 + 3);
                    *(void *)(v166 + 40) = v188[5];
                    *(_OWORD *)v199 = v200;
                    *((unsigned char *)v188 + 47) = 0;
                    *((unsigned char *)v188 + 24) = 0;
                    long long v201 = *((_OWORD *)v188 + 3);
                    *(_OWORD *)(v166 + 60) = *(_OWORD *)((char *)v188 + 60);
                    *(_OWORD *)(v166 + 48) = v201;
                    CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v166 + 80), (const CLMicroLocationProto::RecordingEvent *)(v188 + 10));
                    long long v202 = *((_OWORD *)v188 + 14);
                    *(unsigned char *)(v166 + 240) = *((unsigned char *)v188 + 240);
                    *(_OWORD *)(v166 + 224) = v202;
                    if (!v187) {
                      break;
                    }
                    unint64_t v187 = (v187 - 1) >> 1;
                    char v188 = &a1[31 * v187];
                    unint64_t v203 = bswap64(*v188);
                    unint64_t v204 = bswap64(v243);
                    if (v203 == v204
                      && (unint64_t v203 = bswap64(v188[1]), v204 = bswap64(*((unint64_t *)&v243 + 1)), v203 == v204))
                    {
                      int v205 = 0;
                    }
                    else
                    {
                      int v205 = v203 < v204 ? -1 : 1;
                    }
                    uint64_t v166 = v197;
                  }
                  while (v205 < 0);
                  v206 = (void **)(v197 + 24);
                  long long v207 = v243;
                  *(void *)(v197 + 16) = v244;
                  *(_OWORD *)uint64_t v197 = v207;
                  if (*(char *)(v197 + 47) < 0) {
                    operator delete(*v206);
                  }
                  long long v208 = __p;
                  *(void *)(v197 + 40) = v246;
                  *(_OWORD *)v206 = v208;
                  HIBYTE(v246) = 0;
                  LOBYTE(__p) = 0;
                  long long v209 = *(_OWORD *)((char *)v247 + 12);
                  *(_OWORD *)(v197 + 48) = v247[0];
                  *(_OWORD *)(v197 + 60) = v209;
                  CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v197 + 80), (const CLMicroLocationProto::RecordingEvent *)v248);
                  long long v210 = v249;
                  *(unsigned char *)(v197 + 240) = v250;
                  *(_OWORD *)(v197 + 224) = v210;
                  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
                  if (SHIBYTE(v246) < 0) {
                    operator delete((void *)__p);
                  }
                }
              }
            }
          }
          CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v240);
          a2 -= 31;
        }
        while (v162-- > 2);
      }
      return;
    }
    unint64_t v13 = v12 >> 1;
    long long v14 = &a1[31 * (v12 >> 1)];
    if ((unint64_t)v11 >= 0x7C01)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, &a1[31 * (v12 >> 1)], v9);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1 + 31, &a1[31 * v13 - 31], a2 - 62);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1 + 62, &a1[31 * v13 + 31], a2 - 93);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(&a1[31 * v13 - 31], v14, &a1[31 * v13 + 31]);
      std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)v14);
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(&a1[31 * (v12 >> 1)], a1, v9);
    }
    --a3;
    if ((a4 & 1) == 0
      && ((unint64_t v15 = bswap64(*(a1 - 31)), v16 = bswap64(*a1), v15 == v16)
       && (unint64_t v15 = bswap64(*(a1 - 30)), v16 = bswap64(a1[1]), v15 == v16)
       || (v15 < v16 ? (int v24 = -1) : (int v24 = 1), (v24 & 0x80000000) == 0)))
    {
      long long v17 = *(_OWORD *)a1;
      unint64_t v244 = a1[2];
      long long v243 = v17;
      unint64_t v18 = a1[5];
      long long __p = *(_OWORD *)(a1 + 3);
      unint64_t v246 = v18;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      long long v19 = *(_OWORD *)((char *)a1 + 60);
      v247[0] = *((_OWORD *)a1 + 3);
      *(_OWORD *)((char *)v247 + 12) = v19;
      CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(a1 + 10));
      long long v20 = *((_OWORD *)a1 + 14);
      char v250 = *((unsigned char *)a1 + 240);
      long long v249 = v20;
      unint64_t v21 = bswap64(v243);
      unint64_t v22 = bswap64(*v9);
      if (v21 == v22 && (unint64_t v21 = bswap64(*((unint64_t *)&v243 + 1)), v22 = bswap64(*(a2 - 30)), v21 == v22))
      {
        int v23 = 0;
      }
      else if (v21 < v22)
      {
        int v23 = -1;
      }
      else
      {
        int v23 = 1;
      }
      if (v23 < 0)
      {
        unint64_t v70 = a1;
        unint64_t v10 = a1;
        do
        {
          unint64_t v71 = v10[31];
          v10 += 31;
          unint64_t v72 = bswap64(v243);
          unint64_t v73 = bswap64(v71);
          if (v72 == v73 && (unint64_t v72 = bswap64(*((unint64_t *)&v243 + 1)), v73 = bswap64(v70[32]), v72 == v73))
          {
            int v74 = 0;
          }
          else if (v72 < v73)
          {
            int v74 = -1;
          }
          else
          {
            int v74 = 1;
          }
          unint64_t v70 = v10;
        }
        while ((v74 & 0x80000000) == 0);
      }
      else
      {
        uint64_t v66 = a1 + 31;
        do
        {
          unint64_t v10 = v66;
          if (v66 >= (unint64_t *)v8) {
            break;
          }
          unint64_t v67 = bswap64(v243);
          unint64_t v68 = bswap64(*v10);
          if (v67 == v68 && (unint64_t v67 = bswap64(*((unint64_t *)&v243 + 1)), v68 = bswap64(v10[1]), v67 == v68)) {
            int v69 = 0;
          }
          else {
            int v69 = v67 < v68 ? -1 : 1;
          }
          uint64_t v66 = v10 + 31;
        }
        while ((v69 & 0x80000000) == 0);
      }
      uint64_t v75 = v8;
      if (v10 < (unint64_t *)v8)
      {
        unsigned __int8 v76 = v8;
        uint64_t v75 = v8;
        do
        {
          unint64_t v77 = *((void *)v75 - 31);
          uint64_t v75 = (long long *)((char *)v75 - 248);
          unint64_t v78 = bswap64(v243);
          unint64_t v79 = bswap64(v77);
          if (v78 == v79
            && (unint64_t v78 = bswap64(*((unint64_t *)&v243 + 1)), v79 = bswap64(*((void *)v76 - 30)), v78 == v79))
          {
            int v80 = 0;
          }
          else if (v78 < v79)
          {
            int v80 = -1;
          }
          else
          {
            int v80 = 1;
          }
          unsigned __int8 v76 = v75;
        }
        while (v80 < 0);
      }
      while (v10 < (unint64_t *)v75)
      {
        std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)v10, v75);
        unint64_t v81 = v10;
        do
        {
          unint64_t v82 = v10[31];
          v10 += 31;
          unint64_t v83 = bswap64(v243);
          unint64_t v84 = bswap64(v82);
          if (v83 == v84 && (unint64_t v83 = bswap64(*((unint64_t *)&v243 + 1)), v84 = bswap64(v81[32]), v83 == v84))
          {
            int v85 = 0;
          }
          else if (v83 < v84)
          {
            int v85 = -1;
          }
          else
          {
            int v85 = 1;
          }
          unint64_t v81 = v10;
        }
        while ((v85 & 0x80000000) == 0);
        unint64_t v86 = v75;
        do
        {
          unint64_t v87 = *((void *)v75 - 31);
          uint64_t v75 = (long long *)((char *)v75 - 248);
          unint64_t v88 = bswap64(v243);
          unint64_t v89 = bswap64(v87);
          if (v88 == v89
            && (unint64_t v88 = bswap64(*((unint64_t *)&v243 + 1)), v89 = bswap64(*((void *)v86 - 30)), v88 == v89))
          {
            int v90 = 0;
          }
          else if (v88 < v89)
          {
            int v90 = -1;
          }
          else
          {
            int v90 = 1;
          }
          unint64_t v86 = v75;
        }
        while (v90 < 0);
      }
      char v91 = v10 - 31;
      if (v10 - 31 != a1)
      {
        unint64_t v92 = (void **)(a1 + 3);
        long long v93 = *(_OWORD *)v91;
        a1[2] = *(v10 - 29);
        *(_OWORD *)a1 = v93;
        if (*((char *)a1 + 47) < 0) {
          operator delete(*v92);
        }
        long long v94 = *((_OWORD *)v10 - 14);
        a1[5] = *(v10 - 26);
        *(_OWORD *)unint64_t v92 = v94;
        *((unsigned char *)v10 - 201) = 0;
        *((unsigned char *)v10 - 224) = 0;
        long long v95 = *(_OWORD *)(v10 - 25);
        *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v10 - 188);
        *((_OWORD *)a1 + 3) = v95;
        CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a1 + 10), (const CLMicroLocationProto::RecordingEvent *)(v10 - 21));
        long long v96 = *(_OWORD *)(v10 - 3);
        *((unsigned char *)a1 + 240) = *((unsigned char *)v10 - 8);
        *((_OWORD *)a1 + 14) = v96;
      }
      long long v97 = v243;
      *(v10 - 29) = v244;
      *(_OWORD *)char v91 = v97;
      uint64_t v98 = (void **)(v10 - 28);
      if (*((char *)v10 - 201) < 0) {
        operator delete(*v98);
      }
      long long v99 = __p;
      *(v10 - 26) = v246;
      *(_OWORD *)uint64_t v98 = v99;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      long long v100 = v247[0];
      *(_OWORD *)((char *)v10 - 188) = *(_OWORD *)((char *)v247 + 12);
      *(_OWORD *)(v10 - 25) = v100;
      CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v10 - 21), (const CLMicroLocationProto::RecordingEvent *)v248);
      long long v101 = v249;
      *((unsigned char *)v10 - 8) = v250;
      *(_OWORD *)(v10 - 3) = v101;
      CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
LABEL_79:
      a4 = 0;
    }
    else
    {
      long long v25 = *(_OWORD *)a1;
      unint64_t v244 = a1[2];
      long long v243 = v25;
      unint64_t v26 = a1[5];
      long long __p = *(_OWORD *)(a1 + 3);
      unint64_t v246 = v26;
      a1[4] = 0;
      a1[5] = 0;
      a1[3] = 0;
      long long v27 = *(_OWORD *)((char *)a1 + 60);
      v247[0] = *((_OWORD *)a1 + 3);
      *(_OWORD *)((char *)v247 + 12) = v27;
      CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(a1 + 10));
      uint64_t v28 = 0;
      __n128 v29 = (void **)(a1 + 3);
      long long v30 = *((_OWORD *)a1 + 14);
      char v250 = *((unsigned char *)a1 + 240);
      long long v249 = v30;
      do
      {
        unint64_t v31 = bswap64(a1[v28 + 31]);
        unint64_t v32 = bswap64(v243);
        if (v31 == v32 && (unint64_t v31 = bswap64(a1[v28 + 32]), v32 = bswap64(*((unint64_t *)&v243 + 1)), v31 == v32))
        {
          int v33 = 0;
        }
        else if (v31 < v32)
        {
          int v33 = -1;
        }
        else
        {
          int v33 = 1;
        }
        v28 += 31;
      }
      while (v33 < 0);
      uint64_t v34 = &a1[v28];
      uint64_t v35 = v8;
      if (v28 == 31)
      {
        __n128 v40 = a2;
        while (v34 < v40)
        {
          long long v36 = (long long *)(v40 - 31);
          unint64_t v41 = bswap64(*(v40 - 31));
          unint64_t v42 = bswap64(v243);
          if (v41 == v42 && (unint64_t v41 = bswap64(*(v40 - 30)), v42 = bswap64(*((unint64_t *)&v243 + 1)), v41 == v42))
          {
            int v43 = 0;
          }
          else if (v41 < v42)
          {
            int v43 = -1;
          }
          else
          {
            int v43 = 1;
          }
          v40 -= 31;
          if (v43 < 0) {
            goto LABEL_47;
          }
        }
        long long v36 = (long long *)v40;
      }
      else
      {
        do
        {
          long long v36 = (long long *)((char *)v35 - 248);
          unint64_t v37 = bswap64(*((void *)v35 - 31));
          unint64_t v38 = bswap64(v243);
          if (v37 == v38
            && (v37 = bswap64(*((void *)v35 - 30)), unint64_t v38 = bswap64(*((unint64_t *)&v243 + 1)), v37 == v38))
          {
            int v39 = 0;
          }
          else if (v37 < v38)
          {
            int v39 = -1;
          }
          else
          {
            int v39 = 1;
          }
          uint64_t v35 = (long long *)((char *)v35 - 248);
        }
        while ((v39 & 0x80000000) == 0);
      }
LABEL_47:
      unint64_t v10 = v34;
      if (v34 < (unint64_t *)v36)
      {
        __n128 v44 = v36;
        do
        {
          std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)v10, v44);
          unint64_t v45 = v10;
          do
          {
            unint64_t v46 = v10[31];
            v10 += 31;
            unint64_t v47 = bswap64(v46);
            unint64_t v48 = bswap64(v243);
            if (v47 == v48 && (v47 = bswap64(v45[32]), unint64_t v48 = bswap64(*((unint64_t *)&v243 + 1)), v47 == v48))
            {
              int v49 = 0;
            }
            else if (v47 < v48)
            {
              int v49 = -1;
            }
            else
            {
              int v49 = 1;
            }
            unint64_t v45 = v10;
          }
          while (v49 < 0);
          unsigned __int8 v50 = v44;
          do
          {
            unint64_t v51 = *((void *)v44 - 31);
            __n128 v44 = (long long *)((char *)v44 - 248);
            unint64_t v52 = bswap64(v51);
            unint64_t v53 = bswap64(v243);
            if (v52 == v53
              && (unint64_t v52 = bswap64(*((void *)v50 - 30)), v53 = bswap64(*((unint64_t *)&v243 + 1)), v52 == v53))
            {
              int v54 = 0;
            }
            else if (v52 < v53)
            {
              int v54 = -1;
            }
            else
            {
              int v54 = 1;
            }
            unsigned __int8 v50 = v44;
          }
          while ((v54 & 0x80000000) == 0);
        }
        while (v10 < (unint64_t *)v44);
      }
      double v55 = v10 - 31;
      if (v10 - 31 != a1)
      {
        long long v56 = *(_OWORD *)v55;
        a1[2] = *(v10 - 29);
        *(_OWORD *)a1 = v56;
        if (*((char *)a1 + 47) < 0) {
          operator delete(*v29);
        }
        long long v57 = *((_OWORD *)v10 - 14);
        a1[5] = *(v10 - 26);
        *(_OWORD *)__n128 v29 = v57;
        *((unsigned char *)v10 - 201) = 0;
        *((unsigned char *)v10 - 224) = 0;
        long long v58 = *(_OWORD *)(v10 - 25);
        *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v10 - 188);
        *((_OWORD *)a1 + 3) = v58;
        CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a1 + 10), (const CLMicroLocationProto::RecordingEvent *)(v10 - 21));
        long long v59 = *(_OWORD *)(v10 - 3);
        *((unsigned char *)a1 + 240) = *((unsigned char *)v10 - 8);
        *((_OWORD *)a1 + 14) = v59;
      }
      long long v60 = v243;
      *(v10 - 29) = v244;
      *(_OWORD *)double v55 = v60;
      unint64_t v61 = (void **)(v10 - 28);
      if (*((char *)v10 - 201) < 0) {
        operator delete(*v61);
      }
      long long v62 = __p;
      *(v10 - 26) = v246;
      *(_OWORD *)unint64_t v61 = v62;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      long long v63 = v247[0];
      *(_OWORD *)((char *)v10 - 188) = *(_OWORD *)((char *)v247 + 12);
      *(_OWORD *)(v10 - 25) = v63;
      CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v10 - 21), (const CLMicroLocationProto::RecordingEvent *)v248);
      long long v64 = v249;
      *((unsigned char *)v10 - 8) = v250;
      *(_OWORD *)(v10 - 3) = v64;
      CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
      BOOL v4 = v34 >= (unint64_t *)v36;
      long long v8 = (long long *)a2;
      if (!v4) {
        goto LABEL_78;
      }
      BOOL v65 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *,std::vector<CLMicroLocationRecordingEventsTable::Entry> &,std::function<BOOL ()(void)> const&,CLMicroLocationAnchorAppearanceMap const&,CLMicroLocationFingerprintPool &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::optional<CLMicroLocationModelTable::Entry> const&,CLMicroLocationProto::Model_ModelType)::$_0 &,CLMicroLocationRecordingEventsTable::Entry*>(a1, v10 - 31);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *,std::vector<CLMicroLocationRecordingEventsTable::Entry> &,std::function<BOOL ()(void)> const&,CLMicroLocationAnchorAppearanceMap const&,CLMicroLocationFingerprintPool &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::optional<CLMicroLocationModelTable::Entry> const&,CLMicroLocationProto::Model_ModelType)::$_0 &,CLMicroLocationRecordingEventsTable::Entry*>(v10, a2))
      {
        a2 = v10 - 31;
        if (v65) {
          return;
        }
        goto LABEL_2;
      }
      if (!v65)
      {
LABEL_78:
        std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *,std::vector<CLMicroLocationRecordingEventsTable::Entry> &,std::function<BOOL ()(void)> const&,CLMicroLocationAnchorAppearanceMap const&,CLMicroLocationFingerprintPool &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::optional<CLMicroLocationModelTable::Entry> const&,CLMicroLocationProto::Model_ModelType)::$_0 &,CLMicroLocationRecordingEventsTable::Entry*,false>(a1, v10 - 31, a3, a4 & 1);
        goto LABEL_79;
      }
    }
  }
  if ((a4 & 1) == 0)
  {
    if (a1 == (unint64_t *)v8) {
      return;
    }
    v213 = a1 + 31;
    if (a1 + 31 == a2) {
      return;
    }
    for (uint64_t i = a1 - 31; ; i += 31)
    {
      v215 = v213;
      unint64_t v216 = bswap64(a1[31]);
      unint64_t v217 = bswap64(*a1);
      if (v216 != v217) {
        break;
      }
      unint64_t v216 = bswap64(v215[1]);
      unint64_t v217 = bswap64(a1[1]);
      v218 = a2;
      if (v216 != v217) {
        goto LABEL_280;
      }
LABEL_298:
      v213 = v215 + 31;
      a1 = v215;
      if (v215 + 31 == v218) {
        return;
      }
    }
    v218 = a2;
LABEL_280:
    if (v216 < v217) {
      int v219 = -1;
    }
    else {
      int v219 = 1;
    }
    if (v219 < 0)
    {
      long long v220 = *(_OWORD *)v215;
      unint64_t v244 = v215[2];
      long long v243 = v220;
      long long __p = *((_OWORD *)a1 + 17);
      unint64_t v246 = a1[36];
      a1[34] = 0;
      a1[35] = 0;
      a1[36] = 0;
      v247[0] = *(_OWORD *)(a1 + 37);
      *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)a1 + 308);
      CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248, (const CLMicroLocationProto::RecordingEvent *)(a1 + 41));
      char v250 = *((unsigned char *)a1 + 488);
      long long v249 = *(_OWORD *)(a1 + 59);
      v221 = i;
      do
      {
        *((_OWORD *)v221 + 31) = *(_OWORD *)(v221 + 31);
        v221[64] = v221[33];
        v222 = (void **)(v221 + 65);
        if (*((char *)v221 + 543) < 0) {
          operator delete(*v222);
        }
        *(_OWORD *)v222 = *((_OWORD *)v221 + 17);
        v221[67] = v221[36];
        *((unsigned char *)v221 + 295) = 0;
        *((unsigned char *)v221 + 272) = 0;
        *((_OWORD *)v221 + 34) = *(_OWORD *)(v221 + 37);
        *(_OWORD *)((char *)v221 + 556) = *(_OWORD *)((char *)v221 + 308);
        CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v221 + 72), (const CLMicroLocationProto::RecordingEvent *)(v221 + 41));
        *((unsigned char *)v221 + 736) = *((unsigned char *)v221 + 488);
        *((_OWORD *)v221 + 45) = *(_OWORD *)(v221 + 59);
        unint64_t v223 = bswap64(v243);
        unint64_t v224 = bswap64(*v221);
        if (v223 == v224 && (unint64_t v223 = bswap64(*((unint64_t *)&v243 + 1)), v224 = bswap64(v221[1]), v223 == v224))
        {
          int v225 = 0;
        }
        else if (v223 < v224)
        {
          int v225 = -1;
        }
        else
        {
          int v225 = 1;
        }
        v221 -= 31;
      }
      while (v225 < 0);
      long long v226 = v243;
      v221[64] = v244;
      *((_OWORD *)v221 + 31) = v226;
      v227 = (void **)(v221 + 65);
      if (*((char *)v221 + 543) < 0) {
        operator delete(*v227);
      }
      long long v228 = __p;
      v221[67] = v246;
      *(_OWORD *)v227 = v228;
      HIBYTE(v246) = 0;
      LOBYTE(__p) = 0;
      long long v229 = v247[0];
      *(_OWORD *)((char *)v221 + 556) = *(_OWORD *)((char *)v247 + 12);
      *((_OWORD *)v221 + 34) = v229;
      CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v221 + 72), (const CLMicroLocationProto::RecordingEvent *)v248);
      long long v230 = v249;
      *((unsigned char *)v221 + 736) = v250;
      *((_OWORD *)v221 + 45) = v230;
      CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v248);
      v218 = a2;
      if (SHIBYTE(v246) < 0) {
        operator delete((void *)__p);
      }
    }
    goto LABEL_298;
  }
  if (a1 != (unint64_t *)v8)
  {
    unint64_t v104 = a1 + 31;
    if (a1 + 31 != a2)
    {
      uint64_t v105 = 0;
      uint64_t v106 = (CLMicroLocationProto::RecordingEvent *)v248;
      long long v107 = a1;
      do
      {
        long long v108 = v104;
        unint64_t v109 = bswap64(v107[31]);
        unint64_t v110 = bswap64(*v107);
        if (v109 != v110 || (v109 = bswap64(v108[1]), unint64_t v110 = bswap64(v107[1]), v109 != v110))
        {
          int v111 = v109 < v110 ? -1 : 1;
          if (v111 < 0)
          {
            long long v112 = *(_OWORD *)v108;
            unint64_t v244 = v108[2];
            long long v243 = v112;
            long long __p = *((_OWORD *)v107 + 17);
            unint64_t v246 = v107[36];
            v107[34] = 0;
            v107[35] = 0;
            v107[36] = 0;
            v247[0] = *(_OWORD *)(v107 + 37);
            *(_OWORD *)((char *)v247 + 12) = *(_OWORD *)((char *)v107 + 308);
            uint64_t v113 = v106;
            CLMicroLocationProto::RecordingEvent::RecordingEvent(v106, (const CLMicroLocationProto::RecordingEvent *)(v107 + 41));
            char v250 = *((unsigned char *)v107 + 488);
            long long v249 = *(_OWORD *)(v107 + 59);
            uint64_t v114 = v105;
            while (1)
            {
              unint64_t v115 = (char *)a1 + v114;
              *(_OWORD *)(v115 + 248) = *(_OWORD *)((char *)a1 + v114);
              *((void *)v115 + 33) = *(unint64_t *)((char *)a1 + v114 + 16);
              double v116 = (void **)((char *)a1 + v114 + 272);
              if (*((char *)a1 + v114 + 295) < 0) {
                operator delete(*v116);
              }
              *(_OWORD *)double v116 = *(_OWORD *)(v115 + 24);
              *(unint64_t *)((char *)a1 + v114 + 288) = *((void *)v115 + 5);
              v115[47] = 0;
              v115[24] = 0;
              *(_OWORD *)(v115 + 296) = *((_OWORD *)v115 + 3);
              *(_OWORD *)(v115 + 308) = *(_OWORD *)(v115 + 60);
              CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v115 + 328), (const CLMicroLocationProto::RecordingEvent *)(v115 + 80));
              uint64_t v117 = (char *)a1 + v114;
              *(_OWORD *)((char *)a1 + v114 + 472) = *(_OWORD *)((char *)a1 + v114 + 224);
              *((unsigned char *)a1 + v114 + 488) = *((unsigned char *)a1 + v114 + 240);
              if (!v114) {
                break;
              }
              unint64_t v118 = bswap64(v243);
              unint64_t v119 = bswap64(*((void *)v117 - 31));
              if (v118 == v119
                && (unint64_t v118 = bswap64(*((unint64_t *)&v243 + 1)),
                    unint64_t v119 = bswap64(*((void *)v117 - 30)),
                    v118 == v119))
              {
                int v120 = 0;
              }
              else if (v118 < v119)
              {
                int v120 = -1;
              }
              else
              {
                int v120 = 1;
              }
              v114 -= 248;
              if ((v120 & 0x80000000) == 0)
              {
                uint64_t v121 = (uint64_t)a1 + v114 + 248;
                goto LABEL_169;
              }
            }
            uint64_t v121 = (uint64_t)a1;
LABEL_169:
            long long v122 = v243;
            *(void *)(v121 + 16) = v244;
            *(_OWORD *)uint64_t v121 = v122;
            uint64_t v123 = (void **)(v117 + 24);
            if (*(char *)(v121 + 47) < 0) {
              operator delete(*v123);
            }
            long long v124 = __p;
            *((void *)v117 + 5) = v246;
            *(_OWORD *)uint64_t v123 = v124;
            HIBYTE(v246) = 0;
            LOBYTE(__p) = 0;
            long long v125 = v247[0];
            *(_OWORD *)(v117 + 60) = *(_OWORD *)((char *)v247 + 12);
            *((_OWORD *)v117 + 3) = v125;
            uint64_t v106 = v113;
            CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v117 + 80), v113);
            long long v126 = v249;
            v117[240] = v250;
            *((_OWORD *)v117 + 14) = v126;
            CLMicroLocationProto::RecordingEvent::~RecordingEvent(v113);
            if (SHIBYTE(v246) < 0) {
              operator delete((void *)__p);
            }
          }
        }
        unint64_t v104 = v108 + 31;
        v105 += 248;
        long long v107 = v108;
      }
      while (v108 + 31 != a2);
    }
  }
}

void sub_2563E99F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, CLMicroLocationProto::RecordingEvent *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CLMicroLocationProto::RecordingEvent *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CLMicroLocationProto::RecordingEvent *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *__p,uint64_t a61,int a62,__int16 a63)
{
  if (a65 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *,std::vector<CLMicroLocationRecordingEventsTable::Entry> &,std::function<BOOL ()(void)> const&,CLMicroLocationAnchorAppearanceMap const&,CLMicroLocationFingerprintPool &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::optional<CLMicroLocationModelTable::Entry> const&,CLMicroLocationProto::Model_ModelType)::$_0 &,CLMicroLocationRecordingEventsTable::Entry*>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = a2;
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0xEF7BDEF7BDEF7BDFLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = bswap64(*(a2 - 31));
      unint64_t v7 = bswap64(*a1);
      if (v6 != v7 || (v6 = bswap64(*(a2 - 30)), unint64_t v7 = bswap64(a1[1]), v6 != v7))
      {
        int v28 = v6 < v7 ? -1 : 1;
        if (v28 < 0)
        {
          std::swap[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>((long long *)a1, (long long *)(a2 - 31));
          return 1;
        }
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, a2 - 31);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, a1 + 62, a2 - 31);
      return 1;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *,0>(a1, a1 + 31, a1 + 62, a1 + 93, a2 - 31);
      return 1;
    default:
      long long v8 = a1 + 62;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::semiSupervisedLearnWrapper(CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,std::vector<CLMicroLocationProto::EventType> const&,CLMicroLocationProto::Model_GenerationAlgorithm,NSMutableDictionary *,std::function<BOOL ()(void)>,CLMicroLocationFingerprintPool &,std::string const&,boost::uuids::uuid const&)::$_2 &,CLMicroLocationRecordingEventsTable::Entry *>(a1, a1 + 31, a1 + 62);
      uint64_t v9 = a1 + 93;
      if (a1 + 93 == v2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      unint64_t v12 = &v34;
      unint64_t v13 = (CLMicroLocationProto::RecordingEvent *)&v35;
      __n128 v29 = v2;
      break;
  }
  while (1)
  {
    unint64_t v14 = bswap64(*v9);
    unint64_t v15 = bswap64(*v8);
    if (v14 != v15 || (v14 = bswap64(v9[1]), unint64_t v15 = bswap64(v8[1]), v14 != v15))
    {
      int v16 = v14 < v15 ? -1 : 1;
      if (v16 < 0)
      {
        long long v30 = *(_OWORD *)v9;
        unint64_t v31 = v9[2];
        long long __p = *(_OWORD *)(v9 + 3);
        unint64_t v33 = v9[5];
        void v9[3] = 0;
        void v9[4] = 0;
        v9[5] = 0;
        *(_OWORD *)unint64_t v12 = *((_OWORD *)v9 + 3);
        long long v17 = v12;
        *(_OWORD *)((char *)v12 + 12) = *(_OWORD *)((char *)v9 + 60);
        unint64_t v18 = v13;
        CLMicroLocationProto::RecordingEvent::RecordingEvent(v13, (const CLMicroLocationProto::RecordingEvent *)(v9 + 10));
        long long v36 = *((_OWORD *)v9 + 14);
        char v37 = *((unsigned char *)v9 + 240);
        uint64_t v19 = v10;
        while (1)
        {
          long long v20 = (char *)a1 + v19;
          *(_OWORD *)((char *)a1 + v19 + 744) = *(_OWORD *)((char *)a1 + v19 + 496);
          *(unint64_t *)((char *)a1 + v19 + 760) = *(unint64_t *)((char *)a1 + v19 + 512);
          unint64_t v21 = (void **)((char *)a1 + v19 + 768);
          if (*((char *)a1 + v19 + 791) < 0) {
            operator delete(*v21);
          }
          *(unint64_t *)((char *)a1 + v19 + 784) = *((void *)v20 + 67);
          *(_OWORD *)unint64_t v21 = *(_OWORD *)(v20 + 520);
          v20[543] = 0;
          v20[520] = 0;
          *(_OWORD *)(v20 + 792) = *((_OWORD *)v20 + 34);
          *(_OWORD *)(v20 + 804) = *(_OWORD *)(v20 + 556);
          CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v20 + 824), (const CLMicroLocationProto::RecordingEvent *)(v20 + 576));
          unint64_t v22 = (char *)a1 + v19;
          *(_OWORD *)((char *)a1 + v19 + 968) = *(_OWORD *)((char *)a1 + v19 + 720);
          *((unsigned char *)a1 + v19 + 984) = *((unsigned char *)a1 + v19 + 736);
          if (v19 == -496) {
            break;
          }
          unint64_t v23 = bswap64(v30);
          unint64_t v24 = bswap64(*((void *)v22 + 31));
          if (v23 == v24
            && (v23 = bswap64(*((unint64_t *)&v30 + 1)), unint64_t v24 = bswap64(*((void *)v22 + 32)), v23 == v24))
          {
            int v25 = 0;
          }
          else if (v23 < v24)
          {
            int v25 = -1;
          }
          else
          {
            int v25 = 1;
          }
          v19 -= 248;
          if ((v25 & 0x80000000) == 0)
          {
            uint64_t v26 = (uint64_t)a1 + v19 + 744;
            goto LABEL_26;
          }
        }
        uint64_t v26 = (uint64_t)a1;
LABEL_26:
        *(_OWORD *)uint64_t v26 = v30;
        *(void *)(v26 + 16) = v31;
        long long v27 = (void **)(v22 + 520);
        if (*(char *)(v26 + 47) < 0) {
          operator delete(*v27);
        }
        *(_OWORD *)long long v27 = __p;
        *((void *)v22 + 67) = v33;
        unint64_t v12 = v17;
        *((_OWORD *)v22 + 34) = *(_OWORD *)v17;
        *(_OWORD *)(v22 + 556) = *(_OWORD *)((char *)v17 + 12);
        unint64_t v13 = v18;
        CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v22 + 576), v18);
        *((_OWORD *)v22 + 45) = v36;
        v22[736] = v37;
        CLMicroLocationProto::RecordingEvent::~RecordingEvent(v18);
        uint64_t v2 = v29;
        if (++v11 == 8) {
          return v9 + 31 == v29;
        }
      }
    }
    long long v8 = v9;
    v10 += 248;
    v9 += 31;
    if (v9 == v2) {
      return 1;
    }
  }
}

void sub_2563E9EF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
}

uint64_t std::__function::__value_func<CLMicroLocationFingerprintConfiguration ()(void)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__emplace_multi<std::pair<boost::uuids::uuid const,boost::uuids::uuid>>(void *a1, _OWORD *a2)
{
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__construct_node<std::pair<boost::uuids::uuid const,boost::uuids::uuid>>((uint64_t)a1, a2, (uint64_t)&v4);
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__node_insert_multi(a1, v4);
}

void sub_2563EA00C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__construct_node<std::pair<boost::uuids::uuid const,boost::uuids::uuid>>@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 16;
  BOOL result = operator new(0x30uLL);
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v5;
  *(void *)BOOL result = 0;
  long long v9 = a2[1];
  result[1] = *a2;
  result[2] = v9;
  *(unsigned char *)(a3 + 16) = 1;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)result + v7++ + 16);
  while (v7 != 16);
  *((void *)result + 1) = v8;
  return result;
}

uint64_t **std::back_insert_iterator<std::vector<CLMicroLocationRecordingEventsTable::Entry>>::operator=[abi:ne180100](uint64_t **a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = (*a1)[1];
  uint64_t v5 = *a1;
  unint64_t v7 = v5[2];
  uint64_t v6 = (uint64_t)(v5 + 2);
  if (v4 >= v7)
  {
    uint64_t v8 = std::vector<CLMicroLocationRecordingEventsTable::Entry>::__push_back_slow_path<CLMicroLocationRecordingEventsTable::Entry const&>(v3, a2);
  }
  else
  {
    std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry const&>(v6, v4, a2);
    uint64_t v8 = v4 + 248;
    v3[1] = v4 + 248;
  }
  v3[1] = v8;
  return a1;
}

void sub_2563EA120(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationRecordingEventsTable::Entry>::__push_back_slow_path<CLMicroLocationRecordingEventsTable::Entry const&>(uint64_t *a1, long long *a2)
{
  unint64_t v3 = 0xEF7BDEF7BDEF7BDFLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x108421084210842) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  if (0xDEF7BDEF7BDEF7BELL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0xDEF7BDEF7BDEF7BELL * ((a1[2] - *a1) >> 3);
  }
  if (0xEF7BDEF7BDEF7BDFLL * ((a1[2] - *a1) >> 3) >= 0x84210842108421) {
    unint64_t v6 = 0x108421084210842;
  }
  else {
    unint64_t v6 = v4;
  }
  unint64_t v14 = a1 + 2;
  if (v6) {
    unint64_t v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>>((uint64_t)(a1 + 2), v6);
  }
  else {
    unint64_t v7 = 0;
  }
  uint64_t v10 = v7;
  int v11 = &v7[248 * v3];
  unint64_t v13 = &v7[248 * v6];
  std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  unint64_t v12 = v11 + 248;
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__swap_out_circular_buffer(a1, &v10);
  uint64_t v8 = a1[1];
  std::__split_buffer<CLMicroLocationRecordingEventsTable::Entry>::~__split_buffer(&v10);
  return v8;
}

void sub_2563EA23C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationRecordingEventsTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

__n128 std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry const&>(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v5;
  unint64_t v6 = (std::string *)(a2 + 24);
  if (*((char *)a3 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *((const std::string::value_type **)a3 + 3), *((void *)a3 + 4));
  }
  else
  {
    long long v7 = *(long long *)((char *)a3 + 24);
    *(void *)(a2 + 40) = *((void *)a3 + 5);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  long long v8 = a3[3];
  *(_OWORD *)(a2 + 60) = *(long long *)((char *)a3 + 60);
  *(_OWORD *)(a2 + 48) = v8;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a2 + 80), (const CLMicroLocationProto::RecordingEvent *)(a3 + 5));
  __n128 result = (__n128)a3[14];
  *(unsigned char *)(a2 + 240) = *((unsigned char *)a3 + 240);
  *(__n128 *)(a2 + 224) = result;
  return result;
}

void sub_2563EA2E8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationRecordingEventsTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>>((uint64_t)(a1 + 2), a1[1], (long long *)a1[1], *a1, (long long *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x108421084210843) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(248 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>>(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, long long *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    long long v9 = a3;
    do
    {
      long long v9 = (long long *)((char *)v9 - 248);
      std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry const&>(a1, v7 - 248, v9);
      uint64_t v7 = *((void *)&v16 + 1) - 248;
      *((void *)&v16 + 1) -= 248;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_2563EA480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<CLMicroLocationRecordingEventsTable::Entry>::destroy[abi:ne180100](v3, v1);
      v1 += 248;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<CLMicroLocationRecordingEventsTable::Entry>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<CLMicroLocationRecordingEventsTable::Entry>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 248;
    std::allocator<CLMicroLocationRecordingEventsTable::Entry>::destroy[abi:ne180100](v4, i - 248);
  }
}

char *std::vector<boost::uuids::uuid>::__insert_with_size[abi:ne180100]<std::__hash_const_iterator<std::__hash_node<boost::uuids::uuid,void *> *>,std::__hash_const_iterator<std::__hash_node<boost::uuids::uuid,void *> *>>(uint64_t a1, char *__src, void *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = __src;
  if (a5 >= 1)
  {
    uint64_t v7 = a3;
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v9 = a1 + 16;
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 4)
    {
      unint64_t v19 = a5 + 1;
      long long v20 = a3;
      do
      {
        long long v20 = (void *)*v20;
        --v19;
      }
      while (v19 > 1);
      uint64_t v21 = (uint64_t)(v12 - (void)__src) >> 4;
      if (v21 >= a5)
      {
        unint64_t v23 = *(char **)(v9 - 8);
        uint64_t v21 = a5;
      }
      else
      {
        if ((uint64_t)(v12 - (void)__src) < 1)
        {
          long long v20 = a3;
        }
        else
        {
          unint64_t v22 = v21 + 1;
          long long v20 = a3;
          do
          {
            long long v20 = (void *)*v20;
            --v22;
          }
          while (v22 > 1);
        }
        unint64_t v23 = *(char **)(v9 - 8);
        if (v20 != a4)
        {
          long long v27 = v20;
          int v28 = *(_OWORD **)(v9 - 8);
          do
          {
            *v28++ = *((_OWORD *)v27 + 1);
            long long v27 = (void *)*v27;
            v23 += 16;
          }
          while (v27 != a4);
        }
        *(void *)(a1 + 8) = v23;
      }
      if (v21 >= 1)
      {
        __n128 v29 = &__src[16 * a5];
        long long v30 = &v23[-16 * a5];
        unint64_t v31 = v23;
        if ((unint64_t)v30 < v12)
        {
          unint64_t v31 = v23;
          do
          {
            long long v32 = *(_OWORD *)v30;
            v30 += 16;
            *(_OWORD *)unint64_t v31 = v32;
            v31 += 16;
          }
          while ((unint64_t)v30 < v12);
        }
        *(void *)(a1 + 8) = v31;
        if (v23 != v29) {
          memmove(&v23[-16 * ((v23 - v29) >> 4)], __src, v23 - v29);
        }
        if (v20 != v7)
        {
          unint64_t v33 = v5;
          do
          {
            *(_OWORD *)unint64_t v33 = *((_OWORD *)v7 + 1);
            v33 += 16;
            uint64_t v7 = (void *)*v7;
          }
          while (v7 != v20);
        }
      }
    }
    else
    {
      unint64_t v13 = *(unsigned char **)a1;
      unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
      if (v14 >> 60) {
        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v15 = (__src - v13) >> 4;
      uint64_t v16 = v10 - (void)v13;
      if (v16 >> 3 > v14) {
        unint64_t v14 = v16 >> 3;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v14;
      }
      uint64_t v39 = v9;
      if (v17) {
        unint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(v9, v17);
      }
      else {
        unint64_t v18 = 0;
      }
      unint64_t v24 = &v18[16 * v15];
      long long __p = v18;
      long long v36 = v24;
      uint64_t v38 = &v18[16 * v17];
      uint64_t v25 = 16 * a5;
      uint64_t v26 = &v24[16 * a5];
      do
      {
        *(_OWORD *)unint64_t v24 = *((_OWORD *)v7 + 1);
        v24 += 16;
        uint64_t v7 = (void *)*v7;
        v25 -= 16;
      }
      while (v25);
      char v37 = v26;
      uint64_t v5 = (char *)std::vector<boost::uuids::uuid>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
      if (v37 != v36) {
        v37 += (v36 - v37 + 15) & 0xFFFFFFFFFFFFFFF0;
      }
      if (__p) {
        operator delete(__p);
      }
    }
  }
  return v5;
}

void sub_2563EA7C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *,false>(unint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 5;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(double *)(v10 + 24) < a2[-1].n128_f64[1])
                {
                  __n128 v107 = *(__n128 *)v10;
                  __n128 v116 = *(__n128 *)(v10 + 16);
                  __n128 v44 = a2[-1];
                  *(__n128 *)unint64_t v10 = a2[-2];
                  *(__n128 *)(v10 + 16) = v44;
                  a2[-2] = v107;
                  a2[-1] = v116;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)v10, (double *)(v10 + 32), a2[-2].n128_f64);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((__n128 *)v10, (__n128 *)(v10 + 32), (__n128 *)(v10 + 64), a2 - 2);
                break;
              case 5uLL:
                unint64_t v45 = (__n128 *)(v10 + 32);
                unint64_t v46 = (__n128 *)(v10 + 64);
                unint64_t v47 = (__n128 *)(v10 + 96);
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((__n128 *)v10, (__n128 *)(v10 + 32), (__n128 *)(v10 + 64), (__n128 *)(v10 + 96));
                if (*(double *)(v10 + 120) < a2[-1].n128_f64[1])
                {
                  __n128 v48 = *v47;
                  __n128 v117 = *(__n128 *)(v10 + 112);
                  __n128 v49 = a2[-1];
                  __n128 *v47 = a2[-2];
                  *(__n128 *)(v10 + 112) = v49;
                  a2[-2] = v48;
                  a2[-1] = v117;
                  if (*(double *)(v10 + 88) < *(double *)(v10 + 120))
                  {
                    __n128 v51 = *v46;
                    long long v50 = *(_OWORD *)(v10 + 80);
                    long long v52 = *(_OWORD *)(v10 + 112);
                    *unint64_t v46 = *v47;
                    *(_OWORD *)(v10 + 80) = v52;
                    __n128 *v47 = v51;
                    *(_OWORD *)(v10 + 112) = v50;
                    if (*(double *)(v10 + 56) < *(double *)(v10 + 88))
                    {
                      __n128 v54 = *v45;
                      long long v53 = *(_OWORD *)(v10 + 48);
                      long long v55 = *(_OWORD *)(v10 + 80);
                      *unint64_t v45 = *v46;
                      *(_OWORD *)(v10 + 48) = v55;
                      *unint64_t v46 = v54;
                      *(_OWORD *)(v10 + 80) = v53;
                      if (*(double *)(v10 + 24) < *(double *)(v10 + 56))
                      {
                        __n128 v108 = *(__n128 *)v10;
                        long long v118 = *(_OWORD *)(v10 + 16);
                        long long v56 = *(_OWORD *)(v10 + 48);
                        *(__n128 *)unint64_t v10 = *v45;
                        *(_OWORD *)(v10 + 16) = v56;
                        *unint64_t v45 = v108;
                        *(_OWORD *)(v10 + 48) = v118;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 767)
          {
            long long v57 = (__n128 *)(v10 + 32);
            BOOL v59 = (__n128 *)v10 == a2 || v57 == a2;
            if (a4)
            {
              if (!v59)
              {
                uint64_t v60 = 0;
                unint64_t v61 = v10;
                do
                {
                  double v62 = *(double *)(v61 + 24);
                  double v63 = *(double *)(v61 + 56);
                  unint64_t v61 = (unint64_t)v57;
                  if (v62 < v63)
                  {
                    uint64_t v119 = v57[1].n128_i64[0];
                    __n128 v109 = *v57;
                    uint64_t v64 = v60;
                    while (1)
                    {
                      uint64_t v65 = v10 + v64;
                      long long v66 = *(_OWORD *)(v10 + v64 + 16);
                      *(_OWORD *)(v65 + 32) = *(_OWORD *)(v10 + v64);
                      *(_OWORD *)(v65 + 48) = v66;
                      if (!v64) {
                        break;
                      }
                      v64 -= 32;
                      if (*(double *)(v65 - 8) >= v63)
                      {
                        uint64_t v67 = v10 + v64 + 32;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v67 = v10;
LABEL_83:
                    *(void *)(v67 + 16) = v119;
                    *(__n128 *)uint64_t v67 = v109;
                    *(double *)(v67 + 24) = v63;
                  }
                  long long v57 = (__n128 *)(v61 + 32);
                  v60 += 32;
                }
                while ((__n128 *)(v61 + 32) != a2);
              }
            }
            else if (!v59)
            {
              do
              {
                double v93 = *(double *)(a1 + 24);
                double v94 = *(double *)(a1 + 56);
                a1 = (unint64_t)v57;
                if (v93 < v94)
                {
                  uint64_t v122 = v57[1].n128_i64[0];
                  __n128 v112 = *v57;
                  long long v95 = v57;
                  do
                  {
                    __n128 v96 = v95[-1];
                    *long long v95 = v95[-2];
                    v95[1] = v96;
                    double v97 = v95[-3].n128_f64[1];
                    v95 -= 2;
                  }
                  while (v97 < v94);
                  v95[1].n128_u64[0] = v122;
                  *long long v95 = v112;
                  v95[1].n128_f64[1] = v94;
                }
                v57 += 2;
              }
              while ((__n128 *)(a1 + 32) != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((__n128 *)v10 != a2)
            {
              int64_t v68 = (v12 - 2) >> 1;
              int64_t v69 = v68;
              do
              {
                int64_t v70 = v69;
                if (v68 >= v69)
                {
                  uint64_t v71 = (2 * v69) | 1;
                  unint64_t v72 = v10 + 32 * v71;
                  if (2 * v70 + 2 < (uint64_t)v12 && *(double *)(v72 + 56) < *(double *)(v72 + 24))
                  {
                    v72 += 32;
                    uint64_t v71 = 2 * v70 + 2;
                  }
                  double v73 = *(double *)(v10 + 32 * v70 + 24);
                  if (v73 >= *(double *)(v72 + 24))
                  {
                    unint64_t v74 = v10 + 32 * v70;
                    uint64_t v120 = *(void *)(v74 + 16);
                    long long v110 = *(_OWORD *)v74;
                    do
                    {
                      uint64_t v75 = (_OWORD *)v74;
                      unint64_t v74 = v72;
                      long long v76 = *(_OWORD *)(v72 + 16);
                      _OWORD *v75 = *(_OWORD *)v72;
                      v75[1] = v76;
                      if (v68 < v71) {
                        break;
                      }
                      uint64_t v77 = 2 * v71;
                      uint64_t v71 = (2 * v71) | 1;
                      unint64_t v72 = v10 + 32 * v71;
                      uint64_t v78 = v77 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v72 + 56) < *(double *)(v72 + 24))
                      {
                        v72 += 32;
                        uint64_t v71 = v78;
                      }
                    }
                    while (v73 >= *(double *)(v72 + 24));
                    *(void *)(v74 + 16) = v120;
                    *(_OWORD *)unint64_t v74 = v110;
                    *(double *)(v74 + 24) = v73;
                  }
                }
                int64_t v69 = v70 - 1;
              }
              while (v70);
              uint64_t v79 = (unint64_t)v11 >> 5;
              do
              {
                uint64_t v80 = 0;
                __n128 v111 = *(__n128 *)v10;
                __n128 v121 = *(__n128 *)(v10 + 16);
                unint64_t v81 = v10;
                do
                {
                  unint64_t v82 = (_OWORD *)v81;
                  v81 += 32 * (v80 + 1);
                  uint64_t v83 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  uint64_t v84 = v83 + 2;
                  if (v84 < v79 && *(double *)(v81 + 56) < *(double *)(v81 + 24))
                  {
                    v81 += 32;
                    uint64_t v80 = v84;
                  }
                  long long v85 = *(_OWORD *)(v81 + 16);
                  *unint64_t v82 = *(_OWORD *)v81;
                  v82[1] = v85;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 2;
                if ((__n128 *)v81 == a2)
                {
                  *(__n128 *)unint64_t v81 = v111;
                  *(__n128 *)(v81 + 16) = v121;
                }
                else
                {
                  __n128 v86 = a2[1];
                  *(__n128 *)unint64_t v81 = *a2;
                  *(__n128 *)(v81 + 16) = v86;
                  *a2 = v111;
                  a2[1] = v121;
                  uint64_t v87 = v81 - v10 + 32;
                  if (v87 >= 33)
                  {
                    unint64_t v88 = (((unint64_t)v87 >> 5) - 2) >> 1;
                    double v89 = *(double *)(v81 + 24);
                    if (v89 < *(double *)(v10 + 32 * v88 + 24))
                    {
                      uint64_t v103 = *(void *)(v81 + 16);
                      long long v100 = *(_OWORD *)v81;
                      do
                      {
                        int v90 = (_OWORD *)v81;
                        unint64_t v81 = v10 + 32 * v88;
                        long long v91 = *(_OWORD *)(v81 + 16);
                        _OWORD *v90 = *(_OWORD *)v81;
                        v90[1] = v91;
                        if (!v88) {
                          break;
                        }
                        unint64_t v88 = (v88 - 1) >> 1;
                      }
                      while (v89 < *(double *)(v10 + 32 * v88 + 24));
                      *(void *)(v81 + 16) = v103;
                      *(_OWORD *)unint64_t v81 = v100;
                      *(double *)(v81 + 24) = v89;
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 32 * (v12 >> 1);
          if ((unint64_t)v11 > 0x1000)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)a1, (double *)(a1 + 32 * (v12 >> 1)), a2[-2].n128_f64);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)(a1 + 32), (double *)(v14 - 32), a2[-4].n128_f64);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)(a1 + 64), (double *)(a1 + 32 + 32 * v13), a2[-6].n128_f64);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)(v14 - 32), (double *)v14, (double *)(a1 + 32 + 32 * v13));
            long long v104 = *(_OWORD *)a1;
            long long v113 = *(_OWORD *)(a1 + 16);
            long long v15 = *(_OWORD *)(v14 + 16);
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(_OWORD *)(a1 + 16) = v15;
            *(_OWORD *)unint64_t v14 = v104;
            *(_OWORD *)(v14 + 16) = v113;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)(a1 + 32 * (v12 >> 1)), (double *)a1, a2[-2].n128_f64);
          }
          --a3;
          if (a4) {
            break;
          }
          double v16 = *(double *)(a1 + 24);
          if (v16 < *(double *)(a1 - 8)) {
            goto LABEL_12;
          }
          uint64_t v102 = *(void *)(a1 + 16);
          long long v99 = *(_OWORD *)a1;
          if (a2[-1].n128_f64[1] >= v16)
          {
            unint64_t v34 = a1 + 32;
            do
            {
              unint64_t v10 = v34;
              if (v34 >= (unint64_t)a2) {
                break;
              }
              double v35 = *(double *)(v34 + 24);
              v34 += 32;
            }
            while (v35 >= v16);
          }
          else
          {
            unint64_t v32 = a1;
            do
            {
              unint64_t v10 = v32 + 32;
              double v33 = *(double *)(v32 + 56);
              v32 += 32;
            }
            while (v33 >= v16);
          }
          long long v36 = a2;
          if (v10 < (unint64_t)a2)
          {
            char v37 = a2;
            do
            {
              long long v36 = v37 - 2;
              double v38 = v37[-1].n128_f64[1];
              v37 -= 2;
            }
            while (v38 < v16);
          }
          while (v10 < (unint64_t)v36)
          {
            __n128 v106 = *(__n128 *)v10;
            __n128 v115 = *(__n128 *)(v10 + 16);
            __n128 v39 = v36[1];
            *(__n128 *)unint64_t v10 = *v36;
            *(__n128 *)(v10 + 16) = v39;
            *long long v36 = v106;
            v36[1] = v115;
            do
            {
              double v40 = *(double *)(v10 + 56);
              v10 += 32;
            }
            while (v40 >= v16);
            do
            {
              double v41 = v36[-1].n128_f64[1];
              v36 -= 2;
            }
            while (v41 < v16);
          }
          unint64_t v42 = (_OWORD *)(v10 - 32);
          BOOL v4 = v10 - 32 >= a1;
          BOOL v5 = v10 - 32 == a1;
          if (v10 - 32 != a1)
          {
            long long v43 = *(_OWORD *)(v10 - 16);
            *(_OWORD *)a1 = *v42;
            *(_OWORD *)(a1 + 16) = v43;
          }
          a4 = 0;
          *(void *)(v10 - 16) = v102;
          *unint64_t v42 = v99;
          *(double *)(v10 - 8) = v16;
        }
        double v16 = *(double *)(a1 + 24);
LABEL_12:
        uint64_t v17 = 0;
        uint64_t v101 = *(void *)(a1 + 16);
        long long v98 = *(_OWORD *)a1;
        do
        {
          double v18 = *(double *)(a1 + v17 + 56);
          v17 += 32;
        }
        while (v16 < v18);
        unint64_t v19 = a1 + v17;
        long long v20 = a2;
        if (v17 == 32)
        {
          unint64_t v23 = a2;
          while (v19 < (unint64_t)v23)
          {
            uint64_t v21 = v23 - 2;
            double v24 = v23[-1].n128_f64[1];
            v23 -= 2;
            if (v16 < v24) {
              goto LABEL_22;
            }
          }
          uint64_t v21 = v23;
        }
        else
        {
          do
          {
            uint64_t v21 = v20 - 2;
            double v22 = v20[-1].n128_f64[1];
            v20 -= 2;
          }
          while (v16 >= v22);
        }
LABEL_22:
        unint64_t v10 = v19;
        if (v19 < (unint64_t)v21)
        {
          uint64_t v25 = v21;
          do
          {
            __n128 v105 = *(__n128 *)v10;
            __n128 v114 = *(__n128 *)(v10 + 16);
            __n128 v26 = v25[1];
            *(__n128 *)unint64_t v10 = *v25;
            *(__n128 *)(v10 + 16) = v26;
            *uint64_t v25 = v105;
            v25[1] = v114;
            do
            {
              double v27 = *(double *)(v10 + 56);
              v10 += 32;
            }
            while (v16 < v27);
            do
            {
              double v28 = v25[-1].n128_f64[1];
              v25 -= 2;
            }
            while (v16 >= v28);
          }
          while (v10 < (unint64_t)v25);
        }
        __n128 v29 = (_OWORD *)(v10 - 32);
        if (v10 - 32 != a1)
        {
          long long v30 = *(_OWORD *)(v10 - 16);
          *(_OWORD *)a1 = *v29;
          *(_OWORD *)(a1 + 16) = v30;
        }
        *(void *)(v10 - 16) = v101;
        _OWORD *v29 = v98;
        *(double *)(v10 - 8) = v16;
        if (v19 >= (unint64_t)v21) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *,false>(a1, v10 - 32, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v31 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>(a1, v10 - 32);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v31) {
        goto LABEL_33;
      }
    }
    a2 = (__n128 *)(v10 - 32);
    if (!v31) {
      continue;
    }
    break;
  }
}

double *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>(double *result, double *a2, double *a3)
{
  double v3 = a2[3];
  double v4 = a3[3];
  if (result[3] >= v3)
  {
    if (v3 < v4)
    {
      long long v9 = *(_OWORD *)a2;
      long long v8 = *((_OWORD *)a2 + 1);
      long long v10 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v10;
      *(_OWORD *)a3 = v9;
      *((_OWORD *)a3 + 1) = v8;
      if (result[3] < a2[3])
      {
        long long v12 = *(_OWORD *)result;
        long long v11 = *((_OWORD *)result + 1);
        long long v13 = *((_OWORD *)a2 + 1);
        *(_OWORD *)uint64_t result = *(_OWORD *)a2;
        *((_OWORD *)result + 1) = v13;
        *(_OWORD *)a2 = v12;
        *((_OWORD *)a2 + 1) = v11;
      }
    }
  }
  else
  {
    if (v3 >= v4)
    {
      long long v15 = *(_OWORD *)result;
      long long v14 = *((_OWORD *)result + 1);
      long long v16 = *((_OWORD *)a2 + 1);
      *(_OWORD *)uint64_t result = *(_OWORD *)a2;
      *((_OWORD *)result + 1) = v16;
      *(_OWORD *)a2 = v15;
      *((_OWORD *)a2 + 1) = v14;
      if (a2[3] >= a3[3]) {
        return result;
      }
      long long v6 = *(_OWORD *)a2;
      long long v5 = *((_OWORD *)a2 + 1);
      long long v17 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v17;
    }
    else
    {
      long long v6 = *(_OWORD *)result;
      long long v5 = *((_OWORD *)result + 1);
      long long v7 = *((_OWORD *)a3 + 1);
      *(_OWORD *)uint64_t result = *(_OWORD *)a3;
      *((_OWORD *)result + 1) = v7;
    }
    *(_OWORD *)a3 = v6;
    *((_OWORD *)a3 + 1) = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(double *)(a1 + 24) < *(double *)(a2 - 8))
      {
        __n128 v7 = *(__n128 *)a1;
        long long v6 = *(_OWORD *)(a1 + 16);
        long long v8 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a1 + 16) = v8;
        *(__n128 *)(a2 - 32) = v7;
        *(_OWORD *)(a2 - 16) = v6;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)a1, (double *)(a1 + 32), (double *)(a2 - 32));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a2 - 32));
      return 1;
    case 5:
      double v18 = (__n128 *)(a1 + 32);
      unint64_t v19 = (__n128 *)(a1 + 64);
      long long v20 = (__n128 *)(a1 + 96);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a1 + 96));
      if (*(double *)(a1 + 120) < *(double *)(a2 - 8))
      {
        __n128 v22 = *v20;
        long long v21 = *(_OWORD *)(a1 + 112);
        long long v23 = *(_OWORD *)(a2 - 16);
        *long long v20 = *(__n128 *)(a2 - 32);
        *(_OWORD *)(a1 + 112) = v23;
        *(__n128 *)(a2 - 32) = v22;
        *(_OWORD *)(a2 - 16) = v21;
        if (*(double *)(a1 + 88) < *(double *)(a1 + 120))
        {
          __n128 v25 = *v19;
          long long v24 = *(_OWORD *)(a1 + 80);
          long long v26 = *(_OWORD *)(a1 + 112);
          *unint64_t v19 = *v20;
          *(_OWORD *)(a1 + 80) = v26;
          *long long v20 = v25;
          *(_OWORD *)(a1 + 112) = v24;
          if (*(double *)(a1 + 56) < *(double *)(a1 + 88))
          {
            __n128 v28 = *v18;
            long long v27 = *(_OWORD *)(a1 + 48);
            long long v29 = *(_OWORD *)(a1 + 80);
            __n128 *v18 = *v19;
            *(_OWORD *)(a1 + 48) = v29;
            *unint64_t v19 = v28;
            *(_OWORD *)(a1 + 80) = v27;
            if (*(double *)(a1 + 24) < *(double *)(a1 + 56))
            {
              __n128 v31 = *(__n128 *)a1;
              long long v30 = *(_OWORD *)(a1 + 16);
              long long v32 = *(_OWORD *)(a1 + 48);
              *(__n128 *)a1 = *v18;
              *(_OWORD *)(a1 + 16) = v32;
              __n128 *v18 = v31;
              *(_OWORD *)(a1 + 48) = v30;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v9 = a1 + 64;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)a1, (double *)(a1 + 32), (double *)(a1 + 64));
      uint64_t v10 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    double v13 = *(double *)(v10 + 24);
    if (*(double *)(v9 + 24) < v13)
    {
      long long v33 = *(_OWORD *)v10;
      uint64_t v34 = *(void *)(v10 + 16);
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = a1 + v14;
        long long v16 = *(_OWORD *)(a1 + v14 + 80);
        *(_OWORD *)(v15 + 96) = *(_OWORD *)(a1 + v14 + 64);
        *(_OWORD *)(v15 + 112) = v16;
        if (v14 == -64) {
          break;
        }
        v14 -= 32;
        if (*(double *)(v15 + 56) >= v13)
        {
          uint64_t v17 = a1 + v14 + 96;
          goto LABEL_12;
        }
      }
      uint64_t v17 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v17 = v33;
      *(void *)(v17 + 16) = v34;
      *(double *)(v17 + 24) = v13;
      if (++v12 == 8) {
        return v10 + 32 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 32;
    v10 += 32;
    if (v10 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>(a1->n128_f64, a2->n128_f64, a3->n128_f64);
  result.n128_u64[0] = a3[1].n128_u64[1];
  if (result.n128_f64[0] < a4[1].n128_f64[1])
  {
    __n128 v9 = *a3;
    __n128 result = a3[1];
    __n128 v10 = a4[1];
    *a3 = *a4;
    a3[1] = v10;
    *a4 = v9;
    a4[1] = result;
    result.n128_u64[0] = a2[1].n128_u64[1];
    if (result.n128_f64[0] < a3[1].n128_f64[1])
    {
      __n128 v11 = *a2;
      __n128 result = a2[1];
      __n128 v12 = a3[1];
      *a2 = *a3;
      a2[1] = v12;
      *a3 = v11;
      a3[1] = result;
      result.n128_u64[0] = a1[1].n128_u64[1];
      if (result.n128_f64[0] < a2[1].n128_f64[1])
      {
        __n128 v13 = *a1;
        __n128 result = a1[1];
        __n128 v14 = a2[1];
        *a1 = *a2;
        a1[1] = v14;
        *a2 = v13;
        a2[1] = result;
      }
    }
  }
  return result;
}

void ***std::back_insert_iterator<std::vector<CLMicroLocationModel::SimilarityListData::EventInformation>>::operator=[abi:ne180100](void ***a1, long long *a2)
{
  uint64_t v4 = *a1;
  long long v5 = (char *)(*a1)[1];
  long long v6 = *a1;
  __n128 v9 = (char *)v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  long long v8 = v9;
  if (v5 >= v9)
  {
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (unsigned char *)*v4) >> 2);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0xCCCCCCCCCCCCCCCLL) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - (unsigned char *)*v4) >> 2);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x666666666666666) {
      unint64_t v15 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      long long v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModel::SimilarityListData::EventInformation>>(v7, v15);
    }
    else {
      long long v16 = 0;
    }
    uint64_t v17 = &v16[20 * v12];
    double v18 = &v16[20 * v15];
    long long v19 = *a2;
    *((_DWORD *)v17 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)uint64_t v17 = v19;
    __n128 v11 = v17 + 20;
    long long v21 = (char *)*v4;
    long long v20 = (char *)v4[1];
    if (v20 != *v4)
    {
      do
      {
        long long v22 = *(_OWORD *)(v20 - 20);
        *((_DWORD *)v17 - 1) = *((_DWORD *)v20 - 1);
        *(_OWORD *)(v17 - 20) = v22;
        v17 -= 20;
        v20 -= 20;
      }
      while (v20 != v21);
      long long v20 = (char *)*v4;
    }
    *uint64_t v4 = v17;
    v4[1] = v11;
    v4[2] = v18;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    long long v10 = *a2;
    *((_DWORD *)v5 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)long long v5 = v10;
    __n128 v11 = v5 + 20;
  }
  v4[1] = v11;
  return a1;
}

void *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,int>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,int>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,int>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,int>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,int>>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
    long long v10 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v10)
    {
      __n128 v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1]) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3) {
              break;
            }
          }
          __n128 v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  __n128 v11 = operator new(0x28uLL);
  *__n128 v11 = 0;
  v11[1] = v7;
  *((_OWORD *)v11 + 1) = *(_OWORD *)a3;
  *((_DWORD *)v11 + 8) = *(_DWORD *)(a3 + 16);
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
      else {
        unint64_t v3 = v7;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  long long v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *__n128 v11 = *v21;
LABEL_44:
    void *v21 = v11;
    goto LABEL_45;
  }
  *__n128 v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    unint64_t v22 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    long long v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_2563EB85C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

long long *std::vector<CLMicroLocationRecordingEventsTable::Entry>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationRecordingEventsTable::Entry*>,std::__wrap_iter<CLMicroLocationRecordingEventsTable::Entry*>>(uint64_t *a1, long long *a2, long long *a3, long long *a4, uint64_t a5)
{
  long long v5 = a2;
  if (a5 >= 1)
  {
    unint64_t v7 = a3;
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xEF7BDEF7BDEF7BDFLL * ((uint64_t)(v11 - v12) >> 3)) >= a5)
    {
      uint64_t v20 = v12 - (void)a2;
      if ((uint64_t)(0xEF7BDEF7BDEF7BDFLL * ((uint64_t)(v12 - (void)a2) >> 3)) >= a5)
      {
        long long v21 = (long long *)((char *)a3 + 248 * a5);
      }
      else
      {
        long long v21 = (long long *)((char *)a3 + 8 * ((uint64_t)(v12 - (void)a2) >> 3));
        a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*,CLMicroLocationRecordingEventsTable::Entry*,CLMicroLocationRecordingEventsTable::Entry*>(v9, v21, a4, *(void *)(v9 - 8));
        if (v20 < 1) {
          return v5;
        }
      }
      std::vector<CLMicroLocationRecordingEventsTable::Entry>::__move_range((uint64_t)a1, (uint64_t)v5, v12, (uint64_t)v5 + 248 * a5);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *>((uint64_t)v26, v7, v21, (uint64_t)v5);
    }
    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0x1084210842108421 * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0x108421084210842) {
        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v15 = 0xEF7BDEF7BDEF7BDFLL * (((uint64_t)a2 - v13) >> 3);
      unint64_t v16 = 0xEF7BDEF7BDEF7BDFLL * ((v10 - v13) >> 3);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = v14;
      }
      if (v16 >= 0x84210842108421) {
        unint64_t v18 = 0x108421084210842;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v29 = v9;
      if (v18) {
        size_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>>(v9, v18);
      }
      else {
        size_t v19 = 0;
      }
      unint64_t v22 = &v19[248 * v15];
      v26[0] = v19;
      v26[1] = v22;
      long long v27 = v22;
      __n128 v28 = &v19[248 * v18];
      uint64_t v23 = 248 * a5;
      long long v24 = &v22[248 * a5];
      do
      {
        std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry&>(v29, (uint64_t)v22, v7);
        v22 += 248;
        unint64_t v7 = (long long *)((char *)v7 + 248);
        v23 -= 248;
      }
      while (v23);
      long long v27 = v24;
      long long v5 = (long long *)std::vector<CLMicroLocationRecordingEventsTable::Entry>::__swap_out_circular_buffer((uint64_t)a1, v26, v5);
      std::__split_buffer<CLMicroLocationRecordingEventsTable::Entry>::~__split_buffer(v26);
    }
  }
  return v5;
}

void sub_2563EBA58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationRecordingEventsTable::Entry>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    uint64_t v10 = (long long *)(a2 + v6 - a4);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry>(a1 + 16, v8, v10);
      uint64_t v10 = (long long *)((char *)v10 + 248);
      v8 += 248;
    }
    while ((unint64_t)v10 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *>((uint64_t)&v12, a2, v7, v6);
}

void sub_2563EBB28(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationRecordingEventsTable::Entry>::__swap_out_circular_buffer(uint64_t a1, void *a2, long long *a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = a1 + 16;
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingEventsTable::Entry*>>(a1 + 16, (uint64_t)a3, a3, *(void *)a1, *(long long **)a1, v6, v6);
  a2[1] = v8;
  a2[2] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*,CLMicroLocationRecordingEventsTable::Entry*,CLMicroLocationRecordingEventsTable::Entry*>(v7, a3, *(long long **)(a1 + 8), a2[2]);
  uint64_t v9 = *(void *)a1;
  *(void *)a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[2];
  a2[2] = v10;
  uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*,CLMicroLocationRecordingEventsTable::Entry*,CLMicroLocationRecordingEventsTable::Entry*>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry&>(a1, v4, v6);
      uint64_t v6 = (long long *)((char *)v6 + 248);
      uint64_t v4 = v12 + 248;
      v12 += 248;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_2563EBC7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__n128 std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry&>(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v5;
  uint64_t v6 = (std::string *)(a2 + 24);
  if (*((char *)a3 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *((const std::string::value_type **)a3 + 3), *((void *)a3 + 4));
  }
  else
  {
    long long v7 = *(long long *)((char *)a3 + 24);
    *(void *)(a2 + 40) = *((void *)a3 + 5);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  long long v8 = a3[3];
  *(_OWORD *)(a2 + 60) = *(long long *)((char *)a3 + 60);
  *(_OWORD *)(a2 + 48) = v8;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a2 + 80), (const CLMicroLocationProto::RecordingEvent *)(a3 + 5));
  __n128 result = (__n128)a3[14];
  *(unsigned char *)(a2 + 240) = *((unsigned char *)a3 + 240);
  *(__n128 *)(a2 + 224) = result;
  return result;
}

void sub_2563EBD28(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 248;
      std::allocator<CLMicroLocationRecordingEventsTable::Entry>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
}

__n128 std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry>(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v5;
  long long v6 = *(long long *)((char *)a3 + 24);
  *(void *)(a2 + 40) = *((void *)a3 + 5);
  *(_OWORD *)(a2 + 24) = v6;
  *((void *)a3 + 4) = 0;
  *((void *)a3 + 5) = 0;
  *((void *)a3 + 3) = 0;
  long long v7 = a3[3];
  *(_OWORD *)(a2 + 60) = *(long long *)((char *)a3 + 60);
  *(_OWORD *)(a2 + 48) = v7;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a2 + 80), (const CLMicroLocationProto::RecordingEvent *)(a3 + 5));
  __n128 result = (__n128)a3[14];
  *(unsigned char *)(a2 + 240) = *((unsigned char *)a3 + 240);
  *(__n128 *)(a2 + 224) = result;
  return result;
}

void sub_2563EBE54(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      long long v10 = *(_OWORD *)(a3 + v7 - 248);
      *(void *)(v9 - 232) = *(void *)(a3 + v7 - 232);
      *(_OWORD *)(v9 - 248) = v10;
      uint64_t v11 = (void **)(a4 + v7 - 224);
      if (*(char *)(a4 + v7 - 201) < 0) {
        operator delete(*v11);
      }
      long long v12 = *(_OWORD *)(v8 - 224);
      *(void *)(a4 + v7 - 208) = *(void *)(v8 - 208);
      *(_OWORD *)uint64_t v11 = v12;
      *(unsigned char *)(v8 - 201) = 0;
      *(unsigned char *)(v8 - 224) = 0;
      long long v13 = *(_OWORD *)(v8 - 200);
      *(_OWORD *)(v9 - 188) = *(_OWORD *)(v8 - 188);
      *(_OWORD *)(v9 - 200) = v13;
      CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(v9 - 168), (const CLMicroLocationProto::RecordingEvent *)(v8 - 168));
      long long v14 = *(_OWORD *)(v8 - 24);
      *(unsigned char *)(v9 - 8) = *(unsigned char *)(v8 - 8);
      *(_OWORD *)(v9 - 24) = v14;
      v7 -= 248;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

long long *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *,CLMicroLocationRecordingEventsTable::Entry *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  long long v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  long long v6 = a3;
  do
  {
    long long v7 = *v5;
    *(void *)(a4 + 16) = *((void *)v5 + 2);
    *(_OWORD *)a4 = v7;
    std::string::operator=((std::string *)(a4 + 24), (const std::string *)v5 + 1);
    long long v8 = *(long long *)((char *)v5 + 60);
    *(_OWORD *)(a4 + 48) = v5[3];
    *(_OWORD *)(a4 + 60) = v8;
    CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a4 + 80), (const CLMicroLocationProto::RecordingEvent *)(v5 + 5));
    long long v9 = v5[14];
    *(unsigned char *)(a4 + 240) = *((unsigned char *)v5 + 240);
    *(_OWORD *)(a4 + 224) = v9;
    a4 += 248;
    long long v5 = (long long *)((char *)v5 + 248);
  }
  while (v5 != v6);
  return v6;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*,CLMicroLocationRecordingEventsTable::Entry*,CLMicroLocationRecordingEventsTable::Entry*>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    long long v6 = a2;
    do
    {
      std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,CLMicroLocationRecordingEventsTable::Entry const&>(a1, v4, v6);
      long long v6 = (long long *)((char *)v6 + 248);
      uint64_t v4 = v12 + 248;
      v12 += 248;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingEventsTable::Entry>,CLMicroLocationRecordingEventsTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_2563EC080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_48()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void *CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(void *a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  *a1 = a2;
  v5[0] = &unk_2704DDAD0;
  v5[1] = a1;
  void v5[3] = v5;
  a1[2] = 0;
  a1[3] = 0;
  a1[1] = 0;
  uint64_t v3 = (char *)operator new(0x20uLL);
  a1[3] = v3 + 32;
  a1[1] = v3;
  a1[2] = v3;
  a1[2] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::function<void ()(std::function<BOOL ()(void)>)>>,std::function<void ()(std::function<BOOL ()(void)>)> const*,std::function<void ()(std::function<BOOL ()(void)>)> const*,std::function<void ()(std::function<BOOL ()(void)>)>*>((uint64_t)(a1 + 3), (uint64_t)v5, (uint64_t)&v6, (uint64_t)v3);
  std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::~__value_func[abi:ne180100](v5);
  return a1;
}

void sub_2563EC1AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  long long v5 = va_arg(va1, void **);
  uint64_t v7 = va_arg(va1, void);
  *(void *)(v2 + 16) = v3;
  std::vector<std::function<void ()(std::function<BOOL ()(void)>)>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::__function::__value_func<void ()(std::function<BOOL ()(void)>)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void CLMicroLocationRoutineStateAnalyzer::refreshRoutineStateAtLastLocation(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 48))(v3))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_58);
    }
    uint64_t v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 68289026;
      int v14 = 0;
      __int16 v15 = 2082;
      unint64_t v16 = "";
      long long v5 = "{\"msg%{public}.0s\":\"Background activity cancelled, will skip refresh routine state at last location\"}";
LABEL_19:
      _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v13, 0x12u);
    }
  }
  else
  {
    uint64_t v6 = +[ULDefaultsSingleton shared];
    uint64_t v7 = [v6 defaultsDictionary];

    long long v8 = [NSString stringWithUTF8String:"ULEnableBackgroundRoutineStateRefresh"];
    long long v9 = [v7 objectForKey:v8];
    if (v9 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      char v10 = [v9 BOOLValue];
    }
    else {
      char v10 = [MEMORY[0x263EFFA88] BOOLValue];
    }
    char v11 = v10;

    if (v11)
    {
      uint64_t v12 = *(void (**)(void))(**(void **)a1 + 16);
      v12();
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_58);
      }
      uint64_t v4 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = 68289026;
        int v14 = 0;
        __int16 v15 = 2082;
        unint64_t v16 = "";
        long long v5 = "{\"msg%{public}.0s\":\"#Warning, tried to refresh routine state in background but it's disabled by settings\"}";
        goto LABEL_19;
      }
    }
  }
}

void sub_2563EC474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CLMicroLocationRoutineStateAnalyzer::executeWorkItems(void *result, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = result[1];
  for (uint64_t i = result[2]; v2 != i; v2 += 32)
  {
    std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, a2);
    uint64_t v5 = *(void *)(v2 + 24);
    if (!v5) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 48))(v5, v6);
    __n128 result = std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  }
  return result;
}

void sub_2563EC578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_49()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void std::__function::__func<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0,std::allocator<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0>,void ()(std::function<BOOL ()(void)>)>::~__func()
{
}

void *std::__function::__func<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0,std::allocator<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_2704DDAD0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0,std::allocator<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0>,void ()(std::function<BOOL ()(void)>)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_2704DDAD0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0,std::allocator<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0>,void ()(std::function<BOOL ()(void)>)>::operator()(uint64_t a1, uint64_t a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  uint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<BOOL ()(void)>::__value_func[abi:ne180100]((uint64_t)v6, (uint64_t)v5);
  CLMicroLocationRoutineStateAnalyzer::refreshRoutineStateAtLastLocation(v3, (uint64_t)v6);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v6);
  return std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100](v5);
}

void sub_2563EC6F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0,std::allocator<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0>,void ()(std::function<BOOL ()(void)>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0,std::allocator<CLMicroLocationRoutineStateAnalyzer::CLMicroLocationRoutineStateAnalyzer(CLMicroLocationRoutineStateAnalyzer::IRoutineStateAnalyzerDelegate &)::$_0>,void ()(std::function<BOOL ()(void)>)>::target_type()
{
}

void CLSqliteDatabase::init(CLSqliteDatabase *this)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  *((_DWORD *)this + 28) = 0;
  memset(&__p, 0, sizeof(__p));
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v3 = logObject_MicroLocation_Default;
  BOOL v4 = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG);
  if (v4)
  {
    uint64_t v5 = (void *)((char *)this + 64);
    if (*((char *)this + 87) < 0) {
      uint64_t v5 = (void *)*v5;
    }
    int v6 = *((_DWORD *)this + 12);
    int v7 = *((_DWORD *)this + 13);
    *(_DWORD *)uint64_t buf = 136315650;
    *(void *)&uint8_t buf[4] = v5;
    __int16 v44 = 1024;
    *(_DWORD *)unint64_t v45 = v6;
    *(_WORD *)&void v45[4] = 1024;
    *(_DWORD *)&v45[6] = v7;
    _os_log_impl(&dword_25631F000, v3, OS_LOG_TYPE_DEBUG, "database open. path: %s, protection: %d, persistence: %d", buf, 0x18u);
  }
  if (*((char *)this + 87) < 0) {
    uint64_t v8 = *((void *)this + 9);
  }
  else {
    uint64_t v8 = *((unsigned __int8 *)this + 87);
  }
  long long v9 = (std::string *)((char *)this + 48);
  char v10 = (long long *)((char *)this + 64);
  char v11 = (const void **)((char *)this + 88);
  if (!v8)
  {
    if (*((char *)this + 111) < 0)
    {
      if (*((void *)this + 12))
      {
LABEL_15:
        uint64_t v1 = CLSqliteDatabaseManager::instance((CLSqliteDatabaseManager *)v4);
        std::string::size_type v33 = v9->__r_.__value_.__r.__words[0];
        __int16 v34 = *((_WORD *)this + 28);
        long long v9 = (std::string *)&v35;
        if ((*((char *)this + 87) & 0x80000000) == 0)
        {
          long long v35 = *v10;
          uint64_t v36 = *((void *)this + 10);
          goto LABEL_38;
        }
LABEL_37:
        std::string::__init_copy_ctor_external(v9, *((const std::string::value_type **)this + 8), *((void *)this + 9));
LABEL_38:
        int v14 = CLSqliteDatabaseManager::openDatabase(v1, (uint64_t *)&v33, (const void **)this + 11, (uint64_t)&v40);
        if ((SHIBYTE(v36) & 0x80000000) == 0) {
          goto LABEL_19;
        }
LABEL_39:
        operator delete(v9->__r_.__value_.__l.__data_);
        if (v14) {
          goto LABEL_20;
        }
        goto LABEL_40;
      }
    }
    else if (*((unsigned char *)this + 111))
    {
      goto LABEL_15;
    }
    CLSqliteDatabase::init();

    abort_report_np();
    __break(1u);
    goto LABEL_37;
  }
  uint64_t v12 = std::string::operator=((std::string *)((char *)this + 88), (const std::string *)((char *)this + 64));
  uint64_t v13 = CLSqliteDatabaseManager::instance((CLSqliteDatabaseManager *)v12);
  std::string::size_type v37 = v9->__r_.__value_.__r.__words[0];
  __int16 v38 = *((_WORD *)this + 28);
  long long v9 = &v39;
  if (*((char *)this + 87) < 0)
  {
    std::string::__init_copy_ctor_external(&v39, *((const std::string::value_type **)this + 8), *((void *)this + 9));
  }
  else
  {
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = *v10;
    v39.__r_.__value_.__r.__words[2] = *((void *)this + 10);
  }
  int v14 = CLSqliteDatabaseManager::openDatabase(v13, (uint64_t *)&v37, (const void **)this + 8, (uint64_t)&v40);
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_39;
  }
LABEL_19:
  if (v14)
  {
LABEL_20:
    if (v14 == 23)
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      __int16 v15 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)this + 111) < 0) {
          char v11 = (const void **)*v11;
        }
        *(_DWORD *)uint64_t buf = 136315394;
        *(void *)&uint8_t buf[4] = v11;
        __int16 v44 = 1024;
        *(_DWORD *)unint64_t v45 = v14;
        _os_log_impl(&dword_25631F000, v15, OS_LOG_TYPE_DEFAULT, "#warning Could not open database. path: %s, rc: %d", buf, 0x12u);
      }
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      unint64_t v16 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
      {
        uint64_t v17 = (char *)this + 88;
        if (*((char *)this + 111) < 0) {
          uint64_t v17 = (char *)*v11;
        }
        *(_DWORD *)uint64_t buf = 136315394;
        *(void *)&uint8_t buf[4] = v17;
        __int16 v44 = 1024;
        *(_DWORD *)unint64_t v45 = v14;
        _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_FAULT, "Could not open database. path: %s, rc: %d", buf, 0x12u);
      }
      CLSqliteDatabase::handleSqlError(*((sqlite3 **)this + 1), (uint64_t)this + 88, *((unsigned __int8 *)this + 56), v14);
    }
    *((void *)this + 1) = 0;
    goto LABEL_85;
  }
LABEL_40:
  *(_OWORD *)((char *)this + 8) = v40;
  uint64_t v18 = *((unsigned __int8 *)this + 111);
  if (*((char *)this + 111) < 0) {
    uint64_t v19 = *((void *)this + 12);
  }
  else {
    uint64_t v19 = *((unsigned __int8 *)this + 111);
  }
  if (!v19)
  {
    std::string::operator=((std::string *)((char *)this + 88), &__p);
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    uint64_t v24 = logObject_MicroLocation_Default;
    if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO)) {
      goto LABEL_76;
    }
    if (*((char *)this + 111) < 0) {
      char v11 = (const void **)*v11;
    }
    *(_DWORD *)uint64_t buf = 136315138;
    *(void *)&uint8_t buf[4] = v11;
    __n128 v25 = "Returned database. path: %s";
    long long v26 = v24;
    os_log_type_t v27 = OS_LOG_TYPE_INFO;
    uint32_t v28 = 12;
LABEL_75:
    _os_log_impl(&dword_25631F000, v26, v27, v25, buf, v28);
    goto LABEL_76;
  }
  if ((v18 & 0x80u) == 0) {
    uint64_t v20 = *((unsigned __int8 *)this + 111);
  }
  else {
    uint64_t v20 = *((void *)this + 12);
  }
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (v20 != size) {
    goto LABEL_66;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((v18 & 0x80) != 0)
  {
    if (!memcmp(*v11, p_p, *((void *)this + 12))) {
      goto LABEL_76;
    }
LABEL_66:
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    uint64_t v29 = logObject_MicroLocation_Default;
    if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT)) {
      goto LABEL_76;
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v30 = &__p;
    }
    else {
      long long v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (*((char *)this + 111) < 0) {
      char v11 = (const void **)*v11;
    }
    *(_DWORD *)uint64_t buf = 136315394;
    *(void *)&uint8_t buf[4] = v30;
    __int16 v44 = 2080;
    *(void *)unint64_t v45 = v11;
    __n128 v25 = "Requested filename. expected: %s, actual: %s";
    long long v26 = v29;
    os_log_type_t v27 = OS_LOG_TYPE_FAULT;
    uint32_t v28 = 22;
    goto LABEL_75;
  }
  if (*((unsigned char *)this + 111))
  {
    uint64_t v23 = (unsigned __int8 *)this + 88;
    while (*v23 == p_p->__r_.__value_.__s.__data_[0])
    {
      ++v23;
      p_p = (std::string *)((char *)p_p + 1);
      if (!--v18) {
        goto LABEL_76;
      }
    }
    goto LABEL_66;
  }
LABEL_76:
  if (!*((unsigned char *)this + 56))
  {
    uint64_t v31 = *((void *)this + 2);
    (*(void (**)(uint64_t, std::string *))(*(void *)v31 + 16))(v31, p_p);
    if (!*v41)
    {
      *(void *)uint64_t buf = "TableName";
      *(_DWORD *)&uint8_t buf[8] = 3;
      __int16 v44 = 1;
      v45[2] = 0;
      char v46 = 0;
      unint64_t v47 = "SoftwareVersion";
      int v48 = 3;
      __int16 v49 = 0;
      char v50 = 0;
      char v51 = 0;
      long long v52 = "SerialNumber";
      int v53 = 3;
      __int16 v54 = 0;
      char v55 = 0;
      char v56 = 0;
      uint64_t v57 = 0;
      int v58 = 5;
      __int16 v59 = 0;
      char v60 = 0;
      char v61 = 0;
      CLSqliteDatabase::createTableIfSchemaDiffers((uint64_t)this, "TableInfo", (const char **)buf, 0, 1);
      *double v41 = 1;
    }
    CLSqliteDatabase::initUUID(this);
    (*(void (**)(uint64_t))(*(void *)v31 + 24))(v31);
  }
  if (!CLSqliteDatabase::setForeignKeysEnabled(this, 1))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    long long v32 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl(&dword_25631F000, v32, OS_LOG_TYPE_FAULT, "Unable to turn ON foreign keys check", buf, 2u);
    }
  }
LABEL_85:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2563ECEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, pthread_mutex_t *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void CLSqliteDatabase::CLSqliteDatabase(CLSqliteDatabase *this, uint64_t *a2)
{
  *(void *)this = &unk_2704DDB50;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = (char *)this + 24;
  *((void *)this + 4) = (char *)this + 24;
  *((void *)this + 5) = 0;
  uint64_t v3 = *a2;
  *((_WORD *)this + 28) = *((_WORD *)a2 + 4);
  *((void *)this + 6) = v3;
  if (*((char *)a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 64), (const std::string::value_type *)a2[2], a2[3]);
  }
  else
  {
    long long v4 = *((_OWORD *)a2 + 1);
    *((void *)this + 10) = a2[4];
    *((_OWORD *)this + 4) = v4;
  }
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 15) = 0;
  CLSqliteDatabase::init(this);
}

void sub_2563ECFE8(_Unwind_Exception *a1)
{
  std::__list_imp<sqlite3_stmt *>::clear(v1);
  _Unwind_Resume(a1);
}

void CLSqliteDatabase::~CLSqliteDatabase(CLSqliteDatabase *this)
{
  *(void *)this = &unk_2704DDB50;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, this);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveEveryObserver(LocalCenter, this);
  for (uint64_t i = *((void *)this + 4); (CLSqliteDatabase *)i != (CLSqliteDatabase *)((char *)this + 24); uint64_t i = v6)
  {
    uint64_t v6 = *(void *)(i + 8);
    long long v4 = (CLSqliteDatabaseManager *)CLSqliteDatabase::finalizeStatement(this, *(sqlite3_stmt **)(i + 16));
  }
  if (*((void *)this + 1))
  {
    if (*((int *)this + 28) >= 1)
    {
      do
      {
        long long v4 = (CLSqliteDatabaseManager *)CLMutexDubiousUnlock(*((void *)this + 2));
        int v7 = *((_DWORD *)this + 28);
        BOOL v8 = __OFSUB__(v7--, 1);
        *((_DWORD *)this + 28) = v7;
      }
      while (!((v7 < 0) ^ v8 | (v7 == 0)));
    }
    long long v9 = (CLSqliteDatabaseManager *)CLSqliteDatabaseManager::instance(v4);
    CLSqliteDatabaseManager::closeDatabase(v9, *((sqlite3 **)this + 1));
    *((void *)this + 1) = 0;
  }
  if (*((void *)this + 2)) {
    *((void *)this + 2) = 0;
  }

  if (*((char *)this + 111) < 0) {
    operator delete(*((void **)this + 11));
  }
  if (*((char *)this + 87) < 0) {
    operator delete(*((void **)this + 8));
  }
  std::__list_imp<sqlite3_stmt *>::clear((void *)this + 3);
}

{
  uint64_t vars8;

  CLSqliteDatabase::~CLSqliteDatabase(this);
  JUMPOUT(0x25A2A6340);
}

uint64_t CLSqliteDatabase::finalizeStatement(CLSqliteDatabase *this, sqlite3_stmt *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  uint64_t v5 = (CLSqliteDatabase *)*((void *)this + 4);
  if (v5 == (CLSqliteDatabase *)((char *)this + 24))
  {
LABEL_4:
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    int v7 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 134217984;
      uint64_t v12 = a2;
      _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "Could not find prepared statement. statement: %p", buf, 0xCu);
    }
  }
  else
  {
    while (1)
    {
      uint64_t v6 = (CLSqliteDatabase *)*((void *)v5 + 1);
      if (*((sqlite3_stmt **)v5 + 2) == a2) {
        break;
      }
      uint64_t v5 = (CLSqliteDatabase *)*((void *)v5 + 1);
      if (v6 == (CLSqliteDatabase *)((char *)this + 24)) {
        goto LABEL_4;
      }
    }
    uint64_t v8 = *(void *)v5;
    *(void *)(v8 + 8) = v6;
    **((void **)v5 + 1) = v8;
    --*((void *)this + 5);
    operator delete(v5);
    CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), a2, v9);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
}

void sub_2563ED2C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  AutoLocker::~AutoLocker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::createTableIfSchemaDiffers(uint64_t a1, char *a2, const char **a3, char **a4, char a5)
{
  v143[19] = *MEMORY[0x263EF8340];
  uint64_t v124 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v124 + 16))(v124);
  __int16 v126 = 256;
  __n128 v112 = a2;
  if (a3 && *a3)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
    long long v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v140, (uint64_t)"PRAGMA table_info(", 18);
    size_t v10 = strlen(a2);
    char v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)a2, v10);
    __p[0] = 41;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)__p, 1);
    std::stringbuf::str();
    if (__p[23] >= 0) {
      uint64_t v12 = (sqlite3 *)__p;
    }
    else {
      uint64_t v12 = *(sqlite3 **)__p;
    }
    uint64_t v13 = CLSqliteDatabase::prepareStatementNoCache((CLSqliteDatabase *)a1, v12);
    char v107 = a5;
    __n128 v108 = a4;
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v116 = 0;
    char v14 = 1;
    __n128 v115 = a3;
    while (sqlite3_step((sqlite3_stmt *)v13) == 100)
    {
      unint64_t v16 = &a3[6 * v116];
      uint64_t v17 = *v16;
      if (!*v16) {
        goto LABEL_36;
      }
      uint64_t v18 = sqlite3_column_text((sqlite3_stmt *)v13, 1);
      if (strcmp(v17, (const char *)v18)) {
        goto LABEL_19;
      }
      int v19 = (int)a3[6 * v116 + 1];
      uint64_t v20 = "INTEGER";
      if (v19 != 1)
      {
        uint64_t v21 = 0;
        do
        {
          uint64_t v22 = v21;
          v21 += 16;
        }
        while (v21 != 80 && *(_DWORD *)((char *)&unk_2653F9BC8 + v22 + 16) != v19);
        uint64_t v20 = *(const char **)((char *)&unk_2653F9BC8 + v22 + 24);
      }
      uint64_t v23 = sqlite3_column_text((sqlite3_stmt *)v13, 2);
      if (strcmp(v20, (const char *)v23) || BYTE4(a3[6 * v116 + 1]) != sqlite3_column_int((sqlite3_stmt *)v13, 5) > 0)
      {
LABEL_19:
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
        }
        uint64_t v24 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = (int)a3[6 * v116 + 1];
          long long v26 = "INTEGER";
          if (v25 != 1)
          {
            uint64_t v27 = 0;
            do
            {
              uint64_t v28 = v27;
              v27 += 16;
            }
            while (v27 != 80 && *(_DWORD *)((char *)&unk_2653F9BC8 + v28 + 16) != v25);
            long long v26 = *(const char **)((char *)&unk_2653F9BC8 + v28 + 24);
          }
          uint64_t v29 = *v16;
          int v30 = BYTE4(v115[6 * v116 + 1]);
          uint64_t v31 = sqlite3_column_text((sqlite3_stmt *)v13, 1);
          long long v32 = sqlite3_column_text((sqlite3_stmt *)v13, 2);
          int v33 = sqlite3_column_int((sqlite3_stmt *)v13, 5);
          *(_DWORD *)std::string __p = 136382467;
          *(void *)&__p[4] = a2;
          *(_WORD *)&__p[12] = 1024;
          *(_DWORD *)&__p[14] = v116;
          *(_WORD *)&__p[18] = 2080;
          *(void *)&__p[20] = v29;
          *(_WORD *)&__p[28] = 2080;
          *(void *)&__p[30] = v26;
          *(_WORD *)&__p[38] = 1024;
          *(_DWORD *)&__p[40] = v30;
          *(_WORD *)int64_t v128 = 2080;
          *(void *)&v128[2] = v31;
          *(_WORD *)int64_t v129 = 2080;
          *(void *)&v129[2] = v32;
          LOWORD(v130) = 1024;
          *(_DWORD *)((char *)&v130 + 2) = v33 > 0;
          _os_log_impl(&dword_25631F000, v24, OS_LOG_TYPE_DEFAULT, "#warning Existing table's column does not match expected. table: %{private}s, index: %d, expected name: %s, expected type: %s, expected primary key: %d, actual name: %s, actual type: %s, actual primary key: %d", __p, 0x46u);
          a3 = v115;
        }

        char v14 = 0;
      }
      ++v116;
    }
    if (!a3[6 * v116]) {
      goto LABEL_41;
    }
LABEL_36:
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    uint64_t v36 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string __p = 136380675;
      *(void *)&__p[4] = a2;
      _os_log_impl(&dword_25631F000, v36, OS_LOG_TYPE_DEFAULT, "#warning Existing table's schema does not have the same number of columns as the requested schema. table: %{private}s", __p, 0xCu);
    }

    char v14 = 0;
LABEL_41:
    CLSqliteDatabase::finalizeStatement(*(CLSqliteDatabase **)(a1 + 8), (sqlite3 *)v13, v15);
    if ((v14 & 1) == 0) {
      goto LABEL_128;
    }
    std::string::size_type v37 = 0;
    __n128 v121 = 0;
    uint64_t v122 = 0;
    uint64_t v123 = 0;
    uint64_t v38 = v116;
    do
    {
      if (LOBYTE(a3[6 * v38 + 5]))
      {
        std::string v39 = &a3[6 * v38];
        if (v37 >= v123)
        {
          unint64_t v42 = (char *)v121;
          unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((v37 - (unsigned char *)v121) >> 4);
          unint64_t v44 = v43 + 1;
          if (v43 + 1 > 0x555555555555555) {
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          }
          if (0x5555555555555556 * ((v123 - (unsigned char *)v121) >> 4) > v44) {
            unint64_t v44 = 0x5555555555555556 * ((v123 - (unsigned char *)v121) >> 4);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((v123 - (unsigned char *)v121) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v45 = 0x555555555555555;
          }
          else {
            unint64_t v45 = v44;
          }
          if (v45)
          {
            char v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationClientUtils::ClientIdentitiesAndLocationTypes>>((uint64_t)&v123, v45);
            unint64_t v42 = (char *)v121;
            std::string::size_type v37 = v122;
          }
          else
          {
            char v46 = 0;
          }
          unint64_t v47 = &v46[48 * v43];
          long long v48 = *(_OWORD *)v39;
          long long v49 = *((_OWORD *)v39 + 2);
          *((_OWORD *)v47 + 1) = *((_OWORD *)v39 + 1);
          *((_OWORD *)v47 + 2) = v49;
          *(_OWORD *)unint64_t v47 = v48;
          if (v37 == v42)
          {
            char v51 = &v46[48 * v43];
            a3 = v115;
          }
          else
          {
            char v50 = &v46[48 * v43];
            a3 = v115;
            do
            {
              char v51 = v50 - 48;
              long long v52 = *((_OWORD *)v37 - 3);
              long long v53 = *((_OWORD *)v37 - 1);
              *((_OWORD *)v50 - 2) = *((_OWORD *)v37 - 2);
              *((_OWORD *)v50 - 1) = v53;
              *((_OWORD *)v50 - 3) = v52;
              v37 -= 48;
              v50 -= 48;
            }
            while (v37 != v42);
          }
          std::string::size_type v37 = v47 + 48;
          __n128 v121 = v51;
          uint64_t v122 = v47 + 48;
          uint64_t v123 = &v46[48 * v45];
          if (v42) {
            operator delete(v42);
          }
        }
        else
        {
          long long v40 = *(_OWORD *)v39;
          long long v41 = *((_OWORD *)v39 + 2);
          *((_OWORD *)v37 + 1) = *((_OWORD *)v39 + 1);
          *((_OWORD *)v37 + 2) = v41;
          *(_OWORD *)std::string::size_type v37 = v40;
          v37 += 48;
          a3 = v115;
        }
        uint64_t v122 = v37;
      }
    }
    while (v38-- > 0);
    memset(__p, 0, 24);
    std::string::operator=(&v142, (const std::string *)__p);
    std::stringbuf::__init_buf_ptrs[abi:ne180100]((uint64_t)v141);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    char v55 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v140, (uint64_t)"PRAGMA foreign_key_list(", 24);
    size_t v56 = strlen(a2);
    uint64_t v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)a2, v56);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)")", 1);
    std::stringbuf::str();
    if (__p[23] >= 0) {
      int v58 = (sqlite3 *)__p;
    }
    else {
      int v58 = *(sqlite3 **)__p;
    }
    __int16 v59 = CLSqliteDatabase::prepareStatementNoCache((CLSqliteDatabase *)a1, v58);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    int v60 = sqlite3_step((sqlite3_stmt *)v59);
    uint64_t v62 = (char *)v121;
    double v63 = v122;
    if (v122 == v121 && v60 == 100)
    {
LABEL_74:
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      uint64_t v64 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string __p = 0;
        _os_log_impl(&dword_25631F000, v64, OS_LOG_TYPE_DEFAULT, "#warning Actual table has more foreign key contraints than expected", __p, 2u);
      }

      char v65 = 0;
LABEL_124:
      CLSqliteDatabase::finalizeStatement(*(CLSqliteDatabase **)(a1 + 8), (sqlite3 *)v59, v61);
      if (v121)
      {
        uint64_t v122 = (char *)v121;
        operator delete(v121);
      }
      if (v65)
      {
        uint64_t v35 = 0;
LABEL_135:
        if ((v107 & 1) == 0) {
          CLSqliteDatabase::createCountTriggersIfNecessary((CLSqliteDatabase *)a1, a2);
        }
        if (v108) {
          CLSqliteDatabase::createIndexIfNecessary((CLSqliteDatabase *)a1, a2, (CLSqliteDatabase *)v108);
        }
        *(void *)uint64_t buf = *MEMORY[0x263F8C2B8];
        uint64_t v105 = *(void *)(MEMORY[0x263F8C2B8] + 72);
        *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x263F8C2B8] + 64);
        uint64_t v140 = v105;
        v141[0] = MEMORY[0x263F8C318] + 16;
        if (SHIBYTE(v142.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v142.__r_.__value_.__l.__data_);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x25A2A6280](v143);
        goto LABEL_142;
      }
LABEL_128:
      if (v116)
      {
        if (onceToken_MicroLocation_Default != -1) {
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
        }
        long long v104 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string __p = 136380675;
          *(void *)&__p[4] = a2;
          _os_log_impl(&dword_25631F000, v104, OS_LOG_TYPE_DEFAULT, "#warning Table exists but does not have matching schema. table: %{private}s", __p, 0xCu);
        }

        CLSqliteDatabase::dropTable_internal((CLSqliteDatabase *)a1, a2);
      }
      CLSqliteDatabase::createTable(a1, a2, a3);
      uint64_t v35 = 1;
      goto LABEL_135;
    }
    unint64_t v66 = 0;
    BOOL v67 = v122 == v121 || v60 == 100;
    char v68 = !v67;
    char v65 = v68 ^ 1;
    if (!v67 || v60 != 100)
    {
LABEL_122:
      if (v66 >= 0xAAAAAAAAAAAAAAABLL * ((v63 - v62) >> 4) && v60 != 100) {
        goto LABEL_124;
      }
      goto LABEL_74;
    }
    uint64_t v69 = 1;
    uint64_t v70 = 36;
    char v65 = 1;
    while (1)
    {
      uint64_t v71 = *(const char **)&v62[v70 - 36];
      unint64_t v72 = sqlite3_column_text((sqlite3_stmt *)v59, 3);
      if (strcmp(v71, (const char *)v72)) {
        break;
      }
      double v73 = *(const char **)((char *)v121 + v70 - 20);
      unint64_t v74 = sqlite3_column_text((sqlite3_stmt *)v59, 2);
      if (strcmp(v73, (const char *)v74)) {
        break;
      }
      uint64_t v75 = *(const char **)((char *)v121 + v70 - 12);
      long long v76 = sqlite3_column_text((sqlite3_stmt *)v59, 4);
      if (strcmp(v75, (const char *)v76)) {
        break;
      }
      std::string::basic_string[abi:ne180100]<0>(__p, off_2653F9C28[*(int *)((char *)v121 + v70)]);
      int v77 = __p[23];
      uint64_t v78 = *(const char **)__p;
      uint64_t v79 = sqlite3_column_text((sqlite3_stmt *)v59, 5);
      if (v77 >= 0) {
        uint64_t v80 = __p;
      }
      else {
        uint64_t v80 = v78;
      }
      if (!strcmp(v80, (const char *)v79))
      {
        std::string::basic_string[abi:ne180100]<0>(v119, off_2653F9C28[*(int *)((char *)v121 + v70 - 4)]);
        int v82 = v120;
        uint64_t v83 = (void **)v119[0];
        uint64_t v84 = sqlite3_column_text((sqlite3_stmt *)v59, 6);
        if (v82 >= 0) {
          long long v85 = v119;
        }
        else {
          long long v85 = v83;
        }
        BOOL v81 = strcmp((const char *)v85, (const char *)v84) != 0;
        if (v120 < 0) {
          operator delete(v119[0]);
        }
      }
      else
      {
        BOOL v81 = 1;
      }
      a2 = v112;
      if ((__p[23] & 0x80000000) != 0)
      {
        operator delete(*(void **)__p);
        if (v81) {
          break;
        }
      }
      else if (v81)
      {
        break;
      }
LABEL_119:
      int v60 = sqlite3_step((sqlite3_stmt *)v59);
      uint64_t v62 = (char *)v121;
      double v63 = v122;
      uint64_t v103 = v69 + 1;
      if (v69 != 0xAAAAAAAAAAAAAAABLL * ((v122 - (unsigned char *)v121) >> 4))
      {
        v70 += 48;
        ++v69;
        if (v60 == 100) {
          continue;
        }
      }
      unint64_t v66 = v103 - 1;
      goto LABEL_122;
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __n128 v86 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v87 = *(void *)((char *)v121 + v70 - 36);
      uint64_t v88 = *(void *)((char *)v121 + v70 - 20);
      uint64_t v89 = *(void *)((char *)v121 + v70 - 12);
      log = v86;
      int v90 = sqlite3_column_text((sqlite3_stmt *)v59, 3);
      long long v91 = sqlite3_column_text((sqlite3_stmt *)v59, 2);
      unint64_t v92 = sqlite3_column_text((sqlite3_stmt *)v59, 4);
      uint64_t v110 = v69;
      uint64_t v114 = v70;
      std::string::basic_string[abi:ne180100]<0>(v119, off_2653F9C28[*(int *)((char *)v121 + v70 - 4)]);
      __n128 v109 = v92;
      double v93 = v91;
      double v94 = v90;
      if (v120 >= 0) {
        long long v95 = v119;
      }
      else {
        long long v95 = (void **)v119[0];
      }
      __n128 v96 = sqlite3_column_text((sqlite3_stmt *)v59, 6);
      uint64_t v97 = v88;
      long long v98 = (sqlite3_stmt *)v59;
      std::string::basic_string[abi:ne180100]<0>(v117, off_2653F9C28[*(int *)((char *)v121 + v114)]);
      int v99 = v118;
      long long v100 = (void **)v117[0];
      uint64_t v101 = sqlite3_column_text(v98, 5);
      *(_DWORD *)std::string __p = 136383235;
      uint64_t v102 = v117;
      if (v99 < 0) {
        uint64_t v102 = v100;
      }
      a2 = v112;
      *(void *)&__p[4] = v112;
      *(_WORD *)&__p[12] = 2080;
      *(void *)&__p[14] = v87;
      *(_WORD *)&__p[22] = 2080;
      *(void *)&__p[24] = v97;
      *(_WORD *)&__p[32] = 2080;
      *(void *)&__p[34] = v89;
      *(_WORD *)&__p[42] = 2080;
      *(void *)int64_t v128 = v94;
      *(_WORD *)&v128[8] = 2080;
      *(void *)int64_t v129 = v93;
      *(_WORD *)&v129[8] = 2080;
      uint64_t v130 = v109;
      __int16 v131 = 2080;
      unint64_t v132 = v95;
      __int16 v133 = 2080;
      int v134 = v96;
      __int16 v135 = 2080;
      unint64_t v136 = v102;
      __int16 v137 = 2080;
      int v138 = v101;
      __n128 v86 = log;
      _os_log_impl(&dword_25631F000, log, OS_LOG_TYPE_DEBUG, "#warning Existing table's foreign key constraint does not match expected. table: %{private}s, ExpectedFromCol: %s, ExpectedToTable: %s, ExpectedToCol: %s, ActualFromCol: %s, ActualToTable: %s, ActualToCol: %s, ExpectedOnDelete: %s, ActualOnDelete: %s, ExpectedOnUpdate: %s, ActualOnUpdate: %s", __p, 0x70u);
      if (v118 < 0) {
        operator delete(v117[0]);
      }
      a3 = v115;
      __int16 v59 = (CLSqliteDatabase *)v98;
      uint64_t v69 = v110;
      uint64_t v70 = v114;
      if (v120 < 0) {
        operator delete(v119[0]);
      }
    }

    char v65 = 0;
    goto LABEL_119;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  __int16 v34 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)uint64_t buf = 136380675;
    *(void *)&uint8_t buf[4] = v112;
    _os_log_impl(&dword_25631F000, v34, OS_LOG_TYPE_FAULT, "Need at least one column in table. table: %{private}s", buf, 0xCu);
  }
  uint64_t v35 = 0;
LABEL_142:
  if ((_BYTE)v126) {
    pthread_mutex_unlock(v125);
  }
  else {
    (*(void (**)(uint64_t))(*(void *)v124 + 24))(v124);
  }
  return v35;
}

void sub_2563EE0D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,uint64_t a39,pthread_mutex_t *a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a37) {
    operator delete(a37);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a60);
  AutoLocker::~AutoLocker(&a40);
  _Unwind_Resume(a1);
}

void CLSqliteDatabase::initUUID(CLSqliteDatabase *this)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  long long v48 = "id";
  int v49 = 1;
  __int16 v50 = 1;
  char v51 = 0;
  char v52 = 0;
  long long v53 = "uuid";
  int v54 = 3;
  __int16 v55 = 0;
  char v56 = 0;
  char v57 = 0;
  uint64_t v58 = 0;
  int v59 = 5;
  __int16 v60 = 0;
  char v61 = 0;
  char v62 = 0;
  v47[0] = "uuid";
  v47[1] = 0;
  CLSqliteDatabase::createTableIfNecessary((uint64_t)this, "DatabaseIdentifier", &v48, v47);
  v40[0] = 0;
  v40[1] = 0;
  uint64_t v41 = 0;
  uint64_t v2 = CLSqliteDatabase::prepareStatementNoCache(this, (sqlite3 *)"SELECT * FROM DatabaseIdentifier;");
  uint64_t v3 = (sqlite3_stmt *)v2;
  if (v2)
  {
    if (sqlite3_step((sqlite3_stmt *)v2) == 100)
    {
      uint64_t v5 = sqlite3_column_text(v3, 1);
      MEMORY[0x25A2A6080](v40, v5);
      id v6 = [NSString alloc];
      if (v41 >= 0) {
        int v7 = v40;
      }
      else {
        int v7 = (void **)v40[0];
      }
      uint64_t v8 = [v6 initWithUTF8String:v7];
      long long v9 = (void *)*((void *)this + 15);
      *((void *)this + 15) = v8;

      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      size_t v10 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)this + 111) < 0) {
          std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 11), *((void *)this + 12));
        }
        else {
          std::string __p = *(std::string *)((char *)this + 88);
        }
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        uint64_t v13 = v40;
        if (v41 < 0) {
          uint64_t v13 = (void **)v40[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315395;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2081;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v13;
        _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEFAULT, "initUUID. path: %s, uuid: %{private}s", (uint8_t *)&buf, 0x16u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
    }
    CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), v3, v4);
    if (!*((void *)this + 15))
    {
      char v14 = [MEMORY[0x263F08C38] UUID];
      id v15 = [v14 UUIDString];
      MEMORY[0x25A2A6080](v40, [v15 UTF8String]);

      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__p);
      unint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__p.__r_.__value_.__r.__words[2], (uint64_t)"INSERT INTO DatabaseIdentifier (uuid) VALUES (\"", 47);
      if (v41 >= 0) {
        uint64_t v17 = v40;
      }
      else {
        uint64_t v17 = (void **)v40[0];
      }
      size_t v18 = strlen((const char *)v17);
      int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"\");", 3);
      std::stringbuf::str();
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_std::string buf = (sqlite3 *)&buf;
      }
      else {
        p_std::string buf = (sqlite3 *)buf.__r_.__value_.__r.__words[0];
      }
      uint64_t v21 = CLSqliteDatabase::prepareStatementNoCache(this, p_buf);
      uint64_t v22 = (sqlite3_stmt *)v21;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(buf.__r_.__value_.__l.__data_);
        if (v22)
        {
LABEL_32:
          if (sqlite3_step(v22) == 101)
          {
            uint64_t v23 = [v14 UUIDString];
            uint64_t v24 = (void *)*((void *)this + 15);
            *((void *)this + 15) = v23;

            if (onceToken_MicroLocation_Default != -1) {
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
            }
            int v25 = (id)logObject_MicroLocation_Default;
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_60;
            }
            if (*((char *)this + 111) < 0) {
              std::string::__init_copy_ctor_external(&buf, *((const std::string::value_type **)this + 11), *((void *)this + 12));
            }
            else {
              std::string buf = *(std::string *)((char *)this + 88);
            }
            uint64_t v31 = &buf;
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v31 = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            long long v32 = v40;
            if (v41 < 0) {
              long long v32 = (void **)v40[0];
            }
            *(_DWORD *)unint64_t v42 = 136315395;
            unint64_t v43 = v31;
            __int16 v44 = 2081;
            unint64_t v45 = v32;
            uint64_t v28 = "UUID initialized. path: %s, uuid: %{private}s";
            uint64_t v29 = v25;
            uint32_t v30 = 22;
          }
          else
          {
            if (onceToken_MicroLocation_Default != -1) {
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
            }
            int v25 = (id)logObject_MicroLocation_Default;
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_60;
            }
            if (*((char *)this + 111) < 0) {
              std::string::__init_copy_ctor_external(&buf, *((const std::string::value_type **)this + 11), *((void *)this + 12));
            }
            else {
              std::string buf = *(std::string *)((char *)this + 88);
            }
            uint64_t v27 = &buf;
            if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              uint64_t v27 = (std::string *)buf.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)unint64_t v42 = 136315138;
            unint64_t v43 = v27;
            uint64_t v28 = "Failed to initialize DB UUID. path: %s";
            uint64_t v29 = v25;
            uint32_t v30 = 12;
          }
          _os_log_impl(&dword_25631F000, v29, OS_LOG_TYPE_DEFAULT, v28, v42, v30);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(buf.__r_.__value_.__l.__data_);
          }
LABEL_60:

          CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), v22, v33);
LABEL_61:
          __p.__r_.__value_.__r.__words[0] = *MEMORY[0x263F8C2B8];
          std::string::size_type v34 = *(void *)(MEMORY[0x263F8C2B8] + 72);
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words
                                    + *(void *)(__p.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
          __p.__r_.__value_.__r.__words[2] = v34;
          uint64_t v36 = MEMORY[0x263F8C318] + 16;
          if (v38 < 0) {
            operator delete(v37);
          }
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x25A2A6280](&v39);

          goto LABEL_64;
        }
      }
      else if (v21)
      {
        goto LABEL_32;
      }
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      long long v26 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_impl(&dword_25631F000, v26, OS_LOG_TYPE_DEFAULT, "#warning Failed to create UUID insert statement", (uint8_t *)&buf, 2u);
      }
      goto LABEL_61;
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    char v11 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_25631F000, v11, OS_LOG_TYPE_DEFAULT, "#warning Failed to create UUID select statement", (uint8_t *)&__p, 2u);
    }
  }
LABEL_64:
  if (SHIBYTE(v41) < 0) {
    operator delete(v40[0]);
  }
}

void sub_2563EE900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a9);
  if (a49 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL CLSqliteDatabase::setForeignKeysEnabled(CLSqliteDatabase *this, int a2)
{
  uint64_t v4 = *((void *)this + 2);
  uint64_t v14 = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v15 = 256;
  std::string::basic_string[abi:ne180100]<0>(&v13, "pragma foreign_keys = ");
  if (a2) {
    uint64_t v5 = "1";
  }
  else {
    uint64_t v5 = "0";
  }
  std::string::basic_string[abi:ne180100]<0>(__p, v5);
  if ((v12 & 0x80u) == 0) {
    id v6 = __p;
  }
  else {
    id v6 = (void **)__p[0];
  }
  if ((v12 & 0x80u) == 0) {
    std::string::size_type v7 = v12;
  }
  else {
    std::string::size_type v7 = (std::string::size_type)__p[1];
  }
  std::string::append(&v13, (const std::string::value_type *)v6, v7);
  if ((char)v12 < 0) {
    operator delete(__p[0]);
  }
  if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v8 = &v13;
  }
  else {
    uint64_t v8 = (std::string *)v13.__r_.__value_.__r.__words[0];
  }
  int v9 = sqlite3_exec(*((sqlite3 **)this + 1), (const char *)v8, 0, 0, 0);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  return v9 == 0;
}

void sub_2563EEAD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,pthread_mutex_t *a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  AutoLocker::~AutoLocker(&a22);
  _Unwind_Resume(a1);
}

void CLSqliteDatabase::handleSqlError(CLSqliteDatabase *this, int a2)
{
}

uint64_t CLSqliteDatabase::createTableIfNecessary(uint64_t a1, char *a2, const char **a3, char **a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v8 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136380675;
    char v11 = a2;
    _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_DEFAULT, "createTableIfNecessary. table: %{private}s", (uint8_t *)&v10, 0xCu);
  }
  return CLSqliteDatabase::createTableIfNecessary_internal(a1, a2, a3, a4);
}

CLSqliteDatabase *CLSqliteDatabase::prepareStatementNoCache(CLSqliteDatabase *this, sqlite3 *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (((*(uint64_t (**)(void))(**((void **)this + 2) + 32))(*((void *)this + 2)) & 1) == 0)
  {
    CLSqliteDatabase::prepareStatementNoCache();
LABEL_15:
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    goto LABEL_4;
  }
  if (!*((void *)this + 1)) {
    return 0;
  }
  p_superclass = &OBJC_METACLASS___CLMicroLocationLoiBridge.superclass;
  if (onceToken_MicroLocation_Default != -1) {
    goto LABEL_15;
  }
LABEL_4:
  uint64_t v5 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    std::string::size_type v7 = (void *)((char *)this + 88);
    if (*((char *)this + 111) < 0) {
      std::string::size_type v7 = (void *)*v7;
    }
    int v11 = 136380931;
    uint64_t v12 = a2;
    __int16 v13 = 2080;
    uint64_t v14 = v7;
    _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_DEBUG, "Preparing statement for database. query: %{private}s, path: %s", (uint8_t *)&v11, 0x16u);
  }
  uint64_t v8 = CLSqliteDatabase::prepareStatement(*((CLSqliteDatabase **)this + 1), a2, v6);
  if (p_superclass[429] != (__objc2_class *)-1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  int v9 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    int v11 = 134217984;
    uint64_t v12 = (sqlite3 *)v8;
    _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_DEBUG, "Prepared statement. statement: %p", (uint8_t *)&v11, 0xCu);
  }
  return v8;
}

void CLSqliteDatabase::finalizeStatement(CLSqliteDatabase *this, sqlite3 *pStmt, sqlite3_stmt *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v4 = sqlite3_finalize(pStmt);
  if (v4)
  {
    int v5 = v4;
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    id v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (this) {
        std::string::size_type v7 = sqlite3_errmsg((sqlite3 *)this);
      }
      else {
        std::string::size_type v7 = "no database";
      }
      v8[0] = 67109379;
      v8[1] = v5;
      __int16 v9 = 2081;
      int v10 = v7;
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "#warning Finalized statement previously failed. sqlite_rc: %d, errmsg: %{private}s", (uint8_t *)v8, 0x12u);
    }
  }
}

void sub_2563EEEF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLSqliteDatabase::displaySqlResult(CLSqliteDatabase *this, const char *a2, int a3, sqlite3_stmt *a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (a3 <= 0x1Au && ((1 << a3) & 0x4004C00) != 0)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    std::string::size_type v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      int v8 = *__error();
      if (a4) {
        __int16 v9 = sqlite3_sql(a4);
      }
      else {
        __int16 v9 = 0;
      }
      int v15 = 136315907;
      unint64_t v16 = a2;
      __int16 v17 = 1024;
      int v18 = v8;
      __int16 v19 = 1024;
      int v20 = a3;
      __int16 v21 = 2081;
      uint64_t v22 = v9;
      uint64_t v12 = "displaySqlResult. function: %s, errno: %d, sqlite_rc: %d, query: %{private}s";
      __int16 v13 = v7;
      os_log_type_t v14 = OS_LOG_TYPE_FAULT;
LABEL_17:
      _os_log_impl(&dword_25631F000, v13, v14, v12, (uint8_t *)&v15, 0x22u);
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    std::string::size_type v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *__error();
      if (a4) {
        uint64_t v11 = sqlite3_sql(a4);
      }
      else {
        uint64_t v11 = 0;
      }
      int v15 = 136315907;
      unint64_t v16 = a2;
      __int16 v17 = 1024;
      int v18 = v10;
      __int16 v19 = 1024;
      int v20 = a3;
      __int16 v21 = 2081;
      uint64_t v22 = v11;
      uint64_t v12 = "#warning displaySqlResult. function: %s, errno: %d, sqlite_rc: %d, query: %{private}s";
      __int16 v13 = v7;
      os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_17;
    }
  }
}

void sub_2563EF104(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::getElementCreateStatement@<X0>(CLSqliteDatabase *this@<X0>, char *a2@<X1>, char *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = *((void *)this + 2);
  v30[19] = v8;
  (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  __int16 v31 = 256;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v27);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  __int16 v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)"SELECT sql FROM ", 16);
  int v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"sqlite_master", 13);
  uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" WHERE ", 7);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"Type", 4);
  __int16 v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"=? AND ", 7);
  os_log_type_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"Name", 4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"=?", 2);
  std::stringbuf::str();
  if (v26 >= 0) {
    int v15 = __p;
  }
  else {
    int v15 = (void **)__p[0];
  }
  unint64_t v16 = CLSqliteDatabase::prepareStatementNoCache(this, (sqlite3 *)v15);
  int v18 = (sqlite3_stmt *)v16;
  if (SHIBYTE(v26) < 0)
  {
    operator delete(__p[0]);
    if (!v18) {
      goto LABEL_16;
    }
  }
  else if (!v16)
  {
    goto LABEL_16;
  }
  if (CLSqliteDatabase::bind((CLSqliteDatabase *)v18, (sqlite3_stmt *)1, a2, v17)
    && CLSqliteDatabase::bind((CLSqliteDatabase *)v18, (sqlite3_stmt *)2, a3, v20)
    && sqlite3_step(v18) == 100)
  {
    __int16 v21 = sqlite3_column_text(v18, 0);
    if (v21) {
      uint64_t v22 = (char *)v21;
    }
    else {
      uint64_t v22 = "";
    }
    std::string::basic_string[abi:ne180100]<0>(__p, v22);
    *(_OWORD *)a4 = *(_OWORD *)__p;
    a4[2] = v26;
  }
  CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), v18, v19);
LABEL_16:
  v27[0] = *MEMORY[0x263F8C2B8];
  uint64_t v23 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v27 + *(void *)(v27[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v28[0] = v23;
  v28[1] = MEMORY[0x263F8C318] + 16;
  if (v29 < 0) {
    operator delete((void *)v28[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](v30);
  return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
}

void sub_2563EF430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
  AutoLocker::~AutoLocker((pthread_mutex_t **)(v16 - 104));
  _Unwind_Resume(a1);
}

void CLSqliteDatabase::handleSqlError(sqlite3 *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (a4 == 26 || a4 == 11)
  {
    if (a3)
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      std::string::size_type v7 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v8 = a2;
        }
        else {
          uint64_t v8 = *(void *)a2;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)int v18 = v8;
        *(_WORD *)&v18[8] = 1024;
        *(_DWORD *)&v18[10] = a4;
        _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "handleSqlError on read-only db. path: %s, sqlite_rc: %d", buf, 0x12u);
      }
    }
    else
    {
      __int16 v9 = _CLLogObjectForCategory_MicroLocation_Default();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        if (*(char *)(a2 + 23) >= 0) {
          uint64_t v10 = a2;
        }
        else {
          uint64_t v10 = *(void *)a2;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)int v18 = v10;
        *(_WORD *)&v18[8] = 1024;
        *(_DWORD *)&v18[10] = a4;
        _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_FAULT, "database error; deleting and exiting. path: %s, sqlite_rc: %d",
          buf,
          0x12u);
      }

      CLSqliteDatabase::deleteDatabase(a1, a2);
      uint64_t v11 = _CLLogObjectForCategory_MicroLocation_Default();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 68289539;
        *(_DWORD *)int v18 = 0;
        *(_WORD *)&v18[4] = 2082;
        *(void *)&v18[6] = "";
        __int16 v19 = 2082;
        int v20 = "assert";
        __int16 v21 = 2081;
        uint64_t v22 = "0";
        _os_log_impl(&dword_25631F000, v11, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Killing locationd to resolve corrupted database\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      }

      uint64_t v12 = _CLLogObjectForCategory_MicroLocation_Default();
      if (os_signpost_enabled(v12))
      {
        *(_DWORD *)std::string buf = 68289539;
        *(_DWORD *)int v18 = 0;
        *(_WORD *)&v18[4] = 2082;
        *(void *)&v18[6] = "";
        __int16 v19 = 2082;
        int v20 = "assert";
        __int16 v21 = 2081;
        uint64_t v22 = "0";
        _os_signpost_emit_with_name_impl(&dword_25631F000, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Killing locationd to resolve corrupted database", "{\"msg%{public}.0s\":\"Killing locationd to resolve corrupted database\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      }

      __int16 v13 = _CLLogObjectForCategory_MicroLocation_Default();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::string buf = 68289539;
        *(_DWORD *)int v18 = 0;
        *(_WORD *)&v18[4] = 2082;
        *(void *)&v18[6] = "";
        __int16 v19 = 2082;
        int v20 = "assert";
        __int16 v21 = 2081;
        uint64_t v22 = "0";
        _os_log_impl(&dword_25631F000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Killing locationd to resolve corrupted database\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      }

      os_log_type_t v14 = (sqlite3 *)abort_report_np();
      CLSqliteDatabase::deleteDatabase(v14, v15);
    }
  }
}

void CLSqliteDatabase::deleteDatabase(sqlite3 *a1, uint64_t a2)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  if (a1 && MEMORY[0x263F25588])
  {
    if (CPSqliteDatabaseDelete()) {
      return;
    }
    goto LABEL_6;
  }
  if (a1)
  {
LABEL_6:
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    int v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_FAULT, "Could not delete the database with CPSqliteDatabaseDelete()", buf, 2u);
    }
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  int v5 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
  {
    if (*(char *)(a2 + 23) >= 0) {
      id v6 = (void **)a2;
    }
    else {
      id v6 = *(void ***)a2;
    }
    *(_DWORD *)std::string buf = 136315138;
    char v51 = v6;
    _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_FAULT, "Falling back to file deletion. path: %s", buf, 0xCu);
  }
  sqlite3_close(a1);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v8 = (const std::__fs::filesystem::path *)a2;
  }
  else {
    uint64_t v8 = *(const std::__fs::filesystem::path **)a2;
  }
  if (remove(v8, v7))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __int16 v9 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
    {
      if (*(char *)(a2 + 23) >= 0) {
        uint64_t v10 = (void **)a2;
      }
      else {
        uint64_t v10 = *(void ***)a2;
      }
      int v11 = *__error();
      uint64_t v12 = __error();
      __int16 v13 = strerror(*v12);
      *(_DWORD *)std::string buf = 136315650;
      char v51 = v10;
      __int16 v52 = 1024;
      int v53 = v11;
      __int16 v54 = 2080;
      __int16 v55 = v13;
      _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_FAULT, "could not remove file. path: %s, errno: %d, error: %s", buf, 0x1Cu);
    }
  }
  if (*(char *)(a2 + 23) >= 0) {
    size_t v14 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v14 = *(void *)(a2 + 8);
  }
  uint64_t v15 = v48;
  std::string::basic_string[abi:ne180100]((uint64_t)v48, v14 + 8);
  if (v49 < 0) {
    uint64_t v15 = (void **)v48[0];
  }
  if (v14)
  {
    if (*(char *)(a2 + 23) >= 0) {
      __int16 v17 = (const void *)a2;
    }
    else {
      __int16 v17 = *(const void **)a2;
    }
    memmove(v15, v17, v14);
  }
  strcpy((char *)v15 + v14, "-journal");
  if (v49 >= 0) {
    int v18 = (const std::__fs::filesystem::path *)v48;
  }
  else {
    int v18 = (const std::__fs::filesystem::path *)v48[0];
  }
  if (remove(v18, v16))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __int16 v19 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    {
      if (v49 >= 0) {
        int v20 = v48;
      }
      else {
        int v20 = (void **)v48[0];
      }
      int v21 = *__error();
      uint64_t v22 = __error();
      uint64_t v23 = strerror(*v22);
      *(_DWORD *)std::string buf = 136315650;
      char v51 = v20;
      __int16 v52 = 1024;
      int v53 = v21;
      __int16 v54 = 2080;
      __int16 v55 = v23;
      _os_log_impl(&dword_25631F000, v19, OS_LOG_TYPE_FAULT, "could not remove file. path %s, errno: %d, error: %s", buf, 0x1Cu);
    }
  }
  if (*(char *)(a2 + 23) >= 0) {
    size_t v24 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v24 = *(void *)(a2 + 8);
  }
  int v25 = v46;
  std::string::basic_string[abi:ne180100]((uint64_t)v46, v24 + 4);
  if (v47 < 0) {
    int v25 = (void **)v46[0];
  }
  if (v24)
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v27 = (const void *)a2;
    }
    else {
      uint64_t v27 = *(const void **)a2;
    }
    memmove(v25, v27, v24);
  }
  strcpy((char *)v25 + v24, "-wal");
  if (v47 >= 0) {
    uint64_t v28 = (const std::__fs::filesystem::path *)v46;
  }
  else {
    uint64_t v28 = (const std::__fs::filesystem::path *)v46[0];
  }
  if (remove(v28, v26))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    char v29 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
    {
      if (v47 >= 0) {
        uint32_t v30 = v46;
      }
      else {
        uint32_t v30 = (void **)v46[0];
      }
      int v31 = *__error();
      long long v32 = __error();
      int v33 = strerror(*v32);
      *(_DWORD *)std::string buf = 136315650;
      char v51 = v30;
      __int16 v52 = 1024;
      int v53 = v31;
      __int16 v54 = 2080;
      __int16 v55 = v33;
      _os_log_impl(&dword_25631F000, v29, OS_LOG_TYPE_FAULT, "could not remove file. path: %s, errno: %d, error: %s", buf, 0x1Cu);
    }
  }
  if (*(char *)(a2 + 23) >= 0) {
    size_t v34 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v34 = *(void *)(a2 + 8);
  }
  uint64_t v35 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v34 + 4);
  if (v45 < 0) {
    uint64_t v35 = (void **)__p[0];
  }
  if (v34)
  {
    if (*(char *)(a2 + 23) >= 0) {
      std::string::size_type v37 = (const void *)a2;
    }
    else {
      std::string::size_type v37 = *(const void **)a2;
    }
    memmove(v35, v37, v34);
  }
  strcpy((char *)v35 + v34, "-shm");
  if (v45 >= 0) {
    char v38 = (const std::__fs::filesystem::path *)__p;
  }
  else {
    char v38 = (const std::__fs::filesystem::path *)__p[0];
  }
  if (remove(v38, v36))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    uint64_t v39 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
    {
      if (v45 >= 0) {
        long long v40 = __p;
      }
      else {
        long long v40 = (void **)__p[0];
      }
      int v41 = *__error();
      unint64_t v42 = __error();
      unint64_t v43 = strerror(*v42);
      *(_DWORD *)std::string buf = 136315650;
      char v51 = v40;
      __int16 v52 = 1024;
      int v53 = v41;
      __int16 v54 = 2080;
      __int16 v55 = v43;
      _os_log_impl(&dword_25631F000, v39, OS_LOG_TYPE_FAULT, "could not remove file. path: %s, errno: %d, error: %s", buf, 0x1Cu);
    }
  }
  if (v45 < 0) {
    operator delete(__p[0]);
  }
  if (v47 < 0) {
    operator delete(v46[0]);
  }
  if (v49 < 0) {
    operator delete(v48[0]);
  }
}

void sub_2563EFDD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(a1);
}

CLSqliteDatabase *CLSqliteDatabase::createCountTriggersIfNecessary(CLSqliteDatabase *this, const char *a2)
{
  if (*((unsigned char *)this + 57))
  {
    uint64_t v3 = this;
    CLSqliteDatabase::dropCountTriggers(this, a2);
    return (CLSqliteDatabase *)CLSqliteDatabase::addCountTriggers(v3, a2);
  }
  return this;
}

uint64_t CLSqliteDatabase::dropCountTriggers(CLSqliteDatabase *this, const char *a2)
{
  uint64_t v4 = *((void *)this + 2);
  v25[19] = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v26 = 256;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v21);
  size_t v5 = strlen(a2);
  id v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)a2, v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"IncrementRowCount", 17);
  std::stringbuf::str();
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::dropTrigger(this, (char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&v24, &__p);
  std::stringbuf::__init_buf_ptrs[abi:ne180100]((uint64_t)v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  size_t v8 = strlen(a2);
  __int16 v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)a2, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"DecrementRowCount", 17);
  std::stringbuf::str();
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::dropTrigger(this, (char *)v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&v24, &__p);
  std::stringbuf::__init_buf_ptrs[abi:ne180100]((uint64_t)v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  size_t v11 = strlen(a2);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)a2, v11);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"Counts", 6);
  std::stringbuf::str();
  if (v19 >= 0) {
    __int16 v13 = (char *)&v18;
  }
  else {
    __int16 v13 = (char *)v18;
  }
  CLSqliteDatabase::getElementCreateStatement(this, "table", v13, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    BOOL v14 = __p.__r_.__value_.__l.__size_ == 0;
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  else
  {
    BOOL v14 = SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 0;
  }
  if (v19 < 0)
  {
    operator delete(v18);
    if (v14) {
      goto LABEL_30;
    }
  }
  else if (v14)
  {
    goto LABEL_30;
  }
  std::stringbuf::str();
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = &__p;
  }
  else {
    uint64_t v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::dropTable_internal(this, (char *)v15);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_30:
  v21[0] = *MEMORY[0x263F8C2B8];
  uint64_t v16 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v22 = v16;
  v23[0] = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](v25);
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
}

void sub_2563F0260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a21);
  AutoLocker::~AutoLocker((pthread_mutex_t **)(v21 - 88));
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::addCountTriggers(CLSqliteDatabase *this, const char *a2)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  v31[19] = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v32 = 256;
  size_t v34 = "Count";
  int v35 = 1;
  __int16 v36 = 0;
  char v37 = 0;
  char v38 = 0;
  uint64_t v39 = 0;
  int v40 = 5;
  __int16 v41 = 0;
  char v42 = 0;
  char v43 = 0;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v27);
  size_t v5 = strlen(a2);
  id v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v28, (uint64_t)a2, v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"Counts", 6);
  std::stringbuf::str();
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::createTable((uint64_t)this, (const char *)p_str, &v34);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  memset(&__str, 0, sizeof(__str));
  std::string::operator=(&__p, &__str);
  std::stringbuf::__init_buf_ptrs[abi:ne180100]((uint64_t)v29);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  size_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v28, (uint64_t)"SELECT COUNT(*) FROM ", 21);
  size_t v9 = strlen(a2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)a2, v9);
  std::stringbuf::str();
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v10 = (sqlite3 *)&__str;
  }
  else {
    uint64_t v10 = (sqlite3 *)__str.__r_.__value_.__r.__words[0];
  }
  size_t v11 = CLSqliteDatabase::prepareStatementNoCache(this, v10);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v11)
  {
    if (sqlite3_step((sqlite3_stmt *)v11) == 100)
    {
      sqlite3_column_int((sqlite3_stmt *)v11, 0);
      goto LABEL_25;
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __int16 v13 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      LODWORD(__str.__r_.__value_.__l.__data_) = 136380675;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      BOOL v14 = "Couldn't get row count for. table: %{private}s";
      goto LABEL_24;
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __int16 v13 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      LODWORD(__str.__r_.__value_.__l.__data_) = 136380675;
      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      BOOL v14 = "Couldn't create select count statement. table: %{private}s";
LABEL_24:
      _os_log_impl(&dword_25631F000, v13, OS_LOG_TYPE_FAULT, v14, (uint8_t *)&__str, 0xCu);
    }
  }
LABEL_25:
  CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), (sqlite3 *)v11, v12);
  memset(&__str, 0, sizeof(__str));
  std::string::operator=(&__p, &__str);
  std::stringbuf::__init_buf_ptrs[abi:ne180100]((uint64_t)v29);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v28, (uint64_t)"INSERT INTO ", 12);
  size_t v16 = strlen(a2);
  __int16 v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)a2, v16);
  int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"Counts", 6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" VALUES (", 9);
  char v19 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)")", 1);
  std::stringbuf::str();
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v20 = (sqlite3 *)&__str;
  }
  else {
    int v20 = (sqlite3 *)__str.__r_.__value_.__r.__words[0];
  }
  uint64_t v21 = CLSqliteDatabase::prepareStatementNoCache(this, v20);
  uint64_t v22 = (sqlite3_stmt *)v21;
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__str.__r_.__value_.__l.__data_);
    if (v22) {
      goto LABEL_32;
    }
  }
  else if (v21)
  {
LABEL_32:
    CLSqliteDatabase::executeAndResetStatement(this, v22);
    CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), v22, v23);
    CLSqliteDatabase::addCountTrigger(this, a2, 1);
    CLSqliteDatabase::addCountTrigger(this, a2, 0);
    goto LABEL_38;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  std::string v24 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
  {
    LOWORD(__str.__r_.__value_.__l.__data_) = 0;
    _os_log_impl(&dword_25631F000, v24, OS_LOG_TYPE_FAULT, "Couldn't prepare row count insertion statement", (uint8_t *)&__str, 2u);
  }
LABEL_38:
  v27[0] = *MEMORY[0x263F8C2B8];
  uint64_t v25 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v27 + *(void *)(v27[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v28 = v25;
  v29[0] = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](v31);
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
}

void sub_2563F0898(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLSqliteDatabase::createTableIfNecessary_internal(uint64_t a1, char *a2, const char **a3, char **a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    uint64_t v12 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)int v18 = 0;
      _os_log_impl(&dword_25631F000, v12, OS_LOG_TYPE_FAULT, "Must provide a table name", v18, 2u);
    }
    return 0;
  }
  if (*(unsigned char *)(a1 + 56)) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  *(void *)int v18 = v8;
  (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  __int16 v19 = 256;
  v16[0] = 0;
  v16[1] = 0;
  uint64_t v17 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v15 = 0;
  BOOL SoftwareVersionAndSerialNumberForTable = CLSqliteDatabase::getSoftwareVersionAndSerialNumberForTable(a1, a2, (uint64_t)v16, (uint64_t)__p);
  if (!CLSqliteDatabase::tableExists_internal((CLSqliteDatabase *)a1, a2) && SoftwareVersionAndSerialNumberForTable)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    uint64_t v10 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 136380675;
      uint64_t v21 = a2;
      _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_FAULT, "Table does not exist but its metadata does. table: %{private}s", buf, 0xCu);
    }
    CLSqliteDatabase::deleteRowFromTableInfo((CLSqliteDatabase *)a1, a2);
  }
  uint64_t TableIfSchemaDiffers = CLSqliteDatabase::createTableIfSchemaDiffers(a1, a2, a3, a4, 0);
  if (TableIfSchemaDiffers) {
    CLSqliteDatabase::createRowInTableInfo((CLSqliteDatabase *)a1, a2);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
  (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  return TableIfSchemaDiffers;
}

void sub_2563F0B64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLSqliteDatabase::createIndexIfNecessary(CLSqliteDatabase *this, const char *a2, CLSqliteDatabase *a3)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  uint64_t v6 = *((void *)this + 2);
  uint64_t v69 = v6;
  (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  __int16 v70 = 256;
  if (!a3) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  memset(&v68, 0, sizeof(v68));
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v64);
  size_t v7 = strlen(a2);
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v65, (uint64_t)a2, v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"Index", 5);
  CLSqliteDatabase::indexColumnsToString(a3, &v59);
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v68.__r_.__value_.__l.__data_);
  }
  std::string v68 = v59;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v59);
  size_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v59.__r_.__value_.__r.__words[2], (uint64_t)"CREATE INDEX ", 13);
  std::stringbuf::str();
  if (v74 >= 0) {
    uint64_t v10 = v73;
  }
  else {
    uint64_t v10 = *(unsigned char **)v73;
  }
  if (v74 >= 0) {
    uint64_t v11 = HIBYTE(v74);
  }
  else {
    uint64_t v11 = *(void *)&v73[8];
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  if (SHIBYTE(v74) < 0) {
    operator delete(*(void **)v73);
  }
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v59.__r_.__value_.__r.__words[2], (uint64_t)" ON ", 4);
  size_t v13 = strlen(a2);
  BOOL v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)a2, v13);
  uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" (", 2);
  if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v16 = &v68;
  }
  else {
    size_t v16 = (std::string *)v68.__r_.__value_.__r.__words[0];
  }
  if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v68.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v68.__r_.__value_.__l.__size_;
  }
  int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)v16, size);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)")", 1);
  std::stringbuf::str();
  if (v74 >= 0) {
    __int16 v19 = v73;
  }
  else {
    __int16 v19 = *(char **)v73;
  }
  CLSqliteDatabase::getElementCreateStatement(this, "index", v19, &v56);
  if (SHIBYTE(v74) < 0) {
    operator delete(*(void **)v73);
  }
  size_t v20 = v58;
  if ((v58 & 0x80u) != 0) {
    size_t v20 = v57;
  }
  if (v20)
  {
    std::stringbuf::str();
    int v21 = SHIBYTE(v74);
    uint64_t v22 = *(void **)v73;
    if ((v58 & 0x80u) == 0) {
      size_t v23 = v58;
    }
    else {
      size_t v23 = v57;
    }
    if ((v58 & 0x80u) == 0) {
      std::string v24 = &v56;
    }
    else {
      std::string v24 = v56;
    }
    if (v74 >= 0) {
      size_t v25 = HIBYTE(v74);
    }
    else {
      size_t v25 = *(void *)&v73[8];
    }
    if (v74 >= 0) {
      __int16 v26 = v73;
    }
    else {
      __int16 v26 = *(unsigned char **)v73;
    }
    if (v25 >= v23) {
      size_t v27 = v23;
    }
    else {
      size_t v27 = v25;
    }
    BOOL v28 = memcmp(v24, v26, v27) == 0;
    BOOL v29 = v25 == v23 && v28;
    if (v21 < 0) {
      operator delete(v22);
    }
    if (v29)
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      uint32_t v30 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        std::stringbuf::str();
        int v31 = v74 >= 0 ? v73 : *(unsigned char **)v73;
        *(_DWORD *)std::string buf = 136380675;
        *(void *)&uint8_t buf[4] = v31;
        _os_log_impl(&dword_25631F000, v30, OS_LOG_TYPE_DEBUG, "Index already exists; not re-creating. index: %{private}s",
          buf,
          0xCu);
        if (SHIBYTE(v74) < 0) {
          operator delete(*(void **)v73);
        }
      }

      goto LABEL_96;
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    size_t v34 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str();
      int v35 = v72;
      __int16 v36 = *(unsigned char **)buf;
      int v37 = (char)v58;
      char v38 = (void **)v56;
      std::stringbuf::str();
      uint64_t v39 = &v56;
      if (v37 < 0) {
        uint64_t v39 = v38;
      }
      int v40 = buf;
      if (v35 < 0) {
        int v40 = v36;
      }
      *(_DWORD *)double v73 = 136381187;
      p_p = &__p;
      if (v55 < 0) {
        p_p = __p;
      }
      *(void *)&v73[4] = v40;
      *(_WORD *)&v73[12] = 2081;
      *(void *)&v73[14] = v39;
      __int16 v74 = 2081;
      uint64_t v75 = p_p;
      _os_log_impl(&dword_25631F000, v34, OS_LOG_TYPE_DEBUG, "Index already exists but is different; dropping. index: %{private}s, actual: %{private}s, expected: %{private}s",
        v73,
        0x20u);
      if (v55 < 0) {
        operator delete(__p);
      }
      if (v72 < 0) {
        operator delete(*(void **)buf);
      }
    }

    std::stringbuf::str();
    if (v74 >= 0) {
      char v42 = v73;
    }
    else {
      char v42 = *(const char **)v73;
    }
    CLSqliteDatabase::dropIndex(this, v42);
    if (SHIBYTE(v74) < 0) {
      operator delete(*(void **)v73);
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __int16 v32 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str();
      int v33 = v74 >= 0 ? v73 : *(unsigned char **)v73;
      *(_DWORD *)std::string buf = 136380675;
      *(void *)&uint8_t buf[4] = v33;
      _os_log_impl(&dword_25631F000, v32, OS_LOG_TYPE_DEBUG, "Index does not exist; creating. index: %{private}s",
        buf,
        0xCu);
      if (SHIBYTE(v74) < 0) {
        operator delete(*(void **)v73);
      }
    }
  }
  std::stringbuf::str();
  if (v74 >= 0) {
    char v43 = (sqlite3 *)v73;
  }
  else {
    char v43 = *(sqlite3 **)v73;
  }
  uint64_t v44 = CLSqliteDatabase::prepareStatementNoCache(this, v43);
  char v45 = (sqlite3_stmt *)v44;
  if (SHIBYTE(v74) < 0)
  {
    operator delete(*(void **)v73);
    if (v45) {
      goto LABEL_88;
    }
LABEL_90:
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    char v47 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      long long v48 = &v68;
      if ((v68.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        long long v48 = (std::string *)v68.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)double v73 = 136380931;
      *(void *)&v73[4] = a2;
      *(_WORD *)&v73[12] = 2080;
      *(void *)&v73[14] = v48;
      _os_log_impl(&dword_25631F000, v47, OS_LOG_TYPE_DEFAULT, "#warning Couldn't create index statement. table: %{private}s, columns: %s", v73, 0x16u);
    }
    goto LABEL_96;
  }
  if (!v44) {
    goto LABEL_90;
  }
LABEL_88:
  CLSqliteDatabase::executeAndResetStatement(this, v45);
  CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), v45, v46);
LABEL_96:
  if ((char)v58 < 0) {
    operator delete(v56);
  }
  v59.__r_.__value_.__r.__words[0] = *MEMORY[0x263F8C2B8];
  std::string::size_type v49 = v59.__r_.__value_.__r.__words[0];
  std::string::size_type v50 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  std::string::size_type v51 = *(void *)(MEMORY[0x263F8C2B8] + 64);
  *(std::string::size_type *)((char *)v59.__r_.__value_.__r.__words + *(void *)(v59.__r_.__value_.__r.__words[0] - 24)) = v51;
  std::string::size_type v52 = v50;
  v59.__r_.__value_.__r.__words[2] = v50;
  uint64_t v60 = MEMORY[0x263F8C318] + 16;
  if (v62 < 0) {
    operator delete(v61);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](&v63);
  v64[0] = v49;
  *(void *)((char *)v64 + *(void *)(v49 - 24)) = v51;
  v65[0] = v52;
  v65[1] = MEMORY[0x263F8C318] + 16;
  if (v66 < 0) {
    operator delete((void *)v65[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](&v67);
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v68.__r_.__value_.__l.__data_);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
}

void sub_2563F1420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (*(char *)(v56 - 153) < 0) {
    operator delete(*(void **)(v56 - 176));
  }

  if (a19 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a20);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a55);
  if (*(char *)(v56 - 201) < 0) {
    operator delete(*(void **)(v56 - 224));
  }
  AutoLocker::~AutoLocker((pthread_mutex_t **)(v56 - 200));
  _Unwind_Resume(a1);
}

std::string *CLSqliteDatabase::indexColumnsToString@<X0>(CLSqliteDatabase *this@<X0>, std::string *a2@<X8>)
{
  __n128 result = (std::string *)std::string::basic_string[abi:ne180100]<0>(a2, "");
  if (this)
  {
    uint64_t v6 = *(const std::string::value_type **)this;
    if (*(void *)this)
    {
      uint64_t v7 = 0;
      do
      {
        if (v7)
        {
          std::string::append(a2, ", ");
          uint64_t v6 = (const std::string::value_type *)*((void *)this + v7);
        }
        __n128 result = std::string::append(a2, v6);
        uint64_t v8 = (char *)this + 8 * v7++;
        uint64_t v6 = (const std::string::value_type *)*((void *)v8 + 1);
      }
      while (v6);
    }
  }
  return result;
}

void sub_2563F15A0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLSqliteDatabase::dropIndex(CLSqliteDatabase *this, const char *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  v17[19] = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v18 = 256;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v14);
  size_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"DROP INDEX ", 11);
  size_t v6 = strlen(a2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)a2, v6);
  std::stringbuf::str();
  if (v20 >= 0) {
    uint64_t v7 = (sqlite3 *)buf;
  }
  else {
    uint64_t v7 = *(sqlite3 **)buf;
  }
  uint64_t v8 = CLSqliteDatabase::prepareStatementNoCache(this, v7);
  size_t v9 = (sqlite3_stmt *)v8;
  if (v20 < 0)
  {
    operator delete(*(void **)buf);
    if (v9) {
      goto LABEL_6;
    }
  }
  else if (v8)
  {
LABEL_6:
    CLSqliteDatabase::executeAndResetStatement(this, v9);
    CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), v9, v10);
    goto LABEL_12;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v11 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136380675;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_25631F000, v11, OS_LOG_TYPE_DEFAULT, "#warning Couldn't create drop index statement. index: %{private}s", buf, 0xCu);
  }
LABEL_12:
  v14[0] = *MEMORY[0x263F8C2B8];
  uint64_t v12 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v14 + *(void *)(v14[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v15[0] = v12;
  v15[1] = MEMORY[0x263F8C318] + 16;
  if (v16 < 0) {
    operator delete((void *)v15[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](v17);
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
}

void sub_2563F18B0(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

BOOL CLSqliteDatabase::executeAndResetStatement(CLSqliteDatabase *this, sqlite3_stmt *a2)
{
  uint64_t v4 = *((void *)this + 2);
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  size_t v5 = (CLSqliteDatabase *)sqlite3_step(a2);
  int v6 = (int)v5;
  BOOL v7 = v5 == 101;
  if (v5 != 101)
  {
    CLSqliteDatabase::displaySqlResult(v5, "sqlite3_step()", (int)v5, a2);
    CLSqliteDatabase::handleSqlError(*((sqlite3 **)this + 1), (uint64_t)this + 88, *((unsigned __int8 *)this + 56), v6);
  }
  uint64_t v8 = (CLSqliteDatabase *)sqlite3_reset(a2);
  int v9 = (int)v8;
  if (v8)
  {
    CLSqliteDatabase::displaySqlResult(v8, "sqlite3_reset()", (int)v8, a2);
    CLSqliteDatabase::handleSqlError(*((sqlite3 **)this + 1), (uint64_t)this + 88, *((unsigned __int8 *)this + 56), v9);
    BOOL v7 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  return v7;
}

void sub_2563F1A24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  AutoLocker::~AutoLocker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::dropTrigger(CLSqliteDatabase *this, char *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  v22[19] = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v23 = 256;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v19);
  size_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"DROP TRIGGER ", 13);
  size_t v6 = strlen(a2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)a2, v6);
  CLSqliteDatabase::getElementCreateStatement(this, "trigger", a2, &buf);
  if (v25 < 0)
  {
    uint64_t v11 = *((void *)&buf + 1);
    operator delete((void *)buf);
    if (v11)
    {
LABEL_3:
      std::stringbuf::str();
      if (v25 >= 0) {
        p_long long buf = (sqlite3 *)&buf;
      }
      else {
        p_long long buf = (sqlite3 *)buf;
      }
      uint64_t v8 = CLSqliteDatabase::prepareStatementNoCache(this, p_buf);
      int v9 = (sqlite3_stmt *)v8;
      if (v25 < 0)
      {
        operator delete((void *)buf);
        if (v9) {
          goto LABEL_8;
        }
      }
      else if (v8)
      {
LABEL_8:
        CLSqliteDatabase::executeAndResetStatement(this, v9);
        CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), v9, v10);
        goto LABEL_20;
      }
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      uint64_t v16 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = a2;
        size_t v13 = "#warning Couldn't create drop trigger statement. trigger: %s";
        BOOL v14 = v16;
        os_log_type_t v15 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_19;
      }
      goto LABEL_20;
    }
  }
  else if (v25)
  {
    goto LABEL_3;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v12 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = a2;
    size_t v13 = "Trigger does not exist. trigger: %s";
    BOOL v14 = v12;
    os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
LABEL_19:
    _os_log_impl(&dword_25631F000, v14, v15, v13, (uint8_t *)&buf, 0xCu);
  }
LABEL_20:
  v19[0] = *MEMORY[0x263F8C2B8];
  uint64_t v17 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v19 + *(void *)(v19[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v20[0] = v17;
  v20[1] = MEMORY[0x263F8C318] + 16;
  if (v21 < 0) {
    operator delete((void *)v20[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](v22);
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
}

void sub_2563F1DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (*(char *)(v9 - 73) < 0) {
    operator delete(*(void **)(v9 - 96));
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a9);
  AutoLocker::~AutoLocker((pthread_mutex_t **)(v9 - 120));
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::dropTable_internal(CLSqliteDatabase *this, char *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  size_t v5 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136380675;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_DEFAULT, "Dropping table. table: %{private}s", (uint8_t *)&buf, 0xCu);
  }
  CLSqliteDatabase::deleteRowFromTableInfo(this, a2);
  std::string::basic_string[abi:ne180100]<0>(&buf, "DROP TABLE IF EXISTS ");
  std::string::append(&buf, a2);
  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_std::string buf = (sqlite3 *)&buf;
  }
  else {
    p_std::string buf = (sqlite3 *)buf.__r_.__value_.__r.__words[0];
  }
  BOOL v7 = CLSqliteDatabase::prepareStatementNoCache(this, p_buf);
  CLSqliteDatabase::executeAndResetStatement(this, (sqlite3_stmt *)v7);
  CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), (sqlite3 *)v7, v8);
  CLSqliteDatabase::reduceFreePages(this, 0x7FFFFFFFFFFFFFFFLL);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
}

void sub_2563F1FD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLSqliteDatabase::addCountTrigger(CLSqliteDatabase *this, const char *a2, int a3)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v6 = *((void *)this + 2);
  v37[19] = v6;
  (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  __int16 v38 = 256;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v34);
  if (a3) {
    BOOL v7 = "Increment";
  }
  else {
    BOOL v7 = "Decrement";
  }
  if (a3) {
    uint64_t v8 = "INSERT";
  }
  else {
    uint64_t v8 = "DELETE";
  }
  if (a3) {
    uint64_t v9 = "+";
  }
  else {
    uint64_t v9 = "-";
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)"CREATE TRIGGER IF NOT EXISTS ", 29);
  size_t v10 = strlen(a2);
  uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)a2, v10);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)v7, 9);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"RowCount", 8);
  size_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)" AFTER ", 7);
  BOOL v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)v8, 6);
  os_log_type_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" ON ", 4);
  size_t v16 = strlen(a2);
  uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)a2, v16);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" FOR EACH ROW BEGIN", 19);
  __int16 v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)" UPDATE ", 8);
  size_t v19 = strlen(a2);
  char v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)a2, v19);
  char v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"Counts", 6);
  uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)" SET ", 5);
  __int16 v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"Count", 5);
  std::string v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"=", 1);
  char v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"Count", 5);
  uint64_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)v9, 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"1 WHERE rowid=1; END", 20);
  std::stringbuf::str();
  if (v40 >= 0) {
    size_t v27 = (sqlite3 *)buf;
  }
  else {
    size_t v27 = *(sqlite3 **)buf;
  }
  BOOL v28 = CLSqliteDatabase::prepareStatementNoCache(this, v27);
  BOOL v29 = (sqlite3_stmt *)v28;
  if (v40 < 0)
  {
    operator delete(*(void **)buf);
    if (v29) {
      goto LABEL_15;
    }
  }
  else if (v28)
  {
LABEL_15:
    CLSqliteDatabase::executeAndResetStatement(this, v29);
    CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), v29, v30);
    goto LABEL_21;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  int v31 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::string buf = 136380675;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_25631F000, v31, OS_LOG_TYPE_FAULT, "Couldn't create add count trigger statement. table: %{private}s", buf, 0xCu);
  }
LABEL_21:
  v34[0] = *MEMORY[0x263F8C2B8];
  uint64_t v32 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v34 + *(void *)(v34[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v35[0] = v32;
  v35[1] = MEMORY[0x263F8C318] + 16;
  if (v36 < 0) {
    operator delete((void *)v35[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](v37);
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
}

void sub_2563F246C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLSqliteDatabase::createTable(uint64_t a1, const char *a2, const char **a3)
{
  v38[19] = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v31 = v6;
  (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  __int16 v32 = 256;
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  BOOL v7 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::string buf = 136380675;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_DEBUG, "Creating table. table: %{private}s", buf, 0xCu);
  }
  if (a3 && *a3)
  {
    unsigned int v8 = 0;
    uint64_t v9 = (uint64_t *)(a3 + 6);
    do
    {
      v8 += *((unsigned __int8 *)v9 - 36);
      uint64_t v10 = *v9;
      v9 += 6;
    }
    while (v10);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
    uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)"CREATE TABLE ", 13);
    size_t v12 = strlen(a2);
    size_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)a2, v12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" (", 2);
    CLSqliteDatabase::columnsToString(a3, 1, v8 < 2, (uint64_t)&__p);
    if ((v30 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if ((v30 & 0x80u) == 0) {
      uint64_t v15 = v30;
    }
    else {
      uint64_t v15 = v29;
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)p_p, v15);
    if ((char)v30 < 0) {
      operator delete(__p);
    }
    if (v8 >= 2)
    {
      size_t v16 = (const char *)&__p;
      CLSqliteDatabase::getPrimaryKeyDefinitionString((uint64_t)a3, &__p);
      if ((v30 & 0x80u) != 0) {
        size_t v16 = (const char *)__p;
      }
      size_t v17 = strlen(v16);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)v16, v17);
      if ((char)v30 < 0) {
        operator delete(__p);
      }
    }
    CLSqliteDatabase::getForeignKeyDefinitionString(a1, (uint64_t)a3, &__p);
    if ((v30 & 0x80u) == 0) {
      __int16 v18 = &__p;
    }
    else {
      __int16 v18 = __p;
    }
    if ((v30 & 0x80u) == 0) {
      uint64_t v19 = v30;
    }
    else {
      uint64_t v19 = v29;
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)v18, v19);
    if ((char)v30 < 0) {
      operator delete(__p);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)")", 1);
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    char v20 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str();
      char v21 = (v30 & 0x80u) == 0 ? &__p : (void **)__p;
      *(_DWORD *)int v33 = 136315138;
      size_t v34 = v21;
      _os_log_impl(&dword_25631F000, v20, OS_LOG_TYPE_DEBUG, "Schema statement created. schema: %s", v33, 0xCu);
      if ((char)v30 < 0) {
        operator delete(__p);
      }
    }

    std::stringbuf::str();
    if ((v30 & 0x80u) == 0) {
      uint64_t v22 = (sqlite3 *)&__p;
    }
    else {
      uint64_t v22 = (sqlite3 *)__p;
    }
    __int16 v23 = CLSqliteDatabase::prepareStatementNoCache((CLSqliteDatabase *)a1, v22);
    std::string v24 = (sqlite3_stmt *)v23;
    if ((char)v30 < 0)
    {
      operator delete(__p);
      if (!v24)
      {
LABEL_46:
        *(void *)std::string buf = *MEMORY[0x263F8C2B8];
        uint64_t v26 = *(void *)(MEMORY[0x263F8C2B8] + 72);
        *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x263F8C2B8] + 64);
        v36[0] = v26;
        v36[1] = MEMORY[0x263F8C318] + 16;
        if (v37 < 0) {
          operator delete((void *)v36[9]);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x25A2A6280](v38);
        return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
      }
    }
    else if (!v23)
    {
      goto LABEL_46;
    }
    sqlite3_step(v24);
    CLSqliteDatabase::finalizeStatement(*(CLSqliteDatabase **)(a1 + 8), v24, v25);
    goto LABEL_46;
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
}

void sub_2563F298C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, pthread_mutex_t *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a20);
  AutoLocker::~AutoLocker(&a15);
  _Unwind_Resume(a1);
}

BOOL CLSqliteDatabase::bind(CLSqliteDatabase *this, sqlite3_stmt *a2, char *__s, const char *a4)
{
  int v5 = (int)a2;
  uint64_t v19 = *MEMORY[0x263EF8340];
  int v7 = strlen(__s);
  int v8 = sqlite3_bind_text((sqlite3_stmt *)this, v5, __s, v7, 0);
  if (v8)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    uint64_t v9 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
    {
      int v11 = 136381443;
      size_t v12 = __s;
      __int16 v13 = 1024;
      int v14 = v5;
      __int16 v15 = 1024;
      int v16 = v8;
      __int16 v17 = 2081;
      __int16 v18 = sqlite3_sql((sqlite3_stmt *)this);
      _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_FAULT, "Could not bind. value: %{private}s, index: %d, sqlite_rc: %d, query: %{private}s", (uint8_t *)&v11, 0x22u);
    }
  }
  return v8 == 0;
}

void sub_2563F2B4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL CLSqliteDatabase::tableExists_internal(CLSqliteDatabase *this, const char *a2)
{
  uint64_t v4 = *((void *)this + 2);
  v21[19] = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v22 = 256;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v18);
  int v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"SELECT name FROM ", 17);
  uint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"sqlite_master", 13);
  int v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" WHERE name='", 13);
  size_t v8 = strlen(a2);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)a2, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"';", 2);
  std::stringbuf::str();
  if (v17 >= 0) {
    p_p = (sqlite3 *)&__p;
  }
  else {
    p_p = (sqlite3 *)__p;
  }
  int v11 = CLSqliteDatabase::prepareStatementNoCache(this, p_p);
  if (v17 < 0) {
    operator delete(__p);
  }
  int v12 = sqlite3_step((sqlite3_stmt *)v11);
  CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), (sqlite3 *)v11, v13);
  v18[0] = *MEMORY[0x263F8C2B8];
  uint64_t v14 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v18 + *(void *)(v18[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v19[0] = v14;
  v19[1] = MEMORY[0x263F8C318] + 16;
  if (v20 < 0) {
    operator delete((void *)v19[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](v21);
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  return v12 == 100;
}

void sub_2563F2DE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
  AutoLocker::~AutoLocker((pthread_mutex_t **)(v16 - 88));
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::getPrimaryKeyDefinitionString@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result;
  if (!*(unsigned char *)(result + 12))
  {
    int v6 = 1;
    uint64_t v5 = result;
    while (*(void *)v5)
    {
      int v7 = *(unsigned __int8 *)(v5 + 60);
      ++v6;
      v5 += 48;
      if (v7)
      {
        unsigned int v4 = v6;
        goto LABEL_7;
      }
    }
    goto LABEL_15;
  }
  unsigned int v4 = 1;
  uint64_t v5 = result;
LABEL_7:
  if (!*(void *)v5)
  {
LABEL_15:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return result;
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
  size_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)", PRIMARY KEY (", 15);
  uint64_t v9 = *(const char **)v5;
  size_t v10 = strlen(v9);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)v9, v10);
  uint64_t v11 = v2 + 48 * v4;
  if (*(void *)v11)
  {
    do
    {
      if (*(unsigned char *)(v11 + 12))
      {
        int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)", ", 2);
        size_t v13 = strlen(*(const char **)v11);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, *(void *)v11, v13);
      }
      uint64_t v14 = *(void *)(v11 + 48);
      v11 += 48;
    }
    while (v14);
  }
  char v20 = 41;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)&v20, 1);
  std::stringbuf::str();
  v16[0] = *MEMORY[0x263F8C2B8];
  uint64_t v15 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v16 + *(void *)(v16[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v17[0] = v15;
  v17[1] = MEMORY[0x263F8C318] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x25A2A6280](&v19);
}

void sub_2563F308C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void CLSqliteDatabase::columnsToString(const char **a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  v28[2] = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>((void *)a4, "");
  int v7 = *a1;
  if (*a1)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    size_t v10 = a1;
    do
    {
      if (v8)
      {
        std::string::append((std::string *)a4, ", ");
        int v7 = *v10;
      }
      if (*(char *)(a4 + 23) >= 0) {
        size_t v11 = *(unsigned __int8 *)(a4 + 23);
      }
      else {
        size_t v11 = *(void *)(a4 + 8);
      }
      size_t v12 = strlen(v7);
      std::string::basic_string[abi:ne180100]((uint64_t)&v27, v11 + v12);
      if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v13 = &v27;
      }
      else {
        size_t v13 = (std::string *)v27.__r_.__value_.__r.__words[0];
      }
      if (v11)
      {
        if (*(char *)(a4 + 23) >= 0) {
          uint64_t v14 = (const void *)a4;
        }
        else {
          uint64_t v14 = *(const void **)a4;
        }
        memmove(v13, v14, v11);
      }
      uint64_t v15 = (char *)v13 + v11;
      if (v12) {
        memmove(v15, v7, v12);
      }
      v15[v12] = 0;
      if (*(char *)(a4 + 23) < 0) {
        operator delete(*(void **)a4);
      }
      *(std::string *)a4 = v27;
      if (a2)
      {
        if (*(char *)(a4 + 23) >= 0) {
          size_t v16 = *(unsigned __int8 *)(a4 + 23);
        }
        else {
          size_t v16 = *(void *)(a4 + 8);
        }
        std::string::basic_string[abi:ne180100]((uint64_t)&v27, v16 + 1);
        if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          char v17 = &v27;
        }
        else {
          char v17 = (std::string *)v27.__r_.__value_.__r.__words[0];
        }
        if (v16)
        {
          if (*(char *)(a4 + 23) >= 0) {
            char v18 = (const void *)a4;
          }
          else {
            char v18 = *(const void **)a4;
          }
          memmove(v17, v18, v16);
        }
        *(_WORD *)((char *)&v17->__r_.__value_.__l.__data_ + v16) = 32;
        int v19 = (int)a1[6 * v8 + 1];
        char v20 = "INTEGER";
        if (v19 != 1)
        {
          uint64_t v21 = 0;
          do
          {
            uint64_t v22 = v21;
            v21 += 16;
          }
          while (v21 != 80 && *(_DWORD *)((char *)&unk_2653F9BC8 + v22 + 16) != v19);
          char v20 = *(const std::string::value_type **)((char *)&unk_2653F9BC8 + v22 + 24);
        }
        __int16 v23 = std::string::append(&v27, v20);
        std::string::size_type v24 = v23->__r_.__value_.__r.__words[0];
        v28[0] = v23->__r_.__value_.__l.__size_;
        *(void *)((char *)v28 + 7) = *(std::string::size_type *)((char *)&v23->__r_.__value_.__r.__words[1] + 7);
        char v25 = HIBYTE(v23->__r_.__value_.__r.__words[2]);
        v23->__r_.__value_.__l.__size_ = 0;
        v23->__r_.__value_.__r.__words[2] = 0;
        v23->__r_.__value_.__r.__words[0] = 0;
        if (*(char *)(a4 + 23) < 0) {
          operator delete(*(void **)a4);
        }
        *(void *)a4 = v24;
        *(void *)(a4 + 8) = v28[0];
        *(void *)(a4 + 15) = *(void *)((char *)v28 + 7);
        *(unsigned char *)(a4 + 23) = v25;
        if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v27.__r_.__value_.__l.__data_);
        }
      }
      if (((a3 ^ 1 | v9) & 1) == 0)
      {
        if (BYTE4(a1[6 * v8 + 1]))
        {
          std::string::append((std::string *)a4, " PRIMARY KEY");
          if (BYTE5(a1[6 * v8 + 1])) {
            std::string::append((std::string *)a4, " AUTOINCREMENT");
          }
          int v9 = 1;
        }
        else
        {
          int v9 = 0;
        }
      }
      ++v8;
      size_t v10 = &a1[6 * v8];
      int v7 = *v10;
    }
    while (*v10);
  }
}

void sub_2563F3388(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLSqliteDatabase::getForeignKeyDefinitionString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v37);
  if (a2)
  {
    int v33 = a3;
    if (*(void *)a2)
    {
      do
      {
        if (*(unsigned char *)(a2 + 40))
        {
          if (!CLSqliteDatabase::isForeignKeyReferenceValid(a1, a2))
          {
            if (onceToken_MicroLocation_Default != -1) {
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
            }
            a3 = v33;
            uint64_t v30 = logObject_MicroLocation_Default;
            if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
            {
              LOWORD(__p) = 0;
              std::string v27 = "Foreign key reference and index check failed";
              BOOL v28 = v30;
              os_log_type_t v29 = OS_LOG_TYPE_FAULT;
LABEL_31:
              _os_log_impl(&dword_25631F000, v28, v29, v27, (uint8_t *)&__p, 2u);
            }
            goto LABEL_32;
          }
          int v7 = *(const char **)(a2 + 16);
          int v6 = *(const char **)(a2 + 24);
          uint64_t v8 = *(int *)(a2 + 32);
          uint64_t v9 = *(int *)(a2 + 36);
          size_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)", FOREIGN KEY(", 14);
          size_t v11 = strlen(*(const char **)a2);
          size_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, *(void *)a2, v11);
          size_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)") REFERENCES ", 13);
          size_t v14 = strlen(v7);
          uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)v7, v14);
          size_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"(", 1);
          size_t v17 = strlen(v6);
          char v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v6, v17);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)")", 1);
          int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)" ON DELETE ", 11);
          std::string::basic_string[abi:ne180100]<0>(&__p, off_2653F9C28[v8]);
          if ((v36 & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = __p;
          }
          if ((v36 & 0x80u) == 0) {
            uint64_t v21 = v36;
          }
          else {
            uint64_t v21 = v35;
          }
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)p_p, v21);
          if ((char)v36 < 0) {
            operator delete(__p);
          }
          uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)" ON UPDATE ", 11);
          std::string::basic_string[abi:ne180100]<0>(&__p, off_2653F9C28[v9]);
          if ((v36 & 0x80u) == 0) {
            __int16 v23 = &__p;
          }
          else {
            __int16 v23 = __p;
          }
          if ((v36 & 0x80u) == 0) {
            uint64_t v24 = v36;
          }
          else {
            uint64_t v24 = v35;
          }
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)v23, v24);
          if ((char)v36 < 0) {
            operator delete(__p);
          }
        }
        uint64_t v25 = *(void *)(a2 + 48);
        a2 += 48;
      }
      while (v25);
    }
    std::stringbuf::str();
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    uint64_t v26 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(__p) = 0;
      std::string v27 = "getForeignKeyDefinitionString: NULL column definition";
      BOOL v28 = v26;
      os_log_type_t v29 = OS_LOG_TYPE_DEBUG;
      goto LABEL_31;
    }
LABEL_32:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  v37[0] = *MEMORY[0x263F8C2B8];
  uint64_t v31 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v37 + *(void *)(v37[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v38[0] = v31;
  v38[1] = MEMORY[0x263F8C318] + 16;
  if (v39 < 0) {
    operator delete((void *)v38[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x25A2A6280](&v40);
}

void sub_2563F37B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

BOOL CLSqliteDatabase::getSoftwareVersionAndSerialNumberForTable(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  uint64_t v9 = CLSqliteDatabase::prepareSelectStatement((CLSqliteDatabase *)a1, (const char **)off_2653F9B68, "TableInfo", "TableName");
  CLSqliteDatabase::bind(v9, (sqlite3_stmt *)1, a2, v10);
  int v12 = sqlite3_step((sqlite3_stmt *)v9);
  if (v12 == 100)
  {
    size_t v13 = (char *)sqlite3_column_text((sqlite3_stmt *)v9, 0);
    std::string::basic_string[abi:ne180100]<0>(buf, v13);
    if (*(char *)(a3 + 23) < 0) {
      operator delete(*(void **)a3);
    }
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(void *)(a3 + 16) = *(void *)&buf[16];
    size_t v14 = (char *)sqlite3_column_text((sqlite3_stmt *)v9, 1);
    std::string::basic_string[abi:ne180100]<0>(buf, v14);
    if (*(char *)(a4 + 23) < 0) {
      operator delete(*(void **)a4);
    }
    *(_OWORD *)a4 = *(_OWORD *)buf;
    *(void *)(a4 + 16) = *(void *)&buf[16];
  }
  CLSqliteDatabase::finalizeStatement(*(CLSqliteDatabase **)(a1 + 8), (sqlite3 *)v9, v11);
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v15 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    size_t v16 = (void *)(a1 + 88);
    if (*(char *)(a1 + 111) < 0) {
      size_t v16 = (void *)*v16;
    }
    if (*(char *)(a3 + 23) >= 0) {
      size_t v17 = (void *)a3;
    }
    else {
      size_t v17 = *(void **)a3;
    }
    if (*(char *)(a4 + 23) >= 0) {
      char v18 = (void *)a4;
    }
    else {
      char v18 = *(void **)a4;
    }
    *(_DWORD *)std::string buf = 136381699;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v16;
    *(_WORD *)&buf[22] = 1024;
    int v21 = v12;
    __int16 v22 = 2080;
    __int16 v23 = v17;
    __int16 v24 = 2081;
    uint64_t v25 = v18;
    _os_log_impl(&dword_25631F000, v15, OS_LOG_TYPE_DEBUG, "version and serial number. table: %{private}s, path: %s, sqlite_rc: %d, version: %s, serial number: %{private}s", buf, 0x30u);
  }
  (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  return v12 == 100;
}

void sub_2563F3A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

CLSqliteDatabase *CLSqliteDatabase::prepareSelectStatement(CLSqliteDatabase *this, const char **a2, const char *a3, const char *a4)
{
  v37[19] = *MEMORY[0x263EF8340];
  uint64_t v8 = *((void *)this + 2);
  uint64_t v29 = v8;
  (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  __int16 v30 = 256;
  if (a3 && a4 && *a2)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
    uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33[2], (uint64_t)"SELECT ", 7);
    size_t v10 = strlen(*a2);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)*a2, v10);
    if (a2[1])
    {
      size_t v11 = a2 + 2;
      do
      {
        int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33[2], (uint64_t)", ", 2);
        size_t v13 = strlen(*(v11 - 1));
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)*(v11 - 1), v13);
      }
      while (*v11++);
    }
    uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33[2], (uint64_t)" FROM ", 6);
    size_t v16 = strlen(a3);
    size_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)a3, v16);
    char v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" WHERE ", 7);
    size_t v19 = strlen(a4);
    char v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)a4, v19);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"=?", 2);
    std::stringbuf::str();
    if (v28 >= 0) {
      p_p = (sqlite3 *)&__p;
    }
    else {
      p_p = (sqlite3 *)__p;
    }
    __int16 v22 = CLSqliteDatabase::prepareStatementNoCache(this, p_p);
    if (v28 < 0) {
      operator delete(__p);
    }
    *(void *)std::string buf = *MEMORY[0x263F8C2B8];
    uint64_t v23 = *(void *)(MEMORY[0x263F8C2B8] + 72);
    *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x263F8C2B8] + 64);
    *(void *)&v33[2] = v23;
    size_t v34 = (const char *)(MEMORY[0x263F8C318] + 16);
    if (v36 < 0) {
      operator delete(v35);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x25A2A6280](v37);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __int16 v24 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      uint64_t v25 = *a2;
      *(_DWORD *)std::string buf = 136381187;
      *(void *)&uint8_t buf[4] = a3;
      __int16 v32 = 2080;
      *(void *)int v33 = v25;
      *(_WORD *)&v33[8] = 2080;
      size_t v34 = a4;
      _os_log_impl(&dword_25631F000, v24, OS_LOG_TYPE_FAULT, "Invalid parameters. table: %{private}s, columnNames[0]: %s, key: %s", buf, 0x20u);
    }
    __int16 v22 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  return v22;
}

void sub_2563F3E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, pthread_mutex_t *a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a18);
  AutoLocker::~AutoLocker(&a15);
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::createRowInTableInfo(CLSqliteDatabase *this, char *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  uint64_t v18 = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v19 = 256;
  std::string::basic_string[abi:ne180100]<0>(v16, "");
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  inserted = CLSqliteDatabase::prepareInsertStatement(this, "TableInfo", (const char **)off_2653F9B80, 1);
  CLSqliteDatabase::bind(inserted, (sqlite3_stmt *)1, a2, v6);
  if (v17 >= 0) {
    uint64_t v8 = (char *)v16;
  }
  else {
    uint64_t v8 = (char *)v16[0];
  }
  CLSqliteDatabase::bind(inserted, (sqlite3_stmt *)2, v8, v7);
  if (v15 >= 0) {
    size_t v10 = (char *)__p;
  }
  else {
    size_t v10 = (char *)__p[0];
  }
  CLSqliteDatabase::bind(inserted, (sqlite3_stmt *)3, v10, v9);
  CLSqliteDatabase::executeAndResetStatement(this, (sqlite3_stmt *)inserted);
  CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), (sqlite3 *)inserted, v11);
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  int v12 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::string buf = 136380675;
    int v21 = a2;
    _os_log_impl(&dword_25631F000, v12, OS_LOG_TYPE_DEBUG, "Created row in TableInfo. table: %{private}s", buf, 0xCu);
  }
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  if (v17 < 0) {
    operator delete(v16[0]);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
}

void sub_2563F40B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

CLSqliteDatabase *CLSqliteDatabase::prepareInsertStatement(CLSqliteDatabase *this, const char *a2, const char **a3, int a4)
{
  v34[19] = *MEMORY[0x263EF8340];
  uint64_t v8 = *((void *)this + 2);
  uint64_t v28 = v8;
  (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  __int16 v29 = 256;
  if (a2 && *a3)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)((char *)v32 + 2), (uint64_t)"INSERT ", 7);
    if (a4) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)((char *)v32 + 2), (uint64_t)"OR REPLACE ", 11);
    }
    uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)((char *)v32 + 2), (uint64_t)"INTO ", 5);
    size_t v10 = strlen(a2);
    size_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)a2, v10);
    int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" (", 2);
    size_t v13 = strlen(*a3);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)*a3, v13);
    if (a3[1])
    {
      uint64_t v14 = 0;
      do
      {
        char v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)((char *)v32 + 2), (uint64_t)", ", 2);
        size_t v16 = strlen(a3[v14 + 1]);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)a3[v14 + 1], v16);
      }
      while (a3[v14++ + 2]);
      int v18 = v14 + 1;
    }
    else
    {
      int v18 = 1;
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)((char *)v32 + 2), (uint64_t)") VALUES (?", 11);
    if (v18 >= 2)
    {
      int v22 = v18 + 1;
      do
      {
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)((char *)v32 + 2), (uint64_t)", ?", 3);
        --v22;
      }
      while (v22 > 2);
    }
    LOBYTE(__p[0]) = 41;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)((char *)v32 + 2), (uint64_t)__p, 1);
    std::stringbuf::str();
    if (v27 >= 0) {
      uint64_t v23 = __p;
    }
    else {
      uint64_t v23 = (void **)__p[0];
    }
    int v21 = CLSqliteDatabase::prepareStatementNoCache(this, (sqlite3 *)v23);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    *(void *)std::string buf = *MEMORY[0x263F8C2B8];
    uint64_t v24 = *(void *)(MEMORY[0x263F8C2B8] + 72);
    *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x263F8C2B8] + 64);
    *(void *)((char *)v32 + 2) = v24;
    *(void *)((char *)&v32[1] + 2) = MEMORY[0x263F8C318] + 16;
    if (v33 < 0) {
      operator delete(*(void **)((char *)&v32[9] + 2));
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x25A2A6280](v34);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __int16 v19 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      char v20 = *a3;
      *(_DWORD *)std::string buf = 136380931;
      *(void *)&uint8_t buf[4] = a2;
      __int16 v31 = 2080;
      v32[0] = v20;
      _os_log_impl(&dword_25631F000, v19, OS_LOG_TYPE_FAULT, "Invalid parameters. table: %{private}s, columnNames[0]: %s", buf, 0x16u);
    }
    int v21 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  return v21;
}

void sub_2563F452C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, pthread_mutex_t *a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a18);
  AutoLocker::~AutoLocker(&a15);
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::deleteRowFromTableInfo(CLSqliteDatabase *this, char *a2)
{
  uint64_t v8 = *((void *)this + 2);
  (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  uint64_t v4 = CLSqliteDatabase::prepareDeleteStatement(this, "TableInfo", "TableName");
  CLSqliteDatabase::bind(v4, (sqlite3_stmt *)1, a2, v5);
  CLSqliteDatabase::executeAndResetStatement(this, (sqlite3_stmt *)v4);
  CLSqliteDatabase::finalizeStatement(*((CLSqliteDatabase **)this + 1), (sqlite3 *)v4, v6);
  return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 24))(v8);
}

void sub_2563F4660(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  AutoLocker::~AutoLocker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

CLSqliteDatabase *CLSqliteDatabase::prepareDeleteStatement(CLSqliteDatabase *this, const char *a2, const char *a3)
{
  v28[19] = *MEMORY[0x263EF8340];
  uint64_t v6 = *((void *)this + 2);
  uint64_t v20 = v6;
  (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  __int16 v21 = 256;
  if (a2 && a3)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
    int v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v24[2], (uint64_t)"DELETE FROM ", 12);
    size_t v8 = strlen(a2);
    uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)a2, v8);
    size_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" WHERE ", 7);
    size_t v11 = strlen(a3);
    int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)a3, v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"=?", 2);
    std::stringbuf::str();
    if (v19 >= 0) {
      p_p = (sqlite3 *)&__p;
    }
    else {
      p_p = (sqlite3 *)__p;
    }
    uint64_t v14 = CLSqliteDatabase::prepareStatementNoCache(this, p_p);
    if (v19 < 0) {
      operator delete(__p);
    }
    *(void *)std::string buf = *MEMORY[0x263F8C2B8];
    uint64_t v15 = *(void *)(MEMORY[0x263F8C2B8] + 72);
    *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x263F8C2B8] + 64);
    *(void *)&v24[2] = v15;
    uint64_t v25 = MEMORY[0x263F8C318] + 16;
    if (v27 < 0) {
      operator delete(v26);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x25A2A6280](v28);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    size_t v16 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 136380931;
      *(void *)&uint8_t buf[4] = a2;
      __int16 v23 = 2080;
      *(void *)uint64_t v24 = a3;
      _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_FAULT, "Invalid parameters. table: %{private}s, key: %s", buf, 0x16u);
    }
    uint64_t v14 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  return v14;
}

void sub_2563F49A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, pthread_mutex_t *a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a18);
  AutoLocker::~AutoLocker(&a15);
  _Unwind_Resume(a1);
}

CLSqliteDatabase *CLSqliteDatabase::prepareStatement(CLSqliteDatabase *this, sqlite3 *__s, const char *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (this)
  {
    uint64_t v4 = this;
    size_t v11 = 0;
    ppStmt = 0;
    int v5 = strlen((const char *)__s);
    int v6 = sqlite3_prepare_v2((sqlite3 *)v4, (const char *)__s, v5, &ppStmt, &v11);
    if (v6)
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      int v7 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      {
        size_t v8 = sqlite3_errmsg((sqlite3 *)v4);
        *(_DWORD *)std::string buf = 136381187;
        *(void *)&uint8_t buf[4] = __s;
        __int16 v14 = 1024;
        int v15 = v6;
        __int16 v16 = 2081;
        char v17 = v8;
        _os_log_impl(&dword_25631F000, v7, OS_LOG_TYPE_FAULT, "Could not prepare statement. query: %{private}s, sqlite_rc: %d, errmsg: %{private}s", buf, 0x1Cu);
      }

      uint64_t v9 = sqlite3_db_filename((sqlite3 *)v4, 0);
      if (v9) {
        size_t v10 = (char *)v9;
      }
      else {
        size_t v10 = "";
      }
      std::string::basic_string[abi:ne180100]<0>(buf, v10);
      CLSqliteDatabase::handleSqlError((sqlite3 *)v4, (uint64_t)buf, 0, v6);
      if (SBYTE3(v17) < 0) {
        operator delete(*(void **)buf);
      }
      return 0;
    }
    else
    {
      return (CLSqliteDatabase *)ppStmt;
    }
  }
  return this;
}

void sub_2563F4B74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  _Unwind_Resume(a1);
}

void CLSqliteDatabase::prepareScopedStatement(CLSqliteDatabase *this, sqlite3 *a2)
{
}

void sub_2563F4C84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x25A2A6340](v2, 0xA1C409BE6959DLL);
  AutoLocker::~AutoLocker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

BOOL CLSqliteDatabase::isDatabaseValid(CLSqliteDatabase *this)
{
  return *((void *)this + 1) != 0;
}

uint64_t CLSqliteDatabase::vacuum(CLSqliteDatabase *this, sqlite3 *a2)
{
  uint64_t v7 = 0;
  size_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 0;
  uint64_t v3 = +[ULTransactionManager shared];
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 3221225472;
  v6[2] = ___ZN16CLSqliteDatabase6vacuumEP7sqlite3_block_invoke;
  v6[3] = &unk_2653F9128;
  void v6[4] = &v7;
  void v6[5] = this;
  [v3 performUnderTransaction:@"com.apple.milod.sqlitedb.vacuum" block:v6];

  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_2563F4D9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL ___ZN16CLSqliteDatabase6vacuumEP7sqlite3_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  *(void *)uint64_t v24 = 0;
  int v5 = (CLSqliteDatabase **)(a1 + 40);
  if (CLSqliteDatabase::execAndGetValue(*(CLSqliteDatabase **)(a1 + 40), (sqlite3 *)"pragma page_count;", v24, a4)) {
    uint64_t v7 = *(void *)v24;
  }
  else {
    uint64_t v7 = -1;
  }
  if (CLSqliteDatabase::execAndGetValue(*v5, (sqlite3 *)"pragma freelist_count;", v24, v6)) {
    uint64_t v8 = *(void *)v24;
  }
  else {
    uint64_t v8 = -1;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v9 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    char v10 = sqlite3_db_filename(*(sqlite3 **)(a1 + 40), "main");
    *(_DWORD *)std::string buf = 134218498;
    *(void *)uint64_t v26 = v7;
    *(_WORD *)&v26[8] = 2048;
    *(void *)&v26[10] = v8;
    *(_WORD *)&v26[18] = 2080;
    *(void *)&v26[20] = v10;
    _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_DEFAULT, "start vacuum. page_count: %lld, freelist_count: %lld, path: %s, ", buf, 0x20u);
  }

  if (CLSqliteDatabase::isIncrementalVacuumEnabled(*(CLSqliteDatabase **)(a1 + 40), v11, v12))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    size_t v13 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v14 = sqlite3_db_filename(*(sqlite3 **)(a1 + 40), "main");
      *(_DWORD *)std::string buf = 134218498;
      *(void *)uint64_t v26 = v7;
      *(_WORD *)&v26[8] = 2048;
      *(void *)&v26[10] = v8;
      *(_WORD *)&v26[18] = 2080;
      *(void *)&v26[20] = v14;
      _os_log_impl(&dword_25631F000, v13, OS_LOG_TYPE_DEFAULT, "incremental_vacuum. page_count: %lld, freelist_count: %lld, path: %s", buf, 0x20u);
    }

    BOOL v15 = CLSqliteDatabase::incrementalVacuum(*(CLSqliteDatabase **)(a1 + 40), 0);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    __int16 v16 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      char v17 = sqlite3_db_filename(*(sqlite3 **)(a1 + 40), "main");
      *(_DWORD *)std::string buf = 67109890;
      *(_DWORD *)uint64_t v26 = 1;
      *(_WORD *)&v26[4] = 2048;
      *(void *)&v26[6] = v7;
      *(_WORD *)&v26[14] = 2048;
      *(void *)&v26[16] = v8;
      *(_WORD *)&v26[24] = 2080;
      *(void *)&v26[26] = v17;
      _os_log_impl(&dword_25631F000, v16, OS_LOG_TYPE_DEFAULT, "vacuum. sqlite_rc: %d, page_count: %lld, freelist_count: %lld, path: %s", buf, 0x26u);
    }

    BOOL v15 = sqlite3_exec(*(sqlite3 **)(a1 + 40), "VACUUM", 0, 0, 0) == 0;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v15;
  int v18 = sqlite3_wal_checkpoint_v2(*(sqlite3 **)(a1 + 40), 0, 3, 0, 0);
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  char v19 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = sqlite3_db_filename(*(sqlite3 **)(a1 + 40), "main");
    *(_DWORD *)std::string buf = 136315394;
    *(void *)uint64_t v26 = v20;
    *(_WORD *)&v26[8] = 1024;
    *(_DWORD *)&v26[10] = v18;
    _os_log_impl(&dword_25631F000, v19, OS_LOG_TYPE_DEFAULT, "wal_checkpoint. path: %s, sqlite_rc: %d", buf, 0x12u);
  }

  CLSqliteDatabase::execAndGetValue(*(CLSqliteDatabase **)(a1 + 40), (sqlite3 *)"pragma page_count;", v24, v21);
  return CLSqliteDatabase::execAndGetValue(*(CLSqliteDatabase **)(a1 + 40), (sqlite3 *)"pragma freelist_count;",
           v24,
           v22);
}

void sub_2563F516C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL CLSqliteDatabase::execAndGetValue(CLSqliteDatabase *this, sqlite3 *a2, char *a3, uint64_t *a4)
{
  int v6 = CLSqliteDatabase::prepareStatement(this, a2, a3);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = (sqlite3_stmt *)v6;
  int v8 = sqlite3_step((sqlite3_stmt *)v6);
  BOOL v10 = v8 == 100;
  if (v8 == 100) {
    *(void *)a3 = sqlite3_column_int64(v7, 0);
  }
  CLSqliteDatabase::finalizeStatement(this, v7, v9);
  return v10;
}

BOOL CLSqliteDatabase::isIncrementalVacuumEnabled(CLSqliteDatabase *this, sqlite3 *a2, const char *a3)
{
  uint64_t v4 = CLSqliteDatabase::prepareStatement(this, (sqlite3 *)"pragma auto_vacuum;", a3);
  if (!v4) {
    return 0;
  }
  int v5 = (sqlite3_stmt *)v4;
  BOOL v7 = sqlite3_step((sqlite3_stmt *)v4) == 100 && sqlite3_column_int(v5, 0) == 2;
  CLSqliteDatabase::finalizeStatement(this, v5, v6);
  return v7;
}

BOOL CLSqliteDatabase::incrementalVacuum(CLSqliteDatabase *this, sqlite3 *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v14);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"pragma incremental_vacuum(", 26);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)");", 2);
  std::stringbuf::str();
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  int v5 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = sqlite3_db_filename((sqlite3 *)this, "main");
    *(_DWORD *)std::string buf = 134218242;
    *(void *)&uint8_t buf[4] = a2;
    __int16 v19 = 2080;
    uint64_t v20 = v6;
    _os_log_impl(&dword_25631F000, v5, OS_LOG_TYPE_DEFAULT, "incrementalVacuum. pages: %lld, path: %s", buf, 0x16u);
  }

  std::stringbuf::str();
  if (v21 >= 0) {
    BOOL v7 = buf;
  }
  else {
    BOOL v7 = *(const char **)buf;
  }
  int v8 = sqlite3_exec((sqlite3 *)this, v7, 0, 0, 0);
  if (v21 < 0) {
    operator delete(*(void **)buf);
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v9 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v8;
    _os_log_impl(&dword_25631F000, v9, OS_LOG_TYPE_DEFAULT, "incrementalVacuum. result: %d", buf, 8u);
  }
  if (v13 < 0) {
    operator delete(__p);
  }
  v14[0] = *MEMORY[0x263F8C2B8];
  uint64_t v10 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v14 + *(void *)(v14[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v15[0] = v10;
  v15[1] = MEMORY[0x263F8C318] + 16;
  if (v16 < 0) {
    operator delete((void *)v15[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x25A2A6280](&v17);
  return v8 == 0;
}

{
  BOOL v4;
  uint64_t v6;

  int v6 = *((void *)this + 2);
  (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
  uint64_t v4 = CLSqliteDatabase::incrementalVacuum(*((CLSqliteDatabase **)this + 1), a2);
  (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  return v4;
}

void sub_2563F55C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_2563F56D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  AutoLocker::~AutoLocker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::reduceFreePages(CLSqliteDatabase *this, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 2);
  v14[7] = v4;
  int v5 = (CLSqliteDatabaseManager *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v15 = 256;
  if (*((unsigned char *)this + 56))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    int v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      BOOL v7 = (void *)((char *)this + 88);
      if (*((char *)this + 111) < 0) {
        BOOL v7 = (void *)*v7;
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v7;
      _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_FAULT, "Attempt to reduceFreePages on readonly database. path: %s", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v8 = 2;
  }
  else
  {
    uint64_t v9 = (CLSqliteDatabaseManager *)CLSqliteDatabaseManager::instance(v5);
    if (CLSqliteDatabaseManager::useIncrementalVacuum(v9))
    {
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v17 = 0x2020000000;
      int v18 = 0;
      uint64_t v10 = +[ULTransactionManager shared];
      v14[0] = MEMORY[0x263EF8330];
      v14[1] = 3221225472;
      void v14[2] = ___ZN16CLSqliteDatabase15reduceFreePagesEx_block_invoke;
      v14[3] = &unk_2653F9BA8;
      v14[4] = &buf;
      v14[5] = this;
      v14[6] = a2;
      [v10 performUnderTransaction:@"com.apple.milod.sqlitedb.IncrementalVacuum" block:v14];

      uint64_t v8 = *(unsigned int *)(*((void *)&buf + 1) + 24);
      _Block_object_dispose(&buf, 8);
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      size_t v11 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
      {
        int v12 = (void *)((char *)this + 88);
        if (*((char *)this + 111) < 0) {
          int v12 = (void *)*v12;
        }
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = v12;
        _os_log_impl(&dword_25631F000, v11, OS_LOG_TYPE_DEBUG, "Attempt to reduceFreePages with incremental vacuum disabled. path: %s", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v8 = 3;
    }
  }
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  return v8;
}

void sub_2563F597C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v10 = va_arg(va1, pthread_mutex_t *);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);

  _Block_object_dispose(va1, 8);
  AutoLocker::~AutoLocker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

void ___ZN16CLSqliteDatabase15reduceFreePagesEx_block_invoke(void *a1)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v2 = a1[5];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v3 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_25631F000, v3, OS_LOG_TYPE_DEFAULT, "reduceFreePages", buf, 2u);
  }
  *(void *)char v16 = 0;
  if (CLSqliteDatabase::execAndGetValue(*(CLSqliteDatabase **)(v2 + 8), (sqlite3 *)"pragma page_count;", v16, v4)) {
    uint64_t v6 = *(void *)v16;
  }
  else {
    uint64_t v6 = -1;
  }
  if (CLSqliteDatabase::execAndGetValue(*(CLSqliteDatabase **)(v2 + 8), (sqlite3 *)"pragma freelist_count;", v16, v5)) {
    uint64_t v7 = *(void *)v16;
  }
  else {
    uint64_t v7 = -1;
  }
  uint64_t v8 = v6 - v7;
  if (v6) {
    double v9 = (double)v8 / (double)v6;
  }
  else {
    double v9 = 1.0;
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v10 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    size_t v11 = (void *)(v2 + 88);
    if (*(char *)(v2 + 111) < 0) {
      size_t v11 = (void *)*v11;
    }
    *(_DWORD *)long long buf = 136315906;
    int v18 = v11;
    __int16 v19 = 2048;
    uint64_t v20 = v6;
    __int16 v21 = 2048;
    uint64_t v22 = v7;
    __int16 v23 = 2048;
    double v24 = v9;
    _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEFAULT, "reduceFreePages. path: %s, page_count: %lld, freelist_count: %lld, loadFactor: %f", buf, 0x2Au);
  }
  if (v7)
  {
    if (v6 < 0 || v7 < 0)
    {
      if (onceToken_MicroLocation_Default != -1) {
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
      }
      __int16 v14 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
      {
        __int16 v15 = (void *)(v2 + 88);
        if (*(char *)(v2 + 111) < 0) {
          __int16 v15 = (void *)*v15;
        }
        *(_DWORD *)long long buf = 136315138;
        int v18 = v15;
        _os_log_impl(&dword_25631F000, v14, OS_LOG_TYPE_FAULT, "Cannot reduceFreePages. path: %s", buf, 0xCu);
      }
    }
    else
    {
      if (v9 > 0.85 && (unint64_t)v7 < 0x200) {
        return;
      }
      uint64_t v12 = v9 >= 0.4 ? (sqlite3 *)(uint64_t)((double)v7 * 0.8) : (sqlite3 *)(v7 - v8);
      uint64_t v13 = (sqlite3 *)a1[6];
      if ((uint64_t)v12 > (uint64_t)v13)
      {
        *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = 1;
        uint64_t v12 = v13;
      }
      if (CLSqliteDatabase::incrementalVacuum((CLSqliteDatabase *)v2, v12)) {
        return;
      }
    }
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = 4;
  }
}

BOOL CLSqliteDatabase::setIncrementalVacuumEnabled(CLSqliteDatabase *this, sqlite3 *a2)
{
  int v2 = (int)a2;
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v4 = "pragma auto_vacuum = 2;";
  }
  else {
    uint64_t v4 = "pragma auto_vacuum = 0;";
  }
  int v5 = sqlite3_exec((sqlite3 *)this, v4, 0, 0, 0);
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  uint64_t v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = 67109376;
    int v19 = v2;
    __int16 v20 = 1024;
    int v21 = v5;
    _os_log_impl(&dword_25631F000, v6, OS_LOG_TYPE_DEFAULT, "setIncrementalVacuumEnabled. enabled: %d, sqlite_rc: %d", (uint8_t *)&v18, 0xEu);
  }
  BOOL v8 = v5 == 0;
  if (v2) {
    int v9 = 2;
  }
  else {
    int v9 = 0;
  }
  uint64_t v10 = CLSqliteDatabase::prepareStatement(this, (sqlite3 *)"pragma auto_vacuum;", v7);
  if (v10)
  {
    size_t v11 = (sqlite3_stmt *)v10;
    if (sqlite3_step((sqlite3_stmt *)v10) == 100)
    {
      int v13 = sqlite3_column_int(v11, 0);
      CLSqliteDatabase::finalizeStatement(this, v11, v14);
      if (v13 == v9) {
        return v8;
      }
      goto LABEL_17;
    }
    CLSqliteDatabase::finalizeStatement(this, v11, v12);
  }
  BOOL v8 = 0;
  int v13 = -1;
LABEL_17:
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
  }
  __int16 v15 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = 67109632;
    int v19 = v13;
    __int16 v20 = 1024;
    int v21 = v9;
    __int16 v22 = 1024;
    int v23 = 1;
    _os_log_impl(&dword_25631F000, v15, OS_LOG_TYPE_DEFAULT, "Actual auto-vacuum state does not match desired state. actual: %d, expected: %d, vacuumNow: %d", (uint8_t *)&v18, 0x14u);
  }
  CLSqliteDatabase::vacuum(this, v16);
  return v8;
}

uint64_t CLSqliteDatabase::isForeignKeyReferenceValid(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 16);
  v39[19] = v4;
  (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
  __int16 v40 = 256;
  if (*(void *)a2
    && ((v5 = *(const char **)(a2 + 24), *(unsigned char *)(a2 + 40)) ? (BOOL v6 = v5 == 0) : (BOOL v6 = 1),
        !v6 && (uint64_t v7 = *(const char **)(a2 + 16)) != 0))
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v35);
    BOOL v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"PRAGMA table_info(", 18);
    size_t v9 = strlen(v7);
    uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)v7, v9);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)")", 1);
    std::stringbuf::str();
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string buf = (sqlite3 *)&buf;
    }
    else {
      p_std::string buf = (sqlite3 *)buf.__r_.__value_.__r.__words[0];
    }
    uint64_t v12 = CLSqliteDatabase::prepareStatementNoCache((CLSqliteDatabase *)a1, p_buf);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    while (1)
    {
      int v14 = sqlite3_step((sqlite3_stmt *)v12);
      if (v14 != 100) {
        break;
      }
      __int16 v15 = sqlite3_column_text((sqlite3_stmt *)v12, 1);
      if (!strcmp(v5, (const char *)v15))
      {
        int v16 = *(_DWORD *)(a2 + 8);
        uint64_t v17 = "INTEGER";
        if (v16 != 1)
        {
          uint64_t v18 = 0;
          do
          {
            uint64_t v19 = v18;
            v18 += 16;
          }
          while (v18 != 80 && *(_DWORD *)((char *)&unk_2653F9BC8 + v19 + 16) != v16);
          uint64_t v17 = *(const char **)((char *)&unk_2653F9BC8 + v19 + 24);
        }
        __int16 v20 = sqlite3_column_text((sqlite3_stmt *)v12, 2);
        if (!strcmp(v17, (const char *)v20))
        {
          if (onceToken_MicroLocation_Default != -1) {
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
          }
          int v21 = logObject_MicroLocation_Default;
          if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v5;
            _os_log_impl(&dword_25631F000, v21, OS_LOG_TYPE_DEBUG, "Foreign key references are valid. FK_Table: %s, FK_Col: %s", (uint8_t *)&buf, 0x16u);
          }
          break;
        }
      }
    }
    CLSqliteDatabase::finalizeStatement(*(CLSqliteDatabase **)(a1 + 8), (sqlite3 *)v12, v13);
    memset(&buf, 0, sizeof(buf));
    std::string::operator=(&__p, &buf);
    std::stringbuf::__init_buf_ptrs[abi:ne180100]((uint64_t)v37);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    __int16 v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36, (uint64_t)"SELECT indexInfo.name FROM pragma_index_list('", 46);
    size_t v23 = strlen(v7);
    uint64_t v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)v7, v23);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"') AS indexList, pragma_index_info(indexList.name) AS indexInfo", 63);
    std::stringbuf::str();
    if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v25 = (sqlite3 *)&buf;
    }
    else {
      uint64_t v25 = (sqlite3 *)buf.__r_.__value_.__r.__words[0];
    }
    uint64_t v27 = CLSqliteDatabase::prepareStatementNoCache((CLSqliteDatabase *)a1, v25);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (v14 == 100)
    {
      while (sqlite3_step((sqlite3_stmt *)v27) == 100)
      {
        uint64_t v28 = sqlite3_column_text((sqlite3_stmt *)v27, 0);
        if (!strcmp(v5, (const char *)v28))
        {
          if (onceToken_MicroLocation_Default != -1) {
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
          }
          __int16 v29 = logObject_MicroLocation_Default;
          if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
            WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v5;
            _os_log_impl(&dword_25631F000, v29, OS_LOG_TYPE_DEBUG, "Index exist. FK_Table: %s, FK_Col: %s", (uint8_t *)&buf, 0x16u);
          }
          unsigned int v30 = 1;
          goto LABEL_42;
        }
      }
    }
    unsigned int v30 = 0;
LABEL_42:
    CLSqliteDatabase::finalizeStatement(*(CLSqliteDatabase **)(a1 + 8), (sqlite3 *)v27, v26);
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_59);
    }
    char v33 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 67109376;
      HIDWORD(buf.__r_.__value_.__r.__words[0]) = v14 == 100;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = v30;
      _os_log_impl(&dword_25631F000, v33, OS_LOG_TYPE_DEBUG, "ForeignKey reference. isReferenceValid: %d, isIndexed: %d", (uint8_t *)&buf, 0xEu);
    }
    if (v14 == 100) {
      uint64_t v31 = v30;
    }
    else {
      uint64_t v31 = 0;
    }
    v35[0] = *MEMORY[0x263F8C2B8];
    uint64_t v34 = *(void *)(MEMORY[0x263F8C2B8] + 72);
    *(void *)((char *)v35 + *(void *)(v35[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
    uint64_t v36 = v34;
    v37[0] = MEMORY[0x263F8C318] + 16;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x25A2A6280](v39);
  }
  else
  {
    uint64_t v31 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  return v31;
}

void sub_2563F64B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (*(char *)(v3 - 105) < 0) {
    operator delete(*(void **)(v3 - 128));
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  AutoLocker::~AutoLocker((pthread_mutex_t **)(v3 - 152));
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabase::lock(CLSqliteDatabase *this)
{
  return CLMutexDubiousLock(*((void *)this + 2));
}

uint64_t CLSqliteDatabase::unlock(CLSqliteDatabase *this)
{
  return CLMutexDubiousUnlock(*((void *)this + 2));
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_50()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void *std::__list_imp<sqlite3_stmt *>::clear(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    __n128 result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        __n128 result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t sub_2563F6668()
{
  return 0;
}

void sub_2563F6A8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_2563F6FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_2563F72CC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 56));
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationRecordingEventsTable::Entry::Entry(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, CLMicroLocationProto::RecordingEvent *a5, long long *a6, uint64_t a7, uint64_t a8, double a9)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a9;
  long long v11 = *a4;
  *(void *)(a1 + 40) = *((void *)a4 + 2);
  *(_OWORD *)(a1 + 24) = v11;
  *((void *)a4 + 1) = 0;
  *((void *)a4 + 2) = 0;
  *(void *)a4 = 0;
  *(void *)(a1 + 48) = a7;
  *(void *)(a1 + 56) = a8;
  *(void *)(a1 + 64) = *((void *)a5 + 1);
  *(_DWORD *)(a1 + 72) = *((_DWORD *)a5 + 18);
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a1 + 80), a5);
  long long v12 = *a6;
  *(unsigned char *)(a1 + 240) = *((unsigned char *)a6 + 16);
  *(_OWORD *)(a1 + 224) = v12;
  return a1;
}

void sub_2563F771C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationRecordingEventsTable::Entry::Entry(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, int a5, CLMicroLocationProto::RecordingEvent *a6, uint64_t a7, int a8, double a9, double a10, uint64_t a11, uint64_t a12)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a9;
  long long v14 = *a4;
  *(void *)(a1 + 40) = *((void *)a4 + 2);
  *(_OWORD *)(a1 + 24) = v14;
  *((void *)a4 + 1) = 0;
  *((void *)a4 + 2) = 0;
  *(void *)a4 = 0;
  *(void *)(a1 + 48) = a11;
  *(void *)(a1 + 56) = a12;
  *(double *)(a1 + 64) = a10;
  *(_DWORD *)(a1 + 72) = a5;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a1 + 80), a6);
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 240) = 0;
  if ((*(char *)(a7 + 23) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a7 + 23)) {
      return a1;
    }
    goto LABEL_5;
  }
  if (*(void *)(a7 + 8))
  {
LABEL_5:
    CLMicroLocationProtobufHelper::uuidFromStdString(a7, (uint64_t)&v16);
    *(_OWORD *)(a1 + 224) = v16;
    *(unsigned char *)(a1 + 240) = v17;
  }
  return a1;
}

{
  return CLMicroLocationRecordingEventsTable::Entry::Entry(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

void sub_2563F7824(_Unwind_Exception *a1)
{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v2);
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*(void **)(v1 + 24));
  }
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationRecordingEventsTable::Entry::Entry(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, int a5, CLMicroLocationProto::RecordingEvent *a6, long long *a7, int a8, double a9, double a10, uint64_t a11, uint64_t a12)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a9;
  long long v14 = *a4;
  *(void *)(a1 + 40) = *((void *)a4 + 2);
  *(_OWORD *)(a1 + 24) = v14;
  *((void *)a4 + 1) = 0;
  *((void *)a4 + 2) = 0;
  *(void *)a4 = 0;
  *(void *)(a1 + 48) = a11;
  *(void *)(a1 + 56) = a12;
  *(double *)(a1 + 64) = a10;
  *(_DWORD *)(a1 + 72) = a5;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a1 + 80), a6);
  long long v15 = *a7;
  *(unsigned char *)(a1 + 240) = *((unsigned char *)a7 + 16);
  *(_OWORD *)(a1 + 224) = v15;
  return a1;
}

{
  return CLMicroLocationRecordingEventsTable::Entry::Entry(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

void sub_2563F78E0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_2563F7988(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2563F7AC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2563F7CC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2563F7E18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

void sub_2563F82F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_2563F84B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2563F85FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

void sub_2563F871C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  _Unwind_Resume(a1);
}

void sub_2563F897C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *std::vector<CLMiLoHomeSlamAnalyticEventTable::Entry>::__init_with_size[abi:ne180100]<CLMiLoHomeSlamAnalyticEventTable::Entry*,CLMiLoHomeSlamAnalyticEventTable::Entry*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    __n128 result = std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8 - 6);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2563F8B18(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CLMiLoHomeSlamAnalyticEventTable::Entry>::__assign_with_size[abi:ne180100]<CLMiLoHomeSlamAnalyticEventTable::Entry*,CLMiLoHomeSlamAnalyticEventTable::Entry*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  size_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      _DWORD v7[2] = 0;
    }
    if (a4 >> 60) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](v7, v11);
    int v13 = (char *)v7[1];
    long long v12 = (void **)(v7 + 1);
    size_t v9 = v13;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 6;
      uint64_t v19 = v9;
      __int16 v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  long long v12 = (void **)(result + 8);
  long long v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  long long v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9 - 6);
    size_t v9 = (char *)*v12;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 6;
    uint64_t v19 = v9;
    __int16 v20 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *long long v12 = &v9[v17];
  return result;
}

void CLMicroLocationDendrogramAlgorithm::learn(uint64_t a1@<X1>, uint64_t a2@<X2>, unint64_t a3@<X3>, uint64_t a4@<X4>, CLMicroLocationFingerprintPool *a5@<X5>, unint64_t a6@<X6>, uint64_t a7@<X8>)
{
  uint64_t v9 = a2;
  v100[4] = *MEMORY[0x263EF8340];
  CLMicroLocationAlgorithms::getDendrogramLearningParams(a2, &v84);
  long long v12 = +[ULDefaultsSingleton shared];
  int v13 = [v12 defaultsDictionary];

  long long v14 = [NSString stringWithUTF8String:"ULPruneDistanceThreshold"];
  unint64_t v15 = [v13 objectForKey:v14];
  if (v15 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    [v15 doubleValue];
  }
  else {
    [&unk_2704F0F20 doubleValue];
  }
  double v17 = v16;

  size_t v18 = (double *)v84;
  if (v84 == v85)
  {
    char v62 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "!dendrogramLearningParams.clusterDistanceThresholdVector.empty()";
      _os_log_impl(&dword_25631F000, v62, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"cluster distance threshold must not be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }

    uint64_t v63 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v63))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "!dendrogramLearningParams.clusterDistanceThresholdVector.empty()";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v63, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "cluster distance threshold must not be empty", "{\"msg%{public}.0s\":\"cluster distance threshold must not be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }

    a7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled((os_log_t)a7, OS_LOG_TYPE_INFO))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "!dendrogramLearningParams.clusterDistanceThresholdVector.empty()";
      _os_log_impl(&dword_25631F000, (os_log_t)a7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"cluster distance threshold must not be empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }
    a1 = 30;
    goto LABEL_84;
  }
  uint64_t v19 = (double *)((char *)v84 + 8);
  if ((char *)v84 + 8 != v85)
  {
    double v20 = *(double *)v84;
    int v21 = (double *)((char *)v84 + 8);
    do
    {
      double v22 = *v21++;
      double v23 = v22;
      if (v22 < v20)
      {
        double v20 = v23;
        size_t v18 = v19;
      }
      uint64_t v19 = v21;
    }
    while (v21 != (double *)v85);
  }
  if (v17 > *v18)
  {
    uint64_t v64 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "pruneDistanceThreshold <= *std::min_element(dendrogramLearningParams.clusterDistanceThresholdVector.begin(),"
            " dendrogramLearningParams.clusterDistanceThresholdVector.end())";
      _os_log_impl(&dword_25631F000, v64, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"prune threshold must be less than or equal to clusterDistance threshold\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }

    char v65 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v65))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "pruneDistanceThreshold <= *std::min_element(dendrogramLearningParams.clusterDistanceThresholdVector.begin(),"
            " dendrogramLearningParams.clusterDistanceThresholdVector.end())";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v65, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "prune threshold must be less than or equal to clusterDistance threshold", "{\"msg%{public}.0s\":\"prune threshold must be less than or equal to clusterDistance threshold\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }

    a7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled((os_log_t)a7, OS_LOG_TYPE_INFO))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "pruneDistanceThreshold <= *std::min_element(dendrogramLearningParams.clusterDistanceThresholdVector.begin(),"
            " dendrogramLearningParams.clusterDistanceThresholdVector.end())";
      _os_log_impl(&dword_25631F000, (os_log_t)a7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"prune threshold must be less than or equal to clusterDistance threshold\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }
    a1 = 33;
    goto LABEL_84;
  }
  if (!CLMicroLocationFingerprintVector::size((CLMicroLocationFingerprintVector *)a1))
  {
    char v66 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "fingerprintVector.size() > 0";
      _os_log_impl(&dword_25631F000, v66, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"fingerprintVector must be non-empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }

    uint64_t v67 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_signpost_enabled(v67))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "fingerprintVector.size() > 0";
      _os_signpost_emit_with_name_impl(&dword_25631F000, v67, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "fingerprintVector must be non-empty", "{\"msg%{public}.0s\":\"fingerprintVector must be non-empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }

    a7 = _CLLogObjectForCategory_MicroLocation_Default();
    if (os_log_type_enabled((os_log_t)a7, OS_LOG_TYPE_INFO))
    {
      uint64_t buf = 68289539;
      __int16 v92 = 2082;
      double v93 = "";
      __int16 v94 = 2082;
      long long v95 = "assert";
      __int16 v96 = 2081;
      uint64_t v97 = "fingerprintVector.size() > 0";
      _os_log_impl(&dword_25631F000, (os_log_t)a7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"fingerprintVector must be non-empty\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }
    a1 = 35;
LABEL_84:

    uint64_t v69 = a1;
    __int16 v70 = "learn";
    std::string v68 = "/Library/Caches/com.apple.xbs/Sources/MicroLocation/MicroLocationLogic/CLMicroLocationDendrogramAlgorithm.mm";
    abort_report_np();
    __break(1u);
LABEL_85:
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_61);
    goto LABEL_16;
  }
  CLMicroLocationModel::CLMicroLocationModel((CLMicroLocationModel *)a7);
  *(_DWORD *)a7 = 1;
  *(_DWORD *)(a7 + 4) = v9;
  uint64_t v9 = a7 + 16;
  if (a7 + 16 != a4)
  {
    *(_DWORD *)(a7 + 48) = *(_DWORD *)(a4 + 32);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,void *> *>>((void *)(a7 + 16), *(uint64_t **)(a4 + 16), 0);
  }
  *(_OWORD *)(a7 + 56) = *(_OWORD *)(a4 + 40);
  if (onceToken_MicroLocation_Default != -1) {
    goto LABEL_85;
  }
LABEL_16:
  uint64_t v24 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
  {
    BOOL isStable = CLMicroLocationModel::isStable((CLMicroLocationModel *)a7);
    uint64_t buf = 68289282;
    __int16 v92 = 2082;
    double v93 = "";
    __int16 v94 = 1026;
    LODWORD(v95) = isStable;
    _os_log_impl(&dword_25631F000, v24, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, dendrogram, initialization\", \"isStableflag\":%{public}hhd}", (uint8_t *)&buf, 0x18u);
  }

  uint64_t v26 = +[ULDefaultsSingleton shared];
  uint64_t v27 = [v26 defaultsDictionary];

  uint64_t v28 = [NSString stringWithUTF8String:"ULFingerprintDistanceFunctionType"];
  __int16 v29 = [v27 objectForKey:v28];
  if (v29 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    int v30 = [v29 unsignedIntValue];
  }
  else {
    int v30 = objc_msgSend(&unk_2704F1B18, "unsignedIntValue", v68, v69, v70);
  }
  int v31 = v30;

  __int16 v32 = ULSettings::getFingerprintDistanceFunctionParamsForType(v31);
  char v33 = +[ULDefaultsSingleton shared];
  uint64_t v34 = [v33 defaultsDictionary];

  uint64_t v35 = [NSString stringWithUTF8String:"ULAdaptiveAnchorsEnable"];
  uint64_t v36 = [v34 objectForKey:v35];
  if (v36 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    int v37 = [v36 BOOLValue];
  }
  else {
    int v37 = objc_msgSend(MEMORY[0x263EFFA88], "BOOLValue", v68, v69, v70);
  }
  int v38 = v37;

  if (v38)
  {
    std::unordered_map<boost::uuids::uuid,CLMicroLocationAnchorAppearance>::unordered_map((uint64_t)&buf, v9);
    long long v98 = *(_OWORD *)(a7 + 56);
    char v39 = 1;
  }
  else
  {
    char v39 = 0;
    LOBYTE(buf) = 0;
  }
  char v99 = v39;
  CLMicroLocationAlgorithms::createLearnFingerprintDistanceFunction(v31, v32, (uint64_t)&buf, v100);
  if (v99) {
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&buf);
  }
  __int16 v40 = +[ULDefaultsSingleton shared];
  uint64_t v41 = [v40 defaultsDictionary];

  uint64_t v42 = [NSString stringWithUTF8String:"ULLinkageFunction"];
  char v43 = [v41 objectForKey:v42];
  if (v43 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    unsigned int v44 = [v43 unsignedIntValue];
  }
  else {
    unsigned int v44 = [&unk_2704F1B30 unsignedIntValue];
  }
  unsigned int v45 = v44;

  CLMicroLocationAlgorithms::createLinkageFunction(v45, &buf);
  std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__value_func[abi:ne180100]((uint64_t)v90, (uint64_t)v100);
  CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>>::CLDistanceMatrixTemplate<CLMicroLocationFingerprintVector,std::function<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>>((uint64_t *)&v80, (CLMicroLocationFingerprintVector *)a1, (uint64_t)v90);
  std::__function::__value_func<float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::__value_func[abi:ne180100]((uint64_t)v89, (uint64_t)&buf);
  CLHierarchicalClustering::CLHierarchicalClustering(v83, &v80, v89);
  std::__function::__value_func<float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::~__value_func[abi:ne180100](v89);
  if (__p)
  {
    int v82 = __p;
    operator delete(__p);
  }
  std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__value_func[abi:ne180100](v90);
  unint64_t v46 = vcvtmd_u64_f64(v87 * (double)a6);
  if (v86 <= v46) {
    unint64_t v47 = v46;
  }
  else {
    unint64_t v47 = v86;
  }
  uint64_t v80 = 0;
  std::string __p = 0;
  int v82 = 0;
  unint64_t ClusterLabels = CLHierarchicalClustering::getClusterLabels((uint64_t *)v83, &v80, &v84, v47, a3, v88);
  CLMicroLocationModel::generateRandomIdentifiers(ClusterLabels, v79);
  uint64_t v76 = 0;
  int v77 = 0;
  uint64_t v78 = 0;
  unint64_t v49 = CLHierarchicalClustering::getClusterLabels((uint64_t *)v83, &v76, 0, v17, 0.0);
  uint64_t v73 = 0;
  std::vector<unsigned long>::vector(&v74, v49, &v73);
  std::string::size_type v50 = v76;
  std::string::size_type v51 = (unint64_t *)v74;
  if (v77 != v76)
  {
    unint64_t v52 = 0;
    unint64_t v53 = (v77 - (unsigned char *)v76) >> 3;
    if (v53 <= 1) {
      unint64_t v53 = 1;
    }
    do
    {
      v51[v50[v52]] = v52;
      ++v52;
    }
    while (v53 != v52);
  }
  __int16 v54 = v75;
  while (v51 != v54)
  {
    uint64_t v55 = *((void *)v80 + *v51);
    uint64_t v56 = (const CLMicroLocationFingerprint *)CLMicroLocationFingerprintVector::operator[]((void *)a1, *v51);
    CLMicroLocationModel::addFingerprint((CLMicroLocationModel *)a7, v56, (const uuid *)v79[0] + v55, a5);
    ++v51;
  }
  size_t v57 = v80;
  if (__p != v80)
  {
    unint64_t v58 = 0;
    do
    {
      uint64_t v59 = v57[v58];
      uint64_t v60 = (uuid *)v79[0];
      uint64_t v61 = CLMicroLocationFingerprintVector::operator[]((void *)a1, v58);
      CLMicroLocationModel::addRecording((CLMicroLocationModel *)a7, &v60[v59], (const uuid *)(v61 + 40));
      ++v58;
      size_t v57 = v80;
    }
    while (v58 < ((unsigned char *)__p - (unsigned char *)v80) >> 3);
  }
  if (v74)
  {
    uint64_t v75 = (unint64_t *)v74;
    operator delete(v74);
  }
  if (v76)
  {
    int v77 = v76;
    operator delete(v76);
  }
  if (v79[0])
  {
    v79[1] = v79[0];
    operator delete(v79[0]);
  }
  if (v80)
  {
    std::string __p = v80;
    operator delete(v80);
  }
  if (v83[0])
  {
    v83[1] = v83[0];
    operator delete(v83[0]);
  }
  std::__function::__value_func<float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::~__value_func[abi:ne180100](&buf);
  std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__value_func[abi:ne180100](v100);

  if (v84)
  {
    long long v85 = (char *)v84;
    operator delete(v84);
  }
}

void sub_2563F9860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__value_func[abi:ne180100]((void *)(v46 - 152));
  CLMicroLocationModel::~CLMicroLocationModel(v41);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void CLMicroLocationDendrogramAlgorithm::~CLMicroLocationDendrogramAlgorithm(CLMicroLocationDendrogramAlgorithm *this)
{
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_51()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void *std::__function::__value_func<float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>>::CLDistanceMatrixTemplate<CLMicroLocationFingerprintVector,std::function<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>>(uint64_t *a1, CLMicroLocationFingerprintVector *this, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  a1[1] = 0;
  a1[2] = 0;
  BOOL v6 = a1 + 1;
  a1[3] = 0;
  uint64_t v7 = CLMicroLocationFingerprintVector::size(this);
  *a1 = v7;
  v20[0] = 0;
  std::vector<float>::resize((uint64_t)v6, (unint64_t)(v7 + v7 * v7) >> 1, v20);
  if (*a1)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = CLMicroLocationFingerprintVector::operator[](this, v8);
      std::unordered_set<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::unordered_set((uint64_t)v20, v9);
      long long v10 = *(_OWORD *)(v9 + 40);
      uint64_t v22 = *(void *)(v9 + 56);
      long long v21 = v10;
      std::unordered_set<CLMicroLocationProto::DataType>::unordered_set((uint64_t)v23, v9 + 64);
      std::unordered_map<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>::unordered_map((uint64_t)v24, v9 + 104);
      long long v11 = *(_OWORD *)(v9 + 144);
      int v25 = *(_DWORD *)(v9 + 160);
      *(_OWORD *)&v24[40] = v11;
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      std::string __p = 0;
      std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>(&__p, *(const void **)(v9 + 168), *(void *)(v9 + 176), (uint64_t)(*(void *)(v9 + 176) - *(void *)(v9 + 168)) >> 2);
      if (v8)
      {
        for (unint64_t i = 0; i != v8; ++i)
        {
          uint64_t v13 = CLMicroLocationFingerprintVector::operator[](this, i);
          uint64_t v14 = *(void *)(a3 + 24);
          if (!v14) {
            std::__throw_bad_function_call[abi:ne180100]();
          }
          (*(void (**)(uint64_t, _DWORD *, uint64_t))(*(void *)v14 + 48))(v14, v20, v13);
          if (v8 <= i) {
            unint64_t v16 = i;
          }
          else {
            unint64_t v16 = v8;
          }
          if (v8 >= i) {
            unint64_t v17 = i;
          }
          else {
            unint64_t v17 = v8;
          }
          float v18 = v15;
          *(float *)(*v6 + 4 * (v17 + ((v16 + v16 * v16) >> 1))) = v18;
        }
      }
      if (__p)
      {
        uint64_t v27 = __p;
        operator delete(__p);
      }
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v24);
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v23);
      std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table((uint64_t)v20);
      ++v8;
    }
    while (v8 < *a1);
  }
  return a1;
}

void sub_2563F9DB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v14 = *v12;
  if (*v12)
  {
    *(void *)(v11 + 16) = v14;
    operator delete(v14);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((void **)a1, a2 - v3, a3);
  }
}

void std::vector<float>::__append(void **a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  uint64_t v9 = *(_DWORD **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 2)
  {
    if (a2)
    {
      uint64_t v16 = 4 * a2;
      unint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 4;
      }
      while (v16);
      uint64_t v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 2);
    if (v11 >> 62) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v10 >> 2;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 1 > v11) {
      unint64_t v11 = v13 >> 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      double v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>(v6, v14);
    }
    else {
      double v15 = 0;
    }
    float v18 = &v15[4 * v12];
    uint64_t v19 = &v18[4 * a2];
    uint64_t v20 = 4 * a2;
    long long v21 = v18;
    do
    {
      *(_DWORD *)long long v21 = *a3;
      v21 += 4;
      v20 -= 4;
    }
    while (v20);
    uint64_t v22 = &v15[4 * v14];
    double v23 = (char *)*a1;
    for (unint64_t i = (char *)a1[1]; i != v23; i -= 4)
    {
      int v25 = *((_DWORD *)i - 1);
      *((_DWORD *)v18 - 1) = v25;
      v18 -= 4;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

uint64_t std::__function::__value_func<float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::vector<unsigned long>::vector(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<CLMicroLocationWiFiChannelHistogram>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_2563FA074(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::ULMiloSqliteDatabase(ULMiloSqliteDatabase *this, CLSqliteDatabase *a2)
{
  this->var0 = a2;
}

uint64_t ULMiloSqliteDatabase::tableExists(ULMiloSqliteDatabase *this, const char *a2)
{
  return CLSqliteDatabase::tableExists(this->var0, a2);
}

void ULMiloSqliteDatabase::numEntries(ULMiloSqliteDatabase *this, const char *a2)
{
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 21;
  strcpy((char *)&__p, "SELECT COUNT(*) FROM ");
  uint64_t v3 = std::string::append(&__p, a2);
  long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  int64_t v8 = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v7 = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8 >= 0) {
    int v5 = v7;
  }
  else {
    int v5 = (void **)v7[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, (sqlite3 *)v5);
}

void sub_2563FA228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectRecordingEventEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v48, "RowId");
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v44, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v50.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v43, *a3);
    if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v43;
    }
    else {
      int64_t v8 = (std::string *)v43.__r_.__value_.__r.__words[0];
    }
    if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v43.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v43.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v50, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v53.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v47 < 0) {
      operator delete(__p);
    }
    std::string __p = v11;
    *(void *)uint64_t v46 = v53.__r_.__value_.__r.__words[0];
    *(void *)&v46[7] = *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7);
    unsigned __int8 v47 = v12;
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v43.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v50.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::commaSeparatedColumnNames(&v39);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v39;
  }
  else {
    uint64_t v13 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v39.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v39.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v51, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v52, "MicroLocationRecordingEvents");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v47 & 0x80u) == 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if ((v47 & 0x80u) == 0) {
    std::string::size_type v22 = v47;
  }
  else {
    std::string::size_type v22 = *(void *)v46;
  }
  double v23 = std::string::append(&v41, p_p, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v42, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v49 & 0x80u) == 0) {
    uint64_t v27 = v48;
  }
  else {
    uint64_t v27 = (void **)v48[0];
  }
  if ((v49 & 0x80u) == 0) {
    std::string::size_type v28 = v49;
  }
  else {
    std::string::size_type v28 = (std::string::size_type)v48[1];
  }
  uint64_t v29 = std::string::append(&v53, (const std::string::value_type *)v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v43, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v50, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v44;
  }
  else {
    int v37 = (sqlite3 *)v44.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FA90C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,void *buf,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  if (a60 < 0) {
    operator delete(buf);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  _Unwind_Resume(a1);
}

void sub_2563FAC04()
{
}

void sub_2563FAC10(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2563FAB14);
}

void sub_2563FAC20()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul,6ul,7ul,8ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FAC70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ULMiloSqliteDatabase::_getUUIDFromStringOrNilUUID(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(unsigned __int8 *)(a2 + 23);
  if ((v2 & 0x80u) != 0) {
    uint64_t v2 = *(void *)(a2 + 8);
  }
  if (!v2) {
    return 0;
  }
  CLMicroLocationProtobufHelper::uuidFromStdString(a2, (uint64_t)&v4);
  if (v5) {
    return v4;
  }
  else {
    return 0;
  }
}

void ULMiloSqliteDatabase::selectMeasurementEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v50, "RowId");
  std::string::basic_string[abi:ne180100]<0>(&v47, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v46, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v45, *a3);
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v45;
    }
    else {
      int64_t v8 = (std::string *)v45.__r_.__value_.__r.__words[0];
    }
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v45.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v45.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v52, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v53.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v49 < 0) {
      operator delete(v47);
    }
    unsigned __int8 v47 = v11;
    *(void *)long long v48 = v53.__r_.__value_.__r.__words[0];
    *(void *)&v48[7] = *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7);
    unsigned __int8 v49 = v12;
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::commaSeparatedColumnNames(&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = __p.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)p_p, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v41, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v42, "MicroLocationMeasurements");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v49 & 0x80u) == 0) {
    long long v21 = (const std::string::value_type *)&v47;
  }
  else {
    long long v21 = (const std::string::value_type *)v47;
  }
  if ((v49 & 0x80u) == 0) {
    std::string::size_type v22 = v49;
  }
  else {
    std::string::size_type v22 = *(void *)v48;
  }
  double v23 = std::string::append(&v43, v21, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v44, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v51 & 0x80u) == 0) {
    uint64_t v27 = (const std::string::value_type *)v50;
  }
  else {
    uint64_t v27 = (const std::string::value_type *)v50[0];
  }
  if ((v51 & 0x80u) == 0) {
    std::string::size_type v28 = v51;
  }
  else {
    std::string::size_type v28 = v50[1];
  }
  uint64_t v29 = std::string::append(&v53, v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v45, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v52, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v46;
  }
  else {
    int v37 = (sqlite3 *)v46.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FB2B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v47 - 169) < 0) {
    operator delete(*(void **)(v47 - 192));
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (*(char *)(v47 - 217) < 0) {
    operator delete(*(void **)(v47 - 240));
  }
  if (*(char *)(v47 - 193) < 0) {
    operator delete(*(void **)(v47 - 216));
  }
  _Unwind_Resume(a1);
}

void sub_2563FB49C()
{
}

void sub_2563FB554()
{
}

void sub_2563FB560(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2563FB494);
}

void sub_2563FB570()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FB5C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectLabelEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v49, "RowId");
  std::string::basic_string[abi:ne180100]<0>(&v46, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v44, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v53, *a3);
    if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v53;
    }
    else {
      int64_t v8 = (std::string *)v53.__r_.__value_.__r.__words[0];
    }
    if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v53.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v45, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v52.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v52.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v48 < 0) {
      operator delete(v46);
    }
    std::string v46 = v11;
    *(void *)uint64_t v47 = v52.__r_.__value_.__r.__words[0];
    *(void *)&v47[7] = *(std::string::size_type *)((char *)v52.__r_.__value_.__r.__words + 7);
    unsigned __int8 v48 = v12;
    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v53.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::commaSeparatedColumnNames(&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = __p.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)p_p, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v41, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v42, "MicroLocationLabels");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v48 & 0x80u) == 0) {
    long long v21 = (const std::string::value_type *)&v46;
  }
  else {
    long long v21 = (const std::string::value_type *)v46;
  }
  if ((v48 & 0x80u) == 0) {
    std::string::size_type v22 = v48;
  }
  else {
    std::string::size_type v22 = *(void *)v47;
  }
  double v23 = std::string::append(&v43, v21, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v51, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v50 & 0x80u) == 0) {
    uint64_t v27 = (const std::string::value_type *)v49;
  }
  else {
    uint64_t v27 = (const std::string::value_type *)v49[0];
  }
  if ((v50 & 0x80u) == 0) {
    std::string::size_type v28 = v50;
  }
  else {
    std::string::size_type v28 = v49[1];
  }
  uint64_t v29 = std::string::append(&v52, v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v53, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v44, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v45;
  }
  else {
    int v37 = (sqlite3 *)v45.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FBB60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (*(char *)(v61 - 73) < 0) {
    operator delete(*(void **)(v61 - 96));
  }
  if (a61 < 0) {
    operator delete(__p);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (*(char *)(v61 - 185) < 0) {
    operator delete(*(void **)(v61 - 208));
  }
  if (*(char *)(v61 - 161) < 0) {
    operator delete(*(void **)(v61 - 184));
  }
  _Unwind_Resume(exception_object);
}

void sub_2563FBE10()
{
}

void sub_2563FBE1C(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2563FBD48);
}

void sub_2563FBE2C()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FBE7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectServiceEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v51, "LastActiveTimestamp");
  std::string::basic_string[abi:ne180100]<0>(&v48, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v46, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v55, *a3);
    if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v55;
    }
    else {
      int64_t v8 = (std::string *)v55.__r_.__value_.__r.__words[0];
    }
    if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v55.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v55.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v47, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v54.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v54.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v50 < 0) {
      operator delete(v48);
    }
    unsigned __int8 v48 = v11;
    *(void *)unsigned __int8 v49 = v54.__r_.__value_.__r.__words[0];
    *(void *)&v49[7] = *(std::string::size_type *)((char *)v54.__r_.__value_.__r.__words + 7);
    unsigned __int8 v50 = v12;
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v55.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v42.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v42, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::commaSeparatedColumnNames(&v41);
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v41;
  }
  else {
    uint64_t v13 = (std::string *)v41.__r_.__value_.__r.__words[0];
  }
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v41.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v42, (const std::string::value_type *)v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v43, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v44, "MiLoServices");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v50 & 0x80u) == 0) {
    long long v21 = (const std::string::value_type *)&v48;
  }
  else {
    long long v21 = (const std::string::value_type *)v48;
  }
  if ((v50 & 0x80u) == 0) {
    std::string::size_type v22 = v50;
  }
  else {
    std::string::size_type v22 = *(void *)v49;
  }
  double v23 = std::string::append(&v45, v21, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v53, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v54.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v52 & 0x80u) == 0) {
    uint64_t v27 = (const std::string::value_type *)v51;
  }
  else {
    uint64_t v27 = (const std::string::value_type *)v51[0];
  }
  if ((v52 & 0x80u) == 0) {
    std::string::size_type v28 = v52;
  }
  else {
    std::string::size_type v28 = v51[1];
  }
  uint64_t v29 = std::string::append(&v54, v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  char v40 = 12;
  strcpy(__s, " DESC LIMIT ");
  int v31 = std::string::append(&v55, __s, 0xCuLL);
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v46, (const std::string::value_type *)p_p, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (v40 < 0) {
    operator delete(*(void **)__s);
  }
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v55.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v47;
  }
  else {
    int v37 = (sqlite3 *)v47.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FC47C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (*(char *)(v45 - 73) < 0) {
    operator delete(*(void **)(v45 - 96));
  }
  if (a45 < 0) {
    operator delete(__p);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  if (*(char *)(v45 - 185) < 0) {
    operator delete(*(void **)(v45 - 208));
  }
  if (*(char *)(v45 - 161) < 0) {
    operator delete(*(void **)(v45 - 184));
  }
  _Unwind_Resume(a1);
}

double CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul,6ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FC7D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectLoiEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v51, "LastSeenTimeStamp");
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v46, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v56, *a3);
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v56;
    }
    else {
      int64_t v8 = (std::string *)v56.__r_.__value_.__r.__words[0];
    }
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v56.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v56.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v47, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v55.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v50 < 0) {
      operator delete(__p);
    }
    std::string __p = v11;
    *(void *)unsigned __int8 v49 = v55.__r_.__value_.__r.__words[0];
    *(void *)&v49[7] = *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 7);
    unsigned __int8 v50 = v12;
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v56.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v42.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v42, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::commaSeparatedColumnNames(&v41);
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v41;
  }
  else {
    uint64_t v13 = (std::string *)v41.__r_.__value_.__r.__words[0];
  }
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v41.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v42, (const std::string::value_type *)v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v43, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v44, "MiLoLoiTable");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  long long v21 = std::string::append(&v53, " ");
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v54.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if ((v50 & 0x80u) == 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if ((v50 & 0x80u) == 0) {
    std::string::size_type v24 = v50;
  }
  else {
    std::string::size_type v24 = *(void *)v49;
  }
  int v25 = std::string::append(&v54, p_p, v24);
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  uint64_t v27 = std::string::append(&v45, " ORDER BY ");
  long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  if ((v52 & 0x80u) == 0) {
    uint64_t v29 = (const std::string::value_type *)v51;
  }
  else {
    uint64_t v29 = (const std::string::value_type *)v51[0];
  }
  if ((v52 & 0x80u) == 0) {
    std::string::size_type v30 = v52;
  }
  else {
    std::string::size_type v30 = v51[1];
  }
  int v31 = std::string::append(&v55, v29, v30);
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v56.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  char v33 = std::string::append(&v56, " DESC LIMIT ");
  long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v34;
  v33->__r_.__value_.__l.__size_ = 0;
  v33->__r_.__value_.__r.__words[2] = 0;
  v33->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v40, a2);
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v35 = &v40;
  }
  else {
    uint64_t v35 = (std::string *)v40.__r_.__value_.__r.__words[0];
  }
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v36 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v36 = v40.__r_.__value_.__l.__size_;
  }
  int v37 = std::string::append(&v46, (const std::string::value_type *)v35, v36);
  long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v56.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v55.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string v39 = (sqlite3 *)&v47;
  }
  else {
    std::string v39 = (sqlite3 *)v47.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v39);
}

void sub_2563FCDCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (*(char *)(v50 - 73) < 0) {
    operator delete(*(void **)(v50 - 96));
  }
  if (a43 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  if (*(char *)(v50 - 193) < 0) {
    operator delete(*(void **)(v50 - 216));
  }
  _Unwind_Resume(a1);
}

void sub_2563FD0CC()
{
}

void sub_2563FD0D8(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2563FCFE4);
}

void sub_2563FD0E8()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FD138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectRapportEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v49, "RowId");
  std::string::basic_string[abi:ne180100]<0>(&v46, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v45, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v44, *a3);
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v44;
    }
    else {
      int64_t v8 = (std::string *)v44.__r_.__value_.__r.__words[0];
    }
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v44.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v44.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v51, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v53.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v48 < 0) {
      operator delete(v46);
    }
    std::string v46 = v11;
    *(void *)std::string v47 = v53.__r_.__value_.__r.__words[0];
    *(void *)&v47[7] = *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7);
    unsigned __int8 v48 = v12;
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v51.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::commaSeparatedColumnNames(&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = __p.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)p_p, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v41, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v42, "MicroLocationRapport");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v48 & 0x80u) == 0) {
    long long v21 = (const std::string::value_type *)&v46;
  }
  else {
    long long v21 = (const std::string::value_type *)v46;
  }
  if ((v48 & 0x80u) == 0) {
    std::string::size_type v22 = v48;
  }
  else {
    std::string::size_type v22 = *(void *)v47;
  }
  double v23 = std::string::append(&v52, v21, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v43, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v50 & 0x80u) == 0) {
    uint64_t v27 = (const std::string::value_type *)v49;
  }
  else {
    uint64_t v27 = (const std::string::value_type *)v49[0];
  }
  if ((v50 & 0x80u) == 0) {
    std::string::size_type v28 = v50;
  }
  else {
    std::string::size_type v28 = v49[1];
  }
  uint64_t v29 = std::string::append(&v53, v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v44, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v51, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v45;
  }
  else {
    int v37 = (sqlite3 *)v45.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FD6F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (a54 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v61 - 137) < 0) {
    operator delete(*(void **)(v61 - 160));
  }
  if (a61 < 0) {
    operator delete(a56);
  }
  if (*(char *)(v61 - 185) < 0) {
    operator delete(*(void **)(v61 - 208));
  }
  if (*(char *)(v61 - 161) < 0) {
    operator delete(*(void **)(v61 - 184));
  }
  _Unwind_Resume(exception_object);
}

void sub_2563FD9C4()
{
}

void sub_2563FD9D0(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2563FD8E4);
}

void sub_2563FD9E0()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FDA30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectAssociatedStateEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v49, "Timestamp");
  std::string::basic_string[abi:ne180100]<0>(&v46, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v44, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v53, *a3);
    if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v53;
    }
    else {
      int64_t v8 = (std::string *)v53.__r_.__value_.__r.__words[0];
    }
    if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v53.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v45, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v52.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v52.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v48 < 0) {
      operator delete(v46);
    }
    std::string v46 = v11;
    *(void *)std::string v47 = v52.__r_.__value_.__r.__words[0];
    *(void *)&v47[7] = *(std::string::size_type *)((char *)v52.__r_.__value_.__r.__words + 7);
    unsigned __int8 v48 = v12;
    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v53.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::commaSeparatedColumnNames(&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = __p.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)p_p, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v41, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v42, "MicroLocationAssociatedState");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v48 & 0x80u) == 0) {
    long long v21 = (const std::string::value_type *)&v46;
  }
  else {
    long long v21 = (const std::string::value_type *)v46;
  }
  if ((v48 & 0x80u) == 0) {
    std::string::size_type v22 = v48;
  }
  else {
    std::string::size_type v22 = *(void *)v47;
  }
  double v23 = std::string::append(&v43, v21, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v51, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v50 & 0x80u) == 0) {
    uint64_t v27 = (const std::string::value_type *)v49;
  }
  else {
    uint64_t v27 = (const std::string::value_type *)v49[0];
  }
  if ((v50 & 0x80u) == 0) {
    std::string::size_type v28 = v50;
  }
  else {
    std::string::size_type v28 = v49[1];
  }
  uint64_t v29 = std::string::append(&v52, v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v53, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v44, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v45;
  }
  else {
    int v37 = (sqlite3 *)v45.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FE024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (*(char *)(v61 - 73) < 0) {
    operator delete(*(void **)(v61 - 96));
  }
  if (a61 < 0) {
    operator delete(__p);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (*(char *)(v61 - 185) < 0) {
    operator delete(*(void **)(v61 - 208));
  }
  if (*(char *)(v61 - 161) < 0) {
    operator delete(*(void **)(v61 - 184));
  }
  _Unwind_Resume(exception_object);
}

double CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul,6ul,7ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FE36C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectBluetoothIdentityEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v49, "LastSeenTimeStamp");
  std::string::basic_string[abi:ne180100]<0>(&v46, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v44, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v53, *a3);
    if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v53;
    }
    else {
      int64_t v8 = (std::string *)v53.__r_.__value_.__r.__words[0];
    }
    if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v53.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v45, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v52.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v52.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v48 < 0) {
      operator delete(v46);
    }
    std::string v46 = v11;
    *(void *)std::string v47 = v52.__r_.__value_.__r.__words[0];
    *(void *)&v47[7] = *(std::string::size_type *)((char *)v52.__r_.__value_.__r.__words + 7);
    unsigned __int8 v48 = v12;
    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v53.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::commaSeparatedColumnNames(&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = __p.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)p_p, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v41, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v42, "MicroLocationBluetoothIdentityTable");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v48 & 0x80u) == 0) {
    long long v21 = (const std::string::value_type *)&v46;
  }
  else {
    long long v21 = (const std::string::value_type *)v46;
  }
  if ((v48 & 0x80u) == 0) {
    std::string::size_type v22 = v48;
  }
  else {
    std::string::size_type v22 = *(void *)v47;
  }
  double v23 = std::string::append(&v51, v21, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v43, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v50 & 0x80u) == 0) {
    uint64_t v27 = (const std::string::value_type *)v49;
  }
  else {
    uint64_t v27 = (const std::string::value_type *)v49[0];
  }
  if ((v50 & 0x80u) == 0) {
    std::string::size_type v28 = v50;
  }
  else {
    std::string::size_type v28 = v49[1];
  }
  uint64_t v29 = std::string::append(&v52, v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v53, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v44, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v45;
  }
  else {
    int v37 = (sqlite3 *)v45.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FE924(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (*(char *)(v61 - 73) < 0) {
    operator delete(*(void **)(v61 - 96));
  }
  if (a61 < 0) {
    operator delete(__p);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (*(char *)(v61 - 185) < 0) {
    operator delete(*(void **)(v61 - 208));
  }
  if (*(char *)(v61 - 161) < 0) {
    operator delete(*(void **)(v61 - 184));
  }
  _Unwind_Resume(exception_object);
}

void sub_2563FEB28()
{
}

void sub_2563FEC08()
{
}

void sub_2563FEC14(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2563FEB20);
}

void sub_2563FEC24()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FEC74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectConfigurationEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v49, "GenerationTimestamp");
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v45, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v44, *a3);
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v44;
    }
    else {
      int64_t v8 = (std::string *)v44.__r_.__value_.__r.__words[0];
    }
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v44.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v44.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v51, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v53.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v48 < 0) {
      operator delete(__p);
    }
    std::string __p = v11;
    *(void *)std::string v47 = v53.__r_.__value_.__r.__words[0];
    *(void *)&v47[7] = *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7);
    unsigned __int8 v48 = v12;
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v51.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::commaSeparatedColumnNames(&v39);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v39;
  }
  else {
    uint64_t v13 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v39.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v39.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v41, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v42, "MicroLocationConfiguration");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v48 & 0x80u) == 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if ((v48 & 0x80u) == 0) {
    std::string::size_type v22 = v48;
  }
  else {
    std::string::size_type v22 = *(void *)v47;
  }
  double v23 = std::string::append(&v52, p_p, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v43, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v50 & 0x80u) == 0) {
    uint64_t v27 = (const std::string::value_type *)v49;
  }
  else {
    uint64_t v27 = (const std::string::value_type *)v49[0];
  }
  if ((v50 & 0x80u) == 0) {
    std::string::size_type v28 = v50;
  }
  else {
    std::string::size_type v28 = v49[1];
  }
  uint64_t v29 = std::string::append(&v53, v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v44, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v51, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v45;
  }
  else {
    int v37 = (sqlite3 *)v45.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FF214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v50 - 169) < 0) {
    operator delete(*(void **)(v50 - 192));
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  if (*(char *)(v50 - 193) < 0) {
    operator delete(*(void **)(v50 - 216));
  }
  _Unwind_Resume(a1);
}

void sub_2563FF4E0()
{
}

void sub_2563FF4EC(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2563FF400);
}

void sub_2563FF4FC()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FF54C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectModelEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v47, "RowId");
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v43, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v42, *a3);
    if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v42;
    }
    else {
      int64_t v8 = (std::string *)v42.__r_.__value_.__r.__words[0];
    }
    if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v42.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v42.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v49, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v53.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v46 < 0) {
      operator delete(__p);
    }
    std::string __p = v11;
    *(void *)std::string v45 = v53.__r_.__value_.__r.__words[0];
    *(void *)&v45[7] = *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7);
    unsigned __int8 v46 = v12;
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v42.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v49.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v43.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::commaSeparatedColumnNames(&v39);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v39;
  }
  else {
    uint64_t v13 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v39.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v39.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v50, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v51, "MicroLocationModels");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v46 & 0x80u) == 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if ((v46 & 0x80u) == 0) {
    std::string::size_type v22 = v46;
  }
  else {
    std::string::size_type v22 = *(void *)v45;
  }
  double v23 = std::string::append(&v52, p_p, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v41, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v48 & 0x80u) == 0) {
    uint64_t v27 = v47;
  }
  else {
    uint64_t v27 = (void **)v47[0];
  }
  if ((v48 & 0x80u) == 0) {
    std::string::size_type v28 = v48;
  }
  else {
    std::string::size_type v28 = (std::string::size_type)v47[1];
  }
  uint64_t v29 = std::string::append(&v53, (const std::string::value_type *)v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v42, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v49.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v49, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v51.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v43;
  }
  else {
    int v37 = (sqlite3 *)v43.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_2563FFB44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,void *buf,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a54 < 0) {
    operator delete(buf);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a48 < 0) {
    operator delete(a43);
  }
  _Unwind_Resume(a1);
}

void sub_2563FFE1C()
{
}

void sub_2563FFE28(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2563FFD3CLL);
}

void sub_2563FFE38()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul,6ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_2563FFE88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectLoggedEventEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v50, "RowId");
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v46, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v45, *a3);
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v45;
    }
    else {
      int64_t v8 = (std::string *)v45.__r_.__value_.__r.__words[0];
    }
    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v45.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v45.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v52, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v53.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v49 < 0) {
      operator delete(__p);
    }
    std::string __p = v11;
    *(void *)unsigned __int8 v48 = v53.__r_.__value_.__r.__words[0];
    *(void *)&v48[7] = *(std::string::size_type *)((char *)v53.__r_.__value_.__r.__words + 7);
    unsigned __int8 v49 = v12;
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v52.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v40.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v40, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::commaSeparatedColumnNames(&v39);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v39;
  }
  else {
    uint64_t v13 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v39.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v39.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v40, (const std::string::value_type *)v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v41, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v42, "MicroLocationLoggedEvents");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if ((v49 & 0x80u) == 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if ((v49 & 0x80u) == 0) {
    std::string::size_type v22 = v49;
  }
  else {
    std::string::size_type v22 = *(void *)v48;
  }
  double v23 = std::string::append(&v43, p_p, v22);
  long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  int v25 = std::string::append(&v44, " ORDER BY ");
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if ((v51 & 0x80u) == 0) {
    uint64_t v27 = v50;
  }
  else {
    uint64_t v27 = (void **)v50[0];
  }
  if ((v51 & 0x80u) == 0) {
    std::string::size_type v28 = v51;
  }
  else {
    std::string::size_type v28 = (std::string::size_type)v50[1];
  }
  uint64_t v29 = std::string::append(&v53, (const std::string::value_type *)v27, v28);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  int v31 = std::string::append(&v45, " DESC LIMIT ");
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v38, a2);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v33 = &v38;
  }
  else {
    char v33 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v38.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v38.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v52, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v52.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v39.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v37 = (sqlite3 *)&v46;
  }
  else {
    int v37 = (sqlite3 *)v46.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v37);
}

void sub_256400420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60,void *buf,uint64_t a62,int a63)
{
  if (a40 < 0) {
    operator delete(__p);
  }
  if (a66 < 0) {
    operator delete(buf);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  if (a54 < 0) {
    operator delete(a49);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

void sub_256400604()
{
}

void sub_2564006C0()
{
}

void sub_2564006CC(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x2564005FCLL);
}

void sub_2564006DC()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_25640072C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ULMiloSqliteDatabase::selectCustomLoiEntries(ULMiloSqliteDatabase *this, unsigned int a2, double *a3)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(v51, "LastSeenTimeStamp");
  std::string::basic_string[abi:ne180100]<0>(&__p, "");
  if (*a3 > 0.0)
  {
    std::operator+<char>();
    uint64_t v6 = std::string::append(&v46, " < ");
    long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v56, *a3);
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int64_t v8 = &v56;
    }
    else {
      int64_t v8 = (std::string *)v56.__r_.__value_.__r.__words[0];
    }
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v56.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v56.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v47, (const std::string::value_type *)v8, size);
    unint64_t v11 = (void *)v10->__r_.__value_.__r.__words[0];
    v55.__r_.__value_.__r.__words[0] = v10->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if ((char)v50 < 0) {
      operator delete(__p);
    }
    std::string __p = v11;
    *(void *)unsigned __int8 v49 = v55.__r_.__value_.__r.__words[0];
    *(void *)&v49[7] = *(std::string::size_type *)((char *)v55.__r_.__value_.__r.__words + 7);
    unsigned __int8 v50 = v12;
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v56.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v47.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
  }
  *((unsigned char *)&v42.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v42, "SELECT ");
  CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::commaSeparatedColumnNames(&v41);
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v13 = &v41;
  }
  else {
    uint64_t v13 = (std::string *)v41.__r_.__value_.__r.__words[0];
  }
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v14 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v14 = v41.__r_.__value_.__l.__size_;
  }
  double v15 = std::string::append(&v42, (const std::string::value_type *)v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  unint64_t v17 = std::string::append(&v43, " FROM ");
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v44.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  uint64_t v19 = std::string::append(&v44, "MiLoCustomLoiTable");
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  long long v21 = std::string::append(&v45, " ");
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if ((v50 & 0x80u) == 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if ((v50 & 0x80u) == 0) {
    std::string::size_type v24 = v50;
  }
  else {
    std::string::size_type v24 = *(void *)v49;
  }
  int v25 = std::string::append(&v53, p_p, v24);
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v54.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  uint64_t v27 = std::string::append(&v54, " ORDER BY ");
  long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  if ((v52 & 0x80u) == 0) {
    uint64_t v29 = (const std::string::value_type *)v51;
  }
  else {
    uint64_t v29 = (const std::string::value_type *)v51[0];
  }
  if ((v52 & 0x80u) == 0) {
    std::string::size_type v30 = v52;
  }
  else {
    std::string::size_type v30 = v51[1];
  }
  int v31 = std::string::append(&v55, v29, v30);
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v56.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  char v33 = std::string::append(&v56, " DESC LIMIT ");
  long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v34;
  v33->__r_.__value_.__l.__size_ = 0;
  v33->__r_.__value_.__r.__words[2] = 0;
  v33->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v40, a2);
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v35 = &v40;
  }
  else {
    uint64_t v35 = (std::string *)v40.__r_.__value_.__r.__words[0];
  }
  if ((v40.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v36 = HIBYTE(v40.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v36 = v40.__r_.__value_.__l.__size_;
  }
  int v37 = std::string::append(&v46, (const std::string::value_type *)v35, v36);
  long long v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v56.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v55.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string v39 = (sqlite3 *)&v47;
  }
  else {
    std::string v39 = (sqlite3 *)v47.__r_.__value_.__r.__words[0];
  }
  CLSqliteDatabase::prepareScopedStatement(this->var0, v39);
}

void sub_256400CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (*(char *)(v50 - 73) < 0) {
    operator delete(*(void **)(v50 - 96));
  }
  if (a43 < 0) {
    operator delete(__p);
  }
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a50 < 0) {
    operator delete(a45);
  }
  if (*(char *)(v50 - 193) < 0) {
    operator delete(*(void **)(v50 - 216));
  }
  _Unwind_Resume(a1);
}

void sub_256400FD4()
{
}

void sub_256400FE0(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x256400EECLL);
}

void sub_256400FF0()
{
}

double CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::commaSeparatedColumnNames@<D0>(std::string *a1@<X8>)
{
  memset(&v3, 0, sizeof(v3));
  CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul>(&v3);
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_256401040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_52()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

uint64_t CLMicroLocationDatabaseColumns::convert_from_sql<boost::uuids::uuid>::convert(sqlite3_stmt *a1, int a2)
{
  CLMicroLocationDatabaseColumns::convert_from_sql<std::string>::convert(a1, a2, __p);
  unint64_t v2 = v8;
  if ((v8 & 0x80u) == 0) {
    std::string v3 = (unsigned __int8 *)__p;
  }
  else {
    std::string v3 = (unsigned __int8 *)__p[0];
  }
  if ((v8 & 0x80u) != 0) {
    unint64_t v2 = (unint64_t)__p[1];
  }
  uint64_t v4 = boost::uuids::string_generator::operator()<std::__wrap_iter<char const*>>((boost::uuids::string_generator *)&v6, v3, &v3[v2]);
  if ((char)v8 < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_256401114(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CLMicroLocationDatabaseColumns::convert_from_sql<std::string>::convert(sqlite3_stmt *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v4 = (char *)sqlite3_column_text(a1, a2);
  if (v4)
  {
    std::string::basic_string[abi:ne180100]<0>(a3, v4);
  }
  else
  {
    char v5 = (std::runtime_error *)CLMicroLocationDatabaseColumns::convert_from_sql<std::string>::convert(0);
    CLMicroLocationDatabaseColumns::InvalidDatabaseValue::~InvalidDatabaseValue(v5);
  }
}

void CLMicroLocationDatabaseColumns::InvalidDatabaseValue::~InvalidDatabaseValue(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x25A2A6340);
}

uint64_t boost::uuids::string_generator::operator()<std::__wrap_iter<char const*>>(boost::uuids::string_generator *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  v17[2] = *MEMORY[0x263EF8340];
  if (a2 == a3) {
    goto LABEL_32;
  }
  char v5 = (signed __int8 *)(a2 + 1);
  int v6 = *a2;
  if (v6 == 123)
  {
    if (v5 == (signed __int8 *)a3) {
      goto LABEL_32;
    }
    char v5 = (signed __int8 *)(a2 + 2);
    signed __int8 v7 = a2[1];
  }
  else
  {
    signed __int8 v7 = *a2;
  }
  uint64_t v8 = 0;
  int v9 = 0;
  while (1)
  {
    do
    {
      if (v8 == 4)
      {
        if (v7 == 45)
        {
          if (v5 == (signed __int8 *)a3) {
            goto LABEL_32;
          }
          int v9 = 1;
LABEL_22:
          signed __int8 v12 = *v5++;
          signed __int8 v7 = v12;
          goto LABEL_24;
        }
        int v9 = 0;
      }
      else
      {
        BOOL v11 = (v8 & 0x7FFFFFFD) == 8 || v8 == 6;
        if (v11 && ((v9 ^ 1) & 1) == 0)
        {
          if (v7 != 45 || v5 == (signed __int8 *)a3) {
            goto LABEL_32;
          }
          goto LABEL_22;
        }
      }
LABEL_24:
      char value = boost::uuids::string_generator::get_value(this, v7);
      *((unsigned char *)v17 + v8) = value;
      if (v5 == (signed __int8 *)a3) {
        goto LABEL_32;
      }
      int v14 = *v5++;
      signed __int8 v7 = v14;
      *((unsigned char *)v17 + v8++) = boost::uuids::string_generator::get_value(this, v14) | (16 * value);
    }
    while (!v8);
    if (v8 == 16) {
      break;
    }
    if (v5 == (signed __int8 *)a3) {
      goto LABEL_32;
    }
    signed __int8 v10 = *v5++;
    signed __int8 v7 = v10;
  }
  if (v6 == 123 && (v5 == (signed __int8 *)a3 || (int v15 = *v5, ++v5, v15 != 125))
    || v5 != (signed __int8 *)a3)
  {
LABEL_32:
    boost::uuids::string_generator::throw_invalid(this);
  }
  return v17[0];
}

uint64_t CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::RecordingEvent>::convert<CLMicroLocationProto::RecordingEvent>@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, CLMicroLocationProto::RecordingEvent *a3@<X8>)
{
  int v6 = sqlite3_column_blob(a1, a2);
  uint64_t v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::RecordingEvent>::convert<CLMicroLocationProto::RecordingEvent>(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v11, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v11);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_2704DDC68;
  }
  CLMicroLocationProto::RecordingEvent::RecordingEvent(a3);
  uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v8, v6);
  if ((result & 1) == 0) {
    goto LABEL_5;
  }
  return result;
}

void sub_256401430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      CLMicroLocationProto::RecordingEvent::~RecordingEvent(v15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

sqlite3_int64 CLMicroLocationDatabaseColumns::convert_from_sql<unsigned long long>::convert<unsigned long long>(sqlite3_stmt *a1, int a2)
{
  sqlite3_int64 result = sqlite3_column_int64(a1, a2);
  if (result < 0)
  {
    uint64_t v3 = CLMicroLocationDatabaseColumns::convert_from_sql<unsigned long long>::convert<unsigned long long>();
    return CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::Measurement>::convert<CLMicroLocationProto::Measurement>(v3);
  }
  return result;
}

uint64_t CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::Measurement>::convert<CLMicroLocationProto::Measurement>@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, CLMicroLocationProto::Measurement *a3@<X8>)
{
  int v6 = sqlite3_column_blob(a1, a2);
  uint64_t v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::Measurement>::convert<CLMicroLocationProto::Measurement>(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v11, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v11);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_2704DDC68;
  }
  CLMicroLocationProto::Measurement::Measurement(a3);
  uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v8, v6);
  if ((result & 1) == 0) {
    goto LABEL_5;
  }
  return result;
}

void sub_256401578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      CLMicroLocationProto::Measurement::~Measurement(v15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::RapportDevice>::convert<CLMicroLocationProto::RapportDevice>@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  int v6 = sqlite3_column_blob(a1, a2);
  uint64_t v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::RapportDevice>::convert<CLMicroLocationProto::RapportDevice>(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v11, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v11);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_2704DDC68;
  }
  uint64_t v8 = (wireless_diagnostics::google::protobuf::MessageLite *)CLMicroLocationProto::RapportDevice::RapportDevice(a3);
  uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v8, v6);
  if ((result & 1) == 0) {
    goto LABEL_5;
  }
  return result;
}

void sub_2564016A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      CLMicroLocationProto::RapportDevice::~RapportDevice(v15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t CLMicroLocationDatabaseColumns::convert_from_sql<BOOL>::convert<BOOL>(sqlite3_stmt *a1, int a2)
{
  unint64_t v2 = sqlite3_column_int64(a1, a2);
  if ((v2 & 0x8000000000000000) != 0)
  {
    unint64_t v2 = CLMicroLocationDatabaseColumns::convert_from_sql<BOOL>::convert<BOOL>();
  }
  else if (v2 < 2)
  {
    return v2 != 0;
  }
  uint64_t v4 = CLMicroLocationDatabaseColumns::convert_from_sql<BOOL>::convert<BOOL>(v2);
  return CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::Configuration>::convert<CLMicroLocationProto::Configuration>(v4);
}

uint64_t CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::Configuration>::convert<CLMicroLocationProto::Configuration>@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, CLMicroLocationProto::Configuration *a3@<X8>)
{
  int v6 = sqlite3_column_blob(a1, a2);
  uint64_t v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::Configuration>::convert<CLMicroLocationProto::Configuration>(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v11, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v11);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_2704DDC68;
  }
  CLMicroLocationProto::Configuration::Configuration(a3);
  uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v8, v6);
  if ((result & 1) == 0) {
    goto LABEL_5;
  }
  return result;
}

void sub_2564017FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      CLMicroLocationProto::Configuration::~Configuration(v15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::Model>::convert<CLMicroLocationProto::Model>@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, CLMicroLocationProto::Model *a3@<X8>)
{
  int v6 = sqlite3_column_blob(a1, a2);
  uint64_t v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::Model>::convert<CLMicroLocationProto::Model>(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v11, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v11);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_2704DDC68;
  }
  CLMicroLocationProto::Model::Model(a3);
  uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v8, v6);
  if ((result & 1) == 0) {
    goto LABEL_5;
  }
  return result;
}

void sub_256401924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      CLMicroLocationProto::Model::~Model(v15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::ReceivedEvent>::convert<CLMicroLocationProto::ReceivedEvent>@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, CLMicroLocationProto::ReceivedEvent *a3@<X8>)
{
  int v6 = sqlite3_column_blob(a1, a2);
  uint64_t v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    CLMicroLocationDatabaseColumns::convert_from_sql<CLMicroLocationProto::ReceivedEvent>::convert<CLMicroLocationProto::ReceivedEvent>(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::string::basic_string[abi:ne180100]<0>(&v11, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v11);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_2704DDC68;
  }
  CLMicroLocationProto::ReceivedEvent::ReceivedEvent(a3);
  uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v8, v6);
  if ((result & 1) == 0) {
    goto LABEL_5;
  }
  return result;
}

void sub_256401A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      CLMicroLocationProto::ReceivedEvent::~ReceivedEvent(v15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul,6ul,7ul,8ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<3ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<4ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<5ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<6ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<7ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<8ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  unint64_t v2 = std::string::append(&v7, "RecordingUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256401BA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RecordingTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256401C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RTLOIType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256401D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "ReceivedTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256401E44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "EventType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256401F24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<5ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "Event");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256402004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<6ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564020E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<7ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "TriggerUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564021C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRecordingEventTable::DatabaseColumns::RecordingUUID,ULRecordingEventTable::DatabaseColumns::RecordingTimestamp,ULRecordingEventTable::DatabaseColumns::RTLOIType,ULRecordingEventTable::DatabaseColumns::ReceivedTimestamp,ULRecordingEventTable::DatabaseColumns::EventType,ULRecordingEventTable::DatabaseColumns::Event,ULRecordingEventTable::DatabaseColumns::RowId,ULRecordingEventTable::DatabaseColumns::TriggerUUID,ULRecordingEventTable::DatabaseColumns::RtLoiGroupId>::addColumnName<8ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RtLoiGroupId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564022A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationRecordingEventsTable::Entry>::__emplace_back_slow_path<boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,std::string &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,CLMicroLocationProto::EventType &,CLMicroLocationProto::RecordingEvent &,std::string &,boost::uuids::uuid>(uint64_t *a1, uint64_t *a2, double *a3, uint64_t a4, double *a5, int *a6, CLMicroLocationProto::RecordingEvent *a7, uint64_t a8, uint64_t *a9)
{
  unint64_t v10 = 0xEF7BDEF7BDEF7BDFLL * ((a1[1] - *a1) >> 3);
  unint64_t v11 = v10 + 1;
  if (v10 + 1 > 0x108421084210842) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  if (0xDEF7BDEF7BDEF7BELL * ((a1[2] - *a1) >> 3) > v11) {
    unint64_t v11 = 0xDEF7BDEF7BDEF7BELL * ((a1[2] - *a1) >> 3);
  }
  if (0xEF7BDEF7BDEF7BDFLL * ((a1[2] - *a1) >> 3) >= 0x84210842108421) {
    unint64_t v19 = 0x108421084210842;
  }
  else {
    unint64_t v19 = v11;
  }
  long long v28 = a1 + 2;
  if (v19)
  {
    unint64_t v23 = v10;
    long long v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingEventsTable::Entry>>((uint64_t)(a1 + 2), v19);
    unint64_t v10 = v23;
  }
  else
  {
    long long v20 = 0;
  }
  std::string::size_type v24 = v20;
  int v25 = &v20[248 * v10];
  uint64_t v27 = &v20[248 * v19];
  std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,std::string &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,CLMicroLocationProto::EventType &,CLMicroLocationProto::RecordingEvent &,std::string &,boost::uuids::uuid>((uint64_t)(a1 + 2), (uint64_t)v25, a2, a3, a4, a5, a6, a7, a8, a9);
  long long v26 = v25 + 248;
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__swap_out_circular_buffer(a1, &v24);
  uint64_t v21 = a1[1];
  std::__split_buffer<CLMicroLocationRecordingEventsTable::Entry>::~__split_buffer(&v24);
  return v21;
}

void sub_256402440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<CLMicroLocationRecordingEventsTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::allocator<CLMicroLocationRecordingEventsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry,boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,std::string &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,CLMicroLocationProto::EventType &,CLMicroLocationProto::RecordingEvent &,std::string &,boost::uuids::uuid>(uint64_t a1, uint64_t a2, uint64_t *a3, double *a4, uint64_t a5, double *a6, int *a7, CLMicroLocationProto::RecordingEvent *a8, uint64_t a9, uint64_t *a10)
{
  uint64_t v14 = *a3;
  uint64_t v15 = a3[1];
  double v16 = *a4;
  if (*(char *)(a5 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
  }
  else {
    std::string v20 = *(std::string *)a5;
  }
  double v17 = *a6;
  int v18 = *a7;
  if (*(char *)(a9 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v19, *(const std::string::value_type **)a9, *(void *)(a9 + 8));
  }
  else
  {
    *(_OWORD *)&v19.__r_.__value_.__l.__data_ = *(_OWORD *)a9;
    v19.__r_.__value_.__r.__words[2] = *(void *)(a9 + 16);
  }
  CLMicroLocationRecordingEventsTable::Entry::Entry(a2, v14, v15, (long long *)&v20, v18, a8, (uint64_t)&v19, (int)a8, v16, v17, *a10, a10[1]);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
}

void sub_256402560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<3ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<4ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<5ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  unint64_t v2 = std::string::append(&v7, "RecordingUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640268C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "ScanCFTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640276C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "ScanMCTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640284C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "Data");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640292C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "Flags");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256402A0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULMeasurementTable::DatabaseColumns::RecordingUUID,ULMeasurementTable::DatabaseColumns::ScanCFTimestamp,ULMeasurementTable::DatabaseColumns::ScanMCTimestamp,ULMeasurementTable::DatabaseColumns::Data,ULMeasurementTable::DatabaseColumns::Flags,ULMeasurementTable::DatabaseColumns::RowId>::addColumnName<5ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256402AEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationMeasurementTable::Entry>::__emplace_back_slow_path<boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,unsigned long long &,CLMicroLocationProto::Measurement &,CLMicroLocationMeasurementTable::EntryFlags &>(uint64_t *a1, uint64_t *a2, double *a3, uint64_t *a4, CLMicroLocationProto::Measurement *a5, unsigned int *a6)
{
  uint64_t v7 = *a1;
  unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  unint64_t v9 = v8 + 1;
  if (v8 + 1 > 0x222222222222222) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v15 = (uint64_t)(a1 + 2);
  unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v7) >> 3);
  if (2 * v16 > v9) {
    unint64_t v9 = 2 * v16;
  }
  if (v16 >= 0x111111111111111) {
    unint64_t v17 = 0x222222222222222;
  }
  else {
    unint64_t v17 = v9;
  }
  int v25 = a1 + 2;
  if (v17) {
    int v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>>(v15, v17);
  }
  else {
    int v18 = 0;
  }
  uint64_t v21 = v18;
  long long v22 = &v18[120 * v8];
  uint64_t v23 = (uint64_t)v22;
  std::string::size_type v24 = &v18[120 * v17];
  CLMicroLocationMeasurementTable::Entry::Entry((uint64_t)v22, *a2, a2[1], *a4, a5, *a6 | 0x100000000, *a3);
  uint64_t v23 = (uint64_t)(v22 + 120);
  std::vector<CLMicroLocationMeasurementTable::Entry>::__swap_out_circular_buffer(a1, &v21);
  uint64_t v19 = a1[1];
  std::__split_buffer<CLMicroLocationMeasurementTable::Entry>::~__split_buffer((uint64_t)&v21);
  return v19;
}

void sub_256402C48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationMeasurementTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<3ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<4ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  unint64_t v2 = std::string::append(&v7, "TriggerUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256402D4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "ClientID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256402E2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "LabelUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256402F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "ReceivedTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256402FEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLabelTable::DatabaseColumns::TriggerUUID,ULLabelTable::DatabaseColumns::ClientID,ULLabelTable::DatabaseColumns::LabelUUID,ULLabelTable::DatabaseColumns::ReceivedTimestamp,ULLabelTable::DatabaseColumns::RowId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564030CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__emplace_back_slow_path<boost::uuids::uuid &,std::string &,boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t *a4, double *a5)
{
  uint64_t v6 = (a1[1] - *a1) >> 6;
  unint64_t v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) >> 58) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v12 = a1[2] - *a1;
  if (v12 >> 5 > v7) {
    unint64_t v7 = v12 >> 5;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFC0) {
    unint64_t v13 = 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v7;
  }
  uint64_t v21 = a1 + 2;
  if (v13) {
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>((uint64_t)(a1 + 2), v13);
  }
  else {
    uint64_t v14 = 0;
  }
  unint64_t v17 = v14;
  int v18 = &v14[64 * v6];
  std::string v20 = &v14[64 * v13];
  std::allocator<CLMicroLocationRecordingLabelsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingLabelsTable::Entry,boost::uuids::uuid &,std::string &,boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>((uint64_t)(a1 + 2), (uint64_t)v18, a2, a3, a4, a5);
  uint64_t v19 = v18 + 64;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__swap_out_circular_buffer(a1, &v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::~__split_buffer((uint64_t)&v17);
  return v15;
}

void sub_256403204(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::allocator<CLMicroLocationRecordingLabelsTable::Entry>::construct[abi:ne180100]<CLMicroLocationRecordingLabelsTable::Entry,boost::uuids::uuid &,std::string &,boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, double *a6)
{
  uint64_t v9 = *a3;
  uint64_t v10 = a3[1];
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    std::string __p = *(std::string *)a4;
  }
  CLMicroLocationRecordingLabelsTable::Entry::Entry(a2, v9, v10, (long long *)&__p, *a5, a5[1], *a6);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2564032B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul,6ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<3ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<4ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<5ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<6ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  unint64_t v2 = std::string::append(&v7, "ServiceUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564033CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "LastActiveTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564034AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "ServiceType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640358C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "ClientID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640366C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "LocationTypes");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640374C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<5ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640382C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULServiceTable::DatabaseColumns::ServiceUUID,ULServiceTable::DatabaseColumns::LastActiveTimestamp,ULServiceTable::DatabaseColumns::ServiceType,ULServiceTable::DatabaseColumns::ClientID,ULServiceTable::DatabaseColumns::LocationTypes,ULServiceTable::DatabaseColumns::RowId,ULServiceTable::DatabaseColumns::UserId>::addColumnName<6ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "UserId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640390C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMiLoServiceTable::Entry>::__emplace_back_slow_path<boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,unsigned long long &,std::string &,unsigned long long &,std::string &>(uint64_t *a1, void *a2, double *a3, unsigned int *a4, uint64_t a5, void *a6, uint64_t a7)
{
  uint64_t v8 = *a1;
  uint64_t v9 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v10 = v9 + 1;
  if ((unint64_t)(v9 + 1) > 0x2E8BA2E8BA2E8BALL) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v17 = (uint64_t)(a1 + 2);
  unint64_t v18 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v8) >> 3);
  if (2 * v18 > v10) {
    unint64_t v10 = 2 * v18;
  }
  if (v18 >= 0x1745D1745D1745DLL) {
    unint64_t v19 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v19 = v10;
  }
  uint64_t v27 = a1 + 2;
  if (v19) {
    std::string v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>>(v17, v19);
  }
  else {
    std::string v20 = 0;
  }
  uint64_t v23 = v20;
  std::string::size_type v24 = &v20[88 * v9];
  int v25 = v24;
  long long v26 = &v20[88 * v19];
  CLMiLoServiceTable::Entry::Entry(v24, *a2, a2[1], *a4, a5, *a6, a7, *a3);
  int v25 = v24 + 88;
  std::vector<CLMiLoServiceTable::Entry>::__swap_out_circular_buffer(a1, &v23);
  uint64_t v21 = a1[1];
  std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer(&v23);
  return v21;
}

void sub_256403A84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<3ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<4ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  unint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256403B88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "LastSeenTimeStamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256403C68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "LoiId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256403D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "LoiGroupId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256403E28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoiTable::DatabaseColumns::RowId,ULLoiTable::DatabaseColumns::LastSeenTimeStamp,ULLoiTable::DatabaseColumns::LoiId,ULLoiTable::DatabaseColumns::LoiGroupId,ULLoiTable::DatabaseColumns::LoiType>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "LoiType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256403F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMiLoLoiTable::Entry>::__emplace_back_slow_path<std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,boost::uuids::uuid,boost::uuids::uuid,std::string &>(uint64_t *a1, double *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v6 = (a1[1] - *a1) >> 6;
  unint64_t v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) >> 58) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v12 = a1[2] - *a1;
  if (v12 >> 5 > v7) {
    unint64_t v7 = v12 >> 5;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFC0) {
    unint64_t v13 = 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v7;
  }
  uint64_t v21 = a1 + 2;
  if (v13) {
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>((uint64_t)(a1 + 2), v13);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v17 = v14;
  unint64_t v18 = &v14[64 * v6];
  std::string v20 = &v14[64 * v13];
  std::allocator<CLMiLoLoiTable::Entry>::construct[abi:ne180100]<CLMiLoLoiTable::Entry,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,boost::uuids::uuid,boost::uuids::uuid,std::string &>((uint64_t)(a1 + 2), (uint64_t)v18, a2, a3, a4, a5);
  unint64_t v19 = v18 + 64;
  std::vector<CLMiLoLoiTable::Entry>::__swap_out_circular_buffer(a1, &v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<CLMiLoLoiTable::Entry>::~__split_buffer((uint64_t)&v17);
  return v15;
}

void sub_256404040(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMiLoLoiTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::allocator<CLMiLoLoiTable::Entry>::construct[abi:ne180100]<CLMiLoLoiTable::Entry,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,boost::uuids::uuid,boost::uuids::uuid,std::string &>(uint64_t a1, uint64_t a2, double *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  double v7 = *a3;
  uint64_t v8 = *a4;
  uint64_t v9 = a4[1];
  uint64_t v10 = *a5;
  uint64_t v11 = a5[1];
  if (*(char *)(a6 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a6, *(void *)(a6 + 8));
  }
  else {
    std::string __p = *(std::string *)a6;
  }
  CLMiLoLoiTable::Entry::Entry(a2, v8, v9, v10, v11, (long long *)&__p, v7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2564040F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<3ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<4ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  unint64_t v2 = std::string::append(&v7, "GenerationTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256404204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RTLOIType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564042E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "Device");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564043C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564044A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULRapportTable::DatabaseColumns::GenerationTimestamp,ULRapportTable::DatabaseColumns::RTLOIType,ULRapportTable::DatabaseColumns::Device,ULRapportTable::DatabaseColumns::RowId,ULRapportTable::DatabaseColumns::RtLoiGroupId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  unint64_t v2 = std::string::append(&v7, "RtLoiGroupId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256404584(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationRapportTable::Entry>::__emplace_back_slow_path<std::string &,CLMicroLocationProto::RapportDevice &,boost::uuids::uuid,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0x333333333333333) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v7) {
    unint64_t v7 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) >= 0x199999999999999) {
    unint64_t v12 = 0x333333333333333;
  }
  else {
    unint64_t v12 = v7;
  }
  std::string v20 = a1 + 2;
  if (v12) {
    unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRapportMonitor::Item>>((uint64_t)(a1 + 2), v12);
  }
  else {
    unint64_t v13 = 0;
  }
  unint64_t v16 = v13;
  uint64_t v17 = &v13[80 * v6];
  unint64_t v19 = &v13[80 * v12];
  std::allocator<CLMicroLocationRapportTable::Entry>::construct[abi:ne180100]<CLMicroLocationRapportTable::Entry,std::string &,CLMicroLocationProto::RapportDevice &,boost::uuids::uuid,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>((uint64_t)(a1 + 2), (uint64_t)v17, a2, a3, a4, a5);
  unint64_t v18 = v17 + 80;
  std::vector<CLMicroLocationRapportTable::Entry>::__swap_out_circular_buffer(a1, &v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<CLMicroLocationRapportTable::Entry>::~__split_buffer(&v16);
  return v14;
}

void sub_2564046DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationRapportTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::allocator<CLMicroLocationRapportTable::Entry>::construct[abi:ne180100]<CLMicroLocationRapportTable::Entry,std::string &,CLMicroLocationProto::RapportDevice &,boost::uuids::uuid,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string __p = *(std::string *)a3;
  }
  CLMicroLocationRapportTable::Entry::Entry(a2, &__p, a4, a5, a6);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_25640477C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationRapportTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRapportTable::Entry>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRapportTable::Entry>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 80;
      std::allocator<CLMicroLocationRapportTable::Entry>::construct[abi:ne180100]<CLMicroLocationRapportTable::Entry,CLMicroLocationRapportTable::Entry const&>(a1, (__n128 *)(v7 - 80), v9);
      uint64_t v7 = *((void *)&v16 + 1) - 80;
      *((void *)&v16 + 1) -= 80;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportTable::Entry>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_2564048C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__n128 std::allocator<CLMicroLocationRapportTable::Entry>::construct[abi:ne180100]<CLMicroLocationRapportTable::Entry,CLMicroLocationRapportTable::Entry const&>(uint64_t a1, __n128 *a2, uint64_t a3)
{
  a2->n128_u64[0] = *(void *)a3;
  uint64_t v5 = (std::string *)&a2->n128_i8[8];
  if (*(char *)(a3 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    a2[1].n128_u64[1] = *(void *)(a3 + 24);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  CLMicroLocationProto::RapportDevice::RapportDevice((CLMicroLocationProto::RapportDevice *)&a2[2], (const CLMicroLocationProto::RapportDevice *)(a3 + 32));
  __n128 result = *(__n128 *)(a3 + 64);
  a2[4] = result;
  return result;
}

void sub_256404954(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportTable::Entry>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportTable::Entry>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportTable::Entry>,std::reverse_iterator<CLMicroLocationRapportTable::Entry*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<CLMicroLocationRapportTable::Entry>::destroy[abi:ne180100](v3, v1);
      v1 += 80;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<CLMicroLocationRapportTable::Entry>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<CLMicroLocationRapportTable::Entry>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 80;
    std::allocator<CLMicroLocationRapportTable::Entry>::destroy[abi:ne180100](v4, i - 80);
  }
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul,6ul,7ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<3ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<4ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<5ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<6ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<7ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v2 = std::string::append(&v7, "LoiType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256404B80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LoiGroupId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256404C60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "Timestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256404D40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "IsAssociated");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256404E20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "MacAddress");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256404F00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<5ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "Band");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256404FE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<6ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "Channel");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564050C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULAssociatedStateTable::DatabaseColumns::LoiType,ULAssociatedStateTable::DatabaseColumns::LoiGroupId,ULAssociatedStateTable::DatabaseColumns::Timestamp,ULAssociatedStateTable::DatabaseColumns::IsAssociated,ULAssociatedStateTable::DatabaseColumns::MacAddress,ULAssociatedStateTable::DatabaseColumns::Band,ULAssociatedStateTable::DatabaseColumns::Channel,ULAssociatedStateTable::DatabaseColumns::RowId>::addColumnName<7ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564051A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationAssociatedStateTable::Entry>::__emplace_back_slow_path<std::string &,boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,BOOL &,CLMacAddress,CLMicroLocationAssociatedStateTable::Entry::Band,long long &>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, unsigned int *a7, unsigned int *a8)
{
  uint64_t v9 = *a1;
  unint64_t v10 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v11 = v10 + 1;
  if (v10 + 1 > 0x38E38E38E38E38ELL) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v19 = (uint64_t)(a1 + 2);
  unint64_t v20 = 0x8E38E38E38E38E39 * ((a1[2] - v9) >> 3);
  if (2 * v20 > v11) {
    unint64_t v11 = 2 * v20;
  }
  if (v20 >= 0x1C71C71C71C71C7) {
    unint64_t v21 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v21 = v11;
  }
  uint64_t v29 = a1 + 2;
  if (v21) {
    long long v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationAssociatedStateTable::Entry>>(v19, v21);
  }
  else {
    long long v22 = 0;
  }
  int v25 = v22;
  long long v26 = &v22[72 * v10];
  uint64_t v27 = v26;
  long long v28 = &v22[72 * v21];
  CLMicroLocationAssociatedStateTable::Entry::Entry(v26, a2, a3, a4, *a5, a6, *a7, *a8);
  uint64_t v27 = v26 + 72;
  std::vector<CLMicroLocationAssociatedStateTable::Entry>::__swap_out_circular_buffer(a1, &v25);
  uint64_t v23 = a1[1];
  std::__split_buffer<CLMicroLocationAssociatedStateTable::Entry>::~__split_buffer((uint64_t)&v25);
  return v23;
}

void sub_256405328(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationAssociatedStateTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<3ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<4ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640542C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LastSeenTimeStamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640550C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "BluetoothId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564055EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "DeviceName");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564056CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULBlueToothIdentityTable::DatabaseColumns::RowId,ULBlueToothIdentityTable::DatabaseColumns::LastSeenTimeStamp,ULBlueToothIdentityTable::DatabaseColumns::BluetoothId,ULBlueToothIdentityTable::DatabaseColumns::DeviceName,ULBlueToothIdentityTable::DatabaseColumns::StableIdentifier>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "StableIdentifier");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564057AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationBluetoothIdentityTable::Entry>::__emplace_back_slow_path<boost::uuids::uuid,std::string &,std::string &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, double *a5)
{
  unint64_t v6 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0x38E38E38E38E38ELL) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  if (0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3) > v7) {
    unint64_t v7 = 0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3);
  }
  if (0x8E38E38E38E38E39 * ((a1[2] - *a1) >> 3) >= 0x1C71C71C71C71C7) {
    unint64_t v12 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v12 = v7;
  }
  unint64_t v20 = a1 + 2;
  if (v12) {
    unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationAssociatedStateTable::Entry>>((uint64_t)(a1 + 2), v12);
  }
  else {
    unint64_t v13 = 0;
  }
  long long v16 = v13;
  uint64_t v17 = &v13[72 * v6];
  uint64_t v19 = &v13[72 * v12];
  std::allocator<CLMicroLocationBluetoothIdentityTable::Entry>::construct[abi:ne180100]<CLMicroLocationBluetoothIdentityTable::Entry,boost::uuids::uuid,std::string &,std::string &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>((uint64_t)(a1 + 2), (uint64_t)v17, a2, a3, a4, a5);
  unint64_t v18 = v17 + 72;
  std::vector<CLMicroLocationBluetoothIdentityTable::Entry>::__swap_out_circular_buffer(a1, &v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<CLMicroLocationBluetoothIdentityTable::Entry>::~__split_buffer(&v16);
  return v14;
}

void sub_25640591C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationBluetoothIdentityTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::allocator<CLMicroLocationBluetoothIdentityTable::Entry>::construct[abi:ne180100]<CLMicroLocationBluetoothIdentityTable::Entry,boost::uuids::uuid,std::string &,std::string &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, double *a6)
{
  uint64_t v9 = *a3;
  uint64_t v10 = a3[1];
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    std::string v12 = *(std::string *)a4;
  }
  if (*(char *)(a5 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
  }
  else {
    std::string __p = *(std::string *)a5;
  }
  CLMicroLocationBluetoothIdentityTable::Entry::Entry(a2, v9, v10, &v12, &__p, *a6);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
}

void sub_256405A00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationBluetoothIdentityTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationBluetoothIdentityTable::Entry>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationBluetoothIdentityTable::Entry>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    do
    {
      *(_OWORD *)(v7 - 72) = *(_OWORD *)(a3 - 72);
      long long v8 = *(_OWORD *)(a3 - 56);
      *(void *)(v7 - 40) = *(void *)(a3 - 40);
      *(_OWORD *)(v7 - 56) = v8;
      *(void *)(a3 - 48) = 0;
      *(void *)(a3 - 40) = 0;
      *(void *)(a3 - 56) = 0;
      long long v9 = *(_OWORD *)(a3 - 32);
      *(void *)(v7 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v7 - 32) = v9;
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(v7 - 8) = *(void *)(a3 - 8);
      uint64_t v7 = *((void *)&v15 + 1) - 72;
      *((void *)&v15 + 1) -= 72;
      a3 -= 72;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationBluetoothIdentityTable::Entry>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationBluetoothIdentityTable::Entry>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationBluetoothIdentityTable::Entry>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationBluetoothIdentityTable::Entry>,std::reverse_iterator<CLMicroLocationBluetoothIdentityTable::Entry*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<CLMicroLocationRapportMonitor::Item>::destroy[abi:ne180100](v3, v1);
      v1 += 72;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<CLMicroLocationBluetoothIdentityTable::Entry>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<CLMicroLocationBluetoothIdentityTable::Entry>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 72;
    std::allocator<CLMicroLocationRapportMonitor::Item>::destroy[abi:ne180100](v4, i - 72);
  }
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<3ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<4ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<5ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v2 = std::string::append(&v7, "GenerationTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256405D78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "RTLOIType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256405E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "ConfigurationType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256405F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "Configuration");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256406018(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564060F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULConfigurationTable::DatabaseColumns::GenerationTimestamp,ULConfigurationTable::DatabaseColumns::RTLOIType,ULConfigurationTable::DatabaseColumns::ConfigurationType,ULConfigurationTable::DatabaseColumns::Configuration,ULConfigurationTable::DatabaseColumns::RowId,ULConfigurationTable::DatabaseColumns::RtLoiGroupId>::addColumnName<5ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "RtLoiGroupId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564061D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationConfigurationTable::Entry>::__emplace_back_slow_path<std::string &,CLMicroLocationProto::Configuration &,boost::uuids::uuid>(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) > 0x249249249249249) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4) > v6) {
    unint64_t v6 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 4)) >= 0x124924924924924) {
    unint64_t v10 = 0x249249249249249;
  }
  else {
    unint64_t v10 = v6;
  }
  unint64_t v18 = a1 + 2;
  if (v10) {
    unint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>>((uint64_t)(a1 + 2), v10);
  }
  else {
    unint64_t v11 = 0;
  }
  long long v14 = v11;
  long long v15 = &v11[112 * v5];
  uint64_t v17 = &v11[112 * v10];
  std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,std::string &,CLMicroLocationProto::Configuration &,boost::uuids::uuid>((uint64_t)(a1 + 2), (uint64_t)v15, a2, a3, a4);
  long long v16 = v15 + 112;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__swap_out_circular_buffer(a1, &v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer(&v14);
  return v12;
}

void sub_256406338(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,std::string &,CLMicroLocationProto::Configuration &,boost::uuids::uuid>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string __p = *(std::string *)a3;
  }
  CLMicroLocationConfigurationTable::Entry::Entry(a2, &__p, a4, *a5, a5[1]);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_2564063D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul,5ul,6ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<3ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<4ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<5ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<6ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v2 = std::string::append(&v7, "ModelUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564064EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "GenerationTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564065CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "ModelType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564066AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "Model");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640678C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640686C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<5ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "ClientID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640694C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULModelTable::DatabaseColumns::ModelUUID,ULModelTable::DatabaseColumns::GenerationTimestamp,ULModelTable::DatabaseColumns::ModelType,ULModelTable::DatabaseColumns::Model,ULModelTable::DatabaseColumns::RowId,ULModelTable::DatabaseColumns::ClientID,ULModelTable::DatabaseColumns::LoiGroupId>::addColumnName<6ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LoiGroupId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256406A2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationModelTable::Entry>::__emplace_back_slow_path<boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,CLMicroLocationProto::Model,std::string &,std::optional<boost::uuids::uuid> &,boost::uuids::uuid>(uint64_t *a1, uint64_t *a2, double *a3, uint64_t a4, uint64_t a5, long long *a6, void *a7)
{
  uint64_t v8 = 0x6F96F96F96F96F97 * ((a1[1] - *a1) >> 3);
  unint64_t v9 = v8 + 1;
  if ((unint64_t)(v8 + 1) > 0xD20D20D20D20D2) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  if (0xDF2DF2DF2DF2DF2ELL * ((a1[2] - *a1) >> 3) > v9) {
    unint64_t v9 = 0xDF2DF2DF2DF2DF2ELL * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x6F96F96F96F96F97 * ((a1[2] - *a1) >> 3)) >= 0x69069069069069) {
    unint64_t v16 = 0xD20D20D20D20D2;
  }
  else {
    unint64_t v16 = v9;
  }
  std::string::size_type v24 = a1 + 2;
  if (v16) {
    uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>>((uint64_t)(a1 + 2), v16);
  }
  else {
    uint64_t v17 = 0;
  }
  unint64_t v20 = v17;
  unint64_t v21 = &v17[312 * v8];
  uint64_t v23 = &v17[312 * v16];
  std::allocator<CLMicroLocationModelTable::Entry>::construct[abi:ne180100]<CLMicroLocationModelTable::Entry,boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,CLMicroLocationProto::Model,std::string &,std::optional<boost::uuids::uuid> &,boost::uuids::uuid>((uint64_t)(a1 + 2), (uint64_t)v21, a2, a3, a4, a5, a6, a7);
  long long v22 = v21 + 312;
  std::vector<CLMicroLocationModelTable::Entry>::__swap_out_circular_buffer(a1, &v20);
  uint64_t v18 = a1[1];
  std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer(&v20);
  return v18;
}

void sub_256406BB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::allocator<CLMicroLocationModelTable::Entry>::construct[abi:ne180100]<CLMicroLocationModelTable::Entry,boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,CLMicroLocationProto::Model,std::string &,std::optional<boost::uuids::uuid> &,boost::uuids::uuid>(uint64_t a1, uint64_t a2, uint64_t *a3, double *a4, uint64_t a5, uint64_t a6, long long *a7, void *a8)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v12 = *a3;
  uint64_t v13 = a3[1];
  double v14 = *a4;
  if (*(char *)(a6 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a6, *(void *)(a6 + 8));
  }
  else {
    std::string __p = *(std::string *)a6;
  }
  char v16 = 1;
  long long v17 = *a7;
  char v18 = *((unsigned char *)a7 + 16);
  CLMicroLocationModelTable::Entry::Entry(a2, v12, v13, a5, &__p, &v17, *a8, a8[1], v14);
  if (v16)
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_256406CC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul,4ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<2ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<3ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<4ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v2 = std::string::append(&v7, "EventUUID");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256406DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "ReceivedTimestamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256406EC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "EventType");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256406FA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "Event");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256407080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULLoggedEventTable::DatabaseColumns::EventUUID,ULLoggedEventTable::DatabaseColumns::ReceivedTimestamp,ULLoggedEventTable::DatabaseColumns::EventType,ULLoggedEventTable::DatabaseColumns::Event,ULLoggedEventTable::DatabaseColumns::RowId>::addColumnName<4ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_256407160(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationLoggedEventsTable::Entry>::__emplace_back_slow_path<boost::uuids::uuid &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,CLMicroLocationProto::EventType &,CLMicroLocationProto::ReceivedEvent &>(uint64_t *a1, _OWORD *a2, double *a3, int *a4, CLMicroLocationProto::ReceivedEvent *a5)
{
  uint64_t v6 = *a1;
  unint64_t v7 = 0xCF3CF3CF3CF3CF3DLL * ((a1[1] - *a1) >> 4);
  unint64_t v8 = v7 + 1;
  if (v7 + 1 > 0xC30C30C30C30C3) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v13 = (uint64_t)(a1 + 2);
  unint64_t v14 = 0xCF3CF3CF3CF3CF3DLL * ((a1[2] - v6) >> 4);
  if (2 * v14 > v8) {
    unint64_t v8 = 2 * v14;
  }
  if (v14 >= 0x61861861861861) {
    unint64_t v15 = 0xC30C30C30C30C3;
  }
  else {
    unint64_t v15 = v8;
  }
  uint64_t v23 = a1 + 2;
  if (v15) {
    char v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationLoggedEventsTable::Entry>>(v13, v15);
  }
  else {
    char v16 = 0;
  }
  uint64_t v19 = v16;
  unint64_t v20 = &v16[336 * v7];
  uint64_t v21 = (uint64_t)v20;
  long long v22 = &v16[336 * v15];
  CLMicroLocationLoggedEventsTable::Entry::Entry((uint64_t)v20, a2, *a4, a5, *a3);
  uint64_t v21 = (uint64_t)(v20 + 336);
  std::vector<CLMicroLocationLoggedEventsTable::Entry>::__swap_out_circular_buffer(a1, &v19);
  uint64_t v17 = a1[1];
  std::__split_buffer<CLMicroLocationLoggedEventsTable::Entry>::~__split_buffer((uint64_t)&v19);
  return v17;
}

void sub_2564072C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMicroLocationLoggedEventsTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::commaSeperatedNamesGenerator<0ul,1ul,2ul,3ul>(std::string *a1)
{
  CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::addColumnName<0ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::addColumnName<1ul>(a1);
  CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::addColumnName<2ul>(a1);
  return CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::addColumnName<3ul>(a1);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::addColumnName<0ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v2 = std::string::append(&v7, "RowId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_2564073BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::addColumnName<1ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "ServiceId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640749C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::addColumnName<2ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LoiId");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640757C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationDatabaseColumns::ColumnList<ULCustomLoiTable::DatabaseColumns::RowId,ULCustomLoiTable::DatabaseColumns::ServiceId,ULCustomLoiTable::DatabaseColumns::LoiId,ULCustomLoiTable::DatabaseColumns::LastSeenTimeStamp>::addColumnName<3ul>(std::string *a1)
{
  *((unsigned char *)&v7.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LastSeenTimeStamp");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t v9 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (v9 >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v5 = HIBYTE(v9);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_25640765C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMiLoCustomLoiTable::Entry>::__emplace_back_slow_path<boost::uuids::uuid,boost::uuids::uuid,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &>(uint64_t *a1, uint64_t *a2, uint64_t *a3, double *a4)
{
  std::string::size_type v5 = (char *)*a1;
  unint64_t v6 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0x666666666666666) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v11 = (uint64_t)(a1 + 2);
  unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - (uint64_t)v5) >> 3);
  if (2 * v12 > v7) {
    unint64_t v7 = 2 * v12;
  }
  if (v12 >= 0x333333333333333) {
    unint64_t v13 = 0x666666666666666;
  }
  else {
    unint64_t v13 = v7;
  }
  if (v13)
  {
    unint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoCustomLoiTable::Entry>>(v11, v13);
    uint64_t v16 = v15;
  }
  else
  {
    unint64_t v14 = 0;
    uint64_t v16 = 0;
  }
  uint64_t v17 = CLMiLoCustomLoiTable::Entry::Entry((uint64_t)&v14[40 * v6], *a2, a2[1], *a3, a3[1], *a4);
  uint64_t v18 = v17 + 40;
  unint64_t v20 = (char *)*a1;
  uint64_t v19 = (char *)a1[1];
  if (v19 != (char *)*a1)
  {
    do
    {
      long long v21 = *(_OWORD *)(v19 - 40);
      long long v22 = *(_OWORD *)(v19 - 24);
      *(void *)(v17 - 8) = *((void *)v19 - 1);
      *(_OWORD *)(v17 - 24) = v22;
      *(_OWORD *)(v17 - 40) = v21;
      v17 -= 40;
      v19 -= 40;
    }
    while (v19 != v20);
    uint64_t v19 = (char *)*a1;
  }
  *a1 = v17;
  a1[1] = v18;
  a1[2] = (uint64_t)&v14[40 * v16];
  if (v19) {
    operator delete(v19);
  }
  return v18;
}

void sub_2564077C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoCustomLoiTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(40 * a2);
}

std::runtime_error *CLMicroLocationFingerprintDataSources::IInterruptibleDataSource::CancelledException::CancelledException(std::runtime_error *a1, const std::string *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_2704DD628;
  return result;
}

id CLMicroLocationFingerprintDataSources::create(unsigned int a1)
{
  if (a1 < 2)
  {
    if (a1) {
      std::make_unique[abi:ne180100]<CLMicroLocationFingerprintStdVectorSource,std::function<BOOL ()(void)> &,std::function<CLMicroLocationFingerprintConfiguration ()(void)> &,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,ULDatabase &>();
    }
    std::make_unique[abi:ne180100]<CLMicroLocationFingerprintDatabaseSource,std::function<BOOL ()(void)> &,std::function<CLMicroLocationFingerprintConfiguration ()(void)> &,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,ULDatabase &>();
  }
  CLMicroLocationFingerprintDataSources::create();
  return _CLLogObjectForCategory_MicroLocation_Default();
}

void std::make_unique[abi:ne180100]<CLMicroLocationFingerprintDatabaseSource,std::function<BOOL ()(void)> &,std::function<CLMicroLocationFingerprintConfiguration ()(void)> &,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,ULDatabase &>()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_2564079F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::__function::__value_func<CLMicroLocationFingerprintConfiguration ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  MEMORY[0x25A2A6340](v2, 0x10B3C40564B07AALL);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<CLMicroLocationFingerprintStdVectorSource,std::function<BOOL ()(void)> &,std::function<CLMicroLocationFingerprintConfiguration ()(void)> &,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,ULDatabase &>()
{
  uint64_t v0 = *MEMORY[0x263EF8340];
  operator new();
}

void sub_256407B0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::__function::__value_func<CLMicroLocationFingerprintConfiguration ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<BOOL ()(void)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  MEMORY[0x25A2A6340](v2, 0xA1C4030951706);
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_53()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

double CLCommonConvertTicksToSeconds(unint64_t a1)
{
  double v2 = *(double *)&CLCommonConvertTicksToSeconds::ticksToSeconds;
  if (*(double *)&CLCommonConvertTicksToSeconds::ticksToSeconds == 0.0)
  {
    mach_timebase_info(&info);
    if (info.denom)
    {
      uint32_t denom = info.denom;
      uint32_t numer = info.numer;
      do
      {
        uint32_t v5 = denom;
        uint32_t denom = numer % denom;
        uint32_t numer = v5;
      }
      while (denom);
    }
    else
    {
      uint32_t v5 = info.numer;
    }
    unsigned int v6 = 1000000000;
    uint32_t v7 = info.numer / v5;
    do
    {
      uint32_t v8 = v7;
      uint32_t v7 = v6;
      unsigned int v6 = v8 % v6;
    }
    while (v6);
    double v2 = (double)(info.numer / v5 / v7) / (double)(0x3B9ACA00 / v7 * (unint64_t)(info.denom / v5));
    *(double *)&CLCommonConvertTicksToSeconds::ticksToSeconds = v2;
  }
  return v2 * (double)a1;
}

double CLCommonGetMachContinuousTime()
{
  uint64_t v0 = mach_continuous_time();
  return CLCommonConvertTicksToSeconds(v0);
}

void CLMicroLocationLegacyEventHomeKit::handleEvent(void *a1@<X1>, double *a2@<X2>, unsigned char *a3@<X8>)
{
  id v6 = a1;
  uint32_t v5 = [v6 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"];

  if (v5) {
    CLMicroLocationLegacyEventHomeKit::handleEventScene(v6, a2, a3);
  }
  else {
    CLMicroLocationLegacyEventHomeKit::handleEventAccessory(v6, a2, a3);
  }
}

void sub_256407D24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationLegacyEventHomeKit::handleEventScene(void *a1@<X1>, double *a2@<X2>, unsigned char *a3@<X8>)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  id v5 = a1;
  CLMicroLocationProto::HomeKitScene::HomeKitScene((uint64_t)v41);
  id v6 = [v5 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"];
  BOOL v7 = v6 == 0;

  if (!v7)
  {
    uint32_t v8 = [v5 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"];
    unsigned __int8 v9 = [v8 BOOLValue];
    v50 |= 0x100u;
    unsigned __int8 v46 = v9;
  }
  unint64_t v10 = [v5 objectForKeyedSubscript:@"shouldTriggerRecordingScan"];
  BOOL v11 = v10 == 0;

  if (!v11)
  {
    unint64_t v12 = [v5 objectForKeyedSubscript:@"shouldTriggerRecordingScan"];
    unsigned __int8 v13 = [v12 BOOLValue];
    v50 |= 0x200u;
    unsigned __int8 v47 = v13;
  }
  unint64_t v14 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"];
  BOOL v15 = v14 == 0;

  uint64_t v16 = (uint64_t *)MEMORY[0x263F8C740];
  if (!v15)
  {
    id v17 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"];
    [v17 UTF8String];
    v50 |= 2u;
    if (v42 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  uint64_t v18 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetName"];
  BOOL v19 = v18 == 0;

  if (!v19)
  {
    id v20 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetName"];
    [v20 UTF8String];
    v50 |= 4u;
    if (v43 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  long long v21 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetType"];
  BOOL v22 = v21 == 0;

  if (!v22)
  {
    id v23 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetType"];
    [v23 UTF8String];
    v50 |= 8u;
    if (v44 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  std::string::size_type v24 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.clientName"];
  BOOL v25 = v24 == 0;

  if (!v25)
  {
    id v26 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.clientName"];
    [v26 UTF8String];
    v50 |= 0x20u;
    if (v45 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  uint64_t v27 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.source"];
  BOOL v28 = v27 == 0;

  if (!v28)
  {
    id v29 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.source"];
    [v29 UTF8String];
    v50 |= 0x80u;
    if (v48 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  std::string::size_type v30 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.homeName"];
  BOOL v31 = v30 == 0;

  if (!v31)
  {
    id v32 = [v5 objectForKeyedSubscript:@"private.HomeKit.scene.homeName"];
    [v32 UTF8String];
    v50 |= 0x400u;
    if (v49 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_64);
  }
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_64);
    }
    char v33 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      long long v34 = v42;
      if (*((char *)v42 + 23) < 0) {
        long long v34 = (uint64_t *)*v42;
      }
      uint64_t v35 = v43;
      if (*((char *)v43 + 23) < 0) {
        uint64_t v35 = (uint64_t *)*v43;
      }
      std::string::size_type v36 = v44;
      if (*((char *)v44 + 23) < 0) {
        std::string::size_type v36 = (uint64_t *)*v44;
      }
      int v37 = v45;
      if (*((char *)v45 + 23) < 0) {
        int v37 = (uint64_t *)*v45;
      }
      long long v38 = v48;
      if (*((char *)v48 + 23) < 0) {
        long long v38 = (uint64_t *)*v48;
      }
      std::string v39 = v49;
      if (*((char *)v49 + 23) < 0) {
        std::string v39 = (uint64_t *)*v49;
      }
      uint64_t buf = 68291075;
      __int16 v52 = 2082;
      std::string v53 = "";
      __int16 v54 = 2081;
      std::string v55 = v34;
      __int16 v56 = 2081;
      uint64_t v57 = v35;
      __int16 v58 = 2081;
      uint64_t v59 = v36;
      __int16 v60 = 2081;
      uint64_t v61 = v37;
      __int16 v62 = 2081;
      uint64_t v63 = v38;
      __int16 v64 = 2081;
      char v65 = v39;
      __int16 v66 = 1025;
      int v67 = v46;
      __int16 v68 = 1025;
      int v69 = v47;
      _os_log_impl(&dword_25631F000, v33, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"HomeKit Scene\", \"actionSetUUID\":%{private, location:escape_only}s, \"actionSetName\":%{private, location:escape_only}s, \"actionSetType\":%{private, location:escape_only}s, \"clientName\":%{private, location:escape_only}s, \"source\":%{private, location:escape_only}s, \"homeName\":%{private, location:escape_only}s, \"triggerLocalization\":%{private}hhd, \"triggerRecording\":%{private}hhd}", (uint8_t *)&buf, 0x5Au);
    }
  }
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::HomeKitScene>((CLMicroLocationProto::RecordingEvent *)v41, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v40, *a2);
  LOBYTE(buf) = 1;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)&v52, (const CLMicroLocationProto::RecordingEvent *)v40);
  *a3 = buf;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a3 + 8), (const CLMicroLocationProto::RecordingEvent *)&v52);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&v52);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v40);
  CLMicroLocationProto::HomeKitScene::~HomeKitScene((CLMicroLocationProto::HomeKitScene *)v41);
}

void sub_2564083C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  CLMicroLocationProto::HomeKitScene::~HomeKitScene((CLMicroLocationProto::HomeKitScene *)&a28);
  _Unwind_Resume(a1);
}

void CLMicroLocationLegacyEventHomeKit::handleEventAccessory(void *a1@<X1>, double *a2@<X2>, unsigned char *a3@<X8>)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  id v5 = a1;
  CLMicroLocationProto::HomeKitAccessory::HomeKitAccessory((uint64_t)v49);
  id v6 = [v5 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"];
  BOOL v7 = v6 == 0;

  if (!v7)
  {
    uint32_t v8 = [v5 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"];
    unsigned __int8 v9 = [v8 BOOLValue];
    v60 |= 0x400u;
    unsigned __int8 v53 = v9;
  }
  unint64_t v10 = [v5 objectForKeyedSubscript:@"shouldTriggerRecordingScan"];
  BOOL v11 = v10 == 0;

  if (!v11)
  {
    unint64_t v12 = [v5 objectForKeyedSubscript:@"shouldTriggerRecordingScan"];
    unsigned __int8 v13 = [v12 BOOLValue];
    v60 |= 0x800u;
    unsigned __int8 v54 = v13;
  }
  unint64_t v14 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.accessoryUUID"];
  BOOL v15 = v14 == 0;

  uint64_t v16 = (uint64_t *)MEMORY[0x263F8C740];
  if (!v15)
  {
    id v17 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.accessoryUUID"];
    [v17 UTF8String];
    v60 |= 2u;
    if (v50 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  uint64_t v18 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceType"];
  BOOL v19 = v18 == 0;

  if (!v19)
  {
    id v20 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceType"];
    [v20 UTF8String];
    v60 |= 0x10u;
    if (v51 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  long long v21 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.characteristicType"];
  BOOL v22 = v21 == 0;

  if (!v22)
  {
    id v23 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.characteristicType"];
    [v23 UTF8String];
    v60 |= 0x20u;
    if (v52 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  std::string::size_type v24 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.source"];
  BOOL v25 = v24 == 0;

  if (!v25)
  {
    id v26 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.source"];
    [v26 UTF8String];
    v60 |= 0x100u;
    if (v55 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  uint64_t v27 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.stateString"];
  BOOL v28 = v27 == 0;

  if (!v28)
  {
    id v29 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.stateString"];
    [v29 UTF8String];
    v60 |= 0x1000u;
    if (v57 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  std::string::size_type v30 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceUUID"];
  BOOL v31 = v30 == 0;

  if (!v31)
  {
    id v32 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceUUID"];
    [v32 UTF8String];
    v60 |= 0x200u;
    if (v56 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  char v33 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceGroupUUID"];
  BOOL v34 = v33 == 0;

  if (!v34)
  {
    id v35 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceGroupUUID"];
    [v35 UTF8String];
    v60 |= 0x2000u;
    if (v58 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  std::string::size_type v36 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.roomUUID"];
  BOOL v37 = v36 == 0;

  if (!v37)
  {
    id v38 = [v5 objectForKeyedSubscript:@"private.HomeKit.accessory.roomUUID"];
    [v38 UTF8String];
    v60 |= 0x4000u;
    if (v59 == v16) {
      operator new();
    }
    MEMORY[0x25A2A6080]();
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_64);
  }
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_64);
    }
    std::string v39 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      std::string v40 = v50;
      if (*((char *)v50 + 23) < 0) {
        std::string v40 = (uint64_t *)*v50;
      }
      std::string v41 = v57;
      if (*((char *)v57 + 23) < 0) {
        std::string v41 = (uint64_t *)*v57;
      }
      std::string v42 = v56;
      if (*((char *)v56 + 23) < 0) {
        std::string v42 = (uint64_t *)*v56;
      }
      std::string v43 = v58;
      if (*((char *)v58 + 23) < 0) {
        std::string v43 = (uint64_t *)*v58;
      }
      std::string v44 = v51;
      if (*((char *)v51 + 23) < 0) {
        std::string v44 = (uint64_t *)*v51;
      }
      std::string v45 = v52;
      if (*((char *)v52 + 23) < 0) {
        std::string v45 = (uint64_t *)*v52;
      }
      unsigned __int8 v46 = v55;
      if (*((char *)v55 + 23) < 0) {
        unsigned __int8 v46 = (uint64_t *)*v55;
      }
      unsigned __int8 v47 = v59;
      if (*((char *)v59 + 23) < 0) {
        unsigned __int8 v47 = (uint64_t *)*v59;
      }
      *(_DWORD *)uint64_t buf = 68291587;
      __int16 v63 = 2082;
      int v62 = 0;
      __int16 v64 = "";
      __int16 v65 = 2081;
      __int16 v66 = v40;
      __int16 v67 = 2081;
      __int16 v68 = v41;
      __int16 v69 = 2081;
      uint64_t v70 = v42;
      __int16 v71 = 2081;
      char v72 = v43;
      __int16 v73 = 2081;
      __int16 v74 = v44;
      __int16 v75 = 2081;
      uint64_t v76 = v45;
      __int16 v77 = 2081;
      uint64_t v78 = v46;
      __int16 v79 = 2081;
      uint64_t v80 = v47;
      __int16 v81 = 1025;
      int v82 = v53;
      __int16 v83 = 1025;
      int v84 = v54;
      _os_log_impl(&dword_25631F000, v39, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"HomeKit Accessory\", \"accessoryUUID\":%{private, location:escape_only}s, \"accessoryState\":%{private, location:escape_only}s, \"serviceUUID\":%{private, location:escape_only}s, \"serviceGroupUUID\":%{private, location:escape_only}s, \"serviceType\":%{private, location:escape_only}s, \"characteristicType\":%{private, location:escape_only}s, \"source\":%{private, location:escape_only}s, \"roomUUID\":%{private, location:escape_only}s, \"triggerLocalization\":%{private}hhd, \"triggerRecording\":%{private}hhd}", buf, 0x6Eu);
    }
  }
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::HomeKitAccessory>((CLMicroLocationProto::RecordingEvent *)v49, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v48, *a2);
  buf[0] = 1;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)&v63, (const CLMicroLocationProto::RecordingEvent *)v48);
  *a3 = buf[0];
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a3 + 8), (const CLMicroLocationProto::RecordingEvent *)&v63);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&v63);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v48);
  CLMicroLocationProto::HomeKitAccessory::~HomeKitAccessory((CLMicroLocationProto::HomeKitAccessory *)v49);
}

void sub_256408C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  CLMicroLocationProto::HomeKitAccessory::~HomeKitAccessory((CLMicroLocationProto::HomeKitAccessory *)&a28);
  _Unwind_Resume(a1);
}

BOOL CLMicroLocationLegacyEventHomeKit::isHomeControlSuggestionRequest(CLMicroLocationLegacyEventHomeKit *this, NSDictionary *a2)
{
  double v2 = a2;
  long long v3 = v2;
  if (v2)
  {
    uint64_t v4 = [(NSDictionary *)v2 objectForKeyedSubscript:@"private.HomeKit.accessory.accessoryUUID"];

    if (v4)
    {
      BOOL v5 = 1;
    }
    else
    {
      id v6 = [(NSDictionary *)v3 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"];
      BOOL v5 = v6 != 0;
    }
  }
  else
  {
    BOOL v5 = 0;
  }

  return v5;
}

void sub_256408DA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::HomeKitScene>(CLMicroLocationProto::RecordingEvent *a1@<X0>, CLMicroLocationProto *a2@<X1>, char a3@<W2>, char a4@<W3>, CLMicroLocationProto *a5@<X4>, uint64_t a6@<X8>, double a7@<D0>)
{
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)a6);
  unsigned int v14 = *((_DWORD *)a1 + 12);
  if (!CLMicroLocationProto::EventType_IsValid((CLMicroLocationProto *)v14))
  {
    id v17 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v18 = 20192;
    BOOL v19 = "set_eventtype";
    goto LABEL_10;
  }
  int v15 = *(_DWORD *)(a6 + 140);
  *(_DWORD *)(a6 + 72) = v14;
  *(double *)(a6 + 8) = a7;
  *(unsigned char *)(a6 + 77) = a3;
  *(_DWORD *)(a6 + 140) = v15 | 0x2803;
  *(unsigned char *)(a6 + 76) = a4;
  if (!CLMicroLocationProto::ConfidenceLevel_IsValid(a5))
  {
    id v17 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v18 = 20701;
    BOOL v19 = "set_confidencelevel";
    goto LABEL_10;
  }
  *(_DWORD *)(a6 + 140) |= 0x4000u;
  *(_DWORD *)(a6 + 120) = a5;
  if (((unint64_t)a2 & 0xFF00000000) != 0)
  {
    if (CLMicroLocationProto::MotionState_IsValid(a2))
    {
      *(_DWORD *)(a6 + 140) |= 0x20000u;
      *(_DWORD *)(a6 + 124) = a2;
      goto LABEL_6;
    }
    id v17 = "::CLMicroLocationProto::MotionState_IsValid(value)";
    int v18 = 20793;
    BOOL v19 = "set_motionstate";
LABEL_10:
    __assert_rtn(v19, "microlocation.pb.h", v18, v17);
  }
LABEL_6:
  CLMicroLocationProtobufHelper::setSpecificRecordingEvent((CLMicroLocationProtobufHelper *)a6, a1, v16);
}

void sub_256408EE0(_Unwind_Exception *a1)
{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::HomeKitAccessory>(CLMicroLocationProto::RecordingEvent *a1@<X0>, CLMicroLocationProto *a2@<X1>, char a3@<W2>, char a4@<W3>, CLMicroLocationProto *a5@<X4>, uint64_t a6@<X8>, double a7@<D0>)
{
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)a6);
  unsigned int v14 = *((_DWORD *)a1 + 16);
  if (!CLMicroLocationProto::EventType_IsValid((CLMicroLocationProto *)v14))
  {
    id v17 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v18 = 20192;
    BOOL v19 = "set_eventtype";
    goto LABEL_10;
  }
  int v15 = *(_DWORD *)(a6 + 140);
  *(_DWORD *)(a6 + 72) = v14;
  *(double *)(a6 + 8) = a7;
  *(unsigned char *)(a6 + 77) = a3;
  *(_DWORD *)(a6 + 140) = v15 | 0x2803;
  *(unsigned char *)(a6 + 76) = a4;
  if (!CLMicroLocationProto::ConfidenceLevel_IsValid(a5))
  {
    id v17 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v18 = 20701;
    BOOL v19 = "set_confidencelevel";
    goto LABEL_10;
  }
  *(_DWORD *)(a6 + 140) |= 0x4000u;
  *(_DWORD *)(a6 + 120) = a5;
  if (((unint64_t)a2 & 0xFF00000000) != 0)
  {
    if (CLMicroLocationProto::MotionState_IsValid(a2))
    {
      *(_DWORD *)(a6 + 140) |= 0x20000u;
      *(_DWORD *)(a6 + 124) = a2;
      goto LABEL_6;
    }
    id v17 = "::CLMicroLocationProto::MotionState_IsValid(value)";
    int v18 = 20793;
    BOOL v19 = "set_motionstate";
LABEL_10:
    __assert_rtn(v19, "microlocation.pb.h", v18, v17);
  }
LABEL_6:
  CLMicroLocationProtobufHelper::setSpecificRecordingEvent((CLMicroLocationProtobufHelper *)a6, a1, v16);
}

void sub_256409024(_Unwind_Exception *a1)
{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v1);
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_54()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void sub_256409A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
}

uint64_t CLMicroLocationProto::protobuf_ShutdownFile_microlocation_2eproto(CLMicroLocationProto *this)
{
  if (CLMicroLocationProto::BleLeechedBeacons::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::BleLeechedBeacons::default_instance_ + 8))(CLMicroLocationProto::BleLeechedBeacons::default_instance_);
  }
  if (CLMicroLocationProto::WiFiRssi::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::WiFiRssi::default_instance_ + 8))(CLMicroLocationProto::WiFiRssi::default_instance_);
  }
  if (CLMicroLocationProto::Direction::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::Direction::default_instance_ + 8))(CLMicroLocationProto::Direction::default_instance_);
  }
  if (CLMicroLocationProto::UwbRange::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::UwbRange::default_instance_ + 8))(CLMicroLocationProto::UwbRange::default_instance_);
  }
  if (CLMicroLocationProto::WiFiRange::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::WiFiRange::default_instance_ + 8))(CLMicroLocationProto::WiFiRange::default_instance_);
  }
  if (CLMicroLocationProto::ATVAirplayBluetoothRssi::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ATVAirplayBluetoothRssi::default_instance_ + 8))(CLMicroLocationProto::ATVAirplayBluetoothRssi::default_instance_);
  }
  if (CLMicroLocationProto::HomeKitBluetoothRssi::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::HomeKitBluetoothRssi::default_instance_ + 8))(CLMicroLocationProto::HomeKitBluetoothRssi::default_instance_);
  }
  if (CLMicroLocationProto::Measurement::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::Measurement::default_instance_ + 8))(CLMicroLocationProto::Measurement::default_instance_);
  }
  if (CLMicroLocationProto::DeviceId::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::DeviceId::default_instance_ + 8))(CLMicroLocationProto::DeviceId::default_instance_);
  }
  if (CLMicroLocationProto::FingerprintMeasurement::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::FingerprintMeasurement::default_instance_ + 8))(CLMicroLocationProto::FingerprintMeasurement::default_instance_);
  }
  if (CLMicroLocationProto::Fingerprint::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::Fingerprint::default_instance_ + 8))(CLMicroLocationProto::Fingerprint::default_instance_);
  }
  if (CLMicroLocationProto::ClusterRecordings::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ClusterRecordings::default_instance_ + 8))(CLMicroLocationProto::ClusterRecordings::default_instance_);
  }
  if (CLMicroLocationProto::AnchorMetadata::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::AnchorMetadata::default_instance_ + 8))(CLMicroLocationProto::AnchorMetadata::default_instance_);
  }
  if (CLMicroLocationProto::AnchorAppearance::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::AnchorAppearance::default_instance_ + 8))(CLMicroLocationProto::AnchorAppearance::default_instance_);
  }
  if (CLMicroLocationProto::anchorAppearancesVector::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::anchorAppearancesVector::default_instance_ + 8))(CLMicroLocationProto::anchorAppearancesVector::default_instance_);
  }
  if (CLMicroLocationProto::AnchorValueStatistics::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::AnchorValueStatistics::default_instance_ + 8))(CLMicroLocationProto::AnchorValueStatistics::default_instance_);
  }
  if (CLMicroLocationProto::ClusterAnchorValueStatistics::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ClusterAnchorValueStatistics::default_instance_
  }
                                    + 8))(CLMicroLocationProto::ClusterAnchorValueStatistics::default_instance_);
  if (CLMicroLocationProto::ClusterAnchorValueStatisticsVector::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ClusterAnchorValueStatisticsVector::default_instance_
  }
                                    + 8))(CLMicroLocationProto::ClusterAnchorValueStatisticsVector::default_instance_);
  if (CLMicroLocationProto::LocationSimilarityListElement::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::LocationSimilarityListElement::default_instance_
  }
                                    + 8))(CLMicroLocationProto::LocationSimilarityListElement::default_instance_);
  if (CLMicroLocationProto::LocationSimilarityListData::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::LocationSimilarityListData::default_instance_
  }
                                    + 8))(CLMicroLocationProto::LocationSimilarityListData::default_instance_);
  if (CLMicroLocationProto::BlueAtlasData::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::BlueAtlasData::default_instance_ + 8))(CLMicroLocationProto::BlueAtlasData::default_instance_);
  }
  if (CLMicroLocationProto::Model::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::Model::default_instance_ + 8))(CLMicroLocationProto::Model::default_instance_);
  }
  if (CLMicroLocationProto::BundleIdFeatures::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::BundleIdFeatures::default_instance_ + 8))(CLMicroLocationProto::BundleIdFeatures::default_instance_);
  }
  if (CLMicroLocationProto::ReceivedEventAction::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ReceivedEventAction::default_instance_ + 8))(CLMicroLocationProto::ReceivedEventAction::default_instance_);
  }
  if (CLMicroLocationProto::RecordingRequest::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::RecordingRequest::default_instance_ + 8))(CLMicroLocationProto::RecordingRequest::default_instance_);
  }
  if (CLMicroLocationProto::AppLaunch::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::AppLaunch::default_instance_ + 8))(CLMicroLocationProto::AppLaunch::default_instance_);
  }
  if (CLMicroLocationProto::BacklightOn::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::BacklightOn::default_instance_ + 8))(CLMicroLocationProto::BacklightOn::default_instance_);
  }
  if (CLMicroLocationProto::BatteryChargerConnected::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::BatteryChargerConnected::default_instance_ + 8))(CLMicroLocationProto::BatteryChargerConnected::default_instance_);
  }
  if (CLMicroLocationProto::TruthLabelDonation::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::TruthLabelDonation::default_instance_ + 8))(CLMicroLocationProto::TruthLabelDonation::default_instance_);
  }
  if (CLMicroLocationProto::ForcedRecording::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ForcedRecording::default_instance_ + 8))(CLMicroLocationProto::ForcedRecording::default_instance_);
  }
  if (CLMicroLocationProto::HomeKitAccessory::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::HomeKitAccessory::default_instance_ + 8))(CLMicroLocationProto::HomeKitAccessory::default_instance_);
  }
  if (CLMicroLocationProto::HomeKitScene::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::HomeKitScene::default_instance_ + 8))(CLMicroLocationProto::HomeKitScene::default_instance_);
  }
  if (CLMicroLocationProto::NowPlayingOutputDevice::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::NowPlayingOutputDevice::default_instance_ + 8))(CLMicroLocationProto::NowPlayingOutputDevice::default_instance_);
  }
  if (CLMicroLocationProto::NowPlaying::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::NowPlaying::default_instance_ + 8))(CLMicroLocationProto::NowPlaying::default_instance_);
  }
  if (CLMicroLocationProto::LearnModel::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::LearnModel::default_instance_ + 8))(CLMicroLocationProto::LearnModel::default_instance_);
  }
  if (CLMicroLocationProto::LearnCompleted::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::LearnCompleted::default_instance_ + 8))(CLMicroLocationProto::LearnCompleted::default_instance_);
  }
  if (CLMicroLocationProto::SensorsScanComplete::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::SensorsScanComplete::default_instance_ + 8))(CLMicroLocationProto::SensorsScanComplete::default_instance_);
  }
  if (CLMicroLocationProto::StartSpectating::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::StartSpectating::default_instance_ + 8))(CLMicroLocationProto::StartSpectating::default_instance_);
  }
  if (CLMicroLocationProto::StopSpectating::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::StopSpectating::default_instance_ + 8))(CLMicroLocationProto::StopSpectating::default_instance_);
  }
  if (CLMicroLocationProto::ServiceCreate::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ServiceCreate::default_instance_ + 8))(CLMicroLocationProto::ServiceCreate::default_instance_);
  }
  if (CLMicroLocationProto::ServiceDelete::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ServiceDelete::default_instance_ + 8))(CLMicroLocationProto::ServiceDelete::default_instance_);
  }
  if (CLMicroLocationProto::ServiceConnect::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ServiceConnect::default_instance_ + 8))(CLMicroLocationProto::ServiceConnect::default_instance_);
  }
  if (CLMicroLocationProto::ServiceDisconnect::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ServiceDisconnect::default_instance_ + 8))(CLMicroLocationProto::ServiceDisconnect::default_instance_);
  }
  if (CLMicroLocationProto::ServiceStartUpdating::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ServiceStartUpdating::default_instance_ + 8))(CLMicroLocationProto::ServiceStartUpdating::default_instance_);
  }
  if (CLMicroLocationProto::ServiceStopUpdating::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ServiceStopUpdating::default_instance_ + 8))(CLMicroLocationProto::ServiceStopUpdating::default_instance_);
  }
  if (CLMicroLocationProto::RequestObservation::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::RequestObservation::default_instance_ + 8))(CLMicroLocationProto::RequestObservation::default_instance_);
  }
  if (CLMicroLocationProto::RequestPrediction::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::RequestPrediction::default_instance_ + 8))(CLMicroLocationProto::RequestPrediction::default_instance_);
  }
  if (CLMicroLocationProto::MiloInit::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::MiloInit::default_instance_ + 8))(CLMicroLocationProto::MiloInit::default_instance_);
  }
  if (CLMicroLocationProto::MotionEvent::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::MotionEvent::default_instance_ + 8))(CLMicroLocationProto::MotionEvent::default_instance_);
  }
  if (CLMicroLocationProto::LegacyThrottle::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::LegacyThrottle::default_instance_ + 8))(CLMicroLocationProto::LegacyThrottle::default_instance_);
  }
  if (CLMicroLocationProto::RetrievedLoi::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::RetrievedLoi::default_instance_ + 8))(CLMicroLocationProto::RetrievedLoi::default_instance_);
  }
  if (CLMicroLocationProto::ReceivedEvent::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ReceivedEvent::default_instance_ + 8))(CLMicroLocationProto::ReceivedEvent::default_instance_);
  }
  if (CLMicroLocationProto::AssociatedAccessPointInfo::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::AssociatedAccessPointInfo::default_instance_ + 8))(CLMicroLocationProto::AssociatedAccessPointInfo::default_instance_);
  }
  if (CLMicroLocationProto::RecordingEvent::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::RecordingEvent::default_instance_ + 8))(CLMicroLocationProto::RecordingEvent::default_instance_);
  }
  if (CLMicroLocationProto::TriggerEvent::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::TriggerEvent::default_instance_ + 8))(CLMicroLocationProto::TriggerEvent::default_instance_);
  }
  if (CLMicroLocationProto::LegacyClientStatusUpdate::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::LegacyClientStatusUpdate::default_instance_ + 8))(CLMicroLocationProto::LegacyClientStatusUpdate::default_instance_);
  }
  if (CLMicroLocationProto::SpectatingMotionUpdate::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::SpectatingMotionUpdate::default_instance_ + 8))(CLMicroLocationProto::SpectatingMotionUpdate::default_instance_);
  }
  if (CLMicroLocationProto::EnabledStateUpdate::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::EnabledStateUpdate::default_instance_ + 8))(CLMicroLocationProto::EnabledStateUpdate::default_instance_);
  }
  if (CLMicroLocationProto::ScreenStateUpdate::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ScreenStateUpdate::default_instance_ + 8))(CLMicroLocationProto::ScreenStateUpdate::default_instance_);
  }
  if (CLMicroLocationProto::CloudBackupExport::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::CloudBackupExport::default_instance_ + 8))(CLMicroLocationProto::CloudBackupExport::default_instance_);
  }
  if (CLMicroLocationProto::CloudBackupImport::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::CloudBackupImport::default_instance_ + 8))(CLMicroLocationProto::CloudBackupImport::default_instance_);
  }
  if (CLMicroLocationProto::DataMigration::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::DataMigration::default_instance_ + 8))(CLMicroLocationProto::DataMigration::default_instance_);
  }
  if (CLMicroLocationProto::ChannelAndCount::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::ChannelAndCount::default_instance_ + 8))(CLMicroLocationProto::ChannelAndCount::default_instance_);
  }
  if (CLMicroLocationProto::WifiHistogram::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::WifiHistogram::default_instance_ + 8))(CLMicroLocationProto::WifiHistogram::default_instance_);
  }
  if (CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance_
  }
                                    + 8))(CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance_);
  if (CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance_
  }
                                    + 8))(CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance_);
  if (CLMicroLocationProto::Configuration::default_instance_) {
    (*(void (**)(uint64_t))(*(void *)CLMicroLocationProto::Configuration::default_instance_ + 8))(CLMicroLocationProto::Configuration::default_instance_);
  }
  uint64_t result = CLMicroLocationProto::RapportDevice::default_instance_;
  if (CLMicroLocationProto::RapportDevice::default_instance_)
  {
    double v2 = *(uint64_t (**)(void))(*(void *)CLMicroLocationProto::RapportDevice::default_instance_ + 8);
    return v2();
  }
  return result;
}

void CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto_impl(CLMicroLocationProto *this, uint64_t a2, uint64_t a3, const char *a4)
{
}

uint64_t CLMicroLocationProto::BleLeechedBeacons::BleLeechedBeacons(uint64_t this)
{
  *(void *)this = &unk_2704DDCF0;
  *(void *)(this + 8) = 0;
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)(this + 16) = 5;
  *(void *)(this + 24) = v1;
  *(void *)(this + 48) = v1;
  *(void *)(this + 56) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = v1;
  *(_DWORD *)(this + 64) = 0;
  return this;
}

uint64_t CLMicroLocationProto::WiFiRssi::WiFiRssi(uint64_t this)
{
  *(_DWORD *)(this + 16) = 1;
  *(void *)this = &unk_2704DDD68;
  *(void *)(this + 8) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(void *)(this + 28) = 0;
  *(void *)(this + 20) = 0;
  return this;
}

uint64_t CLMicroLocationProto::Direction::Direction(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DDDE0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::UwbRange::UwbRange(uint64_t this)
{
  *(void *)this = &unk_2704DDE58;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 6;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = MEMORY[0x263F8C740];
  *(void *)(this + 40) = 1;
  *(_DWORD *)(this + 56) = 0;
  *(void *)(this + 48) = 0;
  return this;
}

double CLMicroLocationProto::Measurement::Measurement(CLMicroLocationProto::Measurement *this)
{
  *(void *)this = &unk_2704DE038;
  *((void *)this + 8) = 1;
  *((_DWORD *)this + 18) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = 0;
  return result;
}

void *CLMicroLocationProto::DeviceId::DeviceId(void *this)
{
  *this = &unk_2704DE0B0;
  this[1] = 0;
  this[2] = MEMORY[0x263F8C740];
  this[3] = 0;
  return this;
}

void *CLMicroLocationProto::FingerprintMeasurement::FingerprintMeasurement(void *this)
{
  *this = &unk_2704DE128;
  this[1] = 0;
  this[2] = 1;
  this[3] = 0;
  this[4] = 0;
  return this;
}

uint64_t CLMicroLocationProto::Fingerprint::Fingerprint(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DE1A0;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 80) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)(this + 48) = 0;
  *(void *)(this + 56) = v1;
  *(void *)(this + 64) = v1;
  *(void *)(this + 72) = 0;
  *(_WORD *)(this + 96) = 0;
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 104) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ClusterRecordings::ClusterRecordings(uint64_t this)
{
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DE218;
  *(void *)(this + 8) = v1;
  *(void *)(this + 40) = 0;
  return this;
}

uint64_t CLMicroLocationProto::AnchorAppearance::AnchorAppearance(uint64_t this)
{
  *(void *)(this + 32) = 0;
  *(void *)this = &unk_2704DE308;
  *(void *)(this + 8) = 0;
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = v1;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t CLMicroLocationProto::anchorAppearancesVector::anchorAppearancesVector(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DE380;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  return this;
}

void *CLMicroLocationProto::AnchorValueStatistics::AnchorValueStatistics(void *this)
{
  uint64_t v1 = MEMORY[0x263F8C740];
  *this = &unk_2704DE3F8;
  this[1] = 0;
  this[2] = 0;
  this[3] = v1;
  this[4] = 0;
  return this;
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatistics::ClusterAnchorValueStatistics(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DE470;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 32) = MEMORY[0x263F8C740];
  *(void *)(this + 40) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatisticsVector::ClusterAnchorValueStatisticsVector(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DE4E8;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  return this;
}

void *CLMicroLocationProto::LocationSimilarityListElement::LocationSimilarityListElement(void *this)
{
  this[3] = 0;
  this[4] = 0;
  this[2] = 0;
  uint64_t v1 = MEMORY[0x263F8C740];
  *this = &unk_2704DE560;
  this[1] = v1;
  return this;
}

uint64_t CLMicroLocationProto::LocationSimilarityListData::LocationSimilarityListData(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DE5D8;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(void *)(this + 64) = 0;
  *(void *)(this + 72) = 0;
  *(void *)(this + 56) = 0;
  return this;
}

double CLMicroLocationProto::BlueAtlasData::BlueAtlasData(CLMicroLocationProto::BlueAtlasData *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_2704DE650;
  *((_DWORD *)this + 6) = 0;
  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  return result;
}

double CLMicroLocationProto::Model::Model(CLMicroLocationProto::Model *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_2704DE6C8;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 24) = 0;
  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 108) = 0u;
  *(_OWORD *)((char *)this + 124) = 0u;
  *(_OWORD *)((char *)this + 140) = 0u;
  *(_OWORD *)((char *)this + 156) = 0u;
  *((_DWORD *)this + 43) = 0;
  *((void *)this + 22) = MEMORY[0x263F8C740];
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 50) = 0;
  return result;
}

double CLMicroLocationProto::ReceivedEventAction::ReceivedEventAction(CLMicroLocationProto::ReceivedEventAction *this)
{
  *(void *)this = &unk_2704DE7B8;
  *(void *)&double result = 0x100000001;
  *((void *)this + 1) = 0x100000001;
  uint64_t v2 = MEMORY[0x263F8C740];
  *((void *)this + 2) = MEMORY[0x263F8C740];
  *((void *)this + 3) = v2;
  *((void *)this + 4) = v2;
  *((void *)this + 5) = 0;
  return result;
}

double CLMicroLocationProto::RecordingRequest::RecordingRequest(CLMicroLocationProto::RecordingRequest *this)
{
  *(void *)this = &unk_2704DE830;
  *(void *)&double result = 0x10000000DLL;
  *((void *)this + 1) = 0x10000000DLL;
  uint64_t v2 = MEMORY[0x263F8C740];
  *((void *)this + 2) = MEMORY[0x263F8C740];
  *((void *)this + 3) = v2;
  *((void *)this + 4) = v2;
  *((void *)this + 5) = 0;
  return result;
}

double CLMicroLocationProto::BacklightOn::BacklightOn(CLMicroLocationProto::BacklightOn *this)
{
  *(void *)&double result = 4;
  uint64_t v2 = MEMORY[0x263F8C740];
  *((void *)this + 2) = 4;
  *(void *)this = &unk_2704DE920;
  *((void *)this + 1) = v2;
  *((_DWORD *)this + 6) = 0;
  return result;
}

double CLMicroLocationProto::BatteryChargerConnected::BatteryChargerConnected(CLMicroLocationProto::BatteryChargerConnected *this)
{
  *(void *)this = &unk_2704DE998;
  *(void *)&double result = 5;
  *((void *)this + 1) = 5;
  *((_DWORD *)this + 4) = 0;
  return result;
}

double CLMicroLocationProto::TruthLabelDonation::TruthLabelDonation(CLMicroLocationProto::TruthLabelDonation *this)
{
  *(void *)&double result = 14;
  *((void *)this + 4) = 14;
  uint64_t v2 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DEA10;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2;
  *((void *)this + 3) = v2;
  *((_DWORD *)this + 10) = 0;
  return result;
}

double CLMicroLocationProto::ForcedRecording::ForcedRecording(CLMicroLocationProto::ForcedRecording *this)
{
  *(void *)this = &unk_2704DEA88;
  *(void *)&double result = 7;
  *((void *)this + 1) = 7;
  *((_DWORD *)this + 4) = 0;
  return result;
}

uint64_t CLMicroLocationProto::HomeKitAccessory::HomeKitAccessory(uint64_t this)
{
  *(_DWORD *)(this + 64) = 9;
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DEB00;
  *(void *)(this + 8) = v1;
  *(void *)(this + 16) = v1;
  *(void *)(this + 24) = v1;
  *(void *)(this + 32) = v1;
  *(void *)(this + 40) = v1;
  *(void *)(this + 48) = v1;
  *(void *)(this + 56) = v1;
  *(void *)(this + 72) = v1;
  *(void *)(this + 80) = v1;
  *(_WORD *)(this + 68) = 0;
  *(void *)(this + 88) = v1;
  *(void *)(this + 96) = v1;
  *(void *)(this + 104) = v1;
  *(void *)(this + 112) = 0;
  return this;
}

uint64_t CLMicroLocationProto::HomeKitScene::HomeKitScene(uint64_t this)
{
  *(_DWORD *)(this + 48) = 10;
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DEB78;
  *(void *)(this + 8) = v1;
  *(void *)(this + 16) = v1;
  *(void *)(this + 24) = v1;
  *(void *)(this + 32) = v1;
  *(void *)(this + 40) = v1;
  *(void *)(this + 56) = v1;
  *(void *)(this + 64) = v1;
  *(_WORD *)(this + 52) = 0;
  *(void *)(this + 72) = v1;
  *(void *)(this + 80) = 0;
  return this;
}

double CLMicroLocationProto::LearnModel::LearnModel(CLMicroLocationProto::LearnModel *this)
{
  *(void *)this = &unk_2704DECE0;
  *(void *)&double result = 31;
  *((void *)this + 1) = 31;
  *((_DWORD *)this + 4) = 0;
  return result;
}

double CLMicroLocationProto::LearnCompleted::LearnCompleted(CLMicroLocationProto::LearnCompleted *this)
{
  *(void *)this = &unk_2704DED58;
  *(void *)&double result = 32;
  *((void *)this + 1) = 32;
  *((_DWORD *)this + 4) = 0;
  return result;
}

double CLMicroLocationProto::SensorsScanComplete::SensorsScanComplete(CLMicroLocationProto::SensorsScanComplete *this)
{
  *(void *)this = &unk_2704DEDD0;
  *(void *)&double result = 33;
  *((void *)this + 1) = 33;
  *((_DWORD *)this + 4) = 0;
  return result;
}

double CLMicroLocationProto::StartSpectating::StartSpectating(CLMicroLocationProto::StartSpectating *this)
{
  *(void *)this = &unk_2704DEE48;
  *(void *)&double result = 34;
  *((void *)this + 1) = 34;
  *((_DWORD *)this + 4) = 0;
  return result;
}

double CLMicroLocationProto::StopSpectating::StopSpectating(CLMicroLocationProto::StopSpectating *this)
{
  *(void *)this = &unk_2704DEEC0;
  *(void *)&double result = 35;
  *((void *)this + 1) = 35;
  *((_DWORD *)this + 4) = 0;
  return result;
}

double CLMicroLocationProto::ServiceDelete::ServiceDelete(CLMicroLocationProto::ServiceDelete *this)
{
  *(void *)&double result = 37;
  *((void *)this + 3) = 37;
  uint64_t v2 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DEFB0;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2;
  *((_DWORD *)this + 8) = 0;
  return result;
}

double CLMicroLocationProto::ServiceConnect::ServiceConnect(CLMicroLocationProto::ServiceConnect *this)
{
  *(void *)&double result = 38;
  *((void *)this + 3) = 38;
  uint64_t v2 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DF028;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2;
  *((_DWORD *)this + 8) = 0;
  return result;
}

double CLMicroLocationProto::ServiceDisconnect::ServiceDisconnect(CLMicroLocationProto::ServiceDisconnect *this)
{
  *(void *)&double result = 39;
  *((void *)this + 3) = 39;
  uint64_t v2 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DF0A0;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2;
  *((_DWORD *)this + 8) = 0;
  return result;
}

uint64_t CLMicroLocationProto::ServiceStartUpdating::ServiceStartUpdating(uint64_t this)
{
  *(_DWORD *)(this + 16) = 40;
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DF118;
  *(void *)(this + 8) = v1;
  *(void *)(this + 24) = v1;
  *(void *)(this + 32) = 0;
  *(unsigned char *)(this + 20) = 0;
  return this;
}

double CLMicroLocationProto::ServiceStopUpdating::ServiceStopUpdating(CLMicroLocationProto::ServiceStopUpdating *this)
{
  *(void *)&double result = 41;
  *((void *)this + 3) = 41;
  uint64_t v2 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DF190;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2;
  *((_DWORD *)this + 8) = 0;
  return result;
}

double CLMicroLocationProto::RequestObservation::RequestObservation(CLMicroLocationProto::RequestObservation *this)
{
  *(void *)&double result = 42;
  *((void *)this + 5) = 42;
  uint64_t v2 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DF208;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2;
  *((void *)this + 3) = v2;
  *((void *)this + 4) = v2;
  *((_DWORD *)this + 12) = 0;
  return result;
}

double CLMicroLocationProto::RequestPrediction::RequestPrediction(CLMicroLocationProto::RequestPrediction *this)
{
  *(void *)&double result = 43;
  *((void *)this + 4) = 43;
  uint64_t v2 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DF280;
  *((void *)this + 1) = v2;
  *((void *)this + 2) = v2;
  *((void *)this + 3) = v2;
  *((_DWORD *)this + 10) = 0;
  return result;
}

double CLMicroLocationProto::MiloInit::MiloInit(CLMicroLocationProto::MiloInit *this)
{
  *(void *)&double result = 44;
  uint64_t v2 = MEMORY[0x263F8C740];
  *((void *)this + 2) = 44;
  *(void *)this = &unk_2704DF2F8;
  *((void *)this + 1) = v2;
  *((_DWORD *)this + 6) = 0;
  return result;
}

double CLMicroLocationProto::MotionEvent::MotionEvent(CLMicroLocationProto::MotionEvent *this)
{
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DF370;
  *((void *)this + 1) = v1;
  *(void *)&double result = 45;
  *((void *)this + 2) = 45;
  *((void *)this + 3) = v1;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  return result;
}

double CLMicroLocationProto::LegacyThrottle::LegacyThrottle(CLMicroLocationProto::LegacyThrottle *this)
{
  *(void *)&double result = 46;
  uint64_t v2 = MEMORY[0x263F8C740];
  *((void *)this + 2) = 46;
  *(void *)this = &unk_2704DF3E8;
  *((void *)this + 1) = v2;
  *((_DWORD *)this + 6) = 0;
  return result;
}

double CLMicroLocationProto::RetrievedLoi::RetrievedLoi(CLMicroLocationProto::RetrievedLoi *this)
{
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DF460;
  *((void *)this + 1) = v1;
  *((void *)this + 2) = v1;
  *((void *)this + 4) = v1;
  *(void *)&double result = 0x10000002FLL;
  *((void *)this + 3) = 0x10000002FLL;
  *((unsigned char *)this + 40) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  return result;
}

uint64_t CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DF550;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::TriggerEvent::TriggerEvent(uint64_t this)
{
  *(_DWORD *)(this + 24) = 48;
  *(void *)this = &unk_2704DF640;
  *(void *)(this + 8) = 0;
  *(_WORD *)(this + 28) = 0;
  uint64_t v1 = MEMORY[0x263F8C740];
  *(void *)(this + 16) = MEMORY[0x263F8C740];
  *(void *)(this + 32) = v1;
  *(void *)(this + 40) = v1;
  *(void *)(this + 48) = v1;
  *(void *)(this + 56) = 0;
  *(void *)(this + 64) = v1;
  *(void *)(this + 72) = 0;
  *(void *)(this + 80) = 0;
  return this;
}

double CLMicroLocationProto::LegacyClientStatusUpdate::LegacyClientStatusUpdate(CLMicroLocationProto::LegacyClientStatusUpdate *this)
{
  *(void *)this = &unk_2704DF6B8;
  *(void *)&double result = 0x100000031;
  *(_OWORD *)((char *)this + 8) = xmmword_2565192A0;
  *((_DWORD *)this + 6) = 0;
  return result;
}

uint64_t CLMicroLocationProto::SpectatingMotionUpdate::SpectatingMotionUpdate(uint64_t this)
{
  *(void *)this = &unk_2704DF730;
  *(_DWORD *)(this + 8) = 50;
  *(unsigned char *)(this + 12) = 0;
  *(void *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::EnabledStateUpdate::EnabledStateUpdate(uint64_t this)
{
  *(void *)this = &unk_2704DF7A8;
  *(_DWORD *)(this + 8) = 51;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 12) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ScreenStateUpdate::ScreenStateUpdate(uint64_t this)
{
  *(void *)this = &unk_2704DF820;
  *(_DWORD *)(this + 8) = 52;
  *(unsigned char *)(this + 12) = 0;
  *(void *)(this + 16) = 0;
  return this;
}

double CLMicroLocationProto::CloudBackupExport::CloudBackupExport(CLMicroLocationProto::CloudBackupExport *this)
{
  *(void *)this = &unk_2704DF898;
  *(void *)&double result = 53;
  *((void *)this + 1) = 53;
  *((_DWORD *)this + 4) = 0;
  return result;
}

double CLMicroLocationProto::CloudBackupImport::CloudBackupImport(CLMicroLocationProto::CloudBackupImport *this)
{
  *(void *)this = &unk_2704DF910;
  *(void *)&double result = 54;
  *((void *)this + 1) = 54;
  *((_DWORD *)this + 4) = 0;
  return result;
}

double CLMicroLocationProto::DataMigration::DataMigration(CLMicroLocationProto::DataMigration *this)
{
  *(void *)this = &unk_2704DF988;
  *(void *)&double result = 55;
  *((void *)this + 1) = 55;
  *((_DWORD *)this + 4) = 0;
  return result;
}

uint64_t CLMicroLocationProto::ChannelAndCount::ChannelAndCount(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DFA00;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::WifiHistogram::WifiHistogram(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_2704DFA78;
  *(_DWORD *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

double CLMicroLocationProto::AnchorAppearanceConfiguration::AnchorAppearanceConfiguration(CLMicroLocationProto::AnchorAppearanceConfiguration *this)
{
  *(void *)&double result = 1;
  *((void *)this + 2) = 1;
  *(void *)this = &unk_2704DFAF0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 6) = 0;
  return result;
}

double CLMicroLocationProto::AnchorValueStatisticsConfiguration::AnchorValueStatisticsConfiguration(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this)
{
  *(void *)&double result = 2;
  *((void *)this + 3) = 2;
  *(void *)this = &unk_2704DFB68;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = MEMORY[0x263F8C740];
  *((_DWORD *)this + 8) = 0;
  return result;
}

double CLMicroLocationProto::Configuration::Configuration(CLMicroLocationProto::Configuration *this)
{
  *(void *)this = &unk_2704DFBE0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  return result;
}

void *CLMicroLocationProto::RapportDevice::RapportDevice(void *this)
{
  uint64_t v1 = MEMORY[0x263F8C740];
  *this = &unk_2704DFC58;
  this[1] = v1;
  this[2] = v1;
  this[3] = 0;
  return this;
}

void *CLMicroLocationProto::ReceivedEvent::InitAsDefaultInstance(void *this)
{
  uint64_t v1 = CLMicroLocationProto::AppLaunch::default_instance_;
  this[1] = CLMicroLocationProto::ReceivedEventAction::default_instance_;
  this[2] = v1;
  uint64_t v2 = CLMicroLocationProto::BatteryChargerConnected::default_instance_;
  this[3] = CLMicroLocationProto::BacklightOn::default_instance_;
  this[4] = v2;
  uint64_t v3 = CLMicroLocationProto::HomeKitAccessory::default_instance_;
  this[5] = CLMicroLocationProto::ForcedRecording::default_instance_;
  this[6] = v3;
  uint64_t v4 = CLMicroLocationProto::NowPlaying::default_instance_;
  this[7] = CLMicroLocationProto::HomeKitScene::default_instance_;
  this[8] = v4;
  uint64_t v5 = CLMicroLocationProto::TruthLabelDonation::default_instance_;
  this[9] = CLMicroLocationProto::RecordingRequest::default_instance_;
  this[10] = v5;
  uint64_t v6 = CLMicroLocationProto::LearnCompleted::default_instance_;
  this[11] = CLMicroLocationProto::LearnModel::default_instance_;
  this[12] = v6;
  uint64_t v7 = CLMicroLocationProto::StartSpectating::default_instance_;
  this[13] = CLMicroLocationProto::SensorsScanComplete::default_instance_;
  this[14] = v7;
  uint64_t v8 = CLMicroLocationProto::ServiceCreate::default_instance_;
  this[15] = CLMicroLocationProto::StopSpectating::default_instance_;
  this[16] = v8;
  uint64_t v9 = CLMicroLocationProto::ServiceConnect::default_instance_;
  this[17] = CLMicroLocationProto::ServiceDelete::default_instance_;
  this[18] = v9;
  uint64_t v10 = CLMicroLocationProto::ServiceStartUpdating::default_instance_;
  this[19] = CLMicroLocationProto::ServiceDisconnect::default_instance_;
  this[20] = v10;
  uint64_t v11 = CLMicroLocationProto::RequestObservation::default_instance_;
  this[21] = CLMicroLocationProto::ServiceStopUpdating::default_instance_;
  this[22] = v11;
  uint64_t v12 = CLMicroLocationProto::MiloInit::default_instance_;
  this[23] = CLMicroLocationProto::RequestPrediction::default_instance_;
  this[24] = v12;
  uint64_t v13 = CLMicroLocationProto::LegacyThrottle::default_instance_;
  this[25] = CLMicroLocationProto::MotionEvent::default_instance_;
  this[26] = v13;
  uint64_t v14 = CLMicroLocationProto::TriggerEvent::default_instance_;
  this[27] = CLMicroLocationProto::RetrievedLoi::default_instance_;
  this[28] = v14;
  uint64_t v15 = CLMicroLocationProto::SpectatingMotionUpdate::default_instance_;
  this[29] = CLMicroLocationProto::LegacyClientStatusUpdate::default_instance_;
  this[30] = v15;
  uint64_t v16 = CLMicroLocationProto::ScreenStateUpdate::default_instance_;
  this[31] = CLMicroLocationProto::EnabledStateUpdate::default_instance_;
  this[32] = v16;
  uint64_t v17 = CLMicroLocationProto::CloudBackupImport::default_instance_;
  this[33] = CLMicroLocationProto::CloudBackupExport::default_instance_;
  this[34] = v17;
  this[35] = CLMicroLocationProto::DataMigration::default_instance_;
  return this;
}

void *CLMicroLocationProto::RecordingEvent::InitAsDefaultInstance(void *this)
{
  uint64_t v1 = CLMicroLocationProto::AppLaunch::default_instance_;
  this[2] = CLMicroLocationProto::ReceivedEventAction::default_instance_;
  this[3] = v1;
  uint64_t v2 = CLMicroLocationProto::BatteryChargerConnected::default_instance_;
  this[4] = CLMicroLocationProto::BacklightOn::default_instance_;
  this[5] = v2;
  uint64_t v3 = CLMicroLocationProto::HomeKitAccessory::default_instance_;
  this[6] = CLMicroLocationProto::ForcedRecording::default_instance_;
  this[7] = v3;
  this[8] = CLMicroLocationProto::HomeKitScene::default_instance_;
  uint64_t v4 = CLMicroLocationProto::RecordingRequest::default_instance_;
  this[10] = CLMicroLocationProto::NowPlaying::default_instance_;
  this[11] = v4;
  this[12] = CLMicroLocationProto::TruthLabelDonation::default_instance_;
  this[16] = CLMicroLocationProto::AssociatedAccessPointInfo::default_instance_;
  return this;
}

BOOL CLMicroLocationProto::DataType_IsValid(CLMicroLocationProto *this)
{
  return (this - 1) < 6;
}

BOOL CLMicroLocationProto::ConfidenceReason_IsValid(CLMicroLocationProto *this)
{
  return this < 8;
}

BOOL CLMicroLocationProto::ServiceQualityReasonEnum_IsValid(CLMicroLocationProto *this)
{
  return this < 9;
}

BOOL CLMicroLocationProto::ReceivedEventActionType_IsValid(CLMicroLocationProto *this)
{
  return (this - 1) < 4;
}

BOOL CLMicroLocationProto::RecordingRequestType_IsValid(CLMicroLocationProto *this)
{
  return (this - 1) < 2;
}

BOOL CLMicroLocationProto::TriggerRequestType_IsValid(CLMicroLocationProto *this)
{
  return this < 2;
}

BOOL CLMicroLocationProto::TriggerReason_IsValid(CLMicroLocationProto *this)
{
  return this < 6;
}

BOOL CLMicroLocationProto::MotionState_IsValid(CLMicroLocationProto *this)
{
  return this < 4;
}

BOOL CLMicroLocationProto::ChangedLoiReason_IsValid(CLMicroLocationProto *this)
{
  return (this - 1) < 0xC;
}

BOOL CLMicroLocationProto::NumberOfObservationsStates_IsValid(CLMicroLocationProto *this)
{
  return (this - 1) < 2 || this == 255;
}

BOOL CLMicroLocationProto::ConfigurationType_IsValid(CLMicroLocationProto *this)
{
  return this < 3;
}

CLMicroLocationProto::BleLeechedBeacons *CLMicroLocationProto::BleLeechedBeacons::BleLeechedBeacons(CLMicroLocationProto::BleLeechedBeacons *this, const CLMicroLocationProto::BleLeechedBeacons *a2)
{
  *(void *)this = &unk_2704DDCF0;
  *((void *)this + 1) = 0;
  uint64_t v3 = MEMORY[0x263F8C740];
  *((void *)this + 2) = 5;
  *((void *)this + 3) = v3;
  *((void *)this + 6) = v3;
  *((void *)this + 7) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = v3;
  *((_DWORD *)this + 16) = 0;
  CLMicroLocationProto::BleLeechedBeacons::MergeFrom(this, a2);
  return this;
}

void sub_25640CEB8(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::BleLeechedBeacons::MergeFrom(CLMicroLocationProto::BleLeechedBeacons *this, const CLMicroLocationProto::BleLeechedBeacons *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v16);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 64);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 64))
  {
    int v5 = *((_DWORD *)a2 + 4);
    if ((v5 - 1) >= 6) {
      CLMicroLocationProto::BleLeechedBeacons::MergeFrom();
    }
    *((_DWORD *)this + 16) |= 1u;
    *((_DWORD *)this + 4) = v5;
    int v4 = *((_DWORD *)a2 + 16);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v6 = *((void *)a2 + 1);
    *((_DWORD *)this + 16) |= 2u;
    *((void *)this + 1) = v6;
    int v4 = *((_DWORD *)a2 + 16);
    if ((v4 & 4) == 0)
    {
LABEL_9:
      if ((v4 & 8) == 0) {
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_9;
  }
  int v7 = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 16) |= 4u;
  *((_DWORD *)this + 5) = v7;
  int v4 = *((_DWORD *)a2 + 16);
  if ((v4 & 8) == 0)
  {
LABEL_10:
    if ((v4 & 0x10) == 0) {
      goto LABEL_11;
    }
    goto LABEL_20;
  }
LABEL_17:
  uint64_t v8 = (const std::string *)*((void *)a2 + 3);
  *((_DWORD *)this + 16) |= 8u;
  uint64_t v9 = (std::string *)*((void *)this + 3);
  if (v9 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v9, v8);
  int v4 = *((_DWORD *)a2 + 16);
  if ((v4 & 0x10) == 0)
  {
LABEL_11:
    if ((v4 & 0x20) == 0) {
      goto LABEL_12;
    }
LABEL_21:
    uint64_t v11 = *((void *)a2 + 4);
    *((_DWORD *)this + 16) |= 0x20u;
    *((void *)this + 4) = v11;
    int v4 = *((_DWORD *)a2 + 16);
    if ((v4 & 0x40) == 0)
    {
LABEL_13:
      if ((v4 & 0x80) == 0) {
        return;
      }
      goto LABEL_25;
    }
    goto LABEL_22;
  }
LABEL_20:
  int v10 = *((_DWORD *)a2 + 14);
  *((_DWORD *)this + 16) |= 0x10u;
  *((_DWORD *)this + 14) = v10;
  int v4 = *((_DWORD *)a2 + 16);
  if ((v4 & 0x20) != 0) {
    goto LABEL_21;
  }
LABEL_12:
  if ((v4 & 0x40) == 0) {
    goto LABEL_13;
  }
LABEL_22:
  uint64_t v12 = (const std::string *)*((void *)a2 + 5);
  *((_DWORD *)this + 16) |= 0x40u;
  uint64_t v13 = (std::string *)*((void *)this + 5);
  if (v13 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v13, v12);
  if ((*((_DWORD *)a2 + 16) & 0x80) != 0)
  {
LABEL_25:
    uint64_t v14 = (const std::string *)*((void *)a2 + 6);
    *((_DWORD *)this + 16) |= 0x80u;
    uint64_t v15 = (std::string *)*((void *)this + 6);
    if (v15 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v15, v14);
  }
}

void sub_25640D108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::BleLeechedBeacons::~BleLeechedBeacons(CLMicroLocationProto::BleLeechedBeacons *this)
{
  *(void *)this = &unk_2704DDCF0;
  CLMicroLocationProto::BleLeechedBeacons::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::BleLeechedBeacons::~BleLeechedBeacons(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::BleLeechedBeacons::SharedDtor(CLMicroLocationProto::BleLeechedBeacons *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::BleLeechedBeacons *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 5);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::BleLeechedBeacons *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  uint64_t v7 = *((void *)v1 + 6);
  if (v7 != v3 && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    this = (CLMicroLocationProto::BleLeechedBeacons *)MEMORY[0x25A2A6340](v7, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::BleLeechedBeacons::New(CLMicroLocationProto::BleLeechedBeacons *this)
{
}

uint64_t CLMicroLocationProto::BleLeechedBeacons::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 64);
  if (v1)
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 5;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 8) != 0)
    {
      uint64_t v3 = *(void *)(this + 24);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(this + 56) = 0;
    *(void *)(this + 32) = 0;
    if ((*(unsigned char *)(this + 64) & 0x40) != 0)
    {
      uint64_t v4 = *(void *)(this + 40);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 64) & 0x80) != 0)
    {
      uint64_t v5 = *(void *)(this + 48);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 64) = 0;
  return this;
}

uint64_t CLMicroLocationProto::BleLeechedBeacons::MergePartialFromCodedStream(CLMicroLocationProto::BleLeechedBeacons *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (unint64_t *)((char *)this + 32);
  uint64_t v5 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v6;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        v25[0] = 0;
        uint64_t v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v25);
          if (!result) {
            return result;
          }
          unsigned int v10 = v25[0];
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 - 1 <= 5)
        {
          *((_DWORD *)this + 16) |= 1u;
          *((_DWORD *)this + 4) = v10;
        }
        uint64_t v17 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v17 < *((void *)a2 + 2) && *v17 == 17)
        {
          *((void *)a2 + 1) = v17 + 1;
          goto LABEL_36;
        }
        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_26;
        }
LABEL_36:
        *(void *)BOOL v25 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v25) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v25;
        }
        *((_DWORD *)this + 16) |= 2u;
        int v18 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v18 >= *((void *)a2 + 2) || *v18 != 29) {
          continue;
        }
        *((void *)a2 + 1) = v18 + 1;
LABEL_40:
        v25[0] = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v25))
        {
          *((_DWORD *)this + 5) = v25[0];
          int v11 = *((_DWORD *)this + 16) | 4;
          *((_DWORD *)this + 16) = v11;
          BOOL v19 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v19 < *((void *)a2 + 2) && *v19 == 34)
          {
            *((void *)a2 + 1) = v19 + 1;
LABEL_44:
            *((_DWORD *)this + 16) = v11 | 8;
            if (*((void *)this + 3) == v5) {
              operator new();
            }
            uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
            if (!result) {
              return result;
            }
            id v20 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v12 = *((void *)a2 + 2);
            if ((unint64_t)v20 < v12 && *v20 == 40)
            {
              uint64_t v13 = v20 + 1;
              *((void *)a2 + 1) = v13;
LABEL_50:
              v25[0] = 0;
              if ((unint64_t)v13 >= v12 || *v13 < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v25);
                if (!result) {
                  return result;
                }
                unsigned int v21 = v25[0];
                BOOL v22 = (unsigned char *)*((void *)a2 + 1);
                unint64_t v12 = *((void *)a2 + 2);
              }
              else
              {
                unsigned int v21 = *v13;
                BOOL v22 = v13 + 1;
                *((void *)a2 + 1) = v22;
              }
              *((_DWORD *)this + 14) = v21;
              *((_DWORD *)this + 16) |= 0x10u;
              if ((unint64_t)v22 < v12 && *v22 == 48)
              {
                uint64_t v14 = v22 + 1;
                *((void *)a2 + 1) = v14;
LABEL_58:
                if ((unint64_t)v14 >= v12 || *v14 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v4);
                  if (!result) {
                    return result;
                  }
                  id v23 = (unsigned char *)*((void *)a2 + 1);
                  unint64_t v12 = *((void *)a2 + 2);
                }
                else
                {
                  *uint64_t v4 = *v14;
                  id v23 = v14 + 1;
                  *((void *)a2 + 1) = v23;
                }
                int v15 = *((_DWORD *)this + 16) | 0x20;
                *((_DWORD *)this + 16) = v15;
                if ((unint64_t)v23 < v12 && *v23 == 58)
                {
                  *((void *)a2 + 1) = v23 + 1;
LABEL_66:
                  *((_DWORD *)this + 16) = v15 | 0x40;
                  if (*((void *)this + 5) == v5) {
                    operator new();
                  }
                  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
                  if (!result) {
                    return result;
                  }
                  std::string::size_type v24 = (unsigned char *)*((void *)a2 + 1);
                  if ((unint64_t)v24 < *((void *)a2 + 2) && *v24 == 66)
                  {
                    *((void *)a2 + 1) = v24 + 1;
LABEL_72:
                    *((_DWORD *)this + 16) |= 0x80u;
                    if (*((void *)this + 6) == v5) {
                      operator new();
                    }
                    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
                    if (!result) {
                      return result;
                    }
                    if (*((void *)a2 + 1) == *((void *)a2 + 2)
                      && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                    {
                      *((_DWORD *)a2 + 8) = 0;
                      uint64_t result = 1;
                      *((unsigned char *)a2 + 36) = 1;
                      return result;
                    }
                  }
                }
              }
            }
          }
          continue;
        }
        return 0;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 5) {
          goto LABEL_40;
        }
        goto LABEL_26;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_26;
        }
        int v11 = *((_DWORD *)this + 16);
        goto LABEL_44;
      case 5u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        uint64_t v13 = (char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        goto LABEL_50;
      case 6u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        uint64_t v14 = (char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        goto LABEL_58;
      case 7u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_26;
        }
        int v15 = *((_DWORD *)this + 16);
        goto LABEL_66;
      case 8u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_26;
        }
        goto LABEL_72;
      default:
        int v8 = TagFallback & 7;
LABEL_26:
        if (v8 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t CLMicroLocationProto::BleLeechedBeacons::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 64);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 16), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 64);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 64);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *(float *)(v5 + 20), a3);
  int v6 = *(_DWORD *)(v5 + 64);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_14;
  }
LABEL_13:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  int v6 = *(_DWORD *)(v5 + 64);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_15;
  }
LABEL_14:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(unsigned int *)(v5 + 56), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 64);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
LABEL_16:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    if ((*(_DWORD *)(v5 + 64) & 0x80) == 0) {
      return this;
    }
    goto LABEL_17;
  }
LABEL_15:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(void *)(v5 + 32), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 64);
  if ((v6 & 0x40) != 0) {
    goto LABEL_16;
  }
LABEL_8:
  if ((v6 & 0x80) == 0) {
    return this;
  }
LABEL_17:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::BleLeechedBeacons::ByteSize(CLMicroLocationProto::BleLeechedBeacons *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 64);
  if (!(_BYTE)v2)
  {
    uint64_t v4 = 0;
    goto LABEL_55;
  }
  if (*((unsigned char *)this + 64))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
    if ((v5 & 0x80000000) != 0)
    {
      unsigned int v3 = 11;
    }
    else if (v5 >= 0x80)
    {
      unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
      int v2 = *((_DWORD *)this + 16);
    }
    else
    {
      unsigned int v3 = 2;
    }
  }
  else
  {
    unsigned int v3 = 0;
  }
  if ((v2 & 2) != 0) {
    v3 += 9;
  }
  if ((v2 & 4) != 0) {
    uint64_t v4 = v3 + 5;
  }
  else {
    uint64_t v4 = v3;
  }
  if ((v2 & 8) != 0)
  {
    uint64_t v6 = *((void *)this + 3);
    int v7 = *(unsigned __int8 *)(v6 + 23);
    char v8 = v7;
    uint64_t v9 = *(void *)(v6 + 8);
    if ((v7 & 0x80u) == 0) {
      unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10);
      int v7 = *(unsigned __int8 *)(v6 + 23);
      uint64_t v9 = *(void *)(v6 + 8);
      int v2 = *((_DWORD *)this + 16);
      char v8 = *(unsigned char *)(v6 + 23);
    }
    else
    {
      int v11 = 1;
    }
    if (v8 < 0) {
      int v7 = v9;
    }
    uint64_t v4 = (v4 + v11 + v7 + 1);
    if ((v2 & 0x10) == 0)
    {
LABEL_17:
      if ((v2 & 0x20) == 0) {
        goto LABEL_18;
      }
      goto LABEL_36;
    }
  }
  else if ((v2 & 0x10) == 0)
  {
    goto LABEL_17;
  }
  unint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 14);
  if ((v12 & 0x80000000) != 0)
  {
    int v13 = 11;
  }
  else if (v12 >= 0x80)
  {
    int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12) + 1;
    int v2 = *((_DWORD *)this + 16);
  }
  else
  {
    int v13 = 2;
  }
  uint64_t v4 = (v13 + v4);
  if ((v2 & 0x20) == 0)
  {
LABEL_18:
    if ((v2 & 0x40) == 0) {
      goto LABEL_19;
    }
    goto LABEL_37;
  }
LABEL_36:
  uint64_t v4 = v4
     + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this
                                                                                                 + 4))
     + 1;
  int v2 = *((_DWORD *)this + 16);
  if ((v2 & 0x40) == 0)
  {
LABEL_19:
    if ((v2 & 0x80) == 0) {
      goto LABEL_55;
    }
    goto LABEL_46;
  }
LABEL_37:
  uint64_t v14 = *((void *)this + 5);
  int v15 = *(unsigned __int8 *)(v14 + 23);
  char v16 = v15;
  uint64_t v17 = *(void *)(v14 + 8);
  if ((v15 & 0x80u) == 0) {
    unint64_t v18 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    unint64_t v18 = v17;
  }
  if (v18 >= 0x80)
  {
    int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v18);
    int v15 = *(unsigned __int8 *)(v14 + 23);
    uint64_t v17 = *(void *)(v14 + 8);
    int v2 = *((_DWORD *)this + 16);
    char v16 = *(unsigned char *)(v14 + 23);
  }
  else
  {
    int v19 = 1;
  }
  if (v16 < 0) {
    int v15 = v17;
  }
  uint64_t v4 = (v4 + v19 + v15 + 1);
  if ((v2 & 0x80) != 0)
  {
LABEL_46:
    uint64_t v20 = *((void *)this + 6);
    int v21 = *(unsigned __int8 *)(v20 + 23);
    char v22 = v21;
    uint64_t v23 = *(void *)(v20 + 8);
    if ((v21 & 0x80u) == 0) {
      unint64_t v24 = *(unsigned __int8 *)(v20 + 23);
    }
    else {
      unint64_t v24 = v23;
    }
    if (v24 >= 0x80)
    {
      int v25 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v24);
      int v21 = *(unsigned __int8 *)(v20 + 23);
      uint64_t v23 = *(void *)(v20 + 8);
      char v22 = *(unsigned char *)(v20 + 23);
    }
    else
    {
      int v25 = 1;
    }
    if (v22 < 0) {
      int v21 = v23;
    }
    uint64_t v4 = (v4 + v25 + v21 + 1);
  }
LABEL_55:
  *((_DWORD *)this + 15) = v4;
  return v4;
}

void CLMicroLocationProto::BleLeechedBeacons::CheckTypeAndMergeFrom(CLMicroLocationProto::BleLeechedBeacons *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::BleLeechedBeacons::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::BleLeechedBeacons::CopyFrom(CLMicroLocationProto::BleLeechedBeacons *this, const CLMicroLocationProto::BleLeechedBeacons *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::BleLeechedBeacons *))(*(void *)this + 32))(this);
    CLMicroLocationProto::BleLeechedBeacons::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::BleLeechedBeacons::IsInitialized(CLMicroLocationProto::BleLeechedBeacons *this)
{
  return 1;
}

void *CLMicroLocationProto::BleLeechedBeacons::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.BleLeechedBeacons");
}

CLMicroLocationProto::WiFiRssi *CLMicroLocationProto::WiFiRssi::WiFiRssi(CLMicroLocationProto::WiFiRssi *this, const CLMicroLocationProto::WiFiRssi *a2)
{
  *((_DWORD *)this + 4) = 1;
  *(void *)this = &unk_2704DDD68;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  *(void *)((char *)this + 28) = 0;
  *(void *)((char *)this + 20) = 0;
  CLMicroLocationProto::WiFiRssi::MergeFrom(this, a2);
  return this;
}

void sub_25640DCCC(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::WiFiRssi::MergeFrom(CLMicroLocationProto::WiFiRssi *this, const CLMicroLocationProto::WiFiRssi *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 40);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 40))
  {
    int v5 = *((_DWORD *)a2 + 4);
    if ((v5 - 1) >= 6) {
      CLMicroLocationProto::WiFiRssi::MergeFrom();
    }
    *((_DWORD *)this + 10) |= 1u;
    *((_DWORD *)this + 4) = v5;
    int v4 = *((_DWORD *)a2 + 10);
  }
  if ((v4 & 2) == 0)
  {
    if ((v4 & 4) == 0) {
      goto LABEL_9;
    }
LABEL_14:
    int v8 = *((_DWORD *)a2 + 5);
    *((_DWORD *)this + 10) |= 4u;
    *((_DWORD *)this + 5) = v8;
    int v4 = *((_DWORD *)a2 + 10);
    if ((v4 & 8) == 0)
    {
LABEL_10:
      if ((v4 & 0x10) == 0) {
        return;
      }
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint64_t v7 = *((void *)a2 + 1);
  *((_DWORD *)this + 10) |= 2u;
  *((void *)this + 1) = v7;
  int v4 = *((_DWORD *)a2 + 10);
  if ((v4 & 4) != 0) {
    goto LABEL_14;
  }
LABEL_9:
  if ((v4 & 8) == 0) {
    goto LABEL_10;
  }
LABEL_15:
  uint64_t v9 = *((void *)a2 + 3);
  *((_DWORD *)this + 10) |= 8u;
  *((void *)this + 3) = v9;
  if ((*((_DWORD *)a2 + 10) & 0x10) != 0)
  {
LABEL_11:
    int v6 = *((_DWORD *)a2 + 8);
    *((_DWORD *)this + 10) |= 0x10u;
    *((_DWORD *)this + 8) = v6;
  }
}

void sub_25640DE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::WiFiRssi::~WiFiRssi(CLMicroLocationProto::WiFiRssi *this)
{
  *(void *)this = &unk_2704DDD68;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::WiFiRssi::~WiFiRssi(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::WiFiRssi::New(CLMicroLocationProto::WiFiRssi *this)
{
}

uint64_t CLMicroLocationProto::WiFiRssi::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 40))
  {
    *(_DWORD *)(this + 16) = 1;
    *(void *)(this + 8) = 0;
    *(void *)(this + 28) = 0;
    *(void *)(this + 20) = 0;
  }
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t CLMicroLocationProto::WiFiRssi::MergePartialFromCodedStream(CLMicroLocationProto::WiFiRssi *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  int v4 = (unint64_t *)((char *)this + 24);
  while (2)
  {
    int v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        v20[0] = 0;
        int v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v20);
          if (!result) {
            return result;
          }
          unsigned int v9 = v20[0];
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
        }
        if (v9 - 1 <= 5)
        {
          *((_DWORD *)this + 10) |= 1u;
          *((_DWORD *)this + 4) = v9;
        }
        uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v14 < *((void *)a2 + 2) && *v14 == 17)
        {
          *((void *)a2 + 1) = v14 + 1;
          goto LABEL_31;
        }
        continue;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_20;
        }
LABEL_31:
        *(void *)uint64_t v20 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v20) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v20;
        }
        *((_DWORD *)this + 10) |= 2u;
        int v15 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v15 >= *((void *)a2 + 2) || *v15 != 29) {
          continue;
        }
        *((void *)a2 + 1) = v15 + 1;
LABEL_35:
        v20[0] = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v20))
        {
          *((_DWORD *)this + 5) = v20[0];
          *((_DWORD *)this + 10) |= 4u;
          char v16 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
          if ((unint64_t)v16 < v10 && *v16 == 32)
          {
            int v11 = v16 + 1;
            *((void *)a2 + 1) = v11;
LABEL_39:
            if ((unint64_t)v11 >= v10 || *v11 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v4);
              if (!result) {
                return result;
              }
              uint64_t v17 = (unsigned char *)*((void *)a2 + 1);
              unint64_t v10 = *((void *)a2 + 2);
            }
            else
            {
              *int v4 = *v11;
              uint64_t v17 = v11 + 1;
              *((void *)a2 + 1) = v17;
            }
            *((_DWORD *)this + 10) |= 8u;
            if ((unint64_t)v17 < v10 && *v17 == 40)
            {
              unint64_t v12 = v17 + 1;
              *((void *)a2 + 1) = v12;
LABEL_47:
              v20[0] = 0;
              if ((unint64_t)v12 >= v10 || *v12 < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v20);
                if (!result) {
                  return result;
                }
                unsigned int v18 = v20[0];
                int v19 = (unsigned __int8 *)*((void *)a2 + 1);
                unint64_t v10 = *((void *)a2 + 2);
              }
              else
              {
                unsigned int v18 = *v12;
                int v19 = (unsigned __int8 *)(v12 + 1);
                *((void *)a2 + 1) = v19;
              }
              *((_DWORD *)this + 8) = v18;
              *((_DWORD *)this + 10) |= 0x10u;
              if (v19 == (unsigned __int8 *)v10
                && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
              {
                *((_DWORD *)a2 + 8) = 0;
                uint64_t result = 1;
                *((unsigned char *)a2 + 36) = 1;
                return result;
              }
            }
          }
          continue;
        }
        return 0;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 5) {
          goto LABEL_35;
        }
        goto LABEL_20;
      case 4u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        int v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_39;
      case 5u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        unint64_t v12 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_47;
      default:
        int v7 = TagFallback & 7;
LABEL_20:
        if (v7 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t CLMicroLocationProto::WiFiRssi::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 40);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 16), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 40);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 40);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(void *)(v5 + 24), (uint64_t)a2, a4);
    if ((*(_DWORD *)(v5 + 40) & 0x10) == 0) {
      return this;
    }
    goto LABEL_11;
  }
LABEL_9:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *(float *)(v5 + 20), a3);
  int v6 = *(_DWORD *)(v5 + 40);
  if ((v6 & 8) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v6 & 0x10) == 0) {
    return this;
  }
LABEL_11:
  uint64_t v7 = *(unsigned int *)(v5 + 32);
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v7, (uint64_t)a2, a4);
}

uint64_t CLMicroLocationProto::WiFiRssi::ByteSize(CLMicroLocationProto::WiFiRssi *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 40);
  if ((_BYTE)v2)
  {
    if (*((unsigned char *)this + 40))
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
      if ((v5 & 0x80000000) != 0)
      {
        unsigned int v3 = 11;
      }
      else if (v5 >= 0x80)
      {
        unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
        int v2 = *((_DWORD *)this + 10);
      }
      else
      {
        unsigned int v3 = 2;
      }
    }
    else
    {
      unsigned int v3 = 0;
    }
    if ((v2 & 2) != 0) {
      v3 += 9;
    }
    if ((v2 & 4) != 0) {
      uint64_t v4 = v3 + 5;
    }
    else {
      uint64_t v4 = v3;
    }
    if ((v2 & 8) != 0)
    {
      uint64_t v4 = v4
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 3))
         + 1;
      int v2 = *((_DWORD *)this + 10);
    }
    if ((v2 & 0x10) != 0)
    {
      int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
      if ((v6 & 0x80000000) != 0)
      {
        int v7 = 11;
      }
      else if (v6 >= 0x80)
      {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6) + 1;
      }
      else
      {
        int v7 = 2;
      }
      uint64_t v4 = (v7 + v4);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *((_DWORD *)this + 9) = v4;
  return v4;
}

void CLMicroLocationProto::WiFiRssi::CheckTypeAndMergeFrom(CLMicroLocationProto::WiFiRssi *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::WiFiRssi::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::WiFiRssi::CopyFrom(CLMicroLocationProto::WiFiRssi *this, const CLMicroLocationProto::WiFiRssi *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::WiFiRssi *))(*(void *)this + 32))(this);
    CLMicroLocationProto::WiFiRssi::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::WiFiRssi::IsInitialized(CLMicroLocationProto::WiFiRssi *this)
{
  return 1;
}

void *CLMicroLocationProto::WiFiRssi::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.WiFiRssi");
}

float CLMicroLocationProto::Direction::MergeFrom(CLMicroLocationProto::Direction *this, const CLMicroLocationProto::Direction *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  LOBYTE(v5) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v5)
  {
    if (*((unsigned char *)a2 + 24))
    {
      float result = *((float *)a2 + 2);
      *((_DWORD *)this + 6) |= 1u;
      *((float *)this + 2) = result;
      int v5 = *((_DWORD *)a2 + 6);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          return result;
        }
        goto LABEL_7;
      }
    }
    else if ((*((unsigned char *)a2 + 24) & 2) == 0)
    {
      goto LABEL_6;
    }
    float result = *((float *)a2 + 3);
    *((_DWORD *)this + 6) |= 2u;
    *((float *)this + 3) = result;
    if ((*((_DWORD *)a2 + 6) & 4) == 0) {
      return result;
    }
LABEL_7:
    float result = *((float *)a2 + 4);
    *((_DWORD *)this + 6) |= 4u;
    *((float *)this + 4) = result;
  }
  return result;
}

void sub_25640E5B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::Direction::~Direction(CLMicroLocationProto::Direction *this)
{
  *(void *)this = &unk_2704DDDE0;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::Direction::~Direction(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::Direction::New(CLMicroLocationProto::Direction *this)
{
}

uint64_t CLMicroLocationProto::Direction::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 24))
  {
    *(void *)(this + 8) = 0;
    *(_DWORD *)(this + 16) = 0;
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::Direction::MergePartialFromCodedStream(CLMicroLocationProto::Direction *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t v4 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v4;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v4 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v6 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v7 = TagFallback & 7;
        if (v7 != 5) {
          goto LABEL_27;
        }
        unsigned int v13 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, &v13) & 1) == 0) {
          return 0;
        }
        *((_DWORD *)this + 2) = v13;
        *((_DWORD *)this + 6) |= 1u;
        int v8 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v8 < *((void *)a2 + 2) && *v8 == 21)
        {
          *((void *)a2 + 1) = v8 + 1;
LABEL_17:
          unsigned int v12 = 0;
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, &v12) & 1) == 0) {
            return 0;
          }
          *((_DWORD *)this + 3) = v12;
          *((_DWORD *)this + 6) |= 2u;
          unsigned int v9 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v9 < *((void *)a2 + 2) && *v9 == 29)
          {
            *((void *)a2 + 1) = v9 + 1;
            goto LABEL_21;
          }
        }
      }
      if (v6 == 2)
      {
        int v7 = TagFallback & 7;
        if (v7 != 5) {
          goto LABEL_27;
        }
        goto LABEL_17;
      }
      if (v6 != 3)
      {
        int v7 = TagFallback & 7;
        goto LABEL_27;
      }
      int v7 = TagFallback & 7;
      if (v7 == 5) {
        break;
      }
LABEL_27:
      if (v7 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
    }
      }
LABEL_21:
    unsigned int v11 = 0;
    if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, &v11) & 1) == 0) {
      return 0;
    }
    *((_DWORD *)this + 4) = v11;
    *((_DWORD *)this + 6) |= 4u;
  }
  while (*((void *)a2 + 1) != *((void *)a2 + 2)
       || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10));
  *((_DWORD *)a2 + 8) = 0;
  uint64_t result = 1;
  *((unsigned char *)a2 + 36) = 1;
  return result;
}

uint64_t CLMicroLocationProto::Direction::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 24);
  if ((v5 & 1) == 0)
  {
    if ((v5 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(float *)(v4 + 12), a3);
    if ((*(_DWORD *)(v4 + 24) & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, (uint64_t)a2, *(float *)(this + 8), a3);
  int v5 = *(_DWORD *)(v4 + 24);
  if ((v5 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v5 & 4) == 0) {
    return this;
  }
LABEL_7:
  float v6 = *(float *)(v4 + 16);
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, v6, a3);
}

uint64_t CLMicroLocationProto::Direction::ByteSize(CLMicroLocationProto::Direction *this)
{
  uint64_t v1 = *((unsigned __int8 *)this + 24);
  if (*((unsigned char *)this + 24))
  {
    unsigned int v2 = ((int)(v1 << 31) >> 31) & 5;
    if ((v1 & 2) != 0) {
      v2 += 5;
    }
    if ((v1 & 4) != 0) {
      uint64_t v1 = v2 + 5;
    }
    else {
      uint64_t v1 = v2;
    }
  }
  *((_DWORD *)this + 5) = v1;
  return v1;
}

float CLMicroLocationProto::Direction::CheckTypeAndMergeFrom(CLMicroLocationProto::Direction *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  return CLMicroLocationProto::Direction::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::Direction::IsInitialized(CLMicroLocationProto::Direction *this)
{
  return 1;
}

void *CLMicroLocationProto::Direction::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.Direction");
}

CLMicroLocationProto::UwbRange *CLMicroLocationProto::UwbRange::UwbRange(CLMicroLocationProto::UwbRange *this, const CLMicroLocationProto::UwbRange *a2)
{
  *(void *)this = &unk_2704DDE58;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 6;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = MEMORY[0x263F8C740];
  *((void *)this + 5) = 1;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 6) = 0;
  CLMicroLocationProto::UwbRange::MergeFrom(this, a2);
  return this;
}

void sub_25640EA60(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

float CLMicroLocationProto::UwbRange::MergeFrom(CLMicroLocationProto::UwbRange *this, const CLMicroLocationProto::UwbRange *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }
  LOBYTE(v5) = *((unsigned char *)a2 + 56);
  if ((_BYTE)v5)
  {
    if (*((unsigned char *)a2 + 56))
    {
      int v6 = *((_DWORD *)a2 + 4);
      if ((v6 - 1) >= 6) {
        CLMicroLocationProto::UwbRange::MergeFrom();
      }
      *((_DWORD *)this + 14) |= 1u;
      *((_DWORD *)this + 4) = v6;
      int v5 = *((_DWORD *)a2 + 14);
    }
    if ((v5 & 2) != 0)
    {
      uint64_t v4 = *((void *)a2 + 1);
      *((_DWORD *)this + 14) |= 2u;
      *((void *)this + 1) = v4;
      int v5 = *((_DWORD *)a2 + 14);
      if ((v5 & 4) == 0)
      {
LABEL_9:
        if ((v5 & 8) == 0) {
          goto LABEL_10;
        }
        goto LABEL_19;
      }
    }
    else if ((v5 & 4) == 0)
    {
      goto LABEL_9;
    }
    LODWORD(v4) = *((_DWORD *)a2 + 5);
    *((_DWORD *)this + 14) |= 4u;
    *((_DWORD *)this + 5) = v4;
    int v5 = *((_DWORD *)a2 + 14);
    if ((v5 & 8) == 0)
    {
LABEL_10:
      if ((v5 & 0x10) == 0) {
        goto LABEL_11;
      }
      goto LABEL_24;
    }
LABEL_19:
    *((_DWORD *)this + 14) |= 8u;
    int v7 = (CLMicroLocationProto::Direction *)*((void *)this + 3);
    if (!v7) {
      operator new();
    }
    int v8 = (const CLMicroLocationProto::Direction *)*((void *)a2 + 3);
    if (!v8)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      int v8 = *(const CLMicroLocationProto::Direction **)(CLMicroLocationProto::UwbRange::default_instance_ + 24);
    }
    *(float *)&uint64_t v4 = CLMicroLocationProto::Direction::MergeFrom(v7, v8);
    int v5 = *((_DWORD *)a2 + 14);
    if ((v5 & 0x10) == 0)
    {
LABEL_11:
      if ((v5 & 0x20) == 0) {
        goto LABEL_12;
      }
      goto LABEL_27;
    }
LABEL_24:
    unsigned int v9 = (const std::string *)*((void *)a2 + 4);
    *((_DWORD *)this + 14) |= 0x10u;
    unint64_t v10 = (std::string *)*((void *)this + 4);
    if (v10 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v10, v9);
    int v5 = *((_DWORD *)a2 + 14);
    if ((v5 & 0x20) == 0)
    {
LABEL_12:
      if ((v5 & 0x40) == 0) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
LABEL_27:
    int v11 = *((_DWORD *)a2 + 10);
    if ((v11 - 1) >= 2) {
      CLMicroLocationProto::UwbRange::MergeFrom();
    }
    *((_DWORD *)this + 14) |= 0x20u;
    *((_DWORD *)this + 10) = v11;
    int v5 = *((_DWORD *)a2 + 14);
    if ((v5 & 0x40) == 0) {
      goto LABEL_14;
    }
LABEL_13:
    LODWORD(v4) = *((_DWORD *)a2 + 11);
    *((_DWORD *)this + 14) |= 0x40u;
    *((_DWORD *)this + 11) = v4;
    int v5 = *((_DWORD *)a2 + 14);
LABEL_14:
    if ((v5 & 0x80) != 0)
    {
      LODWORD(v4) = *((_DWORD *)a2 + 12);
      *((_DWORD *)this + 14) |= 0x80u;
      *((_DWORD *)this + 12) = v4;
    }
  }
  return *(float *)&v4;
}

void sub_25640ECA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::UwbRange::~UwbRange(CLMicroLocationProto::UwbRange *this)
{
  *(void *)this = &unk_2704DDE58;
  CLMicroLocationProto::UwbRange::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::UwbRange::~UwbRange(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::UwbRange::SharedDtor(CLMicroLocationProto::UwbRange *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 4);
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::UwbRange *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::UwbRange *)CLMicroLocationProto::UwbRange::default_instance_ != v1)
  {
    uint64_t v4 = *((void *)v1 + 3);
    if (v4)
    {
      int v5 = *(void (**)(void))(*(void *)v4 + 8);
      v5();
    }
  }
}

void CLMicroLocationProto::UwbRange::New(CLMicroLocationProto::UwbRange *this)
{
}

uint64_t CLMicroLocationProto::UwbRange::Clear(uint64_t this)
{
  LOBYTE(v1) = *(unsigned char *)(this + 56);
  if ((_BYTE)v1)
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 6;
    if ((v1 & 8) != 0)
    {
      uint64_t v2 = *(void *)(this + 24);
      if (v2)
      {
        if (*(unsigned char *)(v2 + 24))
        {
          *(void *)(v2 + 8) = 0;
          *(_DWORD *)(v2 + 16) = 0;
        }
        *(_DWORD *)(v2 + 24) = 0;
        int v1 = *(_DWORD *)(this + 56);
      }
    }
    if ((v1 & 0x10) != 0)
    {
      uint64_t v3 = *(void *)(this + 32);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(this + 44) = 0;
    *(_DWORD *)(this + 48) = 0;
    *(_DWORD *)(this + 40) = 1;
  }
  *(_DWORD *)(this + 56) = 0;
  return this;
}

uint64_t CLMicroLocationProto::UwbRange::MergePartialFromCodedStream(CLMicroLocationProto::UwbRange *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    int v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        v29[0] = 0;
        int v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v29);
          if (!result) {
            return result;
          }
          unsigned int v9 = v29[0];
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
        }
        if (v9 - 1 <= 5)
        {
          *((_DWORD *)this + 14) |= 1u;
          *((_DWORD *)this + 4) = v9;
        }
        uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v14 < *((void *)a2 + 2) && *v14 == 17)
        {
          *((void *)a2 + 1) = v14 + 1;
          goto LABEL_36;
        }
        continue;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_26;
        }
LABEL_36:
        *(void *)id v29 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v29) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v29;
        }
        *((_DWORD *)this + 14) |= 2u;
        int v15 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v15 >= *((void *)a2 + 2) || *v15 != 29) {
          continue;
        }
        *((void *)a2 + 1) = v15 + 1;
LABEL_40:
        v29[0] = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v29) & 1) == 0) {
          return 0;
        }
        *((_DWORD *)this + 5) = v29[0];
        int v10 = *((_DWORD *)this + 14) | 4;
        *((_DWORD *)this + 14) = v10;
        char v16 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v16 >= *((void *)a2 + 2) || *v16 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v16 + 1;
LABEL_44:
        *((_DWORD *)this + 14) = v10 | 8;
        uint64_t v17 = (CLMicroLocationProto::Direction *)*((void *)this + 3);
        if (!v17) {
          operator new();
        }
        v29[0] = 0;
        unsigned int v18 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v18 >= *((void *)a2 + 2) || *v18 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v29))return 0; {
        }
          }
        else
        {
          v29[0] = *v18;
          *((void *)a2 + 1) = v18 + 1;
        }
        int v19 = *((_DWORD *)a2 + 14);
        int v20 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v19 + 1;
        if (v19 >= v20) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::Direction::MergePartialFromCodedStream(v17, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v21 = *((_DWORD *)a2 + 14);
        BOOL v22 = __OFSUB__(v21, 1);
        int v23 = v21 - 1;
        if (v23 < 0 == v22) {
          *((_DWORD *)a2 + 14) = v23;
        }
        unint64_t v24 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v24 >= *((void *)a2 + 2) || *v24 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v24 + 1;
LABEL_58:
        *((_DWORD *)this + 14) |= 0x10u;
        if (*((void *)this + 4) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v25 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        if ((unint64_t)v25 >= v11 || *v25 != 48) {
          continue;
        }
        unsigned int v12 = v25 + 1;
        *((void *)a2 + 1) = v12;
LABEL_64:
        v29[0] = 0;
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v29);
          if (!result) {
            return result;
          }
          unsigned int v26 = v29[0];
        }
        else
        {
          unsigned int v26 = *v12;
          *((void *)a2 + 1) = v12 + 1;
        }
        if (v26 - 1 <= 1)
        {
          *((_DWORD *)this + 14) |= 0x20u;
          *((_DWORD *)this + 10) = v26;
        }
        uint64_t v27 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v27 >= *((void *)a2 + 2) || *v27 != 61) {
          continue;
        }
        *((void *)a2 + 1) = v27 + 1;
LABEL_74:
        v29[0] = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v29) & 1) == 0) {
          return 0;
        }
        *((_DWORD *)this + 11) = v29[0];
        *((_DWORD *)this + 14) |= 0x40u;
        BOOL v28 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v28 >= *((void *)a2 + 2) || *v28 != 69) {
          continue;
        }
        *((void *)a2 + 1) = v28 + 1;
LABEL_78:
        v29[0] = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v29))
        {
          *((_DWORD *)this + 12) = v29[0];
          *((_DWORD *)this + 14) |= 0x80u;
          if (*((void *)a2 + 1) == *((void *)a2 + 2)
            && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
          {
            *((_DWORD *)a2 + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)a2 + 36) = 1;
            return result;
          }
          continue;
        }
        return 0;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 5) {
          goto LABEL_40;
        }
        goto LABEL_26;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_26;
        }
        int v10 = *((_DWORD *)this + 14);
        goto LABEL_44;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_58;
        }
        goto LABEL_26;
      case 6u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        unsigned int v12 = (char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        goto LABEL_64;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 == 5) {
          goto LABEL_74;
        }
        goto LABEL_26;
      case 8u:
        int v7 = TagFallback & 7;
        if (v7 != 5) {
          goto LABEL_26;
        }
        goto LABEL_78;
      default:
        int v7 = TagFallback & 7;
LABEL_26:
        if (v7 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

unsigned int *CLMicroLocationProto::UwbRange::SerializeWithCachedSizes(unsigned int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  int v5 = this;
  unsigned int v6 = this[14];
  if (v6)
  {
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[4], (uint64_t)a2, a4);
    unsigned int v6 = v5[14];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *((double *)v5 + 1), a3);
  unsigned int v6 = v5[14];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *((float *)v5 + 5), a3);
  unsigned int v6 = v5[14];
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_16;
  }
LABEL_13:
  uint64_t v7 = *((void *)v5 + 3);
  if (!v7)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v7 = *(void *)(CLMicroLocationProto::UwbRange::default_instance_ + 24);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
  unsigned int v6 = v5[14];
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_17;
  }
LABEL_16:
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  unsigned int v6 = v5[14];
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
LABEL_18:
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, (uint64_t)a2, *((float *)v5 + 11), a3);
    if ((v5[14] & 0x80) == 0) {
      return this;
    }
    goto LABEL_19;
  }
LABEL_17:
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v5[10], (uint64_t)a2, a4);
  unsigned int v6 = v5[14];
  if ((v6 & 0x40) != 0) {
    goto LABEL_18;
  }
LABEL_8:
  if ((v6 & 0x80) == 0) {
    return this;
  }
LABEL_19:
  float v8 = *((float *)v5 + 12);
  return (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, (uint64_t)a2, v8, a3);
}

uint64_t CLMicroLocationProto::UwbRange::ByteSize(CLMicroLocationProto::UwbRange *this)
{
  int v1 = this;
  LOBYTE(v2) = *((unsigned char *)this + 56);
  if (!(_BYTE)v2)
  {
    uint64_t result = 0;
    goto LABEL_49;
  }
  if (*((unsigned char *)this + 56))
  {
    this = (CLMicroLocationProto::UwbRange *)*((unsigned int *)this + 4);
    if ((this & 0x80000000) != 0)
    {
      int v3 = 11;
    }
    else if (this >= 0x80)
    {
      this = (CLMicroLocationProto::UwbRange *)wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(this);
      int v3 = this + 1;
      int v2 = *((_DWORD *)v1 + 14);
    }
    else
    {
      int v3 = 2;
    }
  }
  else
  {
    int v3 = 0;
  }
  if ((v2 & 2) != 0) {
    v3 += 9;
  }
  if ((v2 & 4) != 0) {
    int v5 = v3 + 5;
  }
  else {
    int v5 = v3;
  }
  if ((v2 & 8) != 0)
  {
    uint64_t v6 = *((void *)v1 + 3);
    if (!v6)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      uint64_t v6 = *(void *)(CLMicroLocationProto::UwbRange::default_instance_ + 24);
    }
    int v7 = *(unsigned __int8 *)(v6 + 24);
    int v8 = (v7 << 31 >> 31) & 5;
    if ((v7 & 2) != 0) {
      v8 += 5;
    }
    if ((v7 & 4) != 0) {
      v8 += 5;
    }
    if (*(unsigned char *)(v6 + 24)) {
      int v9 = v8;
    }
    else {
      int v9 = 0;
    }
    *(_DWORD *)(v6 + 20) = v9;
    v5 += v9 + 2;
    int v2 = *((_DWORD *)v1 + 14);
    if ((v2 & 0x10) == 0)
    {
LABEL_17:
      if ((v2 & 0x20) == 0) {
        goto LABEL_44;
      }
      goto LABEL_38;
    }
  }
  else if ((v2 & 0x10) == 0)
  {
    goto LABEL_17;
  }
  uint64_t v10 = *((void *)v1 + 4);
  int v11 = *(unsigned __int8 *)(v10 + 23);
  char v12 = v11;
  uint64_t v13 = *(void *)(v10 + 8);
  if ((v11 & 0x80u) == 0) {
    unint64_t v14 = *(unsigned __int8 *)(v10 + 23);
  }
  else {
    unint64_t v14 = v13;
  }
  if (v14 >= 0x80)
  {
    int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v14);
    int v11 = *(unsigned __int8 *)(v10 + 23);
    uint64_t v13 = *(void *)(v10 + 8);
    int v2 = *((_DWORD *)v1 + 14);
    char v12 = *(unsigned char *)(v10 + 23);
  }
  else
  {
    int v15 = 1;
  }
  if (v12 < 0) {
    int v11 = v13;
  }
  v5 += v15 + v11 + 1;
  if ((v2 & 0x20) == 0) {
    goto LABEL_44;
  }
LABEL_38:
  char v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)v1 + 10);
  if ((v16 & 0x80000000) != 0)
  {
    int v17 = 11;
  }
  else if (v16 >= 0x80)
  {
    int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16) + 1;
    int v2 = *((_DWORD *)v1 + 14);
  }
  else
  {
    int v17 = 2;
  }
  v5 += v17;
LABEL_44:
  unsigned int v18 = v5 + 5;
  if ((v2 & 0x40) == 0) {
    unsigned int v18 = v5;
  }
  if ((v2 & 0x80) != 0) {
    uint64_t result = v18 + 5;
  }
  else {
    uint64_t result = v18;
  }
LABEL_49:
  *((_DWORD *)v1 + 13) = result;
  return result;
}

float CLMicroLocationProto::UwbRange::CheckTypeAndMergeFrom(CLMicroLocationProto::UwbRange *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  return CLMicroLocationProto::UwbRange::MergeFrom(this, lpsrc);
}

float CLMicroLocationProto::UwbRange::CopyFrom(CLMicroLocationProto::UwbRange *this, const CLMicroLocationProto::UwbRange *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::UwbRange *))(*(void *)this + 32))(this);
    return CLMicroLocationProto::UwbRange::MergeFrom(this, a2);
  }
  return result;
}

uint64_t CLMicroLocationProto::UwbRange::IsInitialized(CLMicroLocationProto::UwbRange *this)
{
  return 1;
}

void *CLMicroLocationProto::UwbRange::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.UwbRange");
}

void CLMicroLocationProto::WiFiRange::MergeFrom(CLMicroLocationProto::WiFiRange *this, const CLMicroLocationProto::WiFiRange *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 40);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 40))
    {
      int v5 = *((_DWORD *)a2 + 4);
      if ((v5 - 1) >= 6) {
        CLMicroLocationProto::WiFiRange::MergeFrom();
      }
      *((_DWORD *)this + 10) |= 1u;
      *((_DWORD *)this + 4) = v5;
      int v4 = *((_DWORD *)a2 + 10);
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v6 = *((void *)a2 + 1);
      *((_DWORD *)this + 10) |= 2u;
      *((void *)this + 1) = v6;
      int v4 = *((_DWORD *)a2 + 10);
      if ((v4 & 4) == 0)
      {
LABEL_9:
        if ((v4 & 8) == 0) {
          goto LABEL_10;
        }
        goto LABEL_14;
      }
    }
    else if ((v4 & 4) == 0)
    {
      goto LABEL_9;
    }
    int v7 = *((_DWORD *)a2 + 5);
    *((_DWORD *)this + 10) |= 4u;
    *((_DWORD *)this + 5) = v7;
    int v4 = *((_DWORD *)a2 + 10);
    if ((v4 & 8) == 0)
    {
LABEL_10:
      if ((v4 & 0x10) == 0) {
        return;
      }
LABEL_15:
      int v9 = (const std::string *)*((void *)a2 + 3);
      *((_DWORD *)this + 10) |= 0x10u;
      uint64_t v10 = (std::string *)*((void *)this + 3);
      if (v10 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v10, v9);
      return;
    }
LABEL_14:
    int v8 = *((_DWORD *)a2 + 8);
    *((_DWORD *)this + 10) |= 8u;
    *((_DWORD *)this + 8) = v8;
    if ((*((_DWORD *)a2 + 10) & 0x10) == 0) {
      return;
    }
    goto LABEL_15;
  }
}

void sub_25640F934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::WiFiRange::~WiFiRange(CLMicroLocationProto::WiFiRange *this)
{
  *(void *)this = &unk_2704DDED0;
  CLMicroLocationProto::WiFiRange::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::WiFiRange::~WiFiRange(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::WiFiRange::SharedDtor(CLMicroLocationProto::WiFiRange *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1 != MEMORY[0x263F8C740] && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    this = (CLMicroLocationProto::WiFiRange *)MEMORY[0x25A2A6340](v1, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::WiFiRange::New(CLMicroLocationProto::WiFiRange *this)
{
}

uint64_t CLMicroLocationProto::WiFiRange::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 40);
  if (v1)
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 2;
    *(_DWORD *)(this + 32) = 0;
    if ((v1 & 0x10) != 0)
    {
      uint64_t v2 = *(void *)(this + 24);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t CLMicroLocationProto::WiFiRange::MergePartialFromCodedStream(CLMicroLocationProto::WiFiRange *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    int v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_21;
        }
        v16[0] = 0;
        int v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v16);
          if (!result) {
            return result;
          }
          unsigned int v9 = v16[0];
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
        }
        if (v9 - 1 <= 5)
        {
          *((_DWORD *)this + 10) |= 1u;
          *((_DWORD *)this + 4) = v9;
        }
        char v12 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v12 < *((void *)a2 + 2) && *v12 == 17)
        {
          *((void *)a2 + 1) = v12 + 1;
          goto LABEL_31;
        }
        continue;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_21;
        }
LABEL_31:
        *(void *)char v16 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v16) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v16;
        }
        *((_DWORD *)this + 10) |= 2u;
        uint64_t v13 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v13 >= *((void *)a2 + 2) || *v13 != 29) {
          continue;
        }
        *((void *)a2 + 1) = v13 + 1;
LABEL_35:
        v16[0] = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v16) & 1) == 0) {
          return 0;
        }
        *((_DWORD *)this + 5) = v16[0];
        *((_DWORD *)this + 10) |= 4u;
        unint64_t v14 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 != 37) {
          continue;
        }
        *((void *)a2 + 1) = v14 + 1;
LABEL_39:
        v16[0] = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v16))
        {
          *((_DWORD *)this + 8) = v16[0];
          int v10 = *((_DWORD *)this + 10) | 8;
          *((_DWORD *)this + 10) = v10;
          int v15 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v15 < *((void *)a2 + 2) && *v15 == 42)
          {
            *((void *)a2 + 1) = v15 + 1;
LABEL_43:
            *((_DWORD *)this + 10) = v10 | 0x10;
            if (*((void *)this + 3) == v4) {
              operator new();
            }
            uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
            if (!result) {
              return result;
            }
            if (*((void *)a2 + 1) == *((void *)a2 + 2)
              && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
            {
              *((_DWORD *)a2 + 8) = 0;
              uint64_t result = 1;
              *((unsigned char *)a2 + 36) = 1;
              return result;
            }
          }
          continue;
        }
        return 0;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 5) {
          goto LABEL_35;
        }
        goto LABEL_21;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 5) {
          goto LABEL_39;
        }
        goto LABEL_21;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_21;
        }
        int v10 = *((_DWORD *)this + 10);
        goto LABEL_43;
      default:
        int v7 = TagFallback & 7;
LABEL_21:
        if (v7 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t CLMicroLocationProto::WiFiRange::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 40);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 16), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 40);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 40);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, (uint64_t)a2, *(float *)(v5 + 32), a3);
    if ((*(_DWORD *)(v5 + 40) & 0x10) == 0) {
      return this;
    }
    goto LABEL_11;
  }
LABEL_9:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *(float *)(v5 + 20), a3);
  int v6 = *(_DWORD *)(v5 + 40);
  if ((v6 & 8) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v6 & 0x10) == 0) {
    return this;
  }
LABEL_11:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::WiFiRange::ByteSize(CLMicroLocationProto::WiFiRange *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 40);
  if ((_BYTE)v2)
  {
    if (*((unsigned char *)this + 40))
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
      if ((v5 & 0x80000000) != 0)
      {
        unsigned int v3 = 11;
      }
      else if (v5 >= 0x80)
      {
        unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
        int v2 = *((_DWORD *)this + 10);
      }
      else
      {
        unsigned int v3 = 2;
      }
    }
    else
    {
      unsigned int v3 = 0;
    }
    if ((v2 & 2) != 0) {
      v3 += 9;
    }
    if ((v2 & 4) != 0) {
      v3 += 5;
    }
    if ((v2 & 8) != 0) {
      uint64_t v4 = v3 + 5;
    }
    else {
      uint64_t v4 = v3;
    }
    if ((v2 & 0x10) != 0)
    {
      uint64_t v6 = *((void *)this + 3);
      int v7 = *(unsigned __int8 *)(v6 + 23);
      char v8 = v7;
      uint64_t v9 = *(void *)(v6 + 8);
      if ((v7 & 0x80u) == 0) {
        unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
      }
      else {
        unint64_t v10 = v9;
      }
      if (v10 >= 0x80)
      {
        int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10);
        int v7 = *(unsigned __int8 *)(v6 + 23);
        uint64_t v9 = *(void *)(v6 + 8);
        char v8 = *(unsigned char *)(v6 + 23);
      }
      else
      {
        int v11 = 1;
      }
      if (v8 < 0) {
        int v7 = v9;
      }
      uint64_t v4 = (v4 + v11 + v7 + 1);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *((_DWORD *)this + 9) = v4;
  return v4;
}

void CLMicroLocationProto::WiFiRange::CheckTypeAndMergeFrom(CLMicroLocationProto::WiFiRange *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::WiFiRange::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::WiFiRange::IsInitialized(CLMicroLocationProto::WiFiRange *this)
{
  return 1;
}

void *CLMicroLocationProto::WiFiRange::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.WiFiRange");
}

void CLMicroLocationProto::ATVAirplayBluetoothRssi::MergeFrom(CLMicroLocationProto::ATVAirplayBluetoothRssi *this, const CLMicroLocationProto::ATVAirplayBluetoothRssi *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 44);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 44))
  {
    int v5 = *((_DWORD *)a2 + 4);
    if ((v5 - 1) >= 6) {
      CLMicroLocationProto::ATVAirplayBluetoothRssi::MergeFrom();
    }
    *((_DWORD *)this + 11) |= 1u;
    *((_DWORD *)this + 4) = v5;
    int v4 = *((_DWORD *)a2 + 11);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v7 = *((void *)a2 + 1);
    *((_DWORD *)this + 11) |= 2u;
    *((void *)this + 1) = v7;
    int v4 = *((_DWORD *)a2 + 11);
    if ((v4 & 4) == 0)
    {
LABEL_9:
      if ((v4 & 8) == 0) {
        goto LABEL_10;
      }
LABEL_16:
      int v9 = *((_DWORD *)a2 + 8);
      *((_DWORD *)this + 11) |= 8u;
      *((_DWORD *)this + 8) = v9;
      int v4 = *((_DWORD *)a2 + 11);
      if ((v4 & 0x10) == 0)
      {
LABEL_11:
        if ((v4 & 0x20) == 0) {
          return;
        }
        goto LABEL_12;
      }
      goto LABEL_17;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_9;
  }
  int v8 = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 11) |= 4u;
  *((_DWORD *)this + 5) = v8;
  int v4 = *((_DWORD *)a2 + 11);
  if ((v4 & 8) != 0) {
    goto LABEL_16;
  }
LABEL_10:
  if ((v4 & 0x10) == 0) {
    goto LABEL_11;
  }
LABEL_17:
  unint64_t v10 = (const std::string *)*((void *)a2 + 3);
  *((_DWORD *)this + 11) |= 0x10u;
  int v11 = (std::string *)*((void *)this + 3);
  if (v11 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v11, v10);
  if ((*((_DWORD *)a2 + 11) & 0x20) != 0)
  {
LABEL_12:
    int v6 = *((_DWORD *)a2 + 9);
    *((_DWORD *)this + 11) |= 0x20u;
    *((_DWORD *)this + 9) = v6;
  }
}

void sub_2564101DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ATVAirplayBluetoothRssi::~ATVAirplayBluetoothRssi(CLMicroLocationProto::ATVAirplayBluetoothRssi *this)
{
  *(void *)this = &unk_2704DDF48;
  CLMicroLocationProto::WiFiRange::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ATVAirplayBluetoothRssi::~ATVAirplayBluetoothRssi(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ATVAirplayBluetoothRssi::New(CLMicroLocationProto::ATVAirplayBluetoothRssi *this)
{
}

uint64_t CLMicroLocationProto::ATVAirplayBluetoothRssi::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 44);
  if (v1)
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 3;
    *(_DWORD *)(this + 32) = 0;
    if ((v1 & 0x10) != 0)
    {
      uint64_t v2 = *(void *)(this + 24);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(this + 36) = 0;
  }
  *(_DWORD *)(this + 44) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ATVAirplayBluetoothRssi::MergePartialFromCodedStream(CLMicroLocationProto::ATVAirplayBluetoothRssi *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  int v4 = (unsigned int *)((char *)this + 32);
  uint64_t v5 = MEMORY[0x263F8C740];
  while (2)
  {
    int v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v6;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        v24[0] = 0;
        int v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v24);
          if (!result) {
            return result;
          }
          unsigned int v10 = v24[0];
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 - 1 <= 5)
        {
          *((_DWORD *)this + 11) |= 1u;
          *((_DWORD *)this + 4) = v10;
        }
        int v17 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v17 < *((void *)a2 + 2) && *v17 == 17)
        {
          *((void *)a2 + 1) = v17 + 1;
          goto LABEL_33;
        }
        continue;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_22;
        }
LABEL_33:
        *(void *)unint64_t v24 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v24) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v24;
        }
        *((_DWORD *)this + 11) |= 2u;
        unsigned int v18 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v18 >= *((void *)a2 + 2) || *v18 != 29) {
          continue;
        }
        *((void *)a2 + 1) = v18 + 1;
LABEL_37:
        v24[0] = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v24))
        {
          *((_DWORD *)this + 5) = v24[0];
          *((_DWORD *)this + 11) |= 4u;
          int v19 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v11 = *((void *)a2 + 2);
          if ((unint64_t)v19 < v11 && *v19 == 32)
          {
            char v12 = v19 + 1;
            *((void *)a2 + 1) = v12;
LABEL_41:
            if ((unint64_t)v12 >= v11 || *v12 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v4);
              if (!result) {
                return result;
              }
              int v20 = (unsigned char *)*((void *)a2 + 1);
              unint64_t v11 = *((void *)a2 + 2);
            }
            else
            {
              *int v4 = *v12;
              int v20 = v12 + 1;
              *((void *)a2 + 1) = v20;
            }
            int v13 = *((_DWORD *)this + 11) | 8;
            *((_DWORD *)this + 11) = v13;
            if ((unint64_t)v20 < v11 && *v20 == 42)
            {
              *((void *)a2 + 1) = v20 + 1;
LABEL_49:
              *((_DWORD *)this + 11) = v13 | 0x10;
              if (*((void *)this + 3) == v5) {
                operator new();
              }
              uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
              if (!result) {
                return result;
              }
              int v21 = (unsigned char *)*((void *)a2 + 1);
              unint64_t v14 = *((void *)a2 + 2);
              if ((unint64_t)v21 < v14 && *v21 == 48)
              {
                int v15 = v21 + 1;
                *((void *)a2 + 1) = v15;
LABEL_55:
                v24[0] = 0;
                if ((unint64_t)v15 >= v14 || *v15 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v24);
                  if (!result) {
                    return result;
                  }
                  unsigned int v22 = v24[0];
                  int v23 = (unsigned __int8 *)*((void *)a2 + 1);
                  unint64_t v14 = *((void *)a2 + 2);
                }
                else
                {
                  unsigned int v22 = *v15;
                  int v23 = (unsigned __int8 *)(v15 + 1);
                  *((void *)a2 + 1) = v23;
                }
                *((_DWORD *)this + 9) = v22;
                *((_DWORD *)this + 11) |= 0x20u;
                if (v23 == (unsigned __int8 *)v14
                  && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                {
                  *((_DWORD *)a2 + 8) = 0;
                  uint64_t result = 1;
                  *((unsigned char *)a2 + 36) = 1;
                  return result;
                }
              }
            }
          }
          continue;
        }
        return 0;
      case 3u:
        int v8 = TagFallback & 7;
        if (v8 == 5) {
          goto LABEL_37;
        }
        goto LABEL_22;
      case 4u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        char v12 = (char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        goto LABEL_41;
      case 5u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_22;
        }
        int v13 = *((_DWORD *)this + 11);
        goto LABEL_49;
      case 6u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        int v15 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        goto LABEL_55;
      default:
        int v8 = TagFallback & 7;
LABEL_22:
        if (v8 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t CLMicroLocationProto::ATVAirplayBluetoothRssi::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 44);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 16), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *(float *)(v5 + 20), a3);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
LABEL_12:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    if ((*(_DWORD *)(v5 + 44) & 0x20) == 0) {
      return this;
    }
    goto LABEL_13;
  }
LABEL_11:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(unsigned int *)(v5 + 32), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 0x10) != 0) {
    goto LABEL_12;
  }
LABEL_6:
  if ((v6 & 0x20) == 0) {
    return this;
  }
LABEL_13:
  uint64_t v7 = *(unsigned int *)(v5 + 36);
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v7, (uint64_t)a2, a4);
}

uint64_t CLMicroLocationProto::ATVAirplayBluetoothRssi::ByteSize(CLMicroLocationProto::ATVAirplayBluetoothRssi *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 44);
  if (!(_BYTE)v2)
  {
    uint64_t v4 = 0;
    goto LABEL_38;
  }
  if (*((unsigned char *)this + 44))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
    if ((v5 & 0x80000000) != 0)
    {
      unsigned int v3 = 11;
    }
    else if (v5 >= 0x80)
    {
      unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
      int v2 = *((_DWORD *)this + 11);
    }
    else
    {
      unsigned int v3 = 2;
    }
  }
  else
  {
    unsigned int v3 = 0;
  }
  if ((v2 & 2) != 0) {
    v3 += 9;
  }
  if ((v2 & 4) != 0) {
    uint64_t v4 = v3 + 5;
  }
  else {
    uint64_t v4 = v3;
  }
  if ((v2 & 8) != 0)
  {
    int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
    if (v6 >= 0x80)
    {
      int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6) + 1;
      int v2 = *((_DWORD *)this + 11);
    }
    else
    {
      int v7 = 2;
    }
    uint64_t v4 = (v7 + v4);
    if ((v2 & 0x10) == 0)
    {
LABEL_17:
      if ((v2 & 0x20) == 0) {
        goto LABEL_38;
      }
      goto LABEL_32;
    }
  }
  else if ((v2 & 0x10) == 0)
  {
    goto LABEL_17;
  }
  uint64_t v8 = *((void *)this + 3);
  int v9 = *(unsigned __int8 *)(v8 + 23);
  char v10 = v9;
  uint64_t v11 = *(void *)(v8 + 8);
  if ((v9 & 0x80u) == 0) {
    unint64_t v12 = *(unsigned __int8 *)(v8 + 23);
  }
  else {
    unint64_t v12 = v11;
  }
  if (v12 >= 0x80)
  {
    int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v12);
    int v9 = *(unsigned __int8 *)(v8 + 23);
    uint64_t v11 = *(void *)(v8 + 8);
    int v2 = *((_DWORD *)this + 11);
    char v10 = *(unsigned char *)(v8 + 23);
  }
  else
  {
    int v13 = 1;
  }
  if (v10 < 0) {
    int v9 = v11;
  }
  uint64_t v4 = (v4 + v13 + v9 + 1);
  if ((v2 & 0x20) != 0)
  {
LABEL_32:
    unint64_t v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 9);
    if ((v14 & 0x80000000) != 0)
    {
      int v15 = 11;
    }
    else if (v14 >= 0x80)
    {
      int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14) + 1;
    }
    else
    {
      int v15 = 2;
    }
    uint64_t v4 = (v15 + v4);
  }
LABEL_38:
  *((_DWORD *)this + 10) = v4;
  return v4;
}

void CLMicroLocationProto::ATVAirplayBluetoothRssi::CheckTypeAndMergeFrom(CLMicroLocationProto::ATVAirplayBluetoothRssi *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ATVAirplayBluetoothRssi::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::ATVAirplayBluetoothRssi::IsInitialized(CLMicroLocationProto::ATVAirplayBluetoothRssi *this)
{
  return 1;
}

void *CLMicroLocationProto::ATVAirplayBluetoothRssi::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ATVAirplayBluetoothRssi");
}

void CLMicroLocationProto::HomeKitBluetoothRssi::MergeFrom(CLMicroLocationProto::HomeKitBluetoothRssi *this, const CLMicroLocationProto::HomeKitBluetoothRssi *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 44);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 44))
  {
    int v5 = *((_DWORD *)a2 + 4);
    if ((v5 - 1) >= 6) {
      CLMicroLocationProto::HomeKitBluetoothRssi::MergeFrom();
    }
    *((_DWORD *)this + 11) |= 1u;
    *((_DWORD *)this + 4) = v5;
    int v4 = *((_DWORD *)a2 + 11);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v6 = *((void *)a2 + 1);
    *((_DWORD *)this + 11) |= 2u;
    *((void *)this + 1) = v6;
    int v4 = *((_DWORD *)a2 + 11);
    if ((v4 & 4) == 0)
    {
LABEL_9:
      if ((v4 & 8) == 0) {
        goto LABEL_10;
      }
LABEL_15:
      uint64_t v8 = (const std::string *)*((void *)a2 + 3);
      *((_DWORD *)this + 11) |= 8u;
      int v9 = (std::string *)*((void *)this + 3);
      if (v9 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v9, v8);
      int v4 = *((_DWORD *)a2 + 11);
      if ((v4 & 0x10) == 0)
      {
LABEL_11:
        if ((v4 & 0x20) == 0) {
          return;
        }
        goto LABEL_20;
      }
      goto LABEL_18;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_9;
  }
  int v7 = *((_DWORD *)a2 + 5);
  *((_DWORD *)this + 11) |= 4u;
  *((_DWORD *)this + 5) = v7;
  int v4 = *((_DWORD *)a2 + 11);
  if ((v4 & 8) != 0) {
    goto LABEL_15;
  }
LABEL_10:
  if ((v4 & 0x10) == 0) {
    goto LABEL_11;
  }
LABEL_18:
  int v10 = *((_DWORD *)a2 + 8);
  if ((v10 - 1) >= 0xF) {
    CLMicroLocationProto::HomeKitBluetoothRssi::MergeFrom();
  }
  *((_DWORD *)this + 11) |= 0x10u;
  *((_DWORD *)this + 8) = v10;
  if ((*((_DWORD *)a2 + 11) & 0x20) != 0)
  {
LABEL_20:
    int v11 = *((_DWORD *)a2 + 9);
    if ((v11 - 1) >= 2) {
      CLMicroLocationProto::HomeKitBluetoothRssi::MergeFrom();
    }
    *((_DWORD *)this + 11) |= 0x20u;
    *((_DWORD *)this + 9) = v11;
  }
}

void sub_256410B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::HomeKitBluetoothRssi::~HomeKitBluetoothRssi(CLMicroLocationProto::HomeKitBluetoothRssi *this)
{
  *(void *)this = &unk_2704DDFC0;
  CLMicroLocationProto::WiFiRange::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::HomeKitBluetoothRssi::~HomeKitBluetoothRssi(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::HomeKitBluetoothRssi::New(CLMicroLocationProto::HomeKitBluetoothRssi *this)
{
}

uint64_t CLMicroLocationProto::HomeKitBluetoothRssi::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 44);
  if (v1)
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 4;
    if ((v1 & 8) != 0)
    {
      uint64_t v2 = *(void *)(this + 24);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    *(void *)(this + 32) = 0x100000001;
  }
  *(_DWORD *)(this + 44) = 0;
  return this;
}

uint64_t CLMicroLocationProto::HomeKitBluetoothRssi::MergePartialFromCodedStream(CLMicroLocationProto::HomeKitBluetoothRssi *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    int v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        v23[0] = 0;
        uint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v23);
          if (!result) {
            return result;
          }
          unsigned int v9 = v23[0];
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
        }
        if (v9 - 1 <= 5)
        {
          *((_DWORD *)this + 11) |= 1u;
          *((_DWORD *)this + 4) = v9;
        }
        char v16 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v16 < *((void *)a2 + 2) && *v16 == 17)
        {
          *((void *)a2 + 1) = v16 + 1;
          goto LABEL_33;
        }
        continue;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_22;
        }
LABEL_33:
        *(void *)int v23 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v23) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v23;
        }
        *((_DWORD *)this + 11) |= 2u;
        int v17 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v17 >= *((void *)a2 + 2) || *v17 != 29) {
          continue;
        }
        *((void *)a2 + 1) = v17 + 1;
LABEL_37:
        v23[0] = 0;
        if (wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v23))
        {
          *((_DWORD *)this + 5) = v23[0];
          int v10 = *((_DWORD *)this + 11) | 4;
          *((_DWORD *)this + 11) = v10;
          unsigned int v18 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v18 < *((void *)a2 + 2) && *v18 == 34)
          {
            *((void *)a2 + 1) = v18 + 1;
LABEL_41:
            *((_DWORD *)this + 11) = v10 | 8;
            if (*((void *)this + 3) == v4) {
              operator new();
            }
            uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
            if (!result) {
              return result;
            }
            int v19 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v11 = *((void *)a2 + 2);
            if ((unint64_t)v19 < v11 && *v19 == 40)
            {
              unint64_t v12 = v19 + 1;
              *((void *)a2 + 1) = v12;
LABEL_47:
              v23[0] = 0;
              if ((unint64_t)v12 >= v11 || *v12 < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v23);
                if (!result) {
                  return result;
                }
                unsigned int v20 = v23[0];
              }
              else
              {
                unsigned int v20 = *v12;
                *((void *)a2 + 1) = v12 + 1;
              }
              if (v20 - 1 <= 0xE)
              {
                *((_DWORD *)this + 11) |= 0x10u;
                *((_DWORD *)this + 8) = v20;
              }
              int v21 = (unsigned char *)*((void *)a2 + 1);
              unint64_t v13 = *((void *)a2 + 2);
              if ((unint64_t)v21 < v13 && *v21 == 48)
              {
                unint64_t v14 = v21 + 1;
                *((void *)a2 + 1) = v14;
LABEL_57:
                v23[0] = 0;
                if ((unint64_t)v14 >= v13 || *v14 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v23);
                  if (!result) {
                    return result;
                  }
                  unsigned int v22 = v23[0];
                }
                else
                {
                  unsigned int v22 = *v14;
                  *((void *)a2 + 1) = v14 + 1;
                }
                if (v22 - 1 <= 1)
                {
                  *((_DWORD *)this + 11) |= 0x20u;
                  *((_DWORD *)this + 9) = v22;
                }
                if (*((void *)a2 + 1) == *((void *)a2 + 2)
                  && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                {
                  *((_DWORD *)a2 + 8) = 0;
                  uint64_t result = 1;
                  *((unsigned char *)a2 + 36) = 1;
                  return result;
                }
              }
            }
          }
          continue;
        }
        return 0;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 5) {
          goto LABEL_37;
        }
        goto LABEL_22;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_22;
        }
        int v10 = *((_DWORD *)this + 11);
        goto LABEL_41;
      case 5u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        unint64_t v12 = (char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        goto LABEL_47;
      case 6u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        unint64_t v14 = (char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        goto LABEL_57;
      default:
        int v7 = TagFallback & 7;
LABEL_22:
        if (v7 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t CLMicroLocationProto::HomeKitBluetoothRssi::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 44);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 16), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *(float *)(v5 + 20), a3);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
LABEL_12:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(unsigned int *)(v5 + 32), (uint64_t)a2, a4);
    if ((*(_DWORD *)(v5 + 44) & 0x20) == 0) {
      return this;
    }
    goto LABEL_13;
  }
LABEL_11:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 0x10) != 0) {
    goto LABEL_12;
  }
LABEL_6:
  if ((v6 & 0x20) == 0) {
    return this;
  }
LABEL_13:
  uint64_t v7 = *(unsigned int *)(v5 + 36);
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v7, (uint64_t)a2, a4);
}

uint64_t CLMicroLocationProto::HomeKitBluetoothRssi::ByteSize(CLMicroLocationProto::HomeKitBluetoothRssi *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 44);
  if (!(_BYTE)v2)
  {
    uint64_t v4 = 0;
    goto LABEL_40;
  }
  if (*((unsigned char *)this + 44))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
    if ((v5 & 0x80000000) != 0)
    {
      unsigned int v3 = 11;
    }
    else if (v5 >= 0x80)
    {
      unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
      int v2 = *((_DWORD *)this + 11);
    }
    else
    {
      unsigned int v3 = 2;
    }
  }
  else
  {
    unsigned int v3 = 0;
  }
  if ((v2 & 2) != 0) {
    v3 += 9;
  }
  if ((v2 & 4) != 0) {
    uint64_t v4 = v3 + 5;
  }
  else {
    uint64_t v4 = v3;
  }
  if ((v2 & 8) != 0)
  {
    uint64_t v6 = *((void *)this + 3);
    int v7 = *(unsigned __int8 *)(v6 + 23);
    char v8 = v7;
    uint64_t v9 = *(void *)(v6 + 8);
    if ((v7 & 0x80u) == 0) {
      unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 >= 0x80)
    {
      int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10);
      int v7 = *(unsigned __int8 *)(v6 + 23);
      uint64_t v9 = *(void *)(v6 + 8);
      int v2 = *((_DWORD *)this + 11);
      char v8 = *(unsigned char *)(v6 + 23);
    }
    else
    {
      int v11 = 1;
    }
    if (v8 < 0) {
      int v7 = v9;
    }
    uint64_t v4 = (v4 + v11 + v7 + 1);
    if ((v2 & 0x10) == 0)
    {
LABEL_17:
      if ((v2 & 0x20) == 0) {
        goto LABEL_40;
      }
      goto LABEL_34;
    }
  }
  else if ((v2 & 0x10) == 0)
  {
    goto LABEL_17;
  }
  unint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
  if ((v12 & 0x80000000) != 0)
  {
    int v13 = 11;
  }
  else if (v12 >= 0x80)
  {
    int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12) + 1;
    int v2 = *((_DWORD *)this + 11);
  }
  else
  {
    int v13 = 2;
  }
  uint64_t v4 = (v13 + v4);
  if ((v2 & 0x20) != 0)
  {
LABEL_34:
    unint64_t v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 9);
    if ((v14 & 0x80000000) != 0)
    {
      int v15 = 11;
    }
    else if (v14 >= 0x80)
    {
      int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14) + 1;
    }
    else
    {
      int v15 = 2;
    }
    uint64_t v4 = (v15 + v4);
  }
LABEL_40:
  *((_DWORD *)this + 10) = v4;
  return v4;
}

void CLMicroLocationProto::HomeKitBluetoothRssi::CheckTypeAndMergeFrom(CLMicroLocationProto::HomeKitBluetoothRssi *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::HomeKitBluetoothRssi::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::HomeKitBluetoothRssi::IsInitialized(CLMicroLocationProto::HomeKitBluetoothRssi *this)
{
  return 1;
}

void *CLMicroLocationProto::HomeKitBluetoothRssi::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.HomeKitBluetoothRssi");
}

CLMicroLocationProto::Measurement *CLMicroLocationProto::Measurement::Measurement(CLMicroLocationProto::Measurement *this, const CLMicroLocationProto::Measurement *a2)
{
  *(void *)this = &unk_2704DE038;
  *((void *)this + 8) = 1;
  *((_DWORD *)this + 18) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = 0;
  CLMicroLocationProto::Measurement::MergeFrom(this, a2);
  return this;
}

void sub_2564113A8(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

float CLMicroLocationProto::Measurement::MergeFrom(CLMicroLocationProto::Measurement *this, const CLMicroLocationProto::Measurement *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v20);
  }
  LOBYTE(v5) = *((unsigned char *)a2 + 72);
  if (!(_BYTE)v5) {
    return *(float *)&v4;
  }
  if (*((unsigned char *)a2 + 72))
  {
    int v6 = *((_DWORD *)a2 + 16);
    if ((v6 - 1) >= 6) {
      CLMicroLocationProto::Measurement::MergeFrom();
    }
    *((_DWORD *)this + 18) |= 1u;
    *((_DWORD *)this + 16) = v6;
    int v5 = *((_DWORD *)a2 + 18);
  }
  if ((v5 & 2) != 0)
  {
    uint64_t v4 = *((void *)a2 + 1);
    *((_DWORD *)this + 18) |= 2u;
    *((void *)this + 1) = v4;
    int v5 = *((_DWORD *)a2 + 18);
    if ((v5 & 4) == 0)
    {
LABEL_9:
      if ((v5 & 8) == 0) {
        goto LABEL_10;
      }
      goto LABEL_21;
    }
  }
  else if ((v5 & 4) == 0)
  {
    goto LABEL_9;
  }
  *((_DWORD *)this + 18) |= 4u;
  int v7 = (CLMicroLocationProto::WiFiRssi *)*((void *)this + 2);
  if (!v7) {
    operator new();
  }
  char v8 = (const CLMicroLocationProto::WiFiRssi *)*((void *)a2 + 2);
  if (!v8)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    char v8 = *(const CLMicroLocationProto::WiFiRssi **)(CLMicroLocationProto::Measurement::default_instance_ + 16);
  }
  CLMicroLocationProto::WiFiRssi::MergeFrom(v7, v8);
  int v5 = *((_DWORD *)a2 + 18);
  if ((v5 & 8) == 0)
  {
LABEL_10:
    if ((v5 & 0x10) == 0) {
      goto LABEL_11;
    }
    goto LABEL_26;
  }
LABEL_21:
  *((_DWORD *)this + 18) |= 8u;
  uint64_t v9 = (CLMicroLocationProto::WiFiRange *)*((void *)this + 3);
  if (!v9) {
    operator new();
  }
  unint64_t v10 = (const CLMicroLocationProto::WiFiRange *)*((void *)a2 + 3);
  if (!v10)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    unint64_t v10 = *(const CLMicroLocationProto::WiFiRange **)(CLMicroLocationProto::Measurement::default_instance_ + 24);
  }
  CLMicroLocationProto::WiFiRange::MergeFrom(v9, v10);
  int v5 = *((_DWORD *)a2 + 18);
  if ((v5 & 0x10) == 0)
  {
LABEL_11:
    if ((v5 & 0x20) == 0) {
      goto LABEL_12;
    }
LABEL_31:
    *((_DWORD *)this + 18) |= 0x20u;
    int v13 = (CLMicroLocationProto::HomeKitBluetoothRssi *)*((void *)this + 5);
    if (!v13) {
      operator new();
    }
    unint64_t v14 = (const CLMicroLocationProto::HomeKitBluetoothRssi *)*((void *)a2 + 5);
    if (!v14)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      unint64_t v14 = *(const CLMicroLocationProto::HomeKitBluetoothRssi **)(CLMicroLocationProto::Measurement::default_instance_
                                                                 + 40);
    }
    CLMicroLocationProto::HomeKitBluetoothRssi::MergeFrom(v13, v14);
    int v5 = *((_DWORD *)a2 + 18);
    if ((v5 & 0x40) == 0)
    {
LABEL_13:
      if ((v5 & 0x80) == 0) {
        return *(float *)&v4;
      }
      goto LABEL_41;
    }
    goto LABEL_36;
  }
LABEL_26:
  *((_DWORD *)this + 18) |= 0x10u;
  int v11 = (CLMicroLocationProto::ATVAirplayBluetoothRssi *)*((void *)this + 4);
  if (!v11) {
    operator new();
  }
  unint64_t v12 = (const CLMicroLocationProto::ATVAirplayBluetoothRssi *)*((void *)a2 + 4);
  if (!v12)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    unint64_t v12 = *(const CLMicroLocationProto::ATVAirplayBluetoothRssi **)(CLMicroLocationProto::Measurement::default_instance_
                                                                  + 32);
  }
  CLMicroLocationProto::ATVAirplayBluetoothRssi::MergeFrom(v11, v12);
  int v5 = *((_DWORD *)a2 + 18);
  if ((v5 & 0x20) != 0) {
    goto LABEL_31;
  }
LABEL_12:
  if ((v5 & 0x40) == 0) {
    goto LABEL_13;
  }
LABEL_36:
  *((_DWORD *)this + 18) |= 0x40u;
  int v15 = (CLMicroLocationProto::BleLeechedBeacons *)*((void *)this + 6);
  if (!v15) {
    operator new();
  }
  char v16 = (const CLMicroLocationProto::BleLeechedBeacons *)*((void *)a2 + 6);
  if (!v16)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    char v16 = *(const CLMicroLocationProto::BleLeechedBeacons **)(CLMicroLocationProto::Measurement::default_instance_ + 48);
  }
  CLMicroLocationProto::BleLeechedBeacons::MergeFrom(v15, v16);
  if ((*((_DWORD *)a2 + 18) & 0x80) != 0)
  {
LABEL_41:
    *((_DWORD *)this + 18) |= 0x80u;
    int v17 = (CLMicroLocationProto::UwbRange *)*((void *)this + 7);
    if (!v17) {
      operator new();
    }
    unsigned int v18 = (const CLMicroLocationProto::UwbRange *)*((void *)a2 + 7);
    if (!v18)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      unsigned int v18 = *(const CLMicroLocationProto::UwbRange **)(CLMicroLocationProto::Measurement::default_instance_ + 56);
    }
    *(float *)&uint64_t v4 = CLMicroLocationProto::UwbRange::MergeFrom(v17, v18);
  }
  return *(float *)&v4;
}

void sub_256411808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::Measurement::~Measurement(CLMicroLocationProto::Measurement *this)
{
  *(void *)this = &unk_2704DE038;
  CLMicroLocationProto::Measurement::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::Measurement::~Measurement(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::Measurement::SharedDtor(CLMicroLocationProto::Measurement *this)
{
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::Measurement *)CLMicroLocationProto::Measurement::default_instance_ != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = *((void *)this + 3);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = *((void *)this + 4);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = *((void *)this + 5);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = *((void *)this + 6);
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t v7 = *((void *)this + 7);
    if (v7)
    {
      char v8 = *(void (**)(void))(*(void *)v7 + 8);
      v8();
    }
  }
}

uint64_t CLMicroLocationProto::Measurement::default_instance(CLMicroLocationProto::Measurement *this)
{
  return CLMicroLocationProto::Measurement::default_instance_;
}

void CLMicroLocationProto::Measurement::New(CLMicroLocationProto::Measurement *this)
{
}

uint64_t CLMicroLocationProto::Measurement::Clear(uint64_t this)
{
  uint64_t v1 = this;
  LOBYTE(v2) = *(unsigned char *)(this + 72);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(this + 64) = 1;
    *(void *)(this + 8) = 0;
    if ((v2 & 4) != 0)
    {
      uint64_t v3 = *(void *)(this + 16);
      if (v3)
      {
        if (*(unsigned char *)(v3 + 40))
        {
          *(_DWORD *)(v3 + 16) = 1;
          *(void *)(v3 + 8) = 0;
          *(void *)(v3 + 28) = 0;
          *(void *)(v3 + 20) = 0;
        }
        *(_DWORD *)(v3 + 40) = 0;
        int v2 = *(_DWORD *)(this + 72);
      }
    }
    if ((v2 & 8) != 0)
    {
      this = *(void *)(this + 24);
      if (this)
      {
        this = CLMicroLocationProto::WiFiRange::Clear(this);
        int v2 = *(_DWORD *)(v1 + 72);
      }
    }
    if ((v2 & 0x10) != 0)
    {
      this = *(void *)(v1 + 32);
      if (this)
      {
        this = CLMicroLocationProto::ATVAirplayBluetoothRssi::Clear(this);
        int v2 = *(_DWORD *)(v1 + 72);
      }
    }
    if ((v2 & 0x20) != 0)
    {
      this = *(void *)(v1 + 40);
      if (this)
      {
        this = CLMicroLocationProto::HomeKitBluetoothRssi::Clear(this);
        int v2 = *(_DWORD *)(v1 + 72);
      }
    }
    if ((v2 & 0x40) != 0)
    {
      this = *(void *)(v1 + 48);
      if (this)
      {
        this = CLMicroLocationProto::BleLeechedBeacons::Clear(this);
        int v2 = *(_DWORD *)(v1 + 72);
      }
    }
    if ((v2 & 0x80) != 0)
    {
      this = *(void *)(v1 + 56);
      if (this) {
        this = CLMicroLocationProto::UwbRange::Clear(this);
      }
    }
  }
  *(_DWORD *)(v1 + 72) = 0;
  return this;
}

uint64_t CLMicroLocationProto::Measurement::MergePartialFromCodedStream(CLMicroLocationProto::Measurement *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    uint64_t v4 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v4 < *((void *)a2 + 2) && (*v4 & 0x80000000) == 0)
    {
      TagFallbacuint64_t k = *v4;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v4 + 1;
      if (!TagFallback) {
        return 1;
      }
      goto LABEL_6;
    }
    TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
    *((_DWORD *)a2 + 8) = TagFallback;
    if (!TagFallback) {
      return 1;
    }
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_25;
        }
        v55[0] = 0;
        uint64_t v7 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v7 >= *((void *)a2 + 2) || *v7 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v55);
          if (!result) {
            return result;
          }
          unsigned int v8 = v55[0];
        }
        else
        {
          unsigned int v8 = *v7;
          *((void *)a2 + 1) = v7 + 1;
        }
        if (v8 - 1 <= 5)
        {
          *((_DWORD *)this + 18) |= 1u;
          *((_DWORD *)this + 16) = v8;
        }
        int v11 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v11 < *((void *)a2 + 2) && *v11 == 17)
        {
          *((void *)a2 + 1) = v11 + 1;
          goto LABEL_35;
        }
        continue;
      case 2u:
        int v6 = TagFallback & 7;
        if (v6 != 1) {
          goto LABEL_25;
        }
LABEL_35:
        *(void *)std::string v55 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v55) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v55;
        }
        int v9 = *((_DWORD *)this + 18) | 2;
        *((_DWORD *)this + 18) = v9;
        unint64_t v12 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v12 >= *((void *)a2 + 2) || *v12 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v12 + 1;
LABEL_39:
        *((_DWORD *)this + 18) = v9 | 4;
        int v13 = (CLMicroLocationProto::WiFiRssi *)*((void *)this + 2);
        if (!v13) {
          operator new();
        }
        v55[0] = 0;
        unint64_t v14 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v55))return 0; {
        }
          }
        else
        {
          v55[0] = *v14;
          *((void *)a2 + 1) = v14 + 1;
        }
        int v15 = *((_DWORD *)a2 + 14);
        int v16 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v15 + 1;
        if (v15 >= v16) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::WiFiRssi::MergePartialFromCodedStream(v13, a2) || !*((unsigned char *)a2 + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v17 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v17, 1);
        int v19 = v17 - 1;
        if (v19 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v19;
        }
        unsigned int v20 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v20 >= *((void *)a2 + 2) || *v20 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v20 + 1;
LABEL_53:
        *((_DWORD *)this + 18) |= 8u;
        int v21 = (CLMicroLocationProto::WiFiRange *)*((void *)this + 3);
        if (!v21) {
          operator new();
        }
        v55[0] = 0;
        unsigned int v22 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v22 >= *((void *)a2 + 2) || *v22 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v55))return 0; {
        }
          }
        else
        {
          v55[0] = *v22;
          *((void *)a2 + 1) = v22 + 1;
        }
        int v23 = *((_DWORD *)a2 + 14);
        int v24 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v23 + 1;
        if (v23 >= v24) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::WiFiRange::MergePartialFromCodedStream(v21, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v25 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v25, 1);
        int v26 = v25 - 1;
        if (v26 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v26;
        }
        uint64_t v27 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v27 >= *((void *)a2 + 2) || *v27 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v27 + 1;
LABEL_67:
        *((_DWORD *)this + 18) |= 0x10u;
        BOOL v28 = (CLMicroLocationProto::ATVAirplayBluetoothRssi *)*((void *)this + 4);
        if (!v28) {
          operator new();
        }
        v55[0] = 0;
        id v29 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v29 >= *((void *)a2 + 2) || *v29 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v55))return 0; {
        }
          }
        else
        {
          v55[0] = *v29;
          *((void *)a2 + 1) = v29 + 1;
        }
        int v30 = *((_DWORD *)a2 + 14);
        int v31 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v30 + 1;
        if (v30 >= v31) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ATVAirplayBluetoothRssi::MergePartialFromCodedStream(v28, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v32 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v32, 1);
        int v33 = v32 - 1;
        if (v33 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v33;
        }
        BOOL v34 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v34 >= *((void *)a2 + 2) || *v34 != 50) {
          continue;
        }
        *((void *)a2 + 1) = v34 + 1;
LABEL_81:
        *((_DWORD *)this + 18) |= 0x20u;
        id v35 = (CLMicroLocationProto::HomeKitBluetoothRssi *)*((void *)this + 5);
        if (!v35) {
          operator new();
        }
        v55[0] = 0;
        std::string::size_type v36 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v36 >= *((void *)a2 + 2) || *v36 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v55))return 0; {
        }
          }
        else
        {
          v55[0] = *v36;
          *((void *)a2 + 1) = v36 + 1;
        }
        int v37 = *((_DWORD *)a2 + 14);
        int v38 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v37 + 1;
        if (v37 >= v38) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::HomeKitBluetoothRssi::MergePartialFromCodedStream(v35, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v39 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v39, 1);
        int v40 = v39 - 1;
        if (v40 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v40;
        }
        std::string v41 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v41 >= *((void *)a2 + 2) || *v41 != 58) {
          continue;
        }
        *((void *)a2 + 1) = v41 + 1;
LABEL_95:
        *((_DWORD *)this + 18) |= 0x40u;
        std::string v42 = (CLMicroLocationProto::BleLeechedBeacons *)*((void *)this + 6);
        if (!v42) {
          operator new();
        }
        v55[0] = 0;
        std::string v43 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v43 >= *((void *)a2 + 2) || *v43 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v55))return 0; {
        }
          }
        else
        {
          v55[0] = *v43;
          *((void *)a2 + 1) = v43 + 1;
        }
        int v44 = *((_DWORD *)a2 + 14);
        int v45 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v44 + 1;
        if (v44 >= v45) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::BleLeechedBeacons::MergePartialFromCodedStream(v42, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v46 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v46, 1);
        int v47 = v46 - 1;
        if (v47 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v47;
        }
        unsigned __int8 v48 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v48 >= *((void *)a2 + 2) || *v48 != 66) {
          continue;
        }
        *((void *)a2 + 1) = v48 + 1;
LABEL_109:
        *((_DWORD *)this + 18) |= 0x80u;
        unsigned __int8 v49 = (CLMicroLocationProto::UwbRange *)*((void *)this + 7);
        if (!v49) {
          operator new();
        }
        v55[0] = 0;
        int v50 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v50 >= *((void *)a2 + 2) || *v50 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v55))return 0; {
        }
          }
        else
        {
          v55[0] = *v50;
          *((void *)a2 + 1) = v50 + 1;
        }
        int v51 = *((_DWORD *)a2 + 14);
        int v52 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v51 + 1;
        if (v51 >= v52) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::UwbRange::MergePartialFromCodedStream(v49, a2) || !*((unsigned char *)a2 + 36)) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v53 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v53, 1);
        int v54 = v53 - 1;
        if (v54 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v54;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
        break;
      case 3u:
        int v6 = TagFallback & 7;
        if (v6 != 2) {
          goto LABEL_25;
        }
        int v9 = *((_DWORD *)this + 18);
        goto LABEL_39;
      case 4u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_53;
        }
        goto LABEL_25;
      case 5u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_67;
        }
        goto LABEL_25;
      case 6u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_81;
        }
        goto LABEL_25;
      case 7u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_95;
        }
        goto LABEL_25;
      case 8u:
        int v6 = TagFallback & 7;
        if (v6 != 2) {
          goto LABEL_25;
        }
        goto LABEL_109;
      default:
        int v6 = TagFallback & 7;
LABEL_25:
        if (v6 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

unsigned int *CLMicroLocationProto::Measurement::SerializeWithCachedSizes(unsigned int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  unsigned int v6 = this[18];
  if (v6)
  {
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[16], (uint64_t)a2, a4);
    unsigned int v6 = v5[18];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *((double *)v5 + 1), a3);
  unsigned int v6 = v5[18];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }
LABEL_12:
  uint64_t v7 = *((void *)v5 + 2);
  if (!v7)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v7 = *(void *)(CLMicroLocationProto::Measurement::default_instance_ + 16);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v7, a2, a4);
  unsigned int v6 = v5[18];
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_18;
  }
LABEL_15:
  uint64_t v8 = *((void *)v5 + 3);
  if (!v8)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v8 = *(void *)(CLMicroLocationProto::Measurement::default_instance_ + 24);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v8, a2, a4);
  unsigned int v6 = v5[18];
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_21;
  }
LABEL_18:
  uint64_t v9 = *((void *)v5 + 4);
  if (!v9)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v9 = *(void *)(CLMicroLocationProto::Measurement::default_instance_ + 32);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v9, a2, a4);
  unsigned int v6 = v5[18];
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_24;
  }
LABEL_21:
  uint64_t v10 = *((void *)v5 + 5);
  if (!v10)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v10 = *(void *)(CLMicroLocationProto::Measurement::default_instance_ + 40);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v10, a2, a4);
  unsigned int v6 = v5[18];
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      return this;
    }
    goto LABEL_27;
  }
LABEL_24:
  uint64_t v11 = *((void *)v5 + 6);
  if (!v11)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v11 = *(void *)(CLMicroLocationProto::Measurement::default_instance_ + 48);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v11, a2, a4);
  if ((v5[18] & 0x80) != 0)
  {
LABEL_27:
    uint64_t v12 = *((void *)v5 + 7);
    if (!v12)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
      uint64_t v12 = *(void *)(CLMicroLocationProto::Measurement::default_instance_ + 56);
    }
    return (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, v12, a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::Measurement::ByteSize(CLMicroLocationProto::Measurement *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 72);
  if (!(_BYTE)v2)
  {
    uint64_t v4 = 0;
    goto LABEL_57;
  }
  if (*((unsigned char *)this + 72))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 16);
    if ((v5 & 0x80000000) != 0)
    {
      int v6 = 10;
    }
    else if (v5 >= 0x80)
    {
      int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5);
      int v2 = *((_DWORD *)this + 18);
    }
    else
    {
      int v6 = 1;
    }
    unsigned int v3 = v6 + 1;
  }
  else
  {
    unsigned int v3 = 0;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = v3 + 9;
  }
  else {
    uint64_t v4 = v3;
  }
  if ((v2 & 4) != 0)
  {
    uint64_t v7 = (CLMicroLocationProto::WiFiRssi *)*((void *)this + 2);
    if (!v7)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      uint64_t v7 = *(CLMicroLocationProto::WiFiRssi **)(CLMicroLocationProto::Measurement::default_instance_ + 16);
    }
    uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::WiFiRssi::ByteSize(v7);
    int v9 = (int)v8;
    if (v8 >= 0x80) {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8);
    }
    else {
      int v10 = 1;
    }
    uint64_t v4 = (v4 + v9 + v10 + 1);
    int v2 = *((_DWORD *)this + 18);
    if ((v2 & 8) == 0)
    {
LABEL_16:
      if ((v2 & 0x10) == 0) {
        goto LABEL_17;
      }
      goto LABEL_33;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_16;
  }
  uint64_t v11 = (CLMicroLocationProto::WiFiRange *)*((void *)this + 3);
  if (!v11)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    uint64_t v11 = *(CLMicroLocationProto::WiFiRange **)(CLMicroLocationProto::Measurement::default_instance_ + 24);
  }
  uint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::WiFiRange::ByteSize(v11);
  int v13 = (int)v12;
  if (v12 >= 0x80) {
    int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12);
  }
  else {
    int v14 = 1;
  }
  uint64_t v4 = (v4 + v13 + v14 + 1);
  int v2 = *((_DWORD *)this + 18);
  if ((v2 & 0x10) == 0)
  {
LABEL_17:
    if ((v2 & 0x20) == 0) {
      goto LABEL_18;
    }
    goto LABEL_39;
  }
LABEL_33:
  int v15 = (CLMicroLocationProto::ATVAirplayBluetoothRssi *)*((void *)this + 4);
  if (!v15)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    int v15 = *(CLMicroLocationProto::ATVAirplayBluetoothRssi **)(CLMicroLocationProto::Measurement::default_instance_ + 32);
  }
  int v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::ATVAirplayBluetoothRssi::ByteSize(v15);
  int v17 = (int)v16;
  if (v16 >= 0x80) {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16);
  }
  else {
    int v18 = 1;
  }
  uint64_t v4 = (v4 + v17 + v18 + 1);
  int v2 = *((_DWORD *)this + 18);
  if ((v2 & 0x20) == 0)
  {
LABEL_18:
    if ((v2 & 0x40) == 0) {
      goto LABEL_19;
    }
    goto LABEL_45;
  }
LABEL_39:
  int v19 = (CLMicroLocationProto::HomeKitBluetoothRssi *)*((void *)this + 5);
  if (!v19)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    int v19 = *(CLMicroLocationProto::HomeKitBluetoothRssi **)(CLMicroLocationProto::Measurement::default_instance_ + 40);
  }
  unsigned int v20 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::HomeKitBluetoothRssi::ByteSize(v19);
  int v21 = (int)v20;
  if (v20 >= 0x80) {
    int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v20);
  }
  else {
    int v22 = 1;
  }
  uint64_t v4 = (v4 + v21 + v22 + 1);
  int v2 = *((_DWORD *)this + 18);
  if ((v2 & 0x40) == 0)
  {
LABEL_19:
    if ((v2 & 0x80) == 0) {
      goto LABEL_57;
    }
    goto LABEL_51;
  }
LABEL_45:
  int v23 = (CLMicroLocationProto::BleLeechedBeacons *)*((void *)this + 6);
  if (!v23)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    int v23 = *(CLMicroLocationProto::BleLeechedBeacons **)(CLMicroLocationProto::Measurement::default_instance_ + 48);
  }
  int v24 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::BleLeechedBeacons::ByteSize(v23);
  int v25 = (int)v24;
  if (v24 >= 0x80) {
    int v26 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v24);
  }
  else {
    int v26 = 1;
  }
  uint64_t v4 = (v4 + v25 + v26 + 1);
  if ((*((_DWORD *)this + 18) & 0x80) != 0)
  {
LABEL_51:
    uint64_t v27 = (CLMicroLocationProto::UwbRange *)*((void *)this + 7);
    if (!v27)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      uint64_t v27 = *(CLMicroLocationProto::UwbRange **)(CLMicroLocationProto::Measurement::default_instance_ + 56);
    }
    BOOL v28 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::UwbRange::ByteSize(v27);
    int v29 = (int)v28;
    if (v28 >= 0x80) {
      int v30 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v28);
    }
    else {
      int v30 = 1;
    }
    uint64_t v4 = (v4 + v29 + v30 + 1);
  }
LABEL_57:
  *((_DWORD *)this + 17) = v4;
  return v4;
}

float CLMicroLocationProto::Measurement::CheckTypeAndMergeFrom(CLMicroLocationProto::Measurement *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  return CLMicroLocationProto::Measurement::MergeFrom(this, lpsrc);
}

float CLMicroLocationProto::Measurement::CopyFrom(CLMicroLocationProto::Measurement *this, const CLMicroLocationProto::Measurement *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::Measurement *))(*(void *)this + 32))(this);
    return CLMicroLocationProto::Measurement::MergeFrom(this, a2);
  }
  return result;
}

uint64_t CLMicroLocationProto::Measurement::IsInitialized(CLMicroLocationProto::Measurement *this)
{
  return 1;
}

double CLMicroLocationProto::Measurement::Swap(CLMicroLocationProto::Measurement *this, CLMicroLocationProto::Measurement *a2)
{
  if (a2 != this)
  {
    int v2 = *((_DWORD *)this + 16);
    *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
    *((_DWORD *)a2 + 16) = v2;
    double result = *((double *)this + 1);
    *((void *)this + 1) = *((void *)a2 + 1);
    *((double *)a2 + 1) = result;
    uint64_t v4 = *((void *)this + 2);
    *((void *)this + 2) = *((void *)a2 + 2);
    *((void *)a2 + 2) = v4;
    uint64_t v5 = *((void *)this + 3);
    *((void *)this + 3) = *((void *)a2 + 3);
    *((void *)a2 + 3) = v5;
    uint64_t v6 = *((void *)this + 4);
    *((void *)this + 4) = *((void *)a2 + 4);
    *((void *)a2 + 4) = v6;
    uint64_t v7 = *((void *)this + 5);
    *((void *)this + 5) = *((void *)a2 + 5);
    *((void *)a2 + 5) = v7;
    uint64_t v8 = *((void *)this + 6);
    *((void *)this + 6) = *((void *)a2 + 6);
    *((void *)a2 + 6) = v8;
    uint64_t v9 = *((void *)this + 7);
    *((void *)this + 7) = *((void *)a2 + 7);
    *((void *)a2 + 7) = v9;
    LODWORD(v9) = *((_DWORD *)this + 18);
    *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
    *((_DWORD *)a2 + 18) = v9;
    LODWORD(v9) = *((_DWORD *)this + 17);
    *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
    *((_DWORD *)a2 + 17) = v9;
  }
  return result;
}

void *CLMicroLocationProto::Measurement::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.Measurement");
}

void CLMicroLocationProto::DeviceId::MergeFrom(CLMicroLocationProto::DeviceId *this, const CLMicroLocationProto::DeviceId *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 28);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 28))
    {
      uint64_t v5 = *((void *)a2 + 1);
      *((_DWORD *)this + 7) |= 1u;
      *((void *)this + 1) = v5;
      int v4 = *((_DWORD *)a2 + 7);
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v6 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 7) |= 2u;
      uint64_t v7 = (std::string *)*((void *)this + 2);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
    }
  }
}

void sub_256412AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::DeviceId::~DeviceId(CLMicroLocationProto::DeviceId *this)
{
  *(void *)this = &unk_2704DE0B0;
  CLMicroLocationProto::DeviceId::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::DeviceId::~DeviceId(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::DeviceId::SharedDtor(CLMicroLocationProto::DeviceId *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (v1 != MEMORY[0x263F8C740] && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    this = (CLMicroLocationProto::DeviceId *)MEMORY[0x25A2A6340](v1, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::DeviceId::New(CLMicroLocationProto::DeviceId *this)
{
}

uint64_t CLMicroLocationProto::DeviceId::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 28);
  if (v1)
  {
    *(void *)(this + 8) = 0;
    if ((v1 & 2) != 0)
    {
      uint64_t v2 = *(void *)(this + 16);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 28) = 0;
  return this;
}

uint64_t CLMicroLocationProto::DeviceId::MergePartialFromCodedStream(CLMicroLocationProto::DeviceId *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  int v4 = (unint64_t *)((char *)this + 8);
  uint64_t v5 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v6;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v6 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_16;
        }
        uint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v4);
          if (!result) {
            return result;
          }
          uint64_t v12 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          *int v4 = *v11;
          uint64_t v12 = v11 + 1;
          *((void *)a2 + 1) = v12;
        }
        int v9 = *((_DWORD *)this + 7) | 1;
        *((_DWORD *)this + 7) = v9;
        if ((unint64_t)v12 < v10 && *v12 == 18)
        {
          *((void *)a2 + 1) = v12 + 1;
          goto LABEL_24;
        }
      }
      if (TagFallback >> 3 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_16;
      }
      int v9 = *((_DWORD *)this + 7);
LABEL_24:
      *((_DWORD *)this + 7) = v9 | 2;
      if (*((void *)this + 2) == v5) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
      if (!result) {
        return result;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    int v8 = TagFallback & 7;
LABEL_16:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::DeviceId::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 28);
  if (v5)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(this + 8), (uint64_t)a2, a4);
    int v5 = *(_DWORD *)(v4 + 28);
  }
  if ((v5 & 2) != 0)
  {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  }
  return this;
}

uint64_t CLMicroLocationProto::DeviceId::ByteSize(wireless_diagnostics::google::protobuf::io::CodedOutputStream **this)
{
  if (*((unsigned char *)this + 28))
  {
    if (*((unsigned char *)this + 28))
    {
      uint64_t v2 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(this[1]) + 1;
      if ((*((_DWORD *)this + 7) & 2) == 0) {
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v2 = 0;
      if ((*((unsigned char *)this + 28) & 2) == 0) {
        goto LABEL_16;
      }
    }
    unsigned int v3 = this[2];
    int v4 = *((unsigned __int8 *)v3 + 23);
    char v5 = v4;
    uint64_t v6 = *((void *)v3 + 1);
    if ((v4 & 0x80u) == 0) {
      unint64_t v7 = *((unsigned __int8 *)v3 + 23);
    }
    else {
      unint64_t v7 = v6;
    }
    if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v7);
      int v4 = *((unsigned __int8 *)v3 + 23);
      uint64_t v6 = *((void *)v3 + 1);
      char v5 = *((unsigned char *)v3 + 23);
    }
    else
    {
      int v8 = 1;
    }
    if (v5 < 0) {
      int v4 = v6;
    }
    uint64_t v2 = (v2 + v8 + v4 + 1);
  }
  else
  {
    uint64_t v2 = 0;
  }
LABEL_16:
  *((_DWORD *)this + 6) = v2;
  return v2;
}

void CLMicroLocationProto::DeviceId::CheckTypeAndMergeFrom(CLMicroLocationProto::DeviceId *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::DeviceId::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::DeviceId::IsInitialized(CLMicroLocationProto::DeviceId *this)
{
  return 1;
}

void *CLMicroLocationProto::DeviceId::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.DeviceId");
}

void CLMicroLocationProto::FingerprintMeasurement::MergeFrom(CLMicroLocationProto::FingerprintMeasurement *this, const CLMicroLocationProto::FingerprintMeasurement *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 36);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 36))
    {
      uint64_t v5 = *((void *)a2 + 1);
      *((_DWORD *)this + 9) |= 1u;
      *((void *)this + 1) = v5;
      int v4 = *((_DWORD *)a2 + 9);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *((_DWORD *)a2 + 4);
      if ((v6 - 1) >= 6) {
        CLMicroLocationProto::FingerprintMeasurement::MergeFrom();
      }
      *((_DWORD *)this + 9) |= 2u;
      *((_DWORD *)this + 4) = v6;
      int v4 = *((_DWORD *)a2 + 9);
    }
    if ((v4 & 4) != 0)
    {
      int v7 = *((_DWORD *)a2 + 5);
      *((_DWORD *)this + 9) |= 4u;
      *((_DWORD *)this + 5) = v7;
      int v4 = *((_DWORD *)a2 + 9);
    }
    if ((v4 & 8) != 0)
    {
      *((_DWORD *)this + 9) |= 8u;
      int v8 = (CLMicroLocationProto::DeviceId *)*((void *)this + 3);
      if (!v8) {
        operator new();
      }
      int v9 = (const CLMicroLocationProto::DeviceId *)*((void *)a2 + 3);
      if (!v9)
      {
        CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
        int v9 = *(const CLMicroLocationProto::DeviceId **)(CLMicroLocationProto::FingerprintMeasurement::default_instance_
                                                      + 24);
      }
      CLMicroLocationProto::DeviceId::MergeFrom(v8, v9);
    }
  }
}

void sub_256413164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::FingerprintMeasurement::~FingerprintMeasurement(CLMicroLocationProto::FingerprintMeasurement *this)
{
  *(void *)this = &unk_2704DE128;
  CLMicroLocationProto::FingerprintMeasurement::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::FingerprintMeasurement::~FingerprintMeasurement(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::FingerprintMeasurement::SharedDtor(CLMicroLocationProto::FingerprintMeasurement *this)
{
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::FingerprintMeasurement *)CLMicroLocationProto::FingerprintMeasurement::default_instance_ != this)
  {
    uint64_t v2 = *((void *)this + 3);
    if (v2)
    {
      unsigned int v3 = *(void (**)(void))(*(void *)v2 + 8);
      v3();
    }
  }
}

uint64_t CLMicroLocationProto::FingerprintMeasurement::default_instance(CLMicroLocationProto::FingerprintMeasurement *this)
{
  return CLMicroLocationProto::FingerprintMeasurement::default_instance_;
}

void CLMicroLocationProto::FingerprintMeasurement::New(CLMicroLocationProto::FingerprintMeasurement *this)
{
}

uint64_t CLMicroLocationProto::FingerprintMeasurement::Clear(uint64_t this)
{
  uint64_t v1 = this;
  char v2 = *(unsigned char *)(this + 36);
  if (v2)
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 1;
    if ((v2 & 8) != 0)
    {
      this = *(void *)(this + 24);
      if (this) {
        this = CLMicroLocationProto::DeviceId::Clear(this);
      }
    }
  }
  *(_DWORD *)(v1 + 36) = 0;
  return this;
}

uint64_t CLMicroLocationProto::FingerprintMeasurement::MergePartialFromCodedStream(CLMicroLocationProto::FingerprintMeasurement *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (2)
  {
    int v4 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v4;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v4 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v6 = TagFallback & 7;
        if (v6 != 1) {
          goto LABEL_22;
        }
        *(void *)int v22 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v22) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v22;
        }
        *((_DWORD *)this + 9) |= 1u;
        int v8 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v7 = *((void *)a2 + 2);
        if ((unint64_t)v8 >= v7 || *v8 != 16) {
          continue;
        }
        int v9 = v8 + 1;
        *((void *)a2 + 1) = v9;
        goto LABEL_15;
      case 2u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        int v9 = (char *)*((void *)a2 + 1);
        unint64_t v7 = *((void *)a2 + 2);
LABEL_15:
        v22[0] = 0;
        if ((unint64_t)v9 >= v7 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v22);
          if (!result) {
            return result;
          }
          unsigned int v10 = v22[0];
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 - 1 <= 5)
        {
          *((_DWORD *)this + 9) |= 2u;
          *((_DWORD *)this + 4) = v10;
        }
        int v13 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v13 >= *((void *)a2 + 2) || *v13 != 29) {
          continue;
        }
        *((void *)a2 + 1) = v13 + 1;
LABEL_32:
        v22[0] = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, v22) & 1) == 0) {
          return 0;
        }
        *((_DWORD *)this + 5) = v22[0];
        int v11 = *((_DWORD *)this + 9) | 4;
        *((_DWORD *)this + 9) = v11;
        int v14 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v14 + 1;
LABEL_36:
        *((_DWORD *)this + 9) = v11 | 8;
        int v15 = (CLMicroLocationProto::DeviceId *)*((void *)this + 3);
        if (!v15) {
          operator new();
        }
        v22[0] = 0;
        int v16 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v16 >= *((void *)a2 + 2) || *v16 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v22))return 0; {
        }
          }
        else
        {
          v22[0] = *v16;
          *((void *)a2 + 1) = v16 + 1;
        }
        int v17 = *((_DWORD *)a2 + 14);
        int v18 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v17 + 1;
        if (v17 < v18)
        {
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (CLMicroLocationProto::DeviceId::MergePartialFromCodedStream(v15, a2))
          {
            if (*((unsigned char *)a2 + 36))
            {
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
              int v19 = *((_DWORD *)a2 + 14);
              BOOL v20 = __OFSUB__(v19, 1);
              int v21 = v19 - 1;
              if (v21 < 0 == v20) {
                *((_DWORD *)a2 + 14) = v21;
              }
              if (*((void *)a2 + 1) == *((void *)a2 + 2)
                && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
              {
                *((_DWORD *)a2 + 8) = 0;
                uint64_t result = 1;
                *((unsigned char *)a2 + 36) = 1;
                return result;
              }
              continue;
            }
          }
        }
        return 0;
      case 3u:
        int v6 = TagFallback & 7;
        if (v6 == 5) {
          goto LABEL_32;
        }
        goto LABEL_22;
      case 4u:
        int v6 = TagFallback & 7;
        if (v6 != 2) {
          goto LABEL_22;
        }
        int v11 = *((_DWORD *)this + 9);
        goto LABEL_36;
      default:
        int v6 = TagFallback & 7;
LABEL_22:
        if (v6 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t CLMicroLocationProto::FingerprintMeasurement::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 36);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, (uint64_t)a2, *(double *)(this + 8), a3);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *(float *)(v5 + 20), a3);
      if ((*(_DWORD *)(v5 + 36) & 8) == 0) {
        return this;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned int *)(v5 + 16), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return this;
  }
LABEL_9:
  uint64_t v7 = *(void *)(v5 + 24);
  if (!v7)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v7 = *(void *)(CLMicroLocationProto::FingerprintMeasurement::default_instance_ + 24);
  }
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
}

uint64_t CLMicroLocationProto::FingerprintMeasurement::ByteSize(CLMicroLocationProto::FingerprintMeasurement *this)
{
  int v2 = *((unsigned __int8 *)this + 36);
  if (*((unsigned char *)this + 36))
  {
    LODWORD(v3) = (v2 << 31 >> 31) & 9;
    if ((v2 & 2) != 0)
    {
      int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
      if ((v4 & 0x80000000) != 0)
      {
        int v5 = 11;
      }
      else if (v4 >= 0x80)
      {
        int v5 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
        int v2 = *((_DWORD *)this + 9);
      }
      else
      {
        int v5 = 2;
      }
      LODWORD(v3) = v5 + v3;
    }
    if ((v2 & 4) != 0) {
      uint64_t v3 = (v3 + 5);
    }
    else {
      uint64_t v3 = v3;
    }
    if ((v2 & 8) != 0)
    {
      int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream **)*((void *)this + 3);
      if (!v6)
      {
        CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
        int v6 = *(wireless_diagnostics::google::protobuf::io::CodedOutputStream ***)(CLMicroLocationProto::FingerprintMeasurement::default_instance_
                                                                                + 24);
      }
      uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::DeviceId::ByteSize(v6);
      int v8 = (int)v7;
      if (v7 >= 0x80) {
        int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7);
      }
      else {
        int v9 = 1;
      }
      uint64_t v3 = (v3 + v8 + v9 + 1);
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  *((_DWORD *)this + 8) = v3;
  return v3;
}

void CLMicroLocationProto::FingerprintMeasurement::CheckTypeAndMergeFrom(CLMicroLocationProto::FingerprintMeasurement *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::FingerprintMeasurement::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::FingerprintMeasurement::CopyFrom(CLMicroLocationProto::FingerprintMeasurement *this, const CLMicroLocationProto::FingerprintMeasurement *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::FingerprintMeasurement *))(*(void *)this + 32))(this);
    CLMicroLocationProto::FingerprintMeasurement::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::FingerprintMeasurement::IsInitialized(CLMicroLocationProto::FingerprintMeasurement *this)
{
  return 1;
}

void *CLMicroLocationProto::FingerprintMeasurement::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.FingerprintMeasurement");
}

void CLMicroLocationProto::Fingerprint::MergeFrom(CLMicroLocationProto::Fingerprint *this, const CLMicroLocationProto::Fingerprint *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v20);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::Fingerprint *)((char *)this + 8));
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      int v5 = *(const CLMicroLocationProto::Measurement **)(*((void *)a2 + 1) + 8 * v4);
      int v6 = *((_DWORD *)this + 5);
      uint64_t v7 = *((int *)this + 4);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 6))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::Fingerprint *)((char *)this + 8));
          int v6 = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)this + 1);
      *((_DWORD *)this + 4) = v7 + 1;
      CLMicroLocationProto::Measurement::MergeFrom(*(CLMicroLocationProto::Measurement **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 4));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::MergeFrom<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::FingerprintMeasurement>::TypeHandler>((int *)this + 18, (uint64_t)a2 + 72);
  int v9 = *((_DWORD *)a2 + 26);
  if ((v9 & 0x1FE) == 0) {
    goto LABEL_20;
  }
  if ((v9 & 2) == 0)
  {
    if ((v9 & 4) == 0) {
      goto LABEL_14;
    }
LABEL_24:
    uint64_t v15 = *((void *)a2 + 5);
    *((_DWORD *)this + 26) |= 4u;
    *((void *)this + 5) = v15;
    int v9 = *((_DWORD *)a2 + 26);
    if ((v9 & 8) == 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v14 = *((void *)a2 + 4);
  *((_DWORD *)this + 26) |= 2u;
  *((void *)this + 4) = v14;
  int v9 = *((_DWORD *)a2 + 26);
  if ((v9 & 4) != 0) {
    goto LABEL_24;
  }
LABEL_14:
  if ((v9 & 8) != 0)
  {
LABEL_15:
    uint64_t v10 = *((void *)a2 + 6);
    *((_DWORD *)this + 26) |= 8u;
    *((void *)this + 6) = v10;
    int v9 = *((_DWORD *)a2 + 26);
  }
LABEL_16:
  int v11 = (std::string *)MEMORY[0x263F8C740];
  if ((v9 & 0x10) != 0)
  {
    int v16 = (const std::string *)*((void *)a2 + 7);
    *((_DWORD *)this + 26) |= 0x10u;
    int v17 = (std::string *)*((void *)this + 7);
    if (v17 == v11) {
      operator new();
    }
    std::string::operator=(v17, v16);
    int v9 = *((_DWORD *)a2 + 26);
    if ((v9 & 0x20) == 0)
    {
LABEL_18:
      if ((v9 & 0x80) == 0) {
        goto LABEL_20;
      }
      goto LABEL_19;
    }
  }
  else if ((v9 & 0x20) == 0)
  {
    goto LABEL_18;
  }
  int v18 = (const std::string *)*((void *)a2 + 8);
  *((_DWORD *)this + 26) |= 0x20u;
  int v19 = (std::string *)*((void *)this + 8);
  if (v19 == v11) {
    operator new();
  }
  std::string::operator=(v19, v18);
  int v9 = *((_DWORD *)a2 + 26);
  if ((v9 & 0x80) != 0)
  {
LABEL_19:
    char v12 = *((unsigned char *)a2 + 96);
    *((_DWORD *)this + 26) |= 0x80u;
    *((unsigned char *)this + 96) = v12;
    int v9 = *((_DWORD *)a2 + 26);
  }
LABEL_20:
  if ((v9 & 0x100) != 0)
  {
    char v13 = *((unsigned char *)a2 + 97);
    *((_DWORD *)this + 26) |= 0x100u;
    *((unsigned char *)this + 97) = v13;
  }
}

void sub_256413C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::Fingerprint::~Fingerprint(CLMicroLocationProto::Fingerprint *this)
{
  *(void *)this = &unk_2704DE1A0;
  CLMicroLocationProto::Fingerprint::SharedDtor(this);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 9);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::Fingerprint::~Fingerprint(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::Fingerprint::SharedDtor(CLMicroLocationProto::Fingerprint *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 7);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::Fingerprint *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 8);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::Fingerprint *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::Fingerprint::New(CLMicroLocationProto::Fingerprint *this)
{
}

uint64_t CLMicroLocationProto::Fingerprint::Clear(CLMicroLocationProto::Fingerprint *this)
{
  int v2 = *((_DWORD *)this + 26);
  if ((v2 & 0x1FE) != 0)
  {
    *((void *)this + 4) = 0;
    *((void *)this + 5) = 0;
    *((void *)this + 6) = 0;
    uint64_t v3 = MEMORY[0x263F8C740];
    if ((v2 & 0x10) != 0)
    {
      uint64_t v4 = *((void *)this + 7);
      if (v4 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*((unsigned char *)this + 104) & 0x20) != 0)
    {
      uint64_t v5 = *((void *)this + 8);
      if (v5 != v3)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    *((unsigned char *)this + 96) = 0;
    int v2 = *((_DWORD *)this + 26);
  }
  if ((v2 & 0xFF00) != 0) {
    *((unsigned char *)this + 97) = 0;
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 8);
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 72);
  *((_DWORD *)this + 26) = 0;
  return result;
}

uint64_t CLMicroLocationProto::Fingerprint::MergePartialFromCodedStream(CLMicroLocationProto::Fingerprint *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (CLMicroLocationProto::Fingerprint *)((char *)this + 8);
  uint64_t v5 = (unint64_t *)((char *)this + 32);
  int v6 = (CLMicroLocationProto::Fingerprint *)((char *)this + 72);
  uint64_t v7 = MEMORY[0x263F8C740];
  while (1)
  {
LABEL_2:
    uint64_t v8 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v8 < *((void *)a2 + 2) && (*v8 & 0x80000000) == 0)
    {
      TagFallbacuint64_t k = *v8;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v8 + 1;
      if (!TagFallback) {
        return 1;
      }
      goto LABEL_7;
    }
    TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
    *((_DWORD *)a2 + 8) = TagFallback;
    if (!TagFallback) {
      return 1;
    }
LABEL_7:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_45;
        }
        while (1)
        {
          int v11 = *((_DWORD *)this + 5);
          uint64_t v12 = *((int *)this + 4);
          if ((int)v12 >= v11)
          {
            if (v11 == *((_DWORD *)this + 6))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v4);
              int v11 = *((_DWORD *)this + 5);
            }
            *((_DWORD *)this + 5) = v11 + 1;
            operator new();
          }
          uint64_t v13 = *((void *)this + 1);
          *((_DWORD *)this + 4) = v12 + 1;
          uint64_t v14 = *(CLMicroLocationProto::Measurement **)(v13 + 8 * v12);
          v49[0] = 0;
          uint64_t v15 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v15 >= *((void *)a2 + 2) || *v15 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v49))return 0; {
          }
            }
          else
          {
            v49[0] = *v15;
            *((void *)a2 + 1) = v15 + 1;
          }
          int v16 = *((_DWORD *)a2 + 14);
          int v17 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v16 + 1;
          if (v16 >= v17) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (!CLMicroLocationProto::Measurement::MergePartialFromCodedStream(v14, a2)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
          int v18 = *((_DWORD *)a2 + 14);
          BOOL v19 = __OFSUB__(v18, 1);
          int v20 = v18 - 1;
          if (v20 < 0 == v19) {
            *((_DWORD *)a2 + 14) = v20;
          }
          int v22 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v21 = *((void *)a2 + 2);
          if ((unint64_t)v22 >= v21) {
            goto LABEL_2;
          }
          int v23 = *v22;
          if (v23 != 10) {
            break;
          }
          *((void *)a2 + 1) = v22 + 1;
        }
        if (v23 != 16) {
          continue;
        }
        int v24 = (char *)(v22 + 1);
        *((void *)a2 + 1) = v24;
        goto LABEL_29;
      case 2u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_45;
        }
        int v24 = (char *)*((void *)a2 + 1);
        unint64_t v21 = *((void *)a2 + 2);
LABEL_29:
        if ((unint64_t)v24 >= v21 || *v24 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v5);
          if (!result) {
            return result;
          }
          int v25 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v21 = *((void *)a2 + 2);
        }
        else
        {
          unint64_t *v5 = *v24;
          int v25 = v24 + 1;
          *((void *)a2 + 1) = v25;
        }
        *((_DWORD *)this + 26) |= 2u;
        if ((unint64_t)v25 >= v21 || *v25 != 25) {
          continue;
        }
        *((void *)a2 + 1) = v25 + 1;
LABEL_56:
        *(void *)unsigned __int8 v49 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v49) & 1) == 0)return 0; {
        *((void *)this + 5) = *(void *)v49;
        }
        *((_DWORD *)this + 26) |= 4u;
        int v31 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v31 >= *((void *)a2 + 2) || *v31 != 33) {
          continue;
        }
        *((void *)a2 + 1) = v31 + 1;
LABEL_60:
        *(void *)unsigned __int8 v49 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v49) & 1) == 0)return 0; {
        *((void *)this + 6) = *(void *)v49;
        }
        int v26 = *((_DWORD *)this + 26) | 8;
        *((_DWORD *)this + 26) = v26;
        int v32 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v32 < *((void *)a2 + 2) && *v32 == 42)
        {
          *((void *)a2 + 1) = v32 + 1;
LABEL_64:
          *((_DWORD *)this + 26) = v26 | 0x10;
          if (*((void *)this + 7) == v7) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!result) {
            return result;
          }
          int v33 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v33 < *((void *)a2 + 2) && *v33 == 50)
          {
            *((void *)a2 + 1) = v33 + 1;
LABEL_70:
            *((_DWORD *)this + 26) |= 0x20u;
            if (*((void *)this + 8) == v7) {
              operator new();
            }
            uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
            if (!result) {
              return result;
            }
            BOOL v34 = (unsigned char *)*((void *)a2 + 1);
            if ((unint64_t)v34 < *((void *)a2 + 2) && *v34 == 58)
            {
              do
              {
                *((void *)a2 + 1) = v34 + 1;
LABEL_76:
                int v35 = *((_DWORD *)this + 21);
                uint64_t v36 = *((int *)this + 20);
                if ((int)v36 >= v35)
                {
                  if (v35 == *((_DWORD *)this + 22))
                  {
                    wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v6);
                    int v35 = *((_DWORD *)this + 21);
                  }
                  *((_DWORD *)this + 21) = v35 + 1;
                  operator new();
                }
                uint64_t v37 = *((void *)this + 9);
                *((_DWORD *)this + 20) = v36 + 1;
                int v38 = *(CLMicroLocationProto::FingerprintMeasurement **)(v37 + 8 * v36);
                v49[0] = 0;
                int v39 = (char *)*((void *)a2 + 1);
                if ((unint64_t)v39 >= *((void *)a2 + 2) || *v39 < 0)
                {
                  if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v49))return 0; {
                }
                  }
                else
                {
                  v49[0] = *v39;
                  *((void *)a2 + 1) = v39 + 1;
                }
                int v40 = *((_DWORD *)a2 + 14);
                int v41 = *((_DWORD *)a2 + 15);
                *((_DWORD *)a2 + 14) = v40 + 1;
                if (v40 >= v41) {
                  return 0;
                }
                wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
                if (!CLMicroLocationProto::FingerprintMeasurement::MergePartialFromCodedStream(v38, a2)
                  || !*((unsigned char *)a2 + 36))
                {
                  return 0;
                }
                wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
                int v42 = *((_DWORD *)a2 + 14);
                BOOL v19 = __OFSUB__(v42, 1);
                int v43 = v42 - 1;
                if (v43 < 0 == v19) {
                  *((_DWORD *)a2 + 14) = v43;
                }
                BOOL v34 = (unsigned char *)*((void *)a2 + 1);
                unint64_t v27 = *((void *)a2 + 2);
                if ((unint64_t)v34 >= v27) {
                  goto LABEL_2;
                }
                int v44 = *v34;
              }
              while (v44 == 58);
              if (v44 == 64)
              {
                BOOL v28 = v34 + 1;
                *((void *)a2 + 1) = v28;
LABEL_94:
                v49[0] = 0;
                if ((unint64_t)v28 >= v27 || *v28 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v49);
                  if (!result) {
                    return result;
                  }
                  unsigned int v45 = v49[0];
                  int v46 = (unsigned char *)*((void *)a2 + 1);
                  unint64_t v27 = *((void *)a2 + 2);
                }
                else
                {
                  unsigned int v45 = *v28;
                  int v46 = v28 + 1;
                  *((void *)a2 + 1) = v46;
                }
                *((unsigned char *)this + 96) = v45 != 0;
                *((_DWORD *)this + 26) |= 0x80u;
                if ((unint64_t)v46 < v27 && *v46 == 72)
                {
                  int v29 = v46 + 1;
                  *((void *)a2 + 1) = v29;
LABEL_102:
                  v49[0] = 0;
                  if ((unint64_t)v29 >= v27 || *v29 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v49);
                    if (!result) {
                      return result;
                    }
                    unsigned int v47 = v49[0];
                    unsigned __int8 v48 = (unsigned __int8 *)*((void *)a2 + 1);
                    unint64_t v27 = *((void *)a2 + 2);
                  }
                  else
                  {
                    unsigned int v47 = *v29;
                    unsigned __int8 v48 = (unsigned __int8 *)(v29 + 1);
                    *((void *)a2 + 1) = v48;
                  }
                  *((unsigned char *)this + 97) = v47 != 0;
                  *((_DWORD *)this + 26) |= 0x100u;
                  if (v48 == (unsigned __int8 *)v27
                    && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                  {
                    *((_DWORD *)a2 + 8) = 0;
                    uint64_t result = 1;
                    *((unsigned char *)a2 + 36) = 1;
                    return result;
                  }
                }
              }
            }
          }
        }
        break;
      case 3u:
        int v10 = TagFallback & 7;
        if (v10 == 1) {
          goto LABEL_56;
        }
        goto LABEL_45;
      case 4u:
        int v10 = TagFallback & 7;
        if (v10 == 1) {
          goto LABEL_60;
        }
        goto LABEL_45;
      case 5u:
        int v10 = TagFallback & 7;
        if (v10 != 2) {
          goto LABEL_45;
        }
        int v26 = *((_DWORD *)this + 26);
        goto LABEL_64;
      case 6u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_70;
        }
        goto LABEL_45;
      case 7u:
        int v10 = TagFallback & 7;
        if (v10 == 2) {
          goto LABEL_76;
        }
        goto LABEL_45;
      case 8u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_45;
        }
        BOOL v28 = (char *)*((void *)a2 + 1);
        unint64_t v27 = *((void *)a2 + 2);
        goto LABEL_94;
      case 9u:
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_45;
        }
        int v29 = (char *)*((void *)a2 + 1);
        unint64_t v27 = *((void *)a2 + 2);
        goto LABEL_102;
      default:
        int v10 = TagFallback & 7;
LABEL_45:
        if (v10 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

uint64_t CLMicroLocationProto::Fingerprint::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  if (*(int *)(this + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  int v7 = *(_DWORD *)(v5 + 104);
  if ((v7 & 2) != 0)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(v5 + 32), (uint64_t)a2, a4);
    int v7 = *(_DWORD *)(v5 + 104);
    if ((v7 & 4) == 0)
    {
LABEL_6:
      if ((v7 & 8) == 0) {
        goto LABEL_7;
      }
      goto LABEL_19;
    }
  }
  else if ((v7 & 4) == 0)
  {
    goto LABEL_6;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *(double *)(v5 + 40), a3);
  int v7 = *(_DWORD *)(v5 + 104);
  if ((v7 & 8) == 0)
  {
LABEL_7:
    if ((v7 & 0x10) == 0) {
      goto LABEL_8;
    }
    goto LABEL_20;
  }
LABEL_19:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, (uint64_t)a2, *(double *)(v5 + 48), a3);
  int v7 = *(_DWORD *)(v5 + 104);
  if ((v7 & 0x10) == 0)
  {
LABEL_8:
    if ((v7 & 0x20) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_20:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  if ((*(_DWORD *)(v5 + 104) & 0x20) != 0) {
LABEL_9:
  }
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
LABEL_10:
  if (*(int *)(v5 + 80) >= 1)
  {
    uint64_t v8 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(void *)(*(void *)(v5 + 72) + 8 * v8++), a2, a4);
    while (v8 < *(int *)(v5 + 80));
  }
  int v9 = *(_DWORD *)(v5 + 104);
  if ((v9 & 0x80) != 0)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *(unsigned __int8 *)(v5 + 96), (uint64_t)a2, a4);
    int v9 = *(_DWORD *)(v5 + 104);
  }
  if ((v9 & 0x100) != 0)
  {
    uint64_t v10 = *(unsigned __int8 *)(v5 + 97);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v10, (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::Fingerprint::ByteSize(CLMicroLocationProto::Fingerprint *this)
{
  int v2 = *((_DWORD *)this + 26);
  if ((v2 & 0x1FE) != 0)
  {
    if ((v2 & 2) != 0)
    {
      int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this
                                                                                       + 4))
         + 1;
      int v2 = *((_DWORD *)this + 26);
    }
    else
    {
      int v3 = 0;
    }
    if ((v2 & 4) != 0) {
      v3 += 9;
    }
    if ((v2 & 8) != 0) {
      int v5 = v3 + 9;
    }
    else {
      int v5 = v3;
    }
    if ((v2 & 0x10) != 0)
    {
      uint64_t v6 = *((void *)this + 7);
      int v7 = *(unsigned __int8 *)(v6 + 23);
      char v8 = v7;
      uint64_t v9 = *(void *)(v6 + 8);
      if ((v7 & 0x80u) == 0) {
        unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
      }
      else {
        unint64_t v10 = v9;
      }
      if (v10 >= 0x80)
      {
        int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10);
        int v7 = *(unsigned __int8 *)(v6 + 23);
        uint64_t v9 = *(void *)(v6 + 8);
        int v2 = *((_DWORD *)this + 26);
        char v8 = *(unsigned char *)(v6 + 23);
      }
      else
      {
        int v11 = 1;
      }
      if (v8 < 0) {
        int v7 = v9;
      }
      v5 += v11 + v7 + 1;
    }
    if ((v2 & 0x20) != 0)
    {
      uint64_t v12 = *((void *)this + 8);
      int v13 = *(unsigned __int8 *)(v12 + 23);
      char v14 = v13;
      uint64_t v15 = *(void *)(v12 + 8);
      if ((v13 & 0x80u) == 0) {
        unint64_t v16 = *(unsigned __int8 *)(v12 + 23);
      }
      else {
        unint64_t v16 = v15;
      }
      if (v16 >= 0x80)
      {
        int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16);
        int v13 = *(unsigned __int8 *)(v12 + 23);
        uint64_t v15 = *(void *)(v12 + 8);
        int v2 = *((_DWORD *)this + 26);
        char v14 = *(unsigned char *)(v12 + 23);
      }
      else
      {
        int v17 = 1;
      }
      if (v14 < 0) {
        int v13 = v15;
      }
      v5 += v17 + v13 + 1;
    }
    int v4 = v5 + 2;
    if ((v2 & 0x80) == 0) {
      int v4 = v5;
    }
  }
  else
  {
    int v4 = 0;
  }
  if ((v2 & 0x100) != 0) {
    int v18 = v4 + 2;
  }
  else {
    int v18 = v4;
  }
  int v19 = *((_DWORD *)this + 4);
  int v20 = v18 + v19;
  if (v19 >= 1)
  {
    uint64_t v21 = 0;
    do
    {
      int v22 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::Measurement::ByteSize(*(CLMicroLocationProto::Measurement **)(*((void *)this + 1) + 8 * v21));
      int v23 = (int)v22;
      if (v22 >= 0x80) {
        int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v22);
      }
      else {
        int v24 = 1;
      }
      v20 += v23 + v24;
      ++v21;
    }
    while (v21 < *((int *)this + 4));
  }
  int v25 = *((_DWORD *)this + 20);
  uint64_t v26 = (v25 + v20);
  if (v25 >= 1)
  {
    uint64_t v27 = 0;
    do
    {
      BOOL v28 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::FingerprintMeasurement::ByteSize(*(CLMicroLocationProto::FingerprintMeasurement **)(*((void *)this + 9) + 8 * v27));
      int v29 = (int)v28;
      if (v28 >= 0x80) {
        int v30 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v28);
      }
      else {
        int v30 = 1;
      }
      uint64_t v26 = (v29 + v26 + v30);
      ++v27;
    }
    while (v27 < *((int *)this + 20));
  }
  *((_DWORD *)this + 25) = v26;
  return v26;
}

void CLMicroLocationProto::Fingerprint::CheckTypeAndMergeFrom(CLMicroLocationProto::Fingerprint *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::Fingerprint::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::Fingerprint::CopyFrom(CLMicroLocationProto::Fingerprint *this, const CLMicroLocationProto::Fingerprint *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::Fingerprint *))(*(void *)this + 32))(this);
    CLMicroLocationProto::Fingerprint::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::Fingerprint::IsInitialized(CLMicroLocationProto::Fingerprint *this)
{
  return 1;
}

void *CLMicroLocationProto::Fingerprint::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.Fingerprint");
}

std::string *CLMicroLocationProto::ClusterRecordings::MergeFrom(CLMicroLocationProto::ClusterRecordings *this, const CLMicroLocationProto::ClusterRecordings *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v15);
  }
  uint64_t result = (std::string *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::ClusterRecordings *)((char *)this + 16));
  if (*((int *)a2 + 6) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(const std::string **)(*((void *)a2 + 2) + 8 * v5);
      int v7 = *((_DWORD *)this + 7);
      uint64_t v8 = *((int *)this + 6);
      if ((int)v8 >= v7)
      {
        if (v7 == *((_DWORD *)this + 8))
        {
          uint64_t result = (std::string *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::ClusterRecordings *)((char *)this + 16));
          int v7 = *((_DWORD *)this + 7);
        }
        *((_DWORD *)this + 7) = v7 + 1;
        unint64_t v10 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New((wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)result);
        uint64_t v11 = *((void *)this + 2);
        uint64_t v12 = *((int *)this + 6);
        *((_DWORD *)this + 6) = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }
      else
      {
        uint64_t v9 = *((void *)this + 2);
        *((_DWORD *)this + 6) = v8 + 1;
        unint64_t v10 = *(std::string **)(v9 + 8 * v8);
      }
      uint64_t result = std::string::operator=(v10, v6);
      ++v5;
    }
    while (v5 < *((int *)a2 + 6));
  }
  if (*((unsigned char *)a2 + 44))
  {
    int v13 = (const std::string *)*((void *)a2 + 1);
    *((_DWORD *)this + 11) |= 1u;
    char v14 = (std::string *)*((void *)this + 1);
    if (v14 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    return std::string::operator=(v14, v13);
  }
  return result;
}

void sub_256414BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ClusterRecordings::~ClusterRecordings(CLMicroLocationProto::ClusterRecordings *this)
{
  *(void *)this = &unk_2704DE218;
  CLMicroLocationProto::ClusterRecordings::SharedDtor(this);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((int *)this + 4);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ClusterRecordings::~ClusterRecordings(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ClusterRecordings::New(CLMicroLocationProto::ClusterRecordings *this)
{
}

uint64_t CLMicroLocationProto::ClusterRecordings::Clear(CLMicroLocationProto::ClusterRecordings *this)
{
  if (*((unsigned char *)this + 44))
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2 != MEMORY[0x263F8C740])
    {
      if (*(char *)(v2 + 23) < 0)
      {
        **(unsigned char **)uint64_t v2 = 0;
        *(void *)(v2 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v2 = 0;
        *(unsigned char *)(v2 + 23) = 0;
      }
    }
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((uint64_t)this + 16);
  *((_DWORD *)this + 11) = 0;
  return result;
}

uint64_t CLMicroLocationProto::ClusterRecordings::MergePartialFromCodedStream(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v3 = this;
  int v4 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(this + 16);
  uint64_t v5 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
        {
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          int v7 = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)this;
          *((_DWORD *)a2 + 8) = this;
          if (!this) {
            return 1;
          }
        }
        else
        {
          int v7 = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
          *((_DWORD *)a2 + 8) = v7;
          *((void *)a2 + 1) = v6 + 1;
          if (!v7) {
            return 1;
          }
        }
        if (v7 >> 3 != 1) {
          break;
        }
        int v8 = v7 & 7;
        if (v8 != 2) {
          goto LABEL_19;
        }
        *(_DWORD *)(v3 + 44) |= 1u;
        if (*(void *)(v3 + 8) == v5) {
          operator new();
        }
        this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!this) {
          return this;
        }
        uint64_t v9 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v9 < *((void *)a2 + 2) && *v9 == 18) {
          goto LABEL_22;
        }
      }
      if (v7 >> 3 != 2) {
        break;
      }
      int v8 = v7 & 7;
      if (v8 != 2) {
        goto LABEL_19;
      }
      while (1)
      {
        int v10 = *(_DWORD *)(v3 + 28);
        int v11 = *(_DWORD *)(v3 + 24);
        if (v11 >= v10)
        {
          if (v10 == *(_DWORD *)(v3 + 32))
          {
            this = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v4);
            int v10 = *(_DWORD *)(v3 + 28);
          }
          *(_DWORD *)(v3 + 28) = v10 + 1;
          uint64_t v12 = wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New((wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)this);
          uint64_t v13 = *(void *)(v3 + 16);
          uint64_t v14 = *(int *)(v3 + 24);
          *(_DWORD *)(v3 + 24) = v14 + 1;
          *(void *)(v13 + 8 * v14) = v12;
        }
        else
        {
          *(_DWORD *)(v3 + 24) = v11 + 1;
        }
        this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!this) {
          return this;
        }
        uint64_t v9 = (unsigned char *)*((void *)a2 + 1);
        uint64_t v15 = (unsigned char *)*((void *)a2 + 2);
        if (v9 >= v15 || *v9 != 18) {
          break;
        }
LABEL_22:
        *((void *)a2 + 1) = v9 + 1;
      }
      if (v9 == v15 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        this = 1;
        *((unsigned char *)a2 + 36) = 1;
        return this;
      }
    }
    int v8 = v7 & 7;
LABEL_19:
    if (v8 == 4) {
      return 1;
    }
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, v7);
    if ((this & 1) == 0) {
      return 0;
    }
  }
}

uint64_t CLMicroLocationProto::ClusterRecordings::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2)
{
  uint64_t v2 = this;
  if (*(unsigned char *)(this + 44)) {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  }
  if (*(int *)(v2 + 24) >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
      ++v3;
    }
    while (v3 < *(int *)(v2 + 24));
  }
  return this;
}

uint64_t CLMicroLocationProto::ClusterRecordings::ByteSize(CLMicroLocationProto::ClusterRecordings *this)
{
  if (*((unsigned char *)this + 44))
  {
    uint64_t v3 = *((void *)this + 1);
    int v4 = *(unsigned __int8 *)(v3 + 23);
    char v5 = v4;
    uint64_t v6 = *(void *)(v3 + 8);
    if ((v4 & 0x80u) == 0) {
      unint64_t v7 = *(unsigned __int8 *)(v3 + 23);
    }
    else {
      unint64_t v7 = v6;
    }
    if (v7 >= 0x80)
    {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v7);
      int v4 = *(unsigned __int8 *)(v3 + 23);
      uint64_t v6 = *(void *)(v3 + 8);
      int v8 = v9 + 1;
      char v5 = *(unsigned char *)(v3 + 23);
    }
    else
    {
      int v8 = 2;
    }
    if (v5 < 0) {
      int v4 = v6;
    }
    int v2 = v8 + v4;
  }
  else
  {
    int v2 = 0;
  }
  int v10 = *((_DWORD *)this + 6);
  uint64_t v11 = (v10 + v2);
  if (v10 >= 1)
  {
    for (uint64_t i = 0; i < v10; ++i)
    {
      uint64_t v13 = *(void *)(*((void *)this + 2) + 8 * i);
      int v14 = *(unsigned __int8 *)(v13 + 23);
      char v15 = v14;
      uint64_t v16 = *(void *)(v13 + 8);
      if ((v14 & 0x80u) == 0) {
        unint64_t v17 = *(unsigned __int8 *)(v13 + 23);
      }
      else {
        unint64_t v17 = v16;
      }
      if (v17 >= 0x80)
      {
        int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v17);
        int v14 = *(unsigned __int8 *)(v13 + 23);
        uint64_t v16 = *(void *)(v13 + 8);
        int v10 = *((_DWORD *)this + 6);
        char v15 = *(unsigned char *)(v13 + 23);
      }
      else
      {
        int v18 = 1;
      }
      if (v15 < 0) {
        int v14 = v16;
      }
      uint64_t v11 = (v18 + v11 + v14);
    }
  }
  *((_DWORD *)this + 10) = v11;
  return v11;
}

std::string *CLMicroLocationProto::ClusterRecordings::CheckTypeAndMergeFrom(CLMicroLocationProto::ClusterRecordings *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  return CLMicroLocationProto::ClusterRecordings::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::ClusterRecordings::IsInitialized(CLMicroLocationProto::ClusterRecordings *this)
{
  return 1;
}

void *CLMicroLocationProto::ClusterRecordings::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ClusterRecordings");
}

void CLMicroLocationProto::AnchorMetadata::MergeFrom(CLMicroLocationProto::AnchorMetadata *this, const CLMicroLocationProto::AnchorMetadata *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 48);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 48))
  {
    uint64_t v5 = *((void *)a2 + 1);
    *((_DWORD *)this + 12) |= 1u;
    *((void *)this + 1) = v5;
    int v4 = *((_DWORD *)a2 + 12);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
  }
  else if ((*((unsigned char *)a2 + 48) & 2) == 0)
  {
    goto LABEL_6;
  }
  uint64_t v6 = *((void *)a2 + 2);
  *((_DWORD *)this + 12) |= 2u;
  *((void *)this + 2) = v6;
  int v4 = *((_DWORD *)a2 + 12);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_16;
  }
LABEL_14:
  int v7 = *((_DWORD *)a2 + 6);
  if ((v7 - 1) >= 2) {
    CLMicroLocationProto::AnchorMetadata::MergeFrom();
  }
  *((_DWORD *)this + 12) |= 4u;
  *((_DWORD *)this + 6) = v7;
  int v4 = *((_DWORD *)a2 + 12);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0) {
      goto LABEL_9;
    }
LABEL_17:
    char v9 = *((unsigned char *)a2 + 29);
    *((_DWORD *)this + 12) |= 0x10u;
    *((unsigned char *)this + 29) = v9;
    int v4 = *((_DWORD *)a2 + 12);
    if ((v4 & 0x20) == 0)
    {
LABEL_10:
      if ((v4 & 0x40) == 0) {
        return;
      }
      goto LABEL_20;
    }
    goto LABEL_18;
  }
LABEL_16:
  char v8 = *((unsigned char *)a2 + 28);
  *((_DWORD *)this + 12) |= 8u;
  *((unsigned char *)this + 28) = v8;
  int v4 = *((_DWORD *)a2 + 12);
  if ((v4 & 0x10) != 0) {
    goto LABEL_17;
  }
LABEL_9:
  if ((v4 & 0x20) == 0) {
    goto LABEL_10;
  }
LABEL_18:
  int v10 = *((_DWORD *)a2 + 10);
  if ((v10 - 1) >= 6) {
    CLMicroLocationProto::AnchorMetadata::MergeFrom();
  }
  *((_DWORD *)this + 12) |= 0x20u;
  *((_DWORD *)this + 10) = v10;
  if ((*((_DWORD *)a2 + 12) & 0x40) != 0)
  {
LABEL_20:
    uint64_t v11 = (const std::string *)*((void *)a2 + 4);
    *((_DWORD *)this + 12) |= 0x40u;
    uint64_t v12 = (std::string *)*((void *)this + 4);
    if (v12 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v12, v11);
  }
}

void sub_256415324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::AnchorMetadata::~AnchorMetadata(CLMicroLocationProto::AnchorMetadata *this)
{
  *(void *)this = &unk_2704DE290;
  CLMicroLocationProto::AnchorMetadata::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::AnchorMetadata::~AnchorMetadata(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::AnchorMetadata::SharedDtor(CLMicroLocationProto::AnchorMetadata *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1 != MEMORY[0x263F8C740] && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    this = (CLMicroLocationProto::AnchorMetadata *)MEMORY[0x25A2A6340](v1, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::AnchorMetadata::New(CLMicroLocationProto::AnchorMetadata *this)
{
}

uint64_t CLMicroLocationProto::AnchorMetadata::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 48);
  if (v1)
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 0;
    *(_DWORD *)(this + 24) = 1;
    *(_WORD *)(this + 28) = 0;
    *(_DWORD *)(this + 40) = 1;
    if ((v1 & 0x40) != 0)
    {
      uint64_t v2 = *(void *)(this + 32);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 48) = 0;
  return this;
}

uint64_t CLMicroLocationProto::AnchorMetadata::MergePartialFromCodedStream(CLMicroLocationProto::AnchorMetadata *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_31;
        }
        *(void *)int v25 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v25) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v25;
        }
        *((_DWORD *)this + 12) |= 1u;
        char v8 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 != 17) {
          continue;
        }
        *((void *)a2 + 1) = v8 + 1;
        goto LABEL_15;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_31;
        }
LABEL_15:
        *(void *)int v25 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v25) & 1) == 0)return 0; {
        *((void *)this + 2) = *(void *)v25;
        }
        *((_DWORD *)this + 12) |= 2u;
        int v10 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        if ((unint64_t)v10 >= v9 || *v10 != 24) {
          continue;
        }
        uint64_t v11 = v10 + 1;
        *((void *)a2 + 1) = v11;
LABEL_21:
        v25[0] = 0;
        if ((unint64_t)v11 >= v9 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v25);
          if (!result) {
            return result;
          }
          unsigned int v12 = v25[0];
        }
        else
        {
          unsigned int v12 = *v11;
          *((void *)a2 + 1) = v11 + 1;
        }
        if (v12 - 1 <= 1)
        {
          *((_DWORD *)this + 12) |= 4u;
          *((_DWORD *)this + 6) = v12;
        }
        int v18 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        if ((unint64_t)v18 >= v13 || *v18 != 32) {
          continue;
        }
        int v14 = v18 + 1;
        *((void *)a2 + 1) = v14;
LABEL_41:
        v25[0] = 0;
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v25);
          if (!result) {
            return result;
          }
          unsigned int v19 = v25[0];
          int v20 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v13 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v19 = *v14;
          int v20 = v14 + 1;
          *((void *)a2 + 1) = v20;
        }
        *((unsigned char *)this + 28) = v19 != 0;
        *((_DWORD *)this + 12) |= 8u;
        if ((unint64_t)v20 >= v13 || *v20 != 40) {
          continue;
        }
        char v15 = v20 + 1;
        *((void *)a2 + 1) = v15;
LABEL_49:
        v25[0] = 0;
        if ((unint64_t)v15 >= v13 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v25);
          if (!result) {
            return result;
          }
          unsigned int v21 = v25[0];
          int v22 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v13 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v21 = *v15;
          int v22 = v15 + 1;
          *((void *)a2 + 1) = v22;
        }
        *((unsigned char *)this + 29) = v21 != 0;
        *((_DWORD *)this + 12) |= 0x10u;
        if ((unint64_t)v22 >= v13 || *v22 != 48) {
          continue;
        }
        uint64_t v16 = v22 + 1;
        *((void *)a2 + 1) = v16;
LABEL_57:
        v25[0] = 0;
        if ((unint64_t)v16 >= v13 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v25);
          if (!result) {
            return result;
          }
          unsigned int v23 = v25[0];
        }
        else
        {
          unsigned int v23 = *v16;
          *((void *)a2 + 1) = v16 + 1;
        }
        if (v23 - 1 <= 5)
        {
          *((_DWORD *)this + 12) |= 0x20u;
          *((_DWORD *)this + 10) = v23;
        }
        int v24 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v24 >= *((void *)a2 + 2) || *v24 != 58) {
          continue;
        }
        *((void *)a2 + 1) = v24 + 1;
LABEL_67:
        *((_DWORD *)this + 12) |= 0x40u;
        if (*((void *)this + 4) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) != *((void *)a2 + 2)
          || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
        {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        break;
      case 3u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_31;
        }
        uint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_21;
      case 4u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_31;
        }
        int v14 = (char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        goto LABEL_41;
      case 5u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_31;
        }
        char v15 = (char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        goto LABEL_49;
      case 6u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_31;
        }
        uint64_t v16 = (char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        goto LABEL_57;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_31;
        }
        goto LABEL_67;
      default:
        int v7 = TagFallback & 7;
LABEL_31:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t CLMicroLocationProto::AnchorMetadata::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 48);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, (uint64_t)a2, *(double *)(this + 8), a3);
    int v6 = *(_DWORD *)(v5 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v5 + 16), a3);
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned int *)(v5 + 24), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, *(unsigned __int8 *)(v5 + 28), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
LABEL_14:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(unsigned int *)(v5 + 40), (uint64_t)a2, a4);
    if ((*(_DWORD *)(v5 + 48) & 0x40) == 0) {
      return this;
    }
    goto LABEL_15;
  }
LABEL_13:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(unsigned __int8 *)(v5 + 29), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 0x20) != 0) {
    goto LABEL_14;
  }
LABEL_7:
  if ((v6 & 0x40) == 0) {
    return this;
  }
LABEL_15:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
}

uint64_t CLMicroLocationProto::AnchorMetadata::ByteSize(CLMicroLocationProto::AnchorMetadata *this)
{
  int v2 = *((unsigned __int8 *)this + 48);
  if (*((unsigned char *)this + 48))
  {
    if ((v2 & 2) != 0) {
      int v3 = ((v2 << 31 >> 31) & 9) + 9;
    }
    else {
      int v3 = (v2 << 31 >> 31) & 9;
    }
    if ((v2 & 4) != 0)
    {
      uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
      if ((v4 & 0x80000000) != 0)
      {
        int v5 = 11;
      }
      else if (v4 >= 0x80)
      {
        int v5 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
        int v2 = *((_DWORD *)this + 12);
      }
      else
      {
        int v5 = 2;
      }
      v3 += v5;
    }
    unsigned int v7 = v3 + 2;
    if ((v2 & 8) == 0) {
      unsigned int v7 = v3;
    }
    if ((v2 & 0x10) != 0) {
      uint64_t v6 = v7 + 2;
    }
    else {
      uint64_t v6 = v7;
    }
    if ((v2 & 0x20) != 0)
    {
      char v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 10);
      if ((v8 & 0x80000000) != 0)
      {
        int v9 = 11;
      }
      else if (v8 >= 0x80)
      {
        int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8) + 1;
        int v2 = *((_DWORD *)this + 12);
      }
      else
      {
        int v9 = 2;
      }
      uint64_t v6 = (v9 + v6);
    }
    if ((v2 & 0x40) != 0)
    {
      uint64_t v10 = *((void *)this + 4);
      int v11 = *(unsigned __int8 *)(v10 + 23);
      char v12 = v11;
      uint64_t v13 = *(void *)(v10 + 8);
      if ((v11 & 0x80u) == 0) {
        unint64_t v14 = *(unsigned __int8 *)(v10 + 23);
      }
      else {
        unint64_t v14 = v13;
      }
      if (v14 >= 0x80)
      {
        int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v14);
        int v11 = *(unsigned __int8 *)(v10 + 23);
        uint64_t v13 = *(void *)(v10 + 8);
        char v12 = *(unsigned char *)(v10 + 23);
      }
      else
      {
        int v15 = 1;
      }
      if (v12 < 0) {
        int v11 = v13;
      }
      uint64_t v6 = (v6 + v15 + v11 + 1);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  *((_DWORD *)this + 11) = v6;
  return v6;
}

void CLMicroLocationProto::AnchorMetadata::CheckTypeAndMergeFrom(CLMicroLocationProto::AnchorMetadata *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::AnchorMetadata::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::AnchorMetadata::IsInitialized(CLMicroLocationProto::AnchorMetadata *this)
{
  return 1;
}

void *CLMicroLocationProto::AnchorMetadata::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.AnchorMetadata");
}

void CLMicroLocationProto::AnchorAppearance::MergeFrom(CLMicroLocationProto::AnchorAppearance *this, const CLMicroLocationProto::AnchorAppearance *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 40);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 40))
    {
      uint64_t v5 = *((void *)a2 + 1);
      *((_DWORD *)this + 10) |= 1u;
      *((void *)this + 1) = v5;
      int v4 = *((_DWORD *)a2 + 10);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_11;
      }
    }
    else if ((*((unsigned char *)a2 + 40) & 2) == 0)
    {
      goto LABEL_6;
    }
    uint64_t v6 = *((void *)a2 + 2);
    *((_DWORD *)this + 10) |= 2u;
    *((void *)this + 2) = v6;
    int v4 = *((_DWORD *)a2 + 10);
    if ((v4 & 4) == 0)
    {
LABEL_7:
      if ((v4 & 8) == 0) {
        return;
      }
      goto LABEL_12;
    }
LABEL_11:
    int v7 = *((_DWORD *)a2 + 8);
    *((_DWORD *)this + 10) |= 4u;
    *((_DWORD *)this + 8) = v7;
    if ((*((_DWORD *)a2 + 10) & 8) == 0) {
      return;
    }
LABEL_12:
    char v8 = (const std::string *)*((void *)a2 + 3);
    *((_DWORD *)this + 10) |= 8u;
    int v9 = (std::string *)*((void *)this + 3);
    if (v9 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v9, v8);
  }
}

void sub_256415D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::AnchorAppearance::~AnchorAppearance(CLMicroLocationProto::AnchorAppearance *this)
{
  *(void *)this = &unk_2704DE308;
  CLMicroLocationProto::WiFiRange::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::AnchorAppearance::~AnchorAppearance(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::AnchorAppearance::New(CLMicroLocationProto::AnchorAppearance *this)
{
}

uint64_t CLMicroLocationProto::AnchorAppearance::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 40);
  if (v1)
  {
    *(_DWORD *)(this + 32) = 0;
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 0;
    if ((v1 & 8) != 0)
    {
      uint64_t v2 = *(void *)(this + 24);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t CLMicroLocationProto::AnchorAppearance::MergePartialFromCodedStream(CLMicroLocationProto::AnchorAppearance *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  int v4 = (unsigned int *)((char *)this + 32);
  uint64_t v5 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v6;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_26;
        }
        unint64_t v16 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, &v16) & 1) == 0) {
          return 0;
        }
        *((void *)this + 1) = v16;
        *((_DWORD *)this + 10) |= 1u;
        int v9 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 != 17) {
          continue;
        }
        *((void *)a2 + 1) = v9 + 1;
        goto LABEL_15;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_26;
        }
LABEL_15:
        unint64_t v16 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, &v16) & 1) == 0) {
          return 0;
        }
        *((void *)this + 2) = v16;
        *((_DWORD *)this + 10) |= 2u;
        int v11 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((unint64_t)v11 >= v10 || *v11 != 24) {
          continue;
        }
        char v12 = v11 + 1;
        *((void *)a2 + 1) = v12;
LABEL_21:
        if ((unint64_t)v12 >= v10 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v4);
          if (!result) {
            return result;
          }
          uint64_t v13 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          *int v4 = *v12;
          uint64_t v13 = v12 + 1;
          *((void *)a2 + 1) = v13;
        }
        int v14 = *((_DWORD *)this + 10) | 4;
        *((_DWORD *)this + 10) = v14;
        if ((unint64_t)v13 >= v10 || *v13 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v13 + 1;
LABEL_34:
        *((_DWORD *)this + 10) = v14 | 8;
        if (*((void *)this + 3) == v5) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) != *((void *)a2 + 2)
          || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
        {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        break;
      case 3u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_26;
        }
        char v12 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_21;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_26;
        }
        int v14 = *((_DWORD *)this + 10);
        goto LABEL_34;
      default:
        int v8 = TagFallback & 7;
LABEL_26:
        if (v8 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t CLMicroLocationProto::AnchorAppearance::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 40);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, (uint64_t)a2, *(double *)(this + 8), a3);
    int v6 = *(_DWORD *)(v5 + 40);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned int *)(v5 + 32), (uint64_t)a2, a4);
      if ((*(_DWORD *)(v5 + 40) & 8) == 0) {
        return this;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v5 + 16), a3);
  int v6 = *(_DWORD *)(v5 + 40);
  if ((v6 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v6 & 8) == 0) {
    return this;
  }
LABEL_9:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::AnchorAppearance::ByteSize(CLMicroLocationProto::AnchorAppearance *this)
{
  int v2 = *((unsigned __int8 *)this + 40);
  if (*((unsigned char *)this + 40))
  {
    unsigned int v3 = (v2 << 31 >> 31) & 9;
    if ((v2 & 2) != 0) {
      uint64_t v4 = v3 + 9;
    }
    else {
      uint64_t v4 = v3;
    }
    if ((v2 & 4) != 0)
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
      if (v5 >= 0x80)
      {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
        int v2 = *((_DWORD *)this + 10);
      }
      else
      {
        int v6 = 2;
      }
      uint64_t v4 = (v6 + v4);
    }
    if ((v2 & 8) != 0)
    {
      uint64_t v7 = *((void *)this + 3);
      int v8 = *(unsigned __int8 *)(v7 + 23);
      char v9 = v8;
      uint64_t v10 = *(void *)(v7 + 8);
      if ((v8 & 0x80u) == 0) {
        unint64_t v11 = *(unsigned __int8 *)(v7 + 23);
      }
      else {
        unint64_t v11 = v10;
      }
      if (v11 >= 0x80)
      {
        int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v11);
        int v8 = *(unsigned __int8 *)(v7 + 23);
        uint64_t v10 = *(void *)(v7 + 8);
        char v9 = *(unsigned char *)(v7 + 23);
      }
      else
      {
        int v12 = 1;
      }
      if (v9 < 0) {
        int v8 = v10;
      }
      uint64_t v4 = (v4 + v12 + v8 + 1);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *((_DWORD *)this + 9) = v4;
  return v4;
}

void CLMicroLocationProto::AnchorAppearance::CheckTypeAndMergeFrom(CLMicroLocationProto::AnchorAppearance *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::AnchorAppearance::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::AnchorAppearance::CopyFrom(CLMicroLocationProto::AnchorAppearance *this, const CLMicroLocationProto::AnchorAppearance *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::AnchorAppearance *))(*(void *)this + 32))(this);
    CLMicroLocationProto::AnchorAppearance::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::AnchorAppearance::IsInitialized(CLMicroLocationProto::AnchorAppearance *this)
{
  return 1;
}

void *CLMicroLocationProto::AnchorAppearance::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.AnchorAppearance");
}

void CLMicroLocationProto::anchorAppearancesVector::MergeFrom(CLMicroLocationProto::anchorAppearancesVector *this, const CLMicroLocationProto::anchorAppearancesVector *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::anchorAppearancesVector *)((char *)this + 8));
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(const CLMicroLocationProto::AnchorAppearance **)(*((void *)a2 + 1) + 8 * v4);
      int v6 = *((_DWORD *)this + 5);
      uint64_t v7 = *((int *)this + 4);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 6))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::anchorAppearancesVector *)((char *)this + 8));
          int v6 = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)this + 1);
      *((_DWORD *)this + 4) = v7 + 1;
      CLMicroLocationProto::AnchorAppearance::MergeFrom(*(CLMicroLocationProto::AnchorAppearance **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 4));
  }
}

void sub_25641651C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::anchorAppearancesVector::~anchorAppearancesVector(CLMicroLocationProto::anchorAppearancesVector *this)
{
  *(void *)this = &unk_2704DE380;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::anchorAppearancesVector::~anchorAppearancesVector(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::anchorAppearancesVector::New(CLMicroLocationProto::anchorAppearancesVector *this)
{
}

uint64_t CLMicroLocationProto::anchorAppearancesVector::Clear(CLMicroLocationProto::anchorAppearancesVector *this)
{
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 8);
  *((_DWORD *)this + 9) = 0;
  return result;
}

uint64_t CLMicroLocationProto::anchorAppearancesVector::MergePartialFromCodedStream(CLMicroLocationProto::anchorAppearancesVector *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (CLMicroLocationProto::anchorAppearancesVector *)((char *)this + 8);
  while (1)
  {
LABEL_2:
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
    }
    if (TagFallback == 10)
    {
      while (1)
      {
        int v7 = *((_DWORD *)this + 5);
        uint64_t v8 = *((int *)this + 4);
        if ((int)v8 >= v7)
        {
          if (v7 == *((_DWORD *)this + 6))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v4);
            int v7 = *((_DWORD *)this + 5);
          }
          *((_DWORD *)this + 5) = v7 + 1;
          operator new();
        }
        uint64_t v9 = *((void *)this + 1);
        *((_DWORD *)this + 4) = v8 + 1;
        uint64_t v10 = *(CLMicroLocationProto::AnchorAppearance **)(v9 + 8 * v8);
        unsigned int v20 = 0;
        unint64_t v11 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v11 >= *((void *)a2 + 2) || *v11 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v20))return 0; {
        }
          }
        else
        {
          unsigned int v20 = *v11;
          *((void *)a2 + 1) = v11 + 1;
        }
        int v12 = *((_DWORD *)a2 + 14);
        int v13 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v12 + 1;
        if (v12 >= v13) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::AnchorAppearance::MergePartialFromCodedStream(v10, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v14 = *((_DWORD *)a2 + 14);
        BOOL v15 = __OFSUB__(v14, 1);
        int v16 = v14 - 1;
        if (v16 < 0 == v15) {
          *((_DWORD *)a2 + 14) = v16;
        }
        unint64_t v17 = (unsigned char *)*((void *)a2 + 1);
        int v18 = (unsigned char *)*((void *)a2 + 2);
        if (v17 >= v18 || *v17 != 10)
        {
          if (v17 == v18 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
          {
            *((_DWORD *)a2 + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)a2 + 36) = 1;
            return result;
          }
          goto LABEL_2;
        }
        *((void *)a2 + 1) = v17 + 1;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::anchorAppearancesVector::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(this + 16) >= 1)
  {
    uint64_t v5 = this;
    uint64_t v6 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return this;
}

uint64_t CLMicroLocationProto::anchorAppearancesVector::ByteSize(CLMicroLocationProto::anchorAppearancesVector *this)
{
  uint64_t v2 = *((unsigned int *)this + 4);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::AnchorAppearance::ByteSize(*(CLMicroLocationProto::AnchorAppearance **)(*((void *)this + 1) + 8 * v3));
      int v5 = (int)v4;
      if (v4 >= 0x80) {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4);
      }
      else {
        int v6 = 1;
      }
      uint64_t v2 = (v5 + v2 + v6);
      ++v3;
    }
    while (v3 < *((int *)this + 4));
  }
  *((_DWORD *)this + 8) = v2;
  return v2;
}

void CLMicroLocationProto::anchorAppearancesVector::CheckTypeAndMergeFrom(CLMicroLocationProto::anchorAppearancesVector *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::anchorAppearancesVector::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::anchorAppearancesVector::CopyFrom(CLMicroLocationProto::anchorAppearancesVector *this, const CLMicroLocationProto::anchorAppearancesVector *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::anchorAppearancesVector *))(*(void *)this + 32))(this);
    CLMicroLocationProto::anchorAppearancesVector::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::anchorAppearancesVector::IsInitialized(CLMicroLocationProto::anchorAppearancesVector *this)
{
  return 1;
}

void *CLMicroLocationProto::anchorAppearancesVector::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.anchorAppearancesVector");
}

void CLMicroLocationProto::AnchorValueStatistics::MergeFrom(CLMicroLocationProto::AnchorValueStatistics *this, const CLMicroLocationProto::AnchorValueStatistics *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 36);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 36))
    {
      uint64_t v5 = *((void *)a2 + 1);
      *((_DWORD *)this + 9) |= 1u;
      *((void *)this + 1) = v5;
      int v4 = *((_DWORD *)a2 + 9);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          return;
        }
        goto LABEL_10;
      }
    }
    else if ((*((unsigned char *)a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }
    uint64_t v6 = *((void *)a2 + 2);
    *((_DWORD *)this + 9) |= 2u;
    *((void *)this + 2) = v6;
    if ((*((_DWORD *)a2 + 9) & 4) == 0) {
      return;
    }
LABEL_10:
    int v7 = (const std::string *)*((void *)a2 + 3);
    *((_DWORD *)this + 9) |= 4u;
    uint64_t v8 = (std::string *)*((void *)this + 3);
    if (v8 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v8, v7);
  }
}

void sub_256416B88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::AnchorValueStatistics::~AnchorValueStatistics(CLMicroLocationProto::AnchorValueStatistics *this)
{
  *(void *)this = &unk_2704DE3F8;
  CLMicroLocationProto::WiFiRange::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::AnchorValueStatistics::~AnchorValueStatistics(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::AnchorValueStatistics::New(CLMicroLocationProto::AnchorValueStatistics *this)
{
}

uint64_t CLMicroLocationProto::AnchorValueStatistics::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 36);
  if (v1)
  {
    *(void *)(this + 8) = 0;
    *(void *)(this + 16) = 0;
    if ((v1 & 4) != 0)
    {
      uint64_t v2 = *(void *)(this + 24);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 36) = 0;
  return this;
}

uint64_t CLMicroLocationProto::AnchorValueStatistics::MergePartialFromCodedStream(CLMicroLocationProto::AnchorValueStatistics *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_30;
        }
        unint64_t v13 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, &v13) & 1) == 0) {
          return 0;
        }
        *((void *)this + 1) = v13;
        *((_DWORD *)this + 9) |= 1u;
        uint64_t v10 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v10 < *((void *)a2 + 2) && *v10 == 17)
        {
          *((void *)a2 + 1) = v10 + 1;
          goto LABEL_18;
        }
      }
      if (v7 == 2) {
        break;
      }
      if (v7 == 3)
      {
        int v8 = TagFallback & 7;
        if (v8 == 2)
        {
          int v9 = *((_DWORD *)this + 9);
          goto LABEL_22;
        }
      }
      else
      {
        int v8 = TagFallback & 7;
      }
LABEL_30:
      if (v8 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
    }
      }
    int v8 = TagFallback & 7;
    if (v8 != 1) {
      goto LABEL_30;
    }
LABEL_18:
    unint64_t v13 = 0;
    if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, &v13) & 1) == 0) {
      return 0;
    }
    *((void *)this + 2) = v13;
    int v9 = *((_DWORD *)this + 9) | 2;
    *((_DWORD *)this + 9) = v9;
    unint64_t v11 = (unsigned char *)*((void *)a2 + 1);
    if ((unint64_t)v11 < *((void *)a2 + 2) && *v11 == 26)
    {
      *((void *)a2 + 1) = v11 + 1;
LABEL_22:
      *((_DWORD *)this + 9) = v9 | 4;
      if (*((void *)this + 3) == v4) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
      if (!result) {
        return result;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        break;
      }
    }
  }
  *((_DWORD *)a2 + 8) = 0;
  uint64_t result = 1;
  *((unsigned char *)a2 + 36) = 1;
  return result;
}

uint64_t CLMicroLocationProto::AnchorValueStatistics::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 36);
  if ((v5 & 1) == 0)
  {
    if ((v5 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v4 + 16), a3);
    if ((*(_DWORD *)(v4 + 36) & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, (uint64_t)a2, *(double *)(this + 8), a3);
  int v5 = *(_DWORD *)(v4 + 36);
  if ((v5 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v5 & 4) == 0) {
    return this;
  }
LABEL_7:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::AnchorValueStatistics::ByteSize(CLMicroLocationProto::AnchorValueStatistics *this)
{
  int v2 = *((unsigned __int8 *)this + 36);
  if (*((unsigned char *)this + 36))
  {
    unsigned int v3 = (v2 << 31 >> 31) & 9;
    if ((v2 & 2) != 0) {
      uint64_t v4 = v3 + 9;
    }
    else {
      uint64_t v4 = v3;
    }
    if ((v2 & 4) != 0)
    {
      uint64_t v5 = *((void *)this + 3);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      char v7 = v6;
      uint64_t v8 = *(void *)(v5 + 8);
      if ((v6 & 0x80u) == 0) {
        unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
      }
      else {
        unint64_t v9 = v8;
      }
      if (v9 >= 0x80)
      {
        int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
        int v6 = *(unsigned __int8 *)(v5 + 23);
        uint64_t v8 = *(void *)(v5 + 8);
        char v7 = *(unsigned char *)(v5 + 23);
      }
      else
      {
        int v10 = 1;
      }
      if (v7 < 0) {
        int v6 = v8;
      }
      uint64_t v4 = (v4 + v10 + v6 + 1);
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  *((_DWORD *)this + 8) = v4;
  return v4;
}

void CLMicroLocationProto::AnchorValueStatistics::CheckTypeAndMergeFrom(CLMicroLocationProto::AnchorValueStatistics *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::AnchorValueStatistics::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::AnchorValueStatistics::IsInitialized(CLMicroLocationProto::AnchorValueStatistics *this)
{
  return 1;
}

void *CLMicroLocationProto::AnchorValueStatistics::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.AnchorValueStatistics");
}

void CLMicroLocationProto::ClusterAnchorValueStatistics::MergeFrom(CLMicroLocationProto::ClusterAnchorValueStatistics *this, const CLMicroLocationProto::ClusterAnchorValueStatistics *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::ClusterAnchorValueStatistics *)((char *)this + 8));
  uint64_t v4 = (std::string *)MEMORY[0x263F8C740];
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      int v6 = *(const CLMicroLocationProto::AnchorValueStatistics **)(*((void *)a2 + 1) + 8 * v5);
      int v7 = *((_DWORD *)this + 5);
      uint64_t v8 = *((int *)this + 4);
      if ((int)v8 >= v7)
      {
        if (v7 == *((_DWORD *)this + 6))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::ClusterAnchorValueStatistics *)((char *)this + 8));
          int v7 = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v7 + 1;
        operator new();
      }
      uint64_t v9 = *((void *)this + 1);
      *((_DWORD *)this + 4) = v8 + 1;
      CLMicroLocationProto::AnchorValueStatistics::MergeFrom(*(CLMicroLocationProto::AnchorValueStatistics **)(v9 + 8 * v8), v6);
      ++v5;
    }
    while (v5 < *((int *)a2 + 4));
  }
  if ((*((unsigned char *)a2 + 44) & 2) != 0)
  {
    int v10 = (const std::string *)*((void *)a2 + 4);
    *((_DWORD *)this + 11) |= 2u;
    unint64_t v11 = (std::string *)*((void *)this + 4);
    if (v11 == v4) {
      operator new();
    }
    std::string::operator=(v11, v10);
  }
}

void sub_256417264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ClusterAnchorValueStatistics::~ClusterAnchorValueStatistics(CLMicroLocationProto::ClusterAnchorValueStatistics *this)
{
  *(void *)this = &unk_2704DE470;
  CLMicroLocationProto::AnchorMetadata::SharedDtor(this);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ClusterAnchorValueStatistics::~ClusterAnchorValueStatistics(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ClusterAnchorValueStatistics::New(CLMicroLocationProto::ClusterAnchorValueStatistics *this)
{
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatistics::Clear(CLMicroLocationProto::ClusterAnchorValueStatistics *this)
{
  if ((*((unsigned char *)this + 44) & 2) != 0)
  {
    uint64_t v2 = *((void *)this + 4);
    if (v2 != MEMORY[0x263F8C740])
    {
      if (*(char *)(v2 + 23) < 0)
      {
        **(unsigned char **)uint64_t v2 = 0;
        *(void *)(v2 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v2 = 0;
        *(unsigned char *)(v2 + 23) = 0;
      }
    }
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 8);
  *((_DWORD *)this + 11) = 0;
  return result;
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatistics::MergePartialFromCodedStream(CLMicroLocationProto::ClusterAnchorValueStatistics *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (CLMicroLocationProto::ClusterAnchorValueStatistics *)((char *)this + 8);
  uint64_t v5 = MEMORY[0x263F8C740];
  do
  {
    while (1)
    {
LABEL_2:
      int v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v6;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v6 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 == 2)
      {
        while (1)
        {
          int v10 = *((_DWORD *)this + 5);
          uint64_t v11 = *((int *)this + 4);
          if ((int)v11 >= v10)
          {
            if (v10 == *((_DWORD *)this + 6))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v4);
              int v10 = *((_DWORD *)this + 5);
            }
            *((_DWORD *)this + 5) = v10 + 1;
            operator new();
          }
          uint64_t v12 = *((void *)this + 1);
          *((_DWORD *)this + 4) = v11 + 1;
          unint64_t v13 = *(CLMicroLocationProto::AnchorValueStatistics **)(v12 + 8 * v11);
          unsigned int v22 = 0;
          int v14 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v22))return 0; {
          }
            }
          else
          {
            unsigned int v22 = *v14;
            *((void *)a2 + 1) = v14 + 1;
          }
          int v15 = *((_DWORD *)a2 + 14);
          int v16 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v15 + 1;
          if (v15 >= v16) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (!CLMicroLocationProto::AnchorValueStatistics::MergePartialFromCodedStream(v13, a2)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
          int v17 = *((_DWORD *)a2 + 14);
          BOOL v18 = __OFSUB__(v17, 1);
          int v19 = v17 - 1;
          if (v19 < 0 == v18) {
            *((_DWORD *)a2 + 14) = v19;
          }
          unsigned int v20 = (unsigned __int8 *)*((void *)a2 + 1);
          if ((unint64_t)v20 >= *((void *)a2 + 2)) {
            goto LABEL_2;
          }
          int v21 = *v20;
          if (v21 != 10)
          {
            if (v21 != 18) {
              goto LABEL_2;
            }
            *((void *)a2 + 1) = v20 + 1;
            goto LABEL_10;
          }
          *((void *)a2 + 1) = v20 + 1;
        }
      }
LABEL_36:
      if (v8 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
    }
      }
    if (TagFallback >> 3 != 2)
    {
      int v8 = TagFallback & 7;
      goto LABEL_36;
    }
    int v8 = TagFallback & 7;
    if (v8 != 2) {
      goto LABEL_36;
    }
LABEL_10:
    *((_DWORD *)this + 11) |= 2u;
    if (*((void *)this + 4) == v5) {
      operator new();
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
    if (!result) {
      return result;
    }
  }
  while (*((void *)a2 + 1) != *((void *)a2 + 2)
       || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10));
  *((_DWORD *)a2 + 8) = 0;
  uint64_t result = 1;
  *((unsigned char *)a2 + 36) = 1;
  return result;
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatistics::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  if (*(int *)(this + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  if ((*(unsigned char *)(v5 + 44) & 2) != 0)
  {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  }
  return this;
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatistics::ByteSize(CLMicroLocationProto::ClusterAnchorValueStatistics *this)
{
  if ((*((unsigned char *)this + 44) & 2) != 0)
  {
    uint64_t v3 = *((void *)this + 4);
    int v4 = *(unsigned __int8 *)(v3 + 23);
    char v5 = v4;
    uint64_t v6 = *(void *)(v3 + 8);
    if ((v4 & 0x80u) == 0) {
      unint64_t v7 = *(unsigned __int8 *)(v3 + 23);
    }
    else {
      unint64_t v7 = v6;
    }
    if (v7 >= 0x80)
    {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v7);
      int v4 = *(unsigned __int8 *)(v3 + 23);
      uint64_t v6 = *(void *)(v3 + 8);
      int v8 = v9 + 1;
      char v5 = *(unsigned char *)(v3 + 23);
    }
    else
    {
      int v8 = 2;
    }
    if (v5 < 0) {
      int v4 = v6;
    }
    int v2 = v8 + v4;
  }
  else
  {
    int v2 = 0;
  }
  int v10 = *((_DWORD *)this + 4);
  uint64_t v11 = (v10 + v2);
  if (v10 >= 1)
  {
    uint64_t v12 = 0;
    do
    {
      unint64_t v13 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::AnchorValueStatistics::ByteSize(*(CLMicroLocationProto::AnchorValueStatistics **)(*((void *)this + 1) + 8 * v12));
      int v14 = (int)v13;
      if (v13 >= 0x80) {
        int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v13);
      }
      else {
        int v15 = 1;
      }
      uint64_t v11 = (v14 + v11 + v15);
      ++v12;
    }
    while (v12 < *((int *)this + 4));
  }
  *((_DWORD *)this + 10) = v11;
  return v11;
}

void CLMicroLocationProto::ClusterAnchorValueStatistics::CheckTypeAndMergeFrom(CLMicroLocationProto::ClusterAnchorValueStatistics *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ClusterAnchorValueStatistics::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatistics::IsInitialized(CLMicroLocationProto::ClusterAnchorValueStatistics *this)
{
  return 1;
}

void *CLMicroLocationProto::ClusterAnchorValueStatistics::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ClusterAnchorValueStatistics");
}

void CLMicroLocationProto::ClusterAnchorValueStatisticsVector::MergeFrom(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this, const CLMicroLocationProto::ClusterAnchorValueStatisticsVector *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::ClusterAnchorValueStatisticsVector *)((char *)this + 8));
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      char v5 = *(const CLMicroLocationProto::ClusterAnchorValueStatistics **)(*((void *)a2 + 1) + 8 * v4);
      int v6 = *((_DWORD *)this + 5);
      uint64_t v7 = *((int *)this + 4);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 6))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::ClusterAnchorValueStatisticsVector *)((char *)this + 8));
          int v6 = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)this + 1);
      *((_DWORD *)this + 4) = v7 + 1;
      CLMicroLocationProto::ClusterAnchorValueStatistics::MergeFrom(*(CLMicroLocationProto::ClusterAnchorValueStatistics **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 4));
  }
}

void sub_256417A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ClusterAnchorValueStatisticsVector::~ClusterAnchorValueStatisticsVector(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this)
{
  *(void *)this = &unk_2704DE4E8;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ClusterAnchorValueStatisticsVector::~ClusterAnchorValueStatisticsVector(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ClusterAnchorValueStatisticsVector::New(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this)
{
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatisticsVector::Clear(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this)
{
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 8);
  *((_DWORD *)this + 9) = 0;
  return result;
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatisticsVector::MergePartialFromCodedStream(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (CLMicroLocationProto::ClusterAnchorValueStatisticsVector *)((char *)this + 8);
  while (1)
  {
LABEL_2:
    char v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
    }
    if (TagFallback == 10)
    {
      while (1)
      {
        int v7 = *((_DWORD *)this + 5);
        uint64_t v8 = *((int *)this + 4);
        if ((int)v8 >= v7)
        {
          if (v7 == *((_DWORD *)this + 6))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v4);
            int v7 = *((_DWORD *)this + 5);
          }
          *((_DWORD *)this + 5) = v7 + 1;
          operator new();
        }
        uint64_t v9 = *((void *)this + 1);
        *((_DWORD *)this + 4) = v8 + 1;
        int v10 = *(CLMicroLocationProto::ClusterAnchorValueStatistics **)(v9 + 8 * v8);
        unsigned int v20 = 0;
        uint64_t v11 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v11 >= *((void *)a2 + 2) || *v11 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v20))return 0; {
        }
          }
        else
        {
          unsigned int v20 = *v11;
          *((void *)a2 + 1) = v11 + 1;
        }
        int v12 = *((_DWORD *)a2 + 14);
        int v13 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v12 + 1;
        if (v12 >= v13) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ClusterAnchorValueStatistics::MergePartialFromCodedStream(v10, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v14 = *((_DWORD *)a2 + 14);
        BOOL v15 = __OFSUB__(v14, 1);
        int v16 = v14 - 1;
        if (v16 < 0 == v15) {
          *((_DWORD *)a2 + 14) = v16;
        }
        int v17 = (unsigned char *)*((void *)a2 + 1);
        BOOL v18 = (unsigned char *)*((void *)a2 + 2);
        if (v17 >= v18 || *v17 != 10)
        {
          if (v17 == v18 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
          {
            *((_DWORD *)a2 + 8) = 0;
            uint64_t result = 1;
            *((unsigned char *)a2 + 36) = 1;
            return result;
          }
          goto LABEL_2;
        }
        *((void *)a2 + 1) = v17 + 1;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatisticsVector::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(int *)(this + 16) >= 1)
  {
    uint64_t v5 = this;
    uint64_t v6 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return this;
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatisticsVector::ByteSize(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this)
{
  uint64_t v2 = *((unsigned int *)this + 4);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::ClusterAnchorValueStatistics::ByteSize(*(CLMicroLocationProto::ClusterAnchorValueStatistics **)(*((void *)this + 1) + 8 * v3));
      int v5 = (int)v4;
      if (v4 >= 0x80) {
        int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4);
      }
      else {
        int v6 = 1;
      }
      uint64_t v2 = (v5 + v2 + v6);
      ++v3;
    }
    while (v3 < *((int *)this + 4));
  }
  *((_DWORD *)this + 8) = v2;
  return v2;
}

void CLMicroLocationProto::ClusterAnchorValueStatisticsVector::CheckTypeAndMergeFrom(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ClusterAnchorValueStatisticsVector::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ClusterAnchorValueStatisticsVector::CopyFrom(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this, const CLMicroLocationProto::ClusterAnchorValueStatisticsVector *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ClusterAnchorValueStatisticsVector::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatisticsVector::IsInitialized(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this)
{
  return 1;
}

void *CLMicroLocationProto::ClusterAnchorValueStatisticsVector::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ClusterAnchorValueStatisticsVector");
}

void CLMicroLocationProto::LocationSimilarityListElement::MergeFrom(CLMicroLocationProto::LocationSimilarityListElement *this, const CLMicroLocationProto::LocationSimilarityListElement *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  int v4 = *((_DWORD *)a2 + 6);
  if (v4)
  {
    wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve((uint64_t)this + 16, *((_DWORD *)this + 6) + v4);
    memcpy((void *)(*((void *)this + 2) + 8 * *((int *)this + 6)), *((const void **)a2 + 2), 8 * *((int *)a2 + 6));
    *((_DWORD *)this + 6) += *((_DWORD *)a2 + 6);
  }
  if (*((unsigned char *)a2 + 36))
  {
    int v5 = (const std::string *)*((void *)a2 + 1);
    *((_DWORD *)this + 9) |= 1u;
    int v6 = (std::string *)*((void *)this + 1);
    if (v6 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v6, v5);
  }
}

void sub_256418090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::LocationSimilarityListElement::~LocationSimilarityListElement(CLMicroLocationProto::LocationSimilarityListElement *this)
{
  *(void *)this = &unk_2704DE560;
  CLMicroLocationProto::ClusterRecordings::SharedDtor(this);
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    MEMORY[0x25A2A6320](v2, 0x1000C8000313F17);
  }
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::LocationSimilarityListElement::~LocationSimilarityListElement(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::LocationSimilarityListElement::New(CLMicroLocationProto::LocationSimilarityListElement *this)
{
}

uint64_t CLMicroLocationProto::LocationSimilarityListElement::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 36))
  {
    uint64_t v1 = *(void *)(this + 8);
    if (v1 != MEMORY[0x263F8C740])
    {
      if (*(char *)(v1 + 23) < 0)
      {
        **(unsigned char **)uint64_t v1 = 0;
        *(void *)(v1 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v1 = 0;
        *(unsigned char *)(v1 + 23) = 0;
      }
    }
  }
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 36) = 0;
  return this;
}

uint64_t CLMicroLocationProto::LocationSimilarityListElement::MergePartialFromCodedStream(CLMicroLocationProto::LocationSimilarityListElement *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  int v4 = (char *)this + 16;
  while (1)
  {
    while (1)
    {
      int v5 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v5;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if (v7 != 2) {
        goto LABEL_21;
      }
      *((_DWORD *)this + 9) |= 1u;
      if (*((void *)this + 1) == MEMORY[0x263F8C740]) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
      if (!result) {
        return result;
      }
      uint64_t v9 = (unsigned char *)*((void *)a2 + 1);
      if ((unint64_t)v9 < *((void *)a2 + 2) && *v9 == 17)
      {
        do
        {
          *((void *)a2 + 1) = v9 + 1;
LABEL_25:
          v21[0] = 0;
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, v21) & 1) == 0) {
            return 0;
          }
          unint64_t v10 = v21[0];
          int v11 = *((_DWORD *)this + 6);
          if (v11 == *((_DWORD *)this + 7))
          {
            wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve((uint64_t)v4, v11 + 1);
            int v11 = *((_DWORD *)this + 6);
          }
          uint64_t v12 = *((void *)this + 2);
          int v13 = v11 + 1;
          *((_DWORD *)this + 6) = v11 + 1;
          *(void *)(v12 + 8 * v11) = v10;
          uint64_t v14 = *((void *)a2 + 1);
          int v15 = *((_DWORD *)a2 + 4) - v14;
          if (v15 >= 1)
          {
            signed int v16 = v15 / 9u;
            int v17 = v16 >= *((_DWORD *)this + 7) - v13 ? *((_DWORD *)this + 7) - v13 : v16;
            if (v17 >= 1)
            {
              int v18 = 0;
              while (*(unsigned char *)v14 == 17)
              {
                uint64_t v19 = *(void *)(v14 + 1);
                if (v13 >= *((_DWORD *)this + 7))
                {
                  wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
                  wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
                  wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
                  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v21);
                  int v13 = *((_DWORD *)this + 6);
                  uint64_t v12 = *((void *)this + 2);
                }
                *((_DWORD *)this + 6) = v13 + 1;
                *(void *)(v12 + 8 * v13) = v19;
                ++v18;
                v14 += 9;
                ++v13;
                if (v17 == v18)
                {
                  int v18 = v17;
                  break;
                }
              }
              if (v18) {
                wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip(a2);
              }
            }
          }
LABEL_41:
          uint64_t v9 = (unsigned char *)*((void *)a2 + 1);
          unsigned int v20 = (unsigned char *)*((void *)a2 + 2);
        }
        while (v9 < v20 && *v9 == 17);
        if (v9 == v20 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2) {
      break;
    }
    int v7 = TagFallback & 7;
LABEL_21:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  int v7 = TagFallback & 7;
  if (v7 == 1) {
    goto LABEL_25;
  }
  if (v7 != 2) {
    goto LABEL_21;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<double,(wireless_diagnostics::google::protobuf::internal::WireFormatLite::FieldType)1>(a2, (uint64_t)v4);
  if (result) {
    goto LABEL_41;
  }
  return result;
}

void sub_2564184E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<double,(wireless_diagnostics::google::protobuf::internal::WireFormatLite::FieldType)1>(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2)
{
  unsigned int v9 = 0;
  int v4 = (char *)*((void *)this + 1);
  if ((unint64_t)v4 >= *((void *)this + 2) || *v4 < 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v9);
    if (!result) {
      return result;
    }
  }
  else
  {
    unsigned int v9 = *v4;
    *((void *)this + 1) = v4 + 1;
  }
  wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this);
  if ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) < 1)
  {
LABEL_10:
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this);
    return 1;
  }
  else
  {
    while (1)
    {
      unint64_t v10 = 0;
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v10);
      if (!result) {
        break;
      }
      unint64_t v6 = v10;
      int v7 = *(_DWORD *)(a2 + 8);
      if (v7 == *(_DWORD *)(a2 + 12))
      {
        wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve(a2, v7 + 1);
        int v7 = *(_DWORD *)(a2 + 8);
      }
      uint64_t v8 = *(void *)a2;
      *(_DWORD *)(a2 + 8) = v7 + 1;
      *(void *)(v8 + 8 * v7) = v6;
      if ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) <= 0) {
        goto LABEL_10;
      }
    }
  }
  return result;
}

uint64_t CLMicroLocationProto::LocationSimilarityListElement::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3)
{
  uint64_t v4 = this;
  if (*(unsigned char *)(this + 36)) {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  }
  if (*(int *)(v4 + 24) >= 1)
  {
    uint64_t v5 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(*(void *)(v4 + 16) + 8 * v5++), a3);
    while (v5 < *(int *)(v4 + 24));
  }
  return this;
}

uint64_t CLMicroLocationProto::LocationSimilarityListElement::ByteSize(CLMicroLocationProto::LocationSimilarityListElement *this)
{
  if (*((unsigned char *)this + 36))
  {
    uint64_t v3 = *((void *)this + 1);
    int v4 = *(unsigned __int8 *)(v3 + 23);
    char v5 = v4;
    uint64_t v6 = *(void *)(v3 + 8);
    if ((v4 & 0x80u) == 0) {
      unint64_t v7 = *(unsigned __int8 *)(v3 + 23);
    }
    else {
      unint64_t v7 = v6;
    }
    if (v7 >= 0x80)
    {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v7);
      int v4 = *(unsigned __int8 *)(v3 + 23);
      uint64_t v6 = *(void *)(v3 + 8);
      int v8 = v9 + 1;
      char v5 = *(unsigned char *)(v3 + 23);
    }
    else
    {
      int v8 = 2;
    }
    if (v5 < 0) {
      int v4 = v6;
    }
    int v2 = v8 + v4;
  }
  else
  {
    int v2 = 0;
  }
  uint64_t result = (9 * *((_DWORD *)this + 6) + v2);
  *((_DWORD *)this + 8) = result;
  return result;
}

void CLMicroLocationProto::LocationSimilarityListElement::CheckTypeAndMergeFrom(CLMicroLocationProto::LocationSimilarityListElement *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::LocationSimilarityListElement::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::LocationSimilarityListElement::IsInitialized(CLMicroLocationProto::LocationSimilarityListElement *this)
{
  return 1;
}

void *CLMicroLocationProto::LocationSimilarityListElement::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.LocationSimilarityListElement");
}

void CLMicroLocationProto::LocationSimilarityListData::MergeFrom(CLMicroLocationProto::LocationSimilarityListData *this, const CLMicroLocationProto::LocationSimilarityListData *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v19);
  }
  int v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::LocationSimilarityListData *)((char *)this + 8));
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(const std::string **)(*((void *)a2 + 1) + 8 * v5);
      int v7 = *((_DWORD *)this + 5);
      uint64_t v8 = *((int *)this + 4);
      if ((int)v8 >= v7)
      {
        if (v7 == *((_DWORD *)this + 6))
        {
          int v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::LocationSimilarityListData *)((char *)this + 8));
          int v7 = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v7 + 1;
        unint64_t v10 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(v4);
        uint64_t v11 = *((void *)this + 1);
        uint64_t v12 = *((int *)this + 4);
        *((_DWORD *)this + 4) = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }
      else
      {
        uint64_t v9 = *((void *)this + 1);
        *((_DWORD *)this + 4) = v8 + 1;
        unint64_t v10 = *(std::string **)(v9 + 8 * v8);
      }
      int v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)std::string::operator=(v10, v6);
      ++v5;
    }
    while (v5 < *((int *)a2 + 4));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::LocationSimilarityListData *)((char *)this + 32));
  if (*((int *)a2 + 10) >= 1)
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = *(const CLMicroLocationProto::LocationSimilarityListElement **)(*((void *)a2 + 4) + 8 * v13);
      int v15 = *((_DWORD *)this + 11);
      uint64_t v16 = *((int *)this + 10);
      if ((int)v16 >= v15)
      {
        if (v15 == *((_DWORD *)this + 12))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::LocationSimilarityListData *)((char *)this + 32));
          int v15 = *((_DWORD *)this + 11);
        }
        *((_DWORD *)this + 11) = v15 + 1;
        operator new();
      }
      uint64_t v17 = *((void *)this + 4);
      *((_DWORD *)this + 10) = v16 + 1;
      CLMicroLocationProto::LocationSimilarityListElement::MergeFrom(*(CLMicroLocationProto::LocationSimilarityListElement **)(v17 + 8 * v16), v14);
      ++v13;
    }
    while (v13 < *((int *)a2 + 10));
  }
  int v18 = *((_DWORD *)a2 + 16);
  if (v18)
  {
    wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve((uint64_t)this + 56, *((_DWORD *)this + 16) + v18);
    memcpy((void *)(*((void *)this + 7) + 4 * *((int *)this + 16)), *((const void **)a2 + 7), 4 * *((int *)a2 + 16));
    *((_DWORD *)this + 16) += *((_DWORD *)a2 + 16);
  }
}

void sub_2564189EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::LocationSimilarityListData::~LocationSimilarityListData(CLMicroLocationProto::LocationSimilarityListData *this)
{
  *(void *)this = &unk_2704DE5D8;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    MEMORY[0x25A2A6320](v2, 0x1000C8052888210);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 4);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((int *)this + 2);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::LocationSimilarityListData::~LocationSimilarityListData(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::LocationSimilarityListData::New(CLMicroLocationProto::LocationSimilarityListData *this)
{
}

uint64_t CLMicroLocationProto::LocationSimilarityListData::Clear(CLMicroLocationProto::LocationSimilarityListData *this)
{
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((uint64_t)this + 8);
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 32);
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 19) = 0;
  return result;
}

uint64_t CLMicroLocationProto::LocationSimilarityListData::MergePartialFromCodedStream(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = this + 56;
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(this + 8);
  uint64_t v6 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(this + 32);
  while (1)
  {
    while (1)
    {
      while (1)
      {
LABEL_2:
        int v7 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v7 >= *((void *)a2 + 2) || *v7 < 0)
        {
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)this;
          *((_DWORD *)a2 + 8) = this;
          if (!this) {
            return 1;
          }
        }
        else
        {
          uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v7;
          *((_DWORD *)a2 + 8) = v8;
          *((void *)a2 + 1) = v7 + 1;
          if (!v8) {
            return 1;
          }
        }
        unsigned int v9 = v8 >> 3;
        if (v8 >> 3 != 1) {
          break;
        }
        int v10 = v8 & 7;
        if (v10 != 2) {
          goto LABEL_26;
        }
        while (1)
        {
          int v13 = *(_DWORD *)(v3 + 20);
          int v14 = *(_DWORD *)(v3 + 16);
          if (v14 >= v13)
          {
            if (v13 == *(_DWORD *)(v3 + 24))
            {
              this = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5);
              int v13 = *(_DWORD *)(v3 + 20);
            }
            *(_DWORD *)(v3 + 20) = v13 + 1;
            uint64_t v15 = wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New((wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)this);
            uint64_t v16 = *(void *)(v3 + 8);
            uint64_t v17 = *(int *)(v3 + 16);
            *(_DWORD *)(v3 + 16) = v17 + 1;
            *(void *)(v16 + 8 * v17) = v15;
          }
          else
          {
            *(_DWORD *)(v3 + 16) = v14 + 1;
          }
          this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!this) {
            return this;
          }
          int v18 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v18 >= *((void *)a2 + 2)) {
            break;
          }
          int v19 = *v18;
          if (v19 != 10)
          {
            if (v19 != 18) {
              goto LABEL_2;
            }
            goto LABEL_32;
          }
          *((void *)a2 + 1) = v18 + 1;
        }
      }
      if (v9 != 2) {
        break;
      }
      int v10 = v8 & 7;
      if (v10 != 2) {
        goto LABEL_26;
      }
      while (1)
      {
        int v20 = *(_DWORD *)(v3 + 44);
        uint64_t v21 = *(int *)(v3 + 40);
        if ((int)v21 >= v20)
        {
          if (v20 == *(_DWORD *)(v3 + 48))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v6);
            int v20 = *(_DWORD *)(v3 + 44);
          }
          *(_DWORD *)(v3 + 44) = v20 + 1;
          operator new();
        }
        uint64_t v22 = *(void *)(v3 + 32);
        *(_DWORD *)(v3 + 40) = v21 + 1;
        unsigned int v23 = *(CLMicroLocationProto::LocationSimilarityListElement **)(v22 + 8 * v21);
        unsigned int v36 = 0;
        int v24 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v24 >= *((void *)a2 + 2) || *v24 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v36))return 0; {
        }
          }
        else
        {
          unsigned int v36 = *v24;
          *((void *)a2 + 1) = v24 + 1;
        }
        int v25 = *((_DWORD *)a2 + 14);
        int v26 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v25 + 1;
        if (v25 >= v26) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::LocationSimilarityListElement::MergePartialFromCodedStream(v23, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        this = wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v27 = *((_DWORD *)a2 + 14);
        BOOL v28 = __OFSUB__(v27, 1);
        int v29 = v27 - 1;
        if (v29 < 0 == v28) {
          *((_DWORD *)a2 + 14) = v29;
        }
        int v18 = (char *)*((void *)a2 + 1);
        uint64_t v11 = (char *)*((void *)a2 + 2);
        if (v18 >= v11) {
          break;
        }
        int v30 = *v18;
        if (v30 != 18)
        {
          if (v30 == 24)
          {
            do
            {
              uint64_t v12 = v18 + 1;
              *((void *)a2 + 1) = v12;
LABEL_51:
              unsigned int v35 = 0;
              if (v12 >= v11 || *v12 < 0)
              {
                this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v35);
                if (!this) {
                  return this;
                }
                unsigned int v31 = v35;
              }
              else
              {
                unsigned int v31 = *v12;
                *((void *)a2 + 1) = v12 + 1;
              }
              if (v31 < 4 || v31 == 15)
              {
                int v33 = *(_DWORD *)(v3 + 64);
                if (v33 == *(_DWORD *)(v3 + 68))
                {
                  this = wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve(v4, v33 + 1);
                  int v33 = *(_DWORD *)(v3 + 64);
                }
                uint64_t v34 = *(void *)(v3 + 56);
                *(_DWORD *)(v3 + 64) = v33 + 1;
                *(_DWORD *)(v34 + 4 * v33) = v31;
              }
LABEL_64:
              int v18 = (char *)*((void *)a2 + 1);
              uint64_t v11 = (char *)*((void *)a2 + 2);
            }
            while (v18 < v11 && *v18 == 24);
            if (v18 == v11 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
            {
              *((_DWORD *)a2 + 8) = 0;
              this = 1;
              *((unsigned char *)a2 + 36) = 1;
              return this;
            }
          }
          goto LABEL_2;
        }
LABEL_32:
        *((void *)a2 + 1) = v18 + 1;
      }
    }
    if (v9 != 3)
    {
      int v10 = v8 & 7;
      goto LABEL_26;
    }
    int v10 = v8 & 7;
    if (v10 == 2) {
      break;
    }
    if ((v8 & 7) == 0)
    {
      uint64_t v12 = (char *)*((void *)a2 + 1);
      uint64_t v11 = (char *)*((void *)a2 + 2);
      goto LABEL_51;
    }
LABEL_26:
    if (v10 == 4) {
      return 1;
    }
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, v8);
    if ((this & 1) == 0) {
      return 0;
    }
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline();
  if (this) {
    goto LABEL_64;
  }
  return this;
}

uint64_t CLMicroLocationProto::LocationSimilarityListData::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  if (*(int *)(this + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
      ++v6;
    }
    while (v6 < *(int *)(v5 + 16));
  }
  if (*(int *)(v5 + 40) >= 1)
  {
    uint64_t v7 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(*(void *)(v5 + 32) + 8 * v7++), a2, a4);
    while (v7 < *(int *)(v5 + 40));
  }
  if (*(int *)(v5 + 64) >= 1)
  {
    uint64_t v8 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned int *)(*(void *)(v5 + 56) + 4 * v8++), (uint64_t)a2, a4);
    while (v8 < *(int *)(v5 + 64));
  }
  return this;
}

uint64_t CLMicroLocationProto::LocationSimilarityListData::ByteSize(CLMicroLocationProto::LocationSimilarityListData *this)
{
  int v2 = *((_DWORD *)this + 4);
  if (v2 < 1)
  {
    int v4 = *((_DWORD *)this + 4);
  }
  else
  {
    uint64_t v3 = 0;
    int v4 = *((_DWORD *)this + 4);
    do
    {
      uint64_t v5 = *(void *)(*((void *)this + 1) + 8 * v3);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      char v7 = v6;
      uint64_t v8 = *(void *)(v5 + 8);
      if ((v6 & 0x80u) == 0) {
        unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
      }
      else {
        unint64_t v9 = v8;
      }
      if (v9 >= 0x80)
      {
        int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
        int v6 = *(unsigned __int8 *)(v5 + 23);
        uint64_t v8 = *(void *)(v5 + 8);
        int v2 = *((_DWORD *)this + 4);
        char v7 = *(unsigned char *)(v5 + 23);
      }
      else
      {
        int v10 = 1;
      }
      if (v7 < 0) {
        int v6 = v8;
      }
      v4 += v10 + v6;
      ++v3;
    }
    while (v3 < v2);
  }
  int v11 = *((_DWORD *)this + 10);
  int v12 = v11 + v4;
  if (v11 >= 1)
  {
    uint64_t v13 = 0;
    do
    {
      int v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::LocationSimilarityListElement::ByteSize(*(CLMicroLocationProto::LocationSimilarityListElement **)(*((void *)this + 4) + 8 * v13));
      int v15 = (int)v14;
      if (v14 >= 0x80) {
        int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14);
      }
      else {
        int v16 = 1;
      }
      v12 += v15 + v16;
      ++v13;
    }
    while (v13 < *((int *)this + 10));
  }
  int v17 = *((_DWORD *)this + 16);
  if (v17 < 1)
  {
    int v19 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    int v19 = 0;
    do
    {
      int v20 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*((void *)this + 7)
                                                                                             + 4 * v18);
      if ((v20 & 0x80000000) != 0)
      {
        int v21 = 10;
      }
      else if (v20 >= 0x80)
      {
        int v21 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v20);
        int v17 = *((_DWORD *)this + 16);
      }
      else
      {
        int v21 = 1;
      }
      v19 += v21;
      ++v18;
    }
    while (v18 < v17);
  }
  uint64_t result = (v19 + v12 + v17);
  *((_DWORD *)this + 18) = result;
  return result;
}

void CLMicroLocationProto::LocationSimilarityListData::CheckTypeAndMergeFrom(CLMicroLocationProto::LocationSimilarityListData *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::LocationSimilarityListData::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::LocationSimilarityListData::CopyFrom(CLMicroLocationProto::LocationSimilarityListData *this, const CLMicroLocationProto::LocationSimilarityListData *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::LocationSimilarityListData *))(*(void *)this + 32))(this);
    CLMicroLocationProto::LocationSimilarityListData::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::LocationSimilarityListData::IsInitialized(CLMicroLocationProto::LocationSimilarityListData *this)
{
  return 1;
}

void *CLMicroLocationProto::LocationSimilarityListData::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.LocationSimilarityListData");
}

float CLMicroLocationProto::BlueAtlasData::MergeFrom(CLMicroLocationProto::BlueAtlasData *this, const CLMicroLocationProto::BlueAtlasData *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v17);
  }
  int v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::BlueAtlasData *)((char *)this + 8));
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      char v7 = *(const std::string **)(*((void *)a2 + 1) + 8 * v6);
      int v8 = *((_DWORD *)this + 5);
      uint64_t v9 = *((int *)this + 4);
      if ((int)v9 >= v8)
      {
        if (v8 == *((_DWORD *)this + 6))
        {
          int v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::BlueAtlasData *)((char *)this + 8));
          int v8 = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v8 + 1;
        int v11 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(v4);
        uint64_t v12 = *((void *)this + 1);
        uint64_t v13 = *((int *)this + 4);
        *((_DWORD *)this + 4) = v13 + 1;
        *(void *)(v12 + 8 * v13) = v11;
      }
      else
      {
        uint64_t v10 = *((void *)this + 1);
        *((_DWORD *)this + 4) = v9 + 1;
        int v11 = *(std::string **)(v10 + 8 * v9);
      }
      int v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)std::string::operator=(v11, v7);
      ++v6;
    }
    while (v6 < *((int *)a2 + 4));
  }
  int v14 = *((_DWORD *)a2 + 10);
  if (v14)
  {
    wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve((uint64_t)this + 32, *((_DWORD *)this + 10) + v14);
    int v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)memcpy((void *)(*((void *)this + 4)+ 8 * *((int *)this + 10)), *((const void **)a2 + 4), 8 * *((int *)a2 + 10));
    *((_DWORD *)this + 10) += *((_DWORD *)a2 + 10);
  }
  if ((*((unsigned char *)a2 + 60) & 4) != 0)
  {
    *((_DWORD *)this + 15) |= 4u;
    int v15 = (CLMicroLocationProto::AssociatedAccessPointInfo *)*((void *)this + 6);
    if (!v15) {
      operator new();
    }
    int v16 = (const CLMicroLocationProto::AssociatedAccessPointInfo *)*((void *)a2 + 6);
    if (!v16)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(v4);
      int v16 = *(const CLMicroLocationProto::AssociatedAccessPointInfo **)(CLMicroLocationProto::BlueAtlasData::default_instance_
                                                                      + 48);
    }
    return CLMicroLocationProto::AssociatedAccessPointInfo::MergeFrom(v15, v16);
  }
  return result;
}

void sub_256419468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::BlueAtlasData::~BlueAtlasData(CLMicroLocationProto::BlueAtlasData *this)
{
  *(void *)this = &unk_2704DE650;
  CLMicroLocationProto::BlueAtlasData::SharedDtor(this);
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    MEMORY[0x25A2A6320](v2, 0x1000C8000313F17);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((int *)this + 2);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::BlueAtlasData::~BlueAtlasData(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::BlueAtlasData::SharedDtor(CLMicroLocationProto::BlueAtlasData *this)
{
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::BlueAtlasData *)CLMicroLocationProto::BlueAtlasData::default_instance_ != this)
  {
    uint64_t v2 = *((void *)this + 6);
    if (v2)
    {
      uint64_t v3 = *(void (**)(void))(*(void *)v2 + 8);
      v3();
    }
  }
}

uint64_t CLMicroLocationProto::BlueAtlasData::default_instance(CLMicroLocationProto::BlueAtlasData *this)
{
  return CLMicroLocationProto::BlueAtlasData::default_instance_;
}

void CLMicroLocationProto::BlueAtlasData::New(CLMicroLocationProto::BlueAtlasData *this)
{
}

uint64_t CLMicroLocationProto::BlueAtlasData::Clear(CLMicroLocationProto::BlueAtlasData *this)
{
  if ((*((unsigned char *)this + 60) & 4) != 0)
  {
    uint64_t v2 = *((void *)this + 6);
    if (v2)
    {
      if (*(unsigned char *)(v2 + 24))
      {
        *(void *)(v2 + 8) = 0;
        *(_DWORD *)(v2 + 16) = 0;
      }
      *(_DWORD *)(v2 + 24) = 0;
    }
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>((uint64_t)this + 8);
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 15) = 0;
  return result;
}

uint64_t CLMicroLocationProto::AssociatedAccessPointInfo::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 24))
  {
    *(void *)(this + 8) = 0;
    *(_DWORD *)(this + 16) = 0;
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::BlueAtlasData::MergePartialFromCodedStream(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = this + 32;
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(this + 8);
  while (1)
  {
LABEL_2:
    uint64_t v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      char v7 = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)this;
      *((_DWORD *)a2 + 8) = this;
      if (!this) {
        return 1;
      }
    }
    else
    {
      char v7 = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v6;
      *((_DWORD *)a2 + 8) = v7;
      *((void *)a2 + 1) = v6 + 1;
      if (!v7) {
        return 1;
      }
    }
    unsigned int v8 = v7 >> 3;
    if (v7 >> 3 == 1) {
      break;
    }
    if (v8 == 2)
    {
      int v9 = v7 & 7;
      if (v9 == 2)
      {
        this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<unsigned long long,(wireless_diagnostics::google::protobuf::internal::WireFormatLite::FieldType)4>(a2, v4);
        if (this) {
          goto LABEL_51;
        }
        return this;
      }
      if ((v7 & 7) == 0)
      {
        uint64_t v18 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_33;
      }
LABEL_26:
      if (v9 == 4) {
        return 1;
      }
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, v7);
      if ((this & 1) == 0) {
        return 0;
      }
    }
    else
    {
      if (v8 != 3)
      {
        int v9 = v7 & 7;
        goto LABEL_26;
      }
      int v9 = v7 & 7;
      if (v9 != 2) {
        goto LABEL_26;
      }
LABEL_54:
      *(_DWORD *)(v3 + 60) |= 4u;
      int v29 = *(CLMicroLocationProto::AssociatedAccessPointInfo **)(v3 + 48);
      if (!v29) {
        operator new();
      }
      v37[0] = 0;
      int v30 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v30 >= *((void *)a2 + 2) || *v30 < 0)
      {
        if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v37)) {
          return 0;
        }
      }
      else
      {
        v37[0] = *v30;
        *((void *)a2 + 1) = v30 + 1;
      }
      int v31 = *((_DWORD *)a2 + 14);
      int v32 = *((_DWORD *)a2 + 15);
      *((_DWORD *)a2 + 14) = v31 + 1;
      if (v31 >= v32) {
        return 0;
      }
      wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
      if (!CLMicroLocationProto::AssociatedAccessPointInfo::MergePartialFromCodedStream(v29, a2)
        || !*((unsigned char *)a2 + 36))
      {
        return 0;
      }
      this = wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
      int v33 = *((_DWORD *)a2 + 14);
      BOOL v34 = __OFSUB__(v33, 1);
      int v35 = v33 - 1;
      if (v35 < 0 == v34) {
        *((_DWORD *)a2 + 14) = v35;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        this = 1;
        *((unsigned char *)a2 + 36) = 1;
        return this;
      }
    }
  }
  int v9 = v7 & 7;
  if (v9 != 2) {
    goto LABEL_26;
  }
  while (1)
  {
    int v10 = *(_DWORD *)(v3 + 20);
    int v11 = *(_DWORD *)(v3 + 16);
    if (v11 >= v10)
    {
      if (v10 == *(_DWORD *)(v3 + 24))
      {
        this = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5);
        int v10 = *(_DWORD *)(v3 + 20);
      }
      *(_DWORD *)(v3 + 20) = v10 + 1;
      uint64_t v12 = wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New((wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)this);
      uint64_t v13 = *(void *)(v3 + 8);
      uint64_t v14 = *(int *)(v3 + 16);
      *(_DWORD *)(v3 + 16) = v14 + 1;
      *(void *)(v13 + 8 * v14) = v12;
    }
    else
    {
      *(_DWORD *)(v3 + 16) = v11 + 1;
    }
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
    if (!this) {
      return this;
    }
    int v16 = (unsigned __int8 *)*((void *)a2 + 1);
    unint64_t v15 = *((void *)a2 + 2);
    if ((unint64_t)v16 >= v15) {
      goto LABEL_2;
    }
    int v17 = *v16;
    if (v17 != 10)
    {
      while (v17 == 16)
      {
        uint64_t v18 = (char *)(v16 + 1);
        *((void *)a2 + 1) = v18;
LABEL_33:
        unint64_t v36 = 0;
        if ((unint64_t)v18 >= v15 || *v18 < 0)
        {
          this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, &v36);
          if (!this) {
            return 0;
          }
        }
        else
        {
          unint64_t v36 = *v18;
          *((void *)a2 + 1) = v18 + 1;
        }
        int v19 = *(_DWORD *)(v3 + 40);
        int v20 = *(_DWORD *)(v3 + 44);
        if (v19 == v20)
        {
          this = wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve(v4, v19 + 1);
          int v19 = *(_DWORD *)(v3 + 40);
          int v20 = *(_DWORD *)(v3 + 44);
        }
        unint64_t v21 = v36;
        uint64_t v22 = *(void *)(v3 + 32);
        int v23 = v19 + 1;
        *(_DWORD *)(v3 + 40) = v19 + 1;
        *(void *)(v22 + 8 * v19) = v21;
        if (v20 - (v19 + 1) >= 1)
        {
          int v24 = v20 - v19;
          do
          {
            int v25 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v26 = *((void *)a2 + 2);
            if ((unint64_t)v25 >= v26 || *v25 != 16) {
              break;
            }
            *((void *)a2 + 1) = v25 + 1;
            if ((unint64_t)(v25 + 1) >= v26 || (char)v25[1] < 0)
            {
              this = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, &v36);
              if (!this) {
                return 0;
              }
              int v23 = *(_DWORD *)(v3 + 40);
            }
            else
            {
              unint64_t v36 = v25[1];
              *((void *)a2 + 1) = v25 + 2;
            }
            if (v23 >= *(_DWORD *)(v3 + 44))
            {
              wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
              wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
              wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
              wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v37);
              int v23 = *(_DWORD *)(v3 + 40);
            }
            unint64_t v27 = v36;
            uint64_t v28 = *(void *)(v3 + 32);
            *(_DWORD *)(v3 + 40) = v23 + 1;
            *(void *)(v28 + 8 * v23) = v27;
            --v24;
            ++v23;
          }
          while (v24 > 1);
        }
LABEL_51:
        int v16 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        if ((unint64_t)v16 >= v15) {
          break;
        }
        int v17 = *v16;
        if (v17 == 26)
        {
          *((void *)a2 + 1) = v16 + 1;
          goto LABEL_54;
        }
      }
      goto LABEL_2;
    }
    *((void *)a2 + 1) = v16 + 1;
  }
}

void sub_256419ADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<unsigned long long,(wireless_diagnostics::google::protobuf::internal::WireFormatLite::FieldType)4>(wireless_diagnostics::google::protobuf::io::CodedInputStream *this, uint64_t a2)
{
  unsigned int v11 = 0;
  uint64_t v4 = (char *)*((void *)this + 1);
  if ((unint64_t)v4 >= *((void *)this + 2) || *v4 < 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v11);
    if (!result) {
      return result;
    }
  }
  else
  {
    unsigned int v11 = *v4;
    *((void *)this + 1) = v4 + 1;
  }
  wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this);
  if ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) >= 1)
  {
    do
    {
      unint64_t v10 = 0;
      uint64_t v6 = (char *)*((void *)this + 1);
      if ((unint64_t)v6 >= *((void *)this + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(this, &v10);
        if (!result) {
          return result;
        }
      }
      else
      {
        unint64_t v10 = *v6;
        *((void *)this + 1) = v6 + 1;
      }
      int v7 = *(_DWORD *)(a2 + 8);
      if (v7 == *(_DWORD *)(a2 + 12))
      {
        wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve(a2, v7 + 1);
        int v7 = *(_DWORD *)(a2 + 8);
      }
      unint64_t v8 = v10;
      uint64_t v9 = *(void *)a2;
      *(_DWORD *)(a2 + 8) = v7 + 1;
      *(void *)(v9 + 8 * v7) = v8;
    }
    while ((int)wireless_diagnostics::google::protobuf::io::CodedInputStream::BytesUntilLimit(this) > 0);
  }
  wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this);
  return 1;
}

int *CLMicroLocationProto::BlueAtlasData::SerializeWithCachedSizes(int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  if (this[4] >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
      ++v6;
    }
    while (v6 < v5[4]);
  }
  if (v5[10] >= 1)
  {
    uint64_t v7 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(*((void *)v5 + 4) + 8 * v7++), (uint64_t)a2, a4);
    while (v7 < v5[10]);
  }
  if ((v5[15] & 4) != 0)
  {
    uint64_t v8 = *((void *)v5 + 6);
    if (!v8)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
      uint64_t v8 = *(void *)(CLMicroLocationProto::BlueAtlasData::default_instance_ + 48);
    }
    return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v8, a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::BlueAtlasData::ByteSize(CLMicroLocationProto::BlueAtlasData *this)
{
  if ((*((unsigned char *)this + 60) & 4) != 0)
  {
    uint64_t v3 = (CLMicroLocationProto::AssociatedAccessPointInfo *)*((void *)this + 6);
    if (!v3)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      uint64_t v3 = *(CLMicroLocationProto::AssociatedAccessPointInfo **)(CLMicroLocationProto::BlueAtlasData::default_instance_
                                                               + 48);
    }
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::AssociatedAccessPointInfo::ByteSize(v3);
    int v5 = (int)v4;
    if (v4 >= 0x80) {
      int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4);
    }
    else {
      int v6 = 1;
    }
    int v2 = v5 + v6 + 1;
  }
  else
  {
    int v2 = 0;
  }
  int v7 = *((_DWORD *)this + 4);
  int v8 = v7 + v2;
  if (v7 >= 1)
  {
    for (uint64_t i = 0; i < v7; ++i)
    {
      uint64_t v10 = *(void *)(*((void *)this + 1) + 8 * i);
      int v11 = *(unsigned __int8 *)(v10 + 23);
      char v12 = v11;
      uint64_t v13 = *(void *)(v10 + 8);
      if ((v11 & 0x80u) == 0) {
        unint64_t v14 = *(unsigned __int8 *)(v10 + 23);
      }
      else {
        unint64_t v14 = v13;
      }
      if (v14 >= 0x80)
      {
        int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v14);
        int v11 = *(unsigned __int8 *)(v10 + 23);
        uint64_t v13 = *(void *)(v10 + 8);
        int v7 = *((_DWORD *)this + 4);
        char v12 = *(unsigned char *)(v10 + 23);
      }
      else
      {
        int v15 = 1;
      }
      if (v12 < 0) {
        int v11 = v13;
      }
      v8 += v15 + v11;
    }
  }
  LODWORD(v16) = *((_DWORD *)this + 10);
  if ((int)v16 < 1)
  {
    int v18 = 0;
  }
  else
  {
    uint64_t v17 = 0;
    int v18 = 0;
    do
    {
      v18 += wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(*((void *)this + 4) + 8 * v17++));
      uint64_t v16 = *((int *)this + 10);
    }
    while (v17 < v16);
  }
  uint64_t result = (v18 + v8 + v16);
  *((_DWORD *)this + 14) = result;
  return result;
}

float CLMicroLocationProto::BlueAtlasData::CheckTypeAndMergeFrom(CLMicroLocationProto::BlueAtlasData *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  return CLMicroLocationProto::BlueAtlasData::MergeFrom(this, lpsrc);
}

float CLMicroLocationProto::AssociatedAccessPointInfo::MergeFrom(CLMicroLocationProto::AssociatedAccessPointInfo *this, const CLMicroLocationProto::AssociatedAccessPointInfo *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v5) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v5)
  {
    if (*((unsigned char *)a2 + 24))
    {
      uint64_t v6 = *((void *)a2 + 1);
      *((_DWORD *)this + 6) |= 1u;
      *((void *)this + 1) = v6;
      int v5 = *((_DWORD *)a2 + 6);
    }
    if ((v5 & 2) != 0)
    {
      float result = *((float *)a2 + 4);
      *((_DWORD *)this + 6) |= 2u;
      *((float *)this + 4) = result;
    }
  }
  return result;
}

void sub_256419F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

float CLMicroLocationProto::BlueAtlasData::CopyFrom(CLMicroLocationProto::BlueAtlasData *this, const CLMicroLocationProto::BlueAtlasData *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::BlueAtlasData *))(*(void *)this + 32))(this);
    return CLMicroLocationProto::BlueAtlasData::MergeFrom(this, a2);
  }
  return result;
}

uint64_t CLMicroLocationProto::BlueAtlasData::IsInitialized(CLMicroLocationProto::BlueAtlasData *this)
{
  return 1;
}

void *CLMicroLocationProto::BlueAtlasData::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.BlueAtlasData");
}

CLMicroLocationProto::Model *CLMicroLocationProto::Model::Model(CLMicroLocationProto::Model *this, const CLMicroLocationProto::Model *a2)
{
  *(void *)this = &unk_2704DE6C8;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 24) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 108) = 0u;
  *(_OWORD *)((char *)this + 124) = 0u;
  *(_OWORD *)((char *)this + 140) = 0u;
  *(_OWORD *)((char *)this + 156) = 0u;
  *((_DWORD *)this + 43) = 0;
  *((void *)this + 22) = MEMORY[0x263F8C740];
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 50) = 0;
  CLMicroLocationProto::Model::MergeFrom(this, a2);
  return this;
}

void sub_25641A0A0(_Unwind_Exception *a1)
{
  uint64_t v6 = *((void *)v1 + 17);
  if (v6) {
    MEMORY[0x25A2A6320](v6, 0x1000C8052888210);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(v4);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(v3);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(v2);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

float CLMicroLocationProto::Model::MergeFrom(CLMicroLocationProto::Model *this, const CLMicroLocationProto::Model *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v36);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::MergeFrom<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Fingerprint>::TypeHandler>((int *)this + 2, (uint64_t)a2 + 8);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::Model *)((char *)this + 56));
  if (*((int *)a2 + 16) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      int v5 = *(const CLMicroLocationProto::ClusterRecordings **)(*((void *)a2 + 7) + 8 * v4);
      int v6 = *((_DWORD *)this + 17);
      uint64_t v7 = *((int *)this + 16);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 18))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::Model *)((char *)this + 56));
          int v6 = *((_DWORD *)this + 17);
        }
        *((_DWORD *)this + 17) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)this + 7);
      *((_DWORD *)this + 16) = v7 + 1;
      CLMicroLocationProto::ClusterRecordings::MergeFrom(*(CLMicroLocationProto::ClusterRecordings **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 16));
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::MergeFrom<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::AnchorMetadata>::TypeHandler>((int *)this + 20, (uint64_t)a2 + 80);
  int v11 = *((_DWORD *)a2 + 36);
  if (v11)
  {
    wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve((uint64_t)this + 136, *((_DWORD *)this + 36) + v11);
    uint64_t v9 = (CLMicroLocationProto *)memcpy((void *)(*((void *)this + 17) + 4 * *((int *)this + 36)), *((const void **)a2 + 17), 4 * *((int *)a2 + 36));
    *((_DWORD *)this + 36) += *((_DWORD *)a2 + 36);
  }
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x1FE) == 0) {
    goto LABEL_20;
  }
  if ((v12 & 2) != 0)
  {
    uint64_t v16 = *((void *)a2 + 4);
    *((_DWORD *)this + 50) |= 2u;
    *((void *)this + 4) = v16;
    int v12 = *((_DWORD *)a2 + 50);
    if ((v12 & 4) == 0)
    {
LABEL_16:
      if ((v12 & 8) == 0) {
        goto LABEL_17;
      }
LABEL_41:
      unsigned int v17 = *((_DWORD *)a2 + 12);
      if (v17 >= 6) {
        CLMicroLocationProto::Model::MergeFrom();
      }
      *((_DWORD *)this + 50) |= 8u;
      *((_DWORD *)this + 12) = v17;
      int v12 = *((_DWORD *)a2 + 50);
      if ((v12 & 0x10) == 0)
      {
LABEL_18:
        if ((v12 & 0x80) == 0) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
      goto LABEL_43;
    }
  }
  else if ((v12 & 4) == 0)
  {
    goto LABEL_16;
  }
  uint64_t v10 = *((void *)a2 + 5);
  *((_DWORD *)this + 50) |= 4u;
  *((void *)this + 5) = v10;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 8) != 0) {
    goto LABEL_41;
  }
LABEL_17:
  if ((v12 & 0x10) == 0) {
    goto LABEL_18;
  }
LABEL_43:
  unsigned int v18 = *((_DWORD *)a2 + 13);
  if (v18 >= 4) {
    CLMicroLocationProto::Model::MergeFrom();
  }
  *((_DWORD *)this + 50) |= 0x10u;
  *((_DWORD *)this + 13) = v18;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x80) != 0)
  {
LABEL_19:
    char v13 = *((unsigned char *)a2 + 104);
    *((_DWORD *)this + 50) |= 0x80u;
    *((unsigned char *)this + 104) = v13;
    int v12 = *((_DWORD *)a2 + 50);
  }
LABEL_20:
  if ((v12 & 0xFF00) == 0) {
    goto LABEL_30;
  }
  if ((v12 & 0x100) != 0)
  {
    *((_DWORD *)this + 50) |= 0x100u;
    int v19 = (CLMicroLocationProto::anchorAppearancesVector *)*((void *)this + 14);
    if (!v19) {
      operator new();
    }
    int v20 = (const CLMicroLocationProto::anchorAppearancesVector *)*((void *)a2 + 14);
    if (!v20)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(v9);
      int v20 = *(const CLMicroLocationProto::anchorAppearancesVector **)(CLMicroLocationProto::Model::default_instance_
                                                                    + 112);
    }
    CLMicroLocationProto::anchorAppearancesVector::MergeFrom(v19, v20);
    int v12 = *((_DWORD *)a2 + 50);
    if ((v12 & 0x200) == 0)
    {
LABEL_23:
      if ((v12 & 0x400) == 0) {
        goto LABEL_24;
      }
      goto LABEL_52;
    }
  }
  else if ((v12 & 0x200) == 0)
  {
    goto LABEL_23;
  }
  int v21 = *((_DWORD *)a2 + 27);
  *((_DWORD *)this + 50) |= 0x200u;
  *((_DWORD *)this + 27) = v21;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x400) == 0)
  {
LABEL_24:
    if ((v12 & 0x800) == 0) {
      goto LABEL_25;
    }
    goto LABEL_57;
  }
LABEL_52:
  *((_DWORD *)this + 50) |= 0x400u;
  uint64_t v22 = (CLMicroLocationProto::LocationSimilarityListData *)*((void *)this + 15);
  if (!v22) {
    operator new();
  }
  int v23 = (const CLMicroLocationProto::LocationSimilarityListData *)*((void *)a2 + 15);
  if (!v23)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(v9);
    int v23 = *(const CLMicroLocationProto::LocationSimilarityListData **)(CLMicroLocationProto::Model::default_instance_
                                                                     + 120);
  }
  CLMicroLocationProto::LocationSimilarityListData::MergeFrom(v22, v23);
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x800) == 0)
  {
LABEL_25:
    if ((v12 & 0x1000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_59;
  }
LABEL_57:
  unsigned int v24 = *((_DWORD *)a2 + 32);
  if (v24 >= 4) {
    CLMicroLocationProto::Model::MergeFrom();
  }
  *((_DWORD *)this + 50) |= 0x800u;
  *((_DWORD *)this + 32) = v24;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x1000) == 0)
  {
LABEL_26:
    if ((v12 & 0x4000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
LABEL_59:
  unsigned int v25 = *((_DWORD *)a2 + 33);
  if (v25 >= 4) {
    CLMicroLocationProto::Model::MergeFrom();
  }
  *((_DWORD *)this + 50) |= 0x1000u;
  *((_DWORD *)this + 33) = v25;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x4000) == 0) {
    goto LABEL_28;
  }
LABEL_27:
  int v14 = *((_DWORD *)a2 + 38);
  *((_DWORD *)this + 50) |= 0x4000u;
  *((_DWORD *)this + 38) = v14;
  int v12 = *((_DWORD *)a2 + 50);
LABEL_28:
  if ((v12 & 0x8000) != 0)
  {
    int v15 = *((_DWORD *)a2 + 39);
    *((_DWORD *)this + 50) |= 0x8000u;
    *((_DWORD *)this + 39) = v15;
    int v12 = *((_DWORD *)a2 + 50);
  }
LABEL_30:
  if ((v12 & 0xFF0000) == 0) {
    return *(float *)&v10;
  }
  if ((v12 & 0x10000) != 0)
  {
    int v26 = *((_DWORD *)a2 + 40);
    *((_DWORD *)this + 50) |= 0x10000u;
    *((_DWORD *)this + 40) = v26;
    int v12 = *((_DWORD *)a2 + 50);
    if ((v12 & 0x20000) == 0)
    {
LABEL_33:
      if ((v12 & 0x40000) == 0) {
        goto LABEL_34;
      }
      goto LABEL_64;
    }
  }
  else if ((v12 & 0x20000) == 0)
  {
    goto LABEL_33;
  }
  int v27 = *((_DWORD *)a2 + 41);
  *((_DWORD *)this + 50) |= 0x20000u;
  *((_DWORD *)this + 41) = v27;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x40000) == 0)
  {
LABEL_34:
    if ((v12 & 0x80000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_65;
  }
LABEL_64:
  int v28 = *((_DWORD *)a2 + 42);
  *((_DWORD *)this + 50) |= 0x40000u;
  *((_DWORD *)this + 42) = v28;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x80000) == 0)
  {
LABEL_35:
    if ((v12 & 0x100000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_66;
  }
LABEL_65:
  int v29 = *((_DWORD *)a2 + 43);
  *((_DWORD *)this + 50) |= 0x80000u;
  *((_DWORD *)this + 43) = v29;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x100000) == 0)
  {
LABEL_36:
    if ((v12 & 0x200000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_67;
  }
LABEL_66:
  int v30 = *((_DWORD *)a2 + 48);
  *((_DWORD *)this + 50) |= 0x100000u;
  *((_DWORD *)this + 48) = v30;
  int v12 = *((_DWORD *)a2 + 50);
  if ((v12 & 0x200000) == 0)
  {
LABEL_37:
    if ((v12 & 0x400000) == 0) {
      return *(float *)&v10;
    }
    goto LABEL_70;
  }
LABEL_67:
  int v31 = (const std::string *)*((void *)a2 + 22);
  *((_DWORD *)this + 50) |= 0x200000u;
  int v32 = (std::string *)*((void *)this + 22);
  if (v32 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  uint64_t v9 = (CLMicroLocationProto *)std::string::operator=(v32, v31);
  if ((*((_DWORD *)a2 + 50) & 0x400000) != 0)
  {
LABEL_70:
    *((_DWORD *)this + 50) |= 0x400000u;
    int v33 = (CLMicroLocationProto::BlueAtlasData *)*((void *)this + 23);
    if (!v33) {
      operator new();
    }
    BOOL v34 = (const CLMicroLocationProto::BlueAtlasData *)*((void *)a2 + 23);
    if (!v34)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(v9);
      BOOL v34 = *(const CLMicroLocationProto::BlueAtlasData **)(CLMicroLocationProto::Model::default_instance_ + 184);
    }
    *(float *)&uint64_t v10 = CLMicroLocationProto::BlueAtlasData::MergeFrom(v33, v34);
  }
  return *(float *)&v10;
}

void sub_25641A6E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::Model::~Model(CLMicroLocationProto::Model *this)
{
  *(void *)this = &unk_2704DE6C8;
  CLMicroLocationProto::Model::SharedDtor(this);
  uint64_t v2 = *((void *)this + 17);
  if (v2) {
    MEMORY[0x25A2A6320](v2, 0x1000C8052888210);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 10);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 7);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::Model::~Model(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::Model::SharedDtor(CLMicroLocationProto::Model *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 22);
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::Model *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::Model *)CLMicroLocationProto::Model::default_instance_ != v1)
  {
    uint64_t v4 = *((void *)v1 + 14);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = *((void *)v1 + 15);
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = *((void *)v1 + 23);
    if (v6)
    {
      uint64_t v7 = *(void (**)(void))(*(void *)v6 + 8);
      v7();
    }
  }
}

uint64_t CLMicroLocationProto::Model::default_instance(CLMicroLocationProto::Model *this)
{
  return CLMicroLocationProto::Model::default_instance_;
}

void CLMicroLocationProto::Model::New(CLMicroLocationProto::Model *this)
{
}

uint64_t CLMicroLocationProto::Model::Clear(CLMicroLocationProto::Model *this)
{
  int v2 = *((_DWORD *)this + 50);
  if ((v2 & 0x1FE) != 0)
  {
    *((unsigned char *)this + 104) = 0;
    *((void *)this + 5) = 0;
    *((void *)this + 6) = 0;
    *((void *)this + 4) = 0;
  }
  if ((v2 & 0xFF00) != 0)
  {
    if ((v2 & 0x100) != 0)
    {
      uint64_t v3 = *((void *)this + 14);
      if (v3)
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(v3 + 8);
        *(_DWORD *)(v3 + 36) = 0;
        int v2 = *((_DWORD *)this + 50);
      }
    }
    *((_DWORD *)this + 27) = 0;
    if ((v2 & 0x400) != 0)
    {
      uint64_t v4 = *((void *)this + 15);
      if (v4)
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(v4 + 8);
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(v4 + 32);
        *(_DWORD *)(v4 + 64) = 0;
        *(_DWORD *)(v4 + 76) = 0;
        int v2 = *((_DWORD *)this + 50);
      }
    }
    *((void *)this + 16) = 0;
    *((void *)this + 19) = 0;
  }
  if ((v2 & 0xFF0000) != 0)
  {
    *((_DWORD *)this + 48) = 0;
    *((void *)this + 20) = 0;
    *((void *)this + 21) = 0;
    if ((v2 & 0x200000) != 0)
    {
      uint64_t v5 = *((void *)this + 22);
      if (v5 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    if ((*((unsigned char *)this + 202) & 0x40) != 0)
    {
      uint64_t v6 = (CLMicroLocationProto::BlueAtlasData *)*((void *)this + 23);
      if (v6) {
        CLMicroLocationProto::BlueAtlasData::Clear(v6);
      }
    }
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 8);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 56);
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 80);
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 50) = 0;
  return result;
}

uint64_t CLMicroLocationProto::Model::MergePartialFromCodedStream(CLMicroLocationProto::Model *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (char *)this + 136;
  uint64_t v5 = (CLMicroLocationProto::Model *)((char *)this + 8);
  __n128 v117 = (CLMicroLocationProto::Model *)((char *)this + 56);
  char v118 = (CLMicroLocationProto::Model *)((char *)this + 80);
  uint64_t v119 = (unint64_t *)((char *)this + 32);
  uint64_t v6 = (unsigned int *)((char *)this + 108);
  uint64_t v7 = (unsigned int *)((char *)this + 152);
  uint64_t v8 = (unsigned int *)((char *)this + 156);
  uint64_t v123 = (unsigned int *)((char *)this + 164);
  uint64_t v124 = (unsigned int *)((char *)this + 160);
  __n128 v121 = (unsigned int *)((char *)this + 172);
  uint64_t v122 = (unsigned int *)((char *)this + 168);
  char v120 = (unsigned int *)((char *)this + 192);
  uint64_t v9 = MEMORY[0x263F8C740];
LABEL_2:
  while (2)
  {
    uint64_t v10 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v10 >= *((void *)a2 + 2) || *v10 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v10;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v10 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_86;
        }
        while (1)
        {
          int v13 = *((_DWORD *)this + 5);
          uint64_t v14 = *((int *)this + 4);
          if ((int)v14 >= v13)
          {
            if (v13 == *((_DWORD *)this + 6))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5);
              int v13 = *((_DWORD *)this + 5);
            }
            *((_DWORD *)this + 5) = v13 + 1;
            operator new();
          }
          uint64_t v15 = *((void *)this + 1);
          *((_DWORD *)this + 4) = v14 + 1;
          uint64_t v16 = *(CLMicroLocationProto::Fingerprint **)(v15 + 8 * v14);
          v125[0] = 0;
          unsigned int v17 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v17 >= *((void *)a2 + 2) || *v17 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125))return 0; {
          }
            }
          else
          {
            v125[0] = *v17;
            *((void *)a2 + 1) = v17 + 1;
          }
          int v18 = *((_DWORD *)a2 + 14);
          int v19 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v18 + 1;
          if (v18 >= v19) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (!CLMicroLocationProto::Fingerprint::MergePartialFromCodedStream(v16, a2)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
          int v20 = *((_DWORD *)a2 + 14);
          BOOL v21 = __OFSUB__(v20, 1);
          int v22 = v20 - 1;
          if (v22 < 0 == v21) {
            *((_DWORD *)a2 + 14) = v22;
          }
          unsigned int v24 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v23 = *((void *)a2 + 2);
          if ((unint64_t)v24 >= v23) {
            goto LABEL_2;
          }
          int v25 = *v24;
          if (v25 != 10) {
            break;
          }
          *((void *)a2 + 1) = v24 + 1;
        }
        if (v25 != 16) {
          continue;
        }
        int v26 = (char *)(v24 + 1);
        *((void *)a2 + 1) = v26;
        goto LABEL_29;
      case 2u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v26 = (char *)*((void *)a2 + 1);
        unint64_t v23 = *((void *)a2 + 2);
LABEL_29:
        if ((unint64_t)v26 >= v23 || *v26 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v119);
          if (!result) {
            return result;
          }
          int v27 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v23 = *((void *)a2 + 2);
        }
        else
        {
          unint64_t *v119 = *v26;
          int v27 = v26 + 1;
          *((void *)a2 + 1) = v27;
        }
        *((_DWORD *)this + 50) |= 2u;
        if ((unint64_t)v27 >= v23 || *v27 != 25) {
          continue;
        }
        *((void *)a2 + 1) = v27 + 1;
LABEL_108:
        *(void *)long long v125 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v125) & 1) == 0)return 0; {
        *((void *)this + 5) = *(void *)v125;
        }
        *((_DWORD *)this + 50) |= 4u;
        int v60 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v28 = *((void *)a2 + 2);
        if ((unint64_t)v60 >= v28 || *v60 != 32) {
          continue;
        }
        int v29 = v60 + 1;
        *((void *)a2 + 1) = v29;
LABEL_112:
        v125[0] = 0;
        if ((unint64_t)v29 >= v28 || *v29 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125);
          if (!result) {
            return result;
          }
          unsigned int v61 = v125[0];
        }
        else
        {
          unsigned int v61 = *v29;
          *((void *)a2 + 1) = v29 + 1;
        }
        if (v61 <= 5)
        {
          *((_DWORD *)this + 50) |= 8u;
          *((_DWORD *)this + 12) = v61;
        }
        int v62 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v30 = *((void *)a2 + 2);
        if ((unint64_t)v62 >= v30 || *v62 != 40) {
          continue;
        }
        int v31 = v62 + 1;
        *((void *)a2 + 1) = v31;
LABEL_122:
        v125[0] = 0;
        if ((unint64_t)v31 >= v30 || *v31 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125);
          if (!result) {
            return result;
          }
          unsigned int v63 = v125[0];
        }
        else
        {
          unsigned int v63 = *v31;
          *((void *)a2 + 1) = v31 + 1;
        }
        if (v63 <= 3)
        {
          *((_DWORD *)this + 50) |= 0x10u;
          *((_DWORD *)this + 13) = v63;
        }
        __int16 v64 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v64 >= *((void *)a2 + 2) || *v64 != 50) {
          continue;
        }
        do
        {
          *((void *)a2 + 1) = v64 + 1;
LABEL_132:
          int v65 = *((_DWORD *)this + 17);
          uint64_t v66 = *((int *)this + 16);
          if ((int)v66 >= v65)
          {
            if (v65 == *((_DWORD *)this + 18))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v117);
              int v65 = *((_DWORD *)this + 17);
            }
            *((_DWORD *)this + 17) = v65 + 1;
            operator new();
          }
          uint64_t v67 = *((void *)this + 7);
          *((_DWORD *)this + 16) = v66 + 1;
          uint64_t v68 = *(void *)(v67 + 8 * v66);
          v125[0] = 0;
          __int16 v69 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v69 >= *((void *)a2 + 2) || *v69 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125))return 0; {
          }
            }
          else
          {
            v125[0] = *v69;
            *((void *)a2 + 1) = v69 + 1;
          }
          int v70 = *((_DWORD *)a2 + 14);
          int v71 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v70 + 1;
          if (v70 >= v71) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (!CLMicroLocationProto::ClusterRecordings::MergePartialFromCodedStream(v68, a2)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
          int v72 = *((_DWORD *)a2 + 14);
          BOOL v21 = __OFSUB__(v72, 1);
          int v73 = v72 - 1;
          if (v73 < 0 == v21) {
            *((_DWORD *)a2 + 14) = v73;
          }
          __int16 v64 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v64 >= *((void *)a2 + 2)) {
            goto LABEL_2;
          }
          int v74 = *v64;
        }
        while (v74 == 50);
        if (v74 != 58) {
          continue;
        }
        do
        {
          *((void *)a2 + 1) = v64 + 1;
LABEL_150:
          int v75 = *((_DWORD *)this + 23);
          uint64_t v76 = *((int *)this + 22);
          if ((int)v76 >= v75)
          {
            if (v75 == *((_DWORD *)this + 24))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v118);
              int v75 = *((_DWORD *)this + 23);
            }
            *((_DWORD *)this + 23) = v75 + 1;
            operator new();
          }
          uint64_t v77 = *((void *)this + 10);
          *((_DWORD *)this + 22) = v76 + 1;
          uint64_t v78 = *(CLMicroLocationProto::AnchorMetadata **)(v77 + 8 * v76);
          v125[0] = 0;
          __int16 v79 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v79 >= *((void *)a2 + 2) || *v79 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125))return 0; {
          }
            }
          else
          {
            v125[0] = *v79;
            *((void *)a2 + 1) = v79 + 1;
          }
          int v80 = *((_DWORD *)a2 + 14);
          int v81 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v80 + 1;
          if (v80 >= v81) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (!CLMicroLocationProto::AnchorMetadata::MergePartialFromCodedStream(v78, a2)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
          int v82 = *((_DWORD *)a2 + 14);
          BOOL v21 = __OFSUB__(v82, 1);
          int v83 = v82 - 1;
          if (v83 < 0 == v21) {
            *((_DWORD *)a2 + 14) = v83;
          }
          __int16 v64 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v32 = *((void *)a2 + 2);
          if ((unint64_t)v64 >= v32) {
            goto LABEL_2;
          }
          int v84 = *v64;
        }
        while (v84 == 58);
        if (v84 != 64) {
          continue;
        }
        int v33 = v64 + 1;
        *((void *)a2 + 1) = v33;
LABEL_168:
        v125[0] = 0;
        if ((unint64_t)v33 >= v32 || *v33 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125);
          if (!result) {
            return result;
          }
          unsigned int v85 = v125[0];
          unint64_t v86 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v32 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v85 = *v33;
          unint64_t v86 = v33 + 1;
          *((void *)a2 + 1) = v86;
        }
        *((unsigned char *)this + 104) = v85 != 0;
        int v34 = *((_DWORD *)this + 50) | 0x80;
        *((_DWORD *)this + 50) = v34;
        if ((unint64_t)v86 >= v32 || *v86 != 74) {
          continue;
        }
        *((void *)a2 + 1) = v86 + 1;
LABEL_176:
        *((_DWORD *)this + 50) = v34 | 0x100;
        double v87 = (CLMicroLocationProto::anchorAppearancesVector *)*((void *)this + 14);
        if (!v87) {
          operator new();
        }
        v125[0] = 0;
        double v88 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v88 >= *((void *)a2 + 2) || *v88 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125))return 0; {
        }
          }
        else
        {
          v125[0] = *v88;
          *((void *)a2 + 1) = v88 + 1;
        }
        int v89 = *((_DWORD *)a2 + 14);
        int v90 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v89 + 1;
        if (v89 >= v90) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::anchorAppearancesVector::MergePartialFromCodedStream(v87, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v91 = *((_DWORD *)a2 + 14);
        BOOL v21 = __OFSUB__(v91, 1);
        int v92 = v91 - 1;
        if (v92 < 0 == v21) {
          *((_DWORD *)a2 + 14) = v92;
        }
        double v93 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v35 = *((void *)a2 + 2);
        if ((unint64_t)v93 >= v35 || *v93 != 80) {
          continue;
        }
        unint64_t v36 = v93 + 1;
        *((void *)a2 + 1) = v36;
LABEL_190:
        if ((unint64_t)v36 >= v35 || *v36 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v6);
          if (!result) {
            return result;
          }
          __int16 v94 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v35 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int *v6 = *v36;
          __int16 v94 = v36 + 1;
          *((void *)a2 + 1) = v94;
        }
        int v37 = *((_DWORD *)this + 50) | 0x200;
        *((_DWORD *)this + 50) = v37;
        if ((unint64_t)v94 >= v35 || *v94 != 90) {
          continue;
        }
        *((void *)a2 + 1) = v94 + 1;
LABEL_198:
        *((_DWORD *)this + 50) = v37 | 0x400;
        uint64_t v95 = *((void *)this + 15);
        if (!v95) {
          operator new();
        }
        v125[0] = 0;
        __int16 v96 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v96 >= *((void *)a2 + 2) || *v96 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125))return 0; {
        }
          }
        else
        {
          v125[0] = *v96;
          *((void *)a2 + 1) = v96 + 1;
        }
        int v97 = *((_DWORD *)a2 + 14);
        int v98 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v97 + 1;
        if (v97 >= v98) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::LocationSimilarityListData::MergePartialFromCodedStream(v95, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v99 = *((_DWORD *)a2 + 14);
        BOOL v21 = __OFSUB__(v99, 1);
        int v100 = v99 - 1;
        if (v100 < 0 == v21) {
          *((_DWORD *)a2 + 14) = v100;
        }
        uint64_t v101 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v38 = *((void *)a2 + 2);
        if ((unint64_t)v101 >= v38 || *v101 != 96) {
          continue;
        }
        int v39 = v101 + 1;
        *((void *)a2 + 1) = v39;
LABEL_212:
        v125[0] = 0;
        if ((unint64_t)v39 >= v38 || *v39 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125);
          if (!result) {
            return result;
          }
          unsigned int v102 = v125[0];
        }
        else
        {
          unsigned int v102 = *v39;
          *((void *)a2 + 1) = v39 + 1;
        }
        if (v102 <= 3)
        {
          *((_DWORD *)this + 50) |= 0x800u;
          *((_DWORD *)this + 32) = v102;
        }
        uint64_t v103 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v40 = *((void *)a2 + 2);
        if ((unint64_t)v103 >= v40 || *v103 != 104) {
          continue;
        }
        int v41 = v103 + 1;
        *((void *)a2 + 1) = v41;
LABEL_222:
        v125[0] = 0;
        if ((unint64_t)v41 >= v40 || *v41 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125);
          if (!result) {
            return result;
          }
          unsigned int v104 = v125[0];
        }
        else
        {
          unsigned int v104 = *v41;
          *((void *)a2 + 1) = v41 + 1;
        }
        if (v104 <= 3)
        {
          *((_DWORD *)this + 50) |= 0x1000u;
          *((_DWORD *)this + 33) = v104;
        }
        uint64_t v105 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        if ((unint64_t)v105 < v42)
        {
          int v106 = *v105;
          goto LABEL_242;
        }
        continue;
      case 3u:
        int v12 = TagFallback & 7;
        if (v12 == 1) {
          goto LABEL_108;
        }
        goto LABEL_86;
      case 4u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v29 = (char *)*((void *)a2 + 1);
        unint64_t v28 = *((void *)a2 + 2);
        goto LABEL_112;
      case 5u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v31 = (char *)*((void *)a2 + 1);
        unint64_t v30 = *((void *)a2 + 2);
        goto LABEL_122;
      case 6u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_132;
        }
        goto LABEL_86;
      case 7u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_150;
        }
        goto LABEL_86;
      case 8u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v33 = (char *)*((void *)a2 + 1);
        unint64_t v32 = *((void *)a2 + 2);
        goto LABEL_168;
      case 9u:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_86;
        }
        int v34 = *((_DWORD *)this + 50);
        goto LABEL_176;
      case 0xAu:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        unint64_t v36 = (char *)*((void *)a2 + 1);
        unint64_t v35 = *((void *)a2 + 2);
        goto LABEL_190;
      case 0xBu:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_86;
        }
        int v37 = *((_DWORD *)this + 50);
        goto LABEL_198;
      case 0xCu:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v39 = (char *)*((void *)a2 + 1);
        unint64_t v38 = *((void *)a2 + 2);
        goto LABEL_212;
      case 0xDu:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v41 = (char *)*((void *)a2 + 1);
        unint64_t v40 = *((void *)a2 + 2);
        goto LABEL_222;
      case 0xEu:
        int v12 = TagFallback & 7;
        if (v12 == 2)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline();
          if (!result) {
            return result;
          }
          while (1)
          {
            uint64_t v105 = (unsigned __int8 *)*((void *)a2 + 1);
            unint64_t v42 = *((void *)a2 + 2);
            if ((unint64_t)v105 >= v42) {
              goto LABEL_2;
            }
            int v106 = *v105;
            if (v106 == 120) {
              break;
            }
LABEL_242:
            if (v106 != 112) {
              goto LABEL_2;
            }
            int v43 = (char *)(v105 + 1);
            *((void *)a2 + 1) = v43;
LABEL_231:
            v125[0] = 0;
            if ((unint64_t)v43 >= v42 || *v43 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125);
              if (!result) {
                return result;
              }
              unsigned int v107 = v125[0];
            }
            else
            {
              unsigned int v107 = *v43;
              *((void *)a2 + 1) = v43 + 1;
            }
            if (v107 <= 8)
            {
              int v108 = *((_DWORD *)this + 36);
              if (v108 == *((_DWORD *)this + 37))
              {
                wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve((uint64_t)v4, v108 + 1);
                int v108 = *((_DWORD *)this + 36);
              }
              uint64_t v109 = *((void *)this + 17);
              *((_DWORD *)this + 36) = v108 + 1;
              *(_DWORD *)(v109 + 4 * v108) = v107;
            }
          }
          int v44 = v105 + 1;
          *((void *)a2 + 1) = v44;
LABEL_245:
          if ((unint64_t)v44 >= v42 || (char)*v44 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v7);
            if (!result) {
              return result;
            }
            uint64_t v110 = (unsigned __int8 *)*((void *)a2 + 1);
            unint64_t v42 = *((void *)a2 + 2);
          }
          else
          {
            unsigned int *v7 = *v44;
            uint64_t v110 = v44 + 1;
            *((void *)a2 + 1) = v110;
          }
          *((_DWORD *)this + 50) |= 0x4000u;
          if ((int)v42 - (int)v110 >= 2 && *v110 == 128 && v110[1] == 1)
          {
            unsigned int v45 = v110 + 2;
            *((void *)a2 + 1) = v45;
LABEL_254:
            if ((unint64_t)v45 >= v42 || (char)*v45 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v8);
              if (!result) {
                return result;
              }
              __n128 v111 = (unsigned __int8 *)*((void *)a2 + 1);
              unint64_t v42 = *((void *)a2 + 2);
            }
            else
            {
              *uint64_t v8 = *v45;
              __n128 v111 = v45 + 1;
              *((void *)a2 + 1) = v111;
            }
            *((_DWORD *)this + 50) |= 0x8000u;
            if ((int)v42 - (int)v111 >= 2 && *v111 == 136 && v111[1] == 1)
            {
              int v46 = v111 + 2;
              *((void *)a2 + 1) = v46;
LABEL_263:
              if ((unint64_t)v46 >= v42 || (char)*v46 < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v124);
                if (!result) {
                  return result;
                }
                __n128 v112 = (unsigned __int8 *)*((void *)a2 + 1);
                unint64_t v42 = *((void *)a2 + 2);
              }
              else
              {
                unsigned int *v124 = *v46;
                __n128 v112 = v46 + 1;
                *((void *)a2 + 1) = v112;
              }
              *((_DWORD *)this + 50) |= 0x10000u;
              if ((int)v42 - (int)v112 >= 2 && *v112 == 144 && v112[1] == 1)
              {
                unsigned int v47 = v112 + 2;
                *((void *)a2 + 1) = v47;
LABEL_272:
                if ((unint64_t)v47 >= v42 || (char)*v47 < 0)
                {
                  uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v123);
                  if (!result) {
                    return result;
                  }
                  long long v113 = (unsigned __int8 *)*((void *)a2 + 1);
                  unint64_t v42 = *((void *)a2 + 2);
                }
                else
                {
                  *uint64_t v123 = *v47;
                  long long v113 = v47 + 1;
                  *((void *)a2 + 1) = v113;
                }
                *((_DWORD *)this + 50) |= 0x20000u;
                if ((int)v42 - (int)v113 >= 2 && *v113 == 152 && v113[1] == 1)
                {
                  unsigned __int8 v48 = v113 + 2;
                  *((void *)a2 + 1) = v48;
LABEL_281:
                  if ((unint64_t)v48 >= v42 || (char)*v48 < 0)
                  {
                    uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v122);
                    if (!result) {
                      return result;
                    }
                    uint64_t v114 = (unsigned __int8 *)*((void *)a2 + 1);
                    unint64_t v42 = *((void *)a2 + 2);
                  }
                  else
                  {
                    *uint64_t v122 = *v48;
                    uint64_t v114 = v48 + 1;
                    *((void *)a2 + 1) = v114;
                  }
                  *((_DWORD *)this + 50) |= 0x40000u;
                  if ((int)v42 - (int)v114 >= 2 && *v114 == 160 && v114[1] == 1)
                  {
                    unsigned __int8 v49 = v114 + 2;
                    *((void *)a2 + 1) = v49;
LABEL_290:
                    if ((unint64_t)v49 >= v42 || (char)*v49 < 0)
                    {
                      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v121);
                      if (!result) {
                        return result;
                      }
                      __n128 v115 = (unsigned __int8 *)*((void *)a2 + 1);
                      unint64_t v42 = *((void *)a2 + 2);
                    }
                    else
                    {
                      *__n128 v121 = *v49;
                      __n128 v115 = v49 + 1;
                      *((void *)a2 + 1) = v115;
                    }
                    *((_DWORD *)this + 50) |= 0x80000u;
                    if ((int)v42 - (int)v115 >= 2 && *v115 == 168 && v115[1] == 1)
                    {
                      int v50 = v115 + 2;
                      *((void *)a2 + 1) = v50;
LABEL_299:
                      if ((unint64_t)v50 >= v42 || (char)*v50 < 0)
                      {
                        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v120);
                        if (!result) {
                          return result;
                        }
                        uint64_t v116 = (unsigned __int8 *)*((void *)a2 + 1);
                        unint64_t v42 = *((void *)a2 + 2);
                      }
                      else
                      {
                        *char v120 = *v50;
                        uint64_t v116 = v50 + 1;
                        *((void *)a2 + 1) = v116;
                      }
                      int v51 = *((_DWORD *)this + 50) | 0x100000;
                      *((_DWORD *)this + 50) = v51;
                      if ((int)v42 - (int)v116 >= 2 && *v116 == 178 && v116[1] == 1)
                      {
                        *((void *)a2 + 1) = v116 + 2;
LABEL_73:
                        *((_DWORD *)this + 50) = v51 | 0x200000;
                        if (*((void *)this + 22) == v9) {
                          operator new();
                        }
                        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
                        if (!result) {
                          return result;
                        }
                        int v53 = (unsigned __int8 *)*((void *)a2 + 1);
                        if (*((_DWORD *)a2 + 4) - (int)v53 >= 2 && *v53 == 186 && v53[1] == 1)
                        {
                          *((void *)a2 + 1) = v53 + 2;
LABEL_81:
                          *((_DWORD *)this + 50) |= 0x400000u;
                          uint64_t v54 = *((void *)this + 23);
                          if (!v54) {
                            operator new();
                          }
                          v125[0] = 0;
                          std::string v55 = (char *)*((void *)a2 + 1);
                          if ((unint64_t)v55 >= *((void *)a2 + 2) || *v55 < 0)
                          {
                            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v125))return 0; {
                          }
                            }
                          else
                          {
                            v125[0] = *v55;
                            *((void *)a2 + 1) = v55 + 1;
                          }
                          int v56 = *((_DWORD *)a2 + 14);
                          int v57 = *((_DWORD *)a2 + 15);
                          *((_DWORD *)a2 + 14) = v56 + 1;
                          if (v56 >= v57) {
                            return 0;
                          }
                          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
                          if (!CLMicroLocationProto::BlueAtlasData::MergePartialFromCodedStream(v54, a2)
                            || !*((unsigned char *)a2 + 36))
                          {
                            return 0;
                          }
                          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
                          int v58 = *((_DWORD *)a2 + 14);
                          BOOL v21 = __OFSUB__(v58, 1);
                          int v59 = v58 - 1;
                          if (v59 < 0 == v21) {
                            *((_DWORD *)a2 + 14) = v59;
                          }
                          if (*((void *)a2 + 1) == *((void *)a2 + 2)
                            && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                          {
                            *((_DWORD *)a2 + 8) = 0;
                            uint64_t result = 1;
                            *((unsigned char *)a2 + 36) = 1;
                            return result;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          continue;
        }
        if ((TagFallback & 7) == 0)
        {
          int v43 = (char *)*((void *)a2 + 1);
          unint64_t v42 = *((void *)a2 + 2);
          goto LABEL_231;
        }
LABEL_86:
        if (v12 != 4)
        {
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
          continue;
          }
        }
        return 1;
      case 0xFu:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v44 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        goto LABEL_245;
      case 0x10u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        unsigned int v45 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        goto LABEL_254;
      case 0x11u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v46 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        goto LABEL_263;
      case 0x12u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        unsigned int v47 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        goto LABEL_272;
      case 0x13u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        unsigned __int8 v48 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        goto LABEL_281;
      case 0x14u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        unsigned __int8 v49 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        goto LABEL_290;
      case 0x15u:
        int v12 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_86;
        }
        int v50 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v42 = *((void *)a2 + 2);
        goto LABEL_299;
      case 0x16u:
        int v12 = TagFallback & 7;
        if (v12 != 2) {
          goto LABEL_86;
        }
        int v51 = *((_DWORD *)this + 50);
        goto LABEL_73;
      case 0x17u:
        int v12 = TagFallback & 7;
        if (v12 == 2) {
          goto LABEL_81;
        }
        goto LABEL_86;
      default:
        int v12 = TagFallback & 7;
        goto LABEL_86;
    }
  }
}

int *CLMicroLocationProto::Model::SerializeWithCachedSizes(int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  if (this[4] >= 1)
  {
    uint64_t v6 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(*((void *)v5 + 1) + 8 * v6++), a2, a4);
    while (v6 < v5[4]);
  }
  int v7 = v5[50];
  if ((v7 & 2) != 0)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *((void *)v5 + 4), (uint64_t)a2, a4);
    int v7 = v5[50];
    if ((v7 & 4) == 0)
    {
LABEL_6:
      if ((v7 & 8) == 0) {
        goto LABEL_7;
      }
      goto LABEL_37;
    }
  }
  else if ((v7 & 4) == 0)
  {
    goto LABEL_6;
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, (uint64_t)a2, *((double *)v5 + 5), a3);
  int v7 = v5[50];
  if ((v7 & 8) == 0)
  {
LABEL_7:
    if ((v7 & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_37:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v5[12], (uint64_t)a2, a4);
  if ((v5[50] & 0x10) != 0) {
LABEL_8:
  }
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v5[13], (uint64_t)a2, a4);
LABEL_9:
  if (v5[16] >= 1)
  {
    uint64_t v8 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, *(void *)(*((void *)v5 + 7) + 8 * v8++), a2, a4);
    while (v8 < v5[16]);
  }
  if (v5[22] >= 1)
  {
    uint64_t v9 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, *(void *)(*((void *)v5 + 10) + 8 * v9++), a2, a4);
    while (v9 < v5[22]);
  }
  int v10 = v5[50];
  if ((v10 & 0x80) != 0)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *((unsigned __int8 *)v5 + 104), (uint64_t)a2, a4);
    int v10 = v5[50];
    if ((v10 & 0x100) == 0)
    {
LABEL_17:
      if ((v10 & 0x200) == 0) {
        goto LABEL_18;
      }
      goto LABEL_43;
    }
  }
  else if ((v10 & 0x100) == 0)
  {
    goto LABEL_17;
  }
  uint64_t v13 = *((void *)v5 + 14);
  if (!v13)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v13 = *(void *)(CLMicroLocationProto::Model::default_instance_ + 112);
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v13, a2, a4);
  int v10 = v5[50];
  if ((v10 & 0x200) == 0)
  {
LABEL_18:
    if ((v10 & 0x400) == 0) {
      goto LABEL_19;
    }
    goto LABEL_44;
  }
LABEL_43:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, v5[27], (uint64_t)a2, a4);
  int v10 = v5[50];
  if ((v10 & 0x400) == 0)
  {
LABEL_19:
    if ((v10 & 0x800) == 0) {
      goto LABEL_20;
    }
    goto LABEL_47;
  }
LABEL_44:
  uint64_t v14 = *((void *)v5 + 15);
  if (!v14)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v14 = *(void *)(CLMicroLocationProto::Model::default_instance_ + 120);
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v14, a2, a4);
  int v10 = v5[50];
  if ((v10 & 0x800) == 0)
  {
LABEL_20:
    if ((v10 & 0x1000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_21;
  }
LABEL_47:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, v5[32], (uint64_t)a2, a4);
  if ((v5[50] & 0x1000) != 0) {
LABEL_21:
  }
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, v5[33], (uint64_t)a2, a4);
LABEL_22:
  if (v5[36] >= 1)
  {
    uint64_t v11 = 0;
    do
      this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, *(unsigned int *)(*((void *)v5 + 17) + 4 * v11++), (uint64_t)a2, a4);
    while (v11 < v5[36]);
  }
  int v12 = v5[50];
  if ((v12 & 0x4000) != 0)
  {
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xF, v5[38], (uint64_t)a2, a4);
    int v12 = v5[50];
    if ((v12 & 0x8000) == 0)
    {
LABEL_27:
      if ((v12 & 0x10000) == 0) {
        goto LABEL_28;
      }
      goto LABEL_51;
    }
  }
  else if ((v12 & 0x8000) == 0)
  {
    goto LABEL_27;
  }
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x10, v5[39], (uint64_t)a2, a4);
  int v12 = v5[50];
  if ((v12 & 0x10000) == 0)
  {
LABEL_28:
    if ((v12 & 0x20000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_52;
  }
LABEL_51:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x11, v5[40], (uint64_t)a2, a4);
  int v12 = v5[50];
  if ((v12 & 0x20000) == 0)
  {
LABEL_29:
    if ((v12 & 0x40000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_53;
  }
LABEL_52:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x12, v5[41], (uint64_t)a2, a4);
  int v12 = v5[50];
  if ((v12 & 0x40000) == 0)
  {
LABEL_30:
    if ((v12 & 0x80000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_54;
  }
LABEL_53:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13, v5[42], (uint64_t)a2, a4);
  int v12 = v5[50];
  if ((v12 & 0x80000) == 0)
  {
LABEL_31:
    if ((v12 & 0x100000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_55;
  }
LABEL_54:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, v5[43], (uint64_t)a2, a4);
  int v12 = v5[50];
  if ((v12 & 0x100000) == 0)
  {
LABEL_32:
    if ((v12 & 0x200000) == 0) {
      goto LABEL_33;
    }
LABEL_56:
    this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    if ((v5[50] & 0x400000) == 0) {
      return this;
    }
    goto LABEL_57;
  }
LABEL_55:
  this = (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x15, v5[48], (uint64_t)a2, a4);
  int v12 = v5[50];
  if ((v12 & 0x200000) != 0) {
    goto LABEL_56;
  }
LABEL_33:
  if ((v12 & 0x400000) == 0) {
    return this;
  }
LABEL_57:
  uint64_t v15 = *((void *)v5 + 23);
  if (!v15)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v15 = *(void *)(CLMicroLocationProto::Model::default_instance_ + 184);
  }
  return (int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x17, v15, a2, a4);
}

uint64_t CLMicroLocationProto::Model::ByteSize(CLMicroLocationProto::Model *this)
{
  int v2 = *((_DWORD *)this + 50);
  if ((v2 & 0x1FE) != 0)
  {
    if ((v2 & 2) != 0)
    {
      int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this
                                                                                       + 4))
         + 1;
      int v2 = *((_DWORD *)this + 50);
    }
    else
    {
      int v3 = 0;
    }
    if ((v2 & 4) != 0) {
      int v5 = v3 + 9;
    }
    else {
      int v5 = v3;
    }
    if ((v2 & 8) != 0)
    {
      uint64_t v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 12);
      if ((v6 & 0x80000000) != 0)
      {
        int v7 = 10;
      }
      else if (v6 >= 0x80)
      {
        int v7 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6);
        int v2 = *((_DWORD *)this + 50);
      }
      else
      {
        int v7 = 1;
      }
      v5 += v7 + 1;
    }
    if ((v2 & 0x10) != 0)
    {
      uint64_t v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 13);
      if ((v8 & 0x80000000) != 0)
      {
        int v9 = 10;
      }
      else if (v8 >= 0x80)
      {
        int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8);
        int v2 = *((_DWORD *)this + 50);
      }
      else
      {
        int v9 = 1;
      }
      v5 += v9 + 1;
    }
    if ((v2 & 0x80) != 0) {
      int v4 = v5 + 2;
    }
    else {
      int v4 = v5;
    }
  }
  else
  {
    int v4 = 0;
  }
  if ((v2 & 0xFF00) == 0) {
    goto LABEL_71;
  }
  if ((v2 & 0x100) != 0)
  {
    int v10 = (CLMicroLocationProto::anchorAppearancesVector *)*((void *)this + 14);
    if (!v10)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      int v10 = *(CLMicroLocationProto::anchorAppearancesVector **)(CLMicroLocationProto::Model::default_instance_ + 112);
    }
    uint64_t v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::anchorAppearancesVector::ByteSize(v10);
    int v12 = (int)v11;
    if (v11 >= 0x80) {
      int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11);
    }
    else {
      int v13 = 1;
    }
    v4 += v12 + v13 + 1;
    int v2 = *((_DWORD *)this + 50);
    if ((v2 & 0x200) == 0)
    {
LABEL_29:
      if ((v2 & 0x400) == 0) {
        goto LABEL_30;
      }
      goto LABEL_45;
    }
  }
  else if ((v2 & 0x200) == 0)
  {
    goto LABEL_29;
  }
  uint64_t v14 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 27);
  if (v14 >= 0x80)
  {
    int v15 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v14);
    int v2 = *((_DWORD *)this + 50);
  }
  else
  {
    int v15 = 1;
  }
  v4 += v15 + 1;
  if ((v2 & 0x400) == 0)
  {
LABEL_30:
    if ((v2 & 0x800) == 0) {
      goto LABEL_31;
    }
    goto LABEL_51;
  }
LABEL_45:
  uint64_t v16 = (CLMicroLocationProto::LocationSimilarityListData *)*((void *)this + 15);
  if (!v16)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    uint64_t v16 = *(CLMicroLocationProto::LocationSimilarityListData **)(CLMicroLocationProto::Model::default_instance_ + 120);
  }
  unsigned int v17 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::LocationSimilarityListData::ByteSize(v16);
  int v18 = (int)v17;
  if (v17 >= 0x80) {
    int v19 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v17);
  }
  else {
    int v19 = 1;
  }
  v4 += v18 + v19 + 1;
  int v2 = *((_DWORD *)this + 50);
  if ((v2 & 0x800) == 0)
  {
LABEL_31:
    if ((v2 & 0x1000) == 0) {
      goto LABEL_32;
    }
LABEL_57:
    int v22 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 33);
    if ((v22 & 0x80000000) != 0)
    {
      int v23 = 10;
    }
    else if (v22 >= 0x80)
    {
      int v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v22);
      int v2 = *((_DWORD *)this + 50);
    }
    else
    {
      int v23 = 1;
    }
    v4 += v23 + 1;
    if ((v2 & 0x4000) == 0)
    {
LABEL_33:
      if ((v2 & 0x8000) == 0) {
        goto LABEL_71;
      }
      goto LABEL_67;
    }
    goto LABEL_63;
  }
LABEL_51:
  int v20 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 32);
  if ((v20 & 0x80000000) != 0)
  {
    int v21 = 10;
  }
  else if (v20 >= 0x80)
  {
    int v21 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v20);
    int v2 = *((_DWORD *)this + 50);
  }
  else
  {
    int v21 = 1;
  }
  v4 += v21 + 1;
  if ((v2 & 0x1000) != 0) {
    goto LABEL_57;
  }
LABEL_32:
  if ((v2 & 0x4000) == 0) {
    goto LABEL_33;
  }
LABEL_63:
  unsigned int v24 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 38);
  if (v24 >= 0x80)
  {
    int v25 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v24);
    int v2 = *((_DWORD *)this + 50);
  }
  else
  {
    int v25 = 1;
  }
  v4 += v25 + 1;
  if ((v2 & 0x8000) != 0)
  {
LABEL_67:
    int v26 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 39);
    if (v26 >= 0x80)
    {
      int v27 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v26);
      int v2 = *((_DWORD *)this + 50);
    }
    else
    {
      int v27 = 1;
    }
    v4 += v27 + 2;
  }
LABEL_71:
  if ((v2 & 0xFF0000) == 0) {
    goto LABEL_115;
  }
  if ((v2 & 0x10000) != 0)
  {
    unint64_t v28 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 40);
    if (v28 >= 0x80)
    {
      int v29 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v28);
      int v2 = *((_DWORD *)this + 50);
    }
    else
    {
      int v29 = 1;
    }
    v4 += v29 + 2;
    if ((v2 & 0x20000) == 0)
    {
LABEL_74:
      if ((v2 & 0x40000) == 0) {
        goto LABEL_75;
      }
      goto LABEL_88;
    }
  }
  else if ((v2 & 0x20000) == 0)
  {
    goto LABEL_74;
  }
  unint64_t v30 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 41);
  if (v30 >= 0x80)
  {
    int v31 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v30);
    int v2 = *((_DWORD *)this + 50);
  }
  else
  {
    int v31 = 1;
  }
  v4 += v31 + 2;
  if ((v2 & 0x40000) == 0)
  {
LABEL_75:
    if ((v2 & 0x80000) == 0) {
      goto LABEL_76;
    }
    goto LABEL_92;
  }
LABEL_88:
  unint64_t v32 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 42);
  if (v32 >= 0x80)
  {
    int v33 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v32);
    int v2 = *((_DWORD *)this + 50);
  }
  else
  {
    int v33 = 1;
  }
  v4 += v33 + 2;
  if ((v2 & 0x80000) == 0)
  {
LABEL_76:
    if ((v2 & 0x100000) == 0) {
      goto LABEL_77;
    }
    goto LABEL_96;
  }
LABEL_92:
  int v34 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 43);
  if (v34 >= 0x80)
  {
    int v35 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v34);
    int v2 = *((_DWORD *)this + 50);
  }
  else
  {
    int v35 = 1;
  }
  v4 += v35 + 2;
  if ((v2 & 0x100000) == 0)
  {
LABEL_77:
    if ((v2 & 0x200000) == 0) {
      goto LABEL_78;
    }
    goto LABEL_100;
  }
LABEL_96:
  unint64_t v36 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 48);
  if (v36 >= 0x80)
  {
    int v37 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v36);
    int v2 = *((_DWORD *)this + 50);
  }
  else
  {
    int v37 = 1;
  }
  v4 += v37 + 2;
  if ((v2 & 0x200000) == 0)
  {
LABEL_78:
    if ((v2 & 0x400000) == 0) {
      goto LABEL_115;
    }
    goto LABEL_109;
  }
LABEL_100:
  uint64_t v38 = *((void *)this + 22);
  int v39 = *(unsigned __int8 *)(v38 + 23);
  char v40 = v39;
  uint64_t v41 = *(void *)(v38 + 8);
  if ((v39 & 0x80u) == 0) {
    unint64_t v42 = *(unsigned __int8 *)(v38 + 23);
  }
  else {
    unint64_t v42 = v41;
  }
  if (v42 >= 0x80)
  {
    int v43 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v42);
    int v39 = *(unsigned __int8 *)(v38 + 23);
    uint64_t v41 = *(void *)(v38 + 8);
    int v2 = *((_DWORD *)this + 50);
    char v40 = *(unsigned char *)(v38 + 23);
  }
  else
  {
    int v43 = 1;
  }
  if (v40 < 0) {
    int v39 = v41;
  }
  v4 += v43 + v39 + 2;
  if ((v2 & 0x400000) != 0)
  {
LABEL_109:
    int v44 = (CLMicroLocationProto::BlueAtlasData *)*((void *)this + 23);
    if (!v44)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      int v44 = *(CLMicroLocationProto::BlueAtlasData **)(CLMicroLocationProto::Model::default_instance_ + 184);
    }
    unsigned int v45 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::BlueAtlasData::ByteSize(v44);
    int v46 = (int)v45;
    if (v45 >= 0x80) {
      int v47 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v45);
    }
    else {
      int v47 = 1;
    }
    v4 += v46 + v47 + 2;
  }
LABEL_115:
  int v48 = *((_DWORD *)this + 4);
  int v49 = v48 + v4;
  if (v48 >= 1)
  {
    uint64_t v50 = 0;
    do
    {
      int v51 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::Fingerprint::ByteSize(*(CLMicroLocationProto::Fingerprint **)(*((void *)this + 1) + 8 * v50));
      int v52 = (int)v51;
      if (v51 >= 0x80) {
        int v53 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v51);
      }
      else {
        int v53 = 1;
      }
      v49 += v52 + v53;
      ++v50;
    }
    while (v50 < *((int *)this + 4));
  }
  int v54 = *((_DWORD *)this + 16);
  int v55 = v54 + v49;
  if (v54 >= 1)
  {
    uint64_t v56 = 0;
    do
    {
      int v57 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::ClusterRecordings::ByteSize(*(CLMicroLocationProto::ClusterRecordings **)(*((void *)this + 7) + 8 * v56));
      int v58 = (int)v57;
      if (v57 >= 0x80) {
        int v59 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v57);
      }
      else {
        int v59 = 1;
      }
      v55 += v58 + v59;
      ++v56;
    }
    while (v56 < *((int *)this + 16));
  }
  int v60 = *((_DWORD *)this + 22);
  int v61 = v60 + v55;
  if (v60 >= 1)
  {
    uint64_t v62 = 0;
    do
    {
      unsigned int v63 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::AnchorMetadata::ByteSize(*(CLMicroLocationProto::AnchorMetadata **)(*((void *)this + 10) + 8 * v62));
      int v64 = (int)v63;
      if (v63 >= 0x80) {
        int v65 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v63);
      }
      else {
        int v65 = 1;
      }
      v61 += v64 + v65;
      ++v62;
    }
    while (v62 < *((int *)this + 22));
  }
  int v66 = *((_DWORD *)this + 36);
  if (v66 < 1)
  {
    int v68 = 0;
  }
  else
  {
    uint64_t v67 = 0;
    int v68 = 0;
    do
    {
      __int16 v69 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*((void *)this + 17)
                                                                                             + 4 * v67);
      if ((v69 & 0x80000000) != 0)
      {
        int v70 = 10;
      }
      else if (v69 >= 0x80)
      {
        int v70 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v69);
        int v66 = *((_DWORD *)this + 36);
      }
      else
      {
        int v70 = 1;
      }
      v68 += v70;
      ++v67;
    }
    while (v67 < v66);
  }
  uint64_t result = (v68 + v61 + v66);
  *((_DWORD *)this + 49) = result;
  return result;
}

float CLMicroLocationProto::Model::CheckTypeAndMergeFrom(CLMicroLocationProto::Model *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  return CLMicroLocationProto::Model::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::Model::IsInitialized(CLMicroLocationProto::Model *this)
{
  return 1;
}

double CLMicroLocationProto::Model::Swap(CLMicroLocationProto::Model *this, CLMicroLocationProto::Model *a2)
{
  if (a2 != this)
  {
    wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Swap();
    uint64_t v4 = *((void *)this + 4);
    *((void *)this + 4) = *((void *)a2 + 4);
    *((void *)a2 + 4) = v4;
    uint64_t v5 = *((void *)this + 5);
    *((void *)this + 5) = *((void *)a2 + 5);
    *((void *)a2 + 5) = v5;
    LODWORD(v4) = *((_DWORD *)this + 12);
    *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
    *((_DWORD *)a2 + 12) = v4;
    LODWORD(v4) = *((_DWORD *)this + 13);
    *((_DWORD *)this + 13) = *((_DWORD *)a2 + 13);
    *((_DWORD *)a2 + 13) = v4;
    wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Swap();
    wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Swap();
    char v6 = *((unsigned char *)this + 104);
    *((unsigned char *)this + 104) = *((unsigned char *)a2 + 104);
    *((unsigned char *)a2 + 104) = v6;
    uint64_t v7 = *((void *)this + 14);
    *((void *)this + 14) = *((void *)a2 + 14);
    *((void *)a2 + 14) = v7;
    LODWORD(v7) = *((_DWORD *)this + 27);
    *((_DWORD *)this + 27) = *((_DWORD *)a2 + 27);
    *((_DWORD *)a2 + 27) = v7;
    uint64_t v8 = *((void *)this + 15);
    *((void *)this + 15) = *((void *)a2 + 15);
    *((void *)a2 + 15) = v8;
    LODWORD(v8) = *((_DWORD *)this + 32);
    *((_DWORD *)this + 32) = *((_DWORD *)a2 + 32);
    *((_DWORD *)a2 + 32) = v8;
    LODWORD(v8) = *((_DWORD *)this + 33);
    *((_DWORD *)this + 33) = *((_DWORD *)a2 + 33);
    *((_DWORD *)a2 + 33) = v8;
    uint64_t v9 = *((void *)this + 17);
    *((void *)this + 17) = *((void *)a2 + 17);
    double result = *((double *)a2 + 18);
    *((void *)a2 + 17) = v9;
    uint64_t v11 = *((void *)this + 18);
    *((double *)this + 18) = result;
    *((void *)a2 + 18) = v11;
    LODWORD(v9) = *((_DWORD *)this + 38);
    *((_DWORD *)this + 38) = *((_DWORD *)a2 + 38);
    *((_DWORD *)a2 + 38) = v9;
    LODWORD(v9) = *((_DWORD *)this + 39);
    *((_DWORD *)this + 39) = *((_DWORD *)a2 + 39);
    *((_DWORD *)a2 + 39) = v9;
    LODWORD(v9) = *((_DWORD *)this + 40);
    *((_DWORD *)this + 40) = *((_DWORD *)a2 + 40);
    *((_DWORD *)a2 + 40) = v9;
    LODWORD(v9) = *((_DWORD *)this + 41);
    *((_DWORD *)this + 41) = *((_DWORD *)a2 + 41);
    *((_DWORD *)a2 + 41) = v9;
    LODWORD(v9) = *((_DWORD *)this + 42);
    *((_DWORD *)this + 42) = *((_DWORD *)a2 + 42);
    *((_DWORD *)a2 + 42) = v9;
    LODWORD(v9) = *((_DWORD *)this + 43);
    *((_DWORD *)this + 43) = *((_DWORD *)a2 + 43);
    *((_DWORD *)a2 + 43) = v9;
    LODWORD(v9) = *((_DWORD *)this + 48);
    *((_DWORD *)this + 48) = *((_DWORD *)a2 + 48);
    *((_DWORD *)a2 + 48) = v9;
    uint64_t v12 = *((void *)this + 22);
    *((void *)this + 22) = *((void *)a2 + 22);
    *((void *)a2 + 22) = v12;
    uint64_t v13 = *((void *)this + 23);
    *((void *)this + 23) = *((void *)a2 + 23);
    *((void *)a2 + 23) = v13;
    LODWORD(v13) = *((_DWORD *)this + 50);
    *((_DWORD *)this + 50) = *((_DWORD *)a2 + 50);
    *((_DWORD *)a2 + 50) = v13;
    LODWORD(v13) = *((_DWORD *)this + 49);
    *((_DWORD *)this + 49) = *((_DWORD *)a2 + 49);
    *((_DWORD *)a2 + 49) = v13;
  }
  return result;
}

void *CLMicroLocationProto::Model::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.Model");
}

void CLMicroLocationProto::BundleIdFeatures::MergeFrom(CLMicroLocationProto::BundleIdFeatures *this, const CLMicroLocationProto::BundleIdFeatures *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 16);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 16))
    {
      char v5 = *((unsigned char *)a2 + 8);
      *((_DWORD *)this + 4) |= 1u;
      *((unsigned char *)this + 8) = v5;
      int v4 = *((_DWORD *)a2 + 4);
    }
    if ((v4 & 2) != 0)
    {
      char v6 = *((unsigned char *)a2 + 9);
      *((_DWORD *)this + 4) |= 2u;
      *((unsigned char *)this + 9) = v6;
    }
  }
}

void sub_25641C8C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::BundleIdFeatures::~BundleIdFeatures(CLMicroLocationProto::BundleIdFeatures *this)
{
  *(void *)this = &unk_2704DE740;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::BundleIdFeatures::~BundleIdFeatures(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::BundleIdFeatures::New(CLMicroLocationProto::BundleIdFeatures *this)
{
}

uint64_t CLMicroLocationProto::BundleIdFeatures::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_WORD *)(this + 8) = 0;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::BundleIdFeatures::MergePartialFromCodedStream(CLMicroLocationProto::BundleIdFeatures *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      int v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v6 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_15;
      }
      unsigned int v16 = 0;
      uint64_t v9 = (char *)*((void *)a2 + 1);
      unint64_t v7 = *((void *)a2 + 2);
      if ((unint64_t)v9 >= v7 || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v16);
        if (!result) {
          return result;
        }
        unsigned int v10 = v16;
        uint64_t v11 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v7 = *((void *)a2 + 2);
      }
      else
      {
        unsigned int v10 = *v9;
        uint64_t v11 = v9 + 1;
        *((void *)a2 + 1) = v11;
      }
      *((unsigned char *)this + 8) = v10 != 0;
      *((_DWORD *)this + 4) |= 1u;
      if ((unint64_t)v11 < v7 && *v11 == 16)
      {
        uint64_t v8 = v11 + 1;
        *((void *)a2 + 1) = v8;
LABEL_23:
        unsigned int v15 = 0;
        if ((unint64_t)v8 >= v7 || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v15);
          if (!result) {
            return result;
          }
          unsigned int v12 = v15;
          uint64_t v13 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v7 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v12 = *v8;
          uint64_t v13 = (unsigned __int8 *)(v8 + 1);
          *((void *)a2 + 1) = v13;
        }
        *((unsigned char *)this + 9) = v12 != 0;
        *((_DWORD *)this + 4) |= 2u;
        if (v13 == (unsigned __int8 *)v7 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v6 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        uint64_t v8 = (char *)*((void *)a2 + 1);
        unint64_t v7 = *((void *)a2 + 2);
        goto LABEL_23;
      }
    }
    else
    {
      int v6 = TagFallback & 7;
    }
LABEL_15:
    if (v6 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::BundleIdFeatures::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 16);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned __int8 *)(this + 8), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 16);
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v7 = *(unsigned __int8 *)(v5 + 9);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::BundleIdFeatures::ByteSize(CLMicroLocationProto::BundleIdFeatures *this)
{
  unsigned int v1 = 2 * (*((_DWORD *)this + 4) & 1);
  if ((*((_DWORD *)this + 4) & 2) != 0) {
    v1 += 2;
  }
  if (*((_DWORD *)this + 4)) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0;
  }
  *((_DWORD *)this + 3) = v2;
  return v2;
}

void CLMicroLocationProto::BundleIdFeatures::CheckTypeAndMergeFrom(CLMicroLocationProto::BundleIdFeatures *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::BundleIdFeatures::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::BundleIdFeatures::IsInitialized(CLMicroLocationProto::BundleIdFeatures *this)
{
  return 1;
}

void *CLMicroLocationProto::BundleIdFeatures::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.BundleIdFeatures");
}

void CLMicroLocationProto::ReceivedEventAction::MergeFrom(CLMicroLocationProto::ReceivedEventAction *this, const CLMicroLocationProto::ReceivedEventAction *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 44);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 44))
    {
      unsigned int v5 = *((_DWORD *)a2 + 2);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::ReceivedEventAction::MergeFrom();
      }
      *((_DWORD *)this + 11) |= 1u;
      *((_DWORD *)this + 2) = v5;
      int v4 = *((_DWORD *)a2 + 11);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *((_DWORD *)a2 + 3);
      if ((v6 - 1) >= 4) {
        CLMicroLocationProto::ReceivedEventAction::MergeFrom();
      }
      *((_DWORD *)this + 11) |= 2u;
      *((_DWORD *)this + 3) = v6;
      int v4 = *((_DWORD *)a2 + 11);
    }
    uint64_t v7 = (std::string *)MEMORY[0x263F8C740];
    if ((v4 & 4) != 0)
    {
      uint64_t v8 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 11) |= 4u;
      uint64_t v9 = (std::string *)*((void *)this + 2);
      if (v9 == v7) {
        operator new();
      }
      std::string::operator=(v9, v8);
      int v4 = *((_DWORD *)a2 + 11);
      if ((v4 & 8) == 0)
      {
LABEL_14:
        if ((v4 & 0x10) == 0) {
          return;
        }
        goto LABEL_22;
      }
    }
    else if ((v4 & 8) == 0)
    {
      goto LABEL_14;
    }
    unsigned int v10 = (const std::string *)*((void *)a2 + 3);
    *((_DWORD *)this + 11) |= 8u;
    uint64_t v11 = (std::string *)*((void *)this + 3);
    if (v11 == v7) {
      operator new();
    }
    std::string::operator=(v11, v10);
    if ((*((_DWORD *)a2 + 11) & 0x10) != 0)
    {
LABEL_22:
      unsigned int v12 = (const std::string *)*((void *)a2 + 4);
      *((_DWORD *)this + 11) |= 0x10u;
      uint64_t v13 = (std::string *)*((void *)this + 4);
      if (v13 == v7) {
        operator new();
      }
      std::string::operator=(v13, v12);
    }
  }
}

void sub_25641CEB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ReceivedEventAction::~ReceivedEventAction(CLMicroLocationProto::ReceivedEventAction *this)
{
  *(void *)this = &unk_2704DE7B8;
  CLMicroLocationProto::ReceivedEventAction::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ReceivedEventAction::~ReceivedEventAction(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ReceivedEventAction::SharedDtor(CLMicroLocationProto::ReceivedEventAction *this)
{
  unsigned int v1 = this;
  uint64_t v2 = *((void *)this + 2);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::ReceivedEventAction *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 3);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::ReceivedEventAction *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  uint64_t v7 = *((void *)v1 + 4);
  if (v7 != v3 && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    this = (CLMicroLocationProto::ReceivedEventAction *)MEMORY[0x25A2A6340](v7, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::ReceivedEventAction::New(CLMicroLocationProto::ReceivedEventAction *this)
{
}

uint64_t CLMicroLocationProto::ReceivedEventAction::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 44);
  if (v1)
  {
    *(void *)(this + 8) = 0x100000001;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 4) != 0)
    {
      uint64_t v3 = *(void *)(this + 16);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 44) & 8) != 0)
    {
      uint64_t v4 = *(void *)(this + 24);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 44) & 0x10) != 0)
    {
      uint64_t v5 = *(void *)(this + 32);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 44) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ReceivedEventAction::MergePartialFromCodedStream(CLMicroLocationProto::ReceivedEventAction *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        unsigned int v21 = 0;
        uint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 < *((void *)a2 + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
LABEL_25:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v12 = ((1 << v9) & 0x76B6) == 0) : (BOOL v12 = 1), !v12))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::ReceivedEventAction::MergeFrom();
            }
            *((_DWORD *)this + 11) |= 1u;
            *((_DWORD *)this + 2) = v9;
          }
          uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
          if ((unint64_t)v14 < v10 && *v14 == 16)
          {
            uint64_t v11 = v14 + 1;
            *((void *)a2 + 1) = v11;
            goto LABEL_39;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v21);
        if (result)
        {
          unsigned int v9 = v21;
          goto LABEL_25;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        uint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
LABEL_39:
        unsigned int v20 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v20);
          if (!result) {
            return result;
          }
          unsigned int v15 = v20;
        }
        else
        {
          unsigned int v15 = *v11;
          *((void *)a2 + 1) = v11 + 1;
        }
        if (v15 - 1 <= 3)
        {
          *((_DWORD *)this + 11) |= 2u;
          *((_DWORD *)this + 3) = v15;
        }
        unsigned int v16 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v16 >= *((void *)a2 + 2) || *v16 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v16 + 1;
LABEL_49:
        *((_DWORD *)this + 11) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unsigned int v17 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v17 >= *((void *)a2 + 2) || *v17 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v17 + 1;
LABEL_55:
        *((_DWORD *)this + 11) |= 8u;
        if (*((void *)this + 3) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v18 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v18 >= *((void *)a2 + 2) || *v18 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v18 + 1;
LABEL_61:
        *((_DWORD *)this + 11) |= 0x10u;
        if (*((void *)this + 4) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) != *((void *)a2 + 2)
          || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
        {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_49;
        }
        goto LABEL_20;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_20;
        }
        goto LABEL_55;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_61;
        }
        goto LABEL_20;
      default:
        int v7 = TagFallback & 7;
LABEL_20:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t CLMicroLocationProto::ReceivedEventAction::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 44);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned int *)(v5 + 12), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    if ((*(_DWORD *)(v5 + 44) & 0x10) == 0) {
      return this;
    }
    goto LABEL_11;
  }
LABEL_9:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 8) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v6 & 0x10) == 0) {
    return this;
  }
LABEL_11:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::ReceivedEventAction::ByteSize(CLMicroLocationProto::ReceivedEventAction *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 44);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_50;
  }
  if (*((unsigned char *)this + 44))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v3 = 11;
      if ((v2 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 11);
      if ((v2 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_19;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 44) & 2) == 0) {
      goto LABEL_19;
    }
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 3);
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 11;
  }
  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
    int v2 = *((_DWORD *)this + 11);
  }
  else
  {
    int v6 = 2;
  }
  uint64_t v3 = (v6 + v3);
LABEL_19:
  if ((v2 & 4) != 0)
  {
    uint64_t v7 = *((void *)this + 2);
    int v8 = *(unsigned __int8 *)(v7 + 23);
    char v9 = v8;
    uint64_t v10 = *(void *)(v7 + 8);
    if ((v8 & 0x80u) == 0) {
      unint64_t v11 = *(unsigned __int8 *)(v7 + 23);
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11 >= 0x80)
    {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v11);
      int v8 = *(unsigned __int8 *)(v7 + 23);
      uint64_t v10 = *(void *)(v7 + 8);
      int v2 = *((_DWORD *)this + 11);
      char v9 = *(unsigned char *)(v7 + 23);
    }
    else
    {
      int v12 = 1;
    }
    if (v9 < 0) {
      int v8 = v10;
    }
    uint64_t v3 = (v3 + v12 + v8 + 1);
    if ((v2 & 8) == 0)
    {
LABEL_21:
      if ((v2 & 0x10) == 0) {
        goto LABEL_50;
      }
      goto LABEL_41;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_21;
  }
  uint64_t v13 = *((void *)this + 3);
  int v14 = *(unsigned __int8 *)(v13 + 23);
  char v15 = v14;
  uint64_t v16 = *(void *)(v13 + 8);
  if ((v14 & 0x80u) == 0) {
    unint64_t v17 = *(unsigned __int8 *)(v13 + 23);
  }
  else {
    unint64_t v17 = v16;
  }
  if (v17 >= 0x80)
  {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v17);
    int v14 = *(unsigned __int8 *)(v13 + 23);
    uint64_t v16 = *(void *)(v13 + 8);
    int v2 = *((_DWORD *)this + 11);
    char v15 = *(unsigned char *)(v13 + 23);
  }
  else
  {
    int v18 = 1;
  }
  if (v15 < 0) {
    int v14 = v16;
  }
  uint64_t v3 = (v3 + v18 + v14 + 1);
  if ((v2 & 0x10) != 0)
  {
LABEL_41:
    uint64_t v19 = *((void *)this + 4);
    int v20 = *(unsigned __int8 *)(v19 + 23);
    char v21 = v20;
    uint64_t v22 = *(void *)(v19 + 8);
    if ((v20 & 0x80u) == 0) {
      unint64_t v23 = *(unsigned __int8 *)(v19 + 23);
    }
    else {
      unint64_t v23 = v22;
    }
    if (v23 >= 0x80)
    {
      int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v23);
      int v20 = *(unsigned __int8 *)(v19 + 23);
      uint64_t v22 = *(void *)(v19 + 8);
      char v21 = *(unsigned char *)(v19 + 23);
    }
    else
    {
      int v24 = 1;
    }
    if (v21 < 0) {
      int v20 = v22;
    }
    uint64_t v3 = (v3 + v24 + v20 + 1);
  }
LABEL_50:
  *((_DWORD *)this + 10) = v3;
  return v3;
}

void CLMicroLocationProto::ReceivedEventAction::CheckTypeAndMergeFrom(CLMicroLocationProto::ReceivedEventAction *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ReceivedEventAction::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ReceivedEventAction::CopyFrom(CLMicroLocationProto::ReceivedEventAction *this, const CLMicroLocationProto::ReceivedEventAction *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ReceivedEventAction *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ReceivedEventAction::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ReceivedEventAction::IsInitialized(CLMicroLocationProto::ReceivedEventAction *this)
{
  return 1;
}

void *CLMicroLocationProto::ReceivedEventAction::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ReceivedEventAction");
}

void CLMicroLocationProto::RecordingRequest::MergeFrom(CLMicroLocationProto::RecordingRequest *this, const CLMicroLocationProto::RecordingRequest *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 44);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 44))
    {
      unsigned int v5 = *((_DWORD *)a2 + 2);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::RecordingRequest::MergeFrom();
      }
      *((_DWORD *)this + 11) |= 1u;
      *((_DWORD *)this + 2) = v5;
      int v4 = *((_DWORD *)a2 + 11);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *((_DWORD *)a2 + 3);
      if ((v6 - 1) >= 2) {
        CLMicroLocationProto::RecordingRequest::MergeFrom();
      }
      *((_DWORD *)this + 11) |= 2u;
      *((_DWORD *)this + 3) = v6;
      int v4 = *((_DWORD *)a2 + 11);
    }
    uint64_t v7 = (std::string *)MEMORY[0x263F8C740];
    if ((v4 & 4) != 0)
    {
      int v8 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 11) |= 4u;
      char v9 = (std::string *)*((void *)this + 2);
      if (v9 == v7) {
        operator new();
      }
      std::string::operator=(v9, v8);
      int v4 = *((_DWORD *)a2 + 11);
      if ((v4 & 8) == 0)
      {
LABEL_14:
        if ((v4 & 0x10) == 0) {
          return;
        }
        goto LABEL_22;
      }
    }
    else if ((v4 & 8) == 0)
    {
      goto LABEL_14;
    }
    uint64_t v10 = (const std::string *)*((void *)a2 + 3);
    *((_DWORD *)this + 11) |= 8u;
    unint64_t v11 = (std::string *)*((void *)this + 3);
    if (v11 == v7) {
      operator new();
    }
    std::string::operator=(v11, v10);
    if ((*((_DWORD *)a2 + 11) & 0x10) != 0)
    {
LABEL_22:
      int v12 = (const std::string *)*((void *)a2 + 4);
      *((_DWORD *)this + 11) |= 0x10u;
      uint64_t v13 = (std::string *)*((void *)this + 4);
      if (v13 == v7) {
        operator new();
      }
      std::string::operator=(v13, v12);
    }
  }
}

void sub_25641DAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RecordingRequest::~RecordingRequest(CLMicroLocationProto::RecordingRequest *this)
{
  *(void *)this = &unk_2704DE830;
  CLMicroLocationProto::ReceivedEventAction::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::RecordingRequest::~RecordingRequest(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::RecordingRequest::New(CLMicroLocationProto::RecordingRequest *this)
{
}

uint64_t CLMicroLocationProto::RecordingRequest::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 44);
  if (v1)
  {
    *(void *)(this + 8) = 0x10000000DLL;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 4) != 0)
    {
      uint64_t v3 = *(void *)(this + 16);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 44) & 8) != 0)
    {
      uint64_t v4 = *(void *)(this + 24);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 44) & 0x10) != 0)
    {
      uint64_t v5 = *(void *)(this + 32);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 44) = 0;
  return this;
}

uint64_t CLMicroLocationProto::RecordingRequest::MergePartialFromCodedStream(CLMicroLocationProto::RecordingRequest *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        unsigned int v21 = 0;
        int v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 < *((void *)a2 + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
LABEL_25:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v12 = ((1 << v9) & 0x76B6) == 0) : (BOOL v12 = 1), !v12))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::RecordingRequest::MergeFrom();
            }
            *((_DWORD *)this + 11) |= 1u;
            *((_DWORD *)this + 2) = v9;
          }
          int v14 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
          if ((unint64_t)v14 < v10 && *v14 == 16)
          {
            unint64_t v11 = v14 + 1;
            *((void *)a2 + 1) = v11;
            goto LABEL_39;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v21);
        if (result)
        {
          unsigned int v9 = v21;
          goto LABEL_25;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_20;
        }
        unint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
LABEL_39:
        unsigned int v20 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v20);
          if (!result) {
            return result;
          }
          unsigned int v15 = v20;
        }
        else
        {
          unsigned int v15 = *v11;
          *((void *)a2 + 1) = v11 + 1;
        }
        if (v15 - 1 <= 1)
        {
          *((_DWORD *)this + 11) |= 2u;
          *((_DWORD *)this + 3) = v15;
        }
        uint64_t v16 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v16 >= *((void *)a2 + 2) || *v16 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v16 + 1;
LABEL_49:
        *((_DWORD *)this + 11) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unint64_t v17 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v17 >= *((void *)a2 + 2) || *v17 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v17 + 1;
LABEL_55:
        *((_DWORD *)this + 11) |= 8u;
        if (*((void *)this + 3) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v18 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v18 >= *((void *)a2 + 2) || *v18 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v18 + 1;
LABEL_61:
        *((_DWORD *)this + 11) |= 0x10u;
        if (*((void *)this + 4) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) != *((void *)a2 + 2)
          || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
        {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_49;
        }
        goto LABEL_20;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_20;
        }
        goto LABEL_55;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_61;
        }
        goto LABEL_20;
      default:
        int v7 = TagFallback & 7;
LABEL_20:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t CLMicroLocationProto::RecordingRequest::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 44);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 44);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned int *)(v5 + 12), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    if ((*(_DWORD *)(v5 + 44) & 0x10) == 0) {
      return this;
    }
    goto LABEL_11;
  }
LABEL_9:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 44);
  if ((v6 & 8) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v6 & 0x10) == 0) {
    return this;
  }
LABEL_11:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::RecordingRequest::ByteSize(CLMicroLocationProto::RecordingRequest *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 44);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_50;
  }
  if (*((unsigned char *)this + 44))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v3 = 11;
      if ((v2 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 11);
      if ((v2 & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_19;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 44) & 2) == 0) {
      goto LABEL_19;
    }
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 3);
  if ((v5 & 0x80000000) != 0)
  {
    int v6 = 11;
  }
  else if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
    int v2 = *((_DWORD *)this + 11);
  }
  else
  {
    int v6 = 2;
  }
  uint64_t v3 = (v6 + v3);
LABEL_19:
  if ((v2 & 4) != 0)
  {
    uint64_t v7 = *((void *)this + 2);
    int v8 = *(unsigned __int8 *)(v7 + 23);
    char v9 = v8;
    uint64_t v10 = *(void *)(v7 + 8);
    if ((v8 & 0x80u) == 0) {
      unint64_t v11 = *(unsigned __int8 *)(v7 + 23);
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11 >= 0x80)
    {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v11);
      int v8 = *(unsigned __int8 *)(v7 + 23);
      uint64_t v10 = *(void *)(v7 + 8);
      int v2 = *((_DWORD *)this + 11);
      char v9 = *(unsigned char *)(v7 + 23);
    }
    else
    {
      int v12 = 1;
    }
    if (v9 < 0) {
      int v8 = v10;
    }
    uint64_t v3 = (v3 + v12 + v8 + 1);
    if ((v2 & 8) == 0)
    {
LABEL_21:
      if ((v2 & 0x10) == 0) {
        goto LABEL_50;
      }
      goto LABEL_41;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_21;
  }
  uint64_t v13 = *((void *)this + 3);
  int v14 = *(unsigned __int8 *)(v13 + 23);
  char v15 = v14;
  uint64_t v16 = *(void *)(v13 + 8);
  if ((v14 & 0x80u) == 0) {
    unint64_t v17 = *(unsigned __int8 *)(v13 + 23);
  }
  else {
    unint64_t v17 = v16;
  }
  if (v17 >= 0x80)
  {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v17);
    int v14 = *(unsigned __int8 *)(v13 + 23);
    uint64_t v16 = *(void *)(v13 + 8);
    int v2 = *((_DWORD *)this + 11);
    char v15 = *(unsigned char *)(v13 + 23);
  }
  else
  {
    int v18 = 1;
  }
  if (v15 < 0) {
    int v14 = v16;
  }
  uint64_t v3 = (v3 + v18 + v14 + 1);
  if ((v2 & 0x10) != 0)
  {
LABEL_41:
    uint64_t v19 = *((void *)this + 4);
    int v20 = *(unsigned __int8 *)(v19 + 23);
    char v21 = v20;
    uint64_t v22 = *(void *)(v19 + 8);
    if ((v20 & 0x80u) == 0) {
      unint64_t v23 = *(unsigned __int8 *)(v19 + 23);
    }
    else {
      unint64_t v23 = v22;
    }
    if (v23 >= 0x80)
    {
      int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v23);
      int v20 = *(unsigned __int8 *)(v19 + 23);
      uint64_t v22 = *(void *)(v19 + 8);
      char v21 = *(unsigned char *)(v19 + 23);
    }
    else
    {
      int v24 = 1;
    }
    if (v21 < 0) {
      int v20 = v22;
    }
    uint64_t v3 = (v3 + v24 + v20 + 1);
  }
LABEL_50:
  *((_DWORD *)this + 10) = v3;
  return v3;
}

void CLMicroLocationProto::RecordingRequest::CheckTypeAndMergeFrom(CLMicroLocationProto::RecordingRequest *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::RecordingRequest::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::RecordingRequest::CopyFrom(CLMicroLocationProto::RecordingRequest *this, const CLMicroLocationProto::RecordingRequest *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::RecordingRequest *))(*(void *)this + 32))(this);
    CLMicroLocationProto::RecordingRequest::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::RecordingRequest::IsInitialized(CLMicroLocationProto::RecordingRequest *this)
{
  return 1;
}

void *CLMicroLocationProto::RecordingRequest::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.RecordingRequest");
}

void CLMicroLocationProto::AppLaunch::New(CLMicroLocationProto::AppLaunch *this)
{
}

uint64_t CLMicroLocationProto::AppLaunch::MergePartialFromCodedStream(CLMicroLocationProto::AppLaunch *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v23 = 0;
        int v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v23);
          if (!result) {
            return result;
          }
          unsigned int v9 = v23;
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
        }
        if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v11 = ((1 << v9) & 0x76B6) == 0) : (BOOL v11 = 1), !v11))
        {
          if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
            CLMicroLocationProto::AppLaunch::MergeFrom();
          }
          *((_DWORD *)this + 10) |= 1u;
          *((_DWORD *)this + 8) = v9;
        }
        uint64_t v13 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v13 < *((void *)a2 + 2) && *v13 == 18)
        {
          *((void *)a2 + 1) = v13 + 1;
          goto LABEL_38;
        }
        continue;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_19;
        }
LABEL_38:
        *((_DWORD *)this + 10) |= 2u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v14 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v14 + 1;
LABEL_44:
        *((_DWORD *)this + 10) |= 4u;
        char v15 = (CLMicroLocationProto::BundleIdFeatures *)*((void *)this + 2);
        if (!v15) {
          operator new();
        }
        unsigned int v24 = 0;
        uint64_t v16 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v16 >= *((void *)a2 + 2) || *v16 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v24))return 0; {
        }
          }
        else
        {
          unsigned int v24 = *v16;
          *((void *)a2 + 1) = v16 + 1;
        }
        int v17 = *((_DWORD *)a2 + 14);
        int v18 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v17 + 1;
        if (v17 < v18)
        {
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (CLMicroLocationProto::BundleIdFeatures::MergePartialFromCodedStream(v15, a2))
          {
            if (*((unsigned char *)a2 + 36))
            {
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
              int v19 = *((_DWORD *)a2 + 14);
              BOOL v20 = __OFSUB__(v19, 1);
              int v21 = v19 - 1;
              if (v21 < 0 == v20) {
                *((_DWORD *)a2 + 14) = v21;
              }
              uint64_t v22 = (unsigned char *)*((void *)a2 + 1);
              if ((unint64_t)v22 < *((void *)a2 + 2) && *v22 == 34)
              {
                *((void *)a2 + 1) = v22 + 1;
LABEL_58:
                *((_DWORD *)this + 10) |= 8u;
                if (*((void *)this + 3) == v4) {
                  operator new();
                }
                uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
                if (!result) {
                  return result;
                }
                if (*((void *)a2 + 1) == *((void *)a2 + 2)
                  && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
                {
                  *((_DWORD *)a2 + 8) = 0;
                  uint64_t result = 1;
                  *((unsigned char *)a2 + 36) = 1;
                  return result;
                }
              }
              continue;
            }
          }
        }
        return 0;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_44;
        }
        goto LABEL_19;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_58;
        }
        goto LABEL_19;
      default:
        int v7 = TagFallback & 7;
LABEL_19:
        if (v7 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

void CLMicroLocationProto::AppLaunch::CheckTypeAndMergeFrom(CLMicroLocationProto::AppLaunch *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::AppLaunch::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::AppLaunch::IsInitialized(CLMicroLocationProto::AppLaunch *this)
{
  return 1;
}

void *CLMicroLocationProto::AppLaunch::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.AppLaunch");
}

void CLMicroLocationProto::BacklightOn::MergeFrom(CLMicroLocationProto::BacklightOn *this, const CLMicroLocationProto::BacklightOn *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 24))
    {
      unsigned int v5 = *((_DWORD *)a2 + 4);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::BacklightOn::MergeFrom();
      }
      *((_DWORD *)this + 6) |= 1u;
      *((_DWORD *)this + 4) = v5;
      int v4 = *((_DWORD *)a2 + 6);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 6) |= 2u;
      int v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
    }
  }
}

void sub_25641E9B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::BacklightOn::New(CLMicroLocationProto::BacklightOn *this)
{
}

uint64_t CLMicroLocationProto::BacklightOn::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 24);
  if (v1)
  {
    *(_DWORD *)(this + 16) = 4;
    if ((v1 & 2) != 0)
    {
      uint64_t v2 = *(void *)(this + 8);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::BacklightOn::MergePartialFromCodedStream(CLMicroLocationProto::BacklightOn *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      unsigned int v5 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v5;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unsigned int v14 = 0;
      int v8 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v14);
        if (!result) {
          return result;
        }
        unsigned int v9 = v14;
      }
      else
      {
        unsigned int v9 = *v8;
        *((void *)a2 + 1) = v8 + 1;
      }
      if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v10 = ((1 << v9) & 0x76B6) == 0) : (BOOL v10 = 1), !v10))
      {
        if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
          CLMicroLocationProto::BacklightOn::MergeFrom();
        }
        *((_DWORD *)this + 6) |= 1u;
        *((_DWORD *)this + 4) = v9;
      }
      int v12 = (unsigned char *)*((void *)a2 + 1);
      if ((unint64_t)v12 < *((void *)a2 + 2) && *v12 == 18)
      {
        *((void *)a2 + 1) = v12 + 1;
LABEL_35:
        *((_DWORD *)this + 6) |= 2u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if (v7 == 2) {
        goto LABEL_35;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_16:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

void CLMicroLocationProto::BacklightOn::CheckTypeAndMergeFrom(CLMicroLocationProto::BacklightOn *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::BacklightOn::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::BacklightOn::CopyFrom(CLMicroLocationProto::BacklightOn *this, const CLMicroLocationProto::BacklightOn *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::BacklightOn *))(*(void *)this + 32))(this);
    CLMicroLocationProto::BacklightOn::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::BacklightOn::IsInitialized(CLMicroLocationProto::BacklightOn *this)
{
  return 1;
}

void *CLMicroLocationProto::BacklightOn::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.BacklightOn");
}

void CLMicroLocationProto::BatteryChargerConnected::MergeFrom(CLMicroLocationProto::BatteryChargerConnected *this, const CLMicroLocationProto::BatteryChargerConnected *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::BatteryChargerConnected::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_25641EE50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::BatteryChargerConnected::New(CLMicroLocationProto::BatteryChargerConnected *this)
{
}

uint64_t CLMicroLocationProto::BatteryChargerConnected::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 5;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::BatteryChargerConnected::MergePartialFromCodedStream(CLMicroLocationProto::BatteryChargerConnected *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      unsigned int v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      int v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::BatteryChargerConnected::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

void CLMicroLocationProto::BatteryChargerConnected::CheckTypeAndMergeFrom(CLMicroLocationProto::BatteryChargerConnected *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::BatteryChargerConnected::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::BatteryChargerConnected::CopyFrom(CLMicroLocationProto::BatteryChargerConnected *this, const CLMicroLocationProto::BatteryChargerConnected *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::BatteryChargerConnected *))(*(void *)this + 32))(this);
    CLMicroLocationProto::BatteryChargerConnected::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::BatteryChargerConnected::IsInitialized(CLMicroLocationProto::BatteryChargerConnected *this)
{
  return 1;
}

void *CLMicroLocationProto::BatteryChargerConnected::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.BatteryChargerConnected");
}

void CLMicroLocationProto::TruthLabelDonation::MergeFrom(CLMicroLocationProto::TruthLabelDonation *this, const CLMicroLocationProto::TruthLabelDonation *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 40);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 40))
    {
      unsigned int v5 = *((_DWORD *)a2 + 8);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::TruthLabelDonation::MergeFrom();
      }
      *((_DWORD *)this + 10) |= 1u;
      *((_DWORD *)this + 8) = v5;
      int v4 = *((_DWORD *)a2 + 10);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 10) |= 2u;
      unsigned int v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 10);
      if ((v4 & 4) == 0)
      {
LABEL_11:
        if ((v4 & 8) == 0) {
          return;
        }
        goto LABEL_19;
      }
    }
    else if ((v4 & 4) == 0)
    {
      goto LABEL_11;
    }
    BOOL v8 = (const std::string *)*((void *)a2 + 2);
    *((_DWORD *)this + 10) |= 4u;
    unsigned int v9 = (std::string *)*((void *)this + 2);
    if (v9 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v9, v8);
    if ((*((_DWORD *)a2 + 10) & 8) != 0)
    {
LABEL_19:
      BOOL v10 = (const std::string *)*((void *)a2 + 3);
      *((_DWORD *)this + 10) |= 8u;
      unsigned int v11 = (std::string *)*((void *)this + 3);
      if (v11 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v11, v10);
    }
  }
}

void sub_25641F328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::TruthLabelDonation::~TruthLabelDonation(CLMicroLocationProto::TruthLabelDonation *this)
{
  *(void *)this = &unk_2704DEA10;
  CLMicroLocationProto::TruthLabelDonation::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::TruthLabelDonation::~TruthLabelDonation(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::TruthLabelDonation::SharedDtor(CLMicroLocationProto::TruthLabelDonation *this)
{
  char v1 = this;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::TruthLabelDonation *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 2);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::TruthLabelDonation *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  uint64_t v7 = *((void *)v1 + 3);
  if (v7 != v3 && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    this = (CLMicroLocationProto::TruthLabelDonation *)MEMORY[0x25A2A6340](v7, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::TruthLabelDonation::New(CLMicroLocationProto::TruthLabelDonation *this)
{
}

uint64_t CLMicroLocationProto::TruthLabelDonation::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 40);
  if (v1)
  {
    *(_DWORD *)(this + 32) = 14;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 40) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 40) & 8) != 0)
    {
      uint64_t v5 = *(void *)(this + 24);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t CLMicroLocationProto::TruthLabelDonation::MergePartialFromCodedStream(CLMicroLocationProto::TruthLabelDonation *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 < *((void *)a2 + 2) && (*v5 & 0x80000000) == 0)
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
LABEL_7:
      switch(TagFallback >> 3)
      {
        case 1u:
          int v7 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_19;
          }
          unsigned int v16 = 0;
          BOOL v8 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v16);
            if (!result) {
              return result;
            }
            unsigned int v9 = v16;
          }
          else
          {
            unsigned int v9 = *v8;
            *((void *)a2 + 1) = v8 + 1;
          }
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v10 = ((1 << v9) & 0x76B6) == 0) : (BOOL v10 = 1), !v10))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::TruthLabelDonation::MergeFrom();
            }
            *((_DWORD *)this + 10) |= 1u;
            *((_DWORD *)this + 8) = v9;
          }
          int v12 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v12 < *((void *)a2 + 2) && *v12 == 18)
          {
            *((void *)a2 + 1) = v12 + 1;
            goto LABEL_38;
          }
          continue;
        case 2u:
          int v7 = TagFallback & 7;
          if (v7 != 2) {
            goto LABEL_19;
          }
LABEL_38:
          *((_DWORD *)this + 10) |= 2u;
          if (*((void *)this + 1) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
          if (!result) {
            return result;
          }
          uint64_t v13 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v13 >= *((void *)a2 + 2) || *v13 != 26) {
            continue;
          }
          *((void *)a2 + 1) = v13 + 1;
LABEL_44:
          *((_DWORD *)this + 10) |= 4u;
          if (*((void *)this + 2) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!result) {
            return result;
          }
          unsigned int v14 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 != 34) {
            continue;
          }
          *((void *)a2 + 1) = v14 + 1;
LABEL_50:
          *((_DWORD *)this + 10) |= 8u;
          if (*((void *)this + 3) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!result) {
            return result;
          }
          if (*((void *)a2 + 1) != *((void *)a2 + 2)
            || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
          {
            continue;
          }
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        case 3u:
          int v7 = TagFallback & 7;
          if (v7 == 2) {
            goto LABEL_44;
          }
          goto LABEL_19;
        case 4u:
          int v7 = TagFallback & 7;
          if (v7 == 2) {
            goto LABEL_50;
          }
          goto LABEL_19;
        default:
          int v7 = TagFallback & 7;
LABEL_19:
          if (v7 == 4) {
            return 1;
          }
          if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
          return 0;
          }
      }
    }
    break;
  }
  TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
  *((_DWORD *)a2 + 8) = TagFallback;
  if (TagFallback) {
    goto LABEL_7;
  }
  return 1;
}

uint64_t CLMicroLocationProto::TruthLabelDonation::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 40);
  if (v5)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 32), (uint64_t)a2, a4);
    int v5 = *(_DWORD *)(v4 + 40);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
      if ((*(_DWORD *)(v4 + 40) & 8) == 0) {
        return this;
      }
      goto LABEL_9;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v5 = *(_DWORD *)(v4 + 40);
  if ((v5 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v5 & 8) == 0) {
    return this;
  }
LABEL_9:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::TruthLabelDonation::ByteSize(CLMicroLocationProto::TruthLabelDonation *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 40);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_43;
  }
  if (*((unsigned char *)this + 40))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v3 = 11;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 10);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 40) & 2) == 0) {
      goto LABEL_22;
    }
  }
  uint64_t v5 = *((void *)this + 1);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v2 = *((_DWORD *)this + 10);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 1;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v3 = (v3 + v10 + v6 + 1);
LABEL_22:
  if ((v2 & 4) == 0)
  {
    if ((v2 & 8) == 0) {
      goto LABEL_43;
    }
    goto LABEL_34;
  }
  uint64_t v11 = *((void *)this + 2);
  int v12 = *(unsigned __int8 *)(v11 + 23);
  char v13 = v12;
  uint64_t v14 = *(void *)(v11 + 8);
  if ((v12 & 0x80u) == 0) {
    unint64_t v15 = *(unsigned __int8 *)(v11 + 23);
  }
  else {
    unint64_t v15 = v14;
  }
  if (v15 >= 0x80)
  {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v15);
    int v12 = *(unsigned __int8 *)(v11 + 23);
    uint64_t v14 = *(void *)(v11 + 8);
    int v2 = *((_DWORD *)this + 10);
    char v13 = *(unsigned char *)(v11 + 23);
  }
  else
  {
    int v16 = 1;
  }
  if (v13 < 0) {
    int v12 = v14;
  }
  uint64_t v3 = (v3 + v16 + v12 + 1);
  if ((v2 & 8) != 0)
  {
LABEL_34:
    uint64_t v17 = *((void *)this + 3);
    int v18 = *(unsigned __int8 *)(v17 + 23);
    char v19 = v18;
    uint64_t v20 = *(void *)(v17 + 8);
    if ((v18 & 0x80u) == 0) {
      unint64_t v21 = *(unsigned __int8 *)(v17 + 23);
    }
    else {
      unint64_t v21 = v20;
    }
    if (v21 >= 0x80)
    {
      int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v21);
      int v18 = *(unsigned __int8 *)(v17 + 23);
      uint64_t v20 = *(void *)(v17 + 8);
      char v19 = *(unsigned char *)(v17 + 23);
    }
    else
    {
      int v22 = 1;
    }
    if (v19 < 0) {
      int v18 = v20;
    }
    uint64_t v3 = (v3 + v22 + v18 + 1);
  }
LABEL_43:
  *((_DWORD *)this + 9) = v3;
  return v3;
}

void CLMicroLocationProto::TruthLabelDonation::CheckTypeAndMergeFrom(CLMicroLocationProto::TruthLabelDonation *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::TruthLabelDonation::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::TruthLabelDonation::CopyFrom(CLMicroLocationProto::TruthLabelDonation *this, const CLMicroLocationProto::TruthLabelDonation *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::TruthLabelDonation *))(*(void *)this + 32))(this);
    CLMicroLocationProto::TruthLabelDonation::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::TruthLabelDonation::IsInitialized(CLMicroLocationProto::TruthLabelDonation *this)
{
  return 1;
}

void *CLMicroLocationProto::TruthLabelDonation::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.TruthLabelDonation");
}

void CLMicroLocationProto::ForcedRecording::MergeFrom(CLMicroLocationProto::ForcedRecording *this, const CLMicroLocationProto::ForcedRecording *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::ForcedRecording::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_25641FD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ForcedRecording::~ForcedRecording(CLMicroLocationProto::ForcedRecording *this)
{
  *(void *)this = &unk_2704DEA88;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ForcedRecording::~ForcedRecording(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ForcedRecording::New(CLMicroLocationProto::ForcedRecording *this)
{
}

uint64_t CLMicroLocationProto::ForcedRecording::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 7;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ForcedRecording::MergePartialFromCodedStream(CLMicroLocationProto::ForcedRecording *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      unsigned int v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      int v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::ForcedRecording::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::ForcedRecording::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::ForcedRecording::ByteSize(CLMicroLocationProto::ForcedRecording *this)
{
  if (*((unsigned char *)this + 16))
  {
    uint64_t v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::ForcedRecording::CheckTypeAndMergeFrom(CLMicroLocationProto::ForcedRecording *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ForcedRecording::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ForcedRecording::CopyFrom(CLMicroLocationProto::ForcedRecording *this, const CLMicroLocationProto::ForcedRecording *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ForcedRecording *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ForcedRecording::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ForcedRecording::IsInitialized(CLMicroLocationProto::ForcedRecording *this)
{
  return 1;
}

void *CLMicroLocationProto::ForcedRecording::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ForcedRecording");
}

void CLMicroLocationProto::HomeKitAccessory::MergeFrom(CLMicroLocationProto::HomeKitAccessory *this, const CLMicroLocationProto::HomeKitAccessory *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v32);
  }
  int v4 = *((_DWORD *)a2 + 29);
  if (!(_BYTE)v4) {
    goto LABEL_38;
  }
  if (v4)
  {
    unsigned int v5 = *((_DWORD *)a2 + 16);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
      CLMicroLocationProto::HomeKitAccessory::MergeFrom();
    }
    *((_DWORD *)this + 29) |= 1u;
    *((_DWORD *)this + 16) = v5;
    int v4 = *((_DWORD *)a2 + 29);
  }
  if ((v4 & 2) != 0)
  {
    int v6 = (const std::string *)*((void *)a2 + 1);
    *((_DWORD *)this + 29) |= 2u;
    unsigned int v7 = (std::string *)*((void *)this + 1);
    if (v7 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v7, v6);
    int v4 = *((_DWORD *)a2 + 29);
    if ((v4 & 4) == 0)
    {
LABEL_11:
      if ((v4 & 8) == 0) {
        goto LABEL_12;
      }
      goto LABEL_23;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_11;
  }
  BOOL v8 = (const std::string *)*((void *)a2 + 2);
  *((_DWORD *)this + 29) |= 4u;
  unint64_t v9 = (std::string *)*((void *)this + 2);
  if (v9 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v9, v8);
  int v4 = *((_DWORD *)a2 + 29);
  if ((v4 & 8) == 0)
  {
LABEL_12:
    if ((v4 & 0x10) == 0) {
      goto LABEL_13;
    }
    goto LABEL_26;
  }
LABEL_23:
  int v10 = (const std::string *)*((void *)a2 + 3);
  *((_DWORD *)this + 29) |= 8u;
  unsigned int v11 = (std::string *)*((void *)this + 3);
  if (v11 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v11, v10);
  int v4 = *((_DWORD *)a2 + 29);
  if ((v4 & 0x10) == 0)
  {
LABEL_13:
    if ((v4 & 0x20) == 0) {
      goto LABEL_14;
    }
LABEL_29:
    uint64_t v14 = (const std::string *)*((void *)a2 + 5);
    *((_DWORD *)this + 29) |= 0x20u;
    unint64_t v15 = (std::string *)*((void *)this + 5);
    if (v15 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v15, v14);
    int v4 = *((_DWORD *)a2 + 29);
    if ((v4 & 0x40) == 0)
    {
LABEL_15:
      if ((v4 & 0x80) == 0) {
        goto LABEL_38;
      }
      goto LABEL_35;
    }
    goto LABEL_32;
  }
LABEL_26:
  int v12 = (const std::string *)*((void *)a2 + 4);
  *((_DWORD *)this + 29) |= 0x10u;
  char v13 = (std::string *)*((void *)this + 4);
  if (v13 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v13, v12);
  int v4 = *((_DWORD *)a2 + 29);
  if ((v4 & 0x20) != 0) {
    goto LABEL_29;
  }
LABEL_14:
  if ((v4 & 0x40) == 0) {
    goto LABEL_15;
  }
LABEL_32:
  int v16 = (const std::string *)*((void *)a2 + 6);
  *((_DWORD *)this + 29) |= 0x40u;
  uint64_t v17 = (std::string *)*((void *)this + 6);
  if (v17 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v17, v16);
  int v4 = *((_DWORD *)a2 + 29);
  if ((v4 & 0x80) != 0)
  {
LABEL_35:
    int v18 = (const std::string *)*((void *)a2 + 7);
    *((_DWORD *)this + 29) |= 0x80u;
    char v19 = (std::string *)*((void *)this + 7);
    if (v19 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v19, v18);
    int v4 = *((_DWORD *)a2 + 29);
  }
LABEL_38:
  if ((v4 & 0xFF00) == 0) {
    return;
  }
  if ((v4 & 0x100) != 0)
  {
    uint64_t v20 = (const std::string *)*((void *)a2 + 9);
    *((_DWORD *)this + 29) |= 0x100u;
    unint64_t v21 = (std::string *)*((void *)this + 9);
    if (v21 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v21, v20);
    int v4 = *((_DWORD *)a2 + 29);
    if ((v4 & 0x200) == 0)
    {
LABEL_41:
      if ((v4 & 0x400) == 0) {
        goto LABEL_42;
      }
      goto LABEL_53;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_41;
  }
  int v22 = (const std::string *)*((void *)a2 + 10);
  *((_DWORD *)this + 29) |= 0x200u;
  unsigned int v23 = (std::string *)*((void *)this + 10);
  if (v23 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v23, v22);
  int v4 = *((_DWORD *)a2 + 29);
  if ((v4 & 0x400) == 0)
  {
LABEL_42:
    if ((v4 & 0x800) == 0) {
      goto LABEL_43;
    }
    goto LABEL_54;
  }
LABEL_53:
  char v24 = *((unsigned char *)a2 + 68);
  *((_DWORD *)this + 29) |= 0x400u;
  *((unsigned char *)this + 68) = v24;
  int v4 = *((_DWORD *)a2 + 29);
  if ((v4 & 0x800) == 0)
  {
LABEL_43:
    if ((v4 & 0x1000) == 0) {
      goto LABEL_44;
    }
    goto LABEL_55;
  }
LABEL_54:
  char v25 = *((unsigned char *)a2 + 69);
  *((_DWORD *)this + 29) |= 0x800u;
  *((unsigned char *)this + 69) = v25;
  int v4 = *((_DWORD *)a2 + 29);
  if ((v4 & 0x1000) == 0)
  {
LABEL_44:
    if ((v4 & 0x2000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_58;
  }
LABEL_55:
  int v26 = (const std::string *)*((void *)a2 + 11);
  *((_DWORD *)this + 29) |= 0x1000u;
  int v27 = (std::string *)*((void *)this + 11);
  if (v27 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v27, v26);
  int v4 = *((_DWORD *)a2 + 29);
  if ((v4 & 0x2000) == 0)
  {
LABEL_45:
    if ((v4 & 0x4000) == 0) {
      return;
    }
    goto LABEL_61;
  }
LABEL_58:
  unint64_t v28 = (const std::string *)*((void *)a2 + 12);
  *((_DWORD *)this + 29) |= 0x2000u;
  int v29 = (std::string *)*((void *)this + 12);
  if (v29 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v29, v28);
  if ((*((_DWORD *)a2 + 29) & 0x4000) != 0)
  {
LABEL_61:
    unint64_t v30 = (const std::string *)*((void *)a2 + 13);
    *((_DWORD *)this + 29) |= 0x4000u;
    int v31 = (std::string *)*((void *)this + 13);
    if (v31 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v31, v30);
  }
}

void sub_25642066C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::HomeKitAccessory::~HomeKitAccessory(CLMicroLocationProto::HomeKitAccessory *this)
{
  *(void *)this = &unk_2704DEB00;
  CLMicroLocationProto::HomeKitAccessory::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::HomeKitAccessory::~HomeKitAccessory(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::HomeKitAccessory::SharedDtor(CLMicroLocationProto::HomeKitAccessory *this)
{
  char v1 = this;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 2);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  uint64_t v7 = *((void *)v1 + 3);
  if (v7 != v3 && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v7, 0x1012C40EC159624);
  }
  uint64_t v9 = *((void *)v1 + 4);
  if (v9 != v3 && v9 != 0)
  {
    if (*(char *)(v9 + 23) < 0) {
      operator delete(*(void **)v9);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v9, 0x1012C40EC159624);
  }
  uint64_t v11 = *((void *)v1 + 5);
  if (v11 != v3 && v11)
  {
    if (*(char *)(v11 + 23) < 0) {
      operator delete(*(void **)v11);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v11, 0x1012C40EC159624);
  }
  uint64_t v12 = *((void *)v1 + 6);
  if (v12 != v3 && v12)
  {
    if (*(char *)(v12 + 23) < 0) {
      operator delete(*(void **)v12);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v12, 0x1012C40EC159624);
  }
  uint64_t v13 = *((void *)v1 + 7);
  if (v13 != v3 && v13)
  {
    if (*(char *)(v13 + 23) < 0) {
      operator delete(*(void **)v13);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v13, 0x1012C40EC159624);
  }
  uint64_t v14 = *((void *)v1 + 9);
  if (v14 != v3 && v14)
  {
    if (*(char *)(v14 + 23) < 0) {
      operator delete(*(void **)v14);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v14, 0x1012C40EC159624);
  }
  uint64_t v15 = *((void *)v1 + 10);
  if (v15 != v3 && v15)
  {
    if (*(char *)(v15 + 23) < 0) {
      operator delete(*(void **)v15);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v15, 0x1012C40EC159624);
  }
  uint64_t v16 = *((void *)v1 + 11);
  if (v16 != v3 && v16)
  {
    if (*(char *)(v16 + 23) < 0) {
      operator delete(*(void **)v16);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v16, 0x1012C40EC159624);
  }
  uint64_t v17 = *((void *)v1 + 12);
  if (v17 != v3 && v17)
  {
    if (*(char *)(v17 + 23) < 0) {
      operator delete(*(void **)v17);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v17, 0x1012C40EC159624);
  }
  uint64_t v18 = *((void *)v1 + 13);
  if (v18 != v3 && v18)
  {
    if (*(char *)(v18 + 23) < 0) {
      operator delete(*(void **)v18);
    }
    this = (CLMicroLocationProto::HomeKitAccessory *)MEMORY[0x25A2A6340](v18, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::HomeKitAccessory::New(CLMicroLocationProto::HomeKitAccessory *this)
{
}

uint64_t CLMicroLocationProto::HomeKitAccessory::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 116);
  if (v1)
  {
    *(_DWORD *)(this + 64) = 9;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 116) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 116) & 8) != 0)
    {
      uint64_t v5 = *(void *)(this + 24);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 116) & 0x10) != 0)
    {
      uint64_t v6 = *(void *)(this + 32);
      if (v6 != v2)
      {
        if (*(char *)(v6 + 23) < 0)
        {
          **(unsigned char **)uint64_t v6 = 0;
          *(void *)(v6 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(unsigned char *)(v6 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 116) & 0x20) != 0)
    {
      uint64_t v7 = *(void *)(this + 40);
      if (v7 != v2)
      {
        if (*(char *)(v7 + 23) < 0)
        {
          **(unsigned char **)uint64_t v7 = 0;
          *(void *)(v7 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v7 = 0;
          *(unsigned char *)(v7 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 116) & 0x40) != 0)
    {
      uint64_t v8 = *(void *)(this + 48);
      if (v8 != v2)
      {
        if (*(char *)(v8 + 23) < 0)
        {
          **(unsigned char **)uint64_t v8 = 0;
          *(void *)(v8 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v8 = 0;
          *(unsigned char *)(v8 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 116) & 0x80) != 0)
    {
      uint64_t v9 = *(void *)(this + 56);
      if (v9 != v2)
      {
        if (*(char *)(v9 + 23) < 0)
        {
          **(unsigned char **)uint64_t v9 = 0;
          *(void *)(v9 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v9 = 0;
          *(unsigned char *)(v9 + 23) = 0;
        }
      }
    }
  }
  int v10 = *(_DWORD *)(this + 116);
  if ((v10 & 0xFF00) != 0)
  {
    if ((v10 & 0x100) != 0)
    {
      uint64_t v11 = *(void *)(this + 72);
      if (v11 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v11 + 23) < 0)
        {
          **(unsigned char **)uint64_t v11 = 0;
          *(void *)(v11 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v11 = 0;
          *(unsigned char *)(v11 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 117) & 2) != 0)
    {
      uint64_t v12 = *(void *)(this + 80);
      if (v12 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v12 + 23) < 0)
        {
          **(unsigned char **)uint64_t v12 = 0;
          *(void *)(v12 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v12 = 0;
          *(unsigned char *)(v12 + 23) = 0;
        }
      }
    }
    *(_WORD *)(this + 68) = 0;
    if ((*(unsigned char *)(this + 117) & 0x10) != 0)
    {
      uint64_t v13 = *(void *)(this + 88);
      if (v13 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v13 + 23) < 0)
        {
          **(unsigned char **)uint64_t v13 = 0;
          *(void *)(v13 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v13 = 0;
          *(unsigned char *)(v13 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 117) & 0x20) != 0)
    {
      uint64_t v14 = *(void *)(this + 96);
      if (v14 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v14 + 23) < 0)
        {
          **(unsigned char **)uint64_t v14 = 0;
          *(void *)(v14 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v14 = 0;
          *(unsigned char *)(v14 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 117) & 0x40) != 0)
    {
      uint64_t v15 = *(void *)(this + 104);
      if (v15 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v15 + 23) < 0)
        {
          **(unsigned char **)uint64_t v15 = 0;
          *(void *)(v15 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v15 = 0;
          *(unsigned char *)(v15 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 116) = 0;
  return this;
}

uint64_t CLMicroLocationProto::HomeKitAccessory::MergePartialFromCodedStream(CLMicroLocationProto::HomeKitAccessory *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_40;
        }
        unsigned int v33 = 0;
        uint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 < *((void *)a2 + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
LABEL_45:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v14 = ((1 << v9) & 0x76B6) == 0) : (BOOL v14 = 1), !v14))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::HomeKitAccessory::MergeFrom();
            }
            *((_DWORD *)this + 29) |= 1u;
            *((_DWORD *)this + 16) = v9;
          }
          uint64_t v16 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v16 < *((void *)a2 + 2) && *v16 == 18)
          {
            *((void *)a2 + 1) = v16 + 1;
            goto LABEL_59;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v33);
        if (result)
        {
          unsigned int v9 = v33;
          goto LABEL_45;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_40;
        }
LABEL_59:
        *((_DWORD *)this + 29) |= 2u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v17 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v17 >= *((void *)a2 + 2) || *v17 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v17 + 1;
LABEL_65:
        *((_DWORD *)this + 29) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v18 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v18 >= *((void *)a2 + 2) || *v18 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v18 + 1;
LABEL_71:
        *((_DWORD *)this + 29) |= 8u;
        if (*((void *)this + 3) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        char v19 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v19 >= *((void *)a2 + 2) || *v19 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v19 + 1;
LABEL_77:
        *((_DWORD *)this + 29) |= 0x10u;
        if (*((void *)this + 4) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v20 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v20 >= *((void *)a2 + 2) || *v20 != 50) {
          continue;
        }
        *((void *)a2 + 1) = v20 + 1;
LABEL_83:
        *((_DWORD *)this + 29) |= 0x20u;
        if (*((void *)this + 5) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unint64_t v21 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v21 >= *((void *)a2 + 2) || *v21 != 58) {
          continue;
        }
        *((void *)a2 + 1) = v21 + 1;
LABEL_89:
        *((_DWORD *)this + 29) |= 0x40u;
        if (*((void *)this + 6) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v22 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v22 >= *((void *)a2 + 2) || *v22 != 66) {
          continue;
        }
        *((void *)a2 + 1) = v22 + 1;
LABEL_95:
        *((_DWORD *)this + 29) |= 0x80u;
        if (*((void *)this + 7) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unsigned int v23 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v23 >= *((void *)a2 + 2) || *v23 != 74) {
          continue;
        }
        *((void *)a2 + 1) = v23 + 1;
LABEL_101:
        *((_DWORD *)this + 29) |= 0x100u;
        if (*((void *)this + 9) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        char v24 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v24 >= *((void *)a2 + 2) || *v24 != 82) {
          continue;
        }
        *((void *)a2 + 1) = v24 + 1;
LABEL_107:
        *((_DWORD *)this + 29) |= 0x200u;
        if (*((void *)this + 10) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        char v25 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((unint64_t)v25 >= v10 || *v25 != 88) {
          continue;
        }
        uint64_t v13 = v25 + 1;
        *((void *)a2 + 1) = v13;
LABEL_113:
        unsigned int v35 = 0;
        if ((unint64_t)v13 >= v10 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v35);
          if (!result) {
            return result;
          }
          unsigned int v26 = v35;
          int v27 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v26 = *v13;
          int v27 = v13 + 1;
          *((void *)a2 + 1) = v27;
        }
        *((unsigned char *)this + 68) = v26 != 0;
        *((_DWORD *)this + 29) |= 0x400u;
        if ((unint64_t)v27 >= v10 || *v27 != 96) {
          continue;
        }
        uint64_t v11 = v27 + 1;
        *((void *)a2 + 1) = v11;
LABEL_121:
        unsigned int v34 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v34);
          if (!result) {
            return result;
          }
          unsigned int v28 = v34;
          int v29 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v28 = *v11;
          int v29 = v11 + 1;
          *((void *)a2 + 1) = v29;
        }
        *((unsigned char *)this + 69) = v28 != 0;
        int v12 = *((_DWORD *)this + 29) | 0x800;
        *((_DWORD *)this + 29) = v12;
        if ((unint64_t)v29 >= v10 || *v29 != 106) {
          continue;
        }
        *((void *)a2 + 1) = v29 + 1;
LABEL_129:
        *((_DWORD *)this + 29) = v12 | 0x1000;
        if (*((void *)this + 11) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unint64_t v30 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v30 >= *((void *)a2 + 2) || *v30 != 114) {
          continue;
        }
        *((void *)a2 + 1) = v30 + 1;
LABEL_135:
        *((_DWORD *)this + 29) |= 0x2000u;
        if (*((void *)this + 12) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v31 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v31 >= *((void *)a2 + 2) || *v31 != 122) {
          continue;
        }
        *((void *)a2 + 1) = v31 + 1;
LABEL_141:
        *((_DWORD *)this + 29) |= 0x4000u;
        if (*((void *)this + 13) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) != *((void *)a2 + 2)
          || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
        {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_65;
        }
        goto LABEL_40;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_71;
        }
        goto LABEL_40;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_77;
        }
        goto LABEL_40;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_83;
        }
        goto LABEL_40;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_89;
        }
        goto LABEL_40;
      case 8u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_95;
        }
        goto LABEL_40;
      case 9u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_101;
        }
        goto LABEL_40;
      case 0xAu:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_107;
        }
        goto LABEL_40;
      case 0xBu:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_40;
        }
        uint64_t v13 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_113;
      case 0xCu:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_40;
        }
        uint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_121;
      case 0xDu:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_40;
        }
        int v12 = *((_DWORD *)this + 29);
        goto LABEL_129;
      case 0xEu:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_40;
        }
        goto LABEL_135;
      case 0xFu:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_141;
        }
        goto LABEL_40;
      default:
        int v7 = TagFallback & 7;
LABEL_40:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t CLMicroLocationProto::HomeKitAccessory::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 116);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 64), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 116);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_19;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_20;
  }
LABEL_19:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_21;
  }
LABEL_20:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_22;
  }
LABEL_21:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_23;
  }
LABEL_22:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_24;
  }
LABEL_23:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_25;
  }
LABEL_24:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_26;
  }
LABEL_25:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_27;
  }
LABEL_26:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0) {
      goto LABEL_13;
    }
    goto LABEL_28;
  }
LABEL_27:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, *(unsigned __int8 *)(v5 + 68), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x800) == 0)
  {
LABEL_13:
    if ((v6 & 0x1000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_29;
  }
LABEL_28:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, *(unsigned __int8 *)(v5 + 69), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x1000) == 0)
  {
LABEL_14:
    if ((v6 & 0x2000) == 0) {
      goto LABEL_15;
    }
LABEL_30:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    if ((*(_DWORD *)(v5 + 116) & 0x4000) == 0) {
      return this;
    }
    goto LABEL_31;
  }
LABEL_29:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 116);
  if ((v6 & 0x2000) != 0) {
    goto LABEL_30;
  }
LABEL_15:
  if ((v6 & 0x4000) == 0) {
    return this;
  }
LABEL_31:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
}

uint64_t CLMicroLocationProto::HomeKitAccessory::ByteSize(CLMicroLocationProto::HomeKitAccessory *this)
{
  int v2 = *((_DWORD *)this + 29);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_82;
  }
  if (v2)
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 16);
    if ((v4 & 0x80000000) != 0)
    {
      int v5 = 10;
    }
    else if (v4 >= 0x80)
    {
      int v5 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4);
      int v2 = *((_DWORD *)this + 29);
    }
    else
    {
      int v5 = 1;
    }
    uint64_t v3 = (v5 + 1);
    if ((v2 & 2) == 0) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((v2 & 2) == 0) {
      goto LABEL_21;
    }
  }
  uint64_t v6 = *((void *)this + 1);
  int v7 = *(unsigned __int8 *)(v6 + 23);
  char v8 = v7;
  uint64_t v9 = *(void *)(v6 + 8);
  if ((v7 & 0x80u) == 0) {
    unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10);
    int v7 = *(unsigned __int8 *)(v6 + 23);
    uint64_t v9 = *(void *)(v6 + 8);
    int v2 = *((_DWORD *)this + 29);
    char v8 = *(unsigned char *)(v6 + 23);
  }
  else
  {
    int v11 = 1;
  }
  if (v8 < 0) {
    int v7 = v9;
  }
  uint64_t v3 = (v3 + v11 + v7 + 1);
LABEL_21:
  if ((v2 & 4) != 0)
  {
    uint64_t v12 = *((void *)this + 2);
    int v13 = *(unsigned __int8 *)(v12 + 23);
    char v14 = v13;
    uint64_t v15 = *(void *)(v12 + 8);
    if ((v13 & 0x80u) == 0) {
      unint64_t v16 = *(unsigned __int8 *)(v12 + 23);
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16 >= 0x80)
    {
      int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16);
      int v13 = *(unsigned __int8 *)(v12 + 23);
      uint64_t v15 = *(void *)(v12 + 8);
      int v2 = *((_DWORD *)this + 29);
      char v14 = *(unsigned char *)(v12 + 23);
    }
    else
    {
      int v17 = 1;
    }
    if (v14 < 0) {
      int v13 = v15;
    }
    uint64_t v3 = (v3 + v17 + v13 + 1);
    if ((v2 & 8) == 0)
    {
LABEL_23:
      if ((v2 & 0x10) == 0) {
        goto LABEL_24;
      }
      goto LABEL_46;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_23;
  }
  uint64_t v18 = *((void *)this + 3);
  int v19 = *(unsigned __int8 *)(v18 + 23);
  char v20 = v19;
  uint64_t v21 = *(void *)(v18 + 8);
  if ((v19 & 0x80u) == 0) {
    unint64_t v22 = *(unsigned __int8 *)(v18 + 23);
  }
  else {
    unint64_t v22 = v21;
  }
  if (v22 >= 0x80)
  {
    int v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v22);
    int v19 = *(unsigned __int8 *)(v18 + 23);
    uint64_t v21 = *(void *)(v18 + 8);
    int v2 = *((_DWORD *)this + 29);
    char v20 = *(unsigned char *)(v18 + 23);
  }
  else
  {
    int v23 = 1;
  }
  if (v20 < 0) {
    int v19 = v21;
  }
  uint64_t v3 = (v3 + v23 + v19 + 1);
  if ((v2 & 0x10) == 0)
  {
LABEL_24:
    if ((v2 & 0x20) == 0) {
      goto LABEL_25;
    }
    goto LABEL_55;
  }
LABEL_46:
  uint64_t v24 = *((void *)this + 4);
  int v25 = *(unsigned __int8 *)(v24 + 23);
  char v26 = v25;
  uint64_t v27 = *(void *)(v24 + 8);
  if ((v25 & 0x80u) == 0) {
    unint64_t v28 = *(unsigned __int8 *)(v24 + 23);
  }
  else {
    unint64_t v28 = v27;
  }
  if (v28 >= 0x80)
  {
    int v29 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v28);
    int v25 = *(unsigned __int8 *)(v24 + 23);
    uint64_t v27 = *(void *)(v24 + 8);
    int v2 = *((_DWORD *)this + 29);
    char v26 = *(unsigned char *)(v24 + 23);
  }
  else
  {
    int v29 = 1;
  }
  if (v26 < 0) {
    int v25 = v27;
  }
  uint64_t v3 = (v3 + v29 + v25 + 1);
  if ((v2 & 0x20) == 0)
  {
LABEL_25:
    if ((v2 & 0x40) == 0) {
      goto LABEL_26;
    }
    goto LABEL_64;
  }
LABEL_55:
  uint64_t v30 = *((void *)this + 5);
  int v31 = *(unsigned __int8 *)(v30 + 23);
  char v32 = v31;
  uint64_t v33 = *(void *)(v30 + 8);
  if ((v31 & 0x80u) == 0) {
    unint64_t v34 = *(unsigned __int8 *)(v30 + 23);
  }
  else {
    unint64_t v34 = v33;
  }
  if (v34 >= 0x80)
  {
    int v35 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v34);
    int v31 = *(unsigned __int8 *)(v30 + 23);
    uint64_t v33 = *(void *)(v30 + 8);
    int v2 = *((_DWORD *)this + 29);
    char v32 = *(unsigned char *)(v30 + 23);
  }
  else
  {
    int v35 = 1;
  }
  if (v32 < 0) {
    int v31 = v33;
  }
  uint64_t v3 = (v3 + v35 + v31 + 1);
  if ((v2 & 0x40) == 0)
  {
LABEL_26:
    if ((v2 & 0x80) == 0) {
      goto LABEL_82;
    }
    goto LABEL_73;
  }
LABEL_64:
  uint64_t v36 = *((void *)this + 6);
  int v37 = *(unsigned __int8 *)(v36 + 23);
  char v38 = v37;
  uint64_t v39 = *(void *)(v36 + 8);
  if ((v37 & 0x80u) == 0) {
    unint64_t v40 = *(unsigned __int8 *)(v36 + 23);
  }
  else {
    unint64_t v40 = v39;
  }
  if (v40 >= 0x80)
  {
    int v41 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v40);
    int v37 = *(unsigned __int8 *)(v36 + 23);
    uint64_t v39 = *(void *)(v36 + 8);
    int v2 = *((_DWORD *)this + 29);
    char v38 = *(unsigned char *)(v36 + 23);
  }
  else
  {
    int v41 = 1;
  }
  if (v38 < 0) {
    int v37 = v39;
  }
  uint64_t v3 = (v3 + v41 + v37 + 1);
  if ((v2 & 0x80) != 0)
  {
LABEL_73:
    uint64_t v42 = *((void *)this + 7);
    int v43 = *(unsigned __int8 *)(v42 + 23);
    char v44 = v43;
    uint64_t v45 = *(void *)(v42 + 8);
    if ((v43 & 0x80u) == 0) {
      unint64_t v46 = *(unsigned __int8 *)(v42 + 23);
    }
    else {
      unint64_t v46 = v45;
    }
    if (v46 >= 0x80)
    {
      int v47 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v46);
      int v43 = *(unsigned __int8 *)(v42 + 23);
      uint64_t v45 = *(void *)(v42 + 8);
      int v2 = *((_DWORD *)this + 29);
      char v44 = *(unsigned char *)(v42 + 23);
    }
    else
    {
      int v47 = 1;
    }
    if (v44 < 0) {
      int v43 = v45;
    }
    uint64_t v3 = (v3 + v47 + v43 + 1);
  }
LABEL_82:
  if ((v2 & 0xFF00) == 0) {
    goto LABEL_139;
  }
  if ((v2 & 0x100) != 0)
  {
    uint64_t v48 = *((void *)this + 9);
    int v49 = *(unsigned __int8 *)(v48 + 23);
    char v50 = v49;
    uint64_t v51 = *(void *)(v48 + 8);
    if ((v49 & 0x80u) == 0) {
      unint64_t v52 = *(unsigned __int8 *)(v48 + 23);
    }
    else {
      unint64_t v52 = v51;
    }
    if (v52 >= 0x80)
    {
      int v53 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v52);
      int v49 = *(unsigned __int8 *)(v48 + 23);
      uint64_t v51 = *(void *)(v48 + 8);
      int v2 = *((_DWORD *)this + 29);
      char v50 = *(unsigned char *)(v48 + 23);
    }
    else
    {
      int v53 = 1;
    }
    if (v50 < 0) {
      int v49 = v51;
    }
    LODWORD(v3) = v3 + v53 + v49 + 1;
  }
  if ((v2 & 0x200) != 0)
  {
    uint64_t v54 = *((void *)this + 10);
    int v55 = *(unsigned __int8 *)(v54 + 23);
    char v56 = v55;
    uint64_t v57 = *(void *)(v54 + 8);
    if ((v55 & 0x80u) == 0) {
      unint64_t v58 = *(unsigned __int8 *)(v54 + 23);
    }
    else {
      unint64_t v58 = v57;
    }
    if (v58 >= 0x80)
    {
      int v59 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v58);
      int v55 = *(unsigned __int8 *)(v54 + 23);
      uint64_t v57 = *(void *)(v54 + 8);
      int v2 = *((_DWORD *)this + 29);
      char v56 = *(unsigned char *)(v54 + 23);
    }
    else
    {
      int v59 = 1;
    }
    if (v56 < 0) {
      int v55 = v57;
    }
    LODWORD(v3) = v3 + v59 + v55 + 1;
  }
  unsigned int v60 = v3 + 2;
  if ((v2 & 0x400) == 0) {
    unsigned int v60 = v3;
  }
  if ((v2 & 0x800) != 0) {
    uint64_t v3 = v60 + 2;
  }
  else {
    uint64_t v3 = v60;
  }
  if ((v2 & 0x1000) != 0)
  {
    uint64_t v61 = *((void *)this + 11);
    int v62 = *(unsigned __int8 *)(v61 + 23);
    char v63 = v62;
    uint64_t v64 = *(void *)(v61 + 8);
    if ((v62 & 0x80u) == 0) {
      unint64_t v65 = *(unsigned __int8 *)(v61 + 23);
    }
    else {
      unint64_t v65 = v64;
    }
    if (v65 >= 0x80)
    {
      int v66 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v65);
      int v62 = *(unsigned __int8 *)(v61 + 23);
      uint64_t v64 = *(void *)(v61 + 8);
      int v2 = *((_DWORD *)this + 29);
      char v63 = *(unsigned char *)(v61 + 23);
    }
    else
    {
      int v66 = 1;
    }
    if (v63 < 0) {
      int v62 = v64;
    }
    uint64_t v3 = (v3 + v66 + v62 + 1);
    if ((v2 & 0x2000) == 0)
    {
LABEL_110:
      if ((v2 & 0x4000) == 0) {
        goto LABEL_139;
      }
      goto LABEL_130;
    }
  }
  else if ((v2 & 0x2000) == 0)
  {
    goto LABEL_110;
  }
  uint64_t v67 = *((void *)this + 12);
  int v68 = *(unsigned __int8 *)(v67 + 23);
  char v69 = v68;
  uint64_t v70 = *(void *)(v67 + 8);
  if ((v68 & 0x80u) == 0) {
    unint64_t v71 = *(unsigned __int8 *)(v67 + 23);
  }
  else {
    unint64_t v71 = v70;
  }
  if (v71 >= 0x80)
  {
    int v72 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v71);
    int v68 = *(unsigned __int8 *)(v67 + 23);
    uint64_t v70 = *(void *)(v67 + 8);
    int v2 = *((_DWORD *)this + 29);
    char v69 = *(unsigned char *)(v67 + 23);
  }
  else
  {
    int v72 = 1;
  }
  if (v69 < 0) {
    int v68 = v70;
  }
  uint64_t v3 = (v3 + v72 + v68 + 1);
  if ((v2 & 0x4000) != 0)
  {
LABEL_130:
    uint64_t v73 = *((void *)this + 13);
    int v74 = *(unsigned __int8 *)(v73 + 23);
    char v75 = v74;
    uint64_t v76 = *(void *)(v73 + 8);
    if ((v74 & 0x80u) == 0) {
      unint64_t v77 = *(unsigned __int8 *)(v73 + 23);
    }
    else {
      unint64_t v77 = v76;
    }
    if (v77 >= 0x80)
    {
      int v78 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v77);
      int v74 = *(unsigned __int8 *)(v73 + 23);
      uint64_t v76 = *(void *)(v73 + 8);
      char v75 = *(unsigned char *)(v73 + 23);
    }
    else
    {
      int v78 = 1;
    }
    if (v75 < 0) {
      int v74 = v76;
    }
    uint64_t v3 = (v3 + v78 + v74 + 1);
  }
LABEL_139:
  *((_DWORD *)this + 28) = v3;
  return v3;
}

void CLMicroLocationProto::HomeKitAccessory::CheckTypeAndMergeFrom(CLMicroLocationProto::HomeKitAccessory *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::HomeKitAccessory::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::HomeKitAccessory::CopyFrom(CLMicroLocationProto::HomeKitAccessory *this, const CLMicroLocationProto::HomeKitAccessory *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::HomeKitAccessory *))(*(void *)this + 32))(this);
    CLMicroLocationProto::HomeKitAccessory::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::HomeKitAccessory::IsInitialized(CLMicroLocationProto::HomeKitAccessory *this)
{
  return 1;
}

void *CLMicroLocationProto::HomeKitAccessory::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.HomeKitAccessory");
}

void CLMicroLocationProto::HomeKitScene::MergeFrom(CLMicroLocationProto::HomeKitScene *this, const CLMicroLocationProto::HomeKitScene *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v24);
  }
  int v4 = *((_DWORD *)a2 + 21);
  if (!(_BYTE)v4) {
    goto LABEL_38;
  }
  if (v4)
  {
    unsigned int v5 = *((_DWORD *)a2 + 12);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
      CLMicroLocationProto::HomeKitScene::MergeFrom();
    }
    *((_DWORD *)this + 21) |= 1u;
    *((_DWORD *)this + 12) = v5;
    int v4 = *((_DWORD *)a2 + 21);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v6 = (const std::string *)*((void *)a2 + 1);
    *((_DWORD *)this + 21) |= 2u;
    int v7 = (std::string *)*((void *)this + 1);
    if (v7 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v7, v6);
    int v4 = *((_DWORD *)a2 + 21);
    if ((v4 & 4) == 0)
    {
LABEL_11:
      if ((v4 & 8) == 0) {
        goto LABEL_12;
      }
      goto LABEL_23;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_11;
  }
  char v8 = (const std::string *)*((void *)a2 + 2);
  *((_DWORD *)this + 21) |= 4u;
  uint64_t v9 = (std::string *)*((void *)this + 2);
  if (v9 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v9, v8);
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 8) == 0)
  {
LABEL_12:
    if ((v4 & 0x10) == 0) {
      goto LABEL_13;
    }
    goto LABEL_26;
  }
LABEL_23:
  unint64_t v10 = (const std::string *)*((void *)a2 + 3);
  *((_DWORD *)this + 21) |= 8u;
  int v11 = (std::string *)*((void *)this + 3);
  if (v11 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v11, v10);
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 0x10) == 0)
  {
LABEL_13:
    if ((v4 & 0x20) == 0) {
      goto LABEL_14;
    }
LABEL_29:
    char v14 = (const std::string *)*((void *)a2 + 5);
    *((_DWORD *)this + 21) |= 0x20u;
    uint64_t v15 = (std::string *)*((void *)this + 5);
    if (v15 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v15, v14);
    int v4 = *((_DWORD *)a2 + 21);
    if ((v4 & 0x40) == 0)
    {
LABEL_15:
      if ((v4 & 0x80) == 0) {
        goto LABEL_38;
      }
      goto LABEL_35;
    }
    goto LABEL_32;
  }
LABEL_26:
  uint64_t v12 = (const std::string *)*((void *)a2 + 4);
  *((_DWORD *)this + 21) |= 0x10u;
  int v13 = (std::string *)*((void *)this + 4);
  if (v13 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v13, v12);
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 0x20) != 0) {
    goto LABEL_29;
  }
LABEL_14:
  if ((v4 & 0x40) == 0) {
    goto LABEL_15;
  }
LABEL_32:
  unint64_t v16 = (const std::string *)*((void *)a2 + 7);
  *((_DWORD *)this + 21) |= 0x40u;
  int v17 = (std::string *)*((void *)this + 7);
  if (v17 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v17, v16);
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 0x80) != 0)
  {
LABEL_35:
    uint64_t v18 = (const std::string *)*((void *)a2 + 8);
    *((_DWORD *)this + 21) |= 0x80u;
    int v19 = (std::string *)*((void *)this + 8);
    if (v19 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v19, v18);
    int v4 = *((_DWORD *)a2 + 21);
  }
LABEL_38:
  if ((v4 & 0xFF00) == 0) {
    return;
  }
  if ((v4 & 0x100) == 0)
  {
    if ((v4 & 0x200) == 0) {
      goto LABEL_41;
    }
LABEL_44:
    char v21 = *((unsigned char *)a2 + 53);
    *((_DWORD *)this + 21) |= 0x200u;
    *((unsigned char *)this + 53) = v21;
    if ((*((_DWORD *)a2 + 21) & 0x400) == 0) {
      return;
    }
    goto LABEL_45;
  }
  char v20 = *((unsigned char *)a2 + 52);
  *((_DWORD *)this + 21) |= 0x100u;
  *((unsigned char *)this + 52) = v20;
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 0x200) != 0) {
    goto LABEL_44;
  }
LABEL_41:
  if ((v4 & 0x400) == 0) {
    return;
  }
LABEL_45:
  unint64_t v22 = (const std::string *)*((void *)a2 + 9);
  *((_DWORD *)this + 21) |= 0x400u;
  int v23 = (std::string *)*((void *)this + 9);
  if (v23 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v23, v22);
}

void sub_25642219C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::HomeKitScene::~HomeKitScene(CLMicroLocationProto::HomeKitScene *this)
{
  *(void *)this = &unk_2704DEB78;
  CLMicroLocationProto::HomeKitScene::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::HomeKitScene::~HomeKitScene(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::HomeKitScene::SharedDtor(CLMicroLocationProto::HomeKitScene *this)
{
  char v1 = this;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::HomeKitScene *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 2);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::HomeKitScene *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  uint64_t v7 = *((void *)v1 + 3);
  if (v7 != v3 && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    this = (CLMicroLocationProto::HomeKitScene *)MEMORY[0x25A2A6340](v7, 0x1012C40EC159624);
  }
  uint64_t v9 = *((void *)v1 + 4);
  if (v9 != v3 && v9 != 0)
  {
    if (*(char *)(v9 + 23) < 0) {
      operator delete(*(void **)v9);
    }
    this = (CLMicroLocationProto::HomeKitScene *)MEMORY[0x25A2A6340](v9, 0x1012C40EC159624);
  }
  uint64_t v11 = *((void *)v1 + 5);
  if (v11 != v3 && v11)
  {
    if (*(char *)(v11 + 23) < 0) {
      operator delete(*(void **)v11);
    }
    this = (CLMicroLocationProto::HomeKitScene *)MEMORY[0x25A2A6340](v11, 0x1012C40EC159624);
  }
  uint64_t v12 = *((void *)v1 + 7);
  if (v12 != v3 && v12)
  {
    if (*(char *)(v12 + 23) < 0) {
      operator delete(*(void **)v12);
    }
    this = (CLMicroLocationProto::HomeKitScene *)MEMORY[0x25A2A6340](v12, 0x1012C40EC159624);
  }
  uint64_t v13 = *((void *)v1 + 8);
  if (v13 != v3 && v13)
  {
    if (*(char *)(v13 + 23) < 0) {
      operator delete(*(void **)v13);
    }
    this = (CLMicroLocationProto::HomeKitScene *)MEMORY[0x25A2A6340](v13, 0x1012C40EC159624);
  }
  uint64_t v14 = *((void *)v1 + 9);
  if (v14 != v3 && v14)
  {
    if (*(char *)(v14 + 23) < 0) {
      operator delete(*(void **)v14);
    }
    this = (CLMicroLocationProto::HomeKitScene *)MEMORY[0x25A2A6340](v14, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::HomeKitScene::New(CLMicroLocationProto::HomeKitScene *this)
{
}

uint64_t CLMicroLocationProto::HomeKitScene::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 84);
  if (v1)
  {
    *(_DWORD *)(this + 48) = 10;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 8) != 0)
    {
      uint64_t v5 = *(void *)(this + 24);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 0x10) != 0)
    {
      uint64_t v6 = *(void *)(this + 32);
      if (v6 != v2)
      {
        if (*(char *)(v6 + 23) < 0)
        {
          **(unsigned char **)uint64_t v6 = 0;
          *(void *)(v6 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(unsigned char *)(v6 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 0x20) != 0)
    {
      uint64_t v7 = *(void *)(this + 40);
      if (v7 != v2)
      {
        if (*(char *)(v7 + 23) < 0)
        {
          **(unsigned char **)uint64_t v7 = 0;
          *(void *)(v7 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v7 = 0;
          *(unsigned char *)(v7 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 0x40) != 0)
    {
      uint64_t v8 = *(void *)(this + 56);
      if (v8 != v2)
      {
        if (*(char *)(v8 + 23) < 0)
        {
          **(unsigned char **)uint64_t v8 = 0;
          *(void *)(v8 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v8 = 0;
          *(unsigned char *)(v8 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 0x80) != 0)
    {
      uint64_t v9 = *(void *)(this + 64);
      if (v9 != v2)
      {
        if (*(char *)(v9 + 23) < 0)
        {
          **(unsigned char **)uint64_t v9 = 0;
          *(void *)(v9 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v9 = 0;
          *(unsigned char *)(v9 + 23) = 0;
        }
      }
    }
  }
  int v10 = *(_DWORD *)(this + 84);
  if ((v10 & 0xFF00) != 0)
  {
    *(_WORD *)(this + 52) = 0;
    if ((v10 & 0x400) != 0)
    {
      uint64_t v11 = *(void *)(this + 72);
      if (v11 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v11 + 23) < 0)
        {
          **(unsigned char **)uint64_t v11 = 0;
          *(void *)(v11 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v11 = 0;
          *(unsigned char *)(v11 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 84) = 0;
  return this;
}

uint64_t CLMicroLocationProto::HomeKitScene::MergePartialFromCodedStream(CLMicroLocationProto::HomeKitScene *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_33;
        }
        unsigned int v29 = 0;
        uint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 < *((void *)a2 + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
LABEL_38:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v14 = ((1 << v9) & 0x76B6) == 0) : (BOOL v14 = 1), !v14))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::HomeKitScene::MergeFrom();
            }
            *((_DWORD *)this + 21) |= 1u;
            *((_DWORD *)this + 12) = v9;
          }
          unint64_t v16 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v16 < *((void *)a2 + 2) && *v16 == 18)
          {
            *((void *)a2 + 1) = v16 + 1;
            goto LABEL_52;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v29);
        if (result)
        {
          unsigned int v9 = v29;
          goto LABEL_38;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_33;
        }
LABEL_52:
        *((_DWORD *)this + 21) |= 2u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v17 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v17 >= *((void *)a2 + 2) || *v17 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v17 + 1;
LABEL_58:
        *((_DWORD *)this + 21) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v18 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v18 >= *((void *)a2 + 2) || *v18 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v18 + 1;
LABEL_64:
        *((_DWORD *)this + 21) |= 8u;
        if (*((void *)this + 3) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v19 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v19 >= *((void *)a2 + 2) || *v19 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v19 + 1;
LABEL_70:
        *((_DWORD *)this + 21) |= 0x10u;
        if (*((void *)this + 4) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        char v20 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v20 >= *((void *)a2 + 2) || *v20 != 50) {
          continue;
        }
        *((void *)a2 + 1) = v20 + 1;
LABEL_76:
        *((_DWORD *)this + 21) |= 0x20u;
        if (*((void *)this + 5) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        char v21 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v21 >= *((void *)a2 + 2) || *v21 != 58) {
          continue;
        }
        *((void *)a2 + 1) = v21 + 1;
LABEL_82:
        *((_DWORD *)this + 21) |= 0x40u;
        if (*((void *)this + 7) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unint64_t v22 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v22 >= *((void *)a2 + 2) || *v22 != 66) {
          continue;
        }
        *((void *)a2 + 1) = v22 + 1;
LABEL_88:
        *((_DWORD *)this + 21) |= 0x80u;
        if (*((void *)this + 8) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v23 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((unint64_t)v23 >= v10 || *v23 != 72) {
          continue;
        }
        uint64_t v12 = v23 + 1;
        *((void *)a2 + 1) = v12;
LABEL_94:
        unsigned int v31 = 0;
        if ((unint64_t)v12 >= v10 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v31);
          if (!result) {
            return result;
          }
          unsigned int v24 = v31;
          int v25 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v24 = *v12;
          int v25 = v12 + 1;
          *((void *)a2 + 1) = v25;
        }
        *((unsigned char *)this + 52) = v24 != 0;
        *((_DWORD *)this + 21) |= 0x100u;
        if ((unint64_t)v25 >= v10 || *v25 != 80) {
          continue;
        }
        uint64_t v11 = v25 + 1;
        *((void *)a2 + 1) = v11;
LABEL_102:
        unsigned int v30 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v30);
          if (!result) {
            return result;
          }
          unsigned int v26 = v30;
          uint64_t v27 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v26 = *v11;
          uint64_t v27 = v11 + 1;
          *((void *)a2 + 1) = v27;
        }
        *((unsigned char *)this + 53) = v26 != 0;
        int v13 = *((_DWORD *)this + 21) | 0x200;
        *((_DWORD *)this + 21) = v13;
        if ((unint64_t)v27 >= v10 || *v27 != 90) {
          continue;
        }
        *((void *)a2 + 1) = v27 + 1;
LABEL_110:
        *((_DWORD *)this + 21) = v13 | 0x400;
        if (*((void *)this + 9) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) != *((void *)a2 + 2)
          || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
        {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_58;
        }
        goto LABEL_33;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_64;
        }
        goto LABEL_33;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_70;
        }
        goto LABEL_33;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_76;
        }
        goto LABEL_33;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_82;
        }
        goto LABEL_33;
      case 8u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_88;
        }
        goto LABEL_33;
      case 9u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_33;
        }
        uint64_t v12 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_94;
      case 0xAu:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_33;
        }
        uint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_102;
      case 0xBu:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_33;
        }
        int v13 = *((_DWORD *)this + 21);
        goto LABEL_110;
      default:
        int v7 = TagFallback & 7;
LABEL_33:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t CLMicroLocationProto::HomeKitScene::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 84);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 48), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 84);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_15;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_16;
  }
LABEL_15:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_17;
  }
LABEL_16:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_18;
  }
LABEL_17:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_19;
  }
LABEL_18:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_20;
  }
LABEL_19:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_21;
  }
LABEL_20:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
LABEL_22:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, *(unsigned __int8 *)(v5 + 53), (uint64_t)a2, a4);
    if ((*(_DWORD *)(v5 + 84) & 0x400) == 0) {
      return this;
    }
    goto LABEL_23;
  }
LABEL_21:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, *(unsigned __int8 *)(v5 + 52), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x200) != 0) {
    goto LABEL_22;
  }
LABEL_11:
  if ((v6 & 0x400) == 0) {
    return this;
  }
LABEL_23:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
}

uint64_t CLMicroLocationProto::HomeKitScene::ByteSize(CLMicroLocationProto::HomeKitScene *this)
{
  int v2 = *((_DWORD *)this + 21);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_82;
  }
  if (v2)
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 12);
    if ((v4 & 0x80000000) != 0)
    {
      int v5 = 10;
    }
    else if (v4 >= 0x80)
    {
      int v5 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4);
      int v2 = *((_DWORD *)this + 21);
    }
    else
    {
      int v5 = 1;
    }
    uint64_t v3 = (v5 + 1);
    if ((v2 & 2) == 0) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((v2 & 2) == 0) {
      goto LABEL_21;
    }
  }
  uint64_t v6 = *((void *)this + 1);
  int v7 = *(unsigned __int8 *)(v6 + 23);
  char v8 = v7;
  uint64_t v9 = *(void *)(v6 + 8);
  if ((v7 & 0x80u) == 0) {
    unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10);
    int v7 = *(unsigned __int8 *)(v6 + 23);
    uint64_t v9 = *(void *)(v6 + 8);
    int v2 = *((_DWORD *)this + 21);
    char v8 = *(unsigned char *)(v6 + 23);
  }
  else
  {
    int v11 = 1;
  }
  if (v8 < 0) {
    int v7 = v9;
  }
  uint64_t v3 = (v3 + v11 + v7 + 1);
LABEL_21:
  if ((v2 & 4) != 0)
  {
    uint64_t v12 = *((void *)this + 2);
    int v13 = *(unsigned __int8 *)(v12 + 23);
    char v14 = v13;
    uint64_t v15 = *(void *)(v12 + 8);
    if ((v13 & 0x80u) == 0) {
      unint64_t v16 = *(unsigned __int8 *)(v12 + 23);
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16 >= 0x80)
    {
      int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16);
      int v13 = *(unsigned __int8 *)(v12 + 23);
      uint64_t v15 = *(void *)(v12 + 8);
      int v2 = *((_DWORD *)this + 21);
      char v14 = *(unsigned char *)(v12 + 23);
    }
    else
    {
      int v17 = 1;
    }
    if (v14 < 0) {
      int v13 = v15;
    }
    uint64_t v3 = (v3 + v17 + v13 + 1);
    if ((v2 & 8) == 0)
    {
LABEL_23:
      if ((v2 & 0x10) == 0) {
        goto LABEL_24;
      }
      goto LABEL_46;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_23;
  }
  uint64_t v18 = *((void *)this + 3);
  int v19 = *(unsigned __int8 *)(v18 + 23);
  char v20 = v19;
  uint64_t v21 = *(void *)(v18 + 8);
  if ((v19 & 0x80u) == 0) {
    unint64_t v22 = *(unsigned __int8 *)(v18 + 23);
  }
  else {
    unint64_t v22 = v21;
  }
  if (v22 >= 0x80)
  {
    int v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v22);
    int v19 = *(unsigned __int8 *)(v18 + 23);
    uint64_t v21 = *(void *)(v18 + 8);
    int v2 = *((_DWORD *)this + 21);
    char v20 = *(unsigned char *)(v18 + 23);
  }
  else
  {
    int v23 = 1;
  }
  if (v20 < 0) {
    int v19 = v21;
  }
  uint64_t v3 = (v3 + v23 + v19 + 1);
  if ((v2 & 0x10) == 0)
  {
LABEL_24:
    if ((v2 & 0x20) == 0) {
      goto LABEL_25;
    }
    goto LABEL_55;
  }
LABEL_46:
  uint64_t v24 = *((void *)this + 4);
  int v25 = *(unsigned __int8 *)(v24 + 23);
  char v26 = v25;
  uint64_t v27 = *(void *)(v24 + 8);
  if ((v25 & 0x80u) == 0) {
    unint64_t v28 = *(unsigned __int8 *)(v24 + 23);
  }
  else {
    unint64_t v28 = v27;
  }
  if (v28 >= 0x80)
  {
    int v29 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v28);
    int v25 = *(unsigned __int8 *)(v24 + 23);
    uint64_t v27 = *(void *)(v24 + 8);
    int v2 = *((_DWORD *)this + 21);
    char v26 = *(unsigned char *)(v24 + 23);
  }
  else
  {
    int v29 = 1;
  }
  if (v26 < 0) {
    int v25 = v27;
  }
  uint64_t v3 = (v3 + v29 + v25 + 1);
  if ((v2 & 0x20) == 0)
  {
LABEL_25:
    if ((v2 & 0x40) == 0) {
      goto LABEL_26;
    }
    goto LABEL_64;
  }
LABEL_55:
  uint64_t v30 = *((void *)this + 5);
  int v31 = *(unsigned __int8 *)(v30 + 23);
  char v32 = v31;
  uint64_t v33 = *(void *)(v30 + 8);
  if ((v31 & 0x80u) == 0) {
    unint64_t v34 = *(unsigned __int8 *)(v30 + 23);
  }
  else {
    unint64_t v34 = v33;
  }
  if (v34 >= 0x80)
  {
    int v35 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v34);
    int v31 = *(unsigned __int8 *)(v30 + 23);
    uint64_t v33 = *(void *)(v30 + 8);
    int v2 = *((_DWORD *)this + 21);
    char v32 = *(unsigned char *)(v30 + 23);
  }
  else
  {
    int v35 = 1;
  }
  if (v32 < 0) {
    int v31 = v33;
  }
  uint64_t v3 = (v3 + v35 + v31 + 1);
  if ((v2 & 0x40) == 0)
  {
LABEL_26:
    if ((v2 & 0x80) == 0) {
      goto LABEL_82;
    }
    goto LABEL_73;
  }
LABEL_64:
  uint64_t v36 = *((void *)this + 7);
  int v37 = *(unsigned __int8 *)(v36 + 23);
  char v38 = v37;
  uint64_t v39 = *(void *)(v36 + 8);
  if ((v37 & 0x80u) == 0) {
    unint64_t v40 = *(unsigned __int8 *)(v36 + 23);
  }
  else {
    unint64_t v40 = v39;
  }
  if (v40 >= 0x80)
  {
    int v41 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v40);
    int v37 = *(unsigned __int8 *)(v36 + 23);
    uint64_t v39 = *(void *)(v36 + 8);
    int v2 = *((_DWORD *)this + 21);
    char v38 = *(unsigned char *)(v36 + 23);
  }
  else
  {
    int v41 = 1;
  }
  if (v38 < 0) {
    int v37 = v39;
  }
  uint64_t v3 = (v3 + v41 + v37 + 1);
  if ((v2 & 0x80) != 0)
  {
LABEL_73:
    uint64_t v42 = *((void *)this + 8);
    int v43 = *(unsigned __int8 *)(v42 + 23);
    char v44 = v43;
    uint64_t v45 = *(void *)(v42 + 8);
    if ((v43 & 0x80u) == 0) {
      unint64_t v46 = *(unsigned __int8 *)(v42 + 23);
    }
    else {
      unint64_t v46 = v45;
    }
    if (v46 >= 0x80)
    {
      int v47 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v46);
      int v43 = *(unsigned __int8 *)(v42 + 23);
      uint64_t v45 = *(void *)(v42 + 8);
      int v2 = *((_DWORD *)this + 21);
      char v44 = *(unsigned char *)(v42 + 23);
    }
    else
    {
      int v47 = 1;
    }
    if (v44 < 0) {
      int v43 = v45;
    }
    uint64_t v3 = (v3 + v47 + v43 + 1);
  }
LABEL_82:
  if ((v2 & 0xFF00) != 0)
  {
    unsigned int v48 = v3 + 2;
    if ((v2 & 0x100) == 0) {
      unsigned int v48 = v3;
    }
    if ((v2 & 0x200) != 0) {
      uint64_t v3 = v48 + 2;
    }
    else {
      uint64_t v3 = v48;
    }
    if ((v2 & 0x400) != 0)
    {
      uint64_t v49 = *((void *)this + 9);
      int v50 = *(unsigned __int8 *)(v49 + 23);
      char v51 = v50;
      uint64_t v52 = *(void *)(v49 + 8);
      if ((v50 & 0x80u) == 0) {
        unint64_t v53 = *(unsigned __int8 *)(v49 + 23);
      }
      else {
        unint64_t v53 = v52;
      }
      if (v53 >= 0x80)
      {
        int v54 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v53);
        int v50 = *(unsigned __int8 *)(v49 + 23);
        uint64_t v52 = *(void *)(v49 + 8);
        char v51 = *(unsigned char *)(v49 + 23);
      }
      else
      {
        int v54 = 1;
      }
      if (v51 < 0) {
        int v50 = v52;
      }
      uint64_t v3 = (v3 + v54 + v50 + 1);
    }
  }
  *((_DWORD *)this + 20) = v3;
  return v3;
}

void CLMicroLocationProto::HomeKitScene::CheckTypeAndMergeFrom(CLMicroLocationProto::HomeKitScene *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::HomeKitScene::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::HomeKitScene::CopyFrom(CLMicroLocationProto::HomeKitScene *this, const CLMicroLocationProto::HomeKitScene *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::HomeKitScene *))(*(void *)this + 32))(this);
    CLMicroLocationProto::HomeKitScene::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::HomeKitScene::IsInitialized(CLMicroLocationProto::HomeKitScene *this)
{
  return 1;
}

void *CLMicroLocationProto::HomeKitScene::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.HomeKitScene");
}

void CLMicroLocationProto::NowPlayingOutputDevice::MergeFrom(CLMicroLocationProto::NowPlayingOutputDevice *this, const CLMicroLocationProto::NowPlayingOutputDevice *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 28);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 28))
    {
      int v5 = *((_DWORD *)a2 + 2);
      *((_DWORD *)this + 7) |= 1u;
      *((_DWORD *)this + 2) = v5;
      int v4 = *((_DWORD *)a2 + 7);
      if ((v4 & 2) == 0)
      {
LABEL_6:
        if ((v4 & 4) == 0) {
          return;
        }
        goto LABEL_10;
      }
    }
    else if ((*((unsigned char *)a2 + 28) & 2) == 0)
    {
      goto LABEL_6;
    }
    int v6 = *((_DWORD *)a2 + 3);
    *((_DWORD *)this + 7) |= 2u;
    *((_DWORD *)this + 3) = v6;
    if ((*((_DWORD *)a2 + 7) & 4) == 0) {
      return;
    }
LABEL_10:
    int v7 = (const std::string *)*((void *)a2 + 2);
    *((_DWORD *)this + 7) |= 4u;
    char v8 = (std::string *)*((void *)this + 2);
    if (v8 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v8, v7);
  }
}

void sub_256423438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::NowPlayingOutputDevice::~NowPlayingOutputDevice(CLMicroLocationProto::NowPlayingOutputDevice *this)
{
  *(void *)this = &unk_2704DEBF0;
  CLMicroLocationProto::DeviceId::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::NowPlayingOutputDevice::~NowPlayingOutputDevice(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::NowPlayingOutputDevice::New(CLMicroLocationProto::NowPlayingOutputDevice *this)
{
}

uint64_t CLMicroLocationProto::NowPlayingOutputDevice::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 28);
  if (v1)
  {
    *(void *)(this + 8) = 0;
    if ((v1 & 4) != 0)
    {
      uint64_t v2 = *(void *)(this + 16);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 28) = 0;
  return this;
}

uint64_t CLMicroLocationProto::NowPlayingOutputDevice::MergePartialFromCodedStream(CLMicroLocationProto::NowPlayingOutputDevice *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  int v4 = (unsigned int *)((char *)this + 8);
  int v5 = (unsigned int *)((char *)this + 12);
  uint64_t v6 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v7 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v7 >= *((void *)a2 + 2) || *v7 < 0)
          {
            TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
            *((_DWORD *)a2 + 8) = TagFallback;
            if (!TagFallback) {
              return 1;
            }
          }
          else
          {
            TagFallbacuint64_t k = *v7;
            *((_DWORD *)a2 + 8) = TagFallback;
            *((void *)a2 + 1) = v7 + 1;
            if (!TagFallback) {
              return 1;
            }
          }
          unsigned int v9 = TagFallback >> 3;
          if (TagFallback >> 3 != 1) {
            break;
          }
          int v10 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_19;
          }
          int v13 = (char *)*((void *)a2 + 1);
          unint64_t v12 = *((void *)a2 + 2);
          if ((unint64_t)v13 >= v12 || *v13 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v4);
            if (!result) {
              return result;
            }
            char v14 = (unsigned char *)*((void *)a2 + 1);
            unint64_t v12 = *((void *)a2 + 2);
          }
          else
          {
            *int v4 = *v13;
            char v14 = v13 + 1;
            *((void *)a2 + 1) = v14;
          }
          *((_DWORD *)this + 7) |= 1u;
          if ((unint64_t)v14 < v12 && *v14 == 16)
          {
            uint64_t v15 = v14 + 1;
            *((void *)a2 + 1) = v15;
            goto LABEL_27;
          }
        }
        if (v9 != 2) {
          break;
        }
        int v10 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        uint64_t v15 = (char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
LABEL_27:
        if ((unint64_t)v15 >= v12 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v5);
          if (!result) {
            return result;
          }
          unint64_t v16 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v12 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int *v5 = *v15;
          unint64_t v16 = v15 + 1;
          *((void *)a2 + 1) = v16;
        }
        int v11 = *((_DWORD *)this + 7) | 2;
        *((_DWORD *)this + 7) = v11;
        if ((unint64_t)v16 < v12 && *v16 == 26)
        {
          *((void *)a2 + 1) = v16 + 1;
          goto LABEL_35;
        }
      }
      if (v9 != 3) {
        break;
      }
      int v10 = TagFallback & 7;
      if (v10 != 2) {
        goto LABEL_19;
      }
      int v11 = *((_DWORD *)this + 7);
LABEL_35:
      *((_DWORD *)this + 7) = v11 | 4;
      if (*((void *)this + 2) == v6) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    int v10 = TagFallback & 7;
LABEL_19:
    if (v10 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::NowPlayingOutputDevice::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 28);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(unsigned int *)(v5 + 12), (uint64_t)a2, a4);
    if ((*(_DWORD *)(v5 + 28) & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 28);
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return this;
  }
LABEL_7:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
}

uint64_t CLMicroLocationProto::NowPlayingOutputDevice::ByteSize(CLMicroLocationProto::NowPlayingOutputDevice *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 28);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_24;
  }
  if (*((unsigned char *)this + 28))
  {
    int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 7);
      if ((v2 & 2) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 28) & 2) == 0) {
      goto LABEL_14;
    }
  }
  uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 3);
  if (v5 >= 0x80)
  {
    int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
    int v2 = *((_DWORD *)this + 7);
  }
  else
  {
    int v6 = 2;
  }
  uint64_t v3 = (v6 + v3);
LABEL_14:
  if ((v2 & 4) != 0)
  {
    uint64_t v7 = *((void *)this + 2);
    int v8 = *(unsigned __int8 *)(v7 + 23);
    char v9 = v8;
    uint64_t v10 = *(void *)(v7 + 8);
    if ((v8 & 0x80u) == 0) {
      unint64_t v11 = *(unsigned __int8 *)(v7 + 23);
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11 >= 0x80)
    {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v11);
      int v8 = *(unsigned __int8 *)(v7 + 23);
      uint64_t v10 = *(void *)(v7 + 8);
      char v9 = *(unsigned char *)(v7 + 23);
    }
    else
    {
      int v12 = 1;
    }
    if (v9 < 0) {
      int v8 = v10;
    }
    uint64_t v3 = (v3 + v12 + v8 + 1);
  }
LABEL_24:
  *((_DWORD *)this + 6) = v3;
  return v3;
}

void CLMicroLocationProto::NowPlayingOutputDevice::CheckTypeAndMergeFrom(CLMicroLocationProto::NowPlayingOutputDevice *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::NowPlayingOutputDevice::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::NowPlayingOutputDevice::IsInitialized(CLMicroLocationProto::NowPlayingOutputDevice *this)
{
  return 1;
}

void *CLMicroLocationProto::NowPlayingOutputDevice::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.NowPlayingOutputDevice");
}

void CLMicroLocationProto::NowPlaying::MergeFrom(CLMicroLocationProto::NowPlaying *this, const CLMicroLocationProto::NowPlaying *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v19);
  }
  int v4 = (CLMicroLocationProto *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::NowPlaying *)((char *)this + 32));
  if (*((int *)a2 + 10) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      int v6 = *(const CLMicroLocationProto::NowPlayingOutputDevice **)(*((void *)a2 + 4) + 8 * v5);
      int v7 = *((_DWORD *)this + 11);
      uint64_t v8 = *((int *)this + 10);
      if ((int)v8 >= v7)
      {
        if (v7 == *((_DWORD *)this + 12))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::NowPlaying *)((char *)this + 32));
          int v7 = *((_DWORD *)this + 11);
        }
        *((_DWORD *)this + 11) = v7 + 1;
        operator new();
      }
      uint64_t v9 = *((void *)this + 4);
      *((_DWORD *)this + 10) = v8 + 1;
      CLMicroLocationProto::NowPlayingOutputDevice::MergeFrom(*(CLMicroLocationProto::NowPlayingOutputDevice **)(v9 + 8 * v8), v6);
      ++v5;
    }
    while (v5 < *((int *)a2 + 10));
  }
  LOBYTE(v10) = *((unsigned char *)a2 + 68);
  if (!(_BYTE)v10) {
    return;
  }
  if (*((unsigned char *)a2 + 68))
  {
    unsigned int v11 = *((_DWORD *)a2 + 4);
    if (v11 - 31 >= 0x19 && (v11 > 0xE || ((1 << v11) & 0x76B6) == 0)) {
      CLMicroLocationProto::NowPlaying::MergeFrom();
    }
    *((_DWORD *)this + 17) |= 1u;
    *((_DWORD *)this + 4) = v11;
    int v10 = *((_DWORD *)a2 + 17);
  }
  if ((v10 & 2) == 0)
  {
    if ((v10 & 4) == 0) {
      goto LABEL_19;
    }
LABEL_25:
    int v14 = *((_DWORD *)a2 + 5);
    *((_DWORD *)this + 17) |= 4u;
    *((_DWORD *)this + 5) = v14;
    int v10 = *((_DWORD *)a2 + 17);
    if ((v10 & 8) == 0)
    {
LABEL_20:
      if ((v10 & 0x20) == 0) {
        return;
      }
      goto LABEL_29;
    }
    goto LABEL_26;
  }
  int v12 = (const std::string *)*((void *)a2 + 1);
  *((_DWORD *)this + 17) |= 2u;
  int v13 = (std::string *)*((void *)this + 1);
  if (v13 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  int v4 = (CLMicroLocationProto *)std::string::operator=(v13, v12);
  int v10 = *((_DWORD *)a2 + 17);
  if ((v10 & 4) != 0) {
    goto LABEL_25;
  }
LABEL_19:
  if ((v10 & 8) == 0) {
    goto LABEL_20;
  }
LABEL_26:
  uint64_t v15 = (const std::string *)*((void *)a2 + 3);
  *((_DWORD *)this + 17) |= 8u;
  unint64_t v16 = (std::string *)*((void *)this + 3);
  if (v16 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  int v4 = (CLMicroLocationProto *)std::string::operator=(v16, v15);
  if ((*((_DWORD *)a2 + 17) & 0x20) != 0)
  {
LABEL_29:
    *((_DWORD *)this + 17) |= 0x20u;
    int v17 = (CLMicroLocationProto::BundleIdFeatures *)*((void *)this + 7);
    if (!v17) {
      operator new();
    }
    uint64_t v18 = (const CLMicroLocationProto::BundleIdFeatures *)*((void *)a2 + 7);
    if (!v18)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(v4);
      uint64_t v18 = *(const CLMicroLocationProto::BundleIdFeatures **)(CLMicroLocationProto::NowPlaying::default_instance_ + 56);
    }
    CLMicroLocationProto::BundleIdFeatures::MergeFrom(v17, v18);
  }
}

void sub_256423CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::NowPlaying::~NowPlaying(CLMicroLocationProto::NowPlaying *this)
{
  *(void *)this = &unk_2704DEC68;
  CLMicroLocationProto::NowPlaying::SharedDtor(this);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 4);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::NowPlaying::~NowPlaying(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::NowPlaying::SharedDtor(CLMicroLocationProto::NowPlaying *this)
{
  char v1 = this;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::NowPlaying *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 3);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::NowPlaying *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::NowPlaying *)CLMicroLocationProto::NowPlaying::default_instance_ != v1)
  {
    uint64_t v7 = *((void *)v1 + 7);
    if (v7)
    {
      uint64_t v8 = *(void (**)(void))(*(void *)v7 + 8);
      v8();
    }
  }
}

void CLMicroLocationProto::NowPlaying::New(CLMicroLocationProto::NowPlaying *this)
{
}

uint64_t CLMicroLocationProto::NowPlaying::Clear(CLMicroLocationProto::NowPlaying *this)
{
  char v2 = *((unsigned char *)this + 68);
  if (v2)
  {
    *((_DWORD *)this + 4) = 12;
    uint64_t v3 = MEMORY[0x263F8C740];
    if ((v2 & 2) != 0)
    {
      uint64_t v4 = *((void *)this + 1);
      if (v4 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    *((_DWORD *)this + 5) = 0;
    if ((*((unsigned char *)this + 68) & 8) != 0)
    {
      uint64_t v5 = *((void *)this + 3);
      if (v5 != v3)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    if ((*((unsigned char *)this + 68) & 0x20) != 0)
    {
      uint64_t v6 = *((void *)this + 7);
      if (v6)
      {
        if (*(unsigned char *)(v6 + 16)) {
          *(_WORD *)(v6 + 8) = 0;
        }
        *(_DWORD *)(v6 + 16) = 0;
      }
    }
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 32);
  *((_DWORD *)this + 17) = 0;
  return result;
}

uint64_t CLMicroLocationProto::NowPlaying::MergePartialFromCodedStream(CLMicroLocationProto::NowPlaying *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (unsigned int *)((char *)this + 20);
  uint64_t v5 = (CLMicroLocationProto::NowPlaying *)((char *)this + 32);
  uint64_t v6 = MEMORY[0x263F8C740];
LABEL_2:
  while (2)
  {
    uint64_t v7 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v7 >= *((void *)a2 + 2) || *v7 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v7;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v7 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        unsigned int v39 = 0;
        int v10 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v10 >= *((void *)a2 + 2) || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v39);
          if (!result) {
            return result;
          }
          unsigned int v11 = v39;
        }
        else
        {
          unsigned int v11 = *v10;
          *((void *)a2 + 1) = v10 + 1;
        }
        if (v11 - 31 < 0x19 || (v11 <= 0xE ? (BOOL v16 = ((1 << v11) & 0x76B6) == 0) : (BOOL v16 = 1), !v16))
        {
          if (v11 - 31 >= 0x19 && (v11 > 0xE || ((1 << v11) & 0x76B6) == 0)) {
            CLMicroLocationProto::NowPlaying::MergeFrom();
          }
          *((_DWORD *)this + 17) |= 1u;
          *((_DWORD *)this + 4) = v11;
        }
        uint64_t v18 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v18 < *((void *)a2 + 2) && *v18 == 18)
        {
          *((void *)a2 + 1) = v18 + 1;
          goto LABEL_42;
        }
        continue;
      case 2u:
        int v9 = TagFallback & 7;
        if (v9 != 2) {
          goto LABEL_23;
        }
LABEL_42:
        *((_DWORD *)this + 17) |= 2u;
        if (*((void *)this + 1) == v6) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v19 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        if ((unint64_t)v19 >= v12 || *v19 != 24) {
          continue;
        }
        int v13 = v19 + 1;
        *((void *)a2 + 1) = v13;
LABEL_48:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v4);
          if (!result) {
            return result;
          }
          char v20 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v12 = *((void *)a2 + 2);
        }
        else
        {
          *uint64_t v4 = *v13;
          char v20 = v13 + 1;
          *((void *)a2 + 1) = v20;
        }
        int v14 = *((_DWORD *)this + 17) | 4;
        *((_DWORD *)this + 17) = v14;
        if ((unint64_t)v20 >= v12 || *v20 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v20 + 1;
LABEL_56:
        *((_DWORD *)this + 17) = v14 | 8;
        if (*((void *)this + 3) == v6) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v21 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v21 >= *((void *)a2 + 2) || *v21 != 42) {
          continue;
        }
        do
        {
          *((void *)a2 + 1) = v21 + 1;
LABEL_62:
          int v22 = *((_DWORD *)this + 11);
          uint64_t v23 = *((int *)this + 10);
          if ((int)v23 >= v22)
          {
            if (v22 == *((_DWORD *)this + 12))
            {
              wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5);
              int v22 = *((_DWORD *)this + 11);
            }
            *((_DWORD *)this + 11) = v22 + 1;
            operator new();
          }
          uint64_t v24 = *((void *)this + 4);
          *((_DWORD *)this + 10) = v23 + 1;
          int v25 = *(CLMicroLocationProto::NowPlayingOutputDevice **)(v24 + 8 * v23);
          unsigned int v40 = 0;
          char v26 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v26 >= *((void *)a2 + 2) || *v26 < 0)
          {
            if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v40))return 0; {
          }
            }
          else
          {
            unsigned int v40 = *v26;
            *((void *)a2 + 1) = v26 + 1;
          }
          int v27 = *((_DWORD *)a2 + 14);
          int v28 = *((_DWORD *)a2 + 15);
          *((_DWORD *)a2 + 14) = v27 + 1;
          if (v27 >= v28) {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (!CLMicroLocationProto::NowPlayingOutputDevice::MergePartialFromCodedStream(v25, a2)
            || !*((unsigned char *)a2 + 36))
          {
            return 0;
          }
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
          int v29 = *((_DWORD *)a2 + 14);
          BOOL v30 = __OFSUB__(v29, 1);
          int v31 = v29 - 1;
          if (v31 < 0 == v30) {
            *((_DWORD *)a2 + 14) = v31;
          }
          uint64_t v21 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v21 >= *((void *)a2 + 2)) {
            goto LABEL_2;
          }
          int v32 = *v21;
        }
        while (v32 == 42);
        if (v32 != 50) {
          continue;
        }
        *((void *)a2 + 1) = v21 + 1;
LABEL_80:
        *((_DWORD *)this + 17) |= 0x20u;
        uint64_t v33 = (CLMicroLocationProto::BundleIdFeatures *)*((void *)this + 7);
        if (!v33) {
          operator new();
        }
        unsigned int v41 = 0;
        unint64_t v34 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v34 >= *((void *)a2 + 2) || *v34 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v41))return 0; {
        }
          }
        else
        {
          unsigned int v41 = *v34;
          *((void *)a2 + 1) = v34 + 1;
        }
        int v35 = *((_DWORD *)a2 + 14);
        int v36 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v35 + 1;
        if (v35 < v36)
        {
          wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
          if (CLMicroLocationProto::BundleIdFeatures::MergePartialFromCodedStream(v33, a2))
          {
            if (*((unsigned char *)a2 + 36))
            {
              wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
              int v37 = *((_DWORD *)a2 + 14);
              BOOL v30 = __OFSUB__(v37, 1);
              int v38 = v37 - 1;
              if (v38 < 0 == v30) {
                *((_DWORD *)a2 + 14) = v38;
              }
              if (*((void *)a2 + 1) == *((void *)a2 + 2)
                && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
              {
                *((_DWORD *)a2 + 8) = 0;
                uint64_t result = 1;
                *((unsigned char *)a2 + 36) = 1;
                return result;
              }
              continue;
            }
          }
        }
        return 0;
      case 3u:
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        int v13 = (char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        goto LABEL_48;
      case 4u:
        int v9 = TagFallback & 7;
        if (v9 != 2) {
          goto LABEL_23;
        }
        int v14 = *((_DWORD *)this + 17);
        goto LABEL_56;
      case 5u:
        int v9 = TagFallback & 7;
        if (v9 == 2) {
          goto LABEL_62;
        }
        goto LABEL_23;
      case 6u:
        int v9 = TagFallback & 7;
        if (v9 == 2) {
          goto LABEL_80;
        }
        goto LABEL_23;
      default:
        int v9 = TagFallback & 7;
LABEL_23:
        if (v9 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

unsigned int *CLMicroLocationProto::NowPlaying::SerializeWithCachedSizes(unsigned int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  unsigned int v6 = this[17];
  if (v6)
  {
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[4], (uint64_t)a2, a4);
    unsigned int v6 = v5[17];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_13;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  unsigned int v6 = v5[17];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_13:
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[5], (uint64_t)a2, a4);
  if ((v5[17] & 8) != 0) {
LABEL_5:
  }
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
LABEL_6:
  if ((int)v5[10] >= 1)
  {
    uint64_t v7 = 0;
    do
      this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(void *)(*((void *)v5 + 4) + 8 * v7++), a2, a4);
    while (v7 < (int)v5[10]);
  }
  if ((v5[17] & 0x20) != 0)
  {
    uint64_t v8 = *((void *)v5 + 7);
    if (!v8)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
      uint64_t v8 = *(void *)(CLMicroLocationProto::NowPlaying::default_instance_ + 56);
    }
    return (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v8, a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::NowPlaying::ByteSize(uint64_t this)
{
  uint64_t v1 = this;
  LOBYTE(v2) = *(unsigned char *)(this + 68);
  if (!(_BYTE)v2)
  {
    int v3 = 0;
    goto LABEL_47;
  }
  if (*(unsigned char *)(this + 68))
  {
    this = *(unsigned int *)(this + 16);
    if ((this & 0x80000000) != 0)
    {
      int v3 = 11;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else if (this >= 0x80)
    {
      this = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)this);
      int v3 = this + 1;
      int v2 = *(_DWORD *)(v1 + 68);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else
    {
      int v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    int v3 = 0;
    if ((*(unsigned char *)(this + 68) & 2) == 0) {
      goto LABEL_22;
    }
  }
  uint64_t v4 = *(void *)(v1 + 8);
  int v5 = *(unsigned __int8 *)(v4 + 23);
  char v6 = v5;
  uint64_t v7 = *(void *)(v4 + 8);
  if ((v5 & 0x80u) == 0) {
    unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8 >= 0x80)
  {
    this = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    uint64_t v7 = *(void *)(v4 + 8);
    int v2 = *(_DWORD *)(v1 + 68);
    char v6 = *(unsigned char *)(v4 + 23);
  }
  else
  {
    this = 1;
  }
  if (v6 < 0) {
    int v5 = v7;
  }
  v3 += this + v5 + 1;
LABEL_22:
  if ((v2 & 4) != 0)
  {
    this = *(unsigned int *)(v1 + 20);
    if (this >= 0x80)
    {
      this = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)this);
      int v9 = this + 1;
      int v2 = *(_DWORD *)(v1 + 68);
    }
    else
    {
      int v9 = 2;
    }
    v3 += v9;
    if ((v2 & 8) == 0)
    {
LABEL_24:
      if ((v2 & 0x20) == 0) {
        goto LABEL_47;
      }
      goto LABEL_39;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_24;
  }
  uint64_t v10 = *(void *)(v1 + 24);
  int v11 = *(unsigned __int8 *)(v10 + 23);
  char v12 = v11;
  uint64_t v13 = *(void *)(v10 + 8);
  if ((v11 & 0x80u) == 0) {
    unint64_t v14 = *(unsigned __int8 *)(v10 + 23);
  }
  else {
    unint64_t v14 = v13;
  }
  if (v14 >= 0x80)
  {
    this = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v14);
    int v11 = *(unsigned __int8 *)(v10 + 23);
    uint64_t v13 = *(void *)(v10 + 8);
    int v2 = *(_DWORD *)(v1 + 68);
    char v12 = *(unsigned char *)(v10 + 23);
  }
  else
  {
    this = 1;
  }
  if (v12 < 0) {
    int v11 = v13;
  }
  v3 += this + v11 + 1;
  if ((v2 & 0x20) != 0)
  {
LABEL_39:
    uint64_t v15 = *(void *)(v1 + 56);
    if (!v15)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
      uint64_t v15 = *(void *)(CLMicroLocationProto::NowPlaying::default_instance_ + 56);
    }
    int v16 = 2 * (*(_DWORD *)(v15 + 16) & 1);
    if ((*(_DWORD *)(v15 + 16) & 2) != 0) {
      v16 += 2;
    }
    if (*(_DWORD *)(v15 + 16)) {
      int v17 = v16;
    }
    else {
      int v17 = 0;
    }
    *(_DWORD *)(v15 + 12) = v17;
    v3 += v17 + 2;
  }
LABEL_47:
  int v18 = *(_DWORD *)(v1 + 40);
  uint64_t v19 = (v18 + v3);
  if (v18 >= 1)
  {
    uint64_t v20 = 0;
    do
    {
      uint64_t v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::NowPlayingOutputDevice::ByteSize(*(CLMicroLocationProto::NowPlayingOutputDevice **)(*(void *)(v1 + 32) + 8 * v20));
      int v22 = (int)v21;
      if (v21 >= 0x80) {
        int v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21);
      }
      else {
        int v23 = 1;
      }
      uint64_t v19 = (v22 + v19 + v23);
      ++v20;
    }
    while (v20 < *(int *)(v1 + 40));
  }
  *(_DWORD *)(v1 + 64) = v19;
  return v19;
}

void CLMicroLocationProto::NowPlaying::CheckTypeAndMergeFrom(CLMicroLocationProto::NowPlaying *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::NowPlaying::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::NowPlaying::IsInitialized(CLMicroLocationProto::NowPlaying *this)
{
  return 1;
}

void *CLMicroLocationProto::NowPlaying::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.NowPlaying");
}

void CLMicroLocationProto::LearnModel::MergeFrom(CLMicroLocationProto::LearnModel *this, const CLMicroLocationProto::LearnModel *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::LearnModel::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_256424A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::LearnModel::~LearnModel(CLMicroLocationProto::LearnModel *this)
{
  *(void *)this = &unk_2704DECE0;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::LearnModel::~LearnModel(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::LearnModel::New(CLMicroLocationProto::LearnModel *this)
{
}

uint64_t CLMicroLocationProto::LearnModel::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 31;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::LearnModel::MergePartialFromCodedStream(CLMicroLocationProto::LearnModel *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      unsigned int v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      char v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::LearnModel::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::LearnModel::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::LearnModel::ByteSize(CLMicroLocationProto::LearnModel *this)
{
  if (*((unsigned char *)this + 16))
  {
    int v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::LearnModel::CheckTypeAndMergeFrom(CLMicroLocationProto::LearnModel *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::LearnModel::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::LearnModel::CopyFrom(CLMicroLocationProto::LearnModel *this, const CLMicroLocationProto::LearnModel *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::LearnModel *))(*(void *)this + 32))(this);
    CLMicroLocationProto::LearnModel::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::LearnModel::IsInitialized(CLMicroLocationProto::LearnModel *this)
{
  return 1;
}

void *CLMicroLocationProto::LearnModel::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.LearnModel");
}

void CLMicroLocationProto::LearnCompleted::MergeFrom(CLMicroLocationProto::LearnCompleted *this, const CLMicroLocationProto::LearnCompleted *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::LearnCompleted::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_256424EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::LearnCompleted::~LearnCompleted(CLMicroLocationProto::LearnCompleted *this)
{
  *(void *)this = &unk_2704DED58;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::LearnCompleted::~LearnCompleted(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::LearnCompleted::New(CLMicroLocationProto::LearnCompleted *this)
{
}

uint64_t CLMicroLocationProto::LearnCompleted::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 32;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::LearnCompleted::MergePartialFromCodedStream(CLMicroLocationProto::LearnCompleted *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      unsigned int v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      char v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::LearnCompleted::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::LearnCompleted::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::LearnCompleted::ByteSize(CLMicroLocationProto::LearnCompleted *this)
{
  if (*((unsigned char *)this + 16))
  {
    int v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::LearnCompleted::CheckTypeAndMergeFrom(CLMicroLocationProto::LearnCompleted *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::LearnCompleted::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::LearnCompleted::CopyFrom(CLMicroLocationProto::LearnCompleted *this, const CLMicroLocationProto::LearnCompleted *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::LearnCompleted *))(*(void *)this + 32))(this);
    CLMicroLocationProto::LearnCompleted::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::LearnCompleted::IsInitialized(CLMicroLocationProto::LearnCompleted *this)
{
  return 1;
}

void *CLMicroLocationProto::LearnCompleted::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.LearnCompleted");
}

void CLMicroLocationProto::SensorsScanComplete::MergeFrom(CLMicroLocationProto::SensorsScanComplete *this, const CLMicroLocationProto::SensorsScanComplete *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::SensorsScanComplete::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_2564253A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::SensorsScanComplete::~SensorsScanComplete(CLMicroLocationProto::SensorsScanComplete *this)
{
  *(void *)this = &unk_2704DEDD0;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::SensorsScanComplete::~SensorsScanComplete(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::SensorsScanComplete::New(CLMicroLocationProto::SensorsScanComplete *this)
{
}

uint64_t CLMicroLocationProto::SensorsScanComplete::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 33;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::SensorsScanComplete::MergePartialFromCodedStream(CLMicroLocationProto::SensorsScanComplete *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      unsigned int v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      char v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::SensorsScanComplete::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::SensorsScanComplete::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::SensorsScanComplete::ByteSize(CLMicroLocationProto::SensorsScanComplete *this)
{
  if (*((unsigned char *)this + 16))
  {
    int v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::SensorsScanComplete::CheckTypeAndMergeFrom(CLMicroLocationProto::SensorsScanComplete *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::SensorsScanComplete::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::SensorsScanComplete::CopyFrom(CLMicroLocationProto::SensorsScanComplete *this, const CLMicroLocationProto::SensorsScanComplete *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::SensorsScanComplete *))(*(void *)this + 32))(this);
    CLMicroLocationProto::SensorsScanComplete::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::SensorsScanComplete::IsInitialized(CLMicroLocationProto::SensorsScanComplete *this)
{
  return 1;
}

void *CLMicroLocationProto::SensorsScanComplete::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.SensorsScanComplete");
}

void CLMicroLocationProto::StartSpectating::MergeFrom(CLMicroLocationProto::StartSpectating *this, const CLMicroLocationProto::StartSpectating *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::StartSpectating::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_256425864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::StartSpectating::~StartSpectating(CLMicroLocationProto::StartSpectating *this)
{
  *(void *)this = &unk_2704DEE48;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::StartSpectating::~StartSpectating(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::StartSpectating::New(CLMicroLocationProto::StartSpectating *this)
{
}

uint64_t CLMicroLocationProto::StartSpectating::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 34;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::StartSpectating::MergePartialFromCodedStream(CLMicroLocationProto::StartSpectating *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      unsigned int v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      char v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::StartSpectating::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::StartSpectating::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::StartSpectating::ByteSize(CLMicroLocationProto::StartSpectating *this)
{
  if (*((unsigned char *)this + 16))
  {
    int v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::StartSpectating::CheckTypeAndMergeFrom(CLMicroLocationProto::StartSpectating *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::StartSpectating::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::StartSpectating::CopyFrom(CLMicroLocationProto::StartSpectating *this, const CLMicroLocationProto::StartSpectating *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::StartSpectating *))(*(void *)this + 32))(this);
    CLMicroLocationProto::StartSpectating::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::StartSpectating::IsInitialized(CLMicroLocationProto::StartSpectating *this)
{
  return 1;
}

void *CLMicroLocationProto::StartSpectating::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.StartSpectating");
}

void CLMicroLocationProto::StopSpectating::MergeFrom(CLMicroLocationProto::StopSpectating *this, const CLMicroLocationProto::StopSpectating *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::StopSpectating::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_256425D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::StopSpectating::~StopSpectating(CLMicroLocationProto::StopSpectating *this)
{
  *(void *)this = &unk_2704DEEC0;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::StopSpectating::~StopSpectating(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::StopSpectating::New(CLMicroLocationProto::StopSpectating *this)
{
}

uint64_t CLMicroLocationProto::StopSpectating::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 35;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::StopSpectating::MergePartialFromCodedStream(CLMicroLocationProto::StopSpectating *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      unsigned int v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      char v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::StopSpectating::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::StopSpectating::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::StopSpectating::ByteSize(CLMicroLocationProto::StopSpectating *this)
{
  if (*((unsigned char *)this + 16))
  {
    int v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::StopSpectating::CheckTypeAndMergeFrom(CLMicroLocationProto::StopSpectating *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::StopSpectating::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::StopSpectating::CopyFrom(CLMicroLocationProto::StopSpectating *this, const CLMicroLocationProto::StopSpectating *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::StopSpectating *))(*(void *)this + 32))(this);
    CLMicroLocationProto::StopSpectating::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::StopSpectating::IsInitialized(CLMicroLocationProto::StopSpectating *this)
{
  return 1;
}

void *CLMicroLocationProto::StopSpectating::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.StopSpectating");
}

void CLMicroLocationProto::ServiceCreate::MergeFrom(CLMicroLocationProto::ServiceCreate *this, const CLMicroLocationProto::ServiceCreate *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v9);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 32);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 32))
    {
      unsigned int v5 = *((_DWORD *)a2 + 6);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::ServiceCreate::MergeFrom();
      }
      *((_DWORD *)this + 8) |= 1u;
      *((_DWORD *)this + 6) = v5;
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 2) != 0)
    {
      char v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 8) |= 2u;
      unsigned int v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 4) != 0)
    {
      uint64_t v8 = *((void *)a2 + 2);
      *((_DWORD *)this + 8) |= 4u;
      *((void *)this + 2) = v8;
    }
  }
}

void sub_256426264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ServiceCreate::~ServiceCreate(CLMicroLocationProto::ServiceCreate *this)
{
  *(void *)this = &unk_2704DEF38;
  CLMicroLocationProto::ClusterRecordings::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ServiceCreate::~ServiceCreate(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ServiceCreate::New(CLMicroLocationProto::ServiceCreate *this)
{
}

uint64_t CLMicroLocationProto::ServiceCreate::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 32);
  if (v1)
  {
    *(_DWORD *)(this + 24) = 36;
    if ((v1 & 2) != 0)
    {
      uint64_t v2 = *(void *)(this + 8);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    *(void *)(this + 16) = 0;
  }
  *(_DWORD *)(this + 32) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ServiceCreate::MergePartialFromCodedStream(CLMicroLocationProto::ServiceCreate *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  int v4 = (unint64_t *)((char *)this + 16);
  uint64_t v5 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        char v6 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v6;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v6 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v8 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v9 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v20 = 0;
        char v12 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v12 >= *((void *)a2 + 2) || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v20);
          if (!result) {
            return result;
          }
          unsigned int v13 = v20;
        }
        else
        {
          unsigned int v13 = *v12;
          *((void *)a2 + 1) = v12 + 1;
        }
        if (v13 - 31 < 0x19 || (v13 <= 0xE ? (BOOL v14 = ((1 << v13) & 0x76B6) == 0) : (BOOL v14 = 1), !v14))
        {
          if (v13 - 31 >= 0x19 && (v13 > 0xE || ((1 << v13) & 0x76B6) == 0)) {
            CLMicroLocationProto::ServiceCreate::MergeFrom();
          }
          *((_DWORD *)this + 8) |= 1u;
          *((_DWORD *)this + 6) = v13;
        }
        int v16 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v16 < *((void *)a2 + 2) && *v16 == 18)
        {
          *((void *)a2 + 1) = v16 + 1;
          goto LABEL_38;
        }
      }
      if (v8 != 2) {
        break;
      }
      int v9 = TagFallback & 7;
      if (v9 != 2) {
        goto LABEL_19;
      }
LABEL_38:
      *((_DWORD *)this + 8) |= 2u;
      if (*((void *)this + 1) == v5) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      int v17 = (unsigned char *)*((void *)a2 + 1);
      unint64_t v10 = *((void *)a2 + 2);
      if ((unint64_t)v17 < v10 && *v17 == 24)
      {
        unsigned int v11 = v17 + 1;
        *((void *)a2 + 1) = v11;
LABEL_44:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v4);
          if (!result) {
            return result;
          }
          int v18 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          *int v4 = *v11;
          int v18 = (unsigned __int8 *)(v11 + 1);
          *((void *)a2 + 1) = v18;
        }
        *((_DWORD *)this + 8) |= 4u;
        if (v18 == (unsigned __int8 *)v10 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (v8 == 3)
    {
      int v9 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_44;
      }
    }
    else
    {
      int v9 = TagFallback & 7;
    }
LABEL_19:
    if (v9 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::ServiceCreate::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 32);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    if ((*(_DWORD *)(v5 + 32) & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 24), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 32);
  if ((v6 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v6 & 4) == 0) {
    return this;
  }
LABEL_7:
  uint64_t v7 = *(void *)(v5 + 16);
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v7, (uint64_t)a2, a4);
}

uint64_t CLMicroLocationProto::ServiceCreate::ByteSize(CLMicroLocationProto::ServiceCreate *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 32);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_24;
  }
  if ((*((unsigned char *)this + 32) & 1) == 0)
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 32) & 2) == 0) {
      goto LABEL_22;
    }
LABEL_13:
    uint64_t v5 = *((void *)this + 1);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8);
    if ((v6 & 0x80u) == 0) {
      unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v8 = *(void *)(v5 + 8);
      int v2 = *((_DWORD *)this + 8);
      char v7 = *(unsigned char *)(v5 + 23);
    }
    else
    {
      int v10 = 1;
    }
    if (v7 < 0) {
      int v6 = v8;
    }
    uint64_t v3 = (v3 + v10 + v6 + 1);
    goto LABEL_22;
  }
  int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
  if ((v4 & 0x80000000) != 0)
  {
    uint64_t v3 = 11;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
  else
  {
    if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 8);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
      goto LABEL_13;
    }
    uint64_t v3 = 2;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
LABEL_22:
  if ((v2 & 4) != 0) {
    uint64_t v3 = v3
  }
       + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 2))
       + 1;
LABEL_24:
  *((_DWORD *)this + 7) = v3;
  return v3;
}

void CLMicroLocationProto::ServiceCreate::CheckTypeAndMergeFrom(CLMicroLocationProto::ServiceCreate *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ServiceCreate::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::ServiceCreate::IsInitialized(CLMicroLocationProto::ServiceCreate *this)
{
  return 1;
}

void *CLMicroLocationProto::ServiceCreate::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ServiceCreate");
}

void CLMicroLocationProto::ServiceDelete::MergeFrom(CLMicroLocationProto::ServiceDelete *this, const CLMicroLocationProto::ServiceDelete *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 32);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 32))
    {
      unsigned int v5 = *((_DWORD *)a2 + 6);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::ServiceDelete::MergeFrom();
      }
      *((_DWORD *)this + 8) |= 1u;
      *((_DWORD *)this + 6) = v5;
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 8) |= 2u;
      char v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 4) != 0)
    {
      uint64_t v8 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 8) |= 4u;
      unint64_t v9 = (std::string *)*((void *)this + 2);
      if (v9 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v9, v8);
    }
  }
}

void sub_2564269E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ServiceDelete::~ServiceDelete(CLMicroLocationProto::ServiceDelete *this)
{
  *(void *)this = &unk_2704DEFB0;
  CLMicroLocationProto::ServiceDelete::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ServiceDelete::~ServiceDelete(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ServiceDelete::New(CLMicroLocationProto::ServiceDelete *this)
{
}

uint64_t CLMicroLocationProto::ServiceDelete::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 32);
  if (v1)
  {
    *(_DWORD *)(this + 24) = 37;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 32) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 32) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ServiceDelete::MergePartialFromCodedStream(CLMicroLocationProto::ServiceDelete *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v16 = 0;
        unint64_t v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v16);
          if (!result) {
            return result;
          }
          unsigned int v10 = v16;
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 - 31 < 0x19 || (v10 <= 0xE ? (BOOL v11 = ((1 << v10) & 0x76B6) == 0) : (BOOL v11 = 1), !v11))
        {
          if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0)) {
            CLMicroLocationProto::ServiceDelete::MergeFrom();
          }
          *((_DWORD *)this + 8) |= 1u;
          *((_DWORD *)this + 6) = v10;
        }
        unsigned int v13 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v13 < *((void *)a2 + 2) && *v13 == 18)
        {
          *((void *)a2 + 1) = v13 + 1;
          goto LABEL_38;
        }
      }
      if (v7 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_19;
      }
LABEL_38:
      *((_DWORD *)this + 8) |= 2u;
      if (*((void *)this + 1) == v4) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      BOOL v14 = (unsigned char *)*((void *)a2 + 1);
      if ((unint64_t)v14 < *((void *)a2 + 2) && *v14 == 26)
      {
        *((void *)a2 + 1) = v14 + 1;
LABEL_44:
        *((_DWORD *)this + 8) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (v7 == 3)
    {
      int v8 = TagFallback & 7;
      if (v8 == 2) {
        goto LABEL_44;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_19:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::ServiceDelete::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 32);
  if ((v5 & 1) == 0)
  {
    if ((v5 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    if ((*(_DWORD *)(v4 + 32) & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 24), (uint64_t)a2, a4);
  int v5 = *(_DWORD *)(v4 + 32);
  if ((v5 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v5 & 4) == 0) {
    return this;
  }
LABEL_7:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::ServiceDelete::ByteSize(CLMicroLocationProto::ServiceDelete *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 32);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_32;
  }
  if ((*((unsigned char *)this + 32) & 1) == 0)
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 32) & 2) == 0) {
      goto LABEL_22;
    }
LABEL_13:
    uint64_t v5 = *((void *)this + 1);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8);
    if ((v6 & 0x80u) == 0) {
      unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v8 = *(void *)(v5 + 8);
      int v2 = *((_DWORD *)this + 8);
      char v7 = *(unsigned char *)(v5 + 23);
    }
    else
    {
      int v10 = 1;
    }
    if (v7 < 0) {
      int v6 = v8;
    }
    uint64_t v3 = (v3 + v10 + v6 + 1);
    goto LABEL_22;
  }
  uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
  if ((v4 & 0x80000000) != 0)
  {
    uint64_t v3 = 11;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
  else
  {
    if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 8);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
      goto LABEL_13;
    }
    uint64_t v3 = 2;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
LABEL_22:
  if ((v2 & 4) != 0)
  {
    uint64_t v11 = *((void *)this + 2);
    int v12 = *(unsigned __int8 *)(v11 + 23);
    char v13 = v12;
    uint64_t v14 = *(void *)(v11 + 8);
    if ((v12 & 0x80u) == 0) {
      unint64_t v15 = *(unsigned __int8 *)(v11 + 23);
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15 >= 0x80)
    {
      int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v15);
      int v12 = *(unsigned __int8 *)(v11 + 23);
      uint64_t v14 = *(void *)(v11 + 8);
      char v13 = *(unsigned char *)(v11 + 23);
    }
    else
    {
      int v16 = 1;
    }
    if (v13 < 0) {
      int v12 = v14;
    }
    uint64_t v3 = (v3 + v16 + v12 + 1);
  }
LABEL_32:
  *((_DWORD *)this + 7) = v3;
  return v3;
}

void CLMicroLocationProto::ServiceDelete::CheckTypeAndMergeFrom(CLMicroLocationProto::ServiceDelete *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ServiceDelete::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ServiceDelete::CopyFrom(CLMicroLocationProto::ServiceDelete *this, const CLMicroLocationProto::ServiceDelete *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ServiceDelete *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ServiceDelete::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ServiceDelete::IsInitialized(CLMicroLocationProto::ServiceDelete *this)
{
  return 1;
}

void *CLMicroLocationProto::ServiceDelete::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ServiceDelete");
}

void CLMicroLocationProto::ServiceConnect::MergeFrom(CLMicroLocationProto::ServiceConnect *this, const CLMicroLocationProto::ServiceConnect *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 32);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 32))
    {
      unsigned int v5 = *((_DWORD *)a2 + 6);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::ServiceConnect::MergeFrom();
      }
      *((_DWORD *)this + 8) |= 1u;
      *((_DWORD *)this + 6) = v5;
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 8) |= 2u;
      char v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 4) != 0)
    {
      uint64_t v8 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 8) |= 4u;
      unint64_t v9 = (std::string *)*((void *)this + 2);
      if (v9 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v9, v8);
    }
  }
}

void sub_256427240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ServiceConnect::New(CLMicroLocationProto::ServiceConnect *this)
{
}

uint64_t CLMicroLocationProto::ServiceConnect::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 32);
  if (v1)
  {
    *(_DWORD *)(this + 24) = 38;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 32) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 32) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ServiceConnect::MergePartialFromCodedStream(CLMicroLocationProto::ServiceConnect *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v16 = 0;
        unint64_t v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v16);
          if (!result) {
            return result;
          }
          unsigned int v10 = v16;
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 - 31 < 0x19 || (v10 <= 0xE ? (BOOL v11 = ((1 << v10) & 0x76B6) == 0) : (BOOL v11 = 1), !v11))
        {
          if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0)) {
            CLMicroLocationProto::ServiceConnect::MergeFrom();
          }
          *((_DWORD *)this + 8) |= 1u;
          *((_DWORD *)this + 6) = v10;
        }
        char v13 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v13 < *((void *)a2 + 2) && *v13 == 18)
        {
          *((void *)a2 + 1) = v13 + 1;
          goto LABEL_38;
        }
      }
      if (v7 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_19;
      }
LABEL_38:
      *((_DWORD *)this + 8) |= 2u;
      if (*((void *)this + 1) == v4) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
      if ((unint64_t)v14 < *((void *)a2 + 2) && *v14 == 26)
      {
        *((void *)a2 + 1) = v14 + 1;
LABEL_44:
        *((_DWORD *)this + 8) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (v7 == 3)
    {
      int v8 = TagFallback & 7;
      if (v8 == 2) {
        goto LABEL_44;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_19:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

void CLMicroLocationProto::ServiceConnect::CheckTypeAndMergeFrom(CLMicroLocationProto::ServiceConnect *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ServiceConnect::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ServiceConnect::CopyFrom(CLMicroLocationProto::ServiceConnect *this, const CLMicroLocationProto::ServiceConnect *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ServiceConnect *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ServiceConnect::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ServiceConnect::IsInitialized(CLMicroLocationProto::ServiceConnect *this)
{
  return 1;
}

void *CLMicroLocationProto::ServiceConnect::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ServiceConnect");
}

void CLMicroLocationProto::ServiceDisconnect::MergeFrom(CLMicroLocationProto::ServiceDisconnect *this, const CLMicroLocationProto::ServiceDisconnect *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 32);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 32))
    {
      unsigned int v5 = *((_DWORD *)a2 + 6);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::ServiceDisconnect::MergeFrom();
      }
      *((_DWORD *)this + 8) |= 1u;
      *((_DWORD *)this + 6) = v5;
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 8) |= 2u;
      unsigned int v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 4) != 0)
    {
      int v8 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 8) |= 4u;
      unint64_t v9 = (std::string *)*((void *)this + 2);
      if (v9 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v9, v8);
    }
  }
}

void sub_256427854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ServiceDisconnect::~ServiceDisconnect(CLMicroLocationProto::ServiceDisconnect *this)
{
  *(void *)this = &unk_2704DF0A0;
  CLMicroLocationProto::ServiceDelete::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ServiceDisconnect::~ServiceDisconnect(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ServiceDisconnect::New(CLMicroLocationProto::ServiceDisconnect *this)
{
}

uint64_t CLMicroLocationProto::ServiceDisconnect::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 32);
  if (v1)
  {
    *(_DWORD *)(this + 24) = 39;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 32) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 32) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ServiceDisconnect::MergePartialFromCodedStream(CLMicroLocationProto::ServiceDisconnect *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v16 = 0;
        unint64_t v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v16);
          if (!result) {
            return result;
          }
          unsigned int v10 = v16;
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 - 31 < 0x19 || (v10 <= 0xE ? (BOOL v11 = ((1 << v10) & 0x76B6) == 0) : (BOOL v11 = 1), !v11))
        {
          if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0)) {
            CLMicroLocationProto::ServiceDisconnect::MergeFrom();
          }
          *((_DWORD *)this + 8) |= 1u;
          *((_DWORD *)this + 6) = v10;
        }
        char v13 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v13 < *((void *)a2 + 2) && *v13 == 18)
        {
          *((void *)a2 + 1) = v13 + 1;
          goto LABEL_38;
        }
      }
      if (v7 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_19;
      }
LABEL_38:
      *((_DWORD *)this + 8) |= 2u;
      if (*((void *)this + 1) == v4) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
      if ((unint64_t)v14 < *((void *)a2 + 2) && *v14 == 26)
      {
        *((void *)a2 + 1) = v14 + 1;
LABEL_44:
        *((_DWORD *)this + 8) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (v7 == 3)
    {
      int v8 = TagFallback & 7;
      if (v8 == 2) {
        goto LABEL_44;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_19:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::ServiceDisconnect::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 32);
  if ((v5 & 1) == 0)
  {
    if ((v5 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    if ((*(_DWORD *)(v4 + 32) & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 24), (uint64_t)a2, a4);
  int v5 = *(_DWORD *)(v4 + 32);
  if ((v5 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v5 & 4) == 0) {
    return this;
  }
LABEL_7:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::ServiceDisconnect::ByteSize(CLMicroLocationProto::ServiceDisconnect *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 32);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_32;
  }
  if ((*((unsigned char *)this + 32) & 1) == 0)
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 32) & 2) == 0) {
      goto LABEL_22;
    }
LABEL_13:
    uint64_t v5 = *((void *)this + 1);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8);
    if ((v6 & 0x80u) == 0) {
      unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v8 = *(void *)(v5 + 8);
      int v2 = *((_DWORD *)this + 8);
      char v7 = *(unsigned char *)(v5 + 23);
    }
    else
    {
      int v10 = 1;
    }
    if (v7 < 0) {
      int v6 = v8;
    }
    uint64_t v3 = (v3 + v10 + v6 + 1);
    goto LABEL_22;
  }
  uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
  if ((v4 & 0x80000000) != 0)
  {
    uint64_t v3 = 11;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
  else
  {
    if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 8);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
      goto LABEL_13;
    }
    uint64_t v3 = 2;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
LABEL_22:
  if ((v2 & 4) != 0)
  {
    uint64_t v11 = *((void *)this + 2);
    int v12 = *(unsigned __int8 *)(v11 + 23);
    char v13 = v12;
    uint64_t v14 = *(void *)(v11 + 8);
    if ((v12 & 0x80u) == 0) {
      unint64_t v15 = *(unsigned __int8 *)(v11 + 23);
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15 >= 0x80)
    {
      int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v15);
      int v12 = *(unsigned __int8 *)(v11 + 23);
      uint64_t v14 = *(void *)(v11 + 8);
      char v13 = *(unsigned char *)(v11 + 23);
    }
    else
    {
      int v16 = 1;
    }
    if (v13 < 0) {
      int v12 = v14;
    }
    uint64_t v3 = (v3 + v16 + v12 + 1);
  }
LABEL_32:
  *((_DWORD *)this + 7) = v3;
  return v3;
}

void CLMicroLocationProto::ServiceDisconnect::CheckTypeAndMergeFrom(CLMicroLocationProto::ServiceDisconnect *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ServiceDisconnect::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ServiceDisconnect::CopyFrom(CLMicroLocationProto::ServiceDisconnect *this, const CLMicroLocationProto::ServiceDisconnect *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ServiceDisconnect *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ServiceDisconnect::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ServiceDisconnect::IsInitialized(CLMicroLocationProto::ServiceDisconnect *this)
{
  return 1;
}

void *CLMicroLocationProto::ServiceDisconnect::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ServiceDisconnect");
}

void CLMicroLocationProto::ServiceStartUpdating::MergeFrom(CLMicroLocationProto::ServiceStartUpdating *this, const CLMicroLocationProto::ServiceStartUpdating *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v11);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 36);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 36))
    {
      unsigned int v5 = *((_DWORD *)a2 + 4);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::ServiceStartUpdating::MergeFrom();
      }
      *((_DWORD *)this + 9) |= 1u;
      *((_DWORD *)this + 4) = v5;
      int v4 = *((_DWORD *)a2 + 9);
    }
    if ((v4 & 2) != 0)
    {
      char v7 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 9) |= 2u;
      uint64_t v8 = (std::string *)*((void *)this + 1);
      if (v8 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v8, v7);
      int v4 = *((_DWORD *)a2 + 9);
      if ((v4 & 4) == 0)
      {
LABEL_11:
        if ((v4 & 8) == 0) {
          return;
        }
        goto LABEL_12;
      }
    }
    else if ((v4 & 4) == 0)
    {
      goto LABEL_11;
    }
    unint64_t v9 = (const std::string *)*((void *)a2 + 3);
    *((_DWORD *)this + 9) |= 4u;
    int v10 = (std::string *)*((void *)this + 3);
    if (v10 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v10, v9);
    if ((*((_DWORD *)a2 + 9) & 8) != 0)
    {
LABEL_12:
      char v6 = *((unsigned char *)a2 + 20);
      *((_DWORD *)this + 9) |= 8u;
      *((unsigned char *)this + 20) = v6;
    }
  }
}

void sub_2564280DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ServiceStartUpdating::New(CLMicroLocationProto::ServiceStartUpdating *this)
{
}

uint64_t CLMicroLocationProto::ServiceStartUpdating::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 36);
  if (v1)
  {
    *(_DWORD *)(this + 16) = 40;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 36) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 24);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    *(unsigned char *)(this + 20) = 0;
  }
  *(_DWORD *)(this + 36) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ServiceStartUpdating::MergePartialFromCodedStream(CLMicroLocationProto::ServiceStartUpdating *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    unsigned int v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v20 = 0;
        uint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 < *((void *)a2 + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
LABEL_24:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v12 = ((1 << v9) & 0x76B6) == 0) : (BOOL v12 = 1), !v12))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::ServiceStartUpdating::MergeFrom();
            }
            *((_DWORD *)this + 9) |= 1u;
            *((_DWORD *)this + 4) = v9;
          }
          uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v14 < *((void *)a2 + 2) && *v14 == 18)
          {
            *((void *)a2 + 1) = v14 + 1;
            goto LABEL_38;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v20);
        if (result)
        {
          unsigned int v9 = v20;
          goto LABEL_24;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_19;
        }
LABEL_38:
        *((_DWORD *)this + 9) |= 2u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        unint64_t v15 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v15 >= *((void *)a2 + 2) || *v15 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v15 + 1;
LABEL_44:
        *((_DWORD *)this + 9) |= 4u;
        if (*((void *)this + 3) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v16 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((unint64_t)v16 >= v10 || *v16 != 32) {
          continue;
        }
        uint64_t v11 = v16 + 1;
        *((void *)a2 + 1) = v11;
LABEL_50:
        unsigned int v21 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v21);
          if (!result) {
            return result;
          }
          unsigned int v17 = v21;
          int v18 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v17 = *v11;
          int v18 = (unsigned __int8 *)(v11 + 1);
          *((void *)a2 + 1) = v18;
        }
        *((unsigned char *)this + 20) = v17 != 0;
        *((_DWORD *)this + 9) |= 8u;
        if (v18 != (unsigned __int8 *)v10 || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10)) {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_44;
        }
        goto LABEL_19;
      case 4u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        uint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_50;
      default:
        int v7 = TagFallback & 7;
LABEL_19:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

void CLMicroLocationProto::ServiceStartUpdating::CheckTypeAndMergeFrom(CLMicroLocationProto::ServiceStartUpdating *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ServiceStartUpdating::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ServiceStartUpdating::CopyFrom(CLMicroLocationProto::ServiceStartUpdating *this, const CLMicroLocationProto::ServiceStartUpdating *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ServiceStartUpdating *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ServiceStartUpdating::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ServiceStartUpdating::IsInitialized(CLMicroLocationProto::ServiceStartUpdating *this)
{
  return 1;
}

void *CLMicroLocationProto::ServiceStartUpdating::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ServiceStartUpdating");
}

void CLMicroLocationProto::ServiceStopUpdating::MergeFrom(CLMicroLocationProto::ServiceStopUpdating *this, const CLMicroLocationProto::ServiceStopUpdating *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 32);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 32))
    {
      unsigned int v5 = *((_DWORD *)a2 + 6);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::ServiceStopUpdating::MergeFrom();
      }
      *((_DWORD *)this + 8) |= 1u;
      *((_DWORD *)this + 6) = v5;
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 2) != 0)
    {
      char v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 8) |= 2u;
      int v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 4) != 0)
    {
      uint64_t v8 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 8) |= 4u;
      unsigned int v9 = (std::string *)*((void *)this + 2);
      if (v9 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v9, v8);
    }
  }
}

void sub_25642879C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ServiceStopUpdating::~ServiceStopUpdating(CLMicroLocationProto::ServiceStopUpdating *this)
{
  *(void *)this = &unk_2704DF190;
  CLMicroLocationProto::ServiceDelete::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ServiceStopUpdating::~ServiceStopUpdating(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ServiceStopUpdating::New(CLMicroLocationProto::ServiceStopUpdating *this)
{
}

uint64_t CLMicroLocationProto::ServiceStopUpdating::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 32);
  if (v1)
  {
    *(_DWORD *)(this + 24) = 41;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 32) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 32) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ServiceStopUpdating::MergePartialFromCodedStream(CLMicroLocationProto::ServiceStopUpdating *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v16 = 0;
        unsigned int v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v16);
          if (!result) {
            return result;
          }
          unsigned int v10 = v16;
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 - 31 < 0x19 || (v10 <= 0xE ? (BOOL v11 = ((1 << v10) & 0x76B6) == 0) : (BOOL v11 = 1), !v11))
        {
          if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0)) {
            CLMicroLocationProto::ServiceStopUpdating::MergeFrom();
          }
          *((_DWORD *)this + 8) |= 1u;
          *((_DWORD *)this + 6) = v10;
        }
        char v13 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v13 < *((void *)a2 + 2) && *v13 == 18)
        {
          *((void *)a2 + 1) = v13 + 1;
          goto LABEL_38;
        }
      }
      if (v7 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      if (v8 != 2) {
        goto LABEL_19;
      }
LABEL_38:
      *((_DWORD *)this + 8) |= 2u;
      if (*((void *)this + 1) == v4) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
      if (!result) {
        return result;
      }
      uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
      if ((unint64_t)v14 < *((void *)a2 + 2) && *v14 == 26)
      {
        *((void *)a2 + 1) = v14 + 1;
LABEL_44:
        *((_DWORD *)this + 8) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (v7 == 3)
    {
      int v8 = TagFallback & 7;
      if (v8 == 2) {
        goto LABEL_44;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_19:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::ServiceStopUpdating::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 32);
  if ((v5 & 1) == 0)
  {
    if ((v5 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
    if ((*(_DWORD *)(v4 + 32) & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 24), (uint64_t)a2, a4);
  int v5 = *(_DWORD *)(v4 + 32);
  if ((v5 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v5 & 4) == 0) {
    return this;
  }
LABEL_7:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::ServiceStopUpdating::ByteSize(CLMicroLocationProto::ServiceStopUpdating *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 32);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_32;
  }
  if ((*((unsigned char *)this + 32) & 1) == 0)
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 32) & 2) == 0) {
      goto LABEL_22;
    }
LABEL_13:
    uint64_t v5 = *((void *)this + 1);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8);
    if ((v6 & 0x80u) == 0) {
      unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v8 = *(void *)(v5 + 8);
      int v2 = *((_DWORD *)this + 8);
      char v7 = *(unsigned char *)(v5 + 23);
    }
    else
    {
      int v10 = 1;
    }
    if (v7 < 0) {
      int v6 = v8;
    }
    uint64_t v3 = (v3 + v10 + v6 + 1);
    goto LABEL_22;
  }
  uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
  if ((v4 & 0x80000000) != 0)
  {
    uint64_t v3 = 11;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
  else
  {
    if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 8);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
      goto LABEL_13;
    }
    uint64_t v3 = 2;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
LABEL_22:
  if ((v2 & 4) != 0)
  {
    uint64_t v11 = *((void *)this + 2);
    int v12 = *(unsigned __int8 *)(v11 + 23);
    char v13 = v12;
    uint64_t v14 = *(void *)(v11 + 8);
    if ((v12 & 0x80u) == 0) {
      unint64_t v15 = *(unsigned __int8 *)(v11 + 23);
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15 >= 0x80)
    {
      int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v15);
      int v12 = *(unsigned __int8 *)(v11 + 23);
      uint64_t v14 = *(void *)(v11 + 8);
      char v13 = *(unsigned char *)(v11 + 23);
    }
    else
    {
      int v16 = 1;
    }
    if (v13 < 0) {
      int v12 = v14;
    }
    uint64_t v3 = (v3 + v16 + v12 + 1);
  }
LABEL_32:
  *((_DWORD *)this + 7) = v3;
  return v3;
}

void CLMicroLocationProto::ServiceStopUpdating::CheckTypeAndMergeFrom(CLMicroLocationProto::ServiceStopUpdating *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ServiceStopUpdating::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ServiceStopUpdating::CopyFrom(CLMicroLocationProto::ServiceStopUpdating *this, const CLMicroLocationProto::ServiceStopUpdating *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ServiceStopUpdating *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ServiceStopUpdating::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ServiceStopUpdating::IsInitialized(CLMicroLocationProto::ServiceStopUpdating *this)
{
  return 1;
}

void *CLMicroLocationProto::ServiceStopUpdating::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ServiceStopUpdating");
}

void CLMicroLocationProto::RequestObservation::MergeFrom(CLMicroLocationProto::RequestObservation *this, const CLMicroLocationProto::RequestObservation *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 48);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 48))
  {
    unsigned int v5 = *((_DWORD *)a2 + 10);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
      CLMicroLocationProto::RequestObservation::MergeFrom();
    }
    *((_DWORD *)this + 12) |= 1u;
    *((_DWORD *)this + 10) = v5;
    int v4 = *((_DWORD *)a2 + 12);
  }
  if ((v4 & 2) == 0)
  {
    if ((v4 & 4) == 0) {
      goto LABEL_11;
    }
LABEL_17:
    uint64_t v8 = (const std::string *)*((void *)a2 + 2);
    *((_DWORD *)this + 12) |= 4u;
    unint64_t v9 = (std::string *)*((void *)this + 2);
    if (v9 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v9, v8);
    int v4 = *((_DWORD *)a2 + 12);
    if ((v4 & 8) == 0)
    {
LABEL_12:
      if ((v4 & 0x10) == 0) {
        return;
      }
      goto LABEL_23;
    }
    goto LABEL_20;
  }
  int v6 = (const std::string *)*((void *)a2 + 1);
  *((_DWORD *)this + 12) |= 2u;
  char v7 = (std::string *)*((void *)this + 1);
  if (v7 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v7, v6);
  int v4 = *((_DWORD *)a2 + 12);
  if ((v4 & 4) != 0) {
    goto LABEL_17;
  }
LABEL_11:
  if ((v4 & 8) == 0) {
    goto LABEL_12;
  }
LABEL_20:
  int v10 = (const std::string *)*((void *)a2 + 3);
  *((_DWORD *)this + 12) |= 8u;
  uint64_t v11 = (std::string *)*((void *)this + 3);
  if (v11 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v11, v10);
  if ((*((_DWORD *)a2 + 12) & 0x10) != 0)
  {
LABEL_23:
    int v12 = (const std::string *)*((void *)a2 + 4);
    *((_DWORD *)this + 12) |= 0x10u;
    char v13 = (std::string *)*((void *)this + 4);
    if (v13 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v13, v12);
  }
}

void sub_2564290BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RequestObservation::~RequestObservation(CLMicroLocationProto::RequestObservation *this)
{
  *(void *)this = &unk_2704DF208;
  CLMicroLocationProto::RequestObservation::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::RequestObservation::~RequestObservation(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::RequestObservation::SharedDtor(CLMicroLocationProto::RequestObservation *this)
{
  char v1 = this;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::RequestObservation *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 2);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::RequestObservation *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  uint64_t v7 = *((void *)v1 + 3);
  if (v7 != v3 && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    this = (CLMicroLocationProto::RequestObservation *)MEMORY[0x25A2A6340](v7, 0x1012C40EC159624);
  }
  uint64_t v9 = *((void *)v1 + 4);
  if (v9 != v3 && v9 != 0)
  {
    if (*(char *)(v9 + 23) < 0) {
      operator delete(*(void **)v9);
    }
    this = (CLMicroLocationProto::RequestObservation *)MEMORY[0x25A2A6340](v9, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::RequestObservation::New(CLMicroLocationProto::RequestObservation *this)
{
}

uint64_t CLMicroLocationProto::RequestObservation::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 48);
  if (v1)
  {
    *(_DWORD *)(this + 40) = 42;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 48) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 48) & 8) != 0)
    {
      uint64_t v5 = *(void *)(this + 24);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 48) & 0x10) != 0)
    {
      uint64_t v6 = *(void *)(this + 32);
      if (v6 != v2)
      {
        if (*(char *)(v6 + 23) < 0)
        {
          **(unsigned char **)uint64_t v6 = 0;
          *(void *)(v6 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(unsigned char *)(v6 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 48) = 0;
  return this;
}

uint64_t CLMicroLocationProto::RequestObservation::MergePartialFromCodedStream(CLMicroLocationProto::RequestObservation *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 < *((void *)a2 + 2) && (*v5 & 0x80000000) == 0)
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
LABEL_7:
      switch(TagFallback >> 3)
      {
        case 1u:
          int v7 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_20;
          }
          unsigned int v17 = 0;
          uint64_t v8 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v17);
            if (!result) {
              return result;
            }
            unsigned int v9 = v17;
          }
          else
          {
            unsigned int v9 = *v8;
            *((void *)a2 + 1) = v8 + 1;
          }
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v10 = ((1 << v9) & 0x76B6) == 0) : (BOOL v10 = 1), !v10))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::RequestObservation::MergeFrom();
            }
            *((_DWORD *)this + 12) |= 1u;
            *((_DWORD *)this + 10) = v9;
          }
          int v12 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v12 < *((void *)a2 + 2) && *v12 == 18)
          {
            *((void *)a2 + 1) = v12 + 1;
            goto LABEL_39;
          }
          continue;
        case 2u:
          int v7 = TagFallback & 7;
          if (v7 != 2) {
            goto LABEL_20;
          }
LABEL_39:
          *((_DWORD *)this + 12) |= 2u;
          if (*((void *)this + 1) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
          if (!result) {
            return result;
          }
          char v13 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v13 >= *((void *)a2 + 2) || *v13 != 26) {
            continue;
          }
          *((void *)a2 + 1) = v13 + 1;
LABEL_45:
          *((_DWORD *)this + 12) |= 4u;
          if (*((void *)this + 2) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!result) {
            return result;
          }
          uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 != 34) {
            continue;
          }
          *((void *)a2 + 1) = v14 + 1;
LABEL_51:
          *((_DWORD *)this + 12) |= 8u;
          if (*((void *)this + 3) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!result) {
            return result;
          }
          unint64_t v15 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v15 >= *((void *)a2 + 2) || *v15 != 42) {
            continue;
          }
          *((void *)a2 + 1) = v15 + 1;
LABEL_57:
          *((_DWORD *)this + 12) |= 0x10u;
          if (*((void *)this + 4) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!result) {
            return result;
          }
          if (*((void *)a2 + 1) != *((void *)a2 + 2)
            || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
          {
            continue;
          }
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        case 3u:
          int v7 = TagFallback & 7;
          if (v7 == 2) {
            goto LABEL_45;
          }
          goto LABEL_20;
        case 4u:
          int v7 = TagFallback & 7;
          if (v7 != 2) {
            goto LABEL_20;
          }
          goto LABEL_51;
        case 5u:
          int v7 = TagFallback & 7;
          if (v7 == 2) {
            goto LABEL_57;
          }
          goto LABEL_20;
        default:
          int v7 = TagFallback & 7;
LABEL_20:
          if (v7 == 4) {
            return 1;
          }
          if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
          return 0;
          }
      }
    }
    break;
  }
  TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
  *((_DWORD *)a2 + 8) = TagFallback;
  if (TagFallback) {
    goto LABEL_7;
  }
  return 1;
}

uint64_t CLMicroLocationProto::RequestObservation::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 48);
  if (v5)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 40), (uint64_t)a2, a4);
    int v5 = *(_DWORD *)(v4 + 48);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v5 = *(_DWORD *)(v4 + 48);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    if ((*(_DWORD *)(v4 + 48) & 0x10) == 0) {
      return this;
    }
    goto LABEL_11;
  }
LABEL_9:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  int v5 = *(_DWORD *)(v4 + 48);
  if ((v5 & 8) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v5 & 0x10) == 0) {
    return this;
  }
LABEL_11:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::RequestObservation::ByteSize(CLMicroLocationProto::RequestObservation *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 48);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_53;
  }
  if (*((unsigned char *)this + 48))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 10);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v3 = 11;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 12);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 48) & 2) == 0) {
      goto LABEL_22;
    }
  }
  uint64_t v5 = *((void *)this + 1);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v2 = *((_DWORD *)this + 12);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 1;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v3 = (v3 + v10 + v6 + 1);
LABEL_22:
  if ((v2 & 4) != 0)
  {
    uint64_t v11 = *((void *)this + 2);
    int v12 = *(unsigned __int8 *)(v11 + 23);
    char v13 = v12;
    uint64_t v14 = *(void *)(v11 + 8);
    if ((v12 & 0x80u) == 0) {
      unint64_t v15 = *(unsigned __int8 *)(v11 + 23);
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15 >= 0x80)
    {
      int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v15);
      int v12 = *(unsigned __int8 *)(v11 + 23);
      uint64_t v14 = *(void *)(v11 + 8);
      int v2 = *((_DWORD *)this + 12);
      char v13 = *(unsigned char *)(v11 + 23);
    }
    else
    {
      int v16 = 1;
    }
    if (v13 < 0) {
      int v12 = v14;
    }
    uint64_t v3 = (v3 + v16 + v12 + 1);
    if ((v2 & 8) == 0)
    {
LABEL_24:
      if ((v2 & 0x10) == 0) {
        goto LABEL_53;
      }
      goto LABEL_44;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_24;
  }
  uint64_t v17 = *((void *)this + 3);
  int v18 = *(unsigned __int8 *)(v17 + 23);
  char v19 = v18;
  uint64_t v20 = *(void *)(v17 + 8);
  if ((v18 & 0x80u) == 0) {
    unint64_t v21 = *(unsigned __int8 *)(v17 + 23);
  }
  else {
    unint64_t v21 = v20;
  }
  if (v21 >= 0x80)
  {
    int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v21);
    int v18 = *(unsigned __int8 *)(v17 + 23);
    uint64_t v20 = *(void *)(v17 + 8);
    int v2 = *((_DWORD *)this + 12);
    char v19 = *(unsigned char *)(v17 + 23);
  }
  else
  {
    int v22 = 1;
  }
  if (v19 < 0) {
    int v18 = v20;
  }
  uint64_t v3 = (v3 + v22 + v18 + 1);
  if ((v2 & 0x10) != 0)
  {
LABEL_44:
    uint64_t v23 = *((void *)this + 4);
    int v24 = *(unsigned __int8 *)(v23 + 23);
    char v25 = v24;
    uint64_t v26 = *(void *)(v23 + 8);
    if ((v24 & 0x80u) == 0) {
      unint64_t v27 = *(unsigned __int8 *)(v23 + 23);
    }
    else {
      unint64_t v27 = v26;
    }
    if (v27 >= 0x80)
    {
      int v28 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v27);
      int v24 = *(unsigned __int8 *)(v23 + 23);
      uint64_t v26 = *(void *)(v23 + 8);
      char v25 = *(unsigned char *)(v23 + 23);
    }
    else
    {
      int v28 = 1;
    }
    if (v25 < 0) {
      int v24 = v26;
    }
    uint64_t v3 = (v3 + v28 + v24 + 1);
  }
LABEL_53:
  *((_DWORD *)this + 11) = v3;
  return v3;
}

void CLMicroLocationProto::RequestObservation::CheckTypeAndMergeFrom(CLMicroLocationProto::RequestObservation *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::RequestObservation::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::RequestObservation::CopyFrom(CLMicroLocationProto::RequestObservation *this, const CLMicroLocationProto::RequestObservation *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::RequestObservation *))(*(void *)this + 32))(this);
    CLMicroLocationProto::RequestObservation::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::RequestObservation::IsInitialized(CLMicroLocationProto::RequestObservation *this)
{
  return 1;
}

void *CLMicroLocationProto::RequestObservation::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.RequestObservation");
}

void CLMicroLocationProto::RequestPrediction::MergeFrom(CLMicroLocationProto::RequestPrediction *this, const CLMicroLocationProto::RequestPrediction *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 40);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 40))
    {
      unsigned int v5 = *((_DWORD *)a2 + 8);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::RequestPrediction::MergeFrom();
      }
      *((_DWORD *)this + 10) |= 1u;
      *((_DWORD *)this + 8) = v5;
      int v4 = *((_DWORD *)a2 + 10);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 10) |= 2u;
      char v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 10);
      if ((v4 & 4) == 0)
      {
LABEL_11:
        if ((v4 & 8) == 0) {
          return;
        }
        goto LABEL_19;
      }
    }
    else if ((v4 & 4) == 0)
    {
      goto LABEL_11;
    }
    uint64_t v8 = (const std::string *)*((void *)a2 + 2);
    *((_DWORD *)this + 10) |= 4u;
    unint64_t v9 = (std::string *)*((void *)this + 2);
    if (v9 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v9, v8);
    if ((*((_DWORD *)a2 + 10) & 8) != 0)
    {
LABEL_19:
      int v10 = (const std::string *)*((void *)a2 + 3);
      *((_DWORD *)this + 10) |= 8u;
      uint64_t v11 = (std::string *)*((void *)this + 3);
      if (v11 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v11, v10);
    }
  }
}

void sub_256429D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RequestPrediction::~RequestPrediction(CLMicroLocationProto::RequestPrediction *this)
{
  *(void *)this = &unk_2704DF280;
  CLMicroLocationProto::TruthLabelDonation::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::RequestPrediction::~RequestPrediction(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::RequestPrediction::New(CLMicroLocationProto::RequestPrediction *this)
{
}

uint64_t CLMicroLocationProto::RequestPrediction::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 40);
  if (v1)
  {
    *(_DWORD *)(this + 32) = 43;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 40) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 40) & 8) != 0)
    {
      uint64_t v5 = *(void *)(this + 24);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t CLMicroLocationProto::RequestPrediction::MergePartialFromCodedStream(CLMicroLocationProto::RequestPrediction *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 < *((void *)a2 + 2) && (*v5 & 0x80000000) == 0)
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
LABEL_7:
      switch(TagFallback >> 3)
      {
        case 1u:
          int v7 = TagFallback & 7;
          if ((TagFallback & 7) != 0) {
            goto LABEL_19;
          }
          unsigned int v16 = 0;
          uint64_t v8 = (char *)*((void *)a2 + 1);
          if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
          {
            uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v16);
            if (!result) {
              return result;
            }
            unsigned int v9 = v16;
          }
          else
          {
            unsigned int v9 = *v8;
            *((void *)a2 + 1) = v8 + 1;
          }
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v10 = ((1 << v9) & 0x76B6) == 0) : (BOOL v10 = 1), !v10))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::RequestPrediction::MergeFrom();
            }
            *((_DWORD *)this + 10) |= 1u;
            *((_DWORD *)this + 8) = v9;
          }
          int v12 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v12 < *((void *)a2 + 2) && *v12 == 18)
          {
            *((void *)a2 + 1) = v12 + 1;
            goto LABEL_38;
          }
          continue;
        case 2u:
          int v7 = TagFallback & 7;
          if (v7 != 2) {
            goto LABEL_19;
          }
LABEL_38:
          *((_DWORD *)this + 10) |= 2u;
          if (*((void *)this + 1) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
          if (!result) {
            return result;
          }
          char v13 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v13 >= *((void *)a2 + 2) || *v13 != 26) {
            continue;
          }
          *((void *)a2 + 1) = v13 + 1;
LABEL_44:
          *((_DWORD *)this + 10) |= 4u;
          if (*((void *)this + 2) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!result) {
            return result;
          }
          uint64_t v14 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 != 34) {
            continue;
          }
          *((void *)a2 + 1) = v14 + 1;
LABEL_50:
          *((_DWORD *)this + 10) |= 8u;
          if (*((void *)this + 3) == v4) {
            operator new();
          }
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
          if (!result) {
            return result;
          }
          if (*((void *)a2 + 1) != *((void *)a2 + 2)
            || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
          {
            continue;
          }
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        case 3u:
          int v7 = TagFallback & 7;
          if (v7 == 2) {
            goto LABEL_44;
          }
          goto LABEL_19;
        case 4u:
          int v7 = TagFallback & 7;
          if (v7 == 2) {
            goto LABEL_50;
          }
          goto LABEL_19;
        default:
          int v7 = TagFallback & 7;
LABEL_19:
          if (v7 == 4) {
            return 1;
          }
          if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
          return 0;
          }
      }
    }
    break;
  }
  TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
  *((_DWORD *)a2 + 8) = TagFallback;
  if (TagFallback) {
    goto LABEL_7;
  }
  return 1;
}

uint64_t CLMicroLocationProto::RequestPrediction::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 40);
  if (v5)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 32), (uint64_t)a2, a4);
    int v5 = *(_DWORD *)(v4 + 40);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
      if ((*(_DWORD *)(v4 + 40) & 8) == 0) {
        return this;
      }
      goto LABEL_9;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v5 = *(_DWORD *)(v4 + 40);
  if ((v5 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v5 & 8) == 0) {
    return this;
  }
LABEL_9:
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
}

uint64_t CLMicroLocationProto::RequestPrediction::ByteSize(CLMicroLocationProto::RequestPrediction *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 40);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_43;
  }
  if (*((unsigned char *)this + 40))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v3 = 11;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 10);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 40) & 2) == 0) {
      goto LABEL_22;
    }
  }
  uint64_t v5 = *((void *)this + 1);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v2 = *((_DWORD *)this + 10);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 1;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v3 = (v3 + v10 + v6 + 1);
LABEL_22:
  if ((v2 & 4) == 0)
  {
    if ((v2 & 8) == 0) {
      goto LABEL_43;
    }
    goto LABEL_34;
  }
  uint64_t v11 = *((void *)this + 2);
  int v12 = *(unsigned __int8 *)(v11 + 23);
  char v13 = v12;
  uint64_t v14 = *(void *)(v11 + 8);
  if ((v12 & 0x80u) == 0) {
    unint64_t v15 = *(unsigned __int8 *)(v11 + 23);
  }
  else {
    unint64_t v15 = v14;
  }
  if (v15 >= 0x80)
  {
    int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v15);
    int v12 = *(unsigned __int8 *)(v11 + 23);
    uint64_t v14 = *(void *)(v11 + 8);
    int v2 = *((_DWORD *)this + 10);
    char v13 = *(unsigned char *)(v11 + 23);
  }
  else
  {
    int v16 = 1;
  }
  if (v13 < 0) {
    int v12 = v14;
  }
  uint64_t v3 = (v3 + v16 + v12 + 1);
  if ((v2 & 8) != 0)
  {
LABEL_34:
    uint64_t v17 = *((void *)this + 3);
    int v18 = *(unsigned __int8 *)(v17 + 23);
    char v19 = v18;
    uint64_t v20 = *(void *)(v17 + 8);
    if ((v18 & 0x80u) == 0) {
      unint64_t v21 = *(unsigned __int8 *)(v17 + 23);
    }
    else {
      unint64_t v21 = v20;
    }
    if (v21 >= 0x80)
    {
      int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v21);
      int v18 = *(unsigned __int8 *)(v17 + 23);
      uint64_t v20 = *(void *)(v17 + 8);
      char v19 = *(unsigned char *)(v17 + 23);
    }
    else
    {
      int v22 = 1;
    }
    if (v19 < 0) {
      int v18 = v20;
    }
    uint64_t v3 = (v3 + v22 + v18 + 1);
  }
LABEL_43:
  *((_DWORD *)this + 9) = v3;
  return v3;
}

void CLMicroLocationProto::RequestPrediction::CheckTypeAndMergeFrom(CLMicroLocationProto::RequestPrediction *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::RequestPrediction::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::RequestPrediction::CopyFrom(CLMicroLocationProto::RequestPrediction *this, const CLMicroLocationProto::RequestPrediction *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::RequestPrediction *))(*(void *)this + 32))(this);
    CLMicroLocationProto::RequestPrediction::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::RequestPrediction::IsInitialized(CLMicroLocationProto::RequestPrediction *this)
{
  return 1;
}

void *CLMicroLocationProto::RequestPrediction::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.RequestPrediction");
}

void CLMicroLocationProto::MiloInit::MergeFrom(CLMicroLocationProto::MiloInit *this, const CLMicroLocationProto::MiloInit *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 24))
    {
      unsigned int v5 = *((_DWORD *)a2 + 4);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::MiloInit::MergeFrom();
      }
      *((_DWORD *)this + 6) |= 1u;
      *((_DWORD *)this + 4) = v5;
      int v4 = *((_DWORD *)a2 + 6);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 6) |= 2u;
      char v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
    }
  }
}

void sub_25642A670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::MiloInit::New(CLMicroLocationProto::MiloInit *this)
{
}

uint64_t CLMicroLocationProto::MiloInit::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 24);
  if (v1)
  {
    *(_DWORD *)(this + 16) = 44;
    if ((v1 & 2) != 0)
    {
      uint64_t v2 = *(void *)(this + 8);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::MiloInit::MergePartialFromCodedStream(CLMicroLocationProto::MiloInit *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      unsigned int v5 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v5;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unsigned int v14 = 0;
      uint64_t v8 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v14);
        if (!result) {
          return result;
        }
        unsigned int v9 = v14;
      }
      else
      {
        unsigned int v9 = *v8;
        *((void *)a2 + 1) = v8 + 1;
      }
      if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v10 = ((1 << v9) & 0x76B6) == 0) : (BOOL v10 = 1), !v10))
      {
        if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
          CLMicroLocationProto::MiloInit::MergeFrom();
        }
        *((_DWORD *)this + 6) |= 1u;
        *((_DWORD *)this + 4) = v9;
      }
      int v12 = (unsigned char *)*((void *)a2 + 1);
      if ((unint64_t)v12 < *((void *)a2 + 2) && *v12 == 18)
      {
        *((void *)a2 + 1) = v12 + 1;
LABEL_35:
        *((_DWORD *)this + 6) |= 2u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if (v7 == 2) {
        goto LABEL_35;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_16:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

void CLMicroLocationProto::MiloInit::CheckTypeAndMergeFrom(CLMicroLocationProto::MiloInit *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::MiloInit::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::MiloInit::CopyFrom(CLMicroLocationProto::MiloInit *this, const CLMicroLocationProto::MiloInit *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::MiloInit *))(*(void *)this + 32))(this);
    CLMicroLocationProto::MiloInit::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::MiloInit::IsInitialized(CLMicroLocationProto::MiloInit *this)
{
  return 1;
}

void *CLMicroLocationProto::MiloInit::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.MiloInit");
}

BOOL CLMicroLocationProto::MotionEvent_Status_IsValid(CLMicroLocationProto *this)
{
  return this < 0xB;
}

void CLMicroLocationProto::MotionEvent::MergeFrom(CLMicroLocationProto::MotionEvent *this, const CLMicroLocationProto::MotionEvent *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 44);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 44))
    {
      unsigned int v5 = *((_DWORD *)a2 + 4);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::MotionEvent::MergeFrom();
      }
      *((_DWORD *)this + 11) |= 1u;
      *((_DWORD *)this + 4) = v5;
      int v4 = *((_DWORD *)a2 + 11);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 11) |= 2u;
      int v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 11);
    }
    if ((v4 & 4) != 0)
    {
      unsigned int v8 = *((_DWORD *)a2 + 5);
      if (v8 >= 0xB) {
        CLMicroLocationProto::MotionEvent::MergeFrom();
      }
      *((_DWORD *)this + 11) |= 4u;
      *((_DWORD *)this + 5) = v8;
      int v4 = *((_DWORD *)a2 + 11);
    }
    if ((v4 & 8) != 0)
    {
      unsigned int v9 = (const std::string *)*((void *)a2 + 3);
      *((_DWORD *)this + 11) |= 8u;
      BOOL v10 = (std::string *)*((void *)this + 3);
      if (v10 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v10, v9);
      int v4 = *((_DWORD *)a2 + 11);
    }
    if ((v4 & 0x10) != 0)
    {
      unsigned int v11 = *((_DWORD *)a2 + 8);
      if (v11 >= 3) {
        CLMicroLocationProto::MotionEvent::MergeFrom();
      }
      *((_DWORD *)this + 11) |= 0x10u;
      *((_DWORD *)this + 8) = v11;
      int v4 = *((_DWORD *)a2 + 11);
    }
    if ((v4 & 0x20) != 0)
    {
      int v12 = *((_DWORD *)a2 + 9);
      *((_DWORD *)this + 11) |= 0x20u;
      *((_DWORD *)this + 9) = v12;
    }
  }
}

void sub_25642AC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::MotionEvent::~MotionEvent(CLMicroLocationProto::MotionEvent *this)
{
  *(void *)this = &unk_2704DF370;
  CLMicroLocationProto::ServiceStartUpdating::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::MotionEvent::~MotionEvent(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::MotionEvent::New(CLMicroLocationProto::MotionEvent *this)
{
}

uint64_t CLMicroLocationProto::MotionEvent::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 44);
  if (v1)
  {
    *(_DWORD *)(this + 16) = 45;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(this + 20) = 0;
    if ((*(unsigned char *)(this + 44) & 8) != 0)
    {
      uint64_t v4 = *(void *)(this + 24);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    *(void *)(this + 32) = 0;
  }
  *(_DWORD *)(this + 44) = 0;
  return this;
}

uint64_t CLMicroLocationProto::MotionEvent::MergePartialFromCodedStream(CLMicroLocationProto::MotionEvent *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (unsigned int *)((char *)this + 36);
  uint64_t v5 = MEMORY[0x263F8C740];
  while (2)
  {
    int v6 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v6;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v6 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        unsigned int v30 = 0;
        unsigned int v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 < *((void *)a2 + 2) && (*v9 & 0x80000000) == 0)
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
LABEL_28:
          if (v10 - 31 < 0x19 || (v10 <= 0xE ? (BOOL v17 = ((1 << v10) & 0x76B6) == 0) : (BOOL v17 = 1), !v17))
          {
            if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0)) {
              CLMicroLocationProto::MotionEvent::MergeFrom();
            }
            *((_DWORD *)this + 11) |= 1u;
            *((_DWORD *)this + 4) = v10;
          }
          char v19 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v19 < *((void *)a2 + 2) && *v19 == 18)
          {
            *((void *)a2 + 1) = v19 + 1;
            goto LABEL_42;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v30);
        if (result)
        {
          unsigned int v10 = v30;
          goto LABEL_28;
        }
        break;
      case 2u:
        int v8 = TagFallback & 7;
        if (v8 != 2) {
          goto LABEL_22;
        }
LABEL_42:
        *((_DWORD *)this + 11) |= 2u;
        if (*((void *)this + 1) == v5) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v20 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        if ((unint64_t)v20 >= v11 || *v20 != 24) {
          continue;
        }
        int v12 = v20 + 1;
        *((void *)a2 + 1) = v12;
LABEL_48:
        unsigned int v29 = 0;
        if ((unint64_t)v12 >= v11 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v29);
          if (!result) {
            return result;
          }
          unsigned int v21 = v29;
        }
        else
        {
          unsigned int v21 = *v12;
          *((void *)a2 + 1) = v12 + 1;
        }
        if (v21 <= 0xA)
        {
          *((_DWORD *)this + 11) |= 4u;
          *((_DWORD *)this + 5) = v21;
        }
        int v22 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v22 >= *((void *)a2 + 2) || *v22 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v22 + 1;
LABEL_58:
        *((_DWORD *)this + 11) |= 8u;
        if (*((void *)this + 3) == v5) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        uint64_t v23 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        if ((unint64_t)v23 >= v13 || *v23 != 40) {
          continue;
        }
        unsigned int v14 = v23 + 1;
        *((void *)a2 + 1) = v14;
LABEL_64:
        unsigned int v28 = 0;
        if ((unint64_t)v14 >= v13 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v28);
          if (!result) {
            return result;
          }
          unsigned int v24 = v28;
        }
        else
        {
          unsigned int v24 = *v14;
          *((void *)a2 + 1) = v14 + 1;
        }
        if (v24 <= 2)
        {
          *((_DWORD *)this + 11) |= 0x10u;
          *((_DWORD *)this + 8) = v24;
        }
        char v25 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        if ((unint64_t)v25 >= v15 || *v25 != 48) {
          continue;
        }
        int v16 = v25 + 1;
        *((void *)a2 + 1) = v16;
LABEL_74:
        if ((unint64_t)v16 >= v15 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v4);
          if (!result) {
            return result;
          }
          uint64_t v26 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v15 = *((void *)a2 + 2);
        }
        else
        {
          *uint64_t v4 = *v16;
          uint64_t v26 = (unsigned __int8 *)(v16 + 1);
          *((void *)a2 + 1) = v26;
        }
        *((_DWORD *)this + 11) |= 0x20u;
        if (v26 != (unsigned __int8 *)v15 || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10)) {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        int v12 = (char *)*((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 2);
        goto LABEL_48;
      case 4u:
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_58;
        }
        goto LABEL_22;
      case 5u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        unsigned int v14 = (char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        goto LABEL_64;
      case 6u:
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_22;
        }
        int v16 = (char *)*((void *)a2 + 1);
        unint64_t v15 = *((void *)a2 + 2);
        goto LABEL_74;
      default:
        int v8 = TagFallback & 7;
LABEL_22:
        if (v8 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

unsigned int *CLMicroLocationProto::MotionEvent::SerializeWithCachedSizes(unsigned int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  unsigned int v6 = this[11];
  if (v6)
  {
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[4], (uint64_t)a2, a4);
    unsigned int v6 = v5[11];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  unsigned int v6 = v5[11];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v5[5], (uint64_t)a2, a4);
  unsigned int v6 = v5[11];
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
LABEL_12:
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v5[8], (uint64_t)a2, a4);
    if ((v5[11] & 0x20) == 0) {
      return this;
    }
    goto LABEL_13;
  }
LABEL_11:
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  unsigned int v6 = v5[11];
  if ((v6 & 0x10) != 0) {
    goto LABEL_12;
  }
LABEL_6:
  if ((v6 & 0x20) == 0) {
    return this;
  }
LABEL_13:
  uint64_t v7 = v5[9];
  return (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v7, (uint64_t)a2, a4);
}

uint64_t CLMicroLocationProto::MotionEvent::ByteSize(CLMicroLocationProto::MotionEvent *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 44);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_52;
  }
  if (*((unsigned char *)this + 44))
  {
    uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
    if ((v4 & 0x80000000) != 0)
    {
      uint64_t v3 = 11;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 11);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 44) & 2) == 0) {
      goto LABEL_22;
    }
  }
  uint64_t v5 = *((void *)this + 1);
  int v6 = *(unsigned __int8 *)(v5 + 23);
  char v7 = v6;
  uint64_t v8 = *(void *)(v5 + 8);
  if ((v6 & 0x80u) == 0) {
    unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else {
    unint64_t v9 = v8;
  }
  if (v9 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v8 = *(void *)(v5 + 8);
    int v2 = *((_DWORD *)this + 11);
    char v7 = *(unsigned char *)(v5 + 23);
  }
  else
  {
    int v10 = 1;
  }
  if (v7 < 0) {
    int v6 = v8;
  }
  uint64_t v3 = (v3 + v10 + v6 + 1);
LABEL_22:
  if ((v2 & 4) != 0)
  {
    unint64_t v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 5);
    if ((v11 & 0x80000000) != 0)
    {
      int v12 = 11;
    }
    else if (v11 >= 0x80)
    {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11) + 1;
      int v2 = *((_DWORD *)this + 11);
    }
    else
    {
      int v12 = 2;
    }
    uint64_t v3 = (v12 + v3);
    if ((v2 & 8) == 0)
    {
LABEL_24:
      if ((v2 & 0x10) == 0) {
        goto LABEL_25;
      }
      goto LABEL_42;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_24;
  }
  uint64_t v13 = *((void *)this + 3);
  int v14 = *(unsigned __int8 *)(v13 + 23);
  char v15 = v14;
  uint64_t v16 = *(void *)(v13 + 8);
  if ((v14 & 0x80u) == 0) {
    unint64_t v17 = *(unsigned __int8 *)(v13 + 23);
  }
  else {
    unint64_t v17 = v16;
  }
  if (v17 >= 0x80)
  {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v17);
    int v14 = *(unsigned __int8 *)(v13 + 23);
    uint64_t v16 = *(void *)(v13 + 8);
    int v2 = *((_DWORD *)this + 11);
    char v15 = *(unsigned char *)(v13 + 23);
  }
  else
  {
    int v18 = 1;
  }
  if (v15 < 0) {
    int v14 = v16;
  }
  uint64_t v3 = (v3 + v18 + v14 + 1);
  if ((v2 & 0x10) == 0)
  {
LABEL_25:
    if ((v2 & 0x20) == 0) {
      goto LABEL_52;
    }
    goto LABEL_48;
  }
LABEL_42:
  char v19 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
  if ((v19 & 0x80000000) != 0)
  {
    int v20 = 11;
  }
  else if (v19 >= 0x80)
  {
    int v20 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v19) + 1;
    int v2 = *((_DWORD *)this + 11);
  }
  else
  {
    int v20 = 2;
  }
  uint64_t v3 = (v20 + v3);
  if ((v2 & 0x20) != 0)
  {
LABEL_48:
    unsigned int v21 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 9);
    if (v21 >= 0x80) {
      int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v21) + 1;
    }
    else {
      int v22 = 2;
    }
    uint64_t v3 = (v22 + v3);
  }
LABEL_52:
  *((_DWORD *)this + 10) = v3;
  return v3;
}

void CLMicroLocationProto::MotionEvent::CheckTypeAndMergeFrom(CLMicroLocationProto::MotionEvent *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::MotionEvent::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::MotionEvent::CopyFrom(CLMicroLocationProto::MotionEvent *this, const CLMicroLocationProto::MotionEvent *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::MotionEvent *))(*(void *)this + 32))(this);
    CLMicroLocationProto::MotionEvent::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::MotionEvent::IsInitialized(CLMicroLocationProto::MotionEvent *this)
{
  return 1;
}

void *CLMicroLocationProto::MotionEvent::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.MotionEvent");
}

void CLMicroLocationProto::LegacyThrottle::MergeFrom(CLMicroLocationProto::LegacyThrottle *this, const CLMicroLocationProto::LegacyThrottle *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 24))
    {
      unsigned int v5 = *((_DWORD *)a2 + 4);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::LegacyThrottle::MergeFrom();
      }
      *((_DWORD *)this + 6) |= 1u;
      *((_DWORD *)this + 4) = v5;
      int v4 = *((_DWORD *)a2 + 6);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 6) |= 2u;
      char v7 = (std::string *)*((void *)this + 1);
      if (v7 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v7, v6);
    }
  }
}

void sub_25642B6E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::LegacyThrottle::~LegacyThrottle(CLMicroLocationProto::LegacyThrottle *this)
{
  *(void *)this = &unk_2704DF3E8;
  CLMicroLocationProto::ClusterRecordings::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::LegacyThrottle::~LegacyThrottle(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::LegacyThrottle::New(CLMicroLocationProto::LegacyThrottle *this)
{
}

uint64_t CLMicroLocationProto::LegacyThrottle::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 24);
  if (v1)
  {
    *(_DWORD *)(this + 16) = 46;
    if ((v1 & 2) != 0)
    {
      uint64_t v2 = *(void *)(this + 8);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::LegacyThrottle::MergePartialFromCodedStream(CLMicroLocationProto::LegacyThrottle *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      unsigned int v5 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v5;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v5 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v7 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unsigned int v14 = 0;
      uint64_t v8 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v14);
        if (!result) {
          return result;
        }
        unsigned int v9 = v14;
      }
      else
      {
        unsigned int v9 = *v8;
        *((void *)a2 + 1) = v8 + 1;
      }
      if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v10 = ((1 << v9) & 0x76B6) == 0) : (BOOL v10 = 1), !v10))
      {
        if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
          CLMicroLocationProto::LegacyThrottle::MergeFrom();
        }
        *((_DWORD *)this + 6) |= 1u;
        *((_DWORD *)this + 4) = v9;
      }
      int v12 = (unsigned char *)*((void *)a2 + 1);
      if ((unint64_t)v12 < *((void *)a2 + 2) && *v12 == 18)
      {
        *((void *)a2 + 1) = v12 + 1;
LABEL_35:
        *((_DWORD *)this + 6) |= 2u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v7 = TagFallback & 7;
      if (v7 == 2) {
        goto LABEL_35;
      }
    }
    else
    {
      int v7 = TagFallback & 7;
    }
LABEL_16:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::LegacyThrottle::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v4 = this;
  int v5 = *(_DWORD *)(this + 24);
  if (v5)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 16), (uint64_t)a2, a4);
    int v5 = *(_DWORD *)(v4 + 24);
  }
  if ((v5 & 2) != 0)
  {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  }
  return this;
}

uint64_t CLMicroLocationProto::LegacyThrottle::ByteSize(CLMicroLocationProto::LegacyThrottle *this)
{
  char v2 = *((unsigned char *)this + 24);
  if (v2)
  {
    if (*((unsigned char *)this + 24))
    {
      uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
      if ((v4 & 0x80000000) != 0)
      {
        uint64_t v3 = 11;
        if ((v2 & 2) == 0) {
          goto LABEL_22;
        }
      }
      else if (v4 >= 0x80)
      {
        uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
        if ((*((_DWORD *)this + 6) & 2) == 0) {
          goto LABEL_22;
        }
      }
      else
      {
        uint64_t v3 = 2;
        if ((v2 & 2) == 0) {
          goto LABEL_22;
        }
      }
    }
    else
    {
      uint64_t v3 = 0;
      if ((*((unsigned char *)this + 24) & 2) == 0) {
        goto LABEL_22;
      }
    }
    uint64_t v5 = *((void *)this + 1);
    int v6 = *(unsigned __int8 *)(v5 + 23);
    char v7 = v6;
    uint64_t v8 = *(void *)(v5 + 8);
    if ((v6 & 0x80u) == 0) {
      unint64_t v9 = *(unsigned __int8 *)(v5 + 23);
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v9);
      int v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v8 = *(void *)(v5 + 8);
      char v7 = *(unsigned char *)(v5 + 23);
    }
    else
    {
      int v10 = 1;
    }
    if (v7 < 0) {
      int v6 = v8;
    }
    uint64_t v3 = (v3 + v10 + v6 + 1);
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_22:
  *((_DWORD *)this + 5) = v3;
  return v3;
}

void CLMicroLocationProto::LegacyThrottle::CheckTypeAndMergeFrom(CLMicroLocationProto::LegacyThrottle *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::LegacyThrottle::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::LegacyThrottle::CopyFrom(CLMicroLocationProto::LegacyThrottle *this, const CLMicroLocationProto::LegacyThrottle *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::LegacyThrottle *))(*(void *)this + 32))(this);
    CLMicroLocationProto::LegacyThrottle::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::LegacyThrottle::IsInitialized(CLMicroLocationProto::LegacyThrottle *this)
{
  return 1;
}

void *CLMicroLocationProto::LegacyThrottle::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.LegacyThrottle");
}

void CLMicroLocationProto::RetrievedLoi::MergeFrom(CLMicroLocationProto::RetrievedLoi *this, const CLMicroLocationProto::RetrievedLoi *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 48);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 48))
  {
    unsigned int v5 = *((_DWORD *)a2 + 6);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
      CLMicroLocationProto::RetrievedLoi::MergeFrom();
    }
    *((_DWORD *)this + 12) |= 1u;
    *((_DWORD *)this + 6) = v5;
    int v4 = *((_DWORD *)a2 + 12);
  }
  if ((v4 & 2) != 0)
  {
    char v7 = (const std::string *)*((void *)a2 + 1);
    *((_DWORD *)this + 12) |= 2u;
    uint64_t v8 = (std::string *)*((void *)this + 1);
    if (v8 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v8, v7);
    int v4 = *((_DWORD *)a2 + 12);
    if ((v4 & 4) == 0)
    {
LABEL_11:
      if ((v4 & 8) == 0) {
        goto LABEL_12;
      }
LABEL_22:
      unint64_t v11 = (const std::string *)*((void *)a2 + 4);
      *((_DWORD *)this + 12) |= 8u;
      int v12 = (std::string *)*((void *)this + 4);
      if (v12 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v12, v11);
      int v4 = *((_DWORD *)a2 + 12);
      if ((v4 & 0x10) == 0)
      {
LABEL_13:
        if ((v4 & 0x20) == 0) {
          return;
        }
        goto LABEL_14;
      }
      goto LABEL_25;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_11;
  }
  unint64_t v9 = (const std::string *)*((void *)a2 + 2);
  *((_DWORD *)this + 12) |= 4u;
  int v10 = (std::string *)*((void *)this + 2);
  if (v10 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v10, v9);
  int v4 = *((_DWORD *)a2 + 12);
  if ((v4 & 8) != 0) {
    goto LABEL_22;
  }
LABEL_12:
  if ((v4 & 0x10) == 0) {
    goto LABEL_13;
  }
LABEL_25:
  int v13 = *((_DWORD *)a2 + 7);
  if ((v13 - 1) >= 0xC) {
    CLMicroLocationProto::RetrievedLoi::MergeFrom();
  }
  *((_DWORD *)this + 12) |= 0x10u;
  *((_DWORD *)this + 7) = v13;
  if ((*((_DWORD *)a2 + 12) & 0x20) != 0)
  {
LABEL_14:
    char v6 = *((unsigned char *)a2 + 40);
    *((_DWORD *)this + 12) |= 0x20u;
    *((unsigned char *)this + 40) = v6;
  }
}

void sub_25642BEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RetrievedLoi::~RetrievedLoi(CLMicroLocationProto::RetrievedLoi *this)
{
  *(void *)this = &unk_2704DF460;
  CLMicroLocationProto::RetrievedLoi::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::RetrievedLoi::~RetrievedLoi(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::RetrievedLoi::SharedDtor(CLMicroLocationProto::RetrievedLoi *this)
{
  char v1 = this;
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::RetrievedLoi *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 2);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::RetrievedLoi *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  uint64_t v7 = *((void *)v1 + 4);
  if (v7 != v3 && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    this = (CLMicroLocationProto::RetrievedLoi *)MEMORY[0x25A2A6340](v7, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::RetrievedLoi::New(CLMicroLocationProto::RetrievedLoi *this)
{
}

uint64_t CLMicroLocationProto::RetrievedLoi::Clear(uint64_t this)
{
  char v1 = *(unsigned char *)(this + 48);
  if (v1)
  {
    *(_DWORD *)(this + 24) = 47;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 48) & 4) != 0)
    {
      uint64_t v4 = *(void *)(this + 16);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 48) & 8) != 0)
    {
      uint64_t v5 = *(void *)(this + 32);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(this + 28) = 1;
    *(unsigned char *)(this + 40) = 0;
  }
  *(_DWORD *)(this + 48) = 0;
  return this;
}

uint64_t CLMicroLocationProto::RetrievedLoi::MergePartialFromCodedStream(CLMicroLocationProto::RetrievedLoi *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        unsigned int v26 = 0;
        uint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 < *((void *)a2 + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
LABEL_28:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v14 = ((1 << v9) & 0x76B6) == 0) : (BOOL v14 = 1), !v14))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::RetrievedLoi::MergeFrom();
            }
            *((_DWORD *)this + 12) |= 1u;
            *((_DWORD *)this + 6) = v9;
          }
          uint64_t v16 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v16 < *((void *)a2 + 2) && *v16 == 18)
          {
            *((void *)a2 + 1) = v16 + 1;
            goto LABEL_42;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v26);
        if (result)
        {
          unsigned int v9 = v26;
          goto LABEL_28;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_23;
        }
LABEL_42:
        *((_DWORD *)this + 12) |= 2u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        unint64_t v17 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v17 >= *((void *)a2 + 2) || *v17 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v17 + 1;
LABEL_48:
        *((_DWORD *)this + 12) |= 4u;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v18 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v18 >= *((void *)a2 + 2) || *v18 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v18 + 1;
LABEL_54:
        *((_DWORD *)this + 12) |= 8u;
        if (*((void *)this + 4) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        char v19 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((unint64_t)v19 >= v10 || *v19 != 40) {
          continue;
        }
        unint64_t v11 = v19 + 1;
        *((void *)a2 + 1) = v11;
LABEL_60:
        unsigned int v25 = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v25);
          if (!result) {
            return result;
          }
          unsigned int v20 = v25;
        }
        else
        {
          unsigned int v20 = *v11;
          *((void *)a2 + 1) = v11 + 1;
        }
        if (v20 - 1 <= 0xB)
        {
          *((_DWORD *)this + 12) |= 0x10u;
          *((_DWORD *)this + 7) = v20;
        }
        unsigned int v21 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        if ((unint64_t)v21 >= v12 || *v21 != 48) {
          continue;
        }
        int v13 = v21 + 1;
        *((void *)a2 + 1) = v13;
LABEL_70:
        unsigned int v27 = 0;
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v27);
          if (!result) {
            return result;
          }
          unsigned int v22 = v27;
          uint64_t v23 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v12 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v22 = *v13;
          uint64_t v23 = (unsigned __int8 *)(v13 + 1);
          *((void *)a2 + 1) = v23;
        }
        *((unsigned char *)this + 40) = v22 != 0;
        *((_DWORD *)this + 12) |= 0x20u;
        if (v23 != (unsigned __int8 *)v12 || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10)) {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_48;
        }
        goto LABEL_23;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_54;
        }
        goto LABEL_23;
      case 5u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        unint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_60;
      case 6u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_23;
        }
        int v13 = (char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        goto LABEL_70;
      default:
        int v7 = TagFallback & 7;
LABEL_23:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t CLMicroLocationProto::RetrievedLoi::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 48);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 24), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
LABEL_12:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, *(unsigned int *)(v5 + 28), (uint64_t)a2, a4);
    if ((*(_DWORD *)(v5 + 48) & 0x20) == 0) {
      return this;
    }
    goto LABEL_13;
  }
LABEL_11:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  int v6 = *(_DWORD *)(v5 + 48);
  if ((v6 & 0x10) != 0) {
    goto LABEL_12;
  }
LABEL_6:
  if ((v6 & 0x20) == 0) {
    return this;
  }
LABEL_13:
  uint64_t v7 = *(unsigned __int8 *)(v5 + 40);
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v7, (uint64_t)a2, a4);
}

uint64_t CLMicroLocationProto::RetrievedLoi::ByteSize(CLMicroLocationProto::RetrievedLoi *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 48);
  if (!(_BYTE)v2)
  {
    uint64_t result = 0;
    goto LABEL_53;
  }
  if (*((unsigned char *)this + 48))
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
    if ((v5 & 0x80000000) != 0)
    {
      unsigned int v3 = 11;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else if (v5 >= 0x80)
    {
      unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
      int v2 = *((_DWORD *)this + 12);
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
    else
    {
      unsigned int v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_22;
      }
    }
  }
  else
  {
    unsigned int v3 = 0;
    if ((*((unsigned char *)this + 48) & 2) == 0) {
      goto LABEL_22;
    }
  }
  uint64_t v6 = *((void *)this + 1);
  int v7 = *(unsigned __int8 *)(v6 + 23);
  char v8 = v7;
  uint64_t v9 = *(void *)(v6 + 8);
  if ((v7 & 0x80u) == 0) {
    unint64_t v10 = *(unsigned __int8 *)(v6 + 23);
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10 >= 0x80)
  {
    int v11 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v10);
    int v7 = *(unsigned __int8 *)(v6 + 23);
    uint64_t v9 = *(void *)(v6 + 8);
    int v2 = *((_DWORD *)this + 12);
    char v8 = *(unsigned char *)(v6 + 23);
  }
  else
  {
    int v11 = 1;
  }
  if (v8 < 0) {
    int v7 = v9;
  }
  v3 += v11 + v7 + 1;
LABEL_22:
  if ((v2 & 4) == 0)
  {
    if ((v2 & 8) == 0) {
      goto LABEL_24;
    }
LABEL_35:
    uint64_t v18 = *((void *)this + 4);
    int v19 = *(unsigned __int8 *)(v18 + 23);
    char v20 = v19;
    uint64_t v21 = *(void *)(v18 + 8);
    if ((v19 & 0x80u) == 0) {
      unint64_t v22 = *(unsigned __int8 *)(v18 + 23);
    }
    else {
      unint64_t v22 = v21;
    }
    if (v22 >= 0x80)
    {
      int v23 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v22);
      int v19 = *(unsigned __int8 *)(v18 + 23);
      uint64_t v21 = *(void *)(v18 + 8);
      int v2 = *((_DWORD *)this + 12);
      char v20 = *(unsigned char *)(v18 + 23);
    }
    else
    {
      int v23 = 1;
    }
    if (v20 < 0) {
      int v19 = v21;
    }
    v3 += v23 + v19 + 1;
    if ((v2 & 0x10) == 0) {
      goto LABEL_50;
    }
    goto LABEL_44;
  }
  uint64_t v12 = *((void *)this + 2);
  int v13 = *(unsigned __int8 *)(v12 + 23);
  char v14 = v13;
  uint64_t v15 = *(void *)(v12 + 8);
  if ((v13 & 0x80u) == 0) {
    unint64_t v16 = *(unsigned __int8 *)(v12 + 23);
  }
  else {
    unint64_t v16 = v15;
  }
  if (v16 >= 0x80)
  {
    int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v16);
    int v13 = *(unsigned __int8 *)(v12 + 23);
    uint64_t v15 = *(void *)(v12 + 8);
    int v2 = *((_DWORD *)this + 12);
    char v14 = *(unsigned char *)(v12 + 23);
  }
  else
  {
    int v17 = 1;
  }
  if (v14 < 0) {
    int v13 = v15;
  }
  v3 += v17 + v13 + 1;
  if ((v2 & 8) != 0) {
    goto LABEL_35;
  }
LABEL_24:
  if ((v2 & 0x10) != 0)
  {
LABEL_44:
    unsigned int v24 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 7);
    if ((v24 & 0x80000000) != 0)
    {
      int v25 = 11;
    }
    else if (v24 >= 0x80)
    {
      int v25 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v24) + 1;
      int v2 = *((_DWORD *)this + 12);
    }
    else
    {
      int v25 = 2;
    }
    v3 += v25;
  }
LABEL_50:
  if ((v2 & 0x20) != 0) {
    uint64_t result = v3 + 2;
  }
  else {
    uint64_t result = v3;
  }
LABEL_53:
  *((_DWORD *)this + 11) = result;
  return result;
}

void CLMicroLocationProto::RetrievedLoi::CheckTypeAndMergeFrom(CLMicroLocationProto::RetrievedLoi *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::RetrievedLoi::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::RetrievedLoi::CopyFrom(CLMicroLocationProto::RetrievedLoi *this, const CLMicroLocationProto::RetrievedLoi *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::RetrievedLoi *))(*(void *)this + 32))(this);
    CLMicroLocationProto::RetrievedLoi::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::RetrievedLoi::IsInitialized(CLMicroLocationProto::RetrievedLoi *this)
{
  return 1;
}

void *CLMicroLocationProto::RetrievedLoi::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.RetrievedLoi");
}

uint64_t CLMicroLocationProto::ReceivedEvent::default_instance(CLMicroLocationProto::ReceivedEvent *this)
{
  return CLMicroLocationProto::ReceivedEvent::default_instance_;
}

void CLMicroLocationProto::ReceivedEvent::New(CLMicroLocationProto::ReceivedEvent *this)
{
}

uint64_t CLMicroLocationProto::ReceivedEvent::Clear(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = (unsigned int *)(this + 292);
  unsigned int v3 = *(_DWORD *)(this + 292);
  if ((_BYTE)v3)
  {
    if (v3)
    {
      this = *(void *)(this + 8);
      if (this)
      {
        this = CLMicroLocationProto::ReceivedEventAction::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 2) != 0)
    {
      this = *(void *)(v1 + 16);
      if (this)
      {
        this = CLMicroLocationProto::AppLaunch::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 4) != 0)
    {
      this = *(void *)(v1 + 24);
      if (this)
      {
        this = CLMicroLocationProto::BacklightOn::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 8) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 32);
      if (v4)
      {
        if (*(unsigned char *)(v4 + 16)) {
          *(_DWORD *)(v4 + 8) = 5;
        }
        *(_DWORD *)(v4 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x10) != 0)
    {
      uint64_t v5 = *(void *)(v1 + 40);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 16)) {
          *(_DWORD *)(v5 + 8) = 7;
        }
        *(_DWORD *)(v5 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x20) != 0)
    {
      this = *(void *)(v1 + 48);
      if (this)
      {
        this = CLMicroLocationProto::HomeKitAccessory::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x40) != 0)
    {
      this = *(void *)(v1 + 56);
      if (this)
      {
        this = CLMicroLocationProto::HomeKitScene::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x80) != 0)
    {
      this = *(void *)(v1 + 64);
      if (this)
      {
        this = CLMicroLocationProto::NowPlaying::Clear((CLMicroLocationProto::NowPlaying *)this);
        unsigned int v3 = *v2;
      }
    }
  }
  if ((v3 & 0xFF00) != 0)
  {
    if ((v3 & 0x100) != 0)
    {
      this = *(void *)(v1 + 72);
      if (this)
      {
        this = CLMicroLocationProto::RecordingRequest::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x200) != 0)
    {
      this = *(void *)(v1 + 80);
      if (this)
      {
        this = CLMicroLocationProto::TruthLabelDonation::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x400) != 0)
    {
      uint64_t v6 = *(void *)(v1 + 88);
      if (v6)
      {
        if (*(unsigned char *)(v6 + 16)) {
          *(_DWORD *)(v6 + 8) = 31;
        }
        *(_DWORD *)(v6 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x800) != 0)
    {
      uint64_t v7 = *(void *)(v1 + 96);
      if (v7)
      {
        if (*(unsigned char *)(v7 + 16)) {
          *(_DWORD *)(v7 + 8) = 32;
        }
        *(_DWORD *)(v7 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x1000) != 0)
    {
      uint64_t v8 = *(void *)(v1 + 104);
      if (v8)
      {
        if (*(unsigned char *)(v8 + 16)) {
          *(_DWORD *)(v8 + 8) = 33;
        }
        *(_DWORD *)(v8 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x2000) != 0)
    {
      uint64_t v9 = *(void *)(v1 + 112);
      if (v9)
      {
        if (*(unsigned char *)(v9 + 16)) {
          *(_DWORD *)(v9 + 8) = 34;
        }
        *(_DWORD *)(v9 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x4000) != 0)
    {
      uint64_t v10 = *(void *)(v1 + 120);
      if (v10)
      {
        if (*(unsigned char *)(v10 + 16)) {
          *(_DWORD *)(v10 + 8) = 35;
        }
        *(_DWORD *)(v10 + 16) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x8000) != 0)
    {
      this = *(void *)(v1 + 128);
      if (this)
      {
        this = CLMicroLocationProto::ServiceCreate::Clear(this);
        unsigned int v3 = *v2;
      }
    }
  }
  if ((v3 & 0xFF0000) != 0)
  {
    if ((v3 & 0x10000) != 0)
    {
      this = *(void *)(v1 + 136);
      if (this)
      {
        this = CLMicroLocationProto::ServiceDelete::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x20000) != 0)
    {
      this = *(void *)(v1 + 144);
      if (this)
      {
        this = CLMicroLocationProto::ServiceConnect::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x40000) != 0)
    {
      this = *(void *)(v1 + 152);
      if (this)
      {
        this = CLMicroLocationProto::ServiceDisconnect::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x80000) != 0)
    {
      this = *(void *)(v1 + 160);
      if (this)
      {
        this = CLMicroLocationProto::ServiceStartUpdating::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x100000) != 0)
    {
      this = *(void *)(v1 + 168);
      if (this)
      {
        this = CLMicroLocationProto::ServiceStopUpdating::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x200000) != 0)
    {
      this = *(void *)(v1 + 176);
      if (this)
      {
        this = CLMicroLocationProto::RequestObservation::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x400000) != 0)
    {
      this = *(void *)(v1 + 184);
      if (this)
      {
        this = CLMicroLocationProto::RequestPrediction::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x800000) != 0)
    {
      this = *(void *)(v1 + 192);
      if (this)
      {
        this = CLMicroLocationProto::MiloInit::Clear(this);
        unsigned int v3 = *v2;
      }
    }
  }
  if (HIBYTE(v3))
  {
    if ((v3 & 0x1000000) != 0)
    {
      this = *(void *)(v1 + 200);
      if (this)
      {
        this = CLMicroLocationProto::MotionEvent::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x2000000) != 0)
    {
      this = *(void *)(v1 + 208);
      if (this)
      {
        this = CLMicroLocationProto::LegacyThrottle::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x4000000) != 0)
    {
      this = *(void *)(v1 + 216);
      if (this)
      {
        this = CLMicroLocationProto::RetrievedLoi::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x8000000) != 0)
    {
      this = *(void *)(v1 + 224);
      if (this)
      {
        this = CLMicroLocationProto::TriggerEvent::Clear(this);
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x10000000) != 0)
    {
      uint64_t v11 = *(void *)(v1 + 232);
      if (v11)
      {
        if (*(unsigned char *)(v11 + 24))
        {
          *(void *)(v11 + 8) = 0x100000031;
          *(_DWORD *)(v11 + 16) = 0;
        }
        *(_DWORD *)(v11 + 24) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x20000000) != 0)
    {
      uint64_t v12 = *(void *)(v1 + 240);
      if (v12)
      {
        if (*(unsigned char *)(v12 + 20))
        {
          *(_DWORD *)(v12 + 8) = 50;
          *(unsigned char *)(v12 + 12) = 0;
        }
        *(_DWORD *)(v12 + 20) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x40000000) != 0)
    {
      uint64_t v13 = *(void *)(v1 + 248);
      if (v13)
      {
        int v14 = *(_DWORD *)(v13 + 24);
        if ((_BYTE)v14)
        {
          *(void *)(v13 + 8) = 51;
          *(_DWORD *)(v13 + 15) = 0;
        }
        if ((v14 & 0xFF00) != 0) {
          *(unsigned char *)(v13 + 19) = 0;
        }
        *(_DWORD *)(v13 + 24) = 0;
        unsigned int v3 = *v2;
      }
    }
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t v15 = *(void *)(v1 + 256);
      if (v15)
      {
        if (*(unsigned char *)(v15 + 20))
        {
          *(_DWORD *)(v15 + 8) = 52;
          *(unsigned char *)(v15 + 12) = 0;
        }
        *(_DWORD *)(v15 + 20) = 0;
      }
    }
  }
  LOBYTE(v16) = *(unsigned char *)(v1 + 296);
  if ((_BYTE)v16)
  {
    if (*(unsigned char *)(v1 + 296))
    {
      uint64_t v17 = *(void *)(v1 + 264);
      if (v17)
      {
        if (*(unsigned char *)(v17 + 16)) {
          *(_DWORD *)(v17 + 8) = 53;
        }
        *(_DWORD *)(v17 + 16) = 0;
        int v16 = *(_DWORD *)(v1 + 296);
      }
    }
    if ((v16 & 2) != 0)
    {
      uint64_t v18 = *(void *)(v1 + 272);
      if (v18)
      {
        if (*(unsigned char *)(v18 + 16)) {
          *(_DWORD *)(v18 + 8) = 54;
        }
        *(_DWORD *)(v18 + 16) = 0;
        int v16 = *(_DWORD *)(v1 + 296);
      }
    }
    if ((v16 & 4) != 0)
    {
      uint64_t v19 = *(void *)(v1 + 280);
      if (v19)
      {
        if (*(unsigned char *)(v19 + 16)) {
          *(_DWORD *)(v19 + 8) = 55;
        }
        *(_DWORD *)(v19 + 16) = 0;
      }
    }
  }
  *(void *)uint64_t v2 = 0;
  return this;
}

uint64_t CLMicroLocationProto::TriggerEvent::Clear(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 84);
  if ((_BYTE)v1)
  {
    *(_DWORD *)(this + 24) = 48;
    *(void *)(this + 8) = 0;
    *(unsigned char *)(this + 28) = 0;
    uint64_t v2 = MEMORY[0x263F8C740];
    if ((v1 & 8) != 0)
    {
      uint64_t v3 = *(void *)(this + 16);
      if (v3 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 0x10) != 0)
    {
      uint64_t v4 = *(void *)(this + 32);
      if (v4 != v2)
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 0x20) != 0)
    {
      uint64_t v5 = *(void *)(this + 40);
      if (v5 != v2)
      {
        if (*(char *)(v5 + 23) < 0)
        {
          **(unsigned char **)uint64_t v5 = 0;
          *(void *)(v5 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v5 = 0;
          *(unsigned char *)(v5 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 84) & 0x40) != 0)
    {
      uint64_t v6 = *(void *)(this + 48);
      if (v6 != v2)
      {
        if (*(char *)(v6 + 23) < 0)
        {
          **(unsigned char **)uint64_t v6 = 0;
          *(void *)(v6 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(unsigned char *)(v6 + 23) = 0;
        }
      }
    }
    *(unsigned char *)(this + 29) = 0;
    int v1 = *(_DWORD *)(this + 84);
  }
  if ((v1 & 0xFF00) != 0)
  {
    *(void *)(this + 56) = 0;
    *(_DWORD *)(this + 72) = 0;
    if ((v1 & 0x800) != 0)
    {
      uint64_t v7 = *(void *)(this + 64);
      if (v7 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v7 + 23) < 0)
        {
          **(unsigned char **)uint64_t v7 = 0;
          *(void *)(v7 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v7 = 0;
          *(unsigned char *)(v7 + 23) = 0;
        }
      }
    }
    *(_DWORD *)(this + 76) = 0;
  }
  *(_DWORD *)(this + 84) = 0;
  return this;
}

uint64_t CLMicroLocationProto::LegacyClientStatusUpdate::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 24))
  {
    *(void *)(this + 8) = 0x100000031;
    *(_DWORD *)(this + 16) = 0;
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::SpectatingMotionUpdate::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 20))
  {
    *(_DWORD *)(this + 8) = 50;
    *(unsigned char *)(this + 12) = 0;
  }
  *(_DWORD *)(this + 20) = 0;
  return this;
}

uint64_t CLMicroLocationProto::EnabledStateUpdate::Clear(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 24);
  if ((_BYTE)v1)
  {
    *(void *)(this + 8) = 51;
    *(_DWORD *)(this + 15) = 0;
  }
  if ((v1 & 0xFF00) != 0) {
    *(unsigned char *)(this + 19) = 0;
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ScreenStateUpdate::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 20))
  {
    *(_DWORD *)(this + 8) = 52;
    *(unsigned char *)(this + 12) = 0;
  }
  *(_DWORD *)(this + 20) = 0;
  return this;
}

uint64_t CLMicroLocationProto::CloudBackupExport::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 53;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::CloudBackupImport::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 54;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::DataMigration::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 16)) {
    *(_DWORD *)(this + 8) = 55;
  }
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ReceivedEvent::MergePartialFromCodedStream(CLMicroLocationProto::ReceivedEvent *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    uint64_t v4 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v4 < *((void *)a2 + 2) && (*v4 & 0x80000000) == 0)
    {
      TagFallbacuint64_t k = *v4;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v4 + 1;
      if (!TagFallback) {
        return 1;
      }
      goto LABEL_6;
    }
    TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
    *((_DWORD *)a2 + 8) = TagFallback;
    if (!TagFallback) {
      return 1;
    }
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v6 = TagFallback & 7;
        if (v6 != 2) {
          goto LABEL_81;
        }
        *((_DWORD *)this + 73) |= 1u;
        uint64_t v7 = (CLMicroLocationProto::ReceivedEventAction *)*((void *)this + 1);
        if (!v7) {
          operator new();
        }
        unsigned int v253 = 0;
        uint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v8;
          *((void *)a2 + 1) = v8 + 1;
        }
        int v9 = *((_DWORD *)a2 + 14);
        int v10 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v9 + 1;
        if (v9 >= v10) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ReceivedEventAction::MergePartialFromCodedStream(v7, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v11 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v11, 1);
        int v13 = v11 - 1;
        if (v13 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v13;
        }
        int v14 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 != 18) {
          continue;
        }
        *((void *)a2 + 1) = v14 + 1;
        goto LABEL_93;
      case 2u:
        int v6 = TagFallback & 7;
        if (v6 != 2) {
          goto LABEL_81;
        }
LABEL_93:
        *((_DWORD *)this + 73) |= 2u;
        uint64_t v15 = (CLMicroLocationProto::AppLaunch *)*((void *)this + 2);
        if (!v15) {
          operator new();
        }
        unsigned int v253 = 0;
        int v16 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v16 >= *((void *)a2 + 2) || *v16 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v16;
          *((void *)a2 + 1) = v16 + 1;
        }
        int v17 = *((_DWORD *)a2 + 14);
        int v18 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v17 + 1;
        if (v17 >= v18) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::AppLaunch::MergePartialFromCodedStream(v15, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v19 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v19, 1);
        int v20 = v19 - 1;
        if (v20 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v20;
        }
        uint64_t v21 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v21 >= *((void *)a2 + 2) || *v21 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v21 + 1;
LABEL_107:
        *((_DWORD *)this + 73) |= 4u;
        unint64_t v22 = (CLMicroLocationProto::BacklightOn *)*((void *)this + 3);
        if (!v22) {
          operator new();
        }
        unsigned int v253 = 0;
        int v23 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v23 >= *((void *)a2 + 2) || *v23 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v23;
          *((void *)a2 + 1) = v23 + 1;
        }
        int v24 = *((_DWORD *)a2 + 14);
        int v25 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v24 + 1;
        if (v24 >= v25) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::BacklightOn::MergePartialFromCodedStream(v22, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v26 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v26, 1);
        int v27 = v26 - 1;
        if (v27 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v27;
        }
        unsigned int v28 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v28 >= *((void *)a2 + 2) || *v28 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v28 + 1;
LABEL_121:
        *((_DWORD *)this + 73) |= 8u;
        unsigned int v29 = (CLMicroLocationProto::BatteryChargerConnected *)*((void *)this + 4);
        if (!v29) {
          operator new();
        }
        unsigned int v253 = 0;
        unsigned int v30 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v30 >= *((void *)a2 + 2) || *v30 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v30;
          *((void *)a2 + 1) = v30 + 1;
        }
        int v31 = *((_DWORD *)a2 + 14);
        int v32 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v31 + 1;
        if (v31 >= v32) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::BatteryChargerConnected::MergePartialFromCodedStream(v29, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v33 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v33, 1);
        int v34 = v33 - 1;
        if (v34 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v34;
        }
        int v35 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v35 >= *((void *)a2 + 2) || *v35 != 58) {
          continue;
        }
        *((void *)a2 + 1) = v35 + 1;
LABEL_135:
        *((_DWORD *)this + 73) |= 0x10u;
        int v36 = (CLMicroLocationProto::ForcedRecording *)*((void *)this + 5);
        if (!v36) {
          operator new();
        }
        unsigned int v253 = 0;
        int v37 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v37 >= *((void *)a2 + 2) || *v37 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v37;
          *((void *)a2 + 1) = v37 + 1;
        }
        int v38 = *((_DWORD *)a2 + 14);
        int v39 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v38 + 1;
        if (v38 >= v39) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ForcedRecording::MergePartialFromCodedStream(v36, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v40 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v40, 1);
        int v41 = v40 - 1;
        if (v41 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v41;
        }
        uint64_t v42 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v42 >= *((void *)a2 + 2) || *v42 != 74) {
          continue;
        }
        *((void *)a2 + 1) = v42 + 1;
LABEL_149:
        *((_DWORD *)this + 73) |= 0x20u;
        int v43 = (CLMicroLocationProto::HomeKitAccessory *)*((void *)this + 6);
        if (!v43) {
          operator new();
        }
        unsigned int v253 = 0;
        char v44 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v44 >= *((void *)a2 + 2) || *v44 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v44;
          *((void *)a2 + 1) = v44 + 1;
        }
        int v45 = *((_DWORD *)a2 + 14);
        int v46 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v45 + 1;
        if (v45 >= v46) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::HomeKitAccessory::MergePartialFromCodedStream(v43, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v47 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v47, 1);
        int v48 = v47 - 1;
        if (v48 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v48;
        }
        uint64_t v49 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v49 >= *((void *)a2 + 2) || *v49 != 82) {
          continue;
        }
        *((void *)a2 + 1) = v49 + 1;
LABEL_163:
        *((_DWORD *)this + 73) |= 0x40u;
        int v50 = (CLMicroLocationProto::HomeKitScene *)*((void *)this + 7);
        if (!v50) {
          operator new();
        }
        unsigned int v253 = 0;
        char v51 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v51 >= *((void *)a2 + 2) || *v51 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v51;
          *((void *)a2 + 1) = v51 + 1;
        }
        int v52 = *((_DWORD *)a2 + 14);
        int v53 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v52 + 1;
        if (v52 >= v53) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::HomeKitScene::MergePartialFromCodedStream(v50, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v54 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v54, 1);
        int v55 = v54 - 1;
        if (v55 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v55;
        }
        char v56 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v56 >= *((void *)a2 + 2) || *v56 != 90) {
          continue;
        }
        *((void *)a2 + 1) = v56 + 1;
LABEL_177:
        *((_DWORD *)this + 73) |= 0x80u;
        uint64_t v57 = (CLMicroLocationProto::NowPlaying *)*((void *)this + 8);
        if (!v57) {
          operator new();
        }
        unsigned int v253 = 0;
        unint64_t v58 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v58 >= *((void *)a2 + 2) || *v58 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v58;
          *((void *)a2 + 1) = v58 + 1;
        }
        int v59 = *((_DWORD *)a2 + 14);
        int v60 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v59 + 1;
        if (v59 >= v60) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::NowPlaying::MergePartialFromCodedStream(v57, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v61 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v61, 1);
        int v62 = v61 - 1;
        if (v62 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v62;
        }
        char v63 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v63 >= *((void *)a2 + 2) || *v63 != 98) {
          continue;
        }
        *((void *)a2 + 1) = v63 + 1;
LABEL_191:
        *((_DWORD *)this + 73) |= 0x100u;
        uint64_t v64 = (CLMicroLocationProto::RecordingRequest *)*((void *)this + 9);
        if (!v64) {
          operator new();
        }
        unsigned int v253 = 0;
        unint64_t v65 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v65 >= *((void *)a2 + 2) || *v65 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v65;
          *((void *)a2 + 1) = v65 + 1;
        }
        int v66 = *((_DWORD *)a2 + 14);
        int v67 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v66 + 1;
        if (v66 >= v67) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::RecordingRequest::MergePartialFromCodedStream(v64, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v68 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v68, 1);
        int v69 = v68 - 1;
        if (v69 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v69;
        }
        uint64_t v70 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v70 >= *((void *)a2 + 2) || *v70 != 106) {
          continue;
        }
        *((void *)a2 + 1) = v70 + 1;
LABEL_205:
        *((_DWORD *)this + 73) |= 0x200u;
        unint64_t v71 = (CLMicroLocationProto::TruthLabelDonation *)*((void *)this + 10);
        if (!v71) {
          operator new();
        }
        unsigned int v253 = 0;
        int v72 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v72 >= *((void *)a2 + 2) || *v72 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v72;
          *((void *)a2 + 1) = v72 + 1;
        }
        int v73 = *((_DWORD *)a2 + 14);
        int v74 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v73 + 1;
        if (v73 >= v74) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::TruthLabelDonation::MergePartialFromCodedStream(v71, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v75 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v75, 1);
        int v76 = v75 - 1;
        if (v76 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v76;
        }
        unint64_t v77 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v77 >= *((void *)a2 + 2) || *v77 != 114) {
          continue;
        }
        *((void *)a2 + 1) = v77 + 1;
LABEL_219:
        *((_DWORD *)this + 73) |= 0x400u;
        int v78 = (CLMicroLocationProto::LearnModel *)*((void *)this + 11);
        if (!v78) {
          operator new();
        }
        unsigned int v253 = 0;
        __int16 v79 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v79 >= *((void *)a2 + 2) || *v79 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v79;
          *((void *)a2 + 1) = v79 + 1;
        }
        int v80 = *((_DWORD *)a2 + 14);
        int v81 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v80 + 1;
        if (v80 >= v81) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::LearnModel::MergePartialFromCodedStream(v78, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v82 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v82, 1);
        int v83 = v82 - 1;
        if (v83 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v83;
        }
        int v84 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v84 >= *((void *)a2 + 2) || *v84 != 122) {
          continue;
        }
        *((void *)a2 + 1) = v84 + 1;
LABEL_233:
        *((_DWORD *)this + 73) |= 0x800u;
        unsigned int v85 = (CLMicroLocationProto::LearnCompleted *)*((void *)this + 12);
        if (!v85) {
          operator new();
        }
        unsigned int v253 = 0;
        unint64_t v86 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v86 >= *((void *)a2 + 2) || *v86 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v86;
          *((void *)a2 + 1) = v86 + 1;
        }
        int v87 = *((_DWORD *)a2 + 14);
        int v88 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v87 + 1;
        if (v87 >= v88) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::LearnCompleted::MergePartialFromCodedStream(v85, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v89 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v89, 1);
        int v90 = v89 - 1;
        if (v90 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v90;
        }
        int v91 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v91 <= 1 || *v91 != 130 || v91[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v91 + 2;
LABEL_248:
        *((_DWORD *)this + 73) |= 0x1000u;
        int v92 = (CLMicroLocationProto::SensorsScanComplete *)*((void *)this + 13);
        if (!v92) {
          operator new();
        }
        unsigned int v253 = 0;
        double v93 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v93 >= *((void *)a2 + 2) || *v93 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v93;
          *((void *)a2 + 1) = v93 + 1;
        }
        int v94 = *((_DWORD *)a2 + 14);
        int v95 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v94 + 1;
        if (v94 >= v95) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::SensorsScanComplete::MergePartialFromCodedStream(v92, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v96 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v96, 1);
        int v97 = v96 - 1;
        if (v97 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v97;
        }
        int v98 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v98 <= 1 || *v98 != 138 || v98[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v98 + 2;
LABEL_263:
        *((_DWORD *)this + 73) |= 0x2000u;
        int v99 = (CLMicroLocationProto::StartSpectating *)*((void *)this + 14);
        if (!v99) {
          operator new();
        }
        unsigned int v253 = 0;
        int v100 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v100 >= *((void *)a2 + 2) || *v100 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v100;
          *((void *)a2 + 1) = v100 + 1;
        }
        int v101 = *((_DWORD *)a2 + 14);
        int v102 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v101 + 1;
        if (v101 >= v102) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::StartSpectating::MergePartialFromCodedStream(v99, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v103 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v103, 1);
        int v104 = v103 - 1;
        if (v104 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v104;
        }
        uint64_t v105 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v105 <= 1 || *v105 != 146 || v105[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v105 + 2;
LABEL_278:
        *((_DWORD *)this + 73) |= 0x4000u;
        int v106 = (CLMicroLocationProto::StopSpectating *)*((void *)this + 15);
        if (!v106) {
          operator new();
        }
        unsigned int v253 = 0;
        unsigned int v107 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v107 >= *((void *)a2 + 2) || *v107 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v107;
          *((void *)a2 + 1) = v107 + 1;
        }
        int v108 = *((_DWORD *)a2 + 14);
        int v109 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v108 + 1;
        if (v108 >= v109) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::StopSpectating::MergePartialFromCodedStream(v106, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v110 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v110, 1);
        int v111 = v110 - 1;
        if (v111 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v111;
        }
        __n128 v112 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v112 <= 1 || *v112 != 154 || v112[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v112 + 2;
LABEL_293:
        *((_DWORD *)this + 73) |= 0x8000u;
        long long v113 = (CLMicroLocationProto::ServiceCreate *)*((void *)this + 16);
        if (!v113) {
          operator new();
        }
        unsigned int v253 = 0;
        uint64_t v114 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v114 >= *((void *)a2 + 2) || *v114 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v114;
          *((void *)a2 + 1) = v114 + 1;
        }
        int v115 = *((_DWORD *)a2 + 14);
        int v116 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v115 + 1;
        if (v115 >= v116) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ServiceCreate::MergePartialFromCodedStream(v113, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v117 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v117, 1);
        int v118 = v117 - 1;
        if (v118 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v118;
        }
        uint64_t v119 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v119 <= 1 || *v119 != 162 || v119[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v119 + 2;
LABEL_308:
        *((_DWORD *)this + 73) |= 0x10000u;
        char v120 = (CLMicroLocationProto::ServiceDelete *)*((void *)this + 17);
        if (!v120) {
          operator new();
        }
        unsigned int v253 = 0;
        __n128 v121 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v121 >= *((void *)a2 + 2) || *v121 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v121;
          *((void *)a2 + 1) = v121 + 1;
        }
        int v122 = *((_DWORD *)a2 + 14);
        int v123 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v122 + 1;
        if (v122 >= v123) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ServiceDelete::MergePartialFromCodedStream(v120, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v124 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v124, 1);
        int v125 = v124 - 1;
        if (v125 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v125;
        }
        __int16 v126 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v126 <= 1 || *v126 != 170 || v126[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v126 + 2;
LABEL_323:
        *((_DWORD *)this + 73) |= 0x20000u;
        int64_t v127 = (CLMicroLocationProto::ServiceConnect *)*((void *)this + 18);
        if (!v127) {
          operator new();
        }
        unsigned int v253 = 0;
        int64_t v128 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v128 >= *((void *)a2 + 2) || *v128 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v128;
          *((void *)a2 + 1) = v128 + 1;
        }
        int v129 = *((_DWORD *)a2 + 14);
        int v130 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v129 + 1;
        if (v129 >= v130) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ServiceConnect::MergePartialFromCodedStream(v127, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v131 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v131, 1);
        int v132 = v131 - 1;
        if (v132 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v132;
        }
        __int16 v133 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v133 <= 1 || *v133 != 178 || v133[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v133 + 2;
LABEL_338:
        *((_DWORD *)this + 73) |= 0x40000u;
        int v134 = (CLMicroLocationProto::ServiceDisconnect *)*((void *)this + 19);
        if (!v134) {
          operator new();
        }
        unsigned int v253 = 0;
        __int16 v135 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v135 >= *((void *)a2 + 2) || *v135 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v135;
          *((void *)a2 + 1) = v135 + 1;
        }
        int v136 = *((_DWORD *)a2 + 14);
        int v137 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v136 + 1;
        if (v136 >= v137) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ServiceDisconnect::MergePartialFromCodedStream(v134, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v138 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v138, 1);
        int v139 = v138 - 1;
        if (v139 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v139;
        }
        uint64_t v140 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v140 <= 1 || *v140 != 186 || v140[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v140 + 2;
LABEL_353:
        *((_DWORD *)this + 73) |= 0x80000u;
        long long v141 = (CLMicroLocationProto::ServiceStartUpdating *)*((void *)this + 20);
        if (!v141) {
          operator new();
        }
        unsigned int v253 = 0;
        std::string v142 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v142 >= *((void *)a2 + 2) || *v142 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v142;
          *((void *)a2 + 1) = v142 + 1;
        }
        int v143 = *((_DWORD *)a2 + 14);
        int v144 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v143 + 1;
        if (v143 >= v144) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ServiceStartUpdating::MergePartialFromCodedStream(v141, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v145 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v145, 1);
        int v146 = v145 - 1;
        if (v146 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v146;
        }
        long long v147 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v147 <= 1 || *v147 != 194 || v147[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v147 + 2;
LABEL_368:
        *((_DWORD *)this + 73) |= 0x100000u;
        long long v148 = (CLMicroLocationProto::ServiceStopUpdating *)*((void *)this + 21);
        if (!v148) {
          operator new();
        }
        unsigned int v253 = 0;
        long long v149 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v149 >= *((void *)a2 + 2) || *v149 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v149;
          *((void *)a2 + 1) = v149 + 1;
        }
        int v150 = *((_DWORD *)a2 + 14);
        int v151 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v150 + 1;
        if (v150 >= v151) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ServiceStopUpdating::MergePartialFromCodedStream(v148, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v152 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v152, 1);
        int v153 = v152 - 1;
        if (v153 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v153;
        }
        unint64_t v154 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v154 <= 1 || *v154 != 202 || v154[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v154 + 2;
LABEL_383:
        *((_DWORD *)this + 73) |= 0x200000u;
        unint64_t v155 = (CLMicroLocationProto::RequestObservation *)*((void *)this + 22);
        if (!v155) {
          operator new();
        }
        unsigned int v253 = 0;
        int v156 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v156 >= *((void *)a2 + 2) || *v156 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v156;
          *((void *)a2 + 1) = v156 + 1;
        }
        int v157 = *((_DWORD *)a2 + 14);
        int v158 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v157 + 1;
        if (v157 >= v158) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::RequestObservation::MergePartialFromCodedStream(v155, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v159 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v159, 1);
        int v160 = v159 - 1;
        if (v160 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v160;
        }
        long long v161 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v161 <= 1 || *v161 != 210 || v161[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v161 + 2;
LABEL_398:
        *((_DWORD *)this + 73) |= 0x400000u;
        int64_t v162 = (CLMicroLocationProto::RequestPrediction *)*((void *)this + 23);
        if (!v162) {
          operator new();
        }
        unsigned int v253 = 0;
        uint64_t v163 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v163 >= *((void *)a2 + 2) || *v163 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v163;
          *((void *)a2 + 1) = v163 + 1;
        }
        int v164 = *((_DWORD *)a2 + 14);
        int v165 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v164 + 1;
        if (v164 >= v165) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::RequestPrediction::MergePartialFromCodedStream(v162, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v166 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v166, 1);
        int v167 = v166 - 1;
        if (v167 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v167;
        }
        unint64_t v168 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v168 <= 1 || *v168 != 218 || v168[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v168 + 2;
LABEL_413:
        *((_DWORD *)this + 73) |= 0x800000u;
        unint64_t v169 = (CLMicroLocationProto::MiloInit *)*((void *)this + 24);
        if (!v169) {
          operator new();
        }
        unsigned int v253 = 0;
        int v170 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v170 >= *((void *)a2 + 2) || *v170 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v170;
          *((void *)a2 + 1) = v170 + 1;
        }
        int v171 = *((_DWORD *)a2 + 14);
        int v172 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v171 + 1;
        if (v171 >= v172) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::MiloInit::MergePartialFromCodedStream(v169, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v173 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v173, 1);
        int v174 = v173 - 1;
        if (v174 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v174;
        }
        long long v175 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v175 <= 1 || *v175 != 226 || v175[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v175 + 2;
LABEL_428:
        *((_DWORD *)this + 73) |= 0x1000000u;
        unsigned int v176 = (CLMicroLocationProto::MotionEvent *)*((void *)this + 25);
        if (!v176) {
          operator new();
        }
        unsigned int v253 = 0;
        __int16 v177 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v177 >= *((void *)a2 + 2) || *v177 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v177;
          *((void *)a2 + 1) = v177 + 1;
        }
        int v178 = *((_DWORD *)a2 + 14);
        int v179 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v178 + 1;
        if (v178 >= v179) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::MotionEvent::MergePartialFromCodedStream(v176, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v180 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v180, 1);
        int v181 = v180 - 1;
        if (v181 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v181;
        }
        long long v182 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v182 <= 1 || *v182 != 234 || v182[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v182 + 2;
LABEL_443:
        *((_DWORD *)this + 73) |= 0x2000000u;
        uint64_t v183 = (CLMicroLocationProto::LegacyThrottle *)*((void *)this + 26);
        if (!v183) {
          operator new();
        }
        unsigned int v253 = 0;
        uint64_t v184 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v184 >= *((void *)a2 + 2) || *v184 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v184;
          *((void *)a2 + 1) = v184 + 1;
        }
        int v185 = *((_DWORD *)a2 + 14);
        int v186 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v185 + 1;
        if (v185 >= v186) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::LegacyThrottle::MergePartialFromCodedStream(v183, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v187 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v187, 1);
        int v188 = v187 - 1;
        if (v188 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v188;
        }
        unint64_t v189 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v189 <= 1 || *v189 != 242 || v189[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v189 + 2;
LABEL_458:
        *((_DWORD *)this + 73) |= 0x4000000u;
        unint64_t v190 = (CLMicroLocationProto::RetrievedLoi *)*((void *)this + 27);
        if (!v190) {
          operator new();
        }
        unsigned int v253 = 0;
        long long v191 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v191 >= *((void *)a2 + 2) || *v191 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v191;
          *((void *)a2 + 1) = v191 + 1;
        }
        int v192 = *((_DWORD *)a2 + 14);
        int v193 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v192 + 1;
        if (v192 >= v193) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::RetrievedLoi::MergePartialFromCodedStream(v190, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v194 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v194, 1);
        int v195 = v194 - 1;
        if (v195 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v195;
        }
        long long v196 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v196 <= 1 || *v196 != 250 || v196[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v196 + 2;
LABEL_473:
        *((_DWORD *)this + 73) |= 0x8000000u;
        uint64_t v197 = (CLMicroLocationProto::TriggerEvent *)*((void *)this + 28);
        if (!v197) {
          operator new();
        }
        unsigned int v253 = 0;
        long long v198 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v198 >= *((void *)a2 + 2) || *v198 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v198;
          *((void *)a2 + 1) = v198 + 1;
        }
        int v199 = *((_DWORD *)a2 + 14);
        int v200 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v199 + 1;
        if (v199 >= v200) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::TriggerEvent::MergePartialFromCodedStream(v197, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v201 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v201, 1);
        int v202 = v201 - 1;
        if (v202 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v202;
        }
        unint64_t v203 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v203 <= 1 || *v203 != 130 || v203[1] != 2) {
          continue;
        }
        *((void *)a2 + 1) = v203 + 2;
LABEL_488:
        *((_DWORD *)this + 73) |= 0x10000000u;
        unint64_t v204 = (CLMicroLocationProto::LegacyClientStatusUpdate *)*((void *)this + 29);
        if (!v204) {
          operator new();
        }
        unsigned int v253 = 0;
        int v205 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v205 >= *((void *)a2 + 2) || *v205 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v205;
          *((void *)a2 + 1) = v205 + 1;
        }
        int v206 = *((_DWORD *)a2 + 14);
        int v207 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v206 + 1;
        if (v206 >= v207) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::LegacyClientStatusUpdate::MergePartialFromCodedStream(v204, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v208 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v208, 1);
        int v209 = v208 - 1;
        if (v209 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v209;
        }
        long long v210 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v210 <= 1 || *v210 != 138 || v210[1] != 2) {
          continue;
        }
        *((void *)a2 + 1) = v210 + 2;
LABEL_503:
        *((_DWORD *)this + 73) |= 0x20000000u;
        v211 = (CLMicroLocationProto::SpectatingMotionUpdate *)*((void *)this + 30);
        if (!v211) {
          operator new();
        }
        unsigned int v253 = 0;
        int v212 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v212 >= *((void *)a2 + 2) || *v212 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v212;
          *((void *)a2 + 1) = v212 + 1;
        }
        int v213 = *((_DWORD *)a2 + 14);
        int v214 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v213 + 1;
        if (v213 >= v214) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::SpectatingMotionUpdate::MergePartialFromCodedStream(v211, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v215 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v215, 1);
        int v216 = v215 - 1;
        if (v216 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v216;
        }
        unint64_t v217 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v217 <= 1 || *v217 != 146 || v217[1] != 2) {
          continue;
        }
        *((void *)a2 + 1) = v217 + 2;
LABEL_518:
        *((_DWORD *)this + 73) |= 0x40000000u;
        v218 = (CLMicroLocationProto::EnabledStateUpdate *)*((void *)this + 31);
        if (!v218) {
          operator new();
        }
        unsigned int v253 = 0;
        int v219 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v219 >= *((void *)a2 + 2) || *v219 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v219;
          *((void *)a2 + 1) = v219 + 1;
        }
        int v220 = *((_DWORD *)a2 + 14);
        int v221 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v220 + 1;
        if (v220 >= v221) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::EnabledStateUpdate::MergePartialFromCodedStream(v218, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v222 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v222, 1);
        int v223 = v222 - 1;
        if (v223 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v223;
        }
        unint64_t v224 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v224 <= 1 || *v224 != 154 || v224[1] != 2) {
          continue;
        }
        *((void *)a2 + 1) = v224 + 2;
LABEL_533:
        *((_DWORD *)this + 73) |= 0x80000000;
        int v225 = (CLMicroLocationProto::ScreenStateUpdate *)*((void *)this + 32);
        if (!v225) {
          operator new();
        }
        unsigned int v253 = 0;
        long long v226 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v226 >= *((void *)a2 + 2) || *v226 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v226;
          *((void *)a2 + 1) = v226 + 1;
        }
        int v227 = *((_DWORD *)a2 + 14);
        int v228 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v227 + 1;
        if (v227 >= v228) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ScreenStateUpdate::MergePartialFromCodedStream(v225, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v229 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v229, 1);
        int v230 = v229 - 1;
        if (v230 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v230;
        }
        v231 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v231 <= 1 || *v231 != 162 || v231[1] != 2) {
          continue;
        }
        *((void *)a2 + 1) = v231 + 2;
LABEL_548:
        *((_DWORD *)this + 74) |= 1u;
        v232 = (CLMicroLocationProto::CloudBackupExport *)*((void *)this + 33);
        if (!v232) {
          operator new();
        }
        unsigned int v253 = 0;
        v233 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v233 >= *((void *)a2 + 2) || *v233 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v233;
          *((void *)a2 + 1) = v233 + 1;
        }
        int v234 = *((_DWORD *)a2 + 14);
        int v235 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v234 + 1;
        if (v234 >= v235) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::CloudBackupExport::MergePartialFromCodedStream(v232, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v236 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v236, 1);
        int v237 = v236 - 1;
        if (v237 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v237;
        }
        unint64_t v238 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v238 <= 1 || *v238 != 170 || v238[1] != 2) {
          continue;
        }
        *((void *)a2 + 1) = v238 + 2;
LABEL_563:
        *((_DWORD *)this + 74) |= 2u;
        v239 = (CLMicroLocationProto::CloudBackupImport *)*((void *)this + 34);
        if (!v239) {
          operator new();
        }
        unsigned int v253 = 0;
        v240 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v240 >= *((void *)a2 + 2) || *v240 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v240;
          *((void *)a2 + 1) = v240 + 1;
        }
        int v241 = *((_DWORD *)a2 + 14);
        int v242 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v241 + 1;
        if (v241 >= v242) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::CloudBackupImport::MergePartialFromCodedStream(v239, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v243 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v243, 1);
        int v244 = v243 - 1;
        if (v244 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v244;
        }
        v245 = (unsigned __int8 *)*((void *)a2 + 1);
        if (*((_DWORD *)a2 + 4) - (int)v245 <= 1 || *v245 != 178 || v245[1] != 2) {
          continue;
        }
        *((void *)a2 + 1) = v245 + 2;
LABEL_578:
        *((_DWORD *)this + 74) |= 4u;
        unint64_t v246 = (CLMicroLocationProto::DataMigration *)*((void *)this + 35);
        if (!v246) {
          operator new();
        }
        unsigned int v253 = 0;
        v247 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v247 >= *((void *)a2 + 2) || *v247 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v253))return 0; {
        }
          }
        else
        {
          unsigned int v253 = *v247;
          *((void *)a2 + 1) = v247 + 1;
        }
        int v248 = *((_DWORD *)a2 + 14);
        int v249 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v248 + 1;
        if (v248 >= v249) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::DataMigration::MergePartialFromCodedStream(v246, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v250 = *((_DWORD *)a2 + 14);
        BOOL v12 = __OFSUB__(v250, 1);
        int v251 = v250 - 1;
        if (v251 < 0 == v12) {
          *((_DWORD *)a2 + 14) = v251;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
        break;
      case 4u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_107;
        }
        goto LABEL_81;
      case 5u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_121;
        }
        goto LABEL_81;
      case 7u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_135;
        }
        goto LABEL_81;
      case 9u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_149;
        }
        goto LABEL_81;
      case 0xAu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_163;
        }
        goto LABEL_81;
      case 0xBu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_177;
        }
        goto LABEL_81;
      case 0xCu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_191;
        }
        goto LABEL_81;
      case 0xDu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_205;
        }
        goto LABEL_81;
      case 0xEu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_219;
        }
        goto LABEL_81;
      case 0xFu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_233;
        }
        goto LABEL_81;
      case 0x10u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_248;
        }
        goto LABEL_81;
      case 0x11u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_263;
        }
        goto LABEL_81;
      case 0x12u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_278;
        }
        goto LABEL_81;
      case 0x13u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_293;
        }
        goto LABEL_81;
      case 0x14u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_308;
        }
        goto LABEL_81;
      case 0x15u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_323;
        }
        goto LABEL_81;
      case 0x16u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_338;
        }
        goto LABEL_81;
      case 0x17u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_353;
        }
        goto LABEL_81;
      case 0x18u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_368;
        }
        goto LABEL_81;
      case 0x19u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_383;
        }
        goto LABEL_81;
      case 0x1Au:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_398;
        }
        goto LABEL_81;
      case 0x1Bu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_413;
        }
        goto LABEL_81;
      case 0x1Cu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_428;
        }
        goto LABEL_81;
      case 0x1Du:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_443;
        }
        goto LABEL_81;
      case 0x1Eu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_458;
        }
        goto LABEL_81;
      case 0x1Fu:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_473;
        }
        goto LABEL_81;
      case 0x20u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_488;
        }
        goto LABEL_81;
      case 0x21u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_503;
        }
        goto LABEL_81;
      case 0x22u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_518;
        }
        goto LABEL_81;
      case 0x23u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_533;
        }
        goto LABEL_81;
      case 0x24u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_548;
        }
        goto LABEL_81;
      case 0x25u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_563;
        }
        goto LABEL_81;
      case 0x26u:
        int v6 = TagFallback & 7;
        if (v6 != 2) {
          goto LABEL_81;
        }
        goto LABEL_578;
      default:
        int v6 = TagFallback & 7;
LABEL_81:
        if (v6 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

void CLMicroLocationProto::ReceivedEvent::CheckTypeAndMergeFrom(CLMicroLocationProto::ReceivedEvent *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ReceivedEvent::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::TriggerEvent::MergeFrom(CLMicroLocationProto::TriggerEvent *this, const CLMicroLocationProto::TriggerEvent *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v23);
  }
  int v4 = *((_DWORD *)a2 + 21);
  if (!(_BYTE)v4) {
    goto LABEL_17;
  }
  if (v4)
  {
    unsigned int v5 = *((_DWORD *)a2 + 6);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
      CLMicroLocationProto::TriggerEvent::MergeFrom();
    }
    *((_DWORD *)this + 21) |= 1u;
    *((_DWORD *)this + 6) = v5;
    int v4 = *((_DWORD *)a2 + 21);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v13 = *((void *)a2 + 1);
    *((_DWORD *)this + 21) |= 2u;
    *((void *)this + 1) = v13;
    int v4 = *((_DWORD *)a2 + 21);
    if ((v4 & 4) == 0)
    {
LABEL_11:
      if ((v4 & 8) == 0) {
        goto LABEL_12;
      }
      goto LABEL_37;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_11;
  }
  char v14 = *((unsigned char *)a2 + 28);
  *((_DWORD *)this + 21) |= 4u;
  *((unsigned char *)this + 28) = v14;
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 8) == 0)
  {
LABEL_12:
    if ((v4 & 0x10) == 0) {
      goto LABEL_13;
    }
    goto LABEL_40;
  }
LABEL_37:
  uint64_t v15 = (const std::string *)*((void *)a2 + 2);
  *((_DWORD *)this + 21) |= 8u;
  int v16 = (std::string *)*((void *)this + 2);
  if (v16 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v16, v15);
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 0x10) == 0)
  {
LABEL_13:
    if ((v4 & 0x20) == 0) {
      goto LABEL_14;
    }
LABEL_43:
    int v19 = (const std::string *)*((void *)a2 + 5);
    *((_DWORD *)this + 21) |= 0x20u;
    int v20 = (std::string *)*((void *)this + 5);
    if (v20 == (std::string *)MEMORY[0x263F8C740]) {
      operator new();
    }
    std::string::operator=(v20, v19);
    int v4 = *((_DWORD *)a2 + 21);
    if ((v4 & 0x40) == 0)
    {
LABEL_15:
      if ((v4 & 0x80) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    goto LABEL_46;
  }
LABEL_40:
  int v17 = (const std::string *)*((void *)a2 + 4);
  *((_DWORD *)this + 21) |= 0x10u;
  int v18 = (std::string *)*((void *)this + 4);
  if (v18 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v18, v17);
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 0x20) != 0) {
    goto LABEL_43;
  }
LABEL_14:
  if ((v4 & 0x40) == 0) {
    goto LABEL_15;
  }
LABEL_46:
  uint64_t v21 = (const std::string *)*((void *)a2 + 6);
  *((_DWORD *)this + 21) |= 0x40u;
  unint64_t v22 = (std::string *)*((void *)this + 6);
  if (v22 == (std::string *)MEMORY[0x263F8C740]) {
    operator new();
  }
  std::string::operator=(v22, v21);
  int v4 = *((_DWORD *)a2 + 21);
  if ((v4 & 0x80) != 0)
  {
LABEL_16:
    char v6 = *((unsigned char *)a2 + 29);
    *((_DWORD *)this + 21) |= 0x80u;
    *((unsigned char *)this + 29) = v6;
    int v4 = *((_DWORD *)a2 + 21);
  }
LABEL_17:
  if ((v4 & 0xFF00) != 0)
  {
    if ((v4 & 0x100) != 0)
    {
      unsigned int v7 = *((_DWORD *)a2 + 14);
      if (v7 >= 2) {
        CLMicroLocationProto::TriggerEvent::MergeFrom();
      }
      *((_DWORD *)this + 21) |= 0x100u;
      *((_DWORD *)this + 14) = v7;
      int v4 = *((_DWORD *)a2 + 21);
    }
    if ((v4 & 0x200) != 0)
    {
      unsigned int v8 = *((_DWORD *)a2 + 15);
      if (v8 >= 6) {
        CLMicroLocationProto::TriggerEvent::MergeFrom();
      }
      *((_DWORD *)this + 21) |= 0x200u;
      *((_DWORD *)this + 15) = v8;
      int v4 = *((_DWORD *)a2 + 21);
    }
    if ((v4 & 0x400) != 0)
    {
      unsigned int v9 = *((_DWORD *)a2 + 18);
      if (v9 >= 6) {
        CLMicroLocationProto::TriggerEvent::MergeFrom();
      }
      *((_DWORD *)this + 21) |= 0x400u;
      *((_DWORD *)this + 18) = v9;
      int v4 = *((_DWORD *)a2 + 21);
    }
    if ((v4 & 0x800) != 0)
    {
      int v10 = (const std::string *)*((void *)a2 + 8);
      *((_DWORD *)this + 21) |= 0x800u;
      int v11 = (std::string *)*((void *)this + 8);
      if (v11 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v11, v10);
      int v4 = *((_DWORD *)a2 + 21);
    }
    if ((v4 & 0x1000) != 0)
    {
      unsigned int v12 = *((_DWORD *)a2 + 19);
      if (v12 >= 4) {
        CLMicroLocationProto::TriggerEvent::MergeFrom();
      }
      *((_DWORD *)this + 21) |= 0x1000u;
      *((_DWORD *)this + 19) = v12;
    }
  }
}

void sub_256430100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::LegacyClientStatusUpdate::MergeFrom(CLMicroLocationProto::LegacyClientStatusUpdate *this, const CLMicroLocationProto::LegacyClientStatusUpdate *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 24))
    {
      unsigned int v5 = *((_DWORD *)a2 + 2);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::LegacyClientStatusUpdate::MergeFrom();
      }
      *((_DWORD *)this + 6) |= 1u;
      *((_DWORD *)this + 2) = v5;
      int v4 = *((_DWORD *)a2 + 6);
    }
    if ((v4 & 2) != 0)
    {
      int v6 = *((_DWORD *)a2 + 3);
      if ((v6 - 1) >= 2 && v6 != 255) {
        CLMicroLocationProto::LegacyClientStatusUpdate::MergeFrom();
      }
      *((_DWORD *)this + 6) |= 2u;
      *((_DWORD *)this + 3) = v6;
      int v4 = *((_DWORD *)a2 + 6);
    }
    if ((v4 & 4) != 0)
    {
      int v7 = *((_DWORD *)a2 + 4);
      *((_DWORD *)this + 6) |= 4u;
      *((_DWORD *)this + 4) = v7;
    }
  }
}

void sub_256430224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::SpectatingMotionUpdate::MergeFrom(CLMicroLocationProto::SpectatingMotionUpdate *this, const CLMicroLocationProto::SpectatingMotionUpdate *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 20);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 20))
    {
      unsigned int v5 = *((_DWORD *)a2 + 2);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::SpectatingMotionUpdate::MergeFrom();
      }
      *((_DWORD *)this + 5) |= 1u;
      *((_DWORD *)this + 2) = v5;
      int v4 = *((_DWORD *)a2 + 5);
    }
    if ((v4 & 2) != 0)
    {
      char v6 = *((unsigned char *)a2 + 12);
      *((_DWORD *)this + 5) |= 2u;
      *((unsigned char *)this + 12) = v6;
    }
  }
}

void sub_256430314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::EnabledStateUpdate::MergeFrom(CLMicroLocationProto::EnabledStateUpdate *this, const CLMicroLocationProto::EnabledStateUpdate *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }
  int v4 = *((_DWORD *)a2 + 6);
  if (!(_BYTE)v4) {
    goto LABEL_17;
  }
  if (v4)
  {
    unsigned int v5 = *((_DWORD *)a2 + 2);
    if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
      CLMicroLocationProto::EnabledStateUpdate::MergeFrom();
    }
    *((_DWORD *)this + 6) |= 1u;
    *((_DWORD *)this + 2) = v5;
    int v4 = *((_DWORD *)a2 + 6);
  }
  if ((v4 & 2) != 0)
  {
    char v8 = *((unsigned char *)a2 + 12);
    *((_DWORD *)this + 6) |= 2u;
    *((unsigned char *)this + 12) = v8;
    int v4 = *((_DWORD *)a2 + 6);
    if ((v4 & 4) == 0)
    {
LABEL_11:
      if ((v4 & 8) == 0) {
        goto LABEL_12;
      }
      goto LABEL_22;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_11;
  }
  char v9 = *((unsigned char *)a2 + 13);
  *((_DWORD *)this + 6) |= 4u;
  *((unsigned char *)this + 13) = v9;
  int v4 = *((_DWORD *)a2 + 6);
  if ((v4 & 8) == 0)
  {
LABEL_12:
    if ((v4 & 0x10) == 0) {
      goto LABEL_13;
    }
    goto LABEL_23;
  }
LABEL_22:
  char v10 = *((unsigned char *)a2 + 14);
  *((_DWORD *)this + 6) |= 8u;
  *((unsigned char *)this + 14) = v10;
  int v4 = *((_DWORD *)a2 + 6);
  if ((v4 & 0x10) == 0)
  {
LABEL_13:
    if ((v4 & 0x20) == 0) {
      goto LABEL_14;
    }
LABEL_24:
    char v12 = *((unsigned char *)a2 + 16);
    *((_DWORD *)this + 6) |= 0x20u;
    *((unsigned char *)this + 16) = v12;
    int v4 = *((_DWORD *)a2 + 6);
    if ((v4 & 0x40) == 0)
    {
LABEL_15:
      if ((v4 & 0x80) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    goto LABEL_25;
  }
LABEL_23:
  char v11 = *((unsigned char *)a2 + 15);
  *((_DWORD *)this + 6) |= 0x10u;
  *((unsigned char *)this + 15) = v11;
  int v4 = *((_DWORD *)a2 + 6);
  if ((v4 & 0x20) != 0) {
    goto LABEL_24;
  }
LABEL_14:
  if ((v4 & 0x40) == 0) {
    goto LABEL_15;
  }
LABEL_25:
  char v13 = *((unsigned char *)a2 + 17);
  *((_DWORD *)this + 6) |= 0x40u;
  *((unsigned char *)this + 17) = v13;
  int v4 = *((_DWORD *)a2 + 6);
  if ((v4 & 0x80) != 0)
  {
LABEL_16:
    char v6 = *((unsigned char *)a2 + 18);
    *((_DWORD *)this + 6) |= 0x80u;
    *((unsigned char *)this + 18) = v6;
    int v4 = *((_DWORD *)a2 + 6);
  }
LABEL_17:
  if ((v4 & 0x100) != 0)
  {
    char v7 = *((unsigned char *)a2 + 19);
    *((_DWORD *)this + 6) |= 0x100u;
    *((unsigned char *)this + 19) = v7;
  }
}

void sub_2564304E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ScreenStateUpdate::MergeFrom(CLMicroLocationProto::ScreenStateUpdate *this, const CLMicroLocationProto::ScreenStateUpdate *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 20);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 20))
    {
      unsigned int v5 = *((_DWORD *)a2 + 2);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0)) {
        CLMicroLocationProto::ScreenStateUpdate::MergeFrom();
      }
      *((_DWORD *)this + 5) |= 1u;
      *((_DWORD *)this + 2) = v5;
      int v4 = *((_DWORD *)a2 + 5);
    }
    if ((v4 & 2) != 0)
    {
      char v6 = *((unsigned char *)a2 + 12);
      *((_DWORD *)this + 5) |= 2u;
      *((unsigned char *)this + 12) = v6;
    }
  }
}

void sub_2564305D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::CloudBackupExport::MergeFrom(CLMicroLocationProto::CloudBackupExport *this, const CLMicroLocationProto::CloudBackupExport *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::CloudBackupExport::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_2564306A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::CloudBackupImport::MergeFrom(CLMicroLocationProto::CloudBackupImport *this, const CLMicroLocationProto::CloudBackupImport *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::CloudBackupImport::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_256430778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::DataMigration::MergeFrom(CLMicroLocationProto::DataMigration *this, const CLMicroLocationProto::DataMigration *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v6);
  }
  if (*((unsigned char *)a2 + 16))
  {
    unsigned int v4 = *((_DWORD *)a2 + 2);
    if (v4 - 31 >= 0x19 && (v4 > 0xE || ((1 << v4) & 0x76B6) == 0)) {
      CLMicroLocationProto::DataMigration::MergeFrom();
    }
    *((_DWORD *)this + 4) |= 1u;
    *((_DWORD *)this + 2) = v4;
  }
}

void sub_256430848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationProto::ReceivedEvent::IsInitialized(CLMicroLocationProto::ReceivedEvent *this)
{
  return 1;
}

void *CLMicroLocationProto::ReceivedEvent::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ReceivedEvent");
}

CLMicroLocationProto::AssociatedAccessPointInfo *CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo(CLMicroLocationProto::AssociatedAccessPointInfo *this, const CLMicroLocationProto::AssociatedAccessPointInfo *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_2704DF550;
  *((_DWORD *)this + 6) = 0;
  CLMicroLocationProto::AssociatedAccessPointInfo::MergeFrom(this, a2);
  return this;
}

void sub_2564308C4(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo(CLMicroLocationProto::AssociatedAccessPointInfo *this)
{
  *(void *)this = &unk_2704DF550;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::AssociatedAccessPointInfo::New(CLMicroLocationProto::AssociatedAccessPointInfo *this)
{
}

uint64_t CLMicroLocationProto::AssociatedAccessPointInfo::MergePartialFromCodedStream(CLMicroLocationProto::AssociatedAccessPointInfo *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  unsigned int v4 = (unint64_t *)((char *)this + 8);
  do
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_16;
        }
        char v9 = (char *)*((void *)a2 + 1);
        unint64_t v8 = *((void *)a2 + 2);
        if ((unint64_t)v9 >= v8 || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v4);
          if (!result) {
            return result;
          }
          char v10 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v8 = *((void *)a2 + 2);
        }
        else
        {
          *unsigned int v4 = *v9;
          char v10 = v9 + 1;
          *((void *)a2 + 1) = v10;
        }
        *((_DWORD *)this + 6) |= 1u;
        if ((unint64_t)v10 < v8 && *v10 == 21)
        {
          *((void *)a2 + 1) = v10 + 1;
          goto LABEL_24;
        }
      }
      if (TagFallback >> 3 != 2) {
        break;
      }
      int v7 = TagFallback & 7;
      if (v7 != 5) {
        goto LABEL_16;
      }
LABEL_24:
      unsigned int v12 = 0;
      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(a2, &v12) & 1) == 0) {
        return 0;
      }
      *((_DWORD *)this + 4) = v12;
      *((_DWORD *)this + 6) |= 2u;
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    int v7 = TagFallback & 7;
LABEL_16:
    if (v7 == 4) {
      return 1;
    }
  }
  while ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) != 0);
  return 0;
}

uint64_t CLMicroLocationProto::AssociatedAccessPointInfo::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 24);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(void *)(this + 8), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
  {
    float v7 = *(float *)(v5 + 16);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, v7, a3);
  }
  return this;
}

uint64_t CLMicroLocationProto::AssociatedAccessPointInfo::ByteSize(CLMicroLocationProto::AssociatedAccessPointInfo *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 24);
  if ((_BYTE)v2)
  {
    if (*((unsigned char *)this + 24))
    {
      unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this
                                                                                       + 1))
         + 1;
      int v2 = *((_DWORD *)this + 6);
    }
    else
    {
      unsigned int v3 = 0;
    }
    if ((v2 & 2) != 0) {
      uint64_t result = v3 + 5;
    }
    else {
      uint64_t result = v3;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 5) = result;
  return result;
}

float CLMicroLocationProto::AssociatedAccessPointInfo::CheckTypeAndMergeFrom(CLMicroLocationProto::AssociatedAccessPointInfo *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  return CLMicroLocationProto::AssociatedAccessPointInfo::MergeFrom(this, lpsrc);
}

float CLMicroLocationProto::AssociatedAccessPointInfo::CopyFrom(CLMicroLocationProto::AssociatedAccessPointInfo *this, const CLMicroLocationProto::AssociatedAccessPointInfo *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::AssociatedAccessPointInfo *))(*(void *)this + 32))(this);
    return CLMicroLocationProto::AssociatedAccessPointInfo::MergeFrom(this, a2);
  }
  return result;
}

uint64_t CLMicroLocationProto::AssociatedAccessPointInfo::IsInitialized(CLMicroLocationProto::AssociatedAccessPointInfo *this)
{
  return 1;
}

void *CLMicroLocationProto::AssociatedAccessPointInfo::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.AssociatedAccessPointInfo");
}

uint64_t CLMicroLocationProto::RecordingEvent::default_instance(CLMicroLocationProto::RecordingEvent *this)
{
  return CLMicroLocationProto::RecordingEvent::default_instance_;
}

void CLMicroLocationProto::RecordingEvent::New(CLMicroLocationProto::RecordingEvent *this)
{
}

uint64_t CLMicroLocationProto::RecordingEvent::Clear(uint64_t this)
{
  uint64_t v1 = this;
  int v2 = *(_DWORD *)(this + 140);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(this + 72) = 1;
    *(void *)(this + 8) = 0;
    if ((v2 & 4) != 0)
    {
      this = *(void *)(this + 16);
      if (this)
      {
        this = CLMicroLocationProto::ReceivedEventAction::Clear(this);
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    if ((v2 & 8) != 0)
    {
      this = *(void *)(v1 + 24);
      if (this)
      {
        this = CLMicroLocationProto::AppLaunch::Clear(this);
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    if ((v2 & 0x10) != 0)
    {
      this = *(void *)(v1 + 32);
      if (this)
      {
        this = CLMicroLocationProto::BacklightOn::Clear(this);
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    if ((v2 & 0x20) != 0)
    {
      uint64_t v3 = *(void *)(v1 + 40);
      if (v3)
      {
        if (*(unsigned char *)(v3 + 16)) {
          *(_DWORD *)(v3 + 8) = 5;
        }
        *(_DWORD *)(v3 + 16) = 0;
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    if ((v2 & 0x40) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 48);
      if (v4)
      {
        if (*(unsigned char *)(v4 + 16)) {
          *(_DWORD *)(v4 + 8) = 7;
        }
        *(_DWORD *)(v4 + 16) = 0;
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    if ((v2 & 0x80) != 0)
    {
      this = *(void *)(v1 + 56);
      if (this)
      {
        this = CLMicroLocationProto::HomeKitAccessory::Clear(this);
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
  }
  if ((v2 & 0xFF00) != 0)
  {
    if ((v2 & 0x100) != 0)
    {
      this = *(void *)(v1 + 64);
      if (this)
      {
        this = CLMicroLocationProto::HomeKitScene::Clear(this);
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    if ((v2 & 0x200) != 0)
    {
      this = *(void *)(v1 + 80);
      if (this)
      {
        this = CLMicroLocationProto::NowPlaying::Clear((CLMicroLocationProto::NowPlaying *)this);
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    if ((v2 & 0x400) != 0)
    {
      this = *(void *)(v1 + 88);
      if (this)
      {
        this = CLMicroLocationProto::RecordingRequest::Clear(this);
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    *(unsigned char *)(v1 + 76) = 0;
    if ((v2 & 0x1000) != 0)
    {
      this = *(void *)(v1 + 96);
      if (this)
      {
        this = CLMicroLocationProto::TruthLabelDonation::Clear(this);
        int v2 = *(_DWORD *)(v1 + 140);
      }
    }
    *(unsigned char *)(v1 + 77) = 0;
    *(_DWORD *)(v1 + 120) = 0;
  }
  if ((v2 & 0xFF0000) != 0)
  {
    if ((v2 & 0x10000) != 0)
    {
      uint64_t v5 = *(void *)(v1 + 128);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 24))
        {
          *(void *)(v5 + 8) = 0;
          *(_DWORD *)(v5 + 16) = 0;
        }
        *(_DWORD *)(v5 + 24) = 0;
      }
    }
    *(_DWORD *)(v1 + 124) = 0;
  }
  *(_DWORD *)(v1 + 112) = 0;
  *(_DWORD *)(v1 + 140) = 0;
  return this;
}

uint64_t CLMicroLocationProto::RecordingEvent::MergePartialFromCodedStream(CLMicroLocationProto::RecordingEvent *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (char *)this + 104;
LABEL_2:
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_47;
        }
        v116[0] = 0;
        unint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116);
          if (!result) {
            return result;
          }
          unsigned int v9 = v116[0];
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
        }
        if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v22 = ((1 << v9) & 0x76B6) == 0) : (BOOL v22 = 1), !v22))
        {
          if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
            CLMicroLocationProto::RecordingEvent::MergeFrom();
          }
          *((_DWORD *)this + 35) |= 1u;
          *((_DWORD *)this + 18) = v9;
        }
        int v24 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v24 < *((void *)a2 + 2) && *v24 == 17)
        {
          *((void *)a2 + 1) = v24 + 1;
          goto LABEL_69;
        }
        continue;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_47;
        }
LABEL_69:
        *(void *)int v116 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v116) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v116;
        }
        int v15 = *((_DWORD *)this + 35) | 2;
        *((_DWORD *)this + 35) = v15;
        int v25 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v25 >= *((void *)a2 + 2) || *v25 != 26) {
          continue;
        }
        *((void *)a2 + 1) = v25 + 1;
LABEL_73:
        *((_DWORD *)this + 35) = v15 | 4;
        int v26 = (CLMicroLocationProto::ReceivedEventAction *)*((void *)this + 2);
        if (!v26) {
          operator new();
        }
        v116[0] = 0;
        int v27 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v27 >= *((void *)a2 + 2) || *v27 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v27;
          *((void *)a2 + 1) = v27 + 1;
        }
        int v28 = *((_DWORD *)a2 + 14);
        int v29 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v28 + 1;
        if (v28 >= v29) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ReceivedEventAction::MergePartialFromCodedStream(v26, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v30 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v30, 1);
        int v32 = v30 - 1;
        if (v32 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v32;
        }
        int v33 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v33 >= *((void *)a2 + 2) || *v33 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v33 + 1;
LABEL_87:
        *((_DWORD *)this + 35) |= 8u;
        int v34 = (CLMicroLocationProto::AppLaunch *)*((void *)this + 3);
        if (!v34) {
          operator new();
        }
        v116[0] = 0;
        int v35 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v35 >= *((void *)a2 + 2) || *v35 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v35;
          *((void *)a2 + 1) = v35 + 1;
        }
        int v36 = *((_DWORD *)a2 + 14);
        int v37 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v36 + 1;
        if (v36 >= v37) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::AppLaunch::MergePartialFromCodedStream(v34, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v38 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v38, 1);
        int v39 = v38 - 1;
        if (v39 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v39;
        }
        int v40 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v40 >= *((void *)a2 + 2) || *v40 != 50) {
          continue;
        }
        *((void *)a2 + 1) = v40 + 1;
LABEL_101:
        *((_DWORD *)this + 35) |= 0x10u;
        int v41 = (CLMicroLocationProto::BacklightOn *)*((void *)this + 4);
        if (!v41) {
          operator new();
        }
        v116[0] = 0;
        uint64_t v42 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v42 >= *((void *)a2 + 2) || *v42 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v42;
          *((void *)a2 + 1) = v42 + 1;
        }
        int v43 = *((_DWORD *)a2 + 14);
        int v44 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v43 + 1;
        if (v43 >= v44) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::BacklightOn::MergePartialFromCodedStream(v41, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v45 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v45, 1);
        int v46 = v45 - 1;
        if (v46 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v46;
        }
        int v47 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v47 >= *((void *)a2 + 2) || *v47 != 58) {
          continue;
        }
        *((void *)a2 + 1) = v47 + 1;
LABEL_115:
        *((_DWORD *)this + 35) |= 0x20u;
        int v48 = (CLMicroLocationProto::BatteryChargerConnected *)*((void *)this + 5);
        if (!v48) {
          operator new();
        }
        v116[0] = 0;
        uint64_t v49 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v49 >= *((void *)a2 + 2) || *v49 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v49;
          *((void *)a2 + 1) = v49 + 1;
        }
        int v50 = *((_DWORD *)a2 + 14);
        int v51 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v50 + 1;
        if (v50 >= v51) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::BatteryChargerConnected::MergePartialFromCodedStream(v48, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v52 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v52, 1);
        int v53 = v52 - 1;
        if (v53 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v53;
        }
        int v54 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v54 >= *((void *)a2 + 2) || *v54 != 74) {
          continue;
        }
        *((void *)a2 + 1) = v54 + 1;
LABEL_129:
        *((_DWORD *)this + 35) |= 0x40u;
        int v55 = (CLMicroLocationProto::ForcedRecording *)*((void *)this + 6);
        if (!v55) {
          operator new();
        }
        v116[0] = 0;
        char v56 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v56 >= *((void *)a2 + 2) || *v56 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v56;
          *((void *)a2 + 1) = v56 + 1;
        }
        int v57 = *((_DWORD *)a2 + 14);
        int v58 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v57 + 1;
        if (v57 >= v58) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ForcedRecording::MergePartialFromCodedStream(v55, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v59 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v59, 1);
        int v60 = v59 - 1;
        if (v60 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v60;
        }
        int v61 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v61 >= *((void *)a2 + 2) || *v61 != 90) {
          continue;
        }
        *((void *)a2 + 1) = v61 + 1;
LABEL_143:
        *((_DWORD *)this + 35) |= 0x80u;
        int v62 = (CLMicroLocationProto::HomeKitAccessory *)*((void *)this + 7);
        if (!v62) {
          operator new();
        }
        v116[0] = 0;
        char v63 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v63 >= *((void *)a2 + 2) || *v63 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v63;
          *((void *)a2 + 1) = v63 + 1;
        }
        int v64 = *((_DWORD *)a2 + 14);
        int v65 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v64 + 1;
        if (v64 >= v65) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::HomeKitAccessory::MergePartialFromCodedStream(v62, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v66 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v66, 1);
        int v67 = v66 - 1;
        if (v67 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v67;
        }
        int v68 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v68 >= *((void *)a2 + 2) || *v68 != 98) {
          continue;
        }
        *((void *)a2 + 1) = v68 + 1;
LABEL_157:
        *((_DWORD *)this + 35) |= 0x100u;
        int v69 = (CLMicroLocationProto::HomeKitScene *)*((void *)this + 8);
        if (!v69) {
          operator new();
        }
        v116[0] = 0;
        uint64_t v70 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v70 >= *((void *)a2 + 2) || *v70 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v70;
          *((void *)a2 + 1) = v70 + 1;
        }
        int v71 = *((_DWORD *)a2 + 14);
        int v72 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v71 + 1;
        if (v71 >= v72) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::HomeKitScene::MergePartialFromCodedStream(v69, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v73 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v73, 1);
        int v74 = v73 - 1;
        if (v74 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v74;
        }
        int v75 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v75 >= *((void *)a2 + 2) || *v75 != 114) {
          continue;
        }
        *((void *)a2 + 1) = v75 + 1;
LABEL_171:
        *((_DWORD *)this + 35) |= 0x200u;
        int v76 = (CLMicroLocationProto::NowPlaying *)*((void *)this + 10);
        if (!v76) {
          operator new();
        }
        v116[0] = 0;
        unint64_t v77 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v77 >= *((void *)a2 + 2) || *v77 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v77;
          *((void *)a2 + 1) = v77 + 1;
        }
        int v78 = *((_DWORD *)a2 + 14);
        int v79 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v78 + 1;
        if (v78 >= v79) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::NowPlaying::MergePartialFromCodedStream(v76, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v80 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v80, 1);
        int v81 = v80 - 1;
        if (v81 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v81;
        }
        int v82 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v82 >= *((void *)a2 + 2) || *v82 != 122) {
          continue;
        }
        *((void *)a2 + 1) = v82 + 1;
LABEL_185:
        *((_DWORD *)this + 35) |= 0x400u;
        int v83 = (CLMicroLocationProto::RecordingRequest *)*((void *)this + 11);
        if (!v83) {
          operator new();
        }
        v116[0] = 0;
        int v84 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v84 >= *((void *)a2 + 2) || *v84 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v84;
          *((void *)a2 + 1) = v84 + 1;
        }
        int v85 = *((_DWORD *)a2 + 14);
        int v86 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v85 + 1;
        if (v85 >= v86) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::RecordingRequest::MergePartialFromCodedStream(v83, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v87 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v87, 1);
        int v88 = v87 - 1;
        if (v88 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v88;
        }
        int v89 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        if ((int)v12 - (int)v89 <= 1 || *v89 != 128 || v89[1] != 1) {
          continue;
        }
        char v13 = v89 + 2;
        *((void *)a2 + 1) = v13;
LABEL_200:
        v116[0] = 0;
        if ((unint64_t)v13 >= v12 || (char)*v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116);
          if (!result) {
            return result;
          }
          unsigned int v90 = v116[0];
          int v91 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v12 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v90 = *v13;
          int v91 = v13 + 1;
          *((void *)a2 + 1) = v91;
        }
        *((unsigned char *)this + 76) = v90 != 0;
        int v14 = *((_DWORD *)this + 35) | 0x800;
        *((_DWORD *)this + 35) = v14;
        if ((int)v12 - (int)v91 < 2 || *v91 != 138 || v91[1] != 1) {
          continue;
        }
        *((void *)a2 + 1) = v91 + 2;
LABEL_209:
        *((_DWORD *)this + 35) = v14 | 0x1000;
        int v92 = (CLMicroLocationProto::TruthLabelDonation *)*((void *)this + 12);
        if (!v92) {
          operator new();
        }
        v116[0] = 0;
        double v93 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v93 >= *((void *)a2 + 2) || *v93 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
        }
          }
        else
        {
          v116[0] = *v93;
          *((void *)a2 + 1) = v93 + 1;
        }
        int v94 = *((_DWORD *)a2 + 14);
        int v95 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v94 + 1;
        if (v94 >= v95) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::TruthLabelDonation::MergePartialFromCodedStream(v92, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v96 = *((_DWORD *)a2 + 14);
        BOOL v31 = __OFSUB__(v96, 1);
        int v97 = v96 - 1;
        if (v97 < 0 == v31) {
          *((_DWORD *)a2 + 14) = v97;
        }
        int v98 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((int)v10 - (int)v98 <= 1 || *v98 != 144 || v98[1] != 1) {
          continue;
        }
        char v11 = v98 + 2;
        *((void *)a2 + 1) = v11;
LABEL_224:
        v116[0] = 0;
        if ((unint64_t)v11 >= v10 || (char)*v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116);
          if (!result) {
            return result;
          }
          unsigned int v99 = v116[0];
          int v100 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v99 = *v11;
          int v100 = v11 + 1;
          *((void *)a2 + 1) = v100;
        }
        *((unsigned char *)this + 77) = v99 != 0;
        *((_DWORD *)this + 35) |= 0x2000u;
        if ((int)v10 - (int)v100 < 2 || *v100 != 152 || v100[1] != 1) {
          continue;
        }
        int v16 = (char *)(v100 + 2);
        *((void *)a2 + 1) = v16;
LABEL_233:
        v116[0] = 0;
        if ((unint64_t)v16 >= v10 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116);
          if (!result) {
            return result;
          }
          unsigned int v101 = v116[0];
        }
        else
        {
          unsigned int v101 = *v16;
          *((void *)a2 + 1) = v16 + 1;
        }
        if (v101 < 4 || v101 == 15)
        {
          *((_DWORD *)this + 35) |= 0x4000u;
          *((_DWORD *)this + 30) = v101;
        }
        int v103 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v17 = *((void *)a2 + 2);
        if ((int)v17 - (int)v103 >= 2 && *v103 == 160 && v103[1] == 1) {
          goto LABEL_247;
        }
        continue;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_47;
        }
        int v15 = *((_DWORD *)this + 35);
        goto LABEL_73;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_87;
        }
        goto LABEL_47;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_101;
        }
        goto LABEL_47;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_115;
        }
        goto LABEL_47;
      case 9u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_129;
        }
        goto LABEL_47;
      case 0xBu:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_143;
        }
        goto LABEL_47;
      case 0xCu:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_157;
        }
        goto LABEL_47;
      case 0xEu:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_171;
        }
        goto LABEL_47;
      case 0xFu:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_185;
        }
        goto LABEL_47;
      case 0x10u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_47;
        }
        char v13 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        goto LABEL_200;
      case 0x11u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_47;
        }
        int v14 = *((_DWORD *)this + 35);
        goto LABEL_209;
      case 0x12u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_47;
        }
        char v11 = (unsigned __int8 *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_224;
      case 0x13u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_47;
        }
        int v16 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_233;
      case 0x14u:
        int v7 = TagFallback & 7;
        if (v7 == 2)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline();
          if (!result) {
            return result;
          }
          while (1)
          {
            int v103 = (unsigned __int8 *)*((void *)a2 + 1);
            unint64_t v17 = *((void *)a2 + 2);
            if ((int)v17 - (int)v103 < 2) {
              goto LABEL_2;
            }
            int v107 = *v103;
            if (v107 == 170) {
              break;
            }
            if (v107 != 160 || v103[1] != 1) {
              goto LABEL_2;
            }
LABEL_247:
            int v18 = (char *)(v103 + 2);
            *((void *)a2 + 1) = v18;
LABEL_248:
            v116[0] = 0;
            if ((unint64_t)v18 >= v17 || *v18 < 0)
            {
              uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116);
              if (!result) {
                return result;
              }
              unsigned int v104 = v116[0];
            }
            else
            {
              unsigned int v104 = *v18;
              *((void *)a2 + 1) = v18 + 1;
            }
            if (v104 <= 7)
            {
              int v105 = *((_DWORD *)this + 28);
              if (v105 == *((_DWORD *)this + 29))
              {
                wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve((uint64_t)v4, v105 + 1);
                int v105 = *((_DWORD *)this + 28);
              }
              uint64_t v106 = *((void *)this + 13);
              *((_DWORD *)this + 28) = v105 + 1;
              *(_DWORD *)(v106 + 4 * v105) = v104;
            }
          }
          if (v103[1] == 1)
          {
            *((void *)a2 + 1) = v103 + 2;
LABEL_264:
            *((_DWORD *)this + 35) |= 0x10000u;
            int v108 = (CLMicroLocationProto::AssociatedAccessPointInfo *)*((void *)this + 16);
            if (!v108) {
              operator new();
            }
            v116[0] = 0;
            int v109 = (char *)*((void *)a2 + 1);
            if ((unint64_t)v109 >= *((void *)a2 + 2) || *v109 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116))return 0; {
            }
              }
            else
            {
              v116[0] = *v109;
              *((void *)a2 + 1) = v109 + 1;
            }
            int v110 = *((_DWORD *)a2 + 14);
            int v111 = *((_DWORD *)a2 + 15);
            *((_DWORD *)a2 + 14) = v110 + 1;
            if (v110 >= v111) {
              return 0;
            }
            wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
            if (!CLMicroLocationProto::AssociatedAccessPointInfo::MergePartialFromCodedStream(v108, a2)
              || !*((unsigned char *)a2 + 36))
            {
              return 0;
            }
            wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
            int v112 = *((_DWORD *)a2 + 14);
            BOOL v31 = __OFSUB__(v112, 1);
            int v113 = v112 - 1;
            if (v113 < 0 == v31) {
              *((_DWORD *)a2 + 14) = v113;
            }
            uint64_t v114 = (unsigned __int8 *)*((void *)a2 + 1);
            unint64_t v19 = *((void *)a2 + 2);
            if ((int)v19 - (int)v114 > 1 && *v114 == 176 && v114[1] == 1)
            {
              int v20 = (char *)(v114 + 2);
              *((void *)a2 + 1) = v20;
LABEL_279:
              v116[0] = 0;
              if ((unint64_t)v20 >= v19 || *v20 < 0)
              {
                uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v116);
                if (!result) {
                  return result;
                }
                unsigned int v115 = v116[0];
              }
              else
              {
                unsigned int v115 = *v20;
                *((void *)a2 + 1) = v20 + 1;
              }
              if (v115 <= 3)
              {
                *((_DWORD *)this + 35) |= 0x20000u;
                *((_DWORD *)this + 31) = v115;
              }
              if (*((void *)a2 + 1) == *((void *)a2 + 2)
                && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
              {
                *((_DWORD *)a2 + 8) = 0;
                uint64_t result = 1;
                *((unsigned char *)a2 + 36) = 1;
                return result;
              }
            }
          }
          continue;
        }
        if ((TagFallback & 7) == 0)
        {
          int v18 = (char *)*((void *)a2 + 1);
          unint64_t v17 = *((void *)a2 + 2);
          goto LABEL_248;
        }
LABEL_47:
        if (v7 != 4)
        {
          if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
          continue;
          }
        }
        return 1;
      case 0x15u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_264;
        }
        goto LABEL_47;
      case 0x16u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_47;
        }
        int v20 = (char *)*((void *)a2 + 1);
        unint64_t v19 = *((void *)a2 + 2);
        goto LABEL_279;
      default:
        int v7 = TagFallback & 7;
        goto LABEL_47;
    }
  }
}

unsigned int *CLMicroLocationProto::RecordingEvent::SerializeWithCachedSizes(unsigned int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  unsigned int v6 = this[35];
  if (v6)
  {
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[18], (uint64_t)a2, a4);
    unsigned int v6 = v5[35];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_25;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *((double *)v5 + 1), a3);
  unsigned int v6 = v5[35];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_28;
  }
LABEL_25:
  uint64_t v9 = *((void *)v5 + 2);
  if (!v9)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v9 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 16);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, v9, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_31;
  }
LABEL_28:
  uint64_t v10 = *((void *)v5 + 3);
  if (!v10)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v10 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 24);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v10, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_34;
  }
LABEL_31:
  uint64_t v11 = *((void *)v5 + 4);
  if (!v11)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v11 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 32);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v11, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_37;
  }
LABEL_34:
  uint64_t v12 = *((void *)v5 + 5);
  if (!v12)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v12 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 40);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)7, v12, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_40;
  }
LABEL_37:
  uint64_t v13 = *((void *)v5 + 6);
  if (!v13)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v13 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 48);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, v13, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_43;
  }
LABEL_40:
  uint64_t v14 = *((void *)v5 + 7);
  if (!v14)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v14 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 56);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, v14, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_46;
  }
LABEL_43:
  uint64_t v15 = *((void *)v5 + 8);
  if (!v15)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v15 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 64);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xC, v15, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_49;
  }
LABEL_46:
  uint64_t v16 = *((void *)v5 + 10);
  if (!v16)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v16 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 80);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xE, v16, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0) {
      goto LABEL_13;
    }
    goto LABEL_52;
  }
LABEL_49:
  uint64_t v17 = *((void *)v5 + 11);
  if (!v17)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v17 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 88);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xF, v17, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x800) == 0)
  {
LABEL_13:
    if ((v6 & 0x1000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_53;
  }
LABEL_52:
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x10, *((unsigned __int8 *)v5 + 76), (uint64_t)a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x1000) == 0)
  {
LABEL_14:
    if ((v6 & 0x2000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_56;
  }
LABEL_53:
  uint64_t v18 = *((void *)v5 + 12);
  if (!v18)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v18 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 96);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x11, v18, a2, a4);
  unsigned int v6 = v5[35];
  if ((v6 & 0x2000) == 0)
  {
LABEL_15:
    if ((v6 & 0x4000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_56:
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x12, *((unsigned __int8 *)v5 + 77), (uint64_t)a2, a4);
  if ((v5[35] & 0x4000) != 0) {
LABEL_16:
  }
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13, v5[30], (uint64_t)a2, a4);
LABEL_17:
  if ((int)v5[28] >= 1)
  {
    uint64_t v7 = 0;
    do
      this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x14, *(unsigned int *)(*((void *)v5 + 13) + 4 * v7++), (uint64_t)a2, a4);
    while (v7 < (int)v5[28]);
  }
  unsigned int v8 = v5[35];
  if ((v8 & 0x10000) == 0)
  {
    if ((v8 & 0x20000) == 0) {
      return this;
    }
    goto LABEL_61;
  }
  uint64_t v19 = *((void *)v5 + 16);
  if (!v19)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v19 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 128);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x15, v19, a2, a4);
  if ((v5[35] & 0x20000) != 0)
  {
LABEL_61:
    uint64_t v20 = v5[31];
    return (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x16, v20, (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::RecordingEvent::ByteSize(CLMicroLocationProto::RecordingEvent *this)
{
  int v2 = *((_DWORD *)this + 35);
  if (!(_BYTE)v2)
  {
    int v4 = 0;
    goto LABEL_57;
  }
  if (v2)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 18);
    if ((v5 & 0x80000000) != 0)
    {
      int v6 = 10;
    }
    else if (v5 >= 0x80)
    {
      int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5);
      int v2 = *((_DWORD *)this + 35);
    }
    else
    {
      int v6 = 1;
    }
    int v3 = v6 + 1;
  }
  else
  {
    int v3 = 0;
  }
  if ((v2 & 2) != 0) {
    int v4 = v3 + 9;
  }
  else {
    int v4 = v3;
  }
  if ((v2 & 4) != 0)
  {
    uint64_t v7 = (CLMicroLocationProto::ReceivedEventAction *)*((void *)this + 2);
    if (!v7)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      uint64_t v7 = *(CLMicroLocationProto::ReceivedEventAction **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 16);
    }
    unsigned int v8 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::ReceivedEventAction::ByteSize(v7);
    int v9 = (int)v8;
    if (v8 >= 0x80) {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v8);
    }
    else {
      int v10 = 1;
    }
    v4 += v9 + v10 + 1;
    int v2 = *((_DWORD *)this + 35);
    if ((v2 & 8) == 0)
    {
LABEL_16:
      if ((v2 & 0x10) == 0) {
        goto LABEL_17;
      }
      goto LABEL_33;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_16;
  }
  uint64_t v11 = *((void *)this + 3);
  if (!v11)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    uint64_t v11 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 24);
  }
  uint64_t v12 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::AppLaunch::ByteSize(v11);
  int v13 = (int)v12;
  if (v12 >= 0x80) {
    int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v12);
  }
  else {
    int v14 = 1;
  }
  v4 += v13 + v14 + 1;
  int v2 = *((_DWORD *)this + 35);
  if ((v2 & 0x10) == 0)
  {
LABEL_17:
    if ((v2 & 0x20) == 0) {
      goto LABEL_18;
    }
    goto LABEL_39;
  }
LABEL_33:
  uint64_t v15 = (CLMicroLocationProto::BacklightOn *)*((void *)this + 4);
  if (!v15)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    uint64_t v15 = *(CLMicroLocationProto::BacklightOn **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 32);
  }
  uint64_t v16 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::BacklightOn::ByteSize(v15);
  int v17 = (int)v16;
  if (v16 >= 0x80) {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v16);
  }
  else {
    int v18 = 1;
  }
  v4 += v17 + v18 + 1;
  int v2 = *((_DWORD *)this + 35);
  if ((v2 & 0x20) == 0)
  {
LABEL_18:
    if ((v2 & 0x40) == 0) {
      goto LABEL_19;
    }
    goto LABEL_45;
  }
LABEL_39:
  uint64_t v19 = (CLMicroLocationProto::BatteryChargerConnected *)*((void *)this + 5);
  if (!v19)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    uint64_t v19 = *(CLMicroLocationProto::BatteryChargerConnected **)(CLMicroLocationProto::RecordingEvent::default_instance_
                                                            + 40);
  }
  uint64_t v20 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::BatteryChargerConnected::ByteSize(v19);
  int v21 = (int)v20;
  if (v20 >= 0x80) {
    int v22 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v20);
  }
  else {
    int v22 = 1;
  }
  v4 += v21 + v22 + 1;
  int v2 = *((_DWORD *)this + 35);
  if ((v2 & 0x40) == 0)
  {
LABEL_19:
    if ((v2 & 0x80) == 0) {
      goto LABEL_57;
    }
    goto LABEL_51;
  }
LABEL_45:
  int v23 = (CLMicroLocationProto::ForcedRecording *)*((void *)this + 6);
  if (!v23)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    int v23 = *(CLMicroLocationProto::ForcedRecording **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 48);
  }
  int v24 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::ForcedRecording::ByteSize(v23);
  int v25 = (int)v24;
  if (v24 >= 0x80) {
    int v26 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v24);
  }
  else {
    int v26 = 1;
  }
  v4 += v25 + v26 + 1;
  int v2 = *((_DWORD *)this + 35);
  if ((v2 & 0x80) != 0)
  {
LABEL_51:
    int v27 = (CLMicroLocationProto::HomeKitAccessory *)*((void *)this + 7);
    if (!v27)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      int v27 = *(CLMicroLocationProto::HomeKitAccessory **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 56);
    }
    int v28 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::HomeKitAccessory::ByteSize(v27);
    int v29 = (int)v28;
    if (v28 >= 0x80) {
      int v30 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v28);
    }
    else {
      int v30 = 1;
    }
    v4 += v29 + v30 + 1;
    int v2 = *((_DWORD *)this + 35);
  }
LABEL_57:
  if ((v2 & 0xFF00) == 0) {
    goto LABEL_98;
  }
  if ((v2 & 0x100) == 0)
  {
    if ((v2 & 0x200) == 0) {
      goto LABEL_60;
    }
LABEL_68:
    uint64_t v35 = *((void *)this + 10);
    if (!v35)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      uint64_t v35 = *(void *)(CLMicroLocationProto::RecordingEvent::default_instance_ + 80);
    }
    int v36 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::NowPlaying::ByteSize(v35);
    int v37 = (int)v36;
    if (v36 >= 0x80) {
      int v38 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v36);
    }
    else {
      int v38 = 1;
    }
    v4 += v37 + v38 + 1;
    int v2 = *((_DWORD *)this + 35);
    if ((v2 & 0x400) == 0) {
      goto LABEL_80;
    }
    goto LABEL_74;
  }
  BOOL v31 = (CLMicroLocationProto::HomeKitScene *)*((void *)this + 8);
  if (!v31)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    BOOL v31 = *(CLMicroLocationProto::HomeKitScene **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 64);
  }
  int v32 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::HomeKitScene::ByteSize(v31);
  int v33 = (int)v32;
  if (v32 >= 0x80) {
    int v34 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v32);
  }
  else {
    int v34 = 1;
  }
  v4 += v33 + v34 + 1;
  int v2 = *((_DWORD *)this + 35);
  if ((v2 & 0x200) != 0) {
    goto LABEL_68;
  }
LABEL_60:
  if ((v2 & 0x400) != 0)
  {
LABEL_74:
    int v39 = (CLMicroLocationProto::RecordingRequest *)*((void *)this + 11);
    if (!v39)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      int v39 = *(CLMicroLocationProto::RecordingRequest **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 88);
    }
    int v40 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::RecordingRequest::ByteSize(v39);
    int v41 = (int)v40;
    if (v40 >= 0x80) {
      int v42 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v40);
    }
    else {
      int v42 = 1;
    }
    v4 += v41 + v42 + 1;
    int v2 = *((_DWORD *)this + 35);
  }
LABEL_80:
  if ((v2 & 0x800) != 0) {
    v4 += 3;
  }
  if ((v2 & 0x1000) != 0)
  {
    int v43 = (CLMicroLocationProto::TruthLabelDonation *)*((void *)this + 12);
    if (!v43)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      int v43 = *(CLMicroLocationProto::TruthLabelDonation **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 96);
    }
    int v44 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::TruthLabelDonation::ByteSize(v43);
    int v45 = (int)v44;
    if (v44 >= 0x80) {
      int v46 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v44);
    }
    else {
      int v46 = 1;
    }
    v4 += v45 + v46 + 2;
    int v2 = *((_DWORD *)this + 35);
  }
  if ((v2 & 0x2000) != 0) {
    v4 += 3;
  }
  if ((v2 & 0x4000) != 0)
  {
    int v47 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 30);
    if ((v47 & 0x80000000) != 0)
    {
      int v48 = 12;
    }
    else if (v47 >= 0x80)
    {
      int v48 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v47) + 2;
      int v2 = *((_DWORD *)this + 35);
    }
    else
    {
      int v48 = 3;
    }
    v4 += v48;
  }
LABEL_98:
  if ((v2 & 0xFF0000) != 0)
  {
    if ((v2 & 0x10000) != 0)
    {
      uint64_t v49 = (CLMicroLocationProto::AssociatedAccessPointInfo *)*((void *)this + 16);
      if (!v49)
      {
        CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
        uint64_t v49 = *(CLMicroLocationProto::AssociatedAccessPointInfo **)(CLMicroLocationProto::RecordingEvent::default_instance_
                                                                  + 128);
      }
      int v50 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::AssociatedAccessPointInfo::ByteSize(v49);
      int v51 = (int)v50;
      if (v50 >= 0x80) {
        int v52 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v50);
      }
      else {
        int v52 = 1;
      }
      v4 += v51 + v52 + 2;
      int v2 = *((_DWORD *)this + 35);
    }
    if ((v2 & 0x20000) != 0)
    {
      int v53 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 31);
      if ((v53 & 0x80000000) != 0)
      {
        int v54 = 12;
      }
      else if (v53 >= 0x80)
      {
        int v54 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v53) + 2;
      }
      else
      {
        int v54 = 3;
      }
      v4 += v54;
    }
  }
  int v55 = *((_DWORD *)this + 28);
  if (v55 < 1)
  {
    int v57 = 0;
  }
  else
  {
    uint64_t v56 = 0;
    int v57 = 0;
    do
    {
      int v58 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(*((void *)this + 13)
                                                                                             + 4 * v56);
      if ((v58 & 0x80000000) != 0)
      {
        int v59 = 10;
      }
      else if (v58 >= 0x80)
      {
        int v59 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v58);
        int v55 = *((_DWORD *)this + 28);
      }
      else
      {
        int v59 = 1;
      }
      v57 += v59;
      ++v56;
    }
    while (v56 < v55);
  }
  uint64_t result = (v57 + v4 + 2 * v55);
  *((_DWORD *)this + 34) = result;
  return result;
}

void CLMicroLocationProto::RecordingEvent::CheckTypeAndMergeFrom(CLMicroLocationProto::RecordingEvent *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::RecordingEvent::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::RecordingEvent::CopyFrom(CLMicroLocationProto::RecordingEvent *this, const CLMicroLocationProto::RecordingEvent *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::RecordingEvent *))(*(void *)this + 32))(this);
    CLMicroLocationProto::RecordingEvent::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::RecordingEvent::IsInitialized(CLMicroLocationProto::RecordingEvent *this)
{
  return 1;
}

void *CLMicroLocationProto::RecordingEvent::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.RecordingEvent");
}

CLMicroLocationProto::TriggerEvent *CLMicroLocationProto::TriggerEvent::TriggerEvent(CLMicroLocationProto::TriggerEvent *this, const CLMicroLocationProto::TriggerEvent *a2)
{
  *((_DWORD *)this + 6) = 48;
  *(void *)this = &unk_2704DF640;
  *((void *)this + 1) = 0;
  uint64_t v3 = MEMORY[0x263F8C740];
  *((_WORD *)this + 14) = 0;
  *((void *)this + 2) = v3;
  *((void *)this + 4) = v3;
  *((void *)this + 5) = v3;
  *((void *)this + 6) = v3;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = v3;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  CLMicroLocationProto::TriggerEvent::MergeFrom(this, a2);
  return this;
}

void sub_256432B80(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::TriggerEvent::~TriggerEvent(CLMicroLocationProto::TriggerEvent *this)
{
  *(void *)this = &unk_2704DF640;
  CLMicroLocationProto::TriggerEvent::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::TriggerEvent::~TriggerEvent(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::TriggerEvent::SharedDtor(CLMicroLocationProto::TriggerEvent *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 2);
  uint64_t v3 = MEMORY[0x263F8C740];
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::TriggerEvent *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  uint64_t v5 = *((void *)v1 + 4);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    this = (CLMicroLocationProto::TriggerEvent *)MEMORY[0x25A2A6340](v5, 0x1012C40EC159624);
  }
  uint64_t v7 = *((void *)v1 + 5);
  if (v7 != v3 && v7 != 0)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    this = (CLMicroLocationProto::TriggerEvent *)MEMORY[0x25A2A6340](v7, 0x1012C40EC159624);
  }
  uint64_t v9 = *((void *)v1 + 6);
  if (v9 != v3 && v9 != 0)
  {
    if (*(char *)(v9 + 23) < 0) {
      operator delete(*(void **)v9);
    }
    this = (CLMicroLocationProto::TriggerEvent *)MEMORY[0x25A2A6340](v9, 0x1012C40EC159624);
  }
  uint64_t v11 = *((void *)v1 + 8);
  if (v11 != v3 && v11)
  {
    if (*(char *)(v11 + 23) < 0) {
      operator delete(*(void **)v11);
    }
    this = (CLMicroLocationProto::TriggerEvent *)MEMORY[0x25A2A6340](v11, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
}

void CLMicroLocationProto::TriggerEvent::New(CLMicroLocationProto::TriggerEvent *this)
{
}

uint64_t CLMicroLocationProto::TriggerEvent::MergePartialFromCodedStream(CLMicroLocationProto::TriggerEvent *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (2)
  {
    uint64_t v5 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v5;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v5 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        v43[0] = 0;
        unsigned int v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 < *((void *)a2 + 2) && (*v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
LABEL_42:
          if (v9 - 31 < 0x19 || (v9 <= 0xE ? (BOOL v23 = ((1 << v9) & 0x76B6) == 0) : (BOOL v23 = 1), !v23))
          {
            if (v9 - 31 >= 0x19 && (v9 > 0xE || ((1 << v9) & 0x76B6) == 0)) {
              CLMicroLocationProto::TriggerEvent::MergeFrom();
            }
            *((_DWORD *)this + 21) |= 1u;
            *((_DWORD *)this + 6) = v9;
          }
          int v25 = (unsigned char *)*((void *)a2 + 1);
          if ((unint64_t)v25 < *((void *)a2 + 2) && *v25 == 17)
          {
            *((void *)a2 + 1) = v25 + 1;
            goto LABEL_56;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v43);
        if (result)
        {
          unsigned int v9 = v43[0];
          goto LABEL_42;
        }
        break;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_36;
        }
LABEL_56:
        *(void *)int v43 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v43) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v43;
        }
        *((_DWORD *)this + 21) |= 2u;
        int v26 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        if ((unint64_t)v26 >= v10 || *v26 != 24) {
          continue;
        }
        uint64_t v11 = v26 + 1;
        *((void *)a2 + 1) = v11;
LABEL_60:
        v43[0] = 0;
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v43);
          if (!result) {
            return result;
          }
          unsigned int v27 = v43[0];
          int v28 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v10 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v27 = *v11;
          int v28 = v11 + 1;
          *((void *)a2 + 1) = v28;
        }
        *((unsigned char *)this + 28) = v27 != 0;
        int v16 = *((_DWORD *)this + 21) | 4;
        *((_DWORD *)this + 21) = v16;
        if ((unint64_t)v28 >= v10 || *v28 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v28 + 1;
LABEL_68:
        *((_DWORD *)this + 21) = v16 | 8;
        if (*((void *)this + 2) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v29 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v29 >= *((void *)a2 + 2) || *v29 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v29 + 1;
LABEL_74:
        *((_DWORD *)this + 21) |= 0x10u;
        if (*((void *)this + 4) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        int v30 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v30 >= *((void *)a2 + 2) || *v30 != 50) {
          continue;
        }
        *((void *)a2 + 1) = v30 + 1;
LABEL_80:
        *((_DWORD *)this + 21) |= 0x20u;
        if (*((void *)this + 5) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
        if (!result) {
          return result;
        }
        BOOL v31 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v31 >= *((void *)a2 + 2) || *v31 != 58) {
          continue;
        }
        *((void *)a2 + 1) = v31 + 1;
LABEL_86:
        *((_DWORD *)this + 21) |= 0x40u;
        if (*((void *)this + 6) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v32 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v17 = *((void *)a2 + 2);
        if ((unint64_t)v32 >= v17 || *v32 != 64) {
          continue;
        }
        int v18 = v32 + 1;
        *((void *)a2 + 1) = v18;
LABEL_92:
        v43[0] = 0;
        if ((unint64_t)v18 >= v17 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v43);
          if (!result) {
            return result;
          }
          unsigned int v33 = v43[0];
          int v34 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v17 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v33 = *v18;
          int v34 = v18 + 1;
          *((void *)a2 + 1) = v34;
        }
        *((unsigned char *)this + 29) = v33 != 0;
        *((_DWORD *)this + 21) |= 0x80u;
        if ((unint64_t)v34 >= v17 || *v34 != 72) {
          continue;
        }
        uint64_t v19 = v34 + 1;
        *((void *)a2 + 1) = v19;
LABEL_100:
        v43[0] = 0;
        if ((unint64_t)v19 >= v17 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v43);
          if (!result) {
            return result;
          }
          unsigned int v35 = v43[0];
        }
        else
        {
          unsigned int v35 = *v19;
          *((void *)a2 + 1) = v19 + 1;
        }
        if (v35 <= 1)
        {
          *((_DWORD *)this + 21) |= 0x100u;
          *((_DWORD *)this + 14) = v35;
        }
        int v36 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        if ((unint64_t)v36 >= v12 || *v36 != 80) {
          continue;
        }
        int v13 = v36 + 1;
        *((void *)a2 + 1) = v13;
LABEL_110:
        v43[0] = 0;
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v43);
          if (!result) {
            return result;
          }
          unsigned int v37 = v43[0];
        }
        else
        {
          unsigned int v37 = *v13;
          *((void *)a2 + 1) = v13 + 1;
        }
        if (v37 <= 5)
        {
          *((_DWORD *)this + 21) |= 0x200u;
          *((_DWORD *)this + 15) = v37;
        }
        int v38 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v20 = *((void *)a2 + 2);
        if ((unint64_t)v38 >= v20 || *v38 != 88) {
          continue;
        }
        int v21 = v38 + 1;
        *((void *)a2 + 1) = v21;
LABEL_120:
        v43[0] = 0;
        if ((unint64_t)v21 >= v20 || *v21 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v43);
          if (!result) {
            return result;
          }
          unsigned int v39 = v43[0];
        }
        else
        {
          unsigned int v39 = *v21;
          *((void *)a2 + 1) = v21 + 1;
        }
        if (v39 <= 5)
        {
          *((_DWORD *)this + 21) |= 0x400u;
          *((_DWORD *)this + 18) = v39;
        }
        int v40 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v40 >= *((void *)a2 + 2) || *v40 != 98) {
          continue;
        }
        *((void *)a2 + 1) = v40 + 1;
LABEL_130:
        *((_DWORD *)this + 21) |= 0x800u;
        if (*((void *)this + 8) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v41 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        if ((unint64_t)v41 >= v14 || *v41 != 104) {
          continue;
        }
        uint64_t v15 = v41 + 1;
        *((void *)a2 + 1) = v15;
LABEL_136:
        v43[0] = 0;
        if ((unint64_t)v15 >= v14 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v43);
          if (!result) {
            return result;
          }
          unsigned int v42 = v43[0];
        }
        else
        {
          unsigned int v42 = *v15;
          *((void *)a2 + 1) = v15 + 1;
        }
        if (v42 <= 3)
        {
          *((_DWORD *)this + 21) |= 0x1000u;
          *((_DWORD *)this + 19) = v42;
        }
        if (*((void *)a2 + 1) != *((void *)a2 + 2)
          || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10))
        {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        uint64_t v11 = (char *)*((void *)a2 + 1);
        unint64_t v10 = *((void *)a2 + 2);
        goto LABEL_60;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_36;
        }
        int v16 = *((_DWORD *)this + 21);
        goto LABEL_68;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_74;
        }
        goto LABEL_36;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_80;
        }
        goto LABEL_36;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_86;
        }
        goto LABEL_36;
      case 8u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        int v18 = (char *)*((void *)a2 + 1);
        unint64_t v17 = *((void *)a2 + 2);
        goto LABEL_92;
      case 9u:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        uint64_t v19 = (char *)*((void *)a2 + 1);
        unint64_t v17 = *((void *)a2 + 2);
        goto LABEL_100;
      case 0xAu:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        int v13 = (char *)*((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 2);
        goto LABEL_110;
      case 0xBu:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        int v21 = (char *)*((void *)a2 + 1);
        unint64_t v20 = *((void *)a2 + 2);
        goto LABEL_120;
      case 0xCu:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_130;
        }
        goto LABEL_36;
      case 0xDu:
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_36;
        }
        uint64_t v15 = (char *)*((void *)a2 + 1);
        unint64_t v14 = *((void *)a2 + 2);
        goto LABEL_136;
      default:
        int v7 = TagFallback & 7;
LABEL_36:
        if (v7 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

uint64_t CLMicroLocationProto::TriggerEvent::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 84);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 24), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 84);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_17;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *(double *)(v5 + 8), a3);
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_18;
  }
LABEL_17:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3, *(unsigned __int8 *)(v5 + 28), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_19;
  }
LABEL_18:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x10) == 0)
  {
LABEL_6:
    if ((v6 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_20;
  }
LABEL_19:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x20) == 0)
  {
LABEL_7:
    if ((v6 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_21;
  }
LABEL_20:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x40) == 0)
  {
LABEL_8:
    if ((v6 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_22;
  }
LABEL_21:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x80) == 0)
  {
LABEL_9:
    if ((v6 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_23;
  }
LABEL_22:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)8, *(unsigned __int8 *)(v5 + 29), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x100) == 0)
  {
LABEL_10:
    if ((v6 & 0x200) == 0) {
      goto LABEL_11;
    }
    goto LABEL_24;
  }
LABEL_23:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)9, *(unsigned int *)(v5 + 56), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x200) == 0)
  {
LABEL_11:
    if ((v6 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_25;
  }
LABEL_24:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xA, *(unsigned int *)(v5 + 60), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x400) == 0)
  {
LABEL_12:
    if ((v6 & 0x800) == 0) {
      goto LABEL_13;
    }
LABEL_26:
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    if ((*(_DWORD *)(v5 + 84) & 0x1000) == 0) {
      return this;
    }
    goto LABEL_27;
  }
LABEL_25:
  this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xB, *(unsigned int *)(v5 + 72), (uint64_t)a2, a4);
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 0x800) != 0) {
    goto LABEL_26;
  }
LABEL_13:
  if ((v6 & 0x1000) == 0) {
    return this;
  }
LABEL_27:
  uint64_t v7 = *(unsigned int *)(v5 + 76);
  return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0xD, v7, (uint64_t)a2, a4);
}

uint64_t CLMicroLocationProto::TriggerEvent::ByteSize(CLMicroLocationProto::TriggerEvent *this)
{
  int v2 = *((_DWORD *)this + 21);
  if (!(_BYTE)v2)
  {
    uint64_t v4 = 0;
    goto LABEL_60;
  }
  if (v2)
  {
    uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
    if ((v5 & 0x80000000) != 0)
    {
      int v6 = 10;
    }
    else if (v5 >= 0x80)
    {
      int v6 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5);
      int v2 = *((_DWORD *)this + 21);
    }
    else
    {
      int v6 = 1;
    }
    int v3 = v6 + 1;
  }
  else
  {
    int v3 = 0;
  }
  if ((v2 & 2) != 0) {
    v3 += 9;
  }
  if ((v2 & 4) != 0) {
    LODWORD(v4) = v3 + 2;
  }
  else {
    LODWORD(v4) = v3;
  }
  if ((v2 & 8) != 0)
  {
    uint64_t v7 = *((void *)this + 2);
    int v8 = *(unsigned __int8 *)(v7 + 23);
    char v9 = v8;
    uint64_t v10 = *(void *)(v7 + 8);
    if ((v8 & 0x80u) == 0) {
      unint64_t v11 = *(unsigned __int8 *)(v7 + 23);
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11 >= 0x80)
    {
      int v12 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v11);
      int v8 = *(unsigned __int8 *)(v7 + 23);
      uint64_t v10 = *(void *)(v7 + 8);
      int v2 = *((_DWORD *)this + 21);
      char v9 = *(unsigned char *)(v7 + 23);
    }
    else
    {
      int v12 = 1;
    }
    if (v9 < 0) {
      int v8 = v10;
    }
    LODWORD(v4) = v4 + v12 + v8 + 1;
    if ((v2 & 0x10) == 0)
    {
LABEL_18:
      if ((v2 & 0x20) == 0) {
        goto LABEL_19;
      }
LABEL_39:
      uint64_t v19 = *((void *)this + 5);
      int v20 = *(unsigned __int8 *)(v19 + 23);
      char v21 = v20;
      uint64_t v22 = *(void *)(v19 + 8);
      if ((v20 & 0x80u) == 0) {
        unint64_t v23 = *(unsigned __int8 *)(v19 + 23);
      }
      else {
        unint64_t v23 = v22;
      }
      if (v23 >= 0x80)
      {
        int v24 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v23);
        int v20 = *(unsigned __int8 *)(v19 + 23);
        uint64_t v22 = *(void *)(v19 + 8);
        int v2 = *((_DWORD *)this + 21);
        char v21 = *(unsigned char *)(v19 + 23);
      }
      else
      {
        int v24 = 1;
      }
      if (v21 < 0) {
        int v20 = v22;
      }
      LODWORD(v4) = v4 + v24 + v20 + 1;
      if ((v2 & 0x40) == 0) {
        goto LABEL_57;
      }
      goto LABEL_48;
    }
  }
  else if ((v2 & 0x10) == 0)
  {
    goto LABEL_18;
  }
  uint64_t v13 = *((void *)this + 4);
  int v14 = *(unsigned __int8 *)(v13 + 23);
  char v15 = v14;
  uint64_t v16 = *(void *)(v13 + 8);
  if ((v14 & 0x80u) == 0) {
    unint64_t v17 = *(unsigned __int8 *)(v13 + 23);
  }
  else {
    unint64_t v17 = v16;
  }
  if (v17 >= 0x80)
  {
    int v18 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v17);
    int v14 = *(unsigned __int8 *)(v13 + 23);
    uint64_t v16 = *(void *)(v13 + 8);
    int v2 = *((_DWORD *)this + 21);
    char v15 = *(unsigned char *)(v13 + 23);
  }
  else
  {
    int v18 = 1;
  }
  if (v15 < 0) {
    int v14 = v16;
  }
  LODWORD(v4) = v4 + v18 + v14 + 1;
  if ((v2 & 0x20) != 0) {
    goto LABEL_39;
  }
LABEL_19:
  if ((v2 & 0x40) != 0)
  {
LABEL_48:
    uint64_t v25 = *((void *)this + 6);
    int v26 = *(unsigned __int8 *)(v25 + 23);
    char v27 = v26;
    uint64_t v28 = *(void *)(v25 + 8);
    if ((v26 & 0x80u) == 0) {
      unint64_t v29 = *(unsigned __int8 *)(v25 + 23);
    }
    else {
      unint64_t v29 = v28;
    }
    if (v29 >= 0x80)
    {
      int v30 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v29);
      int v26 = *(unsigned __int8 *)(v25 + 23);
      uint64_t v28 = *(void *)(v25 + 8);
      int v2 = *((_DWORD *)this + 21);
      char v27 = *(unsigned char *)(v25 + 23);
    }
    else
    {
      int v30 = 1;
    }
    if (v27 < 0) {
      int v26 = v28;
    }
    LODWORD(v4) = v4 + v30 + v26 + 1;
  }
LABEL_57:
  if ((v2 & 0x80) != 0) {
    uint64_t v4 = (v4 + 2);
  }
  else {
    uint64_t v4 = v4;
  }
LABEL_60:
  if ((v2 & 0xFF00) == 0) {
    goto LABEL_100;
  }
  if ((v2 & 0x100) != 0)
  {
    BOOL v31 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 14);
    if ((v31 & 0x80000000) != 0)
    {
      int v32 = 11;
    }
    else if (v31 >= 0x80)
    {
      int v32 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v31) + 1;
      int v2 = *((_DWORD *)this + 21);
    }
    else
    {
      int v32 = 2;
    }
    uint64_t v4 = (v32 + v4);
    if ((v2 & 0x200) == 0)
    {
LABEL_63:
      if ((v2 & 0x400) == 0) {
        goto LABEL_64;
      }
      goto LABEL_79;
    }
  }
  else if ((v2 & 0x200) == 0)
  {
    goto LABEL_63;
  }
  unsigned int v33 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 15);
  if ((v33 & 0x80000000) != 0)
  {
    int v34 = 11;
  }
  else if (v33 >= 0x80)
  {
    int v34 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v33) + 1;
    int v2 = *((_DWORD *)this + 21);
  }
  else
  {
    int v34 = 2;
  }
  uint64_t v4 = (v34 + v4);
  if ((v2 & 0x400) == 0)
  {
LABEL_64:
    if ((v2 & 0x800) == 0) {
      goto LABEL_65;
    }
    goto LABEL_85;
  }
LABEL_79:
  unsigned int v35 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 18);
  if ((v35 & 0x80000000) != 0)
  {
    int v36 = 11;
  }
  else if (v35 >= 0x80)
  {
    int v36 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v35) + 1;
    int v2 = *((_DWORD *)this + 21);
  }
  else
  {
    int v36 = 2;
  }
  uint64_t v4 = (v36 + v4);
  if ((v2 & 0x800) == 0)
  {
LABEL_65:
    if ((v2 & 0x1000) == 0) {
      goto LABEL_100;
    }
    goto LABEL_94;
  }
LABEL_85:
  uint64_t v37 = *((void *)this + 8);
  int v38 = *(unsigned __int8 *)(v37 + 23);
  char v39 = v38;
  uint64_t v40 = *(void *)(v37 + 8);
  if ((v38 & 0x80u) == 0) {
    unint64_t v41 = *(unsigned __int8 *)(v37 + 23);
  }
  else {
    unint64_t v41 = v40;
  }
  if (v41 >= 0x80)
  {
    int v42 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v41);
    int v38 = *(unsigned __int8 *)(v37 + 23);
    uint64_t v40 = *(void *)(v37 + 8);
    int v2 = *((_DWORD *)this + 21);
    char v39 = *(unsigned char *)(v37 + 23);
  }
  else
  {
    int v42 = 1;
  }
  if (v39 < 0) {
    int v38 = v40;
  }
  uint64_t v4 = (v4 + v42 + v38 + 1);
  if ((v2 & 0x1000) != 0)
  {
LABEL_94:
    int v43 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 19);
    if ((v43 & 0x80000000) != 0)
    {
      int v44 = 11;
    }
    else if (v43 >= 0x80)
    {
      int v44 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v43) + 1;
    }
    else
    {
      int v44 = 2;
    }
    uint64_t v4 = (v44 + v4);
  }
LABEL_100:
  *((_DWORD *)this + 20) = v4;
  return v4;
}

void CLMicroLocationProto::TriggerEvent::CheckTypeAndMergeFrom(CLMicroLocationProto::TriggerEvent *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::TriggerEvent::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::TriggerEvent::CopyFrom(CLMicroLocationProto::TriggerEvent *this, const CLMicroLocationProto::TriggerEvent *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::TriggerEvent *))(*(void *)this + 32))(this);
    CLMicroLocationProto::TriggerEvent::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::TriggerEvent::IsInitialized(CLMicroLocationProto::TriggerEvent *this)
{
  return 1;
}

void *CLMicroLocationProto::TriggerEvent::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.TriggerEvent");
}

CLMicroLocationProto::LegacyClientStatusUpdate *CLMicroLocationProto::LegacyClientStatusUpdate::LegacyClientStatusUpdate(CLMicroLocationProto::LegacyClientStatusUpdate *this, const CLMicroLocationProto::LegacyClientStatusUpdate *a2)
{
  *(void *)this = &unk_2704DF6B8;
  *(_OWORD *)((char *)this + 8) = xmmword_2565192A0;
  *((_DWORD *)this + 6) = 0;
  CLMicroLocationProto::LegacyClientStatusUpdate::MergeFrom(this, a2);
  return this;
}

void sub_256433BF0(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::LegacyClientStatusUpdate::New(CLMicroLocationProto::LegacyClientStatusUpdate *this)
{
}

uint64_t CLMicroLocationProto::LegacyClientStatusUpdate::MergePartialFromCodedStream(CLMicroLocationProto::LegacyClientStatusUpdate *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (unsigned int *)((char *)this + 16);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v23 = 0;
        unint64_t v11 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v11 >= *((void *)a2 + 2) || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v23);
          if (!result) {
            return result;
          }
          unsigned int v12 = v23;
        }
        else
        {
          unsigned int v12 = *v11;
          *((void *)a2 + 1) = v11 + 1;
        }
        if (v12 - 31 < 0x19 || (v12 <= 0xE ? (BOOL v15 = ((1 << v12) & 0x76B6) == 0) : (BOOL v15 = 1), !v15))
        {
          if (v12 - 31 >= 0x19 && (v12 > 0xE || ((1 << v12) & 0x76B6) == 0)) {
            CLMicroLocationProto::LegacyClientStatusUpdate::MergeFrom();
          }
          *((_DWORD *)this + 6) |= 1u;
          *((_DWORD *)this + 2) = v12;
        }
        unint64_t v17 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v13 = *((void *)a2 + 2);
        if ((unint64_t)v17 < v13 && *v17 == 16)
        {
          int v14 = v17 + 1;
          *((void *)a2 + 1) = v14;
          goto LABEL_38;
        }
      }
      if (v7 != 2) {
        break;
      }
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_19;
      }
      int v14 = (char *)*((void *)a2 + 1);
      unint64_t v13 = *((void *)a2 + 2);
LABEL_38:
      unsigned int v22 = 0;
      if ((unint64_t)v14 >= v13 || *v14 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v22);
        if (!result) {
          return result;
        }
        unsigned int v18 = v22;
      }
      else
      {
        unsigned int v18 = *v14;
        *((void *)a2 + 1) = v14 + 1;
      }
      if (v18 - 1 < 2 || v18 == 255)
      {
        *((_DWORD *)this + 6) |= 2u;
        *((_DWORD *)this + 3) = v18;
      }
      uint64_t v19 = (unsigned char *)*((void *)a2 + 1);
      unint64_t v9 = *((void *)a2 + 2);
      if ((unint64_t)v19 < v9 && *v19 == 24)
      {
        uint64_t v10 = v19 + 1;
        *((void *)a2 + 1) = v10;
LABEL_49:
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v4);
          if (!result) {
            return result;
          }
          int v20 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          *uint64_t v4 = *v10;
          int v20 = (unsigned __int8 *)(v10 + 1);
          *((void *)a2 + 1) = v20;
        }
        *((_DWORD *)this + 6) |= 4u;
        if (v20 == (unsigned __int8 *)v9 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (v7 == 3)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        uint64_t v10 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_49;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_19:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

void CLMicroLocationProto::LegacyClientStatusUpdate::CheckTypeAndMergeFrom(CLMicroLocationProto::LegacyClientStatusUpdate *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::LegacyClientStatusUpdate::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::LegacyClientStatusUpdate::CopyFrom(CLMicroLocationProto::LegacyClientStatusUpdate *this, const CLMicroLocationProto::LegacyClientStatusUpdate *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::LegacyClientStatusUpdate *))(*(void *)this + 32))(this);
    CLMicroLocationProto::LegacyClientStatusUpdate::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::LegacyClientStatusUpdate::IsInitialized(CLMicroLocationProto::LegacyClientStatusUpdate *this)
{
  return 1;
}

void *CLMicroLocationProto::LegacyClientStatusUpdate::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.LegacyClientStatusUpdate");
}

void CLMicroLocationProto::SpectatingMotionUpdate::~SpectatingMotionUpdate(CLMicroLocationProto::SpectatingMotionUpdate *this)
{
  *(void *)this = &unk_2704DF730;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::SpectatingMotionUpdate::~SpectatingMotionUpdate(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::SpectatingMotionUpdate::New(CLMicroLocationProto::SpectatingMotionUpdate *this)
{
}

uint64_t CLMicroLocationProto::SpectatingMotionUpdate::MergePartialFromCodedStream(CLMicroLocationProto::SpectatingMotionUpdate *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      uint64_t v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v6 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_15;
      }
      unsigned int v17 = 0;
      unint64_t v9 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v17);
        if (!result) {
          return result;
        }
        unsigned int v10 = v17;
      }
      else
      {
        unsigned int v10 = *v9;
        *((void *)a2 + 1) = v9 + 1;
      }
      if (v10 - 31 < 0x19 || (v10 <= 0xE ? (BOOL v11 = ((1 << v10) & 0x76B6) == 0) : (BOOL v11 = 1), !v11))
      {
        if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0)) {
          CLMicroLocationProto::SpectatingMotionUpdate::MergeFrom();
        }
        *((_DWORD *)this + 5) |= 1u;
        *((_DWORD *)this + 2) = v10;
      }
      unint64_t v13 = (unsigned char *)*((void *)a2 + 1);
      unint64_t v7 = *((void *)a2 + 2);
      if ((unint64_t)v13 < v7 && *v13 == 16)
      {
        int v8 = v13 + 1;
        *((void *)a2 + 1) = v8;
LABEL_34:
        unsigned int v18 = 0;
        if ((unint64_t)v8 >= v7 || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v18);
          if (!result) {
            return result;
          }
          unsigned int v14 = v18;
          BOOL v15 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v7 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v14 = *v8;
          BOOL v15 = (unsigned __int8 *)(v8 + 1);
          *((void *)a2 + 1) = v15;
        }
        *((unsigned char *)this + 12) = v14 != 0;
        *((_DWORD *)this + 5) |= 2u;
        if (v15 == (unsigned __int8 *)v7 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v6 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        int v8 = (char *)*((void *)a2 + 1);
        unint64_t v7 = *((void *)a2 + 2);
        goto LABEL_34;
      }
    }
    else
    {
      int v6 = TagFallback & 7;
    }
LABEL_15:
    if (v6 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::SpectatingMotionUpdate::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 20);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 20);
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v7 = *(unsigned __int8 *)(v5 + 12);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::SpectatingMotionUpdate::ByteSize(CLMicroLocationProto::SpectatingMotionUpdate *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 20);
  if ((_BYTE)v2)
  {
    if (*((unsigned char *)this + 20))
    {
      uint64_t v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
      if ((v5 & 0x80000000) != 0)
      {
        unsigned int v3 = 11;
      }
      else if (v5 >= 0x80)
      {
        unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
        int v2 = *((_DWORD *)this + 5);
      }
      else
      {
        unsigned int v3 = 2;
      }
    }
    else
    {
      unsigned int v3 = 0;
    }
    if ((v2 & 2) != 0) {
      uint64_t result = v3 + 2;
    }
    else {
      uint64_t result = v3;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 4) = result;
  return result;
}

void CLMicroLocationProto::SpectatingMotionUpdate::CheckTypeAndMergeFrom(CLMicroLocationProto::SpectatingMotionUpdate *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::SpectatingMotionUpdate::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::SpectatingMotionUpdate::CopyFrom(CLMicroLocationProto::SpectatingMotionUpdate *this, const CLMicroLocationProto::SpectatingMotionUpdate *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::SpectatingMotionUpdate *))(*(void *)this + 32))(this);
    CLMicroLocationProto::SpectatingMotionUpdate::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::SpectatingMotionUpdate::IsInitialized(CLMicroLocationProto::SpectatingMotionUpdate *this)
{
  return 1;
}

void *CLMicroLocationProto::SpectatingMotionUpdate::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.SpectatingMotionUpdate");
}

void CLMicroLocationProto::EnabledStateUpdate::New(CLMicroLocationProto::EnabledStateUpdate *this)
{
}

uint64_t CLMicroLocationProto::EnabledStateUpdate::MergePartialFromCodedStream(CLMicroLocationProto::EnabledStateUpdate *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (2)
  {
    uint64_t v4 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
    {
      TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
      *((_DWORD *)a2 + 8) = TagFallback;
      if (!TagFallback) {
        return 1;
      }
    }
    else
    {
      TagFallbacuint64_t k = *v4;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v4 + 1;
      if (!TagFallback) {
        return 1;
      }
    }
    switch(TagFallback >> 3)
    {
      case 1u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        unsigned int v38 = 0;
        uint64_t v7 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v7 < *((void *)a2 + 2) && (*v7 & 0x80000000) == 0)
        {
          unsigned int v8 = *v7;
          *((void *)a2 + 1) = v7 + 1;
LABEL_33:
          if (v8 - 31 < 0x19 || (v8 <= 0xE ? (BOOL v18 = ((1 << v8) & 0x76B6) == 0) : (BOOL v18 = 1), !v18))
          {
            if (v8 - 31 >= 0x19 && (v8 > 0xE || ((1 << v8) & 0x76B6) == 0)) {
              CLMicroLocationProto::EnabledStateUpdate::MergeFrom();
            }
            *((_DWORD *)this + 6) |= 1u;
            *((_DWORD *)this + 2) = v8;
          }
          int v20 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
          if ((unint64_t)v20 < v9 && *v20 == 16)
          {
            unsigned int v12 = v20 + 1;
            *((void *)a2 + 1) = v12;
            goto LABEL_47;
          }
          continue;
        }
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
        if (result)
        {
          unsigned int v8 = v38;
          goto LABEL_33;
        }
        break;
      case 2u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        unsigned int v12 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
LABEL_47:
        unsigned int v38 = 0;
        if ((unint64_t)v12 >= v9 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
          if (!result) {
            return result;
          }
          unsigned int v21 = v38;
          unsigned int v22 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v21 = *v12;
          unsigned int v22 = v12 + 1;
          *((void *)a2 + 1) = v22;
        }
        *((unsigned char *)this + 12) = v21 != 0;
        *((_DWORD *)this + 6) |= 2u;
        if ((unint64_t)v22 >= v9 || *v22 != 24) {
          continue;
        }
        unsigned int v10 = v22 + 1;
        *((void *)a2 + 1) = v10;
LABEL_55:
        unsigned int v38 = 0;
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
          if (!result) {
            return result;
          }
          unsigned int v23 = v38;
          int v24 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v23 = *v10;
          int v24 = v10 + 1;
          *((void *)a2 + 1) = v24;
        }
        *((unsigned char *)this + 13) = v23 != 0;
        *((_DWORD *)this + 6) |= 4u;
        if ((unint64_t)v24 >= v9 || *v24 != 32) {
          continue;
        }
        unint64_t v13 = v24 + 1;
        *((void *)a2 + 1) = v13;
LABEL_63:
        unsigned int v38 = 0;
        if ((unint64_t)v13 >= v9 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
          if (!result) {
            return result;
          }
          unsigned int v25 = v38;
          int v26 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v25 = *v13;
          int v26 = v13 + 1;
          *((void *)a2 + 1) = v26;
        }
        *((unsigned char *)this + 14) = v25 != 0;
        *((_DWORD *)this + 6) |= 8u;
        if ((unint64_t)v26 >= v9 || *v26 != 40) {
          continue;
        }
        BOOL v11 = v26 + 1;
        *((void *)a2 + 1) = v11;
LABEL_71:
        unsigned int v38 = 0;
        if ((unint64_t)v11 >= v9 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
          if (!result) {
            return result;
          }
          unsigned int v27 = v38;
          uint64_t v28 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v27 = *v11;
          uint64_t v28 = v11 + 1;
          *((void *)a2 + 1) = v28;
        }
        *((unsigned char *)this + 15) = v27 != 0;
        *((_DWORD *)this + 6) |= 0x10u;
        if ((unint64_t)v28 >= v9 || *v28 != 48) {
          continue;
        }
        unsigned int v14 = v28 + 1;
        *((void *)a2 + 1) = v14;
LABEL_79:
        unsigned int v38 = 0;
        if ((unint64_t)v14 >= v9 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
          if (!result) {
            return result;
          }
          unsigned int v29 = v38;
          int v30 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v29 = *v14;
          int v30 = v14 + 1;
          *((void *)a2 + 1) = v30;
        }
        *((unsigned char *)this + 16) = v29 != 0;
        *((_DWORD *)this + 6) |= 0x20u;
        if ((unint64_t)v30 >= v9 || *v30 != 56) {
          continue;
        }
        uint64_t v16 = v30 + 1;
        *((void *)a2 + 1) = v16;
LABEL_87:
        unsigned int v38 = 0;
        if ((unint64_t)v16 >= v9 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
          if (!result) {
            return result;
          }
          unsigned int v31 = v38;
          int v32 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v31 = *v16;
          int v32 = v16 + 1;
          *((void *)a2 + 1) = v32;
        }
        *((unsigned char *)this + 17) = v31 != 0;
        *((_DWORD *)this + 6) |= 0x40u;
        if ((unint64_t)v32 >= v9 || *v32 != 64) {
          continue;
        }
        BOOL v15 = v32 + 1;
        *((void *)a2 + 1) = v15;
LABEL_95:
        unsigned int v38 = 0;
        if ((unint64_t)v15 >= v9 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
          if (!result) {
            return result;
          }
          unsigned int v33 = v38;
          int v34 = (unsigned char *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v33 = *v15;
          int v34 = v15 + 1;
          *((void *)a2 + 1) = v34;
        }
        *((unsigned char *)this + 18) = v33 != 0;
        *((_DWORD *)this + 6) |= 0x80u;
        if ((unint64_t)v34 >= v9 || *v34 != 72) {
          continue;
        }
        unsigned int v17 = v34 + 1;
        *((void *)a2 + 1) = v17;
LABEL_103:
        unsigned int v38 = 0;
        if ((unint64_t)v17 >= v9 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v38);
          if (!result) {
            return result;
          }
          unsigned int v35 = v38;
          int v36 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v35 = *v17;
          int v36 = (unsigned __int8 *)(v17 + 1);
          *((void *)a2 + 1) = v36;
        }
        *((unsigned char *)this + 19) = v35 != 0;
        *((_DWORD *)this + 6) |= 0x100u;
        if (v36 != (unsigned __int8 *)v9 || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10)) {
          continue;
        }
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      case 3u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        unsigned int v10 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_55;
      case 4u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        unint64_t v13 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_63;
      case 5u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        BOOL v11 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_71;
      case 6u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        unsigned int v14 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_79;
      case 7u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        uint64_t v16 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_87;
      case 8u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        BOOL v15 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_95;
      case 9u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_28;
        }
        unsigned int v17 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_103;
      default:
        int v6 = TagFallback & 7;
LABEL_28:
        if (v6 == 4) {
          return 1;
        }
        if (wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback))continue; {
        return 0;
        }
    }
    return result;
  }
}

void CLMicroLocationProto::EnabledStateUpdate::CheckTypeAndMergeFrom(CLMicroLocationProto::EnabledStateUpdate *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::EnabledStateUpdate::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::EnabledStateUpdate::CopyFrom(CLMicroLocationProto::EnabledStateUpdate *this, const CLMicroLocationProto::EnabledStateUpdate *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::EnabledStateUpdate *))(*(void *)this + 32))(this);
    CLMicroLocationProto::EnabledStateUpdate::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::EnabledStateUpdate::IsInitialized(CLMicroLocationProto::EnabledStateUpdate *this)
{
  return 1;
}

void *CLMicroLocationProto::EnabledStateUpdate::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.EnabledStateUpdate");
}

void CLMicroLocationProto::ScreenStateUpdate::New(CLMicroLocationProto::ScreenStateUpdate *this)
{
}

uint64_t CLMicroLocationProto::ScreenStateUpdate::MergePartialFromCodedStream(CLMicroLocationProto::ScreenStateUpdate *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      uint64_t v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v6 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_15;
      }
      unsigned int v17 = 0;
      unint64_t v9 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v17);
        if (!result) {
          return result;
        }
        unsigned int v10 = v17;
      }
      else
      {
        unsigned int v10 = *v9;
        *((void *)a2 + 1) = v9 + 1;
      }
      if (v10 - 31 < 0x19 || (v10 <= 0xE ? (BOOL v11 = ((1 << v10) & 0x76B6) == 0) : (BOOL v11 = 1), !v11))
      {
        if (v10 - 31 >= 0x19 && (v10 > 0xE || ((1 << v10) & 0x76B6) == 0)) {
          CLMicroLocationProto::ScreenStateUpdate::MergeFrom();
        }
        *((_DWORD *)this + 5) |= 1u;
        *((_DWORD *)this + 2) = v10;
      }
      unint64_t v13 = (unsigned char *)*((void *)a2 + 1);
      unint64_t v7 = *((void *)a2 + 2);
      if ((unint64_t)v13 < v7 && *v13 == 16)
      {
        unsigned int v8 = v13 + 1;
        *((void *)a2 + 1) = v8;
LABEL_34:
        unsigned int v18 = 0;
        if ((unint64_t)v8 >= v7 || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v18);
          if (!result) {
            return result;
          }
          unsigned int v14 = v18;
          BOOL v15 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v7 = *((void *)a2 + 2);
        }
        else
        {
          unsigned int v14 = *v8;
          BOOL v15 = (unsigned __int8 *)(v8 + 1);
          *((void *)a2 + 1) = v15;
        }
        *((unsigned char *)this + 12) = v14 != 0;
        *((_DWORD *)this + 5) |= 2u;
        if (v15 == (unsigned __int8 *)v7 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v6 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v8 = (char *)*((void *)a2 + 1);
        unint64_t v7 = *((void *)a2 + 2);
        goto LABEL_34;
      }
    }
    else
    {
      int v6 = TagFallback & 7;
    }
LABEL_15:
    if (v6 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

void CLMicroLocationProto::ScreenStateUpdate::CheckTypeAndMergeFrom(CLMicroLocationProto::ScreenStateUpdate *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ScreenStateUpdate::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::ScreenStateUpdate::CopyFrom(CLMicroLocationProto::ScreenStateUpdate *this, const CLMicroLocationProto::ScreenStateUpdate *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::ScreenStateUpdate *))(*(void *)this + 32))(this);
    CLMicroLocationProto::ScreenStateUpdate::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::ScreenStateUpdate::IsInitialized(CLMicroLocationProto::ScreenStateUpdate *this)
{
  return 1;
}

void *CLMicroLocationProto::ScreenStateUpdate::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ScreenStateUpdate");
}

void CLMicroLocationProto::CloudBackupExport::~CloudBackupExport(CLMicroLocationProto::CloudBackupExport *this)
{
  *(void *)this = &unk_2704DF898;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::CloudBackupExport::~CloudBackupExport(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::CloudBackupExport::New(CLMicroLocationProto::CloudBackupExport *this)
{
}

uint64_t CLMicroLocationProto::CloudBackupExport::MergePartialFromCodedStream(CLMicroLocationProto::CloudBackupExport *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      uint64_t v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      int v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::CloudBackupExport::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::CloudBackupExport::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::CloudBackupExport::ByteSize(CLMicroLocationProto::CloudBackupExport *this)
{
  if (*((unsigned char *)this + 16))
  {
    unsigned int v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::CloudBackupExport::CheckTypeAndMergeFrom(CLMicroLocationProto::CloudBackupExport *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::CloudBackupExport::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::CloudBackupExport::CopyFrom(CLMicroLocationProto::CloudBackupExport *this, const CLMicroLocationProto::CloudBackupExport *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::CloudBackupExport *))(*(void *)this + 32))(this);
    CLMicroLocationProto::CloudBackupExport::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::CloudBackupExport::IsInitialized(CLMicroLocationProto::CloudBackupExport *this)
{
  return 1;
}

void *CLMicroLocationProto::CloudBackupExport::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.CloudBackupExport");
}

void CLMicroLocationProto::CloudBackupImport::~CloudBackupImport(CLMicroLocationProto::CloudBackupImport *this)
{
  *(void *)this = &unk_2704DF910;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::CloudBackupImport::~CloudBackupImport(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::CloudBackupImport::New(CLMicroLocationProto::CloudBackupImport *this)
{
}

uint64_t CLMicroLocationProto::CloudBackupImport::MergePartialFromCodedStream(CLMicroLocationProto::CloudBackupImport *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      uint64_t v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      int v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::CloudBackupImport::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::CloudBackupImport::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::CloudBackupImport::ByteSize(CLMicroLocationProto::CloudBackupImport *this)
{
  if (*((unsigned char *)this + 16))
  {
    unsigned int v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::CloudBackupImport::CheckTypeAndMergeFrom(CLMicroLocationProto::CloudBackupImport *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::CloudBackupImport::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::CloudBackupImport::CopyFrom(CLMicroLocationProto::CloudBackupImport *this, const CLMicroLocationProto::CloudBackupImport *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::CloudBackupImport *))(*(void *)this + 32))(this);
    CLMicroLocationProto::CloudBackupImport::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::CloudBackupImport::IsInitialized(CLMicroLocationProto::CloudBackupImport *this)
{
  return 1;
}

void *CLMicroLocationProto::CloudBackupImport::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.CloudBackupImport");
}

void CLMicroLocationProto::DataMigration::~DataMigration(CLMicroLocationProto::DataMigration *this)
{
  *(void *)this = &unk_2704DF988;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::DataMigration::~DataMigration(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::DataMigration::New(CLMicroLocationProto::DataMigration *this)
{
}

uint64_t CLMicroLocationProto::DataMigration::MergePartialFromCodedStream(CLMicroLocationProto::DataMigration *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      uint64_t v4 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
      }
      else
      {
        TagFallbacuint64_t k = *v4;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v4 + 1;
      }
      if (TagFallback != 8) {
        break;
      }
      unsigned int v11 = 0;
      int v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v11);
        if (!result) {
          return result;
        }
        unsigned int v7 = v11;
      }
      else
      {
        unsigned int v7 = *v6;
        *((void *)a2 + 1) = v6 + 1;
      }
      if (v7 - 31 < 0x19 || (v7 <= 0xE ? (BOOL v8 = ((1 << v7) & 0x76B6) == 0) : (BOOL v8 = 1), !v8))
      {
        if (v7 - 31 >= 0x19 && (v7 > 0xE || ((1 << v7) & 0x76B6) == 0)) {
          CLMicroLocationProto::DataMigration::MergeFrom();
        }
        *((_DWORD *)this + 4) |= 1u;
        *((_DWORD *)this + 2) = v7;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    if (!TagFallback || (TagFallback & 7) == 4) {
      break;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
  return 1;
}

uint64_t CLMicroLocationProto::DataMigration::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  if (*(unsigned char *)(this + 16)) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 8), (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::DataMigration::ByteSize(CLMicroLocationProto::DataMigration *this)
{
  if (*((unsigned char *)this + 16))
  {
    unsigned int v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 2);
    if ((v3 & 0x80000000) != 0)
    {
      uint64_t result = 11;
    }
    else if (v3 >= 0x80)
    {
      uint64_t result = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      uint64_t result = 2;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *((_DWORD *)this + 3) = result;
  return result;
}

void CLMicroLocationProto::DataMigration::CheckTypeAndMergeFrom(CLMicroLocationProto::DataMigration *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::DataMigration::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::DataMigration::CopyFrom(CLMicroLocationProto::DataMigration *this, const CLMicroLocationProto::DataMigration *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::DataMigration *))(*(void *)this + 32))(this);
    CLMicroLocationProto::DataMigration::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::DataMigration::IsInitialized(CLMicroLocationProto::DataMigration *this)
{
  return 1;
}

void *CLMicroLocationProto::DataMigration::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.DataMigration");
}

CLMicroLocationProto::ChannelAndCount *CLMicroLocationProto::ChannelAndCount::ChannelAndCount(CLMicroLocationProto::ChannelAndCount *this, const CLMicroLocationProto::ChannelAndCount *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_2704DFA00;
  *((_DWORD *)this + 6) = 0;
  CLMicroLocationProto::ChannelAndCount::MergeFrom(this, a2);
  return this;
}

void sub_256435B40(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ChannelAndCount::MergeFrom(CLMicroLocationProto::ChannelAndCount *this, const CLMicroLocationProto::ChannelAndCount *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v7);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 24))
    {
      int v5 = *((_DWORD *)a2 + 4);
      *((_DWORD *)this + 6) |= 1u;
      *((_DWORD *)this + 4) = v5;
      int v4 = *((_DWORD *)a2 + 6);
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v6 = *((void *)a2 + 1);
      *((_DWORD *)this + 6) |= 2u;
      *((void *)this + 1) = v6;
    }
  }
}

void sub_256435C00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ChannelAndCount::~ChannelAndCount(CLMicroLocationProto::ChannelAndCount *this)
{
  *(void *)this = &unk_2704DFA00;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::ChannelAndCount::~ChannelAndCount(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::ChannelAndCount::New(CLMicroLocationProto::ChannelAndCount *this)
{
}

uint64_t CLMicroLocationProto::ChannelAndCount::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 24))
  {
    *(_DWORD *)(this + 16) = 0;
    *(void *)(this + 8) = 0;
  }
  *(_DWORD *)(this + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::ChannelAndCount::MergePartialFromCodedStream(CLMicroLocationProto::ChannelAndCount *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  int v4 = (unsigned int *)((char *)this + 16);
  int v5 = (unint64_t *)((char *)this + 8);
  while (1)
  {
    while (1)
    {
      uint64_t v6 = (char *)*((void *)a2 + 1);
      if ((unint64_t)v6 >= *((void *)a2 + 2) || *v6 < 0)
      {
        TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
        *((_DWORD *)a2 + 8) = TagFallback;
        if (!TagFallback) {
          return 1;
        }
      }
      else
      {
        TagFallbacuint64_t k = *v6;
        *((_DWORD *)a2 + 8) = TagFallback;
        *((void *)a2 + 1) = v6 + 1;
        if (!TagFallback) {
          return 1;
        }
      }
      if (TagFallback >> 3 != 1) {
        break;
      }
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) != 0) {
        goto LABEL_16;
      }
      unsigned int v11 = (char *)*((void *)a2 + 1);
      unint64_t v9 = *((void *)a2 + 2);
      if ((unint64_t)v11 >= v9 || *v11 < 0)
      {
        uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v4);
        if (!result) {
          return result;
        }
        unsigned int v12 = (unsigned char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
      }
      else
      {
        *int v4 = *v11;
        unsigned int v12 = v11 + 1;
        *((void *)a2 + 1) = v12;
      }
      *((_DWORD *)this + 6) |= 1u;
      if ((unint64_t)v12 < v9 && *v12 == 16)
      {
        unsigned int v10 = v12 + 1;
        *((void *)a2 + 1) = v10;
LABEL_24:
        if ((unint64_t)v10 >= v9 || *v10 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint64Fallback(a2, v5);
          if (!result) {
            return result;
          }
          unint64_t v13 = (unsigned __int8 *)*((void *)a2 + 1);
          unint64_t v9 = *((void *)a2 + 2);
        }
        else
        {
          unint64_t *v5 = *v10;
          unint64_t v13 = (unsigned __int8 *)(v10 + 1);
          *((void *)a2 + 1) = v13;
        }
        *((_DWORD *)this + 6) |= 2u;
        if (v13 == (unsigned __int8 *)v9 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
      }
    }
    if (TagFallback >> 3 == 2)
    {
      int v8 = TagFallback & 7;
      if ((TagFallback & 7) == 0)
      {
        unsigned int v10 = (char *)*((void *)a2 + 1);
        unint64_t v9 = *((void *)a2 + 2);
        goto LABEL_24;
      }
    }
    else
    {
      int v8 = TagFallback & 7;
    }
LABEL_16:
    if (v8 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::ChannelAndCount::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  int v6 = *(_DWORD *)(this + 24);
  if (v6)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt32((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 16), (uint64_t)a2, a4);
    int v6 = *(_DWORD *)(v5 + 24);
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v7 = *(void *)(v5 + 8);
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteUInt64((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, (uint64_t)a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::ChannelAndCount::ByteSize(CLMicroLocationProto::ChannelAndCount *this)
{
  char v2 = *((unsigned char *)this + 24);
  if (v2)
  {
    if ((*((unsigned char *)this + 24) & 1) == 0)
    {
      uint64_t v3 = 0;
      if ((*((unsigned char *)this + 24) & 2) == 0) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
    if (v4 < 0x80)
    {
      uint64_t v3 = 2;
      if ((v2 & 2) == 0) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
    if ((*((_DWORD *)this + 6) & 2) != 0) {
LABEL_10:
    }
      uint64_t v3 = v3
         + wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64(*((wireless_diagnostics::google::protobuf::io::CodedOutputStream **)this + 1))
         + 1;
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_11:
  *((_DWORD *)this + 5) = v3;
  return v3;
}

void CLMicroLocationProto::ChannelAndCount::CheckTypeAndMergeFrom(CLMicroLocationProto::ChannelAndCount *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::ChannelAndCount::MergeFrom(this, lpsrc);
}

uint64_t CLMicroLocationProto::ChannelAndCount::IsInitialized(CLMicroLocationProto::ChannelAndCount *this)
{
  return 1;
}

void *CLMicroLocationProto::ChannelAndCount::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.ChannelAndCount");
}

void CLMicroLocationProto::WifiHistogram::MergeFrom(CLMicroLocationProto::WifiHistogram *this, const CLMicroLocationProto::WifiHistogram *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::WifiHistogram *)((char *)this + 8));
  if (*((int *)a2 + 4) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(const CLMicroLocationProto::ChannelAndCount **)(*((void *)a2 + 1) + 8 * v4);
      int v6 = *((_DWORD *)this + 5);
      uint64_t v7 = *((int *)this + 4);
      if ((int)v7 >= v6)
      {
        if (v6 == *((_DWORD *)this + 6))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((CLMicroLocationProto::WifiHistogram *)((char *)this + 8));
          int v6 = *((_DWORD *)this + 5);
        }
        *((_DWORD *)this + 5) = v6 + 1;
        operator new();
      }
      uint64_t v8 = *((void *)this + 1);
      *((_DWORD *)this + 4) = v7 + 1;
      CLMicroLocationProto::ChannelAndCount::MergeFrom(*(CLMicroLocationProto::ChannelAndCount **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *((int *)a2 + 4));
  }
  if (*((unsigned char *)a2 + 40))
  {
    unsigned int v9 = *((_DWORD *)a2 + 8);
    if (v9 >= 3) {
      CLMicroLocationProto::WifiHistogram::MergeFrom();
    }
    *((_DWORD *)this + 10) |= 1u;
    *((_DWORD *)this + 8) = v9;
  }
}

void sub_2564361CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::WifiHistogram::~WifiHistogram(CLMicroLocationProto::WifiHistogram *this)
{
  *(void *)this = &unk_2704DFA78;
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t *)this + 1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::WifiHistogram::~WifiHistogram(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::WifiHistogram::New(CLMicroLocationProto::WifiHistogram *this)
{
}

uint64_t CLMicroLocationProto::WifiHistogram::Clear(CLMicroLocationProto::WifiHistogram *this)
{
  if (*((unsigned char *)this + 40)) {
    *((_DWORD *)this + 8) = 0;
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>((uint64_t)this + 8);
  *((_DWORD *)this + 10) = 0;
  return result;
}

uint64_t CLMicroLocationProto::WifiHistogram::MergePartialFromCodedStream(CLMicroLocationProto::WifiHistogram *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = (CLMicroLocationProto::WifiHistogram *)((char *)this + 8);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_16;
        }
        unsigned int v23 = 0;
        uint64_t v8 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v8 >= *((void *)a2 + 2) || *v8 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v23);
          if (!result) {
            return result;
          }
          unsigned int v9 = v23;
        }
        else
        {
          unsigned int v9 = *v8;
          *((void *)a2 + 1) = v8 + 1;
        }
        if (v9 <= 2)
        {
          *((_DWORD *)this + 10) |= 1u;
          *((_DWORD *)this + 8) = v9;
        }
        unsigned int v11 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v11 < *((void *)a2 + 2) && *v11 == 18) {
          goto LABEL_25;
        }
      }
      if (TagFallback >> 3 != 2) {
        break;
      }
      int v7 = TagFallback & 7;
      if (v7 != 2) {
        goto LABEL_16;
      }
      while (1)
      {
        int v12 = *((_DWORD *)this + 5);
        uint64_t v13 = *((int *)this + 4);
        if ((int)v13 >= v12)
        {
          if (v12 == *((_DWORD *)this + 6))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v4);
            int v12 = *((_DWORD *)this + 5);
          }
          *((_DWORD *)this + 5) = v12 + 1;
          operator new();
        }
        uint64_t v14 = *((void *)this + 1);
        *((_DWORD *)this + 4) = v13 + 1;
        BOOL v15 = *(CLMicroLocationProto::ChannelAndCount **)(v14 + 8 * v13);
        unsigned int v24 = 0;
        uint64_t v16 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v16 >= *((void *)a2 + 2) || *v16 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v24))return 0; {
        }
          }
        else
        {
          unsigned int v24 = *v16;
          *((void *)a2 + 1) = v16 + 1;
        }
        int v17 = *((_DWORD *)a2 + 14);
        int v18 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v17 + 1;
        if (v17 >= v18) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::ChannelAndCount::MergePartialFromCodedStream(v15, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v19 = *((_DWORD *)a2 + 14);
        BOOL v20 = __OFSUB__(v19, 1);
        int v21 = v19 - 1;
        if (v21 < 0 == v20) {
          *((_DWORD *)a2 + 14) = v21;
        }
        unsigned int v11 = (unsigned char *)*((void *)a2 + 1);
        unsigned int v22 = (unsigned char *)*((void *)a2 + 2);
        if (v11 >= v22 || *v11 != 18) {
          break;
        }
LABEL_25:
        *((void *)a2 + 1) = v11 + 1;
      }
      if (v11 == v22 && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
    int v7 = TagFallback & 7;
LABEL_16:
    if (v7 == 4) {
      return 1;
    }
    if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
  }
    }
}

uint64_t CLMicroLocationProto::WifiHistogram::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = this;
  if (*(unsigned char *)(this + 40)) {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, *(unsigned int *)(this + 32), (uint64_t)a2, a4);
  }
  if (*(int *)(v5 + 16) >= 1)
  {
    uint64_t v6 = 0;
    do
      this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, *(void *)(*(void *)(v5 + 8) + 8 * v6++), a2, a4);
    while (v6 < *(int *)(v5 + 16));
  }
  return this;
}

uint64_t CLMicroLocationProto::WifiHistogram::ByteSize(CLMicroLocationProto::WifiHistogram *this)
{
  if (*((unsigned char *)this + 40))
  {
    uint64_t v3 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 8);
    if ((v3 & 0x80000000) != 0)
    {
      int v2 = 11;
    }
    else if (v3 >= 0x80)
    {
      int v2 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v3) + 1;
    }
    else
    {
      int v2 = 2;
    }
  }
  else
  {
    int v2 = 0;
  }
  int v4 = *((_DWORD *)this + 4);
  uint64_t v5 = (v4 + v2);
  if (v4 >= 1)
  {
    uint64_t v6 = 0;
    do
    {
      int v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::ChannelAndCount::ByteSize(*(CLMicroLocationProto::ChannelAndCount **)(*((void *)this + 1) + 8 * v6));
      int v8 = (int)v7;
      if (v7 >= 0x80) {
        int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7);
      }
      else {
        int v9 = 1;
      }
      uint64_t v5 = (v8 + v5 + v9);
      ++v6;
    }
    while (v6 < *((int *)this + 4));
  }
  *((_DWORD *)this + 9) = v5;
  return v5;
}

void CLMicroLocationProto::WifiHistogram::CheckTypeAndMergeFrom(CLMicroLocationProto::WifiHistogram *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::WifiHistogram::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::WifiHistogram::CopyFrom(CLMicroLocationProto::WifiHistogram *this, const CLMicroLocationProto::WifiHistogram *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::WifiHistogram *))(*(void *)this + 32))(this);
    CLMicroLocationProto::WifiHistogram::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::WifiHistogram::IsInitialized(CLMicroLocationProto::WifiHistogram *this)
{
  return 1;
}

void *CLMicroLocationProto::WifiHistogram::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.WifiHistogram");
}

void CLMicroLocationProto::AnchorAppearanceConfiguration::MergeFrom(CLMicroLocationProto::AnchorAppearanceConfiguration *this, const CLMicroLocationProto::AnchorAppearanceConfiguration *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 24);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 24))
    {
      unsigned int v5 = *((_DWORD *)a2 + 4);
      if (v5 >= 3) {
        CLMicroLocationProto::AnchorAppearanceConfiguration::MergeFrom();
      }
      *((_DWORD *)this + 6) |= 1u;
      *((_DWORD *)this + 4) = v5;
      int v4 = *((_DWORD *)a2 + 6);
    }
    if ((v4 & 2) != 0)
    {
      *((_DWORD *)this + 6) |= 2u;
      uint64_t v6 = (CLMicroLocationProto::anchorAppearancesVector *)*((void *)this + 1);
      if (!v6) {
        operator new();
      }
      int v7 = (const CLMicroLocationProto::anchorAppearancesVector *)*((void *)a2 + 1);
      if (!v7)
      {
        CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
        int v7 = *(const CLMicroLocationProto::anchorAppearancesVector **)(CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance_
                                                                     + 8);
      }
      CLMicroLocationProto::anchorAppearancesVector::MergeFrom(v6, v7);
    }
  }
}

void sub_25643693C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::AnchorAppearanceConfiguration::~AnchorAppearanceConfiguration(CLMicroLocationProto::AnchorAppearanceConfiguration *this)
{
  *(void *)this = &unk_2704DFAF0;
  CLMicroLocationProto::AnchorAppearanceConfiguration::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::AnchorAppearanceConfiguration::~AnchorAppearanceConfiguration(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::AnchorAppearanceConfiguration::SharedDtor(CLMicroLocationProto::AnchorAppearanceConfiguration *this)
{
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::AnchorAppearanceConfiguration *)CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance_ != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2)
    {
      uint64_t v3 = *(void (**)(void))(*(void *)v2 + 8);
      v3();
    }
  }
}

uint64_t CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance(CLMicroLocationProto::AnchorAppearanceConfiguration *this)
{
  return CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance_;
}

void CLMicroLocationProto::AnchorAppearanceConfiguration::New(CLMicroLocationProto::AnchorAppearanceConfiguration *this)
{
}

uint64_t CLMicroLocationProto::AnchorAppearanceConfiguration::Clear(uint64_t this)
{
  uint64_t v1 = this;
  char v2 = *(unsigned char *)(this + 24);
  if (v2)
  {
    *(_DWORD *)(this + 16) = 1;
    if ((v2 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3)
      {
        this = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(v3 + 8);
        *(_DWORD *)(v3 + 36) = 0;
      }
    }
  }
  *(_DWORD *)(v1 + 24) = 0;
  return this;
}

uint64_t CLMicroLocationProto::AnchorAppearanceConfiguration::MergePartialFromCodedStream(CLMicroLocationProto::AnchorAppearanceConfiguration *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v4 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v4 >= *((void *)a2 + 2) || *v4 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v4;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v4 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_15;
        }
        unsigned int v18 = 0;
        int v7 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v7 >= *((void *)a2 + 2) || *v7 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v18);
          if (!result) {
            return result;
          }
          unsigned int v8 = v18;
        }
        else
        {
          unsigned int v8 = *v7;
          *((void *)a2 + 1) = v7 + 1;
        }
        if (v8 <= 2)
        {
          *((_DWORD *)this + 6) |= 1u;
          *((_DWORD *)this + 4) = v8;
        }
        unsigned int v10 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v10 < *((void *)a2 + 2) && *v10 == 18)
        {
          *((void *)a2 + 1) = v10 + 1;
          goto LABEL_25;
        }
      }
      if (TagFallback >> 3 != 2)
      {
        int v6 = TagFallback & 7;
        goto LABEL_15;
      }
      int v6 = TagFallback & 7;
      if (v6 == 2) {
        break;
      }
LABEL_15:
      if (v6 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
    }
      }
LABEL_25:
    *((_DWORD *)this + 6) |= 2u;
    unsigned int v11 = (CLMicroLocationProto::anchorAppearancesVector *)*((void *)this + 1);
    if (!v11) {
      operator new();
    }
    unsigned int v19 = 0;
    int v12 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v12 >= *((void *)a2 + 2) || *v12 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v19)) {
        return 0;
      }
    }
    else
    {
      unsigned int v19 = *v12;
      *((void *)a2 + 1) = v12 + 1;
    }
    int v13 = *((_DWORD *)a2 + 14);
    int v14 = *((_DWORD *)a2 + 15);
    *((_DWORD *)a2 + 14) = v13 + 1;
    if (v13 >= v14) {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
    if (!CLMicroLocationProto::anchorAppearancesVector::MergePartialFromCodedStream(v11, a2)
      || !*((unsigned char *)a2 + 36))
    {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
    int v15 = *((_DWORD *)a2 + 14);
    BOOL v16 = __OFSUB__(v15, 1);
    int v17 = v15 - 1;
    if (v17 < 0 == v16) {
      *((_DWORD *)a2 + 14) = v17;
    }
    if (*((void *)a2 + 1) == *((void *)a2 + 2)
      && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
    {
      *((_DWORD *)a2 + 8) = 0;
      uint64_t result = 1;
      *((unsigned char *)a2 + 36) = 1;
      return result;
    }
  }
}

unsigned int *CLMicroLocationProto::AnchorAppearanceConfiguration::SerializeWithCachedSizes(unsigned int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  unsigned int v5 = this;
  unsigned int v6 = this[6];
  if (v6)
  {
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[4], (uint64_t)a2, a4);
    if ((v5[6] & 2) == 0) {
      return this;
    }
  }
  else if ((v6 & 2) == 0)
  {
    return this;
  }
  uint64_t v7 = *((void *)v5 + 1);
  if (!v7)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v7 = *(void *)(CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance_ + 8);
  }
  return (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
}

uint64_t CLMicroLocationProto::AnchorAppearanceConfiguration::ByteSize(CLMicroLocationProto::AnchorAppearanceConfiguration *this)
{
  char v2 = *((unsigned char *)this + 24);
  if (v2)
  {
    if (*((unsigned char *)this + 24))
    {
      int v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 4);
      if ((v4 & 0x80000000) != 0)
      {
        uint64_t v3 = 11;
        if ((v2 & 2) == 0) {
          goto LABEL_19;
        }
      }
      else if (v4 >= 0x80)
      {
        uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
        if ((*((_DWORD *)this + 6) & 2) == 0) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v3 = 2;
        if ((v2 & 2) == 0) {
          goto LABEL_19;
        }
      }
    }
    else
    {
      uint64_t v3 = 0;
      if ((*((unsigned char *)this + 24) & 2) == 0) {
        goto LABEL_19;
      }
    }
    unsigned int v5 = (CLMicroLocationProto::anchorAppearancesVector *)*((void *)this + 1);
    if (!v5)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      unsigned int v5 = *(CLMicroLocationProto::anchorAppearancesVector **)(CLMicroLocationProto::AnchorAppearanceConfiguration::default_instance_
                                                             + 8);
    }
    unsigned int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::anchorAppearancesVector::ByteSize(v5);
    int v7 = (int)v6;
    if (v6 >= 0x80) {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6);
    }
    else {
      int v8 = 1;
    }
    uint64_t v3 = (v3 + v7 + v8 + 1);
  }
  else
  {
    uint64_t v3 = 0;
  }
LABEL_19:
  *((_DWORD *)this + 5) = v3;
  return v3;
}

void CLMicroLocationProto::AnchorAppearanceConfiguration::CheckTypeAndMergeFrom(CLMicroLocationProto::AnchorAppearanceConfiguration *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::AnchorAppearanceConfiguration::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::AnchorAppearanceConfiguration::CopyFrom(CLMicroLocationProto::AnchorAppearanceConfiguration *this, const CLMicroLocationProto::AnchorAppearanceConfiguration *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::AnchorAppearanceConfiguration *))(*(void *)this + 32))(this);
    CLMicroLocationProto::AnchorAppearanceConfiguration::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::AnchorAppearanceConfiguration::IsInitialized(CLMicroLocationProto::AnchorAppearanceConfiguration *this)
{
  return 1;
}

void *CLMicroLocationProto::AnchorAppearanceConfiguration::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.AnchorAppearanceConfiguration");
}

void CLMicroLocationProto::AnchorValueStatisticsConfiguration::MergeFrom(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this, const CLMicroLocationProto::AnchorValueStatisticsConfiguration *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 32);
  if ((_BYTE)v4)
  {
    if (*((unsigned char *)a2 + 32))
    {
      unsigned int v5 = *((_DWORD *)a2 + 6);
      if (v5 >= 3) {
        CLMicroLocationProto::AnchorValueStatisticsConfiguration::MergeFrom();
      }
      *((_DWORD *)this + 8) |= 1u;
      *((_DWORD *)this + 6) = v5;
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 2) != 0)
    {
      *((_DWORD *)this + 8) |= 2u;
      unsigned int v6 = (CLMicroLocationProto::ClusterAnchorValueStatisticsVector *)*((void *)this + 1);
      if (!v6) {
        operator new();
      }
      int v7 = (const CLMicroLocationProto::ClusterAnchorValueStatisticsVector *)*((void *)a2 + 1);
      if (!v7)
      {
        CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
        int v7 = *(const CLMicroLocationProto::ClusterAnchorValueStatisticsVector **)(CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance_
                                                                                + 8);
      }
      CLMicroLocationProto::ClusterAnchorValueStatisticsVector::MergeFrom(v6, v7);
      int v4 = *((_DWORD *)a2 + 8);
    }
    if ((v4 & 4) != 0)
    {
      int v8 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 8) |= 4u;
      int v9 = (std::string *)*((void *)this + 2);
      if (v9 == (std::string *)MEMORY[0x263F8C740]) {
        operator new();
      }
      std::string::operator=(v9, v8);
    }
  }
}

void sub_256437160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::AnchorValueStatisticsConfiguration::~AnchorValueStatisticsConfiguration(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this)
{
  *(void *)this = &unk_2704DFB68;
  CLMicroLocationProto::AnchorValueStatisticsConfiguration::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::AnchorValueStatisticsConfiguration::~AnchorValueStatisticsConfiguration(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::AnchorValueStatisticsConfiguration::SharedDtor(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 2);
  if (v2 != MEMORY[0x263F8C740] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    this = (CLMicroLocationProto::AnchorValueStatisticsConfiguration *)MEMORY[0x25A2A6340](v2, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::AnchorValueStatisticsConfiguration *)CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance_ != v1)
  {
    uint64_t v4 = *((void *)v1 + 1);
    if (v4)
    {
      unsigned int v5 = *(void (**)(void))(*(void *)v4 + 8);
      v5();
    }
  }
}

uint64_t CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this)
{
  return CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance_;
}

void CLMicroLocationProto::AnchorValueStatisticsConfiguration::New(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this)
{
}

uint64_t CLMicroLocationProto::AnchorValueStatisticsConfiguration::Clear(uint64_t this)
{
  uint64_t v1 = this;
  LOBYTE(v2) = *(unsigned char *)(this + 32);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(this + 24) = 2;
    if ((v2 & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 8);
      if (v3)
      {
        this = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(v3 + 8);
        *(_DWORD *)(v3 + 36) = 0;
        int v2 = *(_DWORD *)(v1 + 32);
      }
    }
    if ((v2 & 4) != 0)
    {
      uint64_t v4 = *(void *)(v1 + 16);
      if (v4 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v4 + 23) < 0)
        {
          **(unsigned char **)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v4 = 0;
          *(unsigned char *)(v4 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(v1 + 32) = 0;
  return this;
}

uint64_t CLMicroLocationProto::AnchorValueStatisticsConfiguration::MergePartialFromCodedStream(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  while (1)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        unsigned int v7 = TagFallback >> 3;
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v8 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        unsigned int v21 = 0;
        int v9 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v9 >= *((void *)a2 + 2) || *v9 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v21);
          if (!result) {
            return result;
          }
          unsigned int v10 = v21;
        }
        else
        {
          unsigned int v10 = *v9;
          *((void *)a2 + 1) = v9 + 1;
        }
        if (v10 <= 2)
        {
          *((_DWORD *)this + 8) |= 1u;
          *((_DWORD *)this + 6) = v10;
        }
        int v12 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v12 < *((void *)a2 + 2) && *v12 == 18)
        {
          *((void *)a2 + 1) = v12 + 1;
          goto LABEL_29;
        }
      }
      if (v7 == 2) {
        break;
      }
      if (v7 == 3)
      {
        int v8 = TagFallback & 7;
        if (v8 == 2) {
          goto LABEL_43;
        }
      }
      else
      {
        int v8 = TagFallback & 7;
      }
LABEL_19:
      if (v8 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
    }
      }
    int v8 = TagFallback & 7;
    if (v8 != 2) {
      goto LABEL_19;
    }
LABEL_29:
    *((_DWORD *)this + 8) |= 2u;
    int v13 = (CLMicroLocationProto::ClusterAnchorValueStatisticsVector *)*((void *)this + 1);
    if (!v13) {
      operator new();
    }
    unsigned int v22 = 0;
    int v14 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 < 0)
    {
      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, &v22)) {
        return 0;
      }
    }
    else
    {
      unsigned int v22 = *v14;
      *((void *)a2 + 1) = v14 + 1;
    }
    int v15 = *((_DWORD *)a2 + 14);
    int v16 = *((_DWORD *)a2 + 15);
    *((_DWORD *)a2 + 14) = v15 + 1;
    if (v15 >= v16) {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
    if (!CLMicroLocationProto::ClusterAnchorValueStatisticsVector::MergePartialFromCodedStream(v13, a2)
      || !*((unsigned char *)a2 + 36))
    {
      return 0;
    }
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
    int v17 = *((_DWORD *)a2 + 14);
    BOOL v18 = __OFSUB__(v17, 1);
    int v19 = v17 - 1;
    if (v19 < 0 == v18) {
      *((_DWORD *)a2 + 14) = v19;
    }
    BOOL v20 = (unsigned char *)*((void *)a2 + 1);
    if ((unint64_t)v20 < *((void *)a2 + 2) && *v20 == 26)
    {
      *((void *)a2 + 1) = v20 + 1;
LABEL_43:
      *((_DWORD *)this + 8) |= 4u;
      if (*((void *)this + 2) == v4) {
        operator new();
      }
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
      if (!result) {
        return result;
      }
      if (*((void *)a2 + 1) == *((void *)a2 + 2)
        && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
      {
        *((_DWORD *)a2 + 8) = 0;
        uint64_t result = 1;
        *((unsigned char *)a2 + 36) = 1;
        return result;
      }
    }
  }
}

unsigned int *CLMicroLocationProto::AnchorValueStatisticsConfiguration::SerializeWithCachedSizes(unsigned int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  unsigned int v5 = this;
  unsigned int v6 = this[8];
  if (v6)
  {
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[6], (uint64_t)a2, a4);
    unsigned int v6 = v5[8];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        return this;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  uint64_t v7 = *((void *)v5 + 1);
  if (!v7)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v7 = *(void *)(CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance_ + 8);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, v7, a2, a4);
  if ((v5[8] & 4) != 0)
  {
LABEL_9:
    return (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
  }
  return this;
}

uint64_t CLMicroLocationProto::AnchorValueStatisticsConfiguration::ByteSize(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 32);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_29;
  }
  if ((*((unsigned char *)this + 32) & 1) == 0)
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 32) & 2) == 0) {
      goto LABEL_19;
    }
LABEL_13:
    unsigned int v5 = (CLMicroLocationProto::ClusterAnchorValueStatisticsVector *)*((void *)this + 1);
    if (!v5)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      unsigned int v5 = *(CLMicroLocationProto::ClusterAnchorValueStatisticsVector **)(CLMicroLocationProto::AnchorValueStatisticsConfiguration::default_instance_
                                                                        + 8);
    }
    unsigned int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::ClusterAnchorValueStatisticsVector::ByteSize(v5);
    int v7 = (int)v6;
    if (v6 >= 0x80) {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v6);
    }
    else {
      int v8 = 1;
    }
    uint64_t v3 = (v3 + v7 + v8 + 1);
    int v2 = *((_DWORD *)this + 8);
    goto LABEL_19;
  }
  uint64_t v4 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 6);
  if ((v4 & 0x80000000) != 0)
  {
    uint64_t v3 = 11;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
  else
  {
    if (v4 >= 0x80)
    {
      uint64_t v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v4) + 1;
      int v2 = *((_DWORD *)this + 8);
      if ((v2 & 2) == 0) {
        goto LABEL_19;
      }
      goto LABEL_13;
    }
    uint64_t v3 = 2;
    if ((v2 & 2) != 0) {
      goto LABEL_13;
    }
  }
LABEL_19:
  if ((v2 & 4) != 0)
  {
    uint64_t v9 = *((void *)this + 2);
    int v10 = *(unsigned __int8 *)(v9 + 23);
    char v11 = v10;
    uint64_t v12 = *(void *)(v9 + 8);
    if ((v10 & 0x80u) == 0) {
      unint64_t v13 = *(unsigned __int8 *)(v9 + 23);
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13 >= 0x80)
    {
      int v14 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v13);
      int v10 = *(unsigned __int8 *)(v9 + 23);
      uint64_t v12 = *(void *)(v9 + 8);
      char v11 = *(unsigned char *)(v9 + 23);
    }
    else
    {
      int v14 = 1;
    }
    if (v11 < 0) {
      int v10 = v12;
    }
    uint64_t v3 = (v3 + v14 + v10 + 1);
  }
LABEL_29:
  *((_DWORD *)this + 7) = v3;
  return v3;
}

void CLMicroLocationProto::AnchorValueStatisticsConfiguration::CheckTypeAndMergeFrom(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::AnchorValueStatisticsConfiguration::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::AnchorValueStatisticsConfiguration::CopyFrom(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this, const CLMicroLocationProto::AnchorValueStatisticsConfiguration *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::AnchorValueStatisticsConfiguration *))(*(void *)this + 32))(this);
    CLMicroLocationProto::AnchorValueStatisticsConfiguration::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::AnchorValueStatisticsConfiguration::IsInitialized(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this)
{
  return 1;
}

void *CLMicroLocationProto::AnchorValueStatisticsConfiguration::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.AnchorValueStatisticsConfiguration");
}

CLMicroLocationProto::Configuration *CLMicroLocationProto::Configuration::Configuration(CLMicroLocationProto::Configuration *this, const CLMicroLocationProto::Configuration *a2)
{
  *(void *)this = &unk_2704DFBE0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  CLMicroLocationProto::Configuration::MergeFrom(this, a2);
  return this;
}

void sub_2564379E8(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::Configuration::MergeFrom(CLMicroLocationProto::Configuration *this, const CLMicroLocationProto::Configuration *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v13);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 48);
  if (!(_BYTE)v4) {
    return;
  }
  if (*((unsigned char *)a2 + 48))
  {
    unsigned int v5 = *((_DWORD *)a2 + 10);
    if (v5 >= 3) {
      CLMicroLocationProto::Configuration::MergeFrom();
    }
    *((_DWORD *)this + 12) |= 1u;
    *((_DWORD *)this + 10) = v5;
    int v4 = *((_DWORD *)a2 + 12);
  }
  if ((v4 & 2) == 0)
  {
    if ((v4 & 4) == 0) {
      goto LABEL_9;
    }
LABEL_13:
    *((_DWORD *)this + 12) |= 4u;
    int v7 = (CLMicroLocationProto::WifiHistogram *)*((void *)this + 2);
    if (!v7) {
      operator new();
    }
    int v8 = (const CLMicroLocationProto::WifiHistogram *)*((void *)a2 + 2);
    if (!v8)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      int v8 = *(const CLMicroLocationProto::WifiHistogram **)(CLMicroLocationProto::Configuration::default_instance_ + 16);
    }
    CLMicroLocationProto::WifiHistogram::MergeFrom(v7, v8);
    int v4 = *((_DWORD *)a2 + 12);
    if ((v4 & 8) == 0)
    {
LABEL_10:
      if ((v4 & 0x10) == 0) {
        return;
      }
      goto LABEL_23;
    }
    goto LABEL_18;
  }
  uint64_t v6 = *((void *)a2 + 1);
  *((_DWORD *)this + 12) |= 2u;
  *((void *)this + 1) = v6;
  int v4 = *((_DWORD *)a2 + 12);
  if ((v4 & 4) != 0) {
    goto LABEL_13;
  }
LABEL_9:
  if ((v4 & 8) == 0) {
    goto LABEL_10;
  }
LABEL_18:
  *((_DWORD *)this + 12) |= 8u;
  uint64_t v9 = (CLMicroLocationProto::AnchorAppearanceConfiguration *)*((void *)this + 3);
  if (!v9) {
    operator new();
  }
  int v10 = (const CLMicroLocationProto::AnchorAppearanceConfiguration *)*((void *)a2 + 3);
  if (!v10)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    int v10 = *(const CLMicroLocationProto::AnchorAppearanceConfiguration **)(CLMicroLocationProto::Configuration::default_instance_
                                                                        + 24);
  }
  CLMicroLocationProto::AnchorAppearanceConfiguration::MergeFrom(v9, v10);
  if ((*((_DWORD *)a2 + 12) & 0x10) != 0)
  {
LABEL_23:
    *((_DWORD *)this + 12) |= 0x10u;
    char v11 = (CLMicroLocationProto::AnchorValueStatisticsConfiguration *)*((void *)this + 4);
    if (!v11) {
      operator new();
    }
    uint64_t v12 = (const CLMicroLocationProto::AnchorValueStatisticsConfiguration *)*((void *)a2 + 4);
    if (!v12)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      uint64_t v12 = *(const CLMicroLocationProto::AnchorValueStatisticsConfiguration **)(CLMicroLocationProto::Configuration::default_instance_
                                                                               + 32);
    }
    CLMicroLocationProto::AnchorValueStatisticsConfiguration::MergeFrom(v11, v12);
  }
}

void sub_256437C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::Configuration::~Configuration(CLMicroLocationProto::Configuration *this)
{
  *(void *)this = &unk_2704DFBE0;
  CLMicroLocationProto::Configuration::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::Configuration::~Configuration(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::Configuration::SharedDtor(CLMicroLocationProto::Configuration *this)
{
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::Configuration *)CLMicroLocationProto::Configuration::default_instance_ != this)
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = *((void *)this + 3);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = *((void *)this + 4);
    if (v4)
    {
      unsigned int v5 = *(void (**)(void))(*(void *)v4 + 8);
      v5();
    }
  }
}

uint64_t CLMicroLocationProto::Configuration::default_instance(CLMicroLocationProto::Configuration *this)
{
  return CLMicroLocationProto::Configuration::default_instance_;
}

void CLMicroLocationProto::Configuration::New(CLMicroLocationProto::Configuration *this)
{
}

uint64_t CLMicroLocationProto::Configuration::Clear(uint64_t this)
{
  uint64_t v1 = this;
  LOBYTE(v2) = *(unsigned char *)(this + 48);
  if ((_BYTE)v2)
  {
    *(_DWORD *)(this + 40) = 0;
    *(void *)(this + 8) = 0;
    if ((v2 & 4) != 0)
    {
      uint64_t v3 = *(void *)(this + 16);
      if (v3)
      {
        if (*(unsigned char *)(v3 + 40)) {
          *(_DWORD *)(v3 + 32) = 0;
        }
        this = wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(v3 + 8);
        *(_DWORD *)(v3 + 40) = 0;
        int v2 = *(_DWORD *)(v1 + 48);
      }
    }
    if ((v2 & 8) != 0)
    {
      this = *(void *)(v1 + 24);
      if (this)
      {
        this = CLMicroLocationProto::AnchorAppearanceConfiguration::Clear(this);
        int v2 = *(_DWORD *)(v1 + 48);
      }
    }
    if ((v2 & 0x10) != 0)
    {
      this = *(void *)(v1 + 32);
      if (this) {
        this = CLMicroLocationProto::AnchorValueStatisticsConfiguration::Clear(this);
      }
    }
  }
  *(_DWORD *)(v1 + 48) = 0;
  return this;
}

uint64_t CLMicroLocationProto::Configuration::MergePartialFromCodedStream(CLMicroLocationProto::Configuration *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  while (1)
  {
    uint64_t v4 = (char *)*((void *)a2 + 1);
    if ((unint64_t)v4 < *((void *)a2 + 2) && (*v4 & 0x80000000) == 0)
    {
      TagFallbacuint64_t k = *v4;
      *((_DWORD *)a2 + 8) = TagFallback;
      *((void *)a2 + 1) = v4 + 1;
      if (!TagFallback) {
        return 1;
      }
      goto LABEL_6;
    }
    TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
    *((_DWORD *)a2 + 8) = TagFallback;
    if (!TagFallback) {
      return 1;
    }
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v6 = TagFallback & 7;
        if ((TagFallback & 7) != 0) {
          goto LABEL_19;
        }
        v34[0] = 0;
        int v7 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v7 >= *((void *)a2 + 2) || *v7 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v34);
          if (!result) {
            return result;
          }
          unsigned int v8 = v34[0];
        }
        else
        {
          unsigned int v8 = *v7;
          *((void *)a2 + 1) = v7 + 1;
        }
        if (v8 <= 2)
        {
          *((_DWORD *)this + 12) |= 1u;
          *((_DWORD *)this + 10) = v8;
        }
        char v11 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v11 < *((void *)a2 + 2) && *v11 == 17)
        {
          *((void *)a2 + 1) = v11 + 1;
          goto LABEL_29;
        }
        continue;
      case 2u:
        int v6 = TagFallback & 7;
        if (v6 != 1) {
          goto LABEL_19;
        }
LABEL_29:
        *(void *)int v34 = 0;
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(a2, (unint64_t *)v34) & 1) == 0)return 0; {
        *((void *)this + 1) = *(void *)v34;
        }
        int v9 = *((_DWORD *)this + 12) | 2;
        *((_DWORD *)this + 12) = v9;
        uint64_t v12 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v12 >= *((void *)a2 + 2) || *v12 != 34) {
          continue;
        }
        *((void *)a2 + 1) = v12 + 1;
LABEL_33:
        *((_DWORD *)this + 12) = v9 | 4;
        unint64_t v13 = (CLMicroLocationProto::WifiHistogram *)*((void *)this + 2);
        if (!v13) {
          operator new();
        }
        v34[0] = 0;
        int v14 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v14 >= *((void *)a2 + 2) || *v14 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v34))return 0; {
        }
          }
        else
        {
          v34[0] = *v14;
          *((void *)a2 + 1) = v14 + 1;
        }
        int v15 = *((_DWORD *)a2 + 14);
        int v16 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v15 + 1;
        if (v15 >= v16) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::WifiHistogram::MergePartialFromCodedStream(v13, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v17 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v17, 1);
        int v19 = v17 - 1;
        if (v19 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v19;
        }
        BOOL v20 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v20 >= *((void *)a2 + 2) || *v20 != 42) {
          continue;
        }
        *((void *)a2 + 1) = v20 + 1;
LABEL_47:
        *((_DWORD *)this + 12) |= 8u;
        unsigned int v21 = (CLMicroLocationProto::AnchorAppearanceConfiguration *)*((void *)this + 3);
        if (!v21) {
          operator new();
        }
        v34[0] = 0;
        unsigned int v22 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v22 >= *((void *)a2 + 2) || *v22 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v34))return 0; {
        }
          }
        else
        {
          v34[0] = *v22;
          *((void *)a2 + 1) = v22 + 1;
        }
        int v23 = *((_DWORD *)a2 + 14);
        int v24 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v23 + 1;
        if (v23 >= v24) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::AnchorAppearanceConfiguration::MergePartialFromCodedStream(v21, a2)
          || !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v25 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v25, 1);
        int v26 = v25 - 1;
        if (v26 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v26;
        }
        unsigned int v27 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v27 >= *((void *)a2 + 2) || *v27 != 50) {
          continue;
        }
        *((void *)a2 + 1) = v27 + 1;
LABEL_61:
        *((_DWORD *)this + 12) |= 0x10u;
        uint64_t v28 = (CLMicroLocationProto::AnchorValueStatisticsConfiguration *)*((void *)this + 4);
        if (!v28) {
          operator new();
        }
        v34[0] = 0;
        unsigned int v29 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v29 >= *((void *)a2 + 2) || *v29 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(a2, v34))return 0; {
        }
          }
        else
        {
          v34[0] = *v29;
          *((void *)a2 + 1) = v29 + 1;
        }
        int v30 = *((_DWORD *)a2 + 14);
        int v31 = *((_DWORD *)a2 + 15);
        *((_DWORD *)a2 + 14) = v30 + 1;
        if (v30 >= v31) {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(a2);
        if (!CLMicroLocationProto::AnchorValueStatisticsConfiguration::MergePartialFromCodedStream(v28, a2)|| !*((unsigned char *)a2 + 36))
        {
          return 0;
        }
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(a2);
        int v32 = *((_DWORD *)a2 + 14);
        BOOL v18 = __OFSUB__(v32, 1);
        int v33 = v32 - 1;
        if (v33 < 0 == v18) {
          *((_DWORD *)a2 + 14) = v33;
        }
        if (*((void *)a2 + 1) == *((void *)a2 + 2)
          && (*((_DWORD *)a2 + 11) || *((_DWORD *)a2 + 6) == *((_DWORD *)a2 + 10)))
        {
          *((_DWORD *)a2 + 8) = 0;
          uint64_t result = 1;
          *((unsigned char *)a2 + 36) = 1;
          return result;
        }
        break;
      case 4u:
        int v6 = TagFallback & 7;
        if (v6 != 2) {
          goto LABEL_19;
        }
        int v9 = *((_DWORD *)this + 12);
        goto LABEL_33;
      case 5u:
        int v6 = TagFallback & 7;
        if (v6 == 2) {
          goto LABEL_47;
        }
        goto LABEL_19;
      case 6u:
        int v6 = TagFallback & 7;
        if (v6 != 2) {
          goto LABEL_19;
        }
        goto LABEL_61;
      default:
        int v6 = TagFallback & 7;
LABEL_19:
        if (v6 == 4) {
          return 1;
        }
        if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
        continue;
        }
    }
  }
}

unsigned int *CLMicroLocationProto::Configuration::SerializeWithCachedSizes(unsigned int *this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  unsigned int v5 = this;
  unsigned int v6 = this[12];
  if (v6)
  {
    this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1, this[10], (uint64_t)a2, a4);
    unsigned int v6 = v5[12];
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2, (uint64_t)a2, *((double *)v5 + 1), a3);
  unsigned int v6 = v5[12];
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v7 = *((void *)v5 + 2);
  if (!v7)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v7 = *(void *)(CLMicroLocationProto::Configuration::default_instance_ + 16);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4, v7, a2, a4);
  unsigned int v6 = v5[12];
  if ((v6 & 8) == 0)
  {
LABEL_5:
    if ((v6 & 0x10) == 0) {
      return this;
    }
    goto LABEL_15;
  }
LABEL_12:
  uint64_t v8 = *((void *)v5 + 3);
  if (!v8)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
    uint64_t v8 = *(void *)(CLMicroLocationProto::Configuration::default_instance_ + 24);
  }
  this = (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5, v8, a2, a4);
  if ((v5[12] & 0x10) != 0)
  {
LABEL_15:
    uint64_t v9 = *((void *)v5 + 4);
    if (!v9)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto((CLMicroLocationProto *)this);
      uint64_t v9 = *(void *)(CLMicroLocationProto::Configuration::default_instance_ + 32);
    }
    return (unsigned int *)wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage((wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6, v9, a2, a4);
  }
  return this;
}

uint64_t CLMicroLocationProto::Configuration::ByteSize(CLMicroLocationProto::Configuration *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 48);
  if (!(_BYTE)v2)
  {
    uint64_t v4 = 0;
    goto LABEL_35;
  }
  if (*((unsigned char *)this + 48))
  {
    unsigned int v5 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*((unsigned int *)this + 10);
    if ((v5 & 0x80000000) != 0)
    {
      unsigned int v3 = 11;
    }
    else if (v5 >= 0x80)
    {
      unsigned int v3 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v5) + 1;
      int v2 = *((_DWORD *)this + 12);
    }
    else
    {
      unsigned int v3 = 2;
    }
  }
  else
  {
    unsigned int v3 = 0;
  }
  if ((v2 & 2) != 0) {
    uint64_t v4 = v3 + 9;
  }
  else {
    uint64_t v4 = v3;
  }
  if ((v2 & 4) != 0)
  {
    unsigned int v6 = (CLMicroLocationProto::WifiHistogram *)*((void *)this + 2);
    if (!v6)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      unsigned int v6 = *(CLMicroLocationProto::WifiHistogram **)(CLMicroLocationProto::Configuration::default_instance_ + 16);
    }
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::WifiHistogram::ByteSize(v6);
    int v8 = (int)v7;
    if (v7 >= 0x80) {
      int v9 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7);
    }
    else {
      int v9 = 1;
    }
    uint64_t v4 = (v4 + v8 + v9 + 1);
    int v2 = *((_DWORD *)this + 12);
    if ((v2 & 8) == 0)
    {
LABEL_15:
      if ((v2 & 0x10) == 0) {
        goto LABEL_35;
      }
      goto LABEL_29;
    }
  }
  else if ((v2 & 8) == 0)
  {
    goto LABEL_15;
  }
  int v10 = (CLMicroLocationProto::AnchorAppearanceConfiguration *)*((void *)this + 3);
  if (!v10)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
    int v10 = *(CLMicroLocationProto::AnchorAppearanceConfiguration **)(CLMicroLocationProto::Configuration::default_instance_
                                                                  + 24);
  }
  char v11 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::AnchorAppearanceConfiguration::ByteSize(v10);
  int v12 = (int)v11;
  if (v11 >= 0x80) {
    int v13 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v11);
  }
  else {
    int v13 = 1;
  }
  uint64_t v4 = (v4 + v12 + v13 + 1);
  if ((*((_DWORD *)this + 12) & 0x10) != 0)
  {
LABEL_29:
    int v14 = (CLMicroLocationProto::AnchorValueStatisticsConfiguration *)*((void *)this + 4);
    if (!v14)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(0);
      int v14 = *(CLMicroLocationProto::AnchorValueStatisticsConfiguration **)(CLMicroLocationProto::Configuration::default_instance_
                                                                         + 32);
    }
    int v15 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)CLMicroLocationProto::AnchorValueStatisticsConfiguration::ByteSize(v14);
    int v16 = (int)v15;
    if (v15 >= 0x80) {
      int v17 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v15);
    }
    else {
      int v17 = 1;
    }
    uint64_t v4 = (v4 + v16 + v17 + 1);
  }
LABEL_35:
  *((_DWORD *)this + 11) = v4;
  return v4;
}

void CLMicroLocationProto::Configuration::CheckTypeAndMergeFrom(CLMicroLocationProto::Configuration *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::Configuration::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::Configuration::CopyFrom(CLMicroLocationProto::Configuration *this, const CLMicroLocationProto::Configuration *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::Configuration *))(*(void *)this + 32))(this);
    CLMicroLocationProto::Configuration::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::Configuration::IsInitialized(CLMicroLocationProto::Configuration *this)
{
  return 1;
}

void *CLMicroLocationProto::Configuration::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.Configuration");
}

CLMicroLocationProto::RapportDevice *CLMicroLocationProto::RapportDevice::RapportDevice(CLMicroLocationProto::RapportDevice *this, const CLMicroLocationProto::RapportDevice *a2)
{
  uint64_t v3 = MEMORY[0x263F8C740];
  *(void *)this = &unk_2704DFC58;
  *((void *)this + 1) = v3;
  *((void *)this + 2) = v3;
  *((void *)this + 3) = 0;
  CLMicroLocationProto::RapportDevice::MergeFrom(this, a2);
  return this;
}

void sub_256438808(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RapportDevice::MergeFrom(CLMicroLocationProto::RapportDevice *this, const CLMicroLocationProto::RapportDevice *a2)
{
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }
  LOBYTE(v4) = *((unsigned char *)a2 + 28);
  if ((_BYTE)v4)
  {
    unsigned int v5 = (std::string *)MEMORY[0x263F8C740];
    if (*((unsigned char *)a2 + 28))
    {
      unsigned int v6 = (const std::string *)*((void *)a2 + 1);
      *((_DWORD *)this + 7) |= 1u;
      uint64_t v7 = (std::string *)*((void *)this + 1);
      if (v7 == v5) {
        operator new();
      }
      std::string::operator=(v7, v6);
      int v4 = *((_DWORD *)a2 + 7);
    }
    if ((v4 & 2) != 0)
    {
      int v8 = (const std::string *)*((void *)a2 + 2);
      *((_DWORD *)this + 7) |= 2u;
      int v9 = (std::string *)*((void *)this + 2);
      if (v9 == v5) {
        operator new();
      }
      std::string::operator=(v9, v8);
    }
  }
}

void sub_256438940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RapportDevice::~RapportDevice(CLMicroLocationProto::RapportDevice *this)
{
  *(void *)this = &unk_2704DFC58;
  CLMicroLocationProto::ServiceDelete::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  uint64_t vars8;

  CLMicroLocationProto::RapportDevice::~RapportDevice(this);
  JUMPOUT(0x25A2A6340);
}

void CLMicroLocationProto::RapportDevice::New(CLMicroLocationProto::RapportDevice *this)
{
}

uint64_t CLMicroLocationProto::RapportDevice::Clear(uint64_t this)
{
  if (*(unsigned char *)(this + 28))
  {
    uint64_t v1 = MEMORY[0x263F8C740];
    if (*(unsigned char *)(this + 28))
    {
      uint64_t v2 = *(void *)(this + 8);
      if (v2 != MEMORY[0x263F8C740])
      {
        if (*(char *)(v2 + 23) < 0)
        {
          **(unsigned char **)uint64_t v2 = 0;
          *(void *)(v2 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + 23) = 0;
        }
      }
    }
    if ((*(unsigned char *)(this + 28) & 2) != 0)
    {
      uint64_t v3 = *(void *)(this + 16);
      if (v3 != v1)
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(unsigned char **)uint64_t v3 = 0;
          *(void *)(v3 + 8) = 0;
        }
        else
        {
          *(unsigned char *)uint64_t v3 = 0;
          *(unsigned char *)(v3 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 28) = 0;
  return this;
}

uint64_t CLMicroLocationProto::RapportDevice::MergePartialFromCodedStream(CLMicroLocationProto::RapportDevice *this, wireless_diagnostics::google::protobuf::io::CodedInputStream *a2)
{
  uint64_t v4 = MEMORY[0x263F8C740];
  do
  {
    while (1)
    {
      while (1)
      {
        unsigned int v5 = (char *)*((void *)a2 + 1);
        if ((unint64_t)v5 >= *((void *)a2 + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(a2);
          *((_DWORD *)a2 + 8) = TagFallback;
          if (!TagFallback) {
            return 1;
          }
        }
        else
        {
          TagFallbacuint64_t k = *v5;
          *((_DWORD *)a2 + 8) = TagFallback;
          *((void *)a2 + 1) = v5 + 1;
          if (!TagFallback) {
            return 1;
          }
        }
        if (TagFallback >> 3 != 1) {
          break;
        }
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_26;
        }
        *((_DWORD *)this + 7) |= 1u;
        if (*((void *)this + 1) == v4) {
          operator new();
        }
        uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadBytes();
        if (!result) {
          return result;
        }
        int v9 = (unsigned char *)*((void *)a2 + 1);
        if ((unint64_t)v9 < *((void *)a2 + 2) && *v9 == 18)
        {
          *((void *)a2 + 1) = v9 + 1;
          goto LABEL_18;
        }
      }
      if (TagFallback >> 3 != 2)
      {
        int v7 = TagFallback & 7;
        goto LABEL_26;
      }
      int v7 = TagFallback & 7;
      if (v7 == 2) {
        break;
      }
LABEL_26:
      if (v7 == 4) {
        return 1;
      }
      if ((wireless_diagnostics::google::protobuf::internal::WireFormatLite::SkipField(a2, (wireless_diagnostics::google::protobuf::io::CodedInputStream *)TagFallback) & 1) == 0)return 0; {
    }
      }
LABEL_18:
    *((_DWORD *)this + 7) |= 2u;
    if (*((void *)this + 2) == v4) {
      operator new();
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::ReadString();
    if (!result) {
      return result;
    }
  }
  while (*((void *)a2 + 1) != *((void *)a2 + 2)
       || !*((_DWORD *)a2 + 11) && *((_DWORD *)a2 + 6) != *((_DWORD *)a2 + 10));
  *((_DWORD *)a2 + 8) = 0;
  uint64_t result = 1;
  *((unsigned char *)a2 + 36) = 1;
  return result;
}

uint64_t CLMicroLocationProto::RapportDevice::SerializeWithCachedSizes(uint64_t this, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a2)
{
  uint64_t v2 = this;
  int v3 = *(_DWORD *)(this + 28);
  if (v3)
  {
    this = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBytes();
    int v3 = *(_DWORD *)(v2 + 28);
  }
  if ((v3 & 2) != 0)
  {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteString();
  }
  return this;
}

uint64_t CLMicroLocationProto::RapportDevice::ByteSize(CLMicroLocationProto::RapportDevice *this)
{
  LOBYTE(v2) = *((unsigned char *)this + 28);
  if (!(_BYTE)v2)
  {
    uint64_t v3 = 0;
    goto LABEL_24;
  }
  if ((*((unsigned char *)this + 28) & 1) == 0)
  {
    uint64_t v3 = 0;
    if ((*((unsigned char *)this + 28) & 2) == 0) {
      goto LABEL_24;
    }
    goto LABEL_15;
  }
  uint64_t v4 = *((void *)this + 1);
  int v5 = *(unsigned __int8 *)(v4 + 23);
  char v6 = v5;
  uint64_t v7 = *(void *)(v4 + 8);
  if ((v5 & 0x80u) == 0) {
    unint64_t v8 = *(unsigned __int8 *)(v4 + 23);
  }
  else {
    unint64_t v8 = v7;
  }
  if (v8 >= 0x80)
  {
    int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v8);
    int v5 = *(unsigned __int8 *)(v4 + 23);
    uint64_t v7 = *(void *)(v4 + 8);
    int v9 = v10 + 1;
    int v2 = *((_DWORD *)this + 7);
    char v6 = *(unsigned char *)(v4 + 23);
  }
  else
  {
    int v9 = 2;
  }
  if (v6 < 0) {
    int v5 = v7;
  }
  uint64_t v3 = (v9 + v5);
  if ((v2 & 2) != 0)
  {
LABEL_15:
    uint64_t v11 = *((void *)this + 2);
    int v12 = *(unsigned __int8 *)(v11 + 23);
    char v13 = v12;
    uint64_t v14 = *(void *)(v11 + 8);
    if ((v12 & 0x80u) == 0) {
      unint64_t v15 = *(unsigned __int8 *)(v11 + 23);
    }
    else {
      unint64_t v15 = v14;
    }
    if (v15 >= 0x80)
    {
      int v16 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback((wireless_diagnostics::google::protobuf::io::CodedOutputStream *)v15);
      int v12 = *(unsigned __int8 *)(v11 + 23);
      uint64_t v14 = *(void *)(v11 + 8);
      char v13 = *(unsigned char *)(v11 + 23);
    }
    else
    {
      int v16 = 1;
    }
    if (v13 < 0) {
      int v12 = v14;
    }
    uint64_t v3 = (v3 + v16 + v12 + 1);
  }
LABEL_24:
  *((_DWORD *)this + 6) = v3;
  return v3;
}

void CLMicroLocationProto::RapportDevice::CheckTypeAndMergeFrom(CLMicroLocationProto::RapportDevice *this, const wireless_diagnostics::google::protobuf::MessageLite *lpsrc)
{
  CLMicroLocationProto::RapportDevice::MergeFrom(this, lpsrc);
}

void CLMicroLocationProto::RapportDevice::CopyFrom(CLMicroLocationProto::RapportDevice *this, const CLMicroLocationProto::RapportDevice *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::RapportDevice *))(*(void *)this + 32))(this);
    CLMicroLocationProto::RapportDevice::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::RapportDevice::IsInitialized(CLMicroLocationProto::RapportDevice *this)
{
  return 1;
}

void *CLMicroLocationProto::RapportDevice::GetTypeName@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "CLMicroLocationProto.RapportDevice");
}

uint64_t CLMicroLocationProto::BleLeechedBeacons::GetCachedSize(CLMicroLocationProto::BleLeechedBeacons *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t CLMicroLocationProto::WiFiRssi::GetCachedSize(CLMicroLocationProto::WiFiRssi *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t CLMicroLocationProto::Direction::GetCachedSize(CLMicroLocationProto::Direction *this)
{
  return *((unsigned int *)this + 5);
}

uint64_t CLMicroLocationProto::UwbRange::GetCachedSize(CLMicroLocationProto::UwbRange *this)
{
  return *((unsigned int *)this + 13);
}

uint64_t CLMicroLocationProto::WiFiRange::GetCachedSize(CLMicroLocationProto::WiFiRange *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t CLMicroLocationProto::ATVAirplayBluetoothRssi::GetCachedSize(CLMicroLocationProto::ATVAirplayBluetoothRssi *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t CLMicroLocationProto::HomeKitBluetoothRssi::GetCachedSize(CLMicroLocationProto::HomeKitBluetoothRssi *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t CLMicroLocationProto::Measurement::GetCachedSize(CLMicroLocationProto::Measurement *this)
{
  return *((unsigned int *)this + 17);
}

uint64_t CLMicroLocationProto::DeviceId::GetCachedSize(CLMicroLocationProto::DeviceId *this)
{
  return *((unsigned int *)this + 6);
}

uint64_t CLMicroLocationProto::FingerprintMeasurement::GetCachedSize(CLMicroLocationProto::FingerprintMeasurement *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t CLMicroLocationProto::Fingerprint::GetCachedSize(CLMicroLocationProto::Fingerprint *this)
{
  return *((unsigned int *)this + 25);
}

uint64_t CLMicroLocationProto::ClusterRecordings::GetCachedSize(CLMicroLocationProto::ClusterRecordings *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t CLMicroLocationProto::AnchorMetadata::GetCachedSize(CLMicroLocationProto::AnchorMetadata *this)
{
  return *((unsigned int *)this + 11);
}

uint64_t CLMicroLocationProto::AnchorAppearance::GetCachedSize(CLMicroLocationProto::AnchorAppearance *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t CLMicroLocationProto::anchorAppearancesVector::GetCachedSize(CLMicroLocationProto::anchorAppearancesVector *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t CLMicroLocationProto::AnchorValueStatistics::GetCachedSize(CLMicroLocationProto::AnchorValueStatistics *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatistics::GetCachedSize(CLMicroLocationProto::ClusterAnchorValueStatistics *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t CLMicroLocationProto::ClusterAnchorValueStatisticsVector::GetCachedSize(CLMicroLocationProto::ClusterAnchorValueStatisticsVector *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t CLMicroLocationProto::LocationSimilarityListElement::GetCachedSize(CLMicroLocationProto::LocationSimilarityListElement *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t CLMicroLocationProto::LocationSimilarityListData::GetCachedSize(CLMicroLocationProto::LocationSimilarityListData *this)
{
  return *((unsigned int *)this + 18);
}

uint64_t CLMicroLocationProto::BlueAtlasData::GetCachedSize(CLMicroLocationProto::BlueAtlasData *this)
{
  return *((unsigned int *)this + 14);
}

uint64_t CLMicroLocationProto::Model::GetCachedSize(CLMicroLocationProto::Model *this)
{
  return *((unsigned int *)this + 49);
}

uint64_t CLMicroLocationProto::BundleIdFeatures::GetCachedSize(CLMicroLocationProto::BundleIdFeatures *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::ReceivedEventAction::GetCachedSize(CLMicroLocationProto::ReceivedEventAction *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t CLMicroLocationProto::RecordingRequest::GetCachedSize(CLMicroLocationProto::RecordingRequest *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t CLMicroLocationProto::TruthLabelDonation::GetCachedSize(CLMicroLocationProto::TruthLabelDonation *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t CLMicroLocationProto::ForcedRecording::GetCachedSize(CLMicroLocationProto::ForcedRecording *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::HomeKitAccessory::GetCachedSize(CLMicroLocationProto::HomeKitAccessory *this)
{
  return *((unsigned int *)this + 28);
}

uint64_t CLMicroLocationProto::HomeKitScene::GetCachedSize(CLMicroLocationProto::HomeKitScene *this)
{
  return *((unsigned int *)this + 20);
}

uint64_t CLMicroLocationProto::NowPlayingOutputDevice::GetCachedSize(CLMicroLocationProto::NowPlayingOutputDevice *this)
{
  return *((unsigned int *)this + 6);
}

uint64_t CLMicroLocationProto::NowPlaying::GetCachedSize(CLMicroLocationProto::NowPlaying *this)
{
  return *((unsigned int *)this + 16);
}

uint64_t CLMicroLocationProto::LearnModel::GetCachedSize(CLMicroLocationProto::LearnModel *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::LearnCompleted::GetCachedSize(CLMicroLocationProto::LearnCompleted *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::SensorsScanComplete::GetCachedSize(CLMicroLocationProto::SensorsScanComplete *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::StartSpectating::GetCachedSize(CLMicroLocationProto::StartSpectating *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::StopSpectating::GetCachedSize(CLMicroLocationProto::StopSpectating *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::ServiceCreate::GetCachedSize(CLMicroLocationProto::ServiceCreate *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t CLMicroLocationProto::ServiceDelete::GetCachedSize(CLMicroLocationProto::ServiceDelete *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t CLMicroLocationProto::ServiceDisconnect::GetCachedSize(CLMicroLocationProto::ServiceDisconnect *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t CLMicroLocationProto::ServiceStopUpdating::GetCachedSize(CLMicroLocationProto::ServiceStopUpdating *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t CLMicroLocationProto::RequestObservation::GetCachedSize(CLMicroLocationProto::RequestObservation *this)
{
  return *((unsigned int *)this + 11);
}

uint64_t CLMicroLocationProto::RequestPrediction::GetCachedSize(CLMicroLocationProto::RequestPrediction *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t CLMicroLocationProto::MotionEvent::GetCachedSize(CLMicroLocationProto::MotionEvent *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t CLMicroLocationProto::LegacyThrottle::GetCachedSize(CLMicroLocationProto::LegacyThrottle *this)
{
  return *((unsigned int *)this + 5);
}

uint64_t CLMicroLocationProto::RetrievedLoi::GetCachedSize(CLMicroLocationProto::RetrievedLoi *this)
{
  return *((unsigned int *)this + 11);
}

uint64_t CLMicroLocationProto::AssociatedAccessPointInfo::GetCachedSize(CLMicroLocationProto::AssociatedAccessPointInfo *this)
{
  return *((unsigned int *)this + 5);
}

uint64_t CLMicroLocationProto::RecordingEvent::GetCachedSize(CLMicroLocationProto::RecordingEvent *this)
{
  return *((unsigned int *)this + 34);
}

uint64_t CLMicroLocationProto::TriggerEvent::GetCachedSize(CLMicroLocationProto::TriggerEvent *this)
{
  return *((unsigned int *)this + 20);
}

uint64_t CLMicroLocationProto::SpectatingMotionUpdate::GetCachedSize(CLMicroLocationProto::SpectatingMotionUpdate *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t CLMicroLocationProto::CloudBackupExport::GetCachedSize(CLMicroLocationProto::CloudBackupExport *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::CloudBackupImport::GetCachedSize(CLMicroLocationProto::CloudBackupImport *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::DataMigration::GetCachedSize(CLMicroLocationProto::DataMigration *this)
{
  return *((unsigned int *)this + 3);
}

uint64_t CLMicroLocationProto::ChannelAndCount::GetCachedSize(CLMicroLocationProto::ChannelAndCount *this)
{
  return *((unsigned int *)this + 5);
}

uint64_t CLMicroLocationProto::WifiHistogram::GetCachedSize(CLMicroLocationProto::WifiHistogram *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t CLMicroLocationProto::AnchorAppearanceConfiguration::GetCachedSize(CLMicroLocationProto::AnchorAppearanceConfiguration *this)
{
  return *((unsigned int *)this + 5);
}

uint64_t CLMicroLocationProto::AnchorValueStatisticsConfiguration::GetCachedSize(CLMicroLocationProto::AnchorValueStatisticsConfiguration *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t CLMicroLocationProto::Configuration::GetCachedSize(CLMicroLocationProto::Configuration *this)
{
  return *((unsigned int *)this + 11);
}

uint64_t CLMicroLocationProto::RapportDevice::GetCachedSize(CLMicroLocationProto::RapportDevice *this)
{
  return *((unsigned int *)this + 6);
}

uint64_t wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(uint64_t result)
{
  uint64_t v1 = result;
  if (*(int *)(result + 8) >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)v1 + 8 * v2) + 32))(*(void *)(*(void *)v1 + 8 * v2));
      ++v2;
    }
    while (v2 < *(int *)(v1 + 8));
  }
  *(_DWORD *)(v1 + 8) = 0;
  return result;
}

uint64_t wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Clear<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(uint64_t result)
{
  if (*(int *)(result + 8) >= 1)
  {
    uint64_t v1 = 0;
    do
    {
      uint64_t v2 = *(void *)(*(void *)result + 8 * v1);
      if (*(char *)(v2 + 23) < 0)
      {
        **(unsigned char **)uint64_t v2 = 0;
        *(void *)(v2 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v2 = 0;
        *(unsigned char *)(v2 + 23) = 0;
      }
      ++v1;
    }
    while (v1 < *(int *)(result + 8));
  }
  *(_DWORD *)(result + 8) = 0;
  return result;
}

uint64_t wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Measurement>::TypeHandler>(uint64_t *a1)
{
  int v2 = *((_DWORD *)a1 + 3);
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(*a1 + 8 * i);
      if (v4)
      {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
        int v2 = *((_DWORD *)a1 + 3);
      }
    }
  }
  uint64_t result = *a1;
  if (*a1)
  {
    JUMPOUT(0x25A2A6320);
  }
  return result;
}

void wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::MergeFrom<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::FingerprintMeasurement>::TypeHandler>(int *a1, uint64_t a2)
{
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)a1);
  if (*(int *)(a2 + 8) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      int v5 = *(const CLMicroLocationProto::FingerprintMeasurement **)(*(void *)a2 + 8 * v4);
      int v6 = a1[3];
      uint64_t v7 = a1[2];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[4])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)a1);
          int v6 = a1[3];
        }
        a1[3] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *(void *)a1;
      a1[2] = v7 + 1;
      CLMicroLocationProto::FingerprintMeasurement::MergeFrom(*(CLMicroLocationProto::FingerprintMeasurement **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 8));
  }
}

uint64_t wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Destroy<wireless_diagnostics::google::protobuf::RepeatedPtrField<std::string>::TypeHandler>(int *a1)
{
  if (a1[3] >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::Delete();
      ++v2;
    }
    while (v2 < a1[3]);
  }
  uint64_t result = *(void *)a1;
  if (*(void *)a1)
  {
    JUMPOUT(0x25A2A6320);
  }
  return result;
}

void wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::MergeFrom<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::Fingerprint>::TypeHandler>(int *a1, uint64_t a2)
{
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)a1);
  if (*(int *)(a2 + 8) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      int v5 = *(const CLMicroLocationProto::Fingerprint **)(*(void *)a2 + 8 * v4);
      int v6 = a1[3];
      uint64_t v7 = a1[2];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[4])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)a1);
          int v6 = a1[3];
        }
        a1[3] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *(void *)a1;
      a1[2] = v7 + 1;
      CLMicroLocationProto::Fingerprint::MergeFrom(*(CLMicroLocationProto::Fingerprint **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 8));
  }
}

void wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::MergeFrom<wireless_diagnostics::google::protobuf::RepeatedPtrField<CLMicroLocationProto::AnchorMetadata>::TypeHandler>(int *a1, uint64_t a2)
{
  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)a1);
  if (*(int *)(a2 + 8) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      int v5 = *(const CLMicroLocationProto::AnchorMetadata **)(*(void *)a2 + 8 * v4);
      int v6 = a1[3];
      uint64_t v7 = a1[2];
      if ((int)v7 >= v6)
      {
        if (v6 == a1[4])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)a1);
          int v6 = a1[3];
        }
        a1[3] = v6 + 1;
        operator new();
      }
      uint64_t v8 = *(void *)a1;
      a1[2] = v7 + 1;
      CLMicroLocationProto::AnchorMetadata::MergeFrom(*(CLMicroLocationProto::AnchorMetadata **)(v8 + 8 * v7), v5);
      ++v4;
    }
    while (v4 < *(int *)(a2 + 8));
  }
}

void sub_2564396D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ULDBUtils::insertEntries<CLMiLoHomeSlamAnalyticEventTable,ULHomeSlamAnalyticEventMO>(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v12 = 0;
  char v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 0;
  uint64_t v4 = [v3 managedObjectContext];
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 3221225472;
  _DWORD v8[2] = ___ZN9ULDBUtils13insertEntriesI32CLMiLoHomeSlamAnalyticEventTable25ULHomeSlamAnalyticEventMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke;
  v8[3] = &unk_2653F90B8;
  uint64_t v11 = a2;
  id v5 = v3;
  id v9 = v5;
  int v10 = &v12;
  [v4 performBlockAndWait:v8];

  uint64_t v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);

  return v6;
}

void sub_256439814(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ULDBUtils::fetchEntries<CLMiLoHomeSlamAnalyticEventTable,ULHomeSlamAnalyticEventMO>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a3;
  uint64_t v23 = 0;
  int v24 = &v23;
  uint64_t v25 = 0x4812000000;
  int v26 = __Block_byref_object_copy__11;
  unsigned int v27 = __Block_byref_object_dispose__11;
  uint64_t v28 = &unk_25654E519;
  int v30 = 0;
  uint64_t v31 = 0;
  std::string __p = 0;
  uint64_t v12 = [v9 managedObjectContext];
  v17[0] = MEMORY[0x263EF8330];
  v17[1] = 3221225472;
  v17[2] = ___ZN9ULDBUtils12fetchEntriesI32CLMiLoHomeSlamAnalyticEventTable25ULHomeSlamAnalyticEventMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke;
  void v17[3] = &unk_2653F90E0;
  id v13 = v10;
  id v18 = v13;
  id v14 = v11;
  id v19 = v14;
  uint64_t v22 = a4;
  id v15 = v9;
  id v20 = v15;
  unsigned int v21 = &v23;
  [v12 performBlockAndWait:v17];

  int v16 = v24;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  std::vector<CLMiLoHomeSlamAnalyticEventTable::Entry>::__init_with_size[abi:ne180100]<CLMiLoHomeSlamAnalyticEventTable::Entry*,CLMiLoHomeSlamAnalyticEventTable::Entry*>(a5, (const void *)v16[6], v16[7], (v16[7] - v16[6]) >> 4);

  _Block_object_dispose(&v23, 8);
  if (__p)
  {
    int v30 = __p;
    operator delete(__p);
  }
}

void sub_2564399F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  _Block_object_dispose(&a18, 8);
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void ULDBUtils::fetchAllWithLimit<CLMiLoHomeSlamAnalyticEventTable,ULHomeSlamAnalyticEventMO>(void *a1@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  v10[1] = *MEMORY[0x263EF8340];
  id v5 = a1;
  uint64_t v6 = (void *)MEMORY[0x263F08B30];
  uint64_t v7 = [(id)objc_opt_class() defaultSortProperty];
  uint64_t v8 = [v6 sortDescriptorWithKey:v7 ascending:0];

  v10[0] = v8;
  id v9 = [MEMORY[0x263EFF8C0] arrayWithObjects:v10 count:1];
  ULDBUtils::fetchEntries<CLMiLoHomeSlamAnalyticEventTable,ULHomeSlamAnalyticEventMO>(v5, 0, v9, a2, a3);
}

void sub_256439B60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_256439D0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_256439F70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643A0E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN9ULDBUtils13insertEntriesI32CLMiLoHomeSlamAnalyticEventTable25ULHomeSlamAnalyticEventMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(uint64_t **)(a1 + 48);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  if (*v2 == v4)
  {
LABEL_4:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [*(id *)(a1 + 32) commitChangesToStore];
    uint64_t v7 = *(void **)(a1 + 32);
    [v7 deleteOldestRecordsIfFull];
  }
  else
  {
    while (1)
    {
      id v5 = [*(id *)(a1 + 32) managedObjectContext];
      uint64_t v6 = +[ULHomeSlamAnalyticEventMO createFromEntry:v3 inManagedObjectContext:v5];

      if (!v6) {
        break;
      }

      v3 += 16;
      if (v3 == v4) {
        goto LABEL_4;
      }
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_66);
    }
    uint64_t v8 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v9 = +[ULHomeSlamAnalyticEventMO entity];
      id v10 = [v9 name];
      int v15 = 68289283;
      int v16 = 0;
      __int16 v17 = 2082;
      id v18 = "";
      __int16 v19 = 2113;
      id v20 = v10;
      _os_log_impl(&dword_25631F000, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v15, 0x1Cu);
    }
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_66);
    }
    id v11 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v11))
    {
      uint64_t v12 = +[ULHomeSlamAnalyticEventMO entity];
      id v13 = [v12 name];
      int v15 = 68289283;
      int v16 = 0;
      __int16 v17 = 2082;
      id v18 = "";
      __int16 v19 = 2113;
      id v20 = v13;
      _os_signpost_emit_with_name_impl(&dword_25631F000, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to create entry from MO", "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v15, 0x1Cu);
    }
    id v14 = [*(id *)(a1 + 32) managedObjectContext];
    [v14 reset];
  }
}

void sub_25643A3D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_55()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

__n128 __Block_byref_object_copy__11(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZN9ULDBUtils12fetchEntriesI32CLMiLoHomeSlamAnalyticEventTable25ULHomeSlamAnalyticEventMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  uint64_t v3 = (objc_class *)objc_opt_class();
  uint64_t v4 = NSStringFromClass(v3);
  id v5 = [v2 fetchManagedObjectsWithEntityName:v4 byAndPredicates:*(void *)(a1 + 32) sortDescriptors:*(void *)(a1 + 40) andLimit:*(void *)(a1 + 64)];

  ULDBUtils::convertManagedObjectsToEntries<CLMiLoHomeSlamAnalyticEventTable,ULHomeSlamAnalyticEventMO>(v5, (uint64_t)&v9);
  uint64_t v6 = *(void **)(*(void *)(a1 + 56) + 8);
  uint64_t v7 = (void *)v6[6];
  if (v7)
  {
    v6[7] = v7;
    operator delete(v7);
    void v6[6] = 0;
    v6[7] = 0;
    v6[8] = 0;
  }
  *((_OWORD *)v6 + 3) = v9;
  v6[8] = v10;
  uint64_t v8 = [*(id *)(a1 + 48) managedObjectContext];
  [v8 reset];
}

void sub_25643A574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ULDBUtils::convertManagedObjectsToEntries<CLMiLoHomeSlamAnalyticEventTable,ULHomeSlamAnalyticEventMO>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  id v3 = a1;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  std::vector<CLMiLoHomeSlamAnalyticEventTable::Entry>::reserve((char **)a2, [v3 count]);
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id v4 = v3;
  uint64_t v5 = [v4 countByEnumeratingWithState:&v33 objects:v43 count:16];
  if (v5)
  {
    id v30 = v3;
    uint64_t v6 = *(void *)v34;
    while (2)
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v34 != v6) {
          objc_enumerationMutation(v4);
        }
        id v8 = *(id *)(*((void *)&v33 + 1) + 8 * i);
        long long v9 = v8;
        if (!v8 || (objc_msgSend(v8, "convertToEntry", v30), !v32))
        {
          if (onceToken_MicroLocation_Default != -1) {
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_66);
          }
          int v24 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            uint64_t v25 = [v9 entity];
            int v26 = [v25 name];
            *(_DWORD *)uint64_t buf = 68289283;
            int v38 = 0;
            __int16 v39 = 2082;
            uint64_t v40 = "";
            __int16 v41 = 2113;
            int v42 = v26;
            _os_log_impl(&dword_25631F000, v24, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);
          }
          if (onceToken_MicroLocation_Default != -1) {
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_66);
          }
          unsigned int v27 = (id)logObject_MicroLocation_Default;
          if (os_signpost_enabled(v27))
          {
            uint64_t v28 = [v9 entity];
            unsigned int v29 = [v28 name];
            *(_DWORD *)uint64_t buf = 68289283;
            int v38 = 0;
            __int16 v39 = 2082;
            uint64_t v40 = "";
            __int16 v41 = 2113;
            int v42 = v29;
            _os_signpost_emit_with_name_impl(&dword_25631F000, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to convert MO to entry", "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);
          }
          *(void *)(a2 + 8) = *(void *)a2;
          goto LABEL_38;
        }
        id v11 = *(_OWORD **)(a2 + 8);
        unint64_t v10 = *(void *)(a2 + 16);
        if ((unint64_t)v11 >= v10)
        {
          uint64_t v12 = ((uint64_t)v11 - *(void *)a2) >> 4;
          unint64_t v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 60) {
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v14 = v10 - *(void *)a2;
          if (v14 >> 3 > v13) {
            unint64_t v13 = v14 >> 3;
          }
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v15 = v13;
          }
          if (v15) {
            int v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(a2 + 16, v15);
          }
          else {
            int v16 = 0;
          }
          __int16 v17 = &v16[16 * v12];
          *(_OWORD *)__int16 v17 = v31;
          __int16 v19 = *(char **)a2;
          id v18 = *(char **)(a2 + 8);
          id v20 = v17;
          if (v18 != *(char **)a2)
          {
            do
            {
              uint64_t v21 = *((void *)v18 - 2);
              v18 -= 16;
              __int16 v22 = *((_WORD *)v18 + 4);
              *((void *)v20 - 2) = v21;
              v20 -= 16;
              *((_WORD *)v20 + 4) = v22;
            }
            while (v18 != v19);
            id v18 = *(char **)a2;
          }
          uint64_t v23 = v17 + 16;
          *(void *)a2 = v20;
          *(void *)(a2 + 8) = v17 + 16;
          *(void *)(a2 + 16) = &v16[16 * v15];
          if (v18) {
            operator delete(v18);
          }
          *(void *)(a2 + 8) = v23;
        }
        else
        {
          *id v11 = v31;
          *(void *)(a2 + 8) = v11 + 1;
        }
      }
      uint64_t v5 = [v4 countByEnumeratingWithState:&v33 objects:v43 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

LABEL_38:
}

void sub_25643A964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  uint64_t v12 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v12;
    operator delete(v12);
  }

  _Unwind_Resume(a1);
}

void std::vector<CLMiLoHomeSlamAnalyticEventTable::Entry>::reserve(char **a1, unint64_t a2)
{
  id v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(v3, a2);
    uint64_t v7 = &v6[v5];
    uint64_t v9 = &v6[16 * v8];
    id v11 = *a1;
    unint64_t v10 = a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 2);
        v10 -= 16;
        __int16 v14 = *((_WORD *)v10 + 4);
        *((void *)v12 - 2) = v13;
        v12 -= 16;
        *((_WORD *)v12 + 4) = v14;
      }
      while (v10 != v11);
      unint64_t v10 = *a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t CLMicroLocationBinaryRoiNullSpaceAlgorithm::localize@<X0>(CLMicroLocationModel *this@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, const CLMicroLocationLocalizationSettings *a4@<X4>, char **a5@<X8>)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (!CLMicroLocationModel::isValid(this))
  {
    CLMicroLocationBinaryRoiNullSpaceAlgorithm::localize();
    goto LABEL_67;
  }
  if (!*(unsigned char *)(a3 + 32))
  {
    CLMicroLocationBinaryRoiNullSpaceAlgorithm::localize();
LABEL_67:
    __break(1u);
  }
  long long v75 = 0u;
  long long v76 = 0u;
  int v77 = 1065353216;
  unint64_t v10 = (void *)*((void *)this + 41);
  for (uint64_t i = (void *)*((void *)this + 42); v10 != i; v10 += 4)
  {
    *(void *)uint64_t buf = v10 + 2;
    uint64_t v12 = (uint64_t **)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>((uint64_t)&v75, v10 + 2, (uint64_t)&std::piecewise_construct, (_OWORD **)buf);
    uint64_t v13 = *(void *)(a3 + 24);
    if (!v13) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    *(void *)uint64_t buf = (*(double (**)(uint64_t, void, uint64_t))(*(void *)v13 + 48))(v13, *v10, a2);
    std::__tree<double>::__emplace_multi<double>(v12 + 4, (double *)buf);
  }
  CLMicroLocationModel::getIdentifiers(this, (uint64_t)v73);
  int v14 = *(_DWORD *)(a2 + 160);
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  *((_DWORD *)a5 + 6) = 3;
  *((unsigned char *)a5 + 80) = 0;
  a5[5] = 0;
  a5[6] = 0;
  a5[4] = 0;
  *((unsigned char *)a5 + 56) = 0;
  unint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a5 + 2), 1uLL);
  __int16 v17 = &v15[32 * v16];
  *(void *)unint64_t v15 = 0;
  *((void *)v15 + 1) = 0;
  *((void *)v15 + 2) = 0;
  int v62 = v14;
  *((_DWORD *)v15 + 6) = v14;
  id v18 = v15 + 32;
  id v20 = *a5;
  __int16 v19 = a5[1];
  if (v19 != *a5)
  {
    do
    {
      long long v21 = *((_OWORD *)v19 - 2);
      *(_OWORD *)(v15 - 20) = *(_OWORD *)(v19 - 20);
      *((_OWORD *)v15 - 2) = v21;
      v15 -= 32;
      v19 -= 32;
    }
    while (v19 != v20);
    __int16 v19 = *a5;
  }
  *a5 = v15;
  a5[1] = v18;
  a5[2] = v17;
  if (v19) {
    operator delete(v19);
  }
  a5[1] = v18;
  CLMicroLocationBinaryRoiNullSpaceAlgorithm::getAdjustmentPowerForBinaryRoiDetectionThreshold((CLMicroLocationBinaryRoiNullSpaceAlgorithm *)v15, a4);
  uint64_t v23 = v74;
  if (v74)
  {
    long double v24 = v22;
    do
    {
      if ((v23[2] & v23[3]) != -1)
      {
        memset(v71, 0, sizeof(v71));
        int v72 = 1065353216;
        for (uint64_t j = (uint64_t *)v76; j; uint64_t j = (uint64_t *)*j)
        {
          if (j[2] == v23[2] && j[3] == v23[3])
          {
            *(void *)uint64_t buf = j + 2;
            uint64_t v28 = (uint64_t **)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>((uint64_t)v71, j + 2, (uint64_t)&std::piecewise_construct, (_OWORD **)buf);
            if (j != (uint64_t *)v28) {
              std::__tree<double>::__assign_multi<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>(v28 + 4, (void *)j[4], j + 5);
            }
          }
          else
          {
            *(void *)uint64_t buf = CL::kNegMicroLocation;
            unsigned int v27 = (char *)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>((uint64_t)v71, CL::kNegMicroLocation, (uint64_t)&std::piecewise_construct, (_OWORD **)buf);
            std::multiset<double>::insert[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>(v27 + 32, (void *)j[4], j + 5);
          }
        }
        CLMicroLocationBinaryRoiNullSpaceAlgorithm::createReducedDistancesMap((CLMacAddress *)a4, (unint64_t)v71, (uint64_t)v69);
        long long v66 = 0u;
        long long v67 = 0u;
        int v68 = 1065353216;
        CLMicroLocationLocalizationSettings::getKernelFuncSettings((id *)a4);
        unsigned int v29 = (CLMicroLocationAlgorithms *)objc_claimAutoreleasedReturnValue();
        CLMicroLocationAlgorithms::createKernelFunction(v29, &v65);

        for (uint64_t k = v70; k; uint64_t k = *(double **)k)
        {
          double v31 = (*(double (**)(uint64_t, double))(*(void *)v65 + 24))(v65, k[4]);
          if (v31 >= 0.0)
          {
            *(void *)uint64_t buf = k + 2;
            *((double *)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,double>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,double>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,double>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,double>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>((uint64_t)&v66, (void *)k + 2, (uint64_t)&std::piecewise_construct, (_OWORD **)buf)+ 4) = v31 / (1.0 - v31);
            if (onceToken_MicroLocation_Default != -1) {
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_67);
            }
            char v32 = (id)logObject_MicroLocation_Default;
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
            {
              long long v33 = operator new(0x28uLL);
              std::string __p = v33;
              long long v64 = xmmword_256514540;
              *long long v33 = 0u;
              v33[1] = 0u;
              *(void *)((char *)v33 + 29) = 0;
              boost::uuids::to_chars<char *>((uint64_t)(k + 2), v33);
              p_p = &__p;
              if (v64 < 0) {
                p_p = __p;
              }
              uint64_t v36 = *((void *)k + 4);
              uint64_t v35 = *((void *)k + 5);
              *(void *)uint64_t buf = 68290051;
              __int16 v79 = 2082;
              int v80 = "";
              __int16 v81 = 2081;
              int v82 = p_p;
              __int16 v83 = 2049;
              uint64_t v84 = v35;
              __int16 v85 = 2049;
              double v86 = v31;
              __int16 v87 = 2049;
              uint64_t v88 = v36;
              _os_log_impl(&dword_25631F000, v32, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"nullspace\", \"identifier\":%{private, location:escape_only}s, \"weight\":\"%{private}f\", \"phat\":\"%{private}f\", \"reducedDistance\":\"%{private}f\"}", buf, 0x3Au);
              if (SHIBYTE(v64) < 0) {
                operator delete(__p);
              }
            }
          }
        }
        uint64_t v37 = (double *)v67;
        if ((void)v67)
        {
          double v38 = 1.0;
          __int16 v39 = (double *)v67;
          do
          {
            double v38 = v38 + v39[4];
            __int16 v39 = *(double **)v39;
          }
          while (v39);
          double v40 = 1.0 / v38;
          do
          {
            if (*((void *)v37 + 2) == v23[2] && *((void *)v37 + 3) == v23[3])
            {
              uint64_t v43 = *((void *)v37 + 2);
              uint64_t v42 = *((void *)v37 + 3);
              double v44 = pow(v40 * v37[4], v24);
              double v45 = v44;
              int v46 = a5[1];
              int v47 = a5[2];
              if (v46 >= v47)
              {
                uint64_t v49 = (v46 - *a5) >> 5;
                unint64_t v50 = v49 + 1;
                if ((unint64_t)(v49 + 1) >> 59) {
                  std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v51 = v47 - *a5;
                if (v51 >> 4 > v50) {
                  unint64_t v50 = v51 >> 4;
                }
                if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFE0) {
                  unint64_t v52 = 0x7FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v52 = v50;
                }
                int v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a5 + 2), v52);
                int v55 = &v53[32 * v49];
                *(void *)int v55 = v43;
                *((void *)v55 + 1) = v42;
                *((double *)v55 + 2) = v45;
                *((_DWORD *)v55 + 6) = v62;
                int v57 = *a5;
                uint64_t v56 = a5[1];
                int v58 = v55;
                if (v56 != *a5)
                {
                  do
                  {
                    long long v59 = *((_OWORD *)v56 - 2);
                    *(_OWORD *)(v58 - 20) = *(_OWORD *)(v56 - 20);
                    *((_OWORD *)v58 - 2) = v59;
                    v58 -= 32;
                    v56 -= 32;
                  }
                  while (v56 != v57);
                  uint64_t v56 = *a5;
                }
                int v48 = v55 + 32;
                *a5 = v58;
                a5[1] = v55 + 32;
                a5[2] = &v53[32 * v54];
                if (v56) {
                  operator delete(v56);
                }
              }
              else
              {
                *(void *)int v46 = v43;
                *((void *)v46 + 1) = v42;
                *((double *)v46 + 2) = v44;
                int v48 = v46 + 32;
                *((_DWORD *)v46 + 6) = v62;
              }
              a5[1] = v48;
            }
            uint64_t v37 = *(double **)v37;
          }
          while (v37);
        }
        uint64_t v60 = v65;
        uint64_t v65 = 0;
        if (v60) {
          (*(void (**)(uint64_t))(*(void *)v60 + 8))(v60);
        }
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v66);
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v69);
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::~__hash_table((uint64_t)v71);
      }
      uint64_t v23 = (void *)*v23;
    }
    while (v23);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v73);
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::~__hash_table((uint64_t)&v75);
}

void sub_25643B0E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  CLMicroLocationAlgorithms::LocalizerResults::~LocalizerResults(v41);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a36);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::~__hash_table((uint64_t)&a41);
  _Unwind_Resume(a1);
}

void CLMicroLocationBinaryRoiNullSpaceAlgorithm::getAdjustmentPowerForBinaryRoiDetectionThreshold(CLMicroLocationBinaryRoiNullSpaceAlgorithm *this, const CLMicroLocationLocalizationSettings *a2)
{
  double v2 = COERCE_DOUBLE(CLMicroLocationLocalizationSettings::getDetectionThresholdForBinaryROI(a2));
  if (v3)
  {
    if (v2 > 0.0 && v2 < 1.0)
    {
      log(v2);
    }
    else
    {
      int AdjustmentPowerForBinaryRoiDetectionThreshold = CLMicroLocationBinaryRoiNullSpaceAlgorithm::getAdjustmentPowerForBinaryRoiDetectionThreshold();
      CLMicroLocationBinaryRoiNullSpaceAlgorithm::createReducedDistancesMap(AdjustmentPowerForBinaryRoiDetectionThreshold, v6, v7);
    }
  }
}

uint64_t *CLMicroLocationBinaryRoiNullSpaceAlgorithm::createReducedDistancesMap@<X0>(CLMacAddress *this@<X2>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(uint64_t **)(a2 + 16);
  if (v6)
  {
    int v7 = 0;
    do
    {
      v7 += *((_DWORD *)v6 + 12);
      int v6 = (uint64_t *)*v6;
    }
    while (v6);
    double v8 = (double)v7;
  }
  else
  {
    double v8 = 0.0;
  }
  uint64_t v9 = CLMacAddress::newFromUint64(this, a2);
  unint64_t v10 = *(uint64_t **)(v9 + 8);
  if (v10)
  {
    uint64_t v3 = v9;
    id v11 = *(uint64_t **)(v9 + 8);
    do
    {
      int v12 = *((_DWORD *)v11 + 8);
      if (v12 <= 2)
      {
        if (v12 == 2) {
          goto LABEL_15;
        }
        ++v11;
      }
      id v11 = (uint64_t *)*v11;
    }
    while (v11);
  }
  CLMicroLocationBinaryRoiNullSpaceAlgorithm::createReducedDistancesMap();
  do
  {
    ++v10;
    do
    {
      unint64_t v10 = (uint64_t *)*v10;
      if (!v10)
      {
        ReducedDistancesMap = (_Unwind_Exception *)CLMicroLocationBinaryRoiNullSpaceAlgorithm::createReducedDistancesMap();
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a3);
        _Unwind_Resume(ReducedDistancesMap);
      }
LABEL_15:
      int v13 = *((_DWORD *)v10 + 8);
    }
    while (v13 > 3);
  }
  while (v13 != 3);
  LODWORD(v23) = 2;
  double v14 = *(double *)std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::at(v3, (int *)&v23);
  LODWORD(v23) = 3;
  __n128 result = std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::at(v3, (int *)&v23);
  double v16 = *(double *)result;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  for (uint64_t i = *(uint64_t **)(a2 + 16); i; uint64_t i = (uint64_t *)*i)
  {
    if (~*((_OWORD *)i + 1) == 0) {
      double v18 = v16;
    }
    else {
      double v18 = v14;
    }
    CLReducerFunction<std::multiset<double>,double>::parametrizedPercentileSorted((void **)i + 4, v18);
    uint64_t v20 = v19;
    unint64_t v21 = i[6];
    uint64_t v23 = i + 2;
    __n128 result = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(a3, i + 2, (uint64_t)&std::piecewise_construct, &v23);
    result[4] = v20;
    *((double *)result + 5) = (double)v21 / v8;
  }
  return result;
}

void **CLReducerFunction<std::multiset<double>,double>::parametrizedPercentileSorted(void **result, double a2)
{
  double v2 = result[2];
  if (!v2) {
    CLReducerFunction<std::multiset<double>,double>::parametrizedPercentileSorted();
  }
  if (a2 < 0.0 || a2 > 1.0) {
    CLReducerFunction<std::multiset<double>,double>::parametrizedPercentileSorted();
  }
  BOOL v4 = a2 == 0.0 || v2 == (void *)1;
  if (!v4)
  {
    if (a2 == 1.0)
    {
      int v6 = result[1];
      ++result;
      uint64_t v5 = v6;
      if (v6)
      {
        do
          uint64_t v5 = (void *)v5[1];
        while (v5);
      }
      else
      {
        do
        {
          BOOL v4 = *result[2] == (void)result;
          __n128 result = (void **)result[2];
        }
        while (v4);
      }
    }
    else
    {
      double v7 = (double)((unint64_t)v2 - 1);
      double v8 = v7 * a2;
      if (v8 < 0.0) {
        double v8 = 0.0;
      }
      if (v8 <= v7) {
        double v9 = v8;
      }
      else {
        double v9 = (double)((unint64_t)v2 - 1);
      }
      uint64_t v10 = llround(floor(v9));
      if (v10 < 0 || v10 > (int)v2 - 2) {
        CLReducerFunction<std::multiset<double>,double>::parametrizedPercentileSorted();
      }
      int v13 = *result;
      __n128 result = std::__advance[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>(&v13, v10);
      id v11 = v13;
      int v12 = (void *)v13[1];
      if (v12)
      {
        do
          int v12 = (void *)*v12;
        while (v12);
      }
      else
      {
        do
        {
          BOOL v4 = *(void *)v11[2] == (void)v11;
          id v11 = (void *)v11[2];
        }
        while (!v4);
      }
    }
  }
  return result;
}

void CLMicroLocationBinaryRoiNullSpaceAlgorithm::~CLMicroLocationBinaryRoiNullSpaceAlgorithm(CLMicroLocationBinaryRoiNullSpaceAlgorithm *this)
{
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_56()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

uint64_t **std::__tree<double>::__assign_multi<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>(uint64_t **result, void *a2, void *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    int v6 = *result;
    double v7 = result[1];
    *__n128 result = (uint64_t *)(result + 1);
    _DWORD v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      double v8 = (uint64_t *)v6[1];
    }
    else {
      double v8 = v6;
    }
    double v14 = result;
    unint64_t v15 = v8;
    double v16 = v8;
    if (v8)
    {
      unint64_t v15 = std::__tree<double>::_DetachedTreeCache::__detach_next((uint64_t)v8);
      if (a2 != a3)
      {
        double v9 = a2;
        do
        {
          void v8[4] = v9[4];
          std::__tree<double>::__node_insert_multi(v5, (uint64_t)v8);
          double v8 = v15;
          double v16 = v15;
          if (v15) {
            unint64_t v15 = std::__tree<double>::_DetachedTreeCache::__detach_next((uint64_t)v15);
          }
          uint64_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint64_t v10 = (void *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              double v9 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          double v9 = a2;
        }
        while (a2 != a3);
      }
    }
    __n128 result = (uint64_t **)std::__tree<double>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      __n128 result = (uint64_t **)std::__tree<double>::__emplace_multi<double>(v5, (double *)a2 + 4);
      int v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          int v13 = v12;
          int v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          int v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_25643B6C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__tree<double>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<double>::__node_insert_multi(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = a1 + 1;
  BOOL v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        if (*(double *)(a2 + 32) >= *((double *)v4 + 4)) {
          break;
        }
        BOOL v4 = (uint64_t *)*v4;
        uint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      BOOL v4 = (uint64_t *)v4[1];
    }
    while (v4);
    uint64_t v5 = v3 + 1;
  }
  else
  {
    uint64_t v5 = a1 + 1;
  }
LABEL_8:
  std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v3, v5, (uint64_t *)a2);
  return a2;
}

void *std::__tree<double>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  __n128 result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *__n128 result = 0;
      while (1)
      {
        BOOL v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          __n128 result = v4;
          BOOL v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          __n128 result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t std::__tree<double>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(*(void *)a1, *(void **)(a1 + 16));
  double v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        double v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(*(void *)a1, v2);
  }
  return a1;
}

uint64_t sub_25643B81C()
{
  return 0;
}

void sub_25643BD7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_25643C190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
}

ULWiFiScanStrategy *ULWiFiStrategyBuilder::buildScanStartegy(int a1, void *a2, unsigned int **a3, uint64_t a4)
{
  double v8 = [MEMORY[0x263EFF980] array];
  if (a1 == 2)
  {
    uint64_t v66 = a4;
    double v16 = +[ULDefaultsSingleton shared];
    __int16 v17 = [v16 defaultsDictionary];

    double v18 = [NSString stringWithUTF8String:"ULRecording80211ScanType"];
    uint64_t v19 = [v17 objectForKey:v18];
    if (v19 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      unsigned int v20 = [v19 unsignedIntValue];
    }
    else {
      unsigned int v20 = [&unk_2704F1B78 unsignedIntValue];
    }
    unsigned int v22 = v20;

    uint64_t v23 = +[ULDefaultsSingleton shared];
    long double v24 = [v23 defaultsDictionary];

    uint64_t v25 = [NSString stringWithUTF8String:"ULRecordingScanLowPriority"];
    int v26 = [v24 objectForKey:v25];
    if (v26 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      char v27 = [v26 BOOLValue];
    }
    else {
      char v27 = [MEMORY[0x263EFFA80] BOOLValue];
    }
    char v33 = v27;

    long long v34 = +[ULDefaultsSingleton shared];
    uint64_t v35 = [v34 defaultsDictionary];

    uint64_t v36 = [NSString stringWithUTF8String:"ULRecordingWifiMaxAgeFirstScan"];
    uint64_t v37 = [v35 objectForKey:v36];
    if (v37 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      int v38 = [v37 intValue];
    }
    else {
      int v38 = [&unk_2704F1B60 intValue];
    }
    int v44 = v38;

    double v45 = *a3;
    for (uint64_t i = a3[1]; v45 != i; v45 += 2)
    {
      int v47 = [ULWiFiScanChannel alloc];
      if (*v45 <= 0xDuLL) {
        uint64_t v48 = 1;
      }
      else {
        uint64_t v48 = 2;
      }
      uint64_t v49 = -[ULWiFiScanChannel initWithBand:andChannelNumber:](v47, "initWithBand:andChannelNumber:", v48);
      [v8 addObject:v49];
    }
    goto LABEL_45;
  }
  if (a1 == 1)
  {
    ULSettings::get<ULSettings::LocalizingTopChannels>(&v68);
    std::vector<int>::pointer begin = v68.__begin_;
    unint64_t v10 = (uint64_t)(a2[1] - *a2) >> 3;
    if (v10 > v68.__end_ - v68.__begin_)
    {
      ULSettings::get<ULSettings::LocalizingTopChannels>(&v67);
      unint64_t v10 = v67.__end_ - v67.__begin_;
      if (v67.__begin_) {
        operator delete(v67.__begin_);
      }
    }
    uint64_t v66 = a4;
    if (begin) {
      operator delete(begin);
    }
    BOOL v11 = +[ULDefaultsSingleton shared];
    int v12 = [v11 defaultsDictionary];

    int v13 = [NSString stringWithUTF8String:"ULLocalizing80211ScanType"];
    double v14 = [v12 objectForKey:v13];
    if (v14 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      unsigned int v15 = [v14 unsignedIntValue];
    }
    else {
      unsigned int v15 = [&unk_2704F1B78 unsignedIntValue];
    }
    unsigned int v22 = v15;

    uint64_t v28 = +[ULDefaultsSingleton shared];
    unsigned int v29 = [v28 defaultsDictionary];

    id v30 = [NSString stringWithUTF8String:"ULLocalizingScanLowPriority"];
    double v31 = [v29 objectForKey:v30];
    if (v31 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      char v32 = [v31 BOOLValue];
    }
    else {
      char v32 = [MEMORY[0x263EFFA80] BOOLValue];
    }
    char v33 = v32;

    __int16 v39 = +[ULDefaultsSingleton shared];
    double v40 = [v39 defaultsDictionary];

    __int16 v41 = [NSString stringWithUTF8String:"ULLocalizingWifiMaxAgeFirstScan"];
    uint64_t v42 = [v40 objectForKey:v41];
    if (v42 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      int v43 = [v42 intValue];
    }
    else {
      int v43 = [&unk_2704F1B60 intValue];
    }
    int v44 = v43;

    if (v10)
    {
      uint64_t v50 = 0;
      do
      {
        uint64_t v51 = *(unsigned int *)(*a2 + v50);
        unint64_t v52 = [ULWiFiScanChannel alloc];
        if (v51 <= 0xD) {
          uint64_t v53 = 1;
        }
        else {
          uint64_t v53 = 2;
        }
        uint64_t v54 = [(ULWiFiScanChannel *)v52 initWithBand:v53 andChannelNumber:v51];
        [v8 addObject:v54];

        v50 += 8;
        --v10;
      }
      while (v10);
    }
LABEL_45:
    if (v22) {
      uint64_t v55 = 110;
    }
    else {
      uint64_t v55 = 50;
    }
    uint64_t v56 = +[ULDefaultsSingleton shared];
    int v57 = [v56 defaultsDictionary];

    int v58 = [NSString stringWithUTF8String:"ULWifiMaxAgeNextScan"];
    long long v59 = [v57 objectForKey:v58];
    if (v59 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
      int v60 = [v59 intValue];
    }
    else {
      int v60 = [&unk_2704F1B60 intValue];
    }
    int v61 = v60;

    int v62 = [ULWiFiScanStrategy alloc];
    char v63 = [MEMORY[0x263EFF8C0] arrayWithArray:v8];
    *(_WORD *)((char *)&v65 + 1) = 0;
    LOBYTE(v65) = v33;
    unint64_t v21 = -[ULWiFiScanStrategy initWithChannels:scanType:numberOfScans:scanIterations:restTime:dwellTime:acceptableCacheAge:maximumAge:isLowPriority:isLowLatency:doAbortOngoingScan:](v62, "initWithChannels:scanType:numberOfScans:scanIterations:restTime:dwellTime:acceptableCacheAge:maximumAge:isLowPriority:isLowLatency:doAbortOngoingScan:", v63, v22, 1, v66, 40, v55, 1000 * v61, 1000 * v44, v65);

    goto LABEL_53;
  }
  unint64_t v21 = 0;
LABEL_53:

  return v21;
}

void sub_25643CB5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ULSettings::get<ULSettings::LocalizingTopChannels>(std::vector<int> *a1@<X8>)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  double v2 = +[ULDefaultsSingleton shared];
  uint64_t v35 = [v2 defaultsDictionary];

  char v33 = [NSString stringWithUTF8String:"ULLocalizingTopChannels"];
  long long v34 = objc_msgSend(v35, "objectForKey:");
  if (v34 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    memset(&v36, 0, sizeof(v36));
    id v32 = v34;
    std::vector<CLMicroLocationProto::ConfidenceLevel>::reserve(&v36, [v32 count]);
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    id v3 = v32;
    uint64_t v4 = [v3 countByEnumeratingWithState:&v37 objects:&v41 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v38;
      do
      {
        for (uint64_t i = 0; i != v4; ++i)
        {
          if (*(void *)v38 != v5) {
            objc_enumerationMutation(v3);
          }
          int v7 = [*(id *)(*((void *)&v37 + 1) + 8 * i) intValue];
          int v8 = v7;
          std::vector<int>::pointer end = v36.__end_;
          if (v36.__end_ >= v36.__end_cap_.__value_)
          {
            std::vector<int>::pointer begin = v36.__begin_;
            int64_t v12 = v36.__end_ - v36.__begin_;
            unint64_t v13 = v12 + 1;
            if ((unint64_t)(v12 + 1) >> 62) {
              std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
            }
            int64_t v14 = (char *)v36.__end_cap_.__value_ - (char *)v36.__begin_;
            if (((char *)v36.__end_cap_.__value_ - (char *)v36.__begin_) >> 1 > v13) {
              unint64_t v13 = v14 >> 1;
            }
            if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v15 = v13;
            }
            if (v15)
            {
              double v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v36.__end_cap_, v15);
              std::vector<int>::pointer begin = v36.__begin_;
              std::vector<int>::pointer end = v36.__end_;
            }
            else
            {
              double v16 = 0;
            }
            __int16 v17 = (int *)&v16[4 * v12];
            int *v17 = v8;
            unint64_t v10 = v17 + 1;
            while (end != begin)
            {
              int v18 = *--end;
              *--__int16 v17 = v18;
            }
            v36.__begin_ = v17;
            v36.__end_ = v10;
            v36.__end_cap_.__value_ = (int *)&v16[4 * v15];
            if (begin) {
              operator delete(begin);
            }
          }
          else
          {
            *v36.__end_ = v7;
            unint64_t v10 = end + 1;
          }
          v36.__end_ = v10;
        }
        uint64_t v4 = [v3 countByEnumeratingWithState:&v37 objects:&v41 count:16];
      }
      while (v4);
    }

    *a1 = v36;
  }
  else
  {
    memset(&v41, 0, sizeof(v41));
    std::vector<CLMicroLocationProto::ConfidenceLevel>::reserve(&v41, 5uLL);
    uint64_t v19 = &_ZGRN10ULSettings14SettingsTraitsINS_21LocalizingTopChannelsEE12defaultValueE_;
    std::vector<int>::pointer v20 = v41.__end_;
    do
    {
      int v21 = *v19;
      if (v20 >= v41.__end_cap_.__value_)
      {
        std::vector<int>::pointer v22 = v41.__begin_;
        uint64_t v23 = v20 - v41.__begin_;
        unint64_t v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 62) {
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        }
        int64_t v25 = (char *)v41.__end_cap_.__value_ - (char *)v41.__begin_;
        if (((char *)v41.__end_cap_.__value_ - (char *)v41.__begin_) >> 1 > v24) {
          unint64_t v24 = v25 >> 1;
        }
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v24;
        }
        if (v26)
        {
          char v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v41.__end_cap_, v26);
          std::vector<int>::pointer v22 = v41.__begin_;
          std::vector<int>::pointer v20 = v41.__end_;
        }
        else
        {
          char v27 = 0;
        }
        uint64_t v28 = (int *)&v27[4 * v23];
        *uint64_t v28 = v21;
        unsigned int v29 = v28 + 1;
        while (v20 != v22)
        {
          int v30 = *--v20;
          *--uint64_t v28 = v30;
        }
        v41.__begin_ = v28;
        v41.__end_ = v29;
        v41.__end_cap_.__value_ = (int *)&v27[4 * v26];
        if (v22) {
          operator delete(v22);
        }
        std::vector<int>::pointer v20 = v29;
      }
      else
      {
        *v20++ = v21;
      }
      v41.__end_ = v20;
      ++v19;
    }
    while (v19 != (int *)&unk_256519F6C);
    char value = v41.__end_cap_.__value_;
    a1->__begin_ = v41.__begin_;
    a1->__end_ = v20;
    a1->__end_cap_.__value_ = value;
  }
}

void sub_25643D088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, void *a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t ULWiFiStrategyBuilder::expectedScanDuration(ULWiFiStrategyBuilder *this, const ULWiFiScanStrategy *a2)
{
  double v2 = this;
  id v3 = v2;
  if (v2)
  {
    uint64_t v4 = [(ULWiFiStrategyBuilder *)v2 channels];
    uint64_t v5 = [v4 count];
    uint64_t v6 = [(ULWiFiStrategyBuilder *)v3 numberOfScans];

    uint64_t v7 = [(ULWiFiStrategyBuilder *)v3 dwellTimeMilliSeconds];
    uint64_t v8 = v6
       * v5
       * (uint64_t)(double)(unint64_t)([(ULWiFiStrategyBuilder *)v3 restTimeInMilliSeconds]+ v7);
  }
  else
  {
    uint64_t v8 = 0;
  }

  return v8;
}

void sub_25643D1C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643D288(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643D5BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  _Unwind_Resume(a1);
}

void sub_25643D728(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643D8E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643DA40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643DC04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643DC88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_25643DD70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643DF24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  CLMicroLocationProto::WiFiRssi::~WiFiRssi((CLMicroLocationProto::WiFiRssi *)&a16);
  _Unwind_Resume(a1);
}

void sub_25643E0D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643E170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643E21C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_25643E6A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,void **a21)
{
  a21 = (void **)&a18;
  std::vector<CLMiLoProtobufWrapper::WiFiRssi>::__destroy_vector::operator()[abi:ne180100](&a21);

  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMiLoProtobufWrapper::WiFiRssi>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x492492492492493) {
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::WiFiRssi>>(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    void v7[3] = v7[0] + 56 * v6;
    std::vector<CLMiLoProtobufWrapper::WiFiRssi>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CLMiLoProtobufWrapper::WiFiRssi>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_25643E804(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMiLoProtobufWrapper::WiFiRssi>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_25643E8E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_25643EA08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_57()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

void std::vector<CLMiLoProtobufWrapper::WiFiRssi>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  double v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        CLMicroLocationProto::WiFiRssi::~WiFiRssi((CLMicroLocationProto::WiFiRssi *)(v4 - 56));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<CLMiLoProtobufWrapper::WiFiRssi>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::WiFiRssi>,std::reverse_iterator<CLMiLoProtobufWrapper::WiFiRssi*>,std::reverse_iterator<CLMiLoProtobufWrapper::WiFiRssi*>,std::reverse_iterator<CLMiLoProtobufWrapper::WiFiRssi*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::WiFiRssi>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(56 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::WiFiRssi>,std::reverse_iterator<CLMiLoProtobufWrapper::WiFiRssi*>,std::reverse_iterator<CLMiLoProtobufWrapper::WiFiRssi*>,std::reverse_iterator<CLMiLoProtobufWrapper::WiFiRssi*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    do
    {
      CLMicroLocationProto::WiFiRssi::WiFiRssi((CLMicroLocationProto::WiFiRssi *)(a7 + v11 - 56), (const CLMicroLocationProto::WiFiRssi *)(a3 + v11 - 56));
      *(_DWORD *)(a7 + v11 - 8) = *(_DWORD *)(a3 + v11 - 8);
      v11 -= 56;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_25643EC4C(_Unwind_Exception *exception_object)
{
  for (; v2; v2 += 56)
    CLMicroLocationProto::WiFiRssi::~WiFiRssi((CLMicroLocationProto::WiFiRssi *)(v1 + v2));
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<CLMiLoProtobufWrapper::WiFiRssi>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    CLMicroLocationProto::WiFiRssi::~WiFiRssi((CLMicroLocationProto::WiFiRssi *)(i - 56));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::vector<CLMiLoProtobufWrapper::WiFiRssi>::__emplace_back_slow_path<CLMiLoProtobufWrapper::WiFiRssi>(uint64_t *a1, const CLMicroLocationProto::WiFiRssi *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492) {
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249) {
    unint64_t v9 = 0x492492492492492;
  }
  else {
    unint64_t v9 = v5;
  }
  __int16 v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::WiFiRssi>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v13 = v10;
  int64_t v14 = (CLMicroLocationProto::WiFiRssi *)&v10[56 * v4];
  unint64_t v15 = v14;
  double v16 = &v10[56 * v9];
  CLMicroLocationProto::WiFiRssi::WiFiRssi(v14, a2);
  *((_DWORD *)v14 + 12) = *((_DWORD *)a2 + 12);
  unint64_t v15 = (CLMicroLocationProto::WiFiRssi *)((char *)v15 + 56);
  std::vector<CLMiLoProtobufWrapper::WiFiRssi>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<CLMiLoProtobufWrapper::WiFiRssi>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_25643EDD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<CLMiLoProtobufWrapper::WiFiRssi>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL CLMicroLocationFingerprintVector::Iterator::operator!=(void *a1, void *a2)
{
  return *a1 != *a2 || a1[1] != a2[1];
}

uint64_t CLMicroLocationFingerprintVector::Iterator::operator*(void *a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)*a1 + 24))(*a1, a1[1]);
}

uint64_t CLMicroLocationFingerprintVector::Iterator::operator++(uint64_t result)
{
  return result;
}

void *CLMicroLocationFingerprintVector::CLMicroLocationFingerprintVector(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *uint64_t result = v2;
  return result;
}

uint64_t CLMicroLocationFingerprintVector::operator[](void *a1, unint64_t a2)
{
  if ((*(uint64_t (**)(void))(*(void *)*a1 + 16))(*a1) <= a2)
  {
    unint64_t v5 = (CLMicroLocationFingerprintVector *)CLMicroLocationFingerprintVector::operator[]();
    return CLMicroLocationFingerprintVector::size(v5);
  }
  else
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)*a1 + 24);
    return v3();
  }
}

uint64_t CLMicroLocationFingerprintVector::size(CLMicroLocationFingerprintVector *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 16))();
}

BOOL CLMicroLocationFingerprintVector::empty(CLMicroLocationFingerprintVector *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 16))(*(void *)this) == 0;
}

uint64_t CLMicroLocationFingerprintVector::begin(CLMicroLocationFingerprintVector *this)
{
  return *(void *)this;
}

uint64_t CLMicroLocationFingerprintVector::end(CLMicroLocationFingerprintVector *this)
{
  uint64_t v1 = *(void *)this;
  (*(void (**)(void))(**(void **)this + 16))(*(void *)this);
  return v1;
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_58()
{
  os_log_t v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  uint64_t v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;
}

uint64_t CLMicroLocationMeasurementTable::Entry::Entry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CLMicroLocationProto::Measurement *a5, uint64_t a6, double a7)
{
  *(void *)a1 = a2;
  *(void *)(a1 + ++*(void *)(result + 8) = a3;
  *(double *)(a1 + 16) = a7;
  *(void *)(a1 + 24) = a4;
  CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)(a1 + 32), a5);
  if ((a6 & 0xFF00000000) != 0) {
    int v9 = a6;
  }
  else {
    int v9 = 0;
  }
  *(_DWORD *)(a1 + 112) = v9;
  return a1;
}

uint64_t CLMicroLocationMeasurementTable::Entry::Entry(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)(a1 + 32));
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  CLMicroLocationProto::Measurement::Swap(v4, (CLMicroLocationProto::Measurement *)(a2 + 32));
  return a1;
}

void sub_25643F138(_Unwind_Exception *a1)
{
  CLMicroLocationProto::Measurement::~Measurement(v1);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationMeasurementTable::Entry::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  CLMicroLocationProto::Measurement::Swap((CLMicroLocationProto::Measurement *)(a1 + 32), (CLMicroLocationProto::Measurement *)(a2 + 32));
  return a1;
}

void sub_25643F718(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void *CLMicroLocationSensorsLogic::State::isAssociatedToWifi(CLMicroLocationSensorsLogic::State *this)
{
  uint64_t result = (void *)*((void *)this + 22);
  if (result) {
    return (void *)[result isAssociated];
  }
  return result;
}

id CLMicroLocationSensorsLogic::State::currentAssociatedWiFiAPInfo(id *this)
{
  return this[22];
}

void CLMicroLocationSensorsLogic::State::setBleSpyscanSessionRunning(CLMicroLocationSensorsLogic::State *this, int a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
  }
  uint64_t v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = "not running";
    if (a2) {
      unint64_t v5 = "running";
    }
    int v6 = 136446210;
    uint64_t v7 = v5;
    _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "BLE spyscan session set to %{public}s", (uint8_t *)&v6, 0xCu);
  }
  *((unsigned char *)this + 169) = a2;
}

void CLMicroLocationSensorsLogic::State::setRangingSessionRunning(CLMicroLocationSensorsLogic::State *this, int a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
  }
  uint64_t v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = "stopped";
    if (a2) {
      unint64_t v5 = "running";
    }
    int v6 = 136446210;
    uint64_t v7 = v5;
    _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "Ranging session set to %{public}s", (uint8_t *)&v6, 0xCu);
  }
  *((unsigned char *)this + 170) = a2;
}

uint64_t CLMicroLocationSensorsLogic::State::receivedWiFiScanError(CLMicroLocationSensorsLogic::State *this)
{
  return *((unsigned __int8 *)this + 184);
}

BOOL CLMicroLocationSensorsLogic::State::isNiSessionStateResumedForRequiredPeriod(uint64_t a1, double a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a1 + 192);
  CFAbsoluteTime v5 = cl::chrono::CFAbsoluteTimeClock::now();
  double v6 = *(double *)(a1 + 200);
  double v7 = v5 - v6;
  if (v6 == -1.79769313e308)
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
    }
    uint64_t v12 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      int v15 = 67240192;
      int v16 = v4;
      int v9 = "Ni Session is in state %{public}d since start";
      unint64_t v10 = v12;
      uint32_t v11 = 8;
      goto LABEL_10;
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1) {
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
    }
    uint64_t v8 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      int v15 = 67240448;
      int v16 = v4;
      __int16 v17 = 2050;
      double v18 = v7;
      int v9 = "Ni Session is in state %{public}d for the last %{public}0.3Lfs";
      unint64_t v10 = v8;
      uint32_t v11 = 18;
LABEL_10:
      _os_log_impl(&dword_25631F000, v10, OS_LOG_TYPE_DEBUG, v9, (uint8_t *)&v15, v11);
    }
  }
  return v7 >= a2 && v4 == 1;
}

void CLMicroLocationSensorsLogic::State::setMotionSessionState(CLMicroLocationSensorsLogic::State *this, int a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
  }
  int v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    CFAbsoluteTime v5 = "stopped";
    if (a2) {
      CFAbsoluteTime v5 = "running";
    }
    int v6 = 136446210;
    double v7 = v5;
    _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "Motion fence set to %{public}s", (uint8_t *)&v6, 0xCu);
  }
  *((unsigned char *)this + 171) = a2;
}

void CLMicroLocationSensorsLogic::State::setOdometryMonitoringRunning(CLMicroLocationSensorsLogic::State *this, int a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
  }
  int v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    CFAbsoluteTime v5 = "stopped";
    if (a2) {
      CFAbsoluteTime v5 = "running";
    }
    int v6 = 136446210;
    double v7 = v5;
    _os_log_impl(&dword_25631F000, v4, OS_LOG_TYPE_DEFAULT, "Odometery monitoring set to %{public}s", (uint8_t *)&v6, 0xCu);
  }
  *((unsigned char *)this + 172) = a2;
}

void CLMicroLocationSensorsLogic::CLMicroLocationSensorsLogic(CLMicroLocationSensorsLogic *this, CLMicroLocationLogic *a2, ULDatabase *a3)
{
  *(void *)this = &unk_2704E0450;
  double v6 = CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationSensorsLogic *)((char *)this + 8));
  *((unsigned char *)this + 153) = 2;
  *((unsigned char *)this + 160) = 0;
  *((unsigned char *)this + 16++*(void *)(result + 8) = 0;
  *((void *)this + 23) = 0;
  *((_WORD *)this + 96) = 0;
  *((_DWORD *)this + 50) = 0;
  *((_DWORD *)this + 44) = 0;
  *((unsigned char *)this + 180) = 0;
  *((void *)this + 26) = 0xFFEFFFFFFFFFFFFFLL;
  *((unsigned char *)this + 216) = 0;
  *((void *)this + 2++*(void *)(result + 8) = a2;
  *((void *)this + 29) = a3;
  CLMicroLocationSensorsDriver::CLMicroLocationSensorsDriver((char *)this + 240, this, v6);
  *((_DWORD *)this + 114) = 0;
  *((unsigned char *)this + 460) = 0;
  *((void *)this + 5++*(void *)(result + 8) = this;
  double v7 = +[ULDefaultsSingleton shared];
  uint64_t v8 = [v7 defaultsDictionary];

  int v9 = [NSString stringWithUTF8String:"ULWifiTimestampJitterThreshold"];
  unint64_t v10 = [v8 objectForKey:v9];
  if (v10 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    int v11 = [v10 intValue];
  }
  else {
    int v11 = [&unk_2704F1C80 intValue];
  }
  int v12 = v11;

  CLMicroLocationScanBuffer::CLMicroLocationScanBuffer((uint64_t)this + 472, (double)v12 / 1000.0);
  unint64_t v13 = +[ULDefaultsSingleton shared];
  int64_t v14 = [v13 defaultsDictionary];

  int v15 = [NSString stringWithUTF8String:"ULBleScanBufferSize"];
  int v16 = [v14 objectForKey:v15];
  if (v16 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v17 = [v16 unsignedLongValue];
  }
  else {
    uint64_t v17 = [&unk_2704F1BC0 unsignedLongValue];
  }
  uint64_t v18 = v17;

  std::string::basic_string[abi:ne180100]<0>(&__p, "Microlocation Ble rssi buffer");
  CLEventsBuffer<CLMicroLocationProto::Measurement,double,ProtoMeasurementGetTime>::CLEventsBuffer((uint64_t)this + 512, v18, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v19 = +[ULDefaultsSingleton shared];
  std::vector<int>::pointer v20 = [v19 defaultsDictionary];

  int v21 = [NSString stringWithUTF8String:"ULUwbRangeBufferSize"];
  std::vector<int>::pointer v22 = [v20 objectForKey:v21];
  if (v22 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    uint64_t v23 = [v22 unsignedLongValue];
  }
  else {
    uint64_t v23 = [&unk_2704F1BD8 unsignedLongValue];
  }
  uint64_t v24 = v23;

  std::string::basic_string[abi:ne180100]<0>(&__str, "Microlocation Uwb range buffer");
  CLEventsBuffer<CLMicroLocationProto::Measurement,double,ProtoMeasurementGetTime>::CLEventsBuffer((uint64_t)this + 576, v24, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  *((_WORD *)this + 32++*(void *)(result + 8) = 0;
  *((_OWORD *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *((_DWORD *)this + 17++*(void *)(result + 8) = 1065353216;
  int64_t v25 = +[ULDefaultsSingleton shared];
  unint64_t v26 = [v25 defaultsDictionary];

  char v27 = [NSString stringWithUTF8String:"ULMaxBleIdentityNumber"];
  uint64_t v28 = [v26 objectForKey:v27];
  if (v28 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    unsigned int v29 = [v28 unsignedIntValue];
  }
  else {
    unsigned int v29 = [&unk_2704F1BD8 unsignedIntValue];
  }
  unsigned int v30 = v29;

  *((void *)this + 90) = v30;
  *(_OWORD *)((char *)this + 72++*(void *)(result + 8) = 0u;
  *((_DWORD *)this + 186) = 0;
}

void sub_256440C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CLMicroLocationSensorsDriver *a10, CLMicroLocationProto::RecordingEvent *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24)
{
  std::__hash_table<CLMicroLocationUtils::BleIdentityItem,CLMicroLocationUtils::BleIdentityItem::HashItem,CLMicroLocationUtils::BleIdentityItem::PredicateItem,std::allocator<CLMicroLocationUtils::BleIdentityItem>>::~__hash_table((uint64_t)(v24 + 85));
  CLEventsBuffer<CLMicroLocationProto::Measurement,double,ProtoMeasurementGetTime>::~CLEventsBuffer(v26);
  CLEventsBuffer<CLMicroLocationProto::Measurement,double,ProtoMeasurementGetTime>::~CLEventsBuffer(v25);
  std::vector<CLMiLoProtobufWrapper::WiFiRssi>::__destroy_vector::operator()[abi:ne180100]((void ***)&a24);
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver(a10);

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(a11);
  _Unwind_Resume(a1);
}

void sub_256440D88()
{
}

void sub_256440D90()
{
}

uint64_t CLEventsBuffer<CLMicroLocationProto::Measurement,double,ProtoMeasurementGetTime>::~CLEventsBuffer(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  std::__tree<CLMicroLocationProto::Measurement,CLEventsBuffer<CLMicroLocationProto::Measurement,double,ProtoMeasurementGetTime>::EventsComparator,std::allocator<CLMicroLocationProto::Measurement>>::destroy(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

void CLMicroLocationSensorsLogic::~CLMicroLocationSensorsLogic(CLMicroLocationSensorsLogic *this)
{
  *(void *)this = &unk_2704E0450;
  if (*((unsigned char *)this + 656) == 1 || *((unsigned char *)this + 657) == 1)
  {
    CLMicroLocationSensorsDriver::stopBleRssiSession((CLMicroLocationSensorsLogic *)((char *)this + 240));
    *((_WORD *)this + 32++*(void *)(result + 8) = 0;
    [*((id *)this + 83) invalidate];
  }
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
  }
  uint64_t v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl(&dword_25631F000, v2, OS_LOG_TYPE_DEFAULT, "CLMicroLocationSensorsLogic: DTOR", v3, 2u);
  }
  std::__hash_table<CLMicroLocationUtils::BleIdentityItem,CLMicroLocationUtils::BleIdentityItem::HashItem,CLMicroLocationUtils::BleIdentityItem::PredicateItem,std::allocator<CLMicroLocationUtils::BleIdentityItem>>::~__hash_table((uint64_t)this + 680);

  if (*((char *)this + 631) < 0) {
    operator delete(*((void **)this + 76));
  }
  std::__tree<CLMicroLocationProto::Measurement,CLEventsBuffer<CLMicroLocationProto::Measurement,double,ProtoMeasurementGetTime>::EventsComparator,std::allocator<CLMicroLocationProto::Measurement>>::destroy((uint64_t)this + 584, *((void **)this + 74));
  if (*((char *)this + 567) < 0) {
    operator delete(*((void **)this + 68));
  }
  std::__tree<CLMicroLocationProto::Measurement,CLEventsBuffer<CLMicroLocationProto::Measurement,double,ProtoMeasurementGetTime>::EventsComparator,std::allocator<CLMicroLocationProto::Measurement>>::destroy((uint64_t)this + 520, *((void **)this + 66));
  int v4 = (void **)((char *)this + 472);
  std::vector<CLMiLoProtobufWrapper::WiFiRssi>::__destroy_vector::operator()[abi:ne180100](&v4);
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsLogic *)((char *)this + 240));

  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationSensorsLogic *)((char *)this + 8));
}

{
  uint64_t vars8;

  CLMicroLocationSensorsLogic::~CLMicroLocationSensorsLogic(this);
  JUMPOUT(0x25A2A6340);
}

uint64_t CLMicroLocationSensorsLogic::onRecordingOrLocalizingInterrupted(CLMicroLocationSensorsLogic *this)
{
  if (onceToken_MicroLocation_Default != -1) {
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
  }
  uint64_t v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFAbsoluteTime v5 = 0;
    _os_log_impl(&dword_25631F000, v2, OS_LOG_TYPE_DEFAULT, "Cancel a requested scan", v5, 2u);
  }
  if (*((unsigned char *)this + 657) == 1)
  {
    int v3 = *((unsigned __int8 *)this + 656);
    CLMicroLocationSensorsDriver::stopBleRssiSession((CLMicroLocationSensorsLogic *)((char *)this + 240));
    *((_WORD *)this + 32++*(void *)(result + 8) = 0;
    [*((id *)this + 83) invalidate];
    if (v3 == 2) {
      CLMicroLocationSensorsLogic::onStartBackgroundSession(this);
    }
  }
  uint64_t result = CLMicroLocationSensorsDriver::cancelWifiScan((CLMicroLocationSensorsLogic *)((char *)this + 240));
  if (*((unsigned char *)this + 216))
  {
    uint64_t result = CLMicroLocationSensorsDriver::resetRangingRate((CLMicroLocationSensorsLogic *)((char *)this + 240));
    *((unsigned char *)this + 216) = 0;
  }
  return result;
}

void CLMicroLocationSensorsLogic::onStartBackgroundSession(CLMicroLocationSensorsLogic *this)
{
  if ([*((id *)this + 81) count]) {
    BOOL v2 = *((unsigned char *)this + 179) != 0;
  }
  else {
    BOOL v2 = 0;
  }
  uint64_t v3 = *((void *)this + 81);
  memset(v4, 0, sizeof(v4));
  CLMicroLocationUtils::BleScanConfiguration::BleScanConfiguration(v5, 0, 1, v2, v3, v4, 0.0);
  uint64_t v8 = (void **)v4;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v8);
  CLMicroLocationSensorsLogic::startBleRssiSession(this, (const CLMicroLocationUtils::BleScanConfiguration *)v5);
  uint64_t v8 = (void **)&v7;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v8);
}

void sub_256441104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  CLMicroLocationUtils::BleScanConfiguration::~BleScanConfiguration((id *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationSensorsLogic::updateTriggerMetrics(id *this, NSMutableDictionary *a2, uint64_t a3)
{
  int v9 = a2;
  if (v9)
  {
    CFAbsoluteTime v5 = objc_msgSend(NSNumber, "numberWithUnsignedInteger:", objc_msgSend(this[81], "count"));
    [(NSMutableDictionary *)v9 setObject:v5 forKeyedSubscript:@"BleIdentitiesFamilyCount"];

    id v6 = [NSNumber numberWithUnsignedLong:this[88]];
    [(NSMutableDictionary *)v9 setObject:v6 forKeyedSubscript:@"BleIdentitiesSameAccountCount"];

    uint64_t v7 = objc_msgSend(NSNumber, "numberWithUnsignedLong:", (char *)this[88] + objc_msgSend(this[81], "count"));
    [(NSMutableDictionary *)v9 setObject:v7 forKeyedSubscript:@"BleIdentitiesTotal"];

    uint64_t v8 = [NSNumber numberWithBool:a3];
    [(NSMutableDictionary *)v9 setObject:v8 forKeyedSubscript:@"BleIsScanRequested"];
  }
}

void sub_256441250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}