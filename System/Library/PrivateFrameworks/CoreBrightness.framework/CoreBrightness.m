uint64_t _DisplayCompareFloats(float *a1, float *a2)
{
  if (*a1 >= *a2) {
    return *a1 > *a2;
  }
  else {
    return -1;
  }
}

float AABC::calculate95thPercentile(AABC *this, AABC::ALSFilter *a2)
{
  v7[4] = (uint64_t)this;
  v7[3] = (uint64_t)a2;
  std::vector<float>::vector(v7, (uint64_t *)a2);
  uint64_t v6 = std::vector<float>::begin[abi:ne180100](v7);
  uint64_t v5 = std::vector<float>::end[abi:ne180100]((uint64_t)v7);
  std::sort[abi:ne180100]<std::__wrap_iter<float *>>(v6, v5);
  uint64_t v2 = std::vector<float>::size[abi:ne180100](v7);
  float v4 = *(float *)std::vector<float>::operator[][abi:ne180100](v7, (unsigned __int16)(vcvtpd_u64_f64((double)(unint64_t)v2 * 0.95) - 1));
  std::vector<float>::~vector[abi:ne180100](v7);
  return v4;
}

void sub_1BA43A194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, _Unwind_Exception *exception_object)
{
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)(v16 - 40));
  _Unwind_Resume(a1);
}

uint64_t *std::vector<float>::~vector[abi:ne180100](uint64_t *a1)
{
  return a1;
}

{
  uint64_t *v3[2];

  v3[1] = a1;
  std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](v3, (uint64_t)a1);
  std::vector<float>::__destroy_vector::operator()[abi:ne180100](v3);
  return a1;
}

void std::vector<float>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  if (**a1)
  {
    std::vector<float>::__clear[abi:ne180100](*a1);
    std::vector<float>::__annotate_delete[abi:ne180100]();
    std::vector<float>::__alloc[abi:ne180100]();
    uint64_t v3 = v1;
    uint64_t v2 = (void *)**a1;
    std::vector<float>::capacity[abi:ne180100](*a1);
    std::allocator_traits<std::allocator<float>>::deallocate[abi:ne180100](v3, v2);
  }
}

void std::vector<float>::__clear[abi:ne180100](uint64_t *a1)
{
}

void std::allocator_traits<std::allocator<float>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

void std::allocator<float>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

void std::__libcpp_deallocate[abi:ne180100](void *a1)
{
}

void std::__do_deallocate_handle_size[abi:ne180100]<>(void *a1)
{
}

void std::__libcpp_operator_delete[abi:ne180100]<void *>(void *a1)
{
}

uint64_t std::vector<float>::capacity[abi:ne180100](void *a1)
{
  std::vector<float>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 4;
}

void std::vector<float>::__end_cap[abi:ne180100]()
{
}

{
  std::__compressed_pair<float *>::first[abi:ne180100]();
}

void std::__compressed_pair<float *>::first[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<float *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<float *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<float *,0,false>::__get[abi:ne180100]();
}

void std::sort[abi:ne180100]<std::__wrap_iter<float *>>(uint64_t a1, uint64_t a2)
{
}

void std::sort[abi:ne180100]<std::__wrap_iter<float *>,std::__less<void,void>>(uint64_t a1, uint64_t a2)
{
}

void std::__sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<float *>,std::__less<void,void>>(uint64_t a1, uint64_t a2)
{
}

void std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<float *>,std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>,0>(uint64_t a1)
{
}

void std::__unwrap_iter_impl<std::__wrap_iter<float *>,true>::__unwrap[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = a1;
  std::__to_address[abi:ne180100]<std::__wrap_iter<float *>,void>(&v1);
}

void std::__to_address[abi:ne180100]<std::__wrap_iter<float *>,void>(uint64_t *a1)
{
}

void std::__to_address_helper<std::__wrap_iter<float *>,void>::__call[abi:ne180100](uint64_t *a1)
{
}

void std::pointer_traits<std::__wrap_iter<float *>>::to_address[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = a1;
  std::__wrap_iter<float *>::base[abi:ne180100]((uint64_t)&v1);
  std::__to_address[abi:ne180100]<float>();
}

uint64_t std::__wrap_iter<float *>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::__sort_dispatch[abi:ne180100]<std::_ClassicAlgPolicy,float,0>()
{
  return std::__sort<std::__less<float,float> &,float *>();
}

void *std::vector<float>::vector(void *a1, uint64_t *a2)
{
  return a1;
}

{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;

  *a1 = 0;
  a1[1] = 0;
  std::vector<float>::__alloc[abi:ne180100]();
  std::allocator_traits<std::allocator<float>>::select_on_container_copy_construction[abi:ne180100]<std::allocator<float>,void,void>();
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float>>(a1 + 2);
  float v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v2 = std::vector<float>::size[abi:ne180100](a2);
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, v4, v5, v2);
  return a1;
}

uint64_t std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v11 = a1;
  uint64_t v10 = a2;
  uint64_t v9 = a3;
  unint64_t v8 = a4;
  std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](&v6, (uint64_t)a1);
  std::__make_exception_guard[abi:ne180100]<std::vector<float>::__destroy_vector>(v6, (uint64_t)v7);
  if (v8)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, v8);
    std::vector<float>::__construct_at_end<float *,float *>((uint64_t)a1, v10, v9, v8);
  }
  std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__complete[abi:ne180100]((uint64_t)v7);
  return std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v7);
}

void *std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void *std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](void *result, uint64_t a2)
{
  *result = a2;
  return result;
}

void *std::vector<float>::__construct_at_end<float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a1;
  uint64_t v10 = a2;
  uint64_t v9 = a3;
  uint64_t v8 = a4;
  std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, a4);
  std::vector<float>::__alloc[abi:ne180100]();
  uint64_t v7 = std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<float>,float *,float *,float *>(v4, v10, v9, v7);
  return std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1BA43A994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
}

void *std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](void *a1)
{
  return a1;
}

void *std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](void *result)
{
  *(void *)(*result + 8) = result[1];
  return result;
}

void *std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

void *std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *result, uint64_t a2, uint64_t a3)
{
  *result = a2;
  result[1] = *(void *)(a2 + 8);
  result[2] = *(void *)(a2 + 8) + 4 * a3;
  return result;
}

void std::vector<float>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 > std::vector<float>::max_size((uint64_t)a1)) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  std::vector<float>::__alloc[abi:ne180100]();
  uint64_t v7 = std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v2, a2);
  *a1 = v7;
  a1[1] = v7;
  uint64_t v5 = *a1 + 4 * v3;
  std::vector<float>::__end_cap[abi:ne180100]();
  *uint64_t v4 = v5;
  std::vector<float>::__annotate_new[abi:ne180100]();
}

uint64_t std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<float>,float *,float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = std::__unwrap_range[abi:ne180100]<float *,float *>(a2, a3);
  uint64_t v8 = v4;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  uint64_t v6 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<float>,float,float,float,(void *)0>(a1, v9, v8, v5);
  return std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(a4, v6);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<float>,float,float,float,(void *)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::copy[abi:ne180100]<float *,float *>(a2, a3, a4);
}

uint64_t std::copy[abi:ne180100]<float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,float *,float *,float *>(a1, a2, a3);
  return v3;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,float *,float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,float *,float *,float *>(a1, a2, a3);
}

uint64_t std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  return a1;
}

{
  if ((*(unsigned char *)(a1 + 8) & 1) == 0) {
    std::vector<float>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)a1);
  }
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__complete[abi:ne180100](uint64_t result)
{
  *(unsigned char *)(result + 8) = 1;
  return result;
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,float *,float *,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,float *,float *,float *,0>(a1, a2, a3);
}

uint64_t std::__make_exception_guard[abi:ne180100]<std::vector<float>::__destroy_vector>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](a2, a1);
}

uint64_t std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](uint64_t result, uint64_t a2)
{
  *(void *)result = a2;
  *(unsigned char *)(result + 8) = 0;
  return result;
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,float *,float *,float *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  v13 = (const void *)std::__unwrap_range[abi:ne180100]<float *,float *>(a1, a2);
  uint64_t v14 = v3;
  uint64_t v7 = v3;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  uint64_t v11 = std::__copy_trivial::operator()[abi:ne180100]<float,float,0>((uint64_t)&v10, v13, v7, v4);
  uint64_t v12 = v5;
  uint64_t v9 = std::__rewrap_range[abi:ne180100]<float *,float *>(v17, v11);
  uint64_t v8 = std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<float *,float *>(&v9, &v8);
}

uint64_t std::__unwrap_range[abi:ne180100]<float *,float *>(uint64_t a1, uint64_t a2)
{
  v6[2] = a1;
  v6[1] = a2;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  v6[0] = v2;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  uint64_t v5 = v3;
  return std::make_pair[abi:ne180100]<float *,float *>(v6, &v5);
}

void std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>()
{
}

void std::__unwrap_iter_impl<float *,true>::__unwrap[abi:ne180100]()
{
}

uint64_t std::make_pair[abi:ne180100]<float *,float *>(void *a1, void *a2)
{
  std::pair<float *,float *>::pair[abi:ne180100]<float *,float *,0>(&v3, a1, a2);
  return v3;
}

void *std::pair<float *,float *>::pair[abi:ne180100]<float *,float *,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<float *,float *>::pair[abi:ne180100]<float *,float *,0>(void *result, void *a2, void *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

void std::vector<float>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); a2 != i; i -= 4)
  {
    std::vector<float>::__alloc[abi:ne180100]();
    std::__to_address[abi:ne180100]<float>();
    std::allocator_traits<std::allocator<float>>::destroy[abi:ne180100]<float,void>();
  }
  *(void *)(a1 + 8) = a2;
}

void std::vector<float>::__alloc[abi:ne180100]()
{
}

{
  std::__compressed_pair<float *>::second[abi:ne180100]();
}

void std::__compressed_pair<float *>::second[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<std::allocator<float>,1,true>::__get[abi:ne180100]();
}

void std::allocator_traits<std::allocator<float>>::destroy[abi:ne180100]<float,void>()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  return std::allocator<float>::allocate[abi:ne180100](a1, a2);
}

void *std::allocator<float>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<float>>::max_size[abi:ne180100]<std::allocator<float>,void>()) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return std::__libcpp_allocate[abi:ne180100](4 * a2);
}

void *std::__libcpp_allocate[abi:ne180100](size_t a1)
{
  return std::__libcpp_operator_new[abi:ne180100]<unsigned long>(a1);
}

void *std::__libcpp_operator_new[abi:ne180100]<unsigned long>(size_t a1)
{
  return operator new(a1);
}

void *std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float>>(void *a1)
{
  return a1;
}

{
  std::__compressed_pair_elem<float *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<float>,1,true>::__compressed_pair_elem[abi:ne180100]<std::allocator<float>,void>();
  return a1;
}

void *std::__compressed_pair_elem<float *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(void *result)
{
  *result = 0;
  return result;
}

uint64_t std::__rewrap_range[abi:ne180100]<float *,float *>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(a1, a2);
}

uint64_t std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<float *,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::__unwrap_iter_impl<float *,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__to_address[abi:ne180100]<float>();
  return a1 + 4 * ((a2 - v2) / 4);
}

uint64_t std::vector<float>::max_size(uint64_t a1)
{
  v3[1] = a1;
  std::vector<float>::__alloc[abi:ne180100]();
  v3[0] = std::allocator_traits<std::allocator<float>>::max_size[abi:ne180100]<std::allocator<float>,void>();
  uint64_t v2 = std::numeric_limits<long>::max[abi:ne180100]();
  return *std::min[abi:ne180100]<unsigned long>(v3, &v2);
}

uint64_t std::allocator_traits<std::allocator<float>>::max_size[abi:ne180100]<std::allocator<float>,void>()
{
  return std::allocator<float>::max_size[abi:ne180100]();
}

uint64_t std::allocator<float>::max_size[abi:ne180100]()
{
  return 0x3FFFFFFFFFFFFFFFLL;
}

void *std::min[abi:ne180100]<unsigned long>(void *a1, void *a2)
{
  return std::min[abi:ne180100]<unsigned long,std::__less<void,void>>(a1, a2);
}

void *std::min[abi:ne180100]<unsigned long,std::__less<void,void>>(void *a1, void *a2)
{
  if (std::__less<void,void>::operator()[abi:ne180100]<unsigned long,unsigned long>((uint64_t)&v6, a2, a1)) {
    return a2;
  }
  else {
    return a1;
  }
}

uint64_t std::numeric_limits<long>::max[abi:ne180100]()
{
  return std::__libcpp_numeric_limits<long,true>::max[abi:ne180100]();
}

uint64_t std::__libcpp_numeric_limits<long,true>::max[abi:ne180100]()
{
  return 0x7FFFFFFFFFFFFFFFLL;
}

BOOL std::__less<void,void>::operator()[abi:ne180100]<unsigned long,unsigned long>(uint64_t a1, void *a2, void *a3)
{
  return *a2 < *a3;
}

uint64_t std::__copy_trivial::operator()[abi:ne180100]<float,float,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<float,float>(a2, a3, a4);
}

uint64_t std::__copy_trivial_impl[abi:ne180100]<float,float>(const void *a1, uint64_t a2, char *a3)
{
  v7[1] = a1;
  v7[0] = a2;
  char v6 = a3;
  uint64_t v5 = (a2 - (uint64_t)a1) / 4;
  std::__constexpr_memmove[abi:ne180100]<float,float,0>(a3, a1, v5);
  uint64_t v4 = &v6[4 * v5];
  return std::make_pair[abi:ne180100]<float *&,float *>(v7, &v4);
}

uint64_t std::make_pair[abi:ne180100]<float *&,float *>(void *a1, void *a2)
{
  std::pair<float *,float *>::pair[abi:ne180100]<float *&,float *,0>(&v3, a1, a2);
  return v3;
}

void *std::pair<float *,float *>::pair[abi:ne180100]<float *&,float *,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<float *,float *>::pair[abi:ne180100]<float *&,float *,0>(void *result, void *a2, void *a3)
{
  *result = *a2;
  result[1] = *a3;
  return result;
}

void *std::__constexpr_memmove[abi:ne180100]<float,float,0>(void *a1, const void *a2, uint64_t a3)
{
  if (a3) {
    memmove(a1, a2, 4 * (a3 - 1) + 4);
  }
  return a1;
}

uint64_t _CFXGetTarget(uint64_t a1, float *a2, float *a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, char a8, float a9)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v48 = a1;
  v47 = a2;
  v46 = a3;
  uint64_t v45 = a4;
  int v44 = a5;
  uint64_t v43 = a6;
  uint64_t v42 = a7;
  char v41 = a8 & 1;
  float v40 = a9;
  uint64_t v53 = 0;
  int v54 = 0;
  uint64_t v53 = *(void *)a2;
  int v54 = *((_DWORD *)a2 + 2);
  if ((a8 & 1) == 0)
  {
    unint64_t v39 = 0;
    CFXTristimulus2Chromaticity(v47, (float *)&v39);
    unint64_t v38 = v39;
    float v37 = 0.0;
    float v37 = *(float *)(v48 + 92);
    float v36 = 0.0;
    int v35 = 0;
    unint64_t v34 = 0;
    uint64_t v33 = 0;
    uint64_t v32 = 0;
    if (*(float *)&v39 < 0.0 || *(float *)&v39 > 1.0)
    {
      syslog(1, "Chromaticity NOT within the range: (x,y) (%f, %f)", *(float *)&v38, *((float *)&v38 + 1));
      LODWORD(v39) = fmaxf(*(float *)&v39, 0.0);
      LODWORD(v39) = fminf(*(float *)&v39, 1.0);
    }
    BOOL v31 = 0;
    if (*(void *)(v48 + 96)) {
      BOOL v31 = (*(unsigned char *)(*(void *)(v48 + 96) + 302) & 1) != 0;
    }
    int v30 = 9;
    if (*(float *)&v39 >= 0.0)
    {
      for (int i = 1; i < v30; ++i)
      {
        if (*(float *)&v39 <= BB_PieceWise_Table[i])
        {
          *(float *)&uint64_t v33 = BB_PieceWise_Table[i - 1];
          *((float *)&v33 + 1) = BB_PieceWise_Table[i - 1 + v30];
          *(float *)&uint64_t v32 = BB_PieceWise_Table[i];
          *((float *)&v32 + 1) = BB_PieceWise_Table[i + v30];
          float v36 = cfx_linear_interpolation((float *)&v33, (float *)&v32, *(float *)&v39);
          int v35 = i - 1;
          break;
        }
      }
    }
    if (*((float *)&v39 + 1) < v36)
    {
      float v9 = compute_projection((float *)&v33, (float *)&v32, (float *)&v39);
      unint64_t v28 = __PAIR64__(v10, LODWORD(v9));
      unint64_t v34 = __PAIR64__(v10, LODWORD(v9));
      if (v9 >= *(float *)&v33 || v35 <= 0)
      {
        if (*(float *)&v34 <= *(float *)&v32)
        {
          unint64_t v39 = v34;
        }
        else
        {
          *(float *)&uint64_t v33 = BB_PieceWise_Table[v35 + 1];
          *((float *)&v33 + 1) = BB_PieceWise_Table[v35 + 10];
          *(float *)&uint64_t v32 = BB_PieceWise_Table[v35 + 2];
          *((float *)&v32 + 1) = BB_PieceWise_Table[v35 + 11];
          float v13 = compute_projection((float *)&v33, (float *)&v32, (float *)&v39);
          unint64_t v26 = __PAIR64__(v14, LODWORD(v13));
          unint64_t v39 = __PAIR64__(v14, LODWORD(v13));
        }
      }
      else
      {
        *(float *)&uint64_t v33 = BB_PieceWise_Table[v35 - 1];
        *((float *)&v33 + 1) = BB_PieceWise_Table[v35 + 8];
        *(float *)&uint64_t v32 = BB_PieceWise_Table[v35];
        *((float *)&v32 + 1) = BB_PieceWise_Table[v35 + 9];
        float v11 = compute_projection((float *)&v33, (float *)&v32, (float *)&v39);
        unint64_t v27 = __PAIR64__(v12, LODWORD(v11));
        unint64_t v39 = __PAIR64__(v12, LODWORD(v11));
      }
    }
    if (*(float *)&v39 != *(float *)&v38 || *((float *)&v39 + 1) != *((float *)&v38 + 1)) {
      syslog(7, "CCT RESTRICTION @%fK: xy (%f, %f) -> (%f, %f)", v37, *(float *)&v38, *((float *)&v38 + 1), *(float *)&v39, *((float *)&v39 + 1));
    }
    int v25 = 1120403456;
    CFXChromaticity2Tristimulus((float *)&v39, (float *)&v53, 100.0);
    memset(v24, 0, 12);
    CFXTristimulus2Lab((float *)&v53, (float *)v24);
    if (v45)
    {
      uint64_t v23 = *(void *)((char *)v24 + 4);
      _CFXStickToPolygon(v45, v44, (float *)&dword_1BA6122BC, (float *)v24 + 1, (float *)v24 + 1);
      if (*(float *)&v23 != *((float *)v24 + 1) && *((float *)&v23 + 1) != *(float *)&v24[1]) {
        syslog(7, "Restrict: (%f, %f) -> (%f, %f)\n", *(float *)&v23, *(float *)&v23, *((float *)v24 + 1), *(float *)&v24[1]);
      }
    }
    int v22 = 0;
    float v15 = (float)(0.0 * 0.0) + (1.0 - 0.0) * *((float *)v24 + 1);
    *((float *)v24 + 1) = v15;
    float v16 = (float)(0.0 * 0.0) + (1.0 - 0.0) * *(float *)&v24[1];
    *(float *)&v24[1] = v16;
    CFXLab2Tristimulus((float *)v24, (float *)&v53);
    if (v31)
    {
      *(void *)v21 = 0;
      CFXTristimulus2Chromaticity((float *)&v53, v21);
      CFXChromaticity2uv(v21, (float *)&v52);
      uint64_t v20 = v52;
      _CFXClampToCurve((uint64_t)&MitigatedDaylightCurve, 13, (float *)&v20);
      uint64_t v52 = v20;
      CFXuv2Chromaticity((float *)&v52, v21);
      CFXChromaticity2Tristimulus(v21, (float *)&v53, *((float *)&v53 + 1));
    }
  }
  _CFXGetMatrix(v48, (float *)&v53, (uint64_t)v46, (float *)(v48 + 2128));
  v51[2] = 1.0;
  v51[1] = 1.0;
  v51[0] = 1.0;
  uint64_t v49 = 0;
  int v50 = 0;
  Mul33MatrixBy31Vector(v46, v51, (float *)&v49);
  v19 = v46;
  float v17 = MaxOfVector((float *)&v49);
  return Div33MatrixByScalar((uint64_t)v19, (uint64_t)v46, v17);
}

uint64_t CFXUpdateColorFade(uint64_t a1, double a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a1;
  double v36 = a2;
  uint64_t v35 = a1;
  char v34 = 0;
  char v33 = 0;
  char v32 = 0;
  char v31 = 0;
  char v30 = 0;
  v29 = 0;
  uint64_t v28 = mach_absolute_time();
  char v27 = 1;
  if (*(void *)(v35 + 96))
  {
    char v27 = *(unsigned char *)(*(void *)(v35 + 96) + 272) & 1;
    char v32 = _CFXUpdateStrengthFade(v36, v35, *(void *)(v35 + 96) + 256) & 1;
    if (*(unsigned char *)(*(void *)(v35 + 96) + 300))
    {
      *(unsigned char *)(*(void *)(v35 + 96) + 300) = 0;
      char v27 = 0;
    }
    if (*(unsigned char *)(*(void *)(v35 + 96) + 303))
    {
      char v27 = (v27 & 1 & *(unsigned char *)(*(void *)(v35 + 96) + 328) & 1) != 0;
      if ((*(unsigned char *)(*(void *)(v35 + 96) + 328) & 1) == 0) {
        _CFXUpdateStrengthFade(v36, v35, *(void *)(v35 + 96) + 312);
      }
    }
  }
  v29 = (double *)(v35 + 368);
  if ((*(unsigned char *)(v35 + 384) & 1) == 0 || (v27 & 1) == 0) {
    char v34 = _CFXUpdateColorFadeInternal(v35, v29, 1, v36) & 1;
  }
  v29 = (double *)(v35 + 536);
  if ((*(unsigned char *)(v35 + 552) & 1) == 0) {
    char v33 = _CFXUpdateColorFadeInternal(v35, v29, 0, v36) & 1;
  }
  memcpy(__dst, (const void *)(v35 + 592), sizeof(__dst));
  _CFXApplyTwilightNightShiftAdjustment(v35, __dst);
  if ((*(unsigned char *)(v35 + 2280) & 1) == 0) {
    char v31 = CFXAmmoliteFadeInternal(v35 + 2264, *(_DWORD *)(v35 + 360), *(void *)(v35 + 352), v36) & 1;
  }
  memcpy(v47, (const void *)(v35 + 496), sizeof(v47));
  Mul33MatrixBy33Matrix(v35 + 496, (uint64_t)__dst, (uint64_t)__src);
  if (*(void *)(v35 + 112)) {
    _CFXMagic(__src, v45, *(float **)(v35 + 112));
  }
  else {
    memcpy(v45, __src, sizeof(v45));
  }
  Mul33MatrixBy33Matrix(v35 + 2320, (uint64_t)v45, (uint64_t)__src);
  if (*(unsigned char *)(v35 + 2520))
  {
    if ((*(unsigned char *)(v35 + 2448) & 1) == 0) {
      char v30 = _CFXUpdateStrengthFade(v36, v35, v35 + 2432) & 1;
    }
    _CFXCorrectForNativeWP(v35, v44, *(float *)(v35 + 2456));
    memcpy(v43, __src, sizeof(v43));
    Mul33MatrixBy33Matrix((uint64_t)v44, (uint64_t)v43, (uint64_t)__src);
  }
  v42[2] = 1.0;
  v42[1] = 1.0;
  v42[0] = 1.0;
  uint64_t v40 = 0;
  int v41 = 0;
  Mul33MatrixBy31Vector(__src, v42, (float *)&v40);
  float v2 = MaxOfVector((float *)&v40);
  Div33MatrixByScalar((uint64_t)__src, (uint64_t)v45, v2);
  BOOL v26 = 0;
  BOOL v26 = *(float *)(v35 + 740) != *(float *)(v35 + 196);
  float v25 = 0.0;
  float v24 = 0.0;
  char v23 = 0;
  char v12 = 1;
  if ((v34 & 1) == 0)
  {
    char v12 = 1;
    if ((v33 & 1) == 0)
    {
      char v12 = 1;
      if ((v32 & 1) == 0) {
        char v12 = v31;
      }
    }
  }
  char v23 = (v12 ^ 1) & 1;
  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < 3; ++j)
    {
      float v25 = vabds_f32(v45[3 * i + j], *(float *)(v35 + 704 + 12 * i + 4 * j));
      if (v25 > v24) {
        float v24 = v25;
      }
      if (v23)
      {
        if (i == j)
        {
          if (vabdd_f64(v45[3 * i + j], 1.0) > 0.001) {
            char v23 = 0;
          }
        }
        else if (fabs(v45[3 * i + j]) > 0.001)
        {
          char v23 = 0;
        }
      }
    }
  }
  if (*(void *)(v35 + 96) && (*(unsigned char *)(*(void *)(v35 + 96) + 184) & 1) != 0) {
    char v23 = 0;
  }
  if (v23) {
    _CFXIdentity(v45);
  }
  if (v24 > 0.001 || (v23 & 1) != 0) {
    BOOL v26 = 1;
  }
  if (v26 && *(void *)(v35 + 328))
  {
    __memcpy_chk();
    *(_DWORD *)(v35 + 740) = *(_DWORD *)(v35 + 196);
    double Current = CFAbsoluteTimeGetCurrent();
    memset(__b, 0, sizeof(__b));
    float v18 = 0.0;
    *(void *)float v17 = 0;
    _CFXGetWPFromMatrix(v35, v45, v17, &v18);
    if (*(_DWORD *)(v35 + 2532) == 1)
    {
      if (*(_DWORD *)(v35 + 2528) == 1)
      {
        _CFXGetXYZD50Matrix(v35, v17, v45);
      }
      else if (!*(_DWORD *)(v35 + 2528))
      {
        _CFXGetsRGBD50Matrix(v35, v17, v45);
      }
    }
    else if (*(_DWORD *)(v35 + 2532) == 2)
    {
      if (*(_DWORD *)(v35 + 2528) == 1)
      {
        _CFXGetXYZMatrixWithLMSIlluminant(v35, v17, (float *)(v35 + 2536), v45);
      }
      else if (!*(_DWORD *)(v35 + 2528))
      {
        _CFXGetsRGBMatrixWithLMSIlluminant(v35, v17, (float *)(v35 + 2536), v45);
      }
    }
    double v3 = _CFXRampInit((uint64_t)__b, 0.0, *(float *)(v35 + 740), v17[0], v17[1], Current, (uint64_t)v45, 0);
    (*(void (**)(void, unsigned char *, double))(v35 + 328))(*(void *)(v35 + 336), __b, v3);
    if (*(unsigned char *)(v35 + 1800))
    {
      _CFXGetWPFromMatrix(v35, v47, v17, &v18);
      double v4 = _CFXRampInit((uint64_t)__b, 0.0, *(float *)(v35 + 740), v17[0], v17[1], Current, (uint64_t)v47, 2);
      (*(void (**)(void, unsigned char *, double))(v35 + 328))(*(void *)(v35 + 336), __b, v4);
      _CFXGetWPFromMatrix(v35, __dst, v17, &v18);
      double v5 = _CFXRampInit((uint64_t)__b, 0.0, *(float *)(v35 + 740), v17[0], v17[1], Current, (uint64_t)__dst, 1);
      (*(void (**)(void, unsigned char *, double))(v35 + 328))(*(void *)(v35 + 336), __b, v5);
      _CFXGetWPFromMatrix(v35, (float *)(v35 + 2320), v17, &v18);
      double v6 = _CFXRampInit((uint64_t)__b, 0.0, *(float *)(v35 + 740), v17[0], v17[1], Current, v35 + 2320, 3);
      (*(void (**)(void, unsigned char *, double))(v35 + 328))(*(void *)(v35 + 336), __b, v6);
    }
    ++*(_DWORD *)(v35 + 1792);
    if (*(unsigned char *)(v35 + 1801)) {
      ++*(_DWORD *)(v35 + 2104);
    }
    int v16 = 0;
    float v7 = 1.0 / v18;
    *(float *)(v35 + 2140) = v7;
    uint64_t v38 = 0;
    int v39 = 0;
    CFXChromaticity2Tristimulus(v17, (float *)&v38, 100.0);
    uint64_t v14 = 0;
    int v15 = 0;
    CFXTristimulus2Lab((float *)&v38, (float *)&v14);
    int v16 = binFromAb((float *)&v14 + 1);
    if (v16 != *(_DWORD *)(v35 + 1228))
    {
      double v13 = MachTimeToSeconds(v28 - *(void *)(v35 + 1232));
      float v9 = (double *)(v35 + 1024 + 8 * *(int *)(v35 + 1228));
      double v8 = *v9 + v13;
      *float v9 = v8;
      *(void *)(v35 + 1232) = v28;
      *(_DWORD *)(v35 + 1228) = v16;
      *(_DWORD *)(v35 + 320) = v16;
      ++*(_DWORD *)(v35 + 1160 + 4 * v16);
    }
    LODWORD(v8) = *(_DWORD *)(v35 + 1784);
    _CFXUpdateCompensatedBacklight(v35, v28, v8);
  }
  char v11 = 1;
  if ((v34 & 1) == 0)
  {
    char v11 = 1;
    if ((v33 & 1) == 0)
    {
      char v11 = 1;
      if ((v32 & 1) == 0)
      {
        char v11 = 1;
        if ((v31 & 1) == 0) {
          char v11 = v30;
        }
      }
    }
  }
  return v11 & 1;
}

uint64_t _CFXUpdateStrengthFade(double a1, uint64_t a2, uint64_t a3)
{
  double v7 = a1 - *(double *)(a3 + 8);
  double v6 = v7 / *(double *)a3;
  char v5 = 0;
  if (*(double *)a3 == 0.0 || v6 >= 1.0 || v7 < 0.0)
  {
    *(_DWORD *)(a3 + 24) = *(_DWORD *)(a3 + 20);
    *(void *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 1;
  }
  else
  {
    float v3 = *(float *)(a3 + 28) + v6 * (float)(*(float *)(a3 + 20) - *(float *)(a3 + 28));
    *(float *)(a3 + 24) = v3;
    char v5 = 1;
  }
  return v5 & 1;
}

uint64_t _CFXGetMatrix(uint64_t a1, float *a2, uint64_t a3, float *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  float v6 = 1.0 / a2[1];
  *a2 = *a2 * v6;
  a2[1] = a2[1] * v6;
  a2[2] = a2[2] * v6;
  uint64_t v18 = 0;
  int v19 = 0;
  CFXTristimulus2lms(a2, (float *)&v18);
  uint64_t v16 = 0;
  int v17 = 0;
  Div31VectorBy31Vector((float *)&v18, a4, (float *)&v16);
  memset(__b, 0, sizeof(__b));
  __b[4] = HIDWORD(v16);
  __b[0] = v16;
  __b[8] = v17;
  Mul33MatrixBy33Matrix((uint64_t)__b, a1 + 2144, (uint64_t)v14);
  Mul33MatrixBy33Matrix(a1 + 2180, (uint64_t)v14, (uint64_t)v13);
  v12[2] = 1.0;
  v12[1] = 1.0;
  v12[0] = 1.0;
  uint64_t v10 = 0;
  int v11 = 0;
  Mul33MatrixBy31Vector(v13, v12, (float *)&v10);
  float v4 = MaxOfVector((float *)&v10);
  return Div33MatrixByScalar((uint64_t)v13, a3, v4);
}

uint64_t Mul33MatrixBy33Matrix(uint64_t result, uint64_t a2, uint64_t a3)
{
  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < 3; ++j)
      *(float *)(a3 + 12 * i + 4 * j) = (float)((float)(*(float *)(result + 12 * i + 4)
                                                          * *(float *)(a2 + 12 + 4 * j))
                                                  + (float)(*(float *)(result + 12 * i) * *(float *)(a2 + 4 * j)))
                                          + (float)(*(float *)(result + 12 * i + 8) * *(float *)(a2 + 24 + 4 * j));
  }
  return result;
}

float MaxOfVector(float *a1)
{
  if (*a1 <= a1[1]) {
    float v3 = a1[1];
  }
  else {
    float v3 = *a1;
  }
  if (v3 <= a1[2]) {
    return a1[2];
  }
  else {
    return v3;
  }
}

uint64_t Div33MatrixByScalar(uint64_t result, uint64_t a2, float a3)
{
  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < 3; ++j)
      *(float *)(a2 + 12 * i + 4 * j) = *(float *)(result + 12 * i + 4 * j) / a3;
  }
  return result;
}

float CFXTristimulus2lms(float *a1, float *a2)
{
  return Mul33MatrixBy31Vector(Mcat, a1, a2);
}

float Div31VectorBy31Vector(float *a1, float *a2, float *a3)
{
  *a3 = *a1 / *a2;
  a3[1] = a1[1] / a2[1];
  float result = a1[2] / a2[2];
  a3[2] = result;
  return result;
}

float _CFXMagic(float *a1, float *a2, float *a3)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  for (int i = 0; i < 3; ++i)
    v5[i] = (float)(a1[3 * i] + a1[3 * i + 1]) + a1[3 * i + 2];
  a2[1] = *a3 * a1[1];
  a2[2] = a3[1] * a1[2];
  *a2 = (float)(v5[0] - a2[1]) - a2[2];
  a2[3] = a3[2] * a1[3];
  a2[5] = a3[3] * a1[5];
  a2[4] = (float)(v5[1] - a2[3]) - a2[5];
  a2[6] = a3[4] * a1[6];
  a2[7] = a3[5] * a1[7];
  float result = (float)(v5[2] - a2[6]) - a2[7];
  a2[8] = result;
  return result;
}

void _CFXApplyTwilightNightShiftAdjustment(uint64_t a1, float *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1;
  float v9 = a2;
  if ((*(unsigned char *)(a1 + 2552) & 1) != 0 && !float_equal(*(float *)(v10 + 2600), 0.0) && !_CFXIsIdentity(v9))
  {
    uint64_t v8 = 0;
    int v7 = 0;
    CFXGetWPFromMatrix(v10, v9, &v8, &v7);
    float v6 = CFXChromaticity2CCT((float *)&v8);
    float v5 = 0.0;
    float v5 = two_dimensional_interpolation(*(float **)(v10 + 2568), *(void *)(v10 + 2560), *(float **)(v10 + 2584), *(void *)(v10 + 2576), *(void *)(v10 + 2592), v6, *(float *)(v10 + 2600));
    if (!float_equal(v5, 0.0))
    {
      float v4 = v6 + v5;
      uint64_t v3 = 0;
      _CFXCCT2xy_Shifted(v10, (float *)&v3, v6 + v5);
      uint64_t v12 = 0;
      int v13 = 0;
      CFXChromaticity2Tristimulus((float *)&v3, (float *)&v12, 100.0);
      _CFXGetMatrix(v10, (float *)&v12, (uint64_t)v9, (float *)(v10 + 2128));
      oslog = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v11, COERCE__INT64(*(float *)(v10 + 2600)), COERCE__INT64(v6), COERCE__INT64(v4));
        _os_log_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_DEFAULT, "TWNS | Twilight.Strength=%f CCT.Original=%f CCT.Adjusted=%f", v11, 0x20u);
      }
    }
  }
}

uint64_t _CFXUpdateColorFadeInternal(uint64_t a1, double *a2, char a3, double a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a1;
  double v31 = a4;
  char v30 = a2;
  char v29 = a3 & 1;
  double v28 = 0.0;
  double v28 = a4 - a2[1];
  double v27 = 0.0;
  double v27 = v28 / *a2;
  char v26 = 0;
  if (*a2 == 0.0 || v27 >= 1.0 || v28 < 0.0)
  {
    memcpy(__dst, (char *)v30 + 20, sizeof(__dst));
    *char v30 = 0.0;
    *((unsigned char *)v30 + 16) = 1;
  }
  else
  {
    int v25 = 0;
    int v25 = *(_DWORD *)(v32 + 360) - 1;
    double v27 = v27 * (float)v25;
    int v24 = (int)v27;
    int v23 = (int)v27 + 1;
    double v22 = v27 - (double)(int)v27;
    double v27 = (1.0 - v22) * *(float *)(*(void *)(v32 + 352) + 4 * (int)v27)
        + v22 * *(float *)(*(void *)(v32 + 352) + 4 * v23);
    for (int i = 0; i < 3; ++i)
    {
      for (int j = 0; j < 3; ++j)
      {
        float v4 = *((float *)v30 + 3 * i + j + 23)
           + v27 * (float)(*((float *)v30 + 3 * i + j + 5) - *((float *)v30 + 3 * i + j + 23));
        __dst[3 * i + j] = v4;
      }
    }
    char v26 = 1;
  }
  __memcpy_chk();
  if ((v29 & 1) != 0 && *(void *)(v32 + 96))
  {
    uint64_t v19 = 0;
    uint64_t v19 = *(void *)(v32 + 96);
    uint64_t v18 = 0;
    int v17 = 0;
    _CFXGetWPFromMatrix(v32, __dst, &v18, &v17);
    memset(v16, 0, sizeof(v16));
    uint64_t v34 = 0;
    int v35 = 0;
    CFXChromaticity2Tristimulus((float *)&v18, (float *)&v34, 100.0);
    CFXTristimulus2Lab((float *)&v34, (float *)v16);
    if (*(void *)(v19 + 56))
    {
      uint64_t v15 = *(void *)&v16[4];
      _CFXStickToPolygon(*(void *)(v19 + 56), *(_DWORD *)(v19 + 148), (float *)&dword_1BA6122BC, (float *)&v16[4], (float *)&v16[4]);
      if (*(float *)&v15 != *(float *)&v16[4] && *((float *)&v15 + 1) != *(float *)&v16[8]) {
        syslog(7, "Restrict: (%f, %f) -> (%f, %f)\n", *(float *)&v15, *(float *)&v15, *(float *)&v16[4], *(float *)&v16[8]);
      }
    }
    float v14 = 0.0;
    if (*(unsigned char *)(*(void *)(v32 + 96) + 303))
    {
      float v13 = fminf(*(float *)(v19 + 336), *(float *)(v19 + 280));
      oslog = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v33, COERCE__INT64(v13), COERCE__INT64(*(float *)(v19 + 336)), COERCE__INT64(*(float *)(v19 + 280)));
        _os_log_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_DEFAULT, "BaselineHarmony: Current strength: %f, ALSStrength: %f, AppStrength: %f", v33, 0x20u);
      }
    }
    else
    {
      float v13 = *(float *)(v19 + 280);
    }
    *(float *)(v19 + 308) = v13;
    if (*(unsigned char *)(v19 + 144))
    {
      float v14 = _CFXFindAdaptation((float *)&v16[4], (uint64_t *)(v19 + 64));
      if (*(unsigned char *)(v19 + 145))
      {
        float v11 = _CFXFindAdaptation((float *)&v16[4], (uint64_t *)(v19 + 104));
        if (v13 > 0.35)
        {
          if (v13 > 0.7)
          {
            if (v13 > 0.85)
            {
              float v14 = 0.0;
            }
            else
            {
              float v7 = (0.85 - v13) / 0.15;
              float v14 = (float)((float)(1.0 - v7) * 0.0) + (float)(v7 * v14);
            }
          }
          else
          {
            float v6 = (0.7 - v13) / 0.35;
            float v14 = (float)((float)(1.0 - v6) * v14) + (float)(v6 * v11);
          }
        }
        else
        {
          float v5 = (0.35 - v13) / 0.35;
          float v14 = (float)((float)(1.0 - v5) * v11) + (float)(v5 * 1.0);
        }
      }
    }
    float v8 = (float)(v14 * 0.0) + (1.0 - v14) * *(float *)&v16[4];
    *(float *)&v16[4] = v8;
    float v9 = (float)(v14 * 0.0) + (1.0 - v14) * *(float *)&v16[8];
    *(float *)&v16[8] = v9;
    *(float *)&v16[4] = v8 + (float)(v13 * *(float *)(v19 + 292));
    *(float *)&v16[8] = v9 + (float)(v13 * *(float *)(v19 + 296));
    CFXLab2Tristimulus((float *)v16, (float *)&v34);
    *(float *)(v32 + 2100) = v14;
    CFXTristimulus2Chromaticity((float *)&v34, (float *)(v32 + 2108));
    _CFXGetMatrix(v32, (float *)&v34, (uint64_t)__dst, (float *)(v32 + 2128));
  }
  __memcpy_chk();
  return v26 & 1;
}

float _CFXFindAdaptation(float *a1, uint64_t *a2)
{
  int v20 = *((_DWORD *)a2 + 2);
  int v19 = *((_DWORD *)a2 + 6);
  int v18 = v20 - 1;
  int v17 = v20 - 1;
  int v16 = v19 - 1;
  int v15 = v19 - 1;
  uint64_t v13 = *a2;
  uint64_t v12 = a2[2];
  for (int i = 0; i < v20; ++i)
  {
    if (*a1 <= *(float *)(v13 + 4 * i))
    {
      int v17 = i;
      if (i) {
        int v8 = i - 1;
      }
      else {
        int v8 = 0;
      }
      int v18 = v8;
      break;
    }
  }
  for (int j = 0; j < v19; ++j)
  {
    if (a1[1] <= *(float *)(v12 + 4 * j))
    {
      int v15 = j;
      if (j) {
        int v7 = j - 1;
      }
      else {
        int v7 = 0;
      }
      int v16 = v7;
      break;
    }
  }
  if (v18 == v17) {
    double v6 = 1.0;
  }
  else {
    double v6 = (float)((float)(*a1 - *(float *)(v13 + 4 * v18))
  }
               / (float)(*(float *)(v13 + 4 * v17) - *(float *)(v13 + 4 * v18)));
  float v2 = v6;
  float v9 = v2;
  if (v16 == v15) {
    double v5 = 1.0;
  }
  else {
    double v5 = (float)((float)(a1[1] - *(float *)(v12 + 4 * v16))
  }
               / (float)(*(float *)(v12 + 4 * v15) - *(float *)(v12 + 4 * v16)));
  float v3 = v5;
  uint64_t v14 = a2[4];
  return (float)((float)((float)(*(float *)(*(void *)(v14 + 8 * v15) + 4 * v17) * v9)
                       + (float)(*(float *)(*(void *)(v14 + 8 * v15) + 4 * v18) * (float)(1.0 - v9)))
               * v3)
       + (float)((float)((float)(*(float *)(*(void *)(v14 + 8 * v16) + 4 * v17) * v9)
                       + (float)(*(float *)(*(void *)(v14 + 8 * v16) + 4 * v18) * (float)(1.0 - v9)))
               * (float)(1.0 - v3));
}

float CFXChromaticity2Tristimulus(float *a1, float *a2, float a3)
{
  *a2 = (float)(*a1 / a1[1]) * a3;
  a2[1] = a3;
  float result = (1.0 - *a1 - a1[1]) / a1[1] * a3;
  a2[2] = result;
  return result;
}

float CFXTristimulus2Lab(float *a1, float *a2)
{
  float v6 = F(*a1 / 95.05);
  float v7 = F(a1[1] / 100.0);
  float v2 = F(a1[2] / 108.9);
  *a2 = (float)(116.0 * v7) + -16.0;
  a2[1] = 500.0 * (float)(v6 - v7);
  float result = 200.0 * (float)(v7 - v2);
  a2[2] = result;
  return result;
}

float F(float a1)
{
  if (a1 > 0.0088565) {
    return powf(a1, 0.33333);
  }
  return 7.787 * a1 + 0.13793;
}

float _CFXGetWPFromMatrix(uint64_t a1, float *a2, void *a3, _DWORD *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1;
  int v8 = a2;
  float v7 = a3;
  float v6 = a4;
  uint64_t v14 = 0x3F8000003F800000;
  int v15 = 1065353216;
  if (*(unsigned char *)(a1 + 2520))
  {
    uint64_t v14 = *(void *)(v9 + 2508);
    int v15 = *(_DWORD *)(v9 + 2516);
  }
  uint64_t v12 = 0;
  int v13 = 0;
  Mul33MatrixBy31Vector(v8, (float *)&v14, (float *)&v12);
  uint64_t v10 = 0;
  int v11 = 0;
  Mul33MatrixBy31Vector((float *)(v9 + 2216), (float *)&v12, (float *)&v10);
  uint64_t v5 = 0;
  CFXTristimulus2Chromaticity((float *)&v10, (float *)&v5);
  *float v7 = v5;
  float result = *((float *)&v10 + 1);
  *float v6 = HIDWORD(v10);
  return result;
}

float Mul33MatrixBy31Vector(float *a1, float *a2, float *a3)
{
  *a3 = (float)((float)(a1[1] * a2[1]) + (float)(*a1 * *a2)) + (float)(a1[2] * a2[2]);
  a3[1] = (float)((float)(a1[4] * a2[1]) + (float)(a1[3] * *a2)) + (float)(a1[5] * a2[2]);
  float result = (float)((float)(a1[7] * a2[1]) + (float)(a1[6] * *a2)) + (float)(a1[8] * a2[2]);
  a3[2] = result;
  return result;
}

float CFXTristimulus2Chromaticity(float *a1, float *a2)
{
  float v3 = (float)(*a1 + a1[1]) + a1[2];
  *a2 = *a1 / v3;
  float result = a1[1] / v3;
  a2[1] = result;
  return result;
}

float _CFXStickToPolygon(uint64_t a1, int a2, float *a3, float *a4, float *a5)
{
  *(float *)&double v5 = *a3;
  if (*a3 == *a4)
  {
    *(float *)&double v5 = a3[1];
    if (*(float *)&v5 == a4[1])
    {
      a5[1] = a4[1];
      *(float *)&double v5 = *a4;
      *a5 = *a4;
    }
    else
    {
      for (int i = 0; i < a2 - 1; ++i)
      {
        *(float *)&double v5 = (float)(*(float *)(a1 + 8 * i) - *a4) * (float)(*a4 - *(float *)(a1 + 8 * (i + 1)));
        if (*(float *)&v5 >= 0.0)
        {
          float v18 = *(float *)(a1 + 8 * i + 4)
              + (float)((float)((float)(*(float *)(a1 + 8 * (i + 1) + 4) - *(float *)(a1 + 8 * i + 4))
                              / (float)(*(float *)(a1 + 8 * (i + 1)) - *(float *)(a1 + 8 * i)))
                      * (float)(*a4 - *(float *)(a1 + 8 * i)));
          float v17 = v18 - a4[1];
          float v16 = a4[1] - a3[1];
          if ((float)(v17 * v16) > 0.0)
          {
            a5[1] = a4[1];
            *(float *)&double v5 = *a4;
            *a5 = *a4;
            return *(float *)&v5;
          }
          double v5 = fabs(v17);
          if (v5 < fabs(v16))
          {
            a5[1] = v18;
            *(float *)&double v5 = *a4;
            *a5 = *a4;
            return *(float *)&v5;
          }
        }
      }
    }
  }
  else
  {
    for (int j = 0; j < a2 - 1; ++j)
    {
      float v14 = (float)(a4[1] - a3[1]) / (float)(*a4 - *a3);
      float v13 = a3[1] - (float)(v14 * *a3);
      if ((float)(*(float *)(a1 + 8 * (j + 1)) - *(float *)(a1 + 8 * j)) == 0.0)
      {
        float v12 = *(float *)(a1 + 8 * (j + 1));
      }
      else
      {
        float v10 = (float)(*(float *)(a1 + 8 * (j + 1) + 4) - *(float *)(a1 + 8 * j + 4))
            / (float)(*(float *)(a1 + 8 * (j + 1)) - *(float *)(a1 + 8 * j));
        float v12 = (float)(v13 - (float)(*(float *)(a1 + 8 * j + 4) - (float)(v10 * *(float *)(a1 + 8 * j))))
            / (float)(v10 - v14);
      }
      float v11 = v13 + (float)(v14 * v12);
      *(float *)&double v5 = (float)(*(float *)(a1 + 8 * j) - v12) * (float)(v12 - *(float *)(a1 + 8 * (j + 1)));
      if (*(float *)&v5 >= 0.0)
      {
        *(float *)&double v5 = (float)(*(float *)(a1 + 8 * j + 4) - v11) * (float)(v11 - *(float *)(a1 + 8 * (j + 1) + 4));
        if (*(float *)&v5 >= 0.0)
        {
          float v9 = (float)((float)(a3[1] - v11) * (float)(a3[1] - v11)) + (float)((float)(*a3 - v12) * (float)(*a3 - v12));
          float v8 = (float)((float)(a3[1] - a4[1]) * (float)(a3[1] - a4[1]))
             + (float)((float)(*a3 - *a4) * (float)(*a3 - *a4));
          float v7 = (float)((float)(a4[1] - v11) * (float)(a4[1] - v11)) + (float)((float)(*a4 - v12) * (float)(*a4 - v12));
          if (v9 >= v8 && v9 >= v7)
          {
            a5[1] = a4[1];
            *(float *)&double v5 = *a4;
            *a5 = *a4;
            return *(float *)&v5;
          }
          *(float *)&double v5 = (float)((float)(a3[1] - a4[1]) * (float)(a3[1] - a4[1]))
                        + (float)((float)(*a3 - *a4) * (float)(*a3 - *a4));
          if (v8 >= v9)
          {
            *(float *)&double v5 = (float)((float)(a3[1] - a4[1]) * (float)(a3[1] - a4[1]))
                          + (float)((float)(*a3 - *a4) * (float)(*a3 - *a4));
            if (v8 >= v7)
            {
              a5[1] = v11;
              *(float *)&double v5 = v12;
              *a5 = v12;
              return *(float *)&v5;
            }
          }
        }
      }
    }
  }
  return *(float *)&v5;
}

float CFXLab2Tristimulus(float *a1, float *a2)
{
  float v5 = (float)(*a1 + 16.0) / 116.0;
  float v2 = v5 + a1[1] / 500.0;
  *a2 = 95.05 * invF(v2);
  a2[1] = 100.0 * invF(v5);
  float v3 = v5 - a1[2] / 200.0;
  float result = 108.9 * invF(v3);
  a2[2] = result;
  return result;
}

float invF(float a1)
{
  if (a1 > 0.2069) {
    return powf(a1, 3.0);
  }
  return 0.12842 * (a1 - 0.13793);
}

uint64_t __os_log_helper_16_0_3_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1) = 3;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  return result;
}

float cfx_linear_interpolation(float *a1, float *a2, float a3)
{
  if (a1 && a2) {
    return a1[1] + (float)((float)((float)(a2[1] - a1[1]) / (float)(*a2 - *a1)) * (float)(a3 - *a1));
  }
  syslog(1, "%s: Invalid input params: p1=>0x%x, p2=>0x%x\n", "cfx_linear_interpolation", a1, a2);
  return -1.0;
}

float CFXuv2Chromaticity(float *a1, float *a2)
{
  float v3 = 12.0 - (float)((float)(16.0 * a1[1]) - (float)(6.0 * *a1));
  *a2 = (float)(9.0 * *a1) / v3;
  float result = (float)(4.0 * a1[1]) / v3;
  a2[1] = result;
  return result;
}

double _CFXUpdateCompensatedBacklight(uint64_t a1, unint64_t a2, double result)
{
  float v8 = *(float *)&result;
  *(void *)&float result = LODWORD(result);
  if (a1)
  {
    float v5 = _CFXFindBrightnessCompAlpha(AlphaArray, 7, *(float *)&result);
    float v3 = (float)(v5 * *(float *)(a1 + 2140)) + 1.0 - v5;
    float v6 = v8 * v3;
    double v4 = MachTimeToSeconds((unint64_t)((double)a2 - *(double *)(a1 + 1776)));
    *(double *)(a1 + 1752) = *(double *)(a1 + 1752) + v4;
    *(double *)(a1 + 1760) = *(double *)(a1 + 1760) + v4 * *(float *)(a1 + 1788);
    *(double *)(a1 + 1768) = *(double *)(a1 + 1768) + v4 * *(float *)(a1 + 1784);
    *(float *)(a1 + 1784) = v8;
    *(float *)(a1 + 1788) = v6;
    float result = (double)a2;
    *(double *)(a1 + 1776) = (double)a2;
  }
  return result;
}

double _CFXRampInit(uint64_t a1, float a2, float a3, float a4, float a5, double a6, uint64_t a7, int a8)
{
  unint64_t v13 = __PAIR64__(LODWORD(a5), LODWORD(a4));
  *(float *)(a1 + 44) = a3;
  *(_DWORD *)(a1 + 40) = 9;
  __memcpy_chk();
  *(float *)a1 = a2;
  *(void *)(a1 + 48) = v13;
  *(_DWORD *)(a1 + 56) = a8;
  double result = a6;
  *(double *)(a1 + 64) = a6;
  return result;
}

float __DisplayGetRestrictionFactorTarget_block_invoke(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48)) {
    float v2 = *(float *)(*(void *)(a1 + 40) + 1008);
  }
  else {
    float v2 = *(float *)(*(void *)(a1 + 40) + 1080);
  }
  float result = v2;
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v2;
  return result;
}

void sub_1BA44298C()
{
  _Unwind_Resume(v0);
}

void __DisplaySetABBrightnessForPowerReport_block_invoke(uint64_t a1)
{
  *(_DWORD *)(*(void *)(a1 + 32) + 1272) = *(_DWORD *)(a1 + 40);
  if (*(unsigned char *)(a1 + 44)) {
    __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 32), 0x2000, *(float *)(*(void *)(a1 + 32) + 1256));
  }
}

void sub_1BA4457C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 64), 8);
  _Unwind_Resume(a1);
}

BOOL float_equal(float a1, float a2)
{
  float v4 = std::__math::fabs[abi:ne180100](a1 - a2);
  float v3 = std::__math::fabs[abi:ne180100](a1);
  return v4 <= (float)(0.00000011921 * fmaxf(v3, std::__math::fabs[abi:ne180100](a2)));
}

float std::__math::fabs[abi:ne180100](float a1)
{
  return fabsf(a1);
}

__IOHIDEvent *AABC::filter(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    float v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    float v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_4_0_4_0((uint64_t)v12, 4, *((_DWORD *)this + 94));
    _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "[%x]: _plugInEnabled=%x", v12, 0xEu);
  }
  if (*((_DWORD *)this + 94))
  {
    unsigned int Type = IOHIDEventGetType();
    if (Type <= 2)
    {
      uint64_t v5 = Type - 2;
      char v4 = 0;
    }
    else
    {
      uint64_t v5 = Type - 2;
      char v4 = 1;
    }
    if ((v4 & 1) == 0)
    {
      switch(v5)
      {
        case 0:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 11:
          return a3;
        case 1:
          AABC::HandleKeyboardEvent(this, a2, a3);
          break;
        case 9:
          if (*((void *)this + 59) && a2 == *((__IOHIDServiceClient **)this + 59)) {
            AABC::HandleDigitizerEvent(this, a2, a3);
          }
          break;
        case 10:
          if (*((void *)this + 53) && a2 && CFDictionaryContainsKey(*((CFDictionaryRef *)this + 53), a2)) {
            AABC::HandleALSEvent(this, a2, a3);
          }
          break;
        case 12:
          if (*((void *)this + 60) && a2 == *((__IOHIDServiceClient **)this + 60)) {
            AABC::HandleProxEvent(this, a2, a3);
          }
          break;
        default:
          JUMPOUT(0);
      }
    }
  }
  return a3;
}

void __DisplaySetCurrentAmbient_block_invoke(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = a1;
  uint64_t v28 = a1;
  BOOL v27 = 0;
  BOOL v27 = *(float *)(*(void *)(a1 + 32) + 1192) != *(float *)(a1 + 40);
  float v26 = 0.0;
  float v26 = *(float *)(a1 + 40) - *(float *)(*(void *)(a1 + 32) + 1192);
  *(_DWORD *)(*(void *)(a1 + 32) + 1192) = *(_DWORD *)(a1 + 40);
  BOOL v25 = 0;
  if (*(unsigned char *)(*(void *)(a1 + 32) + 1517) & 1) != 0 && (_DisplayBDMAvailable(*(void *)(a1 + 32)))
  {
    float v24 = 0.0;
    float v24 = *(float *)(*(void *)(a1 + 32) + 1168);
    float BrightDotCap = 0.0;
    float BrightDotCap = _DisplayGetBrightDotCap(*(void *)(a1 + 32), *(float *)(*(void *)(a1 + 32) + 1192));
    BOOL v25 = v24 != BrightDotCap;
    if (v24 != BrightDotCap)
    {
      if (v26 < 850.0)
      {
        float v22 = 0.0;
        float v22 = *(float *)(*(void *)(a1 + 32) + 1172);
        float v21 = BrightDotCap - v24;
        if ((float)(BrightDotCap - v24) <= v22)
        {
          if (v21 < (float)-v22) {
            float v21 = -v22;
          }
        }
        else
        {
          float v21 = v22;
        }
        *(float *)(*(void *)(a1 + 32) + 1168) = *(float *)(*(void *)(a1 + 32) + 1168) + v21;
      }
      else
      {
        *(float *)(*(void *)(a1 + 32) + 1168) = BrightDotCap;
      }
    }
  }
  if (v27)
  {
    CFNumberRef v20 = 0;
    CFNumberRef v20 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (const void *)(a1 + 40));
    if (v20)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 32) + 192), @"TrustedLux", v20);
      (*(void (**)(void, __CFString *, CFNumberRef))(*(void *)(a1 + 32) + 16))(*(void *)(*(void *)(a1 + 32) + 24), @"TrustedLux", v20);
      CFRelease(v20);
    }
  }
  if (v25)
  {
    float v1 = (float)*(int *)(*(void *)(a1 + 32) + 1248) / 65536.0;
    SendSyncDBVNotification(*(void *)(a1 + 32), 0, v1);
    float v19 = 0.0;
    float v19 = __DisplayLogicalToPhysicalBrightness(*(void *)(a1 + 32), *(float *)(*(void *)(a1 + 32) + 1256));
    float v18 = 0.0;
    float v18 = _DisplayLogicalToSliderBrightnessInternal(*(void *)(a1 + 32), *(float *)(*(void *)(a1 + 32) + 1256));
    uint64_t v2 = *(void *)(a1 + 32);
    float v3 = (float)*(int *)(v2 + 1248) / 65536.0;
    __DisplayUpdateSlider((float *)v2, v18, v19, v3);
  }
  if (v27 || v25)
  {
    float v17 = 0.0;
    float v17 = _DisplayComputeEDRNitsCap(*(void *)(a1 + 32));
    os_log_t oslog = 0;
    if (_logHandle)
    {
      float v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v8 = inited;
    }
    os_log_t oslog = v8;
    os_log_type_t type = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_8_0((uint64_t)v31, COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 1500)), COERCE__INT64(v17), *(_DWORD *)(*(void *)(a1 + 32) + 12600), COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 1192)), COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 12528)));
      _os_log_debug_impl(&dword_1BA438000, oslog, type, "Ambient change - SetLibEDRBrightness - physicalBrightness:%f, maxLum: %f, edrState: %d, lux: %f, brightness boost: %f\n", v31, 0x30u);
    }
    SetLibEDRBrightness(*(void *)(a1 + 32), *(float *)(*(void *)(a1 + 32) + 1500), v17, *(float *)(*(void *)(a1 + 32) + 1192), *(float *)(*(void *)(a1 + 32) + 12528));
  }
  if ((DisplayHasDCP(*(void *)(a1 + 32)) & 1) != 0
    && ![+[CBAODState sharedInstance] isAODActive]&& *(_DWORD *)(*(void *)(a1 + 32) + 108))
  {
    *(_DWORD *)(*(void *)(a1 + 32) + 12740 + 4 * (*(_DWORD *)(*(void *)(a1 + 32) + 12728))++) = *(_DWORD *)(*(void *)(a1 + 32) + 1192);
    *(_DWORD *)(*(void *)(a1 + 32) + 12728) %= *(_DWORD *)(*(void *)(a1 + 32) + 12736);
    if (*(_DWORD *)(*(void *)(a1 + 32) + 12732) < *(_DWORD *)(*(void *)(a1 + 32) + 12736)) {
      ++*(_DWORD *)(*(void *)(a1 + 32) + 12732);
    }
    float v14 = 0.0;
    float v14 = *(float *)(*(void *)(a1 + 32) + 1192);
    if (*(_DWORD *)(*(void *)(a1 + 32) + 12732) > 1u)
    {
      __base = 0;
      __base = malloc_type_malloc(4 * *(unsigned int *)(*(void *)(a1 + 32) + 12732), 0x100004052888210uLL);
      if (__base)
      {
        __memcpy_chk();
        qsort(__base, *(unsigned int *)(*(void *)(a1 + 32) + 12732), 4uLL, (int (__cdecl *)(const void *, const void *))_DisplayCompareFloats);
        float v14 = *((float *)__base + *(_DWORD *)(*(void *)(a1 + 32) + 12732) / 2u);
        free(__base);
      }
    }
    if (v14 >= 0.0 && v14 != *(float *)(*(void *)(a1 + 32) + 12940))
    {
      *(float *)(*(void *)(a1 + 32) + 12940) = v14;
      float v12 = fminf(v14, 30000.0);
      int v11 = (int)(float)(v12 * 65536.0);
      CFAllocatorRef v4 = CFGetAllocator(*(CFTypeRef *)(a1 + 32));
      CFNumberRef property = CFNumberCreate(v4, kCFNumberSInt32Type, &v11);
      if (property)
      {
        if (_logHandle)
        {
          float v6 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v5 = init_default_corebrightness_log();
          }
          float v6 = v5;
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v30, COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 1192)), COERCE__INT64((float)((float)v11 / 65536.0)));
          _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "Set capped lux to IOMFB %f (%f)", v30, 0x16u);
        }
        IORegistryEntrySetCFProperty(*(_DWORD *)(*(void *)(a1 + 32) + 108), @"AmbientBrightness", property);
        CFRelease(property);
      }
    }
  }
}

float _DisplayGetBrightDotCap(uint64_t a1, float a2)
{
  float v8 = *(float *)(a1 + 1544);
  char v7 = _DisplayBDMAvailable(a1) & 1;
  if (*(unsigned char *)(a1 + 1517) & 1) != 0 && (v7)
  {
    float v6 = *(float *)(a1 + 1152);
    float v5 = *(float *)(a1 + 1156);
    float v4 = *(float *)(a1 + 1160);
    float v3 = *(float *)(a1 + 1164);
    if (a2 > v6)
    {
      if (a2 >= v4) {
        return fminf(v3, v8);
      }
      else {
        return fminf(v5 + (float)((float)((float)(a2 - v6) * (float)(v3 - v5)) / (float)(v4 - v6)), v8);
      }
    }
    else
    {
      return fminf(v5, v8);
    }
  }
  return v8;
}

uint64_t _DisplayBDMAvailable(uint64_t a1)
{
  char v2 = 0;
  if (DisplayRequiresBDM(a1))
  {
    char v2 = 0;
    if ((*(unsigned char *)(a1 + 1144) & 1) == 0) {
      char v2 = *(unsigned char *)(a1 + 1176);
    }
  }
  return v2 & 1;
}

uint64_t DisplayRequiresBDM(uint64_t a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  float v5 = __DisplayRequiresBDM_block_invoke;
  float v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = a1;
  float v10 = &DisplayRequiresBDM_token;
  float v9 = &v2;
  if (DisplayRequiresBDM_token != -1) {
    dispatch_once(v10, v9);
  }
  return DisplayRequiresBDM_requiresBDM & 1;
}

uint64_t DisplayHasDCP(uint64_t a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  float v5 = __DisplayHasDCP_block_invoke;
  float v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = a1;
  float v10 = &DisplayHasDCP_token;
  float v9 = &v2;
  if (DisplayHasDCP_token != -1) {
    dispatch_once(v10, v9);
  }
  return DisplayHasDCP_hasDCP & 1;
}

uint64_t AABC::HandleDigitizerEvent(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  float v14 = this;
  uint64_t v13 = a2;
  float v12 = a3;
  uint64_t v4 = MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  uint64_t v7 = ___ZN4AABC20HandleDigitizerEventEP20__IOHIDServiceClientP12__IOHIDEvent_block_invoke;
  uint64_t v8 = &__block_descriptor_56_e35_v24__0____IOHIDServiceClient__8_v16l;
  float v9 = this;
  float v10 = a3;
  int v11 = a2;
  return AABC::enumerateALSes((uint64_t)this, (uint64_t)&v4);
}

uint64_t AABC::enumerateALSes(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = a1;
  uint64_t v10 = a2;
  uint64_t v2 = *(void **)(a1 + 424);
  uint64_t v4 = MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  uint64_t v7 = ___ZN4AABC14enumerateALSesEU13block_pointerFvP20__IOHIDServiceClientPNS_3ALSEE_block_invoke;
  uint64_t v8 = &unk_1E621AC00;
  uint64_t v9 = a2;
  return objc_msgSend(v2, "enumerateKeysAndObjectsUsingBlock:");
}

uint64_t __SendSyncDBVNotification_block_invoke_27(uint64_t result)
{
  if (*(void *)(*(void *)(result + 40) + 16)) {
    return (*(uint64_t (**)(void, __CFString *, void))(*(void *)(result + 40) + 16))(*(void *)(*(void *)(result + 40) + 24), @"FrameSynchronizedBrightnessTransaction", *(void *)(result + 32));
  }
  return result;
}

void DisplayRefPropertyChangedCallback(void *a1, const __CFString *a2, const void *a3)
{
  float v21 = a1;
  CFTypeRef v20 = a2;
  CFTypeRef v19 = a3;
  if (a1)
  {
    int v15 = v21;
    if (v20) {
      CFRetain(v20);
    }
    if (v19) {
      CFRetain(v19);
    }
    int v3 = *((void *)v15 + 3);
    uint64_t block = MEMORY[0x1E4F143A8];
    int v8 = -1073741824;
    int v9 = 0;
    uint64_t v10 = ___Z33DisplayRefPropertyChangedCallbackPvPK10__CFStringPKv_block_invoke;
    uint64_t v11 = &unk_1E6219100;
    float v12 = v15;
    CFTypeRef v13 = v20;
    CFTypeRef v14 = v19;
    dispatch_async(v3, &block);
  }
  else
  {
    float v18 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    float v18 = inited;
    char v17 = 16;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      log = v18;
      os_log_type_t type = v17;
      __os_log_helper_16_0_0(v16);
      _os_log_error_impl(&dword_1BA438000, log, type, "invalid arguments", v16, 2u);
    }
  }
}

void __DisplaySetBLDriverProperty(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t v13 = a1;
  CFStringRef v12 = a2;
  uint64_t v11 = a3;
  if (a1 && *(_DWORD *)(v13 + 80) && v11)
  {
    if (*(void *)(v13 + 120))
    {
      char v10 = 0;
      if (!*(void *)(v13 + 128))
      {
        *(void *)(v13 + 128) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        char v10 = 1;
      }
      if (*(void *)(v13 + 128))
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v13 + 128), v12, v11);
        if (v10)
        {
          int v3 = *(NSObject **)(v13 + 120);
          uint64_t block = MEMORY[0x1E4F143A8];
          int v5 = -1073741824;
          int v6 = 0;
          uint64_t v7 = ____DisplaySetBLDriverProperty_block_invoke;
          int v8 = &__block_descriptor_40_e5_v8__0l;
          uint64_t v9 = v13;
          dispatch_async(v3, &block);
        }
      }
    }
    else
    {
      IORegistryEntrySetCFProperty(*(_DWORD *)(v13 + 80), v12, v11);
    }
  }
}

float ___ZN4AABC24_UpdateAggregateFunctionEP20__IOHIDServiceClientPNS_3ALSE_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    [a3 floatValue];
    *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = fmaxf(*(float *)(*(void *)(*(void *)(a1 + 32) + 8)+ 24), v4);
    float result = fminf(*(float *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), v4);
    *(float *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  }
  return result;
}

uint64_t CFXGetAmbientAdaptationMode(uint64_t a1, float *a2)
{
  unsigned int v3 = 0;
  if (a1)
  {
    if (*(void *)(a1 + 96))
    {
      unsigned int v3 = *(_DWORD *)(*(void *)(a1 + 96) + 248);
      if (a2) {
        *a2 = _CFXGetStrengthFromMode(a1, v3);
      }
    }
  }
  return v3;
}

void CFXAnimateAmbientAdaptationModes(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, float *a6, float a7, float a8)
{
  if (a1 && *(void *)(a1 + 96) && a4 && a5 > 0)
  {
    float v19 = 1.0;
    char v18 = 0;
    int v17 = *(_DWORD *)(*(void *)(a1 + 96) + 248);
    for (int i = 0; i < a5; ++i)
    {
      float v15 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(a4 + 4 * i));
      if (v15 <= v19)
      {
        float v19 = v15;
        int v17 = *(_DWORD *)(a4 + 4 * i);
        char v18 = 1;
      }
    }
    float v14 = 1.0;
    char v13 = 0;
    int v12 = *(_DWORD *)(*(void *)(a1 + 96) + 248);
    if (a2)
    {
      for (int j = 0; j < a3; ++j)
      {
        float v10 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(a2 + 4 * j));
        if (v10 <= v14)
        {
          float v14 = v10;
          int v12 = *(_DWORD *)(a2 + 4 * j);
          char v13 = 1;
        }
      }
    }
    if ((v13 & 1) == 0) {
      float v14 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(*(void *)(a1 + 96) + 248));
    }
    if (v18)
    {
      float v24 = fminf(1.0, fmaxf(0.0, a7));
      float v9 = v14 + (float)(v24 * (float)(v19 - v14));
      if (a6) {
        *a6 = v9;
      }
      syslog(7, "ANIMATING from mode %d to mode %d with ratio %f and period %f -> strength %f", v12, v17, (float)(v24 * 100.0), a8, v9);
      if (*(unsigned char *)(*(void *)(a1 + 96) + 184))
      {
        *(float *)&CFAbsoluteTime v8 = v14 + (float)(v24 * (float)(v19 - v14));
        CFXSetAmbientAdaptationStrength(a1, v8, a8);
      }
      if (v24 >= 1.0) {
        *(_DWORD *)(*(void *)(a1 + 96) + 248) = v17;
      }
      else {
        *(_DWORD *)(*(void *)(a1 + 96) + 248) = v12;
      }
    }
  }
}

float _CFXGetStrengthFromMode(uint64_t a1, unsigned int a2)
{
  float v3 = 0.0;
  if (a1 && *(void *)(a1 + 96)) {
    return *(float *)(*(void *)(a1 + 96) + 224 + 4 * a2);
  }
  return v3;
}

CFAbsoluteTime CFXSetAmbientAdaptationStrength(uint64_t a1, CFAbsoluteTime result, float a3)
{
  float v10 = *(float *)&result;
  if (a1)
  {
    LODWORD(result) = *(_DWORD *)(a1 + 2252);
    if (*(float *)&result >= 0.0)
    {
      LODWORD(result) = *(_DWORD *)(a1 + 2252);
      a3 = *(float *)&result;
    }
    if (*(void *)(a1 + 96))
    {
      float v9 = *(float *)(*(void *)(a1 + 96) + 252) * a3;
      *(float *)&float result = v10;
      if (v10 != **(float **)(a1 + 96))
      {
        **(float **)(a1 + 96) = v10;
        if (*(void *)(*(void *)(a1 + 96) + 56))
        {
          free(*(void **)(*(void *)(a1 + 96) + 56));
          *(void *)(*(void *)(a1 + 96) + 56) = 0;
        }
        syslog(7, "Set strength %f\n", v10);
        *(void *)(*(void *)(a1 + 96) + 56) = _CFXPolygonFromStrength((void *)(*(void *)(a1 + 96) + 40), *(_DWORD *)(*(void *)(a1 + 96) + 148), 0.85);
        float result = CFAbsoluteTimeGetCurrent();
        double v6 = result;
        if ((*(unsigned char *)(a1 + 364) & 1) != 0 && (*(unsigned char *)(*(void *)(a1 + 96) + 301) & 1) == 0)
        {
          *(unsigned char *)(*(void *)(a1 + 96) + 272) = 0;
          *(_DWORD *)(*(void *)(a1 + 96) + 284) = *(_DWORD *)(*(void *)(a1 + 96) + 280);
          *(float *)(*(void *)(a1 + 96) + 276) = v10;
          *(CFAbsoluteTime *)(*(void *)(a1 + 96) + 264) = result;
          float result = v9;
          *(double *)(*(void *)(a1 + 96) + 256) = v9;
          if (*(unsigned char *)(*(void *)(a1 + 96) + 303))
          {
            *(unsigned char *)(*(void *)(a1 + 96) + 328) = 0;
            *(_DWORD *)(*(void *)(a1 + 96) + 340) = *(_DWORD *)(*(void *)(a1 + 96) + 336);
            *(_DWORD *)(*(void *)(a1 + 96) + 332) = *(_DWORD *)(*(void *)(a1 + 96) + 332);
            *(double *)(*(void *)(a1 + 96) + 320) = v6;
            float result = v9;
            *(double *)(*(void *)(a1 + 96) + 312) = v9;
          }
          if (*(void *)(a1 + 328)) {
            (*(void (**)(void, void))(a1 + 328))(*(void *)(a1 + 336), 0);
          }
        }
        if (*(unsigned char *)(*(void *)(a1 + 96) + 184))
        {
          *(float *)&float result = v10 * 10.0;
          int v5 = (int)(float)(v10 * 10.0);
          if (v5 > 9) {
            int v5 = 9;
          }
          if (v5 != *(_DWORD *)(a1 + 1736))
          {
            double v3 = MachTimeToSeconds((unint64_t)(v6 - *(double *)(a1 + 1744)));
            float v4 = (double *)(a1 + 1656 + 8 * *(int *)(a1 + 1736));
            *float v4 = *v4 + v3;
            float result = v6;
            *(double *)(a1 + 1744) = v6;
            *(_DWORD *)(a1 + 1736) = v5;
          }
        }
      }
    }
  }
  return result;
}

void CFXSetWeakestAmbientAdaptationMode(uint64_t a1, uint64_t a2, int a3, float a4)
{
  if (a1 && *(void *)(a1 + 96))
  {
    float v9 = 1.0;
    char v8 = 0;
    int v7 = *(_DWORD *)(*(void *)(a1 + 96) + 248);
    for (int i = 0; i < a3; ++i)
    {
      float v5 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(a2 + 4 * i));
      if (v5 <= v9)
      {
        float v9 = v5;
        int v7 = *(_DWORD *)(a2 + 4 * i);
        char v8 = 1;
      }
    }
    syslog(7, "Min strength %f\n", v9);
    if (v8)
    {
      if (*(unsigned char *)(*(void *)(a1 + 96) + 184))
      {
        *(float *)&CFAbsoluteTime v4 = v9;
        CFXSetAmbientAdaptationStrength(a1, v4, a4);
      }
      *(_DWORD *)(*(void *)(a1 + 96) + 248) = v7;
    }
  }
}

uint64_t getMLMultiArrayClass()
{
  uint64_t v9 = 0;
  float v10 = &v9;
  int v11 = 1375731712;
  int v12 = 48;
  char v13 = __Block_byref_object_copy__14;
  float v14 = __Block_byref_object_dispose__14;
  uint64_t v8 = getMLMultiArrayClass_softClass;
  uint64_t v15 = getMLMultiArrayClass_softClass;
  if (!getMLMultiArrayClass_softClass)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    float v5 = __getMLMultiArrayClass_block_invoke;
    double v6 = &unk_1E6219058;
    int v7 = &v9;
    __getMLMultiArrayClass_block_invoke((uint64_t)&v2);
  }
  uint64_t v1 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v1;
}

float *_CFXPolygonFromStrength(void *a1, int a2, float a3)
{
  int v7 = 0;
  if (a2 > 0 && *a1 && a1[1])
  {
    int v7 = (float *)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
    if (a3 > 0.85)
    {
      float v3 = (a3 - 0.85) / 0.15;
      float v4 = 1.0 - v3;
      for (int i = 0; i < a2; ++i)
      {
        v7[2 * i] = (float)(v4 * *(float *)(*a1 + 8 * i)) + (float)(v3 * *(float *)(a1[1] + 8 * i));
        v7[2 * i + 1] = (float)(v4 * *(float *)(*a1 + 8 * i + 4)) + (float)(v3 * *(float *)(a1[1] + 8 * i + 4));
      }
    }
    else
    {
      __memcpy_chk();
    }
  }
  return v7;
}

uint64_t __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1) = 9;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  *(unsigned char *)(result + 42) = 0;
  *(unsigned char *)(result + 43) = 8;
  *(void *)(result + 44) = a6;
  *(unsigned char *)(result + 52) = 0;
  *(unsigned char *)(result + 53) = 8;
  *(void *)(result + 54) = a7;
  *(unsigned char *)(result + 62) = 0;
  *(unsigned char *)(result + 63) = 8;
  *(void *)(result + 64) = a8;
  *(unsigned char *)(result + 72) = 0;
  *(unsigned char *)(result + 73) = 8;
  *(void *)(result + 74) = a9;
  *(unsigned char *)(result + 82) = 0;
  *(unsigned char *)(result + 83) = 8;
  *(void *)(result + 84) = a10;
  return result;
}

void AABC::HandleALSEvent(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  v290 = "HandleALSEvent";
  CFDictionaryApplierFunction v291 = (CFDictionaryApplierFunction)AABC::UpdateAggregateFunction;
  uint64_t v429 = *MEMORY[0x1E4F143B8];
  v407 = this;
  v406 = a2;
  v405 = a3;
  v292 = (char *)this;
  os_log_t v404 = 0;
  if (_logHandle)
  {
    os_log_t v289 = (os_log_t)_logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
    {
      v288 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else
    {
      uint64_t inited = init_default_corebrightness_log();
      v288 = inited;
    }
    os_log_t v289 = v288;
  }
  os_log_t v404 = v289;
  os_log_type_t v403 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v289, OS_LOG_TYPE_DEBUG))
  {
    os_log_t v284 = v404;
    int v285 = v403;
    v286 = v428;
    __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v428, 4, (uint64_t)v406, (uint64_t)v405);
    _os_log_debug_impl(&dword_1BA438000, v404, v403, "[%x]: %p %p", v428, 0x1Cu);
  }
  v402 = 0;
  float v400 = 0.0;
  v399 = 0;
  uint64_t TimeStamp = IOHIDEventGetTimeStamp();
  float v3 = (double)(unint64_t)TimeStamp * *(double *)&AABC::_sMachTimebaseFactor;
  float v401 = v3;
  float v398 = 0.0;
  if (*((float *)v292 + 168) < v3 || *((_DWORD *)v292 + 92))
  {
    if (v292[505] & 1) != 0 && (v292[506])
    {
      os_log_t v395 = 0;
      if (_logHandle)
      {
        os_log_t v277 = (os_log_t)_logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          v276 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          v276 = init_default_corebrightness_log();
        }
        os_log_t v277 = v276;
      }
      os_log_t v395 = v277;
      os_log_type_t v394 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v277, OS_LOG_TYPE_DEBUG))
      {
        os_log_t v273 = v395;
        int v274 = v394;
        v275 = v426;
        __os_log_helper_16_0_1_4_0((uint64_t)v426, 4);
        _os_log_debug_impl(&dword_1BA438000, v395, v394, "[%x]: throwing away sample, preStrobe is in progress", v426, 8u);
      }
    }
    else
    {
      v272 = +[CBAODState sharedInstance];
      unint64_t v271 = [(CBAODState *)v272 AODState];
      if (AABC::ignoreALSEventsInAOD((uint64_t)v292, v271))
      {
        v393 = 0;
        if (_logHandle)
        {
          os_log_t v270 = (os_log_t)_logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            v269 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            v269 = init_default_corebrightness_log();
          }
          os_log_t v270 = v269;
        }
        v393 = v270;
        unsigned __int8 v392 = 0;
        if (os_log_type_enabled(v270, OS_LOG_TYPE_DEFAULT))
        {
          os_log_t v266 = v393;
          int v267 = v392;
          v268 = v391;
          __os_log_helper_16_0_0(v391);
          _os_log_impl(&dword_1BA438000, v266, (os_log_type_t)v267, "Ongoing AOD transition IN/OUT -> Ignoring ALS Events!!", v391, 2u);
        }
      }
      else if (*((_DWORD *)v292 + 717) != 1 && *((_DWORD *)v292 + 717) != 2 && *((_DWORD *)v292 + 717) != 3)
      {
        if ((v292[444] & 1) == 0)
        {
          float v4 = v292;
          v292[444] = 1;
          if (*((void *)v4 + 57))
          {
            if (*(_DWORD *)(*((void *)v292 + 57) + 8) == 8 || *(_DWORD *)(*((void *)v292 + 57) + 8) == 9)
            {
              os_log_t v390 = 0;
              if (_logHandle)
              {
                os_log_t v265 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v264 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v263 = init_default_corebrightness_log();
                  v264 = v263;
                }
                os_log_t v265 = v264;
              }
              os_log_t v390 = v265;
              os_log_type_t v389 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
              {
                os_log_t v260 = v390;
                int v261 = v389;
                *(double *)&uint64_t v5 = *((float *)v292 + 852);
                v262 = v425;
                __os_log_helper_16_0_2_8_0_8_0((uint64_t)v425, v5, 0x3FE0000000000000);
                _os_log_impl(&dword_1BA438000, v390, v389, "AABC has received the first ALS sample since the initialization. ALS TIMEOUT will change: %fms -> %fms.", v425, 0x16u);
              }
              *((float *)v292 + 852) = 0.5;
            }
          }
        }
        if ((v292[443] & 1) == 0)
        {
          uint64_t v259 = mach_absolute_time();
          double v388 = (double)v259 * *(double *)&AABC::_sMachTimebaseFactor;
          CFNumberRef v387 = 0;
          CFNumberRef v258 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &v388);
          CFNumberRef v387 = v258;
          if (v258)
          {
            if (*((void *)v292 + 48)) {
              CFDictionarySetValue(*((CFMutableDictionaryRef *)v292 + 48), @"EventTimestampFirstALSSample", v387);
            }
            os_log_t v386 = 0;
            if (_logHandle)
            {
              os_log_t v257 = (os_log_t)_logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
              {
                v256 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else
              {
                uint64_t v255 = init_default_corebrightness_log();
                v256 = v255;
              }
              os_log_t v257 = v256;
            }
            os_log_t v386 = v257;
            os_log_type_t v385 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
            {
              os_log_t v252 = v386;
              int v253 = v385;
              v254 = v424;
              __os_log_helper_16_0_1_8_0((uint64_t)v424, *(uint64_t *)&v388);
              _os_log_impl(&dword_1BA438000, v386, v385, "ts=%f kCBEventTimestampFirstALSSampleKey", v424, 0xCu);
            }
            CFRelease(v387);
          }
        }
        double v6 = v292;
        v292[443] = 1;
        if (*((_DWORD *)v6 + 112) == 1) {
          v292[440] = 1;
        }
        if ((v292[440] & 1) == 0 && *((void *)v292 + 54))
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)v292 + 54), v406, v405);
          unsigned int v384 = 0;
          CFIndex Count = CFDictionaryGetCount(*((CFDictionaryRef *)v292 + 54));
          unsigned int v384 = Count;
          uint64_t v249 = (int)Count;
          CFIndex v250 = CFDictionaryGetCount(*((CFDictionaryRef *)v292 + 53));
          if ((int)Count == v250) {
            v292[440] = 1;
          }
          v383 = &v58;
          unint64_t v243 = (8 * v384 + 15) & 0xFFFFFFFFFFFFFFF0;
          MEMORY[0x1F4188790]();
          v247 = (const void **)((char *)&v58 - v243);
          uint64_t v382 = v7;
          uint64_t v244 = 512;
          if ((unint64_t)(8 * v7) <= 0x200) {
            size_t v8 = 8 * v7;
          }
          else {
            size_t v8 = 512;
          }
          bzero((char *)&v58 - v243, v8);
          uint64_t v246 = v384;
          unint64_t v245 = (8 * v384 + 15) & 0xFFFFFFFFFFFFFFF0;
          MEMORY[0x1F4188790]();
          v248 = (const void **)((char *)&v58 - v245);
          uint64_t v381 = v246;
          if ((unint64_t)(8 * v246) <= 0x200) {
            size_t v10 = 8 * v246;
          }
          else {
            size_t v10 = v9;
          }
          bzero((char *)&v58 - v245, v10);
          CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)v292 + 54), v247, v248);
          int v380 = -1;
          float v379 = -1.0;
          for (int i = 0; i < (int)v384; ++i)
          {
            if (v248[i])
            {
              double v377 = 0.0;
              if (v292[3936])
              {
                IOHIDEventGetDoubleValue();
                double v242 = v11;
                double v241 = v11;
              }
              else
              {
                uint64_t IntegerValue = IOHIDEventGetIntegerValue();
                double v241 = (double)IntegerValue;
              }
              double v377 = v241;
              float v12 = v241;
              float v376 = v12;
              if (v12 > v379)
              {
                float v379 = v376;
                int v380 = i;
              }
            }
          }
          if (v380 >= 0)
          {
            v405 = v248[v380];
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D530], 0);
            v399 = Mutable;
            v375 = 0;
            Value = CFDictionaryGetValue(*((CFDictionaryRef *)v292 + 53), v247[v380]);
            v375 = Value;
            if (v399)
            {
              if (v375) {
                CFDictionaryAddValue(v399, v247[v380], v375);
              }
            }
          }
        }
        if (v292[440]) {
          v292[441] = 0;
        }
        v237 = (AABC::ALS *)CFDictionaryGetValue(*((CFDictionaryRef *)v292 + 53), v406);
        v402 = v237;
        if (v292[445]) {
          AABC::lazyLoadIntegrationTimes((AABC *)v292, v406, v402);
        }
        float v398 = *((float *)v402 + 38);
        double v374 = 0.0;
        if (v292[3936])
        {
          IOHIDEventGetDoubleValue();
          double v236 = v13;
          double v235 = v13;
        }
        else
        {
          uint64_t v234 = IOHIDEventGetIntegerValue();
          double v235 = (double)v234;
        }
        double v374 = v235;
        if (*((unsigned char *)v402 + 68))
        {
          float v233 = *((float *)v402 + 16);
        }
        else
        {
          float v14 = v374;
          float v233 = v14;
        }
        float v400 = v233;
        v373 = 0;
        if (_logHandle)
        {
          os_log_t v232 = (os_log_t)_logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            v231 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            uint64_t v230 = init_default_corebrightness_log();
            v231 = v230;
          }
          os_log_t v232 = v231;
        }
        v373 = v232;
        unsigned __int8 v372 = 2;
        if (os_log_type_enabled(v232, OS_LOG_TYPE_DEBUG))
        {
          os_log_t v227 = v373;
          int v228 = v372;
          if (*((unsigned char *)v402 + 68)) {
            uint64_t v15 = "(override)";
          }
          else {
            uint64_t v15 = "";
          }
          v229 = v423;
          __os_log_helper_16_2_3_4_0_8_0_8_32((uint64_t)v423, 16, COERCE__INT64(v400), (uint64_t)v15);
          _os_log_debug_impl(&dword_1BA438000, v227, (os_log_type_t)v228, "[%x]: %0.4f %s", v229, 0x1Cu);
        }
        if (v292[440] & 1) != 0 || (v292[442] & 1) != 0 || (v292[441]) {
          AABC::CancelFirstSampleTimeout((dispatch_object_t *)v292);
        }
        *((float *)v402 + 15) = v400;
        v371 = 0;
        if (_logHandle)
        {
          os_log_t v226 = (os_log_t)_logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            v225 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            uint64_t v224 = init_default_corebrightness_log();
            v225 = v224;
          }
          os_log_t v226 = v225;
        }
        v371 = v226;
        unsigned __int8 v370 = 2;
        if (os_log_type_enabled(v226, OS_LOG_TYPE_DEBUG))
        {
          os_log_t v221 = v371;
          int v222 = v370;
          *(double *)&uint64_t v16 = *((float *)v402 + 15);
          v223 = v422;
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v422, 16, v16);
          _os_log_debug_impl(&dword_1BA438000, v221, (os_log_type_t)v222, "[%x]: als->_Esensor_device=%0.4f", v223, 0x12u);
        }
        float v369 = 0.0;
        if (*((void *)v292 + 60)
          && *((_DWORD *)v292 + 987) == 2
          && (float)(v401 - *((float *)v292 + 986)) > *((float *)v292 + 985))
        {
          v368 = 0;
          if (_logHandle)
          {
            os_log_t v220 = (os_log_t)_logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v219 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              uint64_t v218 = init_default_corebrightness_log();
              v219 = v218;
            }
            os_log_t v220 = v219;
          }
          v368 = v220;
          unsigned __int8 v367 = 2;
          if (os_log_type_enabled(v220, OS_LOG_TYPE_DEBUG))
          {
            os_log_t v215 = v368;
            int v216 = v367;
            *(double *)&uint64_t v17 = *((float *)v292 + 986);
            *(double *)&uint64_t v18 = (float)(v401 - *((float *)v292 + 986));
            *(double *)&uint64_t v19 = *((float *)v292 + 985);
            v217 = v421;
            __os_log_helper_16_0_5_4_0_8_0_8_0_8_0_8_0((uint64_t)v421, 64, COERCE__INT64(v401), v17, v18, v19);
            _os_log_debug_impl(&dword_1BA438000, v215, (os_log_type_t)v216, "[%x]: setting _proxState = kProxNone (timestamp=%f _proxReleaseTime=%f delta=%f _proxTriggerDelay=%f)", v217, 0x30u);
          }
          CFTypeRef v20 = v292;
          *((_DWORD *)v292 + 987) = 0;
          if (v20[3937])
          {
            float v21 = (float **)v292;
            v292[4160] = 1;
            float VirtualBrightness = DisplayGetVirtualBrightness(v21[51]);
            *((float *)v292 + 154) = VirtualBrightness;
          }
        }
        if (*((void *)v402 + 3))
        {
          v366 = 0;
          v213 = [CBALSEvent alloc];
          v212 = [(CBALSEvent *)v213 initWithHIDEvent:v405 andNode:*((void *)v402 + 4)];
          v366 = v212;
          id v365 = 0;
          id v365 = (id)*((void *)v402 + 3);
          char v364 = 0;
          int v211 = [v365 isObstructed];
          char v364 = v211 & 1;
          [v365 filterEvent:v366];
          int v210 = [v365 isActive];
          if (v210)
          {
            int v209 = [v365 isObstructed];
            if (v209 & 1) == 0 && (v364)
            {
              float v22 = (AABC::ALS **)v292;
              v292[4160] = 1;
              if (v402 == v22[57])
              {
                float v208 = DisplayGetVirtualBrightness(*((float **)v292 + 51));
                *((float *)v292 + 154) = v208;
              }
            }
          }
        }
        float v363 = v400;
        double v362 = 0.0;
        double Current = CFAbsoluteTimeGetCurrent();
        double v362 = Current;
        if (*((_DWORD *)v292 + 169) && v362 > *((double *)v292 + 86))
        {
          AABC::CancelFastRampMode((CFAbsoluteTime *)v292);
          v292[3320] = 1;
        }
        float v363 = fmaxf(v363, *((float *)v402 + 13));
        if ((v292[3368] & 1) != 0
          && *((_DWORD *)v292 + 832)
          && *((_DWORD *)v292 + 832) < *((_DWORD *)v292 + 843)
          && !*((_DWORD *)v292 + 840)
          && v362 > *(double *)&v292[8 * (*((_DWORD *)v292 + 832) - 1) + 3336] + *((double *)v292 + 424)
          && (v292[3400] & 1) != 0)
        {
          AABC::writeOutlierRemovalPreferences((uint64_t)v292, 1);
          *((_DWORD *)v292 + 832) = *((_DWORD *)v292 + 843);
        }
        if (v292[440] & 1) != 0 || (v292[442] & 1) != 0 || (v292[441]) {
          ++*((_DWORD *)v292 + 150);
        }
        v361 = 0;
        if (_logHandle)
        {
          os_log_t v206 = (os_log_t)_logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            v205 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            uint64_t v204 = init_default_corebrightness_log();
            v205 = v204;
          }
          os_log_t v206 = v205;
        }
        v361 = v206;
        unsigned __int8 v360 = 2;
        if (os_log_type_enabled(v206, OS_LOG_TYPE_DEBUG))
        {
          os_log_t v201 = v361;
          int v202 = v360;
          int v23 = *((_DWORD *)v292 + 864);
          int v24 = *((_DWORD *)v402 + 20);
          v203 = v420;
          __os_log_helper_16_0_3_4_0_4_0_4_0((uint64_t)v420, 2, v23, v24);
          _os_log_debug_impl(&dword_1BA438000, v201, (os_log_type_t)v202, "[%x]: _luxFilter=%x als->_Ehistory_max=%d", v203, 0x14u);
        }
        if (*((_DWORD *)v292 + 864))
        {
          int v359 = 0;
          if (*((float *)v402 + 38) <= 0.01)
          {
            int v359 = 1;
          }
          else
          {
            int v359 = (int)std::__math::round[abi:ne180100](v398 / *((float *)v402 + 38));
            if (v359 <= 0) {
              int v200 = 1;
            }
            else {
              int v200 = v359;
            }
            int v359 = v200;
          }
          if (v292[264]) {
            float v363 = AABC::calculateMovingAverage((AABC *)v292, v363);
          }
          for (int j = 0; j < v359; ++j)
          {
            if (*((_DWORD *)v402 + 20))
            {
              float v199 = v363;
              BOOL v25 = (float *)std::vector<float>::operator[][abi:ne180100]((void *)v402 + 11, *((unsigned int *)v402 + 18));
              *BOOL v25 = v199;
              *((_DWORD *)v402 + 18) = (*((_DWORD *)v402 + 18) + 1) % *((_DWORD *)v402 + 20);
              if (*((_DWORD *)v402 + 19) < *((_DWORD *)v402 + 20)) {
                ++*((_DWORD *)v402 + 19);
              }
            }
          }
          if ((v292[136] & 1) != 0 && *((_DWORD *)v292 + 720) == 1)
          {
            if (!*((_DWORD *)v402 + 30))
            {
              *((_DWORD *)v402 + 30) = 5;
              std::vector<float>::resize((uint64_t *)v402 + 16, *((unsigned int *)v402 + 30));
            }
            float v198 = v363;
            float v26 = (float *)std::vector<float>::operator[][abi:ne180100]((void *)v402 + 16, *((unsigned int *)v402 + 28));
            *float v26 = v198;
            *((_DWORD *)v402 + 28) = (*((_DWORD *)v402 + 28) + 1) % *((_DWORD *)v402 + 30);
            if (*((_DWORD *)v402 + 29) < *((_DWORD *)v402 + 30)) {
              ++*((_DWORD *)v402 + 29);
            }
          }
          if (v292[160]) {
            AABC::addToFilter((AABC *)v292, (AABC::ALSFilter *)(v292 + 168), v363);
          }
        }
        if (*((_DWORD *)v292 + 864) == 3)
        {
          float v357 = v363;
          if (std::vector<float>::size[abi:ne180100]((void *)v402 + 11))
          {
            if (*((_DWORD *)v402 + 19) >= 2u)
            {
              std::vector<float>::vector(v356, (uint64_t *)v402 + 11);
              v197 = v356;
              uint64_t v355 = std::vector<float>::begin[abi:ne180100](v356);
              uint64_t v354 = std::vector<float>::end[abi:ne180100]((uint64_t)v197);
              std::sort[abi:ne180100]<std::__wrap_iter<float *>>(v355, v354);
              if (std::vector<float>::size[abi:ne180100]((void *)v402 + 11) == 2)
              {
                float v357 = *(float *)std::vector<float>::operator[][abi:ne180100](v356, 0);
                v353 = 0;
                if (_logHandle)
                {
                  os_log_t v196 = (os_log_t)_logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    v195 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    uint64_t v194 = init_default_corebrightness_log();
                    v195 = v194;
                  }
                  os_log_t v196 = v195;
                }
                v353 = v196;
                unsigned __int8 v352 = 2;
                if (os_log_type_enabled(v196, OS_LOG_TYPE_DEBUG))
                {
                  os_log_t v191 = v353;
                  int v192 = v352;
                  v193 = v351;
                  __os_log_helper_16_0_0(v351);
                  _os_log_debug_impl(&dword_1BA438000, v191, (os_log_type_t)v192, "Median filter computed on 2 samples - defaulting to minimum", v193, 2u);
                }
              }
              else
              {
                v190 = v356;
                uint64_t v27 = std::vector<float>::size[abi:ne180100](v356);
                float v357 = *(float *)std::vector<float>::operator[][abi:ne180100](v190, v27 - (*((_DWORD *)v402 + 19) + 1) / 2u);
                v350 = 0;
                if (_logHandle)
                {
                  os_log_t v189 = (os_log_t)_logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    v188 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    uint64_t v187 = init_default_corebrightness_log();
                    v188 = v187;
                  }
                  os_log_t v189 = v188;
                }
                v350 = v189;
                unsigned __int8 v349 = 2;
                if (os_log_type_enabled(v189, OS_LOG_TYPE_DEBUG))
                {
                  os_log_t v184 = v350;
                  int v185 = v349;
                  int v28 = *((_DWORD *)v402 + 19);
                  v186 = v419;
                  __os_log_helper_16_0_2_4_0_4_0((uint64_t)v419, 16, v28);
                  _os_log_debug_impl(&dword_1BA438000, v184, (os_log_type_t)v185, "[%x]: Median filter computed on %d samples", v186, 0xEu);
                }
                v348 = 0;
                if (_logHandle)
                {
                  os_log_t v183 = (os_log_t)_logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    v182 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    uint64_t v181 = init_default_corebrightness_log();
                    v182 = v181;
                  }
                  os_log_t v183 = v182;
                }
                v348 = v183;
                unsigned __int8 v347 = 2;
                if (os_log_type_enabled(v183, OS_LOG_TYPE_DEBUG))
                {
                  os_log_t v178 = v348;
                  int v179 = v347;
                  int v29 = *((_DWORD *)v402 + 19);
                  v180 = v418;
                  __os_log_helper_16_0_1_4_0((uint64_t)v418, v29);
                  _os_log_debug_impl(&dword_1BA438000, v178, (os_log_type_t)v179, "Median filter computed on %d samples", v180, 8u);
                }
              }
              std::vector<float>::~vector[abi:ne180100](v356);
            }
            if (*((_DWORD *)v292 + 169) && (v292[3460] & 1) == 0) {
              *((float *)v402 + 39) = v357;
            }
            else {
              *((float *)v402 + 39) = v357;
            }
          }
          else
          {
            *((float *)v402 + 39) = v363;
          }
          v346 = 0;
          if (_logHandle)
          {
            os_log_t v177 = (os_log_t)_logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v176 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              uint64_t v175 = init_default_corebrightness_log();
              v176 = v175;
            }
            os_log_t v177 = v176;
          }
          v346 = v177;
          unsigned __int8 v345 = 2;
          if (os_log_type_enabled(v177, OS_LOG_TYPE_DEBUG))
          {
            os_log_t v172 = v346;
            int v173 = v345;
            v174 = v417;
            __os_log_helper_16_0_4_4_0_8_0_8_0_8_0((uint64_t)v417, 16, COERCE__INT64(v401), COERCE__INT64(v363), COERCE__INT64(v357));
            _os_log_debug_impl(&dword_1BA438000, v172, (os_log_type_t)v173, "[%x]: ts=%f Esensor=%f Emedian=%f", v174, 0x26u);
          }
          if (v292[160])
          {
            float v171 = AABC::calculate95thPercentile((AABC *)v292, (AABC::ALSFilter *)(v292 + 168));
            float v30 = v171 * 1.25;
            *((float *)v402 + 39) = v30;
            v344 = 0;
            if (_logHandle)
            {
              os_log_t v170 = (os_log_t)_logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
              {
                v169 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else
              {
                uint64_t v168 = init_default_corebrightness_log();
                v169 = v168;
              }
              os_log_t v170 = v169;
            }
            v344 = v170;
            unsigned __int8 v343 = 0;
            if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
            {
              os_log_t v165 = v344;
              int v166 = v343;
              *(double *)&uint64_t v31 = *((float *)v402 + 39);
              v167 = v416;
              __os_log_helper_16_0_1_8_0((uint64_t)v416, v31);
              _os_log_impl(&dword_1BA438000, v165, (os_log_type_t)v166, "Scaled 95th percentile lux value: %f, scale factor:1.25", v167, 0xCu);
            }
          }
          if (v292[161])
          {
            AABC::addToFilter((AABC *)v292, (AABC::ALSFilter *)(v292 + 216), *((float *)v402 + 39));
            float v342 = 0.0;
            float v164 = AABC::calculate95thPercentile((AABC *)v292, (AABC::ALSFilter *)(v292 + 216));
            float v342 = v164;
            if (v164 >= 100.0)
            {
              *((float *)v402 + 39) = fmaxf(*((float *)v402 + 39), 100.0);
            }
            else
            {
              *((float *)v402 + 39) = v342;
              v341 = 0;
              if (_logHandle)
              {
                os_log_t v163 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v162 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v161 = init_default_corebrightness_log();
                  v162 = v161;
                }
                os_log_t v163 = v162;
              }
              v341 = v163;
              unsigned __int8 v340 = 2;
              if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
              {
                os_log_t v158 = v341;
                int v159 = v340;
                *(double *)&uint64_t v32 = *((float *)v402 + 39);
                v160 = v415;
                __os_log_helper_16_0_1_8_0((uint64_t)v415, v32);
                _os_log_debug_impl(&dword_1BA438000, v158, (os_log_type_t)v159, "Aliasing Mitigation: using 95th percentile lux value: %f", v160, 0xCu);
              }
            }
          }
        }
        else if (*((_DWORD *)v292 + 864) == 2)
        {
          float v339 = v363;
          if (std::vector<float>::size[abi:ne180100]((void *)v402 + 16) && *((_DWORD *)v402 + 29) >= 2u)
          {
            std::vector<float>::vector(v338, (uint64_t *)v402 + 16);
            v157 = v338;
            uint64_t v337 = std::vector<float>::begin[abi:ne180100](v338);
            uint64_t v336 = std::vector<float>::end[abi:ne180100]((uint64_t)v157);
            std::sort[abi:ne180100]<std::__wrap_iter<float *>>(v337, v336);
            v156 = v338;
            uint64_t v33 = std::vector<float>::size[abi:ne180100](v338);
            float v339 = *(float *)std::vector<float>::operator[][abi:ne180100](v156, v33 - (*((_DWORD *)v402 + 29) + 1) / 2u);
            v335 = 0;
            if (_logHandle)
            {
              os_log_t v155 = (os_log_t)_logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
              {
                v154 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else
              {
                uint64_t v153 = init_default_corebrightness_log();
                v154 = v153;
              }
              os_log_t v155 = v154;
            }
            v335 = v155;
            unsigned __int8 v334 = 2;
            if (os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG))
            {
              os_log_t v150 = v335;
              int v151 = v334;
              int v34 = *((_DWORD *)v402 + 29);
              v152 = v414;
              __os_log_helper_16_2_3_4_0_8_32_4_0((uint64_t)v414, 16, (uint64_t)v290, v34);
              _os_log_debug_impl(&dword_1BA438000, v150, (os_log_type_t)v151, "[%x]: %s: Accessory filter computed on %d samples", v152, 0x18u);
            }
            std::vector<float>::~vector[abi:ne180100](v338);
          }
          float v333 = 0.0;
          if (*((float *)v402 + 31) <= -1.0) {
            float v149 = 0.0;
          }
          else {
            float v149 = vabds_f32(*((float *)v402 + 31), v363);
          }
          float v333 = v149;
          float v332 = 0.0;
          if (v339 <= 0.0) {
            float v148 = 2.0;
          }
          else {
            float v148 = vabds_f32(v339, v363) / v339;
          }
          float v332 = v148;
          if (*((float *)v402 + 31) == -1.0)
          {
            *((float *)v402 + 39) = v363;
            *((float *)v402 + 31) = v363;
          }
          else if (v332 < 1.0 && v333 > *((float *)v292 + 35) || v363 == 0.0)
          {
            *((float *)v402 + 39) = v363;
            *((float *)v402 + 31) = v363;
          }
          else
          {
            *((_DWORD *)v402 + 39) = *((_DWORD *)v402 + 31);
          }
        }
        else
        {
          v331 = 0;
          if (_logHandle)
          {
            os_log_t v147 = (os_log_t)_logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v146 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              uint64_t v145 = init_default_corebrightness_log();
              v146 = v145;
            }
            os_log_t v147 = v146;
          }
          v331 = v147;
          unsigned __int8 v330 = 2;
          if (os_log_type_enabled(v147, OS_LOG_TYPE_DEBUG))
          {
            os_log_t v142 = v331;
            int v143 = v330;
            v144 = v413;
            __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v413, 16, COERCE__INT64(v401), COERCE__INT64(v363));
            _os_log_debug_impl(&dword_1BA438000, v142, (os_log_type_t)v143, "[%x]: ts=%f Esensor=%f", v144, 0x1Cu);
          }
          *((float *)v402 + 39) = v363;
        }
        if (v292[440] & 1) != 0 || (v292[442] & 1) != 0 || (v292[441])
        {
          *((_DWORD *)v292 + 134) = 0;
          if (v399) {
            CFDictionaryApplyFunction(v399, v291, v292);
          }
          else {
            CFDictionaryApplyFunction(*((CFDictionaryRef *)v292 + 53), v291, v292);
          }
          AABC::_ReportEsensorAggregated((AABC *)v292);
          float v139 = *((float *)v292 + 136);
          double v35 = -1.0;
          if (*((_DWORD *)v292 + 150) <= 1u) {
            double v35 = 0.1;
          }
          float v36 = v35;
          float v140 = v36;
          BOOL v37 = *((_DWORD *)v292 + 150) <= 1u;
          int v141 = 1;
          if (!v37) {
            int v141 = v292[4160];
          }
          AABC::_UpdateNitsRestrictions((AABC *)v292, v139, v140, v141 & 1);
          id v137 = (id)*((void *)v292 + 491);
          BOOL v38 = *((void *)v292 + 60) == 0;
          BOOL v138 = 0;
          if (!v38) {
            BOOL v138 = *((_DWORD *)v292 + 987) != 0;
          }
          BOOL v135 = v138;
          BOOL v39 = *(void *)(*((void *)v292 + 57) + 24) == 0;
          int v136 = 0;
          if (!v39)
          {
            int v134 = [*(id *)(*((void *)v292 + 57) + 24) isObstructedIgnoreActive];
            int v136 = v134;
          }
          [v137 recordOcclusionByProx:v135 andByTouch:v136 & 1];
          v329 = 0;
          if (_logHandle)
          {
            os_log_t v133 = (os_log_t)_logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              v132 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              uint64_t v131 = init_default_corebrightness_log();
              v132 = v131;
            }
            os_log_t v133 = v132;
          }
          v329 = v133;
          unsigned __int8 v328 = 2;
          if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
          {
            os_log_t v125 = v329;
            int v126 = v328;
            *(double *)&uint64_t v127 = *((float *)v292 + 136);
            v128 = (&kAABStateStr)[*((unsigned int *)v292 + 92)];
            v129 = (&kProxStateStr)[*((unsigned int *)v292 + 987)];
            int isTouchObstructed = AABC::ALS::isTouchObstructed(*((id **)v292 + 57));
            uint64_t v40 = (&kDimPolicyStr)[*((unsigned int *)v292 + 859)];
            int v41 = *((_DWORD *)v292 + 859);
            v57 = (&kOrientationString)[*((unsigned int *)v292 + 176)];
            v124 = v412;
            __os_log_helper_16_2_8_4_0_8_0_8_32_8_32_4_0_8_32_4_0_8_32((uint64_t)v412, 16, v127, (uint64_t)v128, (uint64_t)v129, isTouchObstructed & 1, (uint64_t)v40, v41, (uint64_t)v57);
            _os_log_debug_impl(&dword_1BA438000, v125, (os_log_type_t)v126, "[%x]: _Esensor_trusted=%f _state=%s _proxState=%s _touchIsObstucted=%d _settings._internal._dimPolicy=%s %d _orientation=%s", v124, 0x46u);
          }
          if (*((float *)v292 + 123) == 0.0 || *((float *)v292 + 123) == 1.0)
          {
            unsigned int v123 = *((_DWORD *)v292 + 92);
            if (v123 > 1 && (v123 == 3 || v123 == 2))
            {
              float v327 = 0.0;
              float v326 = 0.0;
              if (*((_DWORD *)v292 + 130))
              {
                float LogicalBrightness = DisplayGetLogicalBrightness(*((void *)v292 + 51));
                float v327 = LogicalBrightness;
                if (v292[3417])
                {
                  float v325 = 0.0;
                  float v121 = AABC::IlluminanceToLuminance((uint64_t)v292, (float *)v292 + 802, *((float *)v292 + 136), *((float *)v292 + 139));
                  float v325 = v121;
                  if ((v292[3418] & 1) == 0) {
                    float v327 = fminf(*((float *)v292 + 855), v325);
                  }
                }
                float v120 = AABC::IlluminanceToLuminance((uint64_t)v292, (float *)v292 + 262, *((float *)v292 + 136), *((float *)v292 + 139));
                float v326 = v120;
              }
              else
              {
                float v119 = AABC::IlluminanceToLuminance((uint64_t)v292, (float *)v292 + 262, *((float *)v292 + 136), *((float *)v292 + 139));
                float v327 = v119;
                if (v292[3417])
                {
                  float v324 = 0.0;
                  float v118 = AABC::IlluminanceToLuminance((uint64_t)v292, (float *)v292 + 802, *((float *)v292 + 136), *((float *)v292 + 139));
                  float v324 = v118;
                  float v327 = fminf(v327, v118);
                  if ((v292[3418] & 1) == 0) {
                    float v327 = fminf(*((float *)v292 + 855), v324);
                  }
                }
              }
              float v327 = fmaxf(v327, *((float *)v292 + 180));
              float v327 = fminf(v327, *((float *)v292 + 182));
              if (*((_DWORD *)v292 + 130))
              {
                float v326 = fmaxf(v326, *((float *)v292 + 180));
                float v326 = fminf(v326, *((float *)v292 + 182));
                DisplaySetABBrightnessForPowerReport(*((void *)v292 + 51), 1, v326);
              }
              else
              {
                DisplaySetABBrightnessForPowerReport(*((void *)v292 + 51), 0, v327);
              }
              float v369 = AABC::IlluminanceToReflectivity((AABC *)v292, *((float *)v292 + 139));
              v323 = 0;
              if (_logHandle)
              {
                os_log_t v117 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v116 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v115 = init_default_corebrightness_log();
                  v116 = v115;
                }
                os_log_t v117 = v116;
              }
              v323 = v117;
              unsigned __int8 v322 = 2;
              if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
              {
                os_log_t v112 = v323;
                int v113 = v322;
                int v43 = *(_DWORD *)v402;
                int v44 = *((_DWORD *)v402 + 1);
                *(double *)&uint64_t v45 = *((float *)v402 + 39);
                *(double *)&uint64_t v46 = *((float *)v292 + 136);
                v114 = v411;
                __os_log_helper_16_0_7_4_0_4_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v411, v43, v44, COERCE__INT64(v400), v45, v46, COERCE__INT64(v327), COERCE__INT64(v369));
                _os_log_debug_impl(&dword_1BA438000, v112, (os_log_type_t)v113, "[%02x/%02x] Esensor_device: %0.2f als->_Esensor_filtered: %0.2f _Esensor_trusted: %0.2f  L: %0.4f L_reflected: %0.4f", v114, 0x40u);
              }
              char v321 = 0;
              if (!*((_DWORD *)v292 + 719) || (char v47 = v292[136], v111 = 1, (v47 & 1) == 0)) {
                int v111 = v292[136] ^ 1;
              }
              char v321 = v111 & 1;
              if (v111)
              {
                float v320 = 0.0;
                char v319 = 0;
                int BrightnessOverride = DisplayGetBrightnessOverride(*((void *)v292 + 51), &v320);
                char v319 = BrightnessOverride & 1;
                if (BrightnessOverride)
                {
                  id v109 = (id)[*((id *)v292 + 490) LLPM];
                  [v109 pushNumberWeighted:v320 withWeight:*((float *)v292 + 158)];
                }
                else
                {
                  id v318 = 0;
                  if (*((_DWORD *)v292 + 130))
                  {
                    v108 = (void *)[*((id *)v292 + 490) LOff];
                    id v107 = v108;
                  }
                  else
                  {
                    v106 = (void *)[*((id *)v292 + 490) L];
                    id v107 = v106;
                  }
                  id v318 = v107;
                  [v107 pushNumberWeighted:v327 withWeight:*((float *)v292 + 158)];
                }
              }
              else
              {
                float v317 = 0.0;
                float DeviceBrightness = DisplayGetDeviceBrightness(*((void *)v292 + 51));
                float v317 = DeviceBrightness;
                id v316 = 0;
                if (*((_DWORD *)v292 + 130))
                {
                  v104 = (void *)[*((id *)v292 + 490) LDeviceOff];
                  id v103 = v104;
                }
                else
                {
                  v102 = (void *)[*((id *)v292 + 490) LDevice];
                  id v103 = v102;
                }
                id v316 = v103;
                [v103 pushNumberWeighted:v317 withWeight:*((float *)v292 + 158)];
              }
              id v101 = (id)[*((id *)v292 + 490) E];
              [v101 pushNumberWeighted:v400 withWeight:*((float *)v292 + 158)];
              if (*((int *)v292 + 926) >= 0)
              {
                uint64_t v315 = 0;
                uint64_t v100 = mach_absolute_time();
                uint64_t v48 = v292;
                uint64_t v315 = v100;
                unint64_t v314 = 0;
                unint64_t v314 = v100 - *((void *)v292 + 485);
                uint64_t v49 = (double *)&v292[8 * *((int *)v292 + 926) + 3808];
                *uint64_t v49 = *v49 + (double)v314 * *(double *)&AABC::_sMachTimebaseFactor;
                *((void *)v48 + 485) = v315;
              }
              int v313 = 2;
              int v99 = AABC::ALS::isTouchObstructed(*((id **)v292 + 57));
              if (v99) {
                int v313 = *((void *)v292 + 60) == 0;
              }
              unint64_t v98 = *((unsigned int *)v292 + 859);
              if (v98 <= 7)
              {
                switch(v98)
                {
                  case 1uLL:
                    int v313 = 1;
                    if (*((void *)v292 + 59))
                    {
                      CFTypeRef v312 = 0;
                      CFTypeRef v97 = IOHIDServiceClientCopyProperty(*((IOHIDServiceClientRef *)v292 + 59), @"GraphicsOrientation");
                      CFTypeRef v312 = v97;
                      if (v97)
                      {
                        int v311 = 0;
                        CFTypeID v96 = CFGetTypeID(v312);
                        CFTypeID TypeID = CFNumberGetTypeID();
                        if (v96 == TypeID) {
                          CFNumberGetValue((CFNumberRef)v312, kCFNumberIntType, &v311);
                        }
                        CFRelease(v312);
                        if ((float)v311 != *((float *)v292 + 140) && v311 == 1) {
                          *((_DWORD *)v292 + 991) = 0;
                        }
                        *((float *)v292 + 140) = (float)v311;
                        if (v311 == 1 && *((_DWORD *)v292 + 991) < *((_DWORD *)v292 + 992))
                        {
                          int v50 = v292;
                          ++*((_DWORD *)v292 + 991);
                          if (*((_DWORD *)v50 + 991) == *((_DWORD *)v50 + 992))
                          {
                            v51 = v292;
                            *((_DWORD *)v292 + 988) = 0;
                            *((_DWORD *)v51 + 989) = 0;
                            *((_DWORD *)v51 + 151) = 0;
                            v310 = 0;
                            if (_logHandle)
                            {
                              os_log_t v94 = (os_log_t)_logHandle;
                            }
                            else
                            {
                              if (_COREBRIGHTNESS_LOG_DEFAULT)
                              {
                                v93 = _COREBRIGHTNESS_LOG_DEFAULT;
                              }
                              else
                              {
                                uint64_t v92 = init_default_corebrightness_log();
                                v93 = v92;
                              }
                              os_log_t v94 = v93;
                            }
                            v310 = v94;
                            unsigned __int8 v309 = 2;
                            if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
                            {
                              os_log_t v89 = v310;
                              int v90 = v309;
                              int v52 = *((_DWORD *)v292 + 992);
                              v91 = v410;
                              __os_log_helper_16_0_1_4_0((uint64_t)v410, v52);
                              _os_log_debug_impl(&dword_1BA438000, v89, (os_log_type_t)v90, "Stayed in portrait mode for %d samples, resetting dimming", v91, 8u);
                            }
                          }
                        }
                      }
                    }
                    break;
                  case 2uLL:
                    if (*((_DWORD *)v292 + 176) == 3 || *((_DWORD *)v292 + 176) == 4) {
                      int v313 = 1;
                    }
                    break;
                  case 3uLL:
                    break;
                  case 4uLL:
                    if (*((int *)v292 + 996) > 0) {
                      int v313 = 0;
                    }
                    break;
                  case 5uLL:
                    if (*((int *)v292 + 996) > 0) {
                      int v313 = 1;
                    }
                    break;
                  case 6uLL:
                  case 7uLL:
                    char v308 = 1;
                    if (*((void *)v292 + 59))
                    {
                      CFTypeRef v307 = 0;
                      CFTypeRef v88 = IOHIDServiceClientCopyProperty(*((IOHIDServiceClientRef *)v292 + 59), @"GraphicsOrientation");
                      CFTypeRef v307 = v88;
                      if (v88)
                      {
                        int v306 = 0;
                        CFTypeID v87 = CFGetTypeID(v307);
                        CFTypeID v86 = CFNumberGetTypeID();
                        if (v87 == v86) {
                          CFNumberGetValue((CFNumberRef)v307, kCFNumberIntType, &v306);
                        }
                        CFRelease(v307);
                        if (*((_DWORD *)v292 + 859) == 7 && v306 == 1)
                        {
                          *((_DWORD *)v292 + 152) = 0;
                          char v308 = 0;
                        }
                        else if ((float)v306 != *((float *)v292 + 140))
                        {
                          v305 = 0;
                          if (_logHandle)
                          {
                            os_log_t v85 = (os_log_t)_logHandle;
                          }
                          else
                          {
                            if (_COREBRIGHTNESS_LOG_DEFAULT)
                            {
                              v84 = _COREBRIGHTNESS_LOG_DEFAULT;
                            }
                            else
                            {
                              uint64_t v83 = init_default_corebrightness_log();
                              v84 = v83;
                            }
                            os_log_t v85 = v84;
                          }
                          v305 = v85;
                          unsigned __int8 v304 = 1;
                          if (os_log_type_enabled(v85, OS_LOG_TYPE_INFO))
                          {
                            os_log_t v80 = v305;
                            int v81 = v304;
                            v82 = v303;
                            __os_log_helper_16_0_0(v303);
                            _os_log_impl(&dword_1BA438000, v80, (os_log_type_t)v81, "Orientation changed. Allowing dimming", v82, 2u);
                          }
                          uint64_t v53 = v292;
                          *((_DWORD *)v292 + 988) = 0;
                          v53[989] = 0;
                          v53[151] = 0;
                          int v313 = 1;
                          v53[152] = 0;
                          v53[141] = 0;
                          char v308 = 0;
                        }
                        *((float *)v292 + 140) = (float)v306;
                      }
                    }
                    if (v308)
                    {
                      int v302 = 0;
                      int IsProxEmulationTriggered = AABC::IsProxEmulationTriggered((AABC *)v292, &v302);
                      if (IsProxEmulationTriggered && *((float *)v292 + 154) < *((float *)v292 + 155))
                      {
                        v301 = 0;
                        if (_logHandle)
                        {
                          os_log_t v78 = (os_log_t)_logHandle;
                        }
                        else
                        {
                          if (_COREBRIGHTNESS_LOG_DEFAULT)
                          {
                            v77 = _COREBRIGHTNESS_LOG_DEFAULT;
                          }
                          else
                          {
                            uint64_t v76 = init_default_corebrightness_log();
                            v77 = v76;
                          }
                          os_log_t v78 = v77;
                        }
                        v301 = v78;
                        unsigned __int8 v300 = 1;
                        if (os_log_type_enabled(v78, OS_LOG_TYPE_INFO))
                        {
                          os_log_t v73 = v301;
                          int v74 = v300;
                          v75 = v299;
                          __os_log_helper_16_0_0(v299);
                          _os_log_impl(&dword_1BA438000, v73, (os_log_type_t)v74, "Cancel ramp, ALS covered mitigation", v75, 2u);
                        }
                        AABC::CancelRamp((AABC *)v292);
                      }
                      if (v302) {
                        int v313 = 1;
                      }
                    }
                    break;
                  default:
                    int v313 = 0;
                    break;
                }
              }
              char v298 = 0;
              v297 = 0;
              if (_logHandle)
              {
                os_log_t v72 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v71 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v70 = init_default_corebrightness_log();
                  v71 = v70;
                }
                os_log_t v72 = v71;
              }
              v297 = v72;
              unsigned __int8 v296 = 2;
              if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
              {
                os_log_t v67 = v297;
                int v68 = v296;
                int v54 = (&kDimRestrictionStr)[v313];
                v69 = v409;
                __os_log_helper_16_2_2_4_0_8_32((uint64_t)v409, 16, (uint64_t)v54);
                _os_log_debug_impl(&dword_1BA438000, v67, (os_log_type_t)v68, "[%x]: dimRestriction=%s", v69, 0x12u);
              }
              DisplaySetCurrentAmbient(*((void *)v292 + 51), *((float *)v292 + 136));
              if (*((float *)v292 + 124) > 0.0)
              {
                if (*((_DWORD *)v292 + 150) == 1)
                {
                  v295 = 0;
                  if (_logHandle)
                  {
                    os_log_t v66 = (os_log_t)_logHandle;
                  }
                  else
                  {
                    if (_COREBRIGHTNESS_LOG_DEFAULT)
                    {
                      v65 = _COREBRIGHTNESS_LOG_DEFAULT;
                    }
                    else
                    {
                      uint64_t v64 = init_default_corebrightness_log();
                      v65 = v64;
                    }
                    os_log_t v66 = v65;
                  }
                  v295 = v66;
                  unsigned __int8 v294 = 2;
                  if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
                  {
                    os_log_t v61 = v295;
                    int v62 = v294;
                    v63 = v408;
                    __os_log_helper_16_0_1_8_0((uint64_t)v408, COERCE__INT64(v327));
                    _os_log_debug_impl(&dword_1BA438000, v61, (os_log_type_t)v62, "Display on L=%0.4f", v63, 0xCu);
                  }
                  int updated = AABC::UpdateDisplayBrightness_Block6((uint64_t)v292, 0, 2, 0, v327);
                  char v298 = updated & 1;
                }
                else
                {
                  int v59 = AABC::UpdateDisplayBrightness_Block6((uint64_t)v292, 1, v313, 0, v327);
                  char v298 = v59 & 1;
                }
                if (v298) {
                  IOHIDEventSetIntegerValue();
                }
              }
            }
          }
          if (*((float *)v292 + 124) > 0.0
            && *((float *)v292 + 87) != v369
            && std::__math::fabs[abi:ne180100](1.0 - (float)(v369 / *((float *)v292 + 87))) > 0.1)
          {
            float v293 = 0.0;
            if (v369 <= *((float *)v292 + 87)) {
              float v293 = 45.0;
            }
            else {
              float v293 = 3.0;
            }
            DisplaySetReflectedBrightnessWithFade(*((void *)v292 + 51), 0, 0, v369, v293);
            *((float *)v292 + 87) = v369;
          }
          if (*((_DWORD *)v292 + 150) == 1 && *((_DWORD *)v292 + 167) == 1)
          {
            if (*((_DWORD *)v292 + 92) == 3)
            {
              uint64_t v55 = v292;
              *((_DWORD *)v292 + 158) = *((_DWORD *)v402 + 12);
              *((_DWORD *)v55 + 167) = 3;
            }
            else if (*((_DWORD *)v292 + 92) == 2)
            {
              v56 = v292;
              *((_DWORD *)v292 + 158) = *((_DWORD *)v402 + 11);
              *((_DWORD *)v56 + 167) = 2;
            }
            if (*((_DWORD *)v292 + 160) && *((float *)v292 + 158) < 0.05) {
              *((_DWORD *)v292 + 158) = 1045220557;
            }
            AABC::UpdateALSState((CFDictionaryRef *)v292, 17);
          }
        }
        if (v399) {
          CFRelease(v399);
        }
      }
    }
  }
  else
  {
    os_log_t v397 = 0;
    if (_logHandle)
    {
      os_log_t v282 = (os_log_t)_logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        v281 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        v281 = init_default_corebrightness_log();
      }
      os_log_t v282 = v281;
    }
    os_log_t v397 = v282;
    os_log_type_t v396 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v282, OS_LOG_TYPE_DEBUG))
    {
      os_log_t v278 = v397;
      int v279 = v396;
      v280 = v427;
      __os_log_helper_16_0_1_4_0((uint64_t)v427, 4);
      _os_log_debug_impl(&dword_1BA438000, v397, v396, "[%x]: throwing away stale sample", v427, 8u);
    }
  }
}

void sub_1BA450560(_Unwind_Exception *a1)
{
  *uint64_t v1 = a1;
  _Unwind_Resume(*v1);
}

uint64_t std::vector<float>::size[abi:ne180100](void *a1)
{
  return (a1[1] - *a1) / 4;
}

uint64_t std::vector<float>::operator[][abi:ne180100](void *a1, uint64_t a2)
{
  return *a1 + 4 * a2;
}

uint64_t AABC::ALS::isTouchObstructed(id *this)
{
  char v2 = 0;
  if (this[3]) {
    char v2 = [this[3] isObstructed];
  }
  return v2 & 1;
}

uint64_t std::vector<float>::end[abi:ne180100](uint64_t a1)
{
  return std::vector<float>::__make_iter[abi:ne180100](a1, *(void *)(a1 + 8));
}

uint64_t std::vector<float>::begin[abi:ne180100](uint64_t *a1)
{
  return std::vector<float>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

uint64_t std::vector<float>::__make_iter[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__wrap_iter<float *>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

void *std::__wrap_iter<float *>::__wrap_iter[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void *std::__wrap_iter<float *>::__wrap_iter[abi:ne180100](void *result, uint64_t a2)
{
  *float result = a2;
  return result;
}

float std::__math::round[abi:ne180100](float a1)
{
  return round(a1);
}

float AABC::IlluminanceToReflectivity(AABC *this, float a2)
{
  return (float)(*((float *)this + 86) * a2) / 3.14159265;
}

void AABC::_ReportEsensorAggregated(AABC *this)
{
  if (*((float *)this + 135) != *((float *)this + 134))
  {
    *((_DWORD *)this + 135) = *((_DWORD *)this + 134);
    if (*((void *)this + 44))
    {
      CFNumberRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 536);
      if (cf)
      {
        (*((void (**)(void, __CFString *, CFNumberRef))this + 44))(*((void *)this + 45), @"Lux", cf);
        CFRelease(cf);
      }
    }
  }
}

float AABC::addToFilter(AABC *this, AABC::ALSFilter *a2, float a3)
{
  size_t v8 = this;
  uint64_t v7 = (uint64_t *)a2;
  float v6 = a3;
  if (std::vector<float>::size[abi:ne180100](a2))
  {
    if (CFAbsoluteTimeGetCurrent() >= *((double *)v7 + 4))
    {
      unint64_t v5 = *((unsigned __int16 *)v7 + 20);
      *((_WORD *)v7 + 20) = v5 % std::vector<float>::size[abi:ne180100](v7);
      float v4 = (float *)std::vector<float>::operator[][abi:ne180100](v7, *((unsigned __int16 *)v7 + 20));
      float result = v6;
      *float v4 = v6;
    }
    else
    {
      std::vector<float>::push_back[abi:ne180100](v7, &v6);
    }
    ++*((_WORD *)v7 + 20);
  }
  else
  {
    *((CFAbsoluteTime *)v7 + 4) = CFAbsoluteTimeGetCurrent() + (double)*((unsigned __int16 *)v7 + 12);
    std::vector<float>::push_back[abi:ne180100](v7, &v6);
    ++*((_WORD *)v7 + 20);
  }
  return result;
}

uint64_t DisplayGetBrightnessOverride(uint64_t a1, _DWORD *a2)
{
  if (*(unsigned char *)(a1 + 1504))
  {
    if (a2) {
      *a2 = *(_DWORD *)(a1 + 1524);
    }
    char v3 = 1;
  }
  else
  {
    char v3 = 0;
  }
  return v3 & 1;
}

void AABC::CancelFirstSampleTimeout(dispatch_object_t *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (this[74])
  {
    if (_logHandle)
    {
      char v3 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      char v3 = inited;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(double *)&uint64_t v1 = CFAbsoluteTimeGetCurrent();
      __os_log_helper_16_0_1_8_0((uint64_t)v5, v1);
      _os_log_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEFAULT, "ts=%f Cancelling first sample timeout", v5, 0xCu);
    }
    dispatch_release(this[74]);
    this[74] = 0;
  }
}

BOOL AABC::ignoreALSEventsInAOD(uint64_t a1, uint64_t a2)
{
  BOOL v3 = 1;
  if (a2 != 2)
  {
    BOOL v3 = 1;
    if (a2 != 3) {
      return a2 == 4;
    }
  }
  return v3;
}

void DisplaySetReflectedBrightnessWithFade(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  uint64_t v20 = a1;
  float v19 = a4;
  float v18 = a5;
  uint64_t v17 = a2;
  uint64_t v16 = a3;
  if (*(unsigned char *)(a1 + 380)) {
    float v18 = *(float *)(v20 + 376);
  }
  if ((*(unsigned char *)(v20 + 12282) & 1) == 0)
  {
    unint64_t v5 = *(NSObject **)(v20 + 144);
    uint64_t v6 = (void (*)(void))MEMORY[0x1E4F143A8];
    int v7 = -1073741824;
    int v8 = 0;
    size_t v9 = __DisplaySetReflectedBrightnessWithFade_block_invoke;
    size_t v10 = &__block_descriptor_64_e5_v8__0l;
    uint64_t v11 = v20;
    float v14 = v18;
    float v15 = v19;
    uint64_t v12 = v17;
    uint64_t v13 = v16;
    disp_dispatch_sync(v5, &v6);
  }
}

uint64_t __os_log_helper_16_2_2_8_0_8_66(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 66;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  return result;
}

void sub_1BA451B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 56), 8);
  _Unwind_Resume(a1);
}

void AABC::unregisterService(CFMutableDictionaryRef *this, __IOHIDServiceClient *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  size_t v10 = (AABC *)this;
  CFMutableDictionaryRef v9 = a2;
  os_log_t v8 = 0;
  if (_logHandle)
  {
    BOOL v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    BOOL v3 = inited;
  }
  os_log_t v8 = v3;
  os_log_type_t v7 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v11, 4);
    _os_log_debug_impl(&dword_1BA438000, v8, v7, "[%x]: ", v11, 8u);
  }
  if (this[59] && this[59] == v9) {
    this[59] = 0;
  }
  if (this[60] && this[60] == v9) {
    this[60] = 0;
  }
  value = 0;
  if (CFDictionaryGetValueIfPresent(this[53], v9, (const void **)&value))
  {
    unint64_t v5 = (id *)value;
    if (*((void *)value + 3)) {

    }
    if (v5[4]) {
    if (v5)
    }
    {
      AABC::ALS::~ALS((AABC::ALS *)v5);
      MEMORY[0x1BA9EC4A0](v5, 0x10A0C404818E04CLL);
    }
    CFDictionaryRemoveValue(this[53], v9);
    if (this[54]) {
      CFDictionaryRemoveValue(this[54], v9);
    }
  }
}

void sub_1BA452EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, id obj, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, int a19, uint64_t a20)
{
}

BOOL CBU_IsAccessory()
{
  return MGGetSInt32Answer() == 7;
}

uint64_t __os_log_helper_16_2_1_8_32(uint64_t result, uint64_t a2)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 1;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  return result;
}

uint64_t __os_log_helper_16_2_1_8_66(uint64_t result, uint64_t a2)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 1;
  *(unsigned char *)(result + 2) = 66;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  return result;
}

uint64_t CFXTriggerMitigation(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(*(void *)(result + 96) + 302) = a2 & 1;
  }
  return result;
}

float CFXSetSampleStrength(uint64_t a1, float result)
{
  if (a1) {
    *(float *)(*(void *)(a1 + 96) + 332) = result;
  }
  return result;
}

float CFXSetFadeDuration(uint64_t a1, char a2)
{
  if (a1 && *(void *)(a1 + 96))
  {
    uint64_t v3 = *(void *)(a1 + 96);
    *(_DWORD *)(v3 + 180) = 1114636288;
    *(float *)(v3 + 176) = 20.0;
    if (a2)
    {
      float result = 15.0;
      *(float *)(v3 + 160) = 15.0;
      *(float *)(v3 + 164) = 15.0;
      *(float *)(v3 + 168) = 15.0;
      *(float *)(v3 + 172) = 15.0;
    }
    else
    {
      float result = 5.0;
      *(float *)(v3 + 160) = 5.0;
      *(float *)(v3 + 164) = 5.0;
      *(float *)(v3 + 168) = 5.0;
      *(float *)(v3 + 172) = 5.0;
    }
  }
  return result;
}

void CFXInputAmbientColor(uint64_t *a1, float *a2, int a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  float v18 = a1;
  uint64_t v17 = a2;
  int v16 = a3;
  float v15 = a1;
  if (a1 && v17)
  {
    if (v17[1] >= 11140.846)
    {
      float v17[3] = 0.31272;
      v17[4] = 0.329;
      CFXChromaticity2Tristimulus(v17 + 3, v17, v17[1]);
      v17[5] = 6500.0;
    }
    memcpy(v15, v17, 0x3CuLL);
    *((_DWORD *)v15 + 19) = v16;
    char v14 = 0;
    _CFXAdaptToColorSample((uint64_t)v15, (uint64_t)v17, v16, &v14, 0.0);
    if (*((unsigned char *)v15 + 1801)) {
      _CFXLogSample((uint64_t)v15, v14 & 1);
    }
    *((unsigned char *)v15 + 344) = 0;
    int v13 = 0;
    int v12 = 0;
    if (v17[3] == 0.0 && v17[4] == 0.0)
    {
      int v12 = 0;
      int v13 = 0;
    }
    else
    {
      uint64_t v19 = 0;
      int v20 = 0;
      CFXChromaticity2Tristimulus(v17 + 3, (float *)&v19, 100.0);
      uint64_t v10 = 0;
      int v11 = 0;
      CFXTristimulus2Lab((float *)&v19, (float *)&v10);
      int v13 = binFromAb((float *)&v10 + 1);
      int v12 = ansiBinFromChromaticity(v17 + 3);
    }
    if (v13 != *((_DWORD *)v15 + 253))
    {
      uint64_t v9 = mach_absolute_time();
      double v8 = MachTimeToSeconds(v9 - v15[127]);
      uint64_t v3 = (double *)&v15[*((int *)v15 + 253) + 101];
      *uint64_t v3 = *v3 + v8;
      v15[127] = v9;
      *((_DWORD *)v15 + 253) = v13;
      ++*((_DWORD *)v15 + v13 + 236);
    }
    if (v12 != *((_DWORD *)v15 + 402))
    {
      uint64_t v7 = mach_absolute_time();
      double v6 = MachTimeToSeconds(v7 - v15[202]);
      float v4 = (double *)&v15[*((int *)v15 + 402) + 155];
      *float v4 = *v4 + v6;
      v15[202] = v7;
      *((_DWORD *)v15 + 402) = v12;
    }
    float v5 = v17[1] * 3.14159265;
    CFXAmmoliteUpdateTarget(v15[282], v5);
    if (v15[282] && (*(unsigned char *)(v15[282] + 24) & 1) != 0)
    {
      if (v15[41]) {
        ((void (*)(uint64_t, void))v15[41])(v15[42], 0);
      }
    }
  }
}

uint64_t binFromAb(float *a1)
{
  float v10 = *a1;
  float v9 = a1[1];
  unsigned int v8 = 0;
  if (fmaxf(fabsf(*a1), fabsf(v9)) != 0.0)
  {
    float v7 = sqrtf((float)(v9 * v9) + (float)(v10 * v10));
    if (v7 <= 15.0) {
      int v1 = 1;
    }
    else {
      int v1 = 9;
    }
    int v6 = v1;
    float v2 = atan2f(v9 / v7, v10 / v7) + 0.392699082;
    float v5 = v2;
    if (v2 < 0.0)
    {
      float v3 = v2 + 6.28318531;
      float v5 = v3;
    }
    syslog(7, "%f %f %f -> ANGLE %f -> BIN %d", v7, v10, v9, v5, (int)(v5 / 0.785398163));
    return ((int)(v5 / 0.785398163) + v6);
  }
  return v8;
}

double MachTimeToSeconds(unint64_t a1)
{
  unint64_t v6 = a1;
  double v5 = 0.0;
  mach_timebase_info info = 0;
  if (!mach_timebase_info(&info))
  {
    LODWORD(v1) = info.numer;
    *(double *)&unint64_t v2 = (double)v1;
    LODWORD(v2) = info.denom;
    double v5 = 0.000000001 * (double)v1 / (double)v2;
  }
  return (double)v6 * v5;
}

uint64_t ansiBinFromChromaticity(float *a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  int v41 = a1;
  int v40 = -1;
  int v39 = 0;
  for (int i = 0; i < 14; ++i)
  {
    for (int j = 0; j < 3; ++j)
    {
      char v36 = 0;
      uint64_t v42 = (float *)&ColorAnsiBins[8 * i + 2 * j];
      int v23 = 1;
      int v43 = (float *)&ColorAnsiBins[8 * i + 2 + 2 * j];
      int v44 = (float *)&ColorAnsiBins[8 * i + 8 + 2 * j];
      BOOL v1 = triangleInclusion(v41, &v42);
      char v36 = v1 & v23;
      if (v1 & v23)
      {
        double v2 = *v41;
        double v3 = v41[1];
        double v4 = *v42;
        double v5 = v42[1];
        double v6 = *v43;
        double v7 = v43[1];
        double v8 = *v44;
        double v9 = v44[1];
        float v22 = v20;
        syslog(7, "BIN %d: (%f, %f) fitting in (%f, %f)-(%f, %f)-(%f, %f)\n", v39, v2, v3, v4, v5, v6, v7, v8, v9);
        int v40 = v39;
        break;
      }
      int v21 = 1;
      uint64_t v42 = (float *)&ColorAnsiBins[8 * i + 10 + 2 * j];
      BOOL v10 = triangleInclusion(v41, &v42);
      char v36 = v10 & v21;
      if (v10 & v21)
      {
        double v11 = *v41;
        double v12 = v41[1];
        double v13 = *v42;
        double v14 = v42[1];
        double v15 = *v43;
        double v16 = v43[1];
        double v17 = *v44;
        double v18 = v44[1];
        v20[11] = v20;
        syslog(7, "BIN %d: (%f, %f) fitting in (%f, %f)-(%f, %f)-(%f, %f)\n", v39, v11, v12, v13, v14, v15, v16, v17, v18);
        int v40 = v39;
        break;
      }
      ++v39;
    }
    if (v40 >= 0) {
      break;
    }
  }
  if (v40 < 0)
  {
    if ((float v35 = (float)(0.4313 - 0.521) / (float)(0.5443 - 0.6127),
          float v34 = 0.521 - (float)(v35 * 0.6127),
          float v33 = 0.0,
          float v33 = v41[1] - (float)(v35 * *v41),
          float v32 = v33 - v34,
          v35 >= 0.0)
      && v32 <= 0.0
      || v35 < 0.0 && v32 > 0.0)
    {
      int v40 = 42;
    }
  }
  if (v40 < 0)
  {
    if ((float v31 = (float)(0.2585 - 0.2757) / (float)(0.2391 - 0.2127),
          float v30 = 0.2757 - (float)(v31 * 0.2127),
          float v29 = 0.0,
          float v29 = v41[1] - (float)(v31 * *v41),
          float v28 = v29 - v30,
          v31 >= 0.0)
      && v28 >= 0.0
      || v31 < 0.0 && v28 < 0.0)
    {
      int v40 = 43;
    }
  }
  if (v40 < 0)
  {
    float v27 = (float)(0.2757 - 0.521) / (float)(0.2127 - 0.6127);
    float v26 = 0.2757 - (float)(v27 * 0.2127);
    float v25 = 0.0;
    float v25 = v41[1] - (float)(v27 * *v41);
    float v24 = v25 - v26;
    if ((float)(v25 - v26) < 0.0) {
      return 45;
    }
    else {
      return 44;
    }
  }
  return v40;
}

BOOL triangleInclusion(float *a1, float **a2)
{
  BOOL v10 = 0;
  float v9 = *a2[1] - **a2;
  float v8 = *a2[2] - **a2;
  float v7 = a2[1][1] - (*a2)[1];
  float v6 = a2[2][1] - (*a2)[1];
  float v5 = *a1 - **a2;
  float v2 = a1[1] - (*a2)[1];
  float v4 = (float)((float)(v9 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v2)
     + (float)((float)((float)-v7 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v5);
  if ((float)((float)((float)((float)-v8 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v2)
             + (float)((float)(v6 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v5)) >= 0.0
    && v4 >= 0.0)
  {
    return (float)((float)((float)((float)((float)-v8 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v2)
                         + (float)((float)(v6 / (float)-(float)((float)(v8 * v7) - (float)(v9 * v6))) * v5))
                 + v4) <= 1.0;
  }
  return v10;
}

void _CFXAdaptToColorSample(uint64_t a1, uint64_t a2, int a3, unsigned char *a4, float a5)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a1;
  uint64_t v12 = a2;
  int v11 = a3;
  float v10 = a5;
  float v9 = a4;
  syslog(7, "LOWLUX %f\n", *(float *)(a2 + 4));
  uint64_t v14 = 0;
  int v15 = 0;
  int v8 = 0;
  char v7 = 0;
  char v6 = 0;
  if (_CFXRestrictLowAmbientColor(v13, v12, (float *)&v14, (float *)&v8, &v7))
  {
    if ((*(unsigned char *)(*(void *)(v13 + 96) + 220) & 1) != 0
      || (v7 & 1) != 0
      || (*(unsigned char *)(*(void *)(v13 + 96) + 288) & 1) != 0)
    {
      char v6 = 1;
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(v13 + 96) + 220) = 0;
    char v6 = 1;
  }
  if (v6)
  {
    if (*(unsigned char *)(*(void *)(v13 + 96) + 288)) {
      float v10 = 2.0;
    }
    __memcpy_chk();
    *(_DWORD *)(v13 + 92) = v8;
    if (*(unsigned char *)(*(void *)(v13 + 96) + 184))
    {
      BOOL v5 = 1;
      if ((*(unsigned char *)(v13 + 344) & 1) == 0) {
        BOOL v5 = (v11 & 1) != 0;
      }
      _CFXUpdateTarget(v13, (float *)(v13 + 80), v5, (v11 & 2) != 0, v10);
    }
  }
  *float v9 = v6 & 1;
  *(unsigned char *)(*(void *)(v13 + 96) + 288) = 0;
}

void _CFXUpdateTarget(uint64_t a1, float *a2, char a3, char a4, float a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a1;
  float v24 = a2;
  char v23 = a3 & 1;
  float v22 = a5;
  char v21 = a4 & 1;
  uint64_t v20 = 0;
  uint64_t v20 = *(void *)(a1 + 96);
  _CFXIdentity(v28);
  if (v20
    && (*(unsigned char *)(v20 + 184) & 1) != 0
    && *(float *)v20 >= 0.0
    && (*v24 != 0.0 || v24[1] != 0.0 || v24[2] != 0.0))
  {
    _CFXGetTarget(v25, v24, v28, *(void *)(v20 + 56), *(_DWORD *)(v20 + 148), v20 + 144, v20 + 64, 0, *(float *)v20);
  }
  float v19 = 0.0;
  *(void *)double v18 = 0;
  int v17 = 0;
  _CFXGetWPFromMatrix(v25, v28, v18, &v17);
  CFXChromaticity2uv(v18, &v26);
  float v19 = CFXChromaticity2CCT(v18);
  float v16 = 0.0;
  float v16 = v26 - *(float *)(v25 + 120);
  float v15 = 0.0;
  float v15 = v27 - *(float *)(v25 + 124);
  float v5 = sqrt((float)((float)(v15 * v15) + (float)(v16 * v16)));
  float v14 = v5;
  float v13 = 0.0;
  if ((v23 & 1) != 0 || v20 && v14 >= *(float *)(v20 + 156))
  {
    int v12 = 0;
    if (v23)
    {
      float v13 = v22;
    }
    else if (v24[1] >= *(float *)(v20 + 196) / 3.14159265)
    {
      if (v24[1] >= *(float *)(v20 + 204) / 3.14159265)
      {
        if (v19 < (float)*(unsigned int *)(v25 + 128))
        {
          float v13 = *(float *)(v20 + 164);
          int v12 = 1;
        }
        else
        {
          float v13 = *(float *)(v20 + 160);
        }
      }
      else
      {
        float v13 = *(float *)(v20 + 176);
        int v12 = 2;
      }
    }
    else
    {
      float v13 = *(float *)(v20 + 180);
      int v12 = 2;
    }
    if ((v23 & 1) == 0)
    {
      float v11 = 0.0;
      uint64_t v9 = v25 + 760;
      double Current = CFAbsoluteTimeGetCurrent();
      if (_CFXCheckStats(v9, v12, &v11, Current)) {
        float v13 = fmaxf(v11, v13);
      }
    }
    _CFXSetTarget(v25, v28, 1, 1, v13, 1.0);
    *(float *)(v25 + 120) = v26;
    *(float *)(v25 + 124) = v27;
    *(_DWORD *)(v25 + 128) = v19;
  }
  else if (v20 && v14 >= *(float *)(v20 + 152))
  {
    if (v24[1] >= *(float *)(v20 + 196) / 3.14159265)
    {
      if (v24[1] >= *(float *)(v20 + 204) / 3.14159265)
      {
        if (v19 < (float)*(unsigned int *)(v25 + 128)) {
          float v13 = *(float *)(v20 + 172);
        }
        else {
          float v13 = *(float *)(v20 + 168);
        }
      }
      else
      {
        float v13 = *(float *)(v20 + 176);
      }
    }
    else
    {
      float v13 = *(float *)(v20 + 180);
    }
    float v10 = 0.0;
    uint64_t v8 = v25 + 760;
    double v7 = CFAbsoluteTimeGetCurrent();
    if (_CFXCheckStats(v8, 3, &v10, v7)) {
      float v13 = fmaxf(v10, v13);
    }
    if (_CFXSetTarget(v25, v28, 0, 1, v13, 1.0))
    {
      *(float *)(v25 + 120) = v26;
      *(float *)(v25 + 124) = v27;
      *(_DWORD *)(v25 + 128) = v19;
    }
  }
}

float CFXChromaticity2uv(float *a1, float *a2)
{
  float v3 = (float)((float)(12.0 * a1[1]) + (float)(-2.0 * *a1)) + 3.0;
  *a2 = (float)(4.0 * *a1) / v3;
  float result = (float)(9.0 * a1[1]) / v3;
  a2[1] = result;
  return result;
}

uint64_t _CFXRestrictLowAmbientColor(uint64_t a1, uint64_t a2, float *a3, float *a4, unsigned char *a5)
{
  uint64_t v24 = a1;
  char v23 = (float *)a2;
  float v22 = a3;
  char v21 = a4;
  uint64_t v20 = a5;
  char v19 = 0;
  uint64_t v18 = 0;
  *a5 = 0;
  if (v23[4] >= 0.1958) {
    *char v21 = CFXChromaticity2CCT(v23 + 3);
  }
  else {
    *char v21 = v23[5];
  }
  syslog(7, "[%s:%s] xy=(%f,%f), CCT = %f, CCT1 = %f", "ColorEffects.c", "_CFXRestrictLowAmbientColor", v23[3], v23[4], *v21, v23[5]);
  if (v24 && *(void *)(v24 + 96))
  {
    uint64_t v17 = 0;
    uint64_t v17 = *(void *)(v24 + 96);
    float v16 = 0.0;
    float v5 = v23[1] * 3.14159265;
    float v16 = v5;
    if (*(unsigned char *)(*(void *)(v24 + 96) + 302))
    {
      char v19 = _CFXRestrictLowAmbientColorWithMitigation(v24, (uint64_t)v23, (float *)&v18, v20) & 1;
    }
    else if (v16 <= *(float *)(v17 + 196))
    {
      uint64_t v15 = 0;
      if (v16 > 2.0 && *v21 >= 6000.0)
      {
        uint64_t v15 = 0x3EA872D23EA01C4CLL;
        if (vabdd_f64(*(float *)(v24 + 92), 6504.0) > 1000.0) {
          *uint64_t v20 = 1;
        }
      }
      else
      {
        uint64_t v15 = *(void *)(v17 + 212);
        if (fabs((float)(*(float *)(v24 + 92) - 4000.0)) > 1000.0) {
          *uint64_t v20 = 1;
        }
      }
      if (v16 > *(float *)(v17 + 192))
      {
        uint64_t v14 = 0;
        uint64_t v14 = *(void *)(v23 + 3);
        float v13 = 0.0;
        float v13 = (float)(*(float *)(v17 + 196) - v16) / (float)(*(float *)(v17 + 196) - *(float *)(v17 + 192));
        *(float *)&uint64_t v18 = (float)((float)(1.0 - v13) * *(float *)&v14) + (float)(v13 * *(float *)&v15);
        *((float *)&v18 + 1) = (float)((float)(1.0 - v13) * *((float *)&v14 + 1)) + (float)(v13 * *((float *)&v15 + 1));
        double v6 = *v21;
        int v12 = &v10;
        syslog(7, "RESTRICTION in Lux=%f: CCT %f +Fixed (alpha=%f) => RC = (%f, %f), xyFixed = (%f, %f), xy = (%f, %f)\n", v16, v6, v13, *(float *)&v14, *((float *)&v14 + 1), *(float *)&v15, *((float *)&v15 + 1), *(float *)&v18, *((float *)&v18 + 1));
      }
      else
      {
        uint64_t v18 = v15;
        syslog(7, "RESTRICTION in Lux=%f: xyFixed xy = (%f, %f)\n", v16, *(float *)&v15, *((float *)&v15 + 1));
      }
      char v19 = 1;
    }
  }
  if (v19)
  {
    float v7 = fmaxf(v23[1], 1.0);
    float v11 = (float *)&v18;
    CFXChromaticity2Tristimulus((float *)&v18, v22, v7);
    float v8 = CFXChromaticity2CCT(v11);
    *char v21 = v8;
  }
  else
  {
    __memcpy_chk();
  }
  return v19 & 1;
}

float CFXChromaticity2CCT(float *a1)
{
  float v1 = (*a1 - 0.332) / (0.1858 - a1[1]);
  return (float)(int)((float)((float)((float)(3525.0 * v1) * v1) + (float)((float)((float)(449.0 * v1) * v1) * v1))
                    + 6823.3 * v1
                    + 5520.33);
}

uint64_t _CFXRestrictLowAmbientColorWithMitigation(uint64_t a1, uint64_t a2, float *a3, unsigned char *a4)
{
  char v10 = 0;
  *a4 = 0;
  if (a1)
  {
    if (*(void *)(a1 + 96))
    {
      uint64_t v9 = *(void *)(a1 + 96);
      float v4 = *(float *)(a2 + 4) * 3.14159265;
      if (v4 <= *(float *)(v9 + 196))
      {
        if (v4 > 2.0) {
          uint64_t v8 = 0x3EACE8533EA4B5DDLL;
        }
        else {
          uint64_t v8 = *(void *)(v9 + 212);
        }
        if (v4 > *(float *)(v9 + 192))
        {
          uint64_t v7 = *(void *)(a2 + 12);
          float v6 = (float)(*(float *)(v9 + 196) - v4) / (float)(*(float *)(v9 + 196) - *(float *)(v9 + 192));
          *a3 = (float)((float)(1.0 - v6) * *(float *)&v7) + (float)(v6 * *(float *)&v8);
          a3[1] = (float)((float)(1.0 - v6) * *((float *)&v7 + 1)) + (float)(v6 * *((float *)&v8 + 1));
        }
        else
        {
          *(void *)a3 = v8;
        }
        char v10 = 1;
        *a4 = 1;
      }
    }
  }
  return v10 & 1;
}

float _CFXIdentity(float *a1)
{
  __memset_chk();
  float result = 1.0;
  a1[8] = 1.0;
  a1[4] = 1.0;
  *a1 = 1.0;
  return result;
}

void CFXAmmoliteUpdateTarget(uint64_t a1, float a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    for (int i = 0; i < *(void *)(a1 + 8); ++i)
    {
      if (a2 < *(float *)(*(void *)a1 + 40 * i))
      {
        uint64_t v11 = i;
        break;
      }
    }
    if (v11)
    {
      if (v11 < *(void *)(a1 + 8))
      {
        float v9 = (float)(a2 - *(float *)(*(void *)a1 + 40 * (v11 - 1)))
           / (float)(*(float *)(*(void *)a1 + 40 * v11) - *(float *)(*(void *)a1 + 40 * (v11 - 1)));
        for (int j = 0; j < 3; ++j)
        {
          for (int k = 0; k < 3; ++k)
          {
            float v2 = (float)(v9 * *(float *)(*(void *)a1 + 40 * v11 + 4 + 12 * j + 4 * k))
               + (1.0 - v9) * *(float *)(*(void *)a1 + 40 * (v11 - 1) + 4 + 12 * j + 4 * k);
            *(float *)&__dst[3 * j + k] = v2;
          }
        }
      }
      else
      {
        memcpy(__dst, (const void *)(*(void *)a1 + 40 * (*(void *)(a1 + 8) - 1) + 4), sizeof(__dst));
      }
    }
    else
    {
      memcpy(__dst, (const void *)(*(void *)a1 + 4), sizeof(__dst));
    }
    float v3 = fabs((float)(a2 - *(float *)(a1 + 28)));
    float v6 = v3;
    float v5 = 0.0;
    if (*(float *)(a1 + 28) > 0.0) {
      float v5 = v3 / *(float *)(a1 + 28);
    }
    if (*(void *)(a1 + 48)) {
      float v4 = *(NSObject **)(a1 + 48);
    }
    else {
      float v4 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_4_8_32_8_0_8_0_8_0((uint64_t)v14, (uint64_t)"CFXAmmoliteUpdateTarget", COERCE__INT64(a2), COERCE__INT64(v6), COERCE__INT64(*(float *)(a1 + 32)));
      _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_INFO, "%s: Ammolite: Lux %f (delta %f / thr %f)\n", v14, 0x2Au);
    }
    if (v6 > *(float *)(a1 + 32)
      && (*(float *)(a1 + 28) == 0.0 || *(float *)(a1 + 28) > 0.0 && v5 > *(float *)(a1 + 36)))
    {
      *(float *)(a1 + 28) = a2;
      *(unsigned char *)(*(void *)(a1 + 16) + 16) = 0;
      __memcpy_chk();
      __memcpy_chk();
      *(CFAbsoluteTime *)(*(void *)(a1 + 16) + 8) = CFAbsoluteTimeGetCurrent();
      **(double **)(a1 + 16) = *(float *)(a1 + 40);
      *(unsigned char *)(a1 + 24) = 1;
    }
    else
    {
      *(unsigned char *)(a1 + 24) = 0;
    }
  }
}

uint64_t _CFXCheckStats(uint64_t a1, int a2, float *a3, double a4)
{
  char v11 = 0;
  while (*(void *)(a1 + 8) && **(double **)(a1 + 8) < a4 - *(double *)(a1 + 32))
  {
    uint64_t v10 = *(void *)(*(void *)(a1 + 8) + 8);
    free(*(void **)(a1 + 8));
    *(void *)(a1 + 8) = v10;
    --*(_DWORD *)(a1 + 24);
    syslog(7, "REMOVING STAT\n");
    if (!*(_DWORD *)(a1 + 24)) {
      *(void *)(a1 + 16) = 0;
    }
  }
  if (*(void *)(a1 + 16) && a4 - **(double **)(a1 + 16) > *(float *)(a1 + 44))
  {
    syslog(7, "CLEARING STATS\n");
    _CFXClearStats(a1);
  }
  if (a2 != *(_DWORD *)a1 && a2 != 3)
  {
    float v9 = (double *)malloc_type_malloc(0x10uLL, 0x10200405730B0C9uLL);
    v9[1] = 0.0;
    *float v9 = a4;
    if (*(void *)(a1 + 8) && *(void *)(a1 + 16))
    {
      *(void *)(*(void *)(a1 + 16) + 8) = v9;
      *(void *)(a1 + 16) = v9;
    }
    else
    {
      *(void *)(a1 + 8) = v9;
      *(void *)(a1 + 16) = v9;
    }
    ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)a1 = a2;
    syslog(7, "ADDING %d STAT\n", *(_DWORD *)(a1 + 24));
  }
  *a3 = 0.0;
  if (*(void *)(a1 + 8))
  {
    if (*(void *)(a1 + 16))
    {
      double v8 = **(double **)(a1 + 16) - **(double **)(a1 + 8);
      syslog(7, "DELTAT %f\n", v8);
      if (*(int *)(a1 + 24) >= 5)
      {
        float v4 = (float)((float)*(int *)(a1 + 24) - 1.0) / v8;
        float v7 = v4;
        syslog(7, "Freq %f Hz\n", v4);
        float v5 = 3.0 / v7;
        *(float *)(a1 + 44) = v5;
        syslog(7, "Switch time %f\n", *(float *)(a1 + 44));
        *a3 = 10.0 / v7;
        char v11 = 1;
      }
    }
  }
  return v11 & 1;
}

void sub_1BA457D30()
{
  _Unwind_Resume(v0);
}

void AABC::UpdateAggregateFunction(AABC *this, id *a2, AABC::ALS *a3, AABC *a4)
{
}

void AABC::_UpdateAggregateFunction(AABC *this, __IOHIDServiceClient *a2, id *a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  float v34 = this;
  float v33 = a2;
  float v32 = a3;
  if (a3 == *((id **)this + 57))
  {
    BOOL v31 = 0;
    BOOL v9 = !*((void *)this + 60) || (*((unsigned char *)this + 3937) & 1) == 0 || *((_DWORD *)this + 987) == 0;
    BOOL v31 = v9;
    char v30 = (AABC::ALS::isTouchObstructed(v32) ^ 1) & 1;
    if (*((float *)v32 + 39) > *((float *)this + 136) || v31 && (v30 & 1) != 0) {
      AABC::_UpdateEsensorTrusted(this, *((float *)v32 + 39));
    }
    if (*((int *)this + 926) < 0) {
      *((void *)this + 485) = mach_absolute_time();
    }
    *((_DWORD *)this + 926) = *((_DWORD *)v32 + 1);
    if (*((int *)this + 926) >= 9) {
      *((_DWORD *)this + 926) = 8;
    }
  }
  else if (*((float *)v32 + 39) > *((float *)this + 136))
  {
    *((void *)this + 57) = v32;
    AABC::_UpdateEsensorTrusted(this, *((float *)v32 + 39));
    uint64_t v29 = mach_absolute_time();
    if (*((int *)this + 926) >= 0)
    {
      unint64_t v28 = 0;
      unint64_t v28 = v29 - *((void *)this + 485);
      float v3 = (double *)((char *)this + 8 * *((int *)this + 926) + 3808);
      *float v3 = *v3 + (double)v28 * *(double *)&AABC::_sMachTimebaseFactor;
    }
    *((_DWORD *)this + 926) = *((_DWORD *)v32 + 1);
    if (*((int *)this + 926) >= 9) {
      *((_DWORD *)this + 926) = 8;
    }
    *((void *)this + 485) = v29;
    ++*((_DWORD *)this + 974);
  }
  if (*((float *)v32 + 39) > *((float *)this + 134)) {
    *((_DWORD *)this + 134) = *((_DWORD *)v32 + 39);
  }
  *((float *)this + 152) = fmaxf(*((float *)v32 + 39), *((float *)this + 152));
  os_log_t v27 = 0;
  if (_logHandle)
  {
    double v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    double v8 = inited;
  }
  os_log_t v27 = v8;
  os_log_type_t v26 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_4_0_8_0_8_0_8_0((uint64_t)v35, 16, COERCE__INT64(*((float *)v32 + 39)), COERCE__INT64(*((float *)this + 136)), COERCE__INT64(*((float *)this + 134)));
    _os_log_debug_impl(&dword_1BA438000, v27, v26, "[%x]: _Esensor_filtered=%0.4f _Esensor_trusted=%0.4f _Esensor_aggregated=%0.4f", v35, 0x26u);
  }
  uint64_t v25 = mach_absolute_time();
  if ([*((id *)this + 488) count])
  {
    uint64_t v20 = 0;
    char v21 = (float *)&v20;
    int v22 = 0x20000000;
    int v23 = 32;
    float v24 = -1.0;
    uint64_t v15 = 0;
    uint64_t v16 = (float *)&v15;
    int v17 = 0x20000000;
    int v18 = 32;
    int v19 = 1259902592;
    objc_msgSend(*((id *)this + 488), "enumerateKeysAndObjectsUsingBlock:");
    double v14 = (double)(v25 - *((void *)this + 486)) * *(double *)&AABC::_sMachTimebaseFactor;
    if (v21[6] > 5.0) {
      int v13 = (int)((log10((v21[6] + 1.0) / (v16[6] + 1.0)) + 0.25) * 2.0) + 1;
    }
    else {
      int v13 = 0;
    }
    if (v13 > 11) {
      int v13 = 11;
    }
    *((double *)this + v13 + 464) = *((double *)this + v13 + 464) + v14;
    _Block_object_dispose(&v15, 8);
    _Block_object_dispose(&v20, 8);
  }
  id v6 = objc_alloc(NSNumber);
  id v12 = (id)[v6 initWithInt:*((unsigned int *)v32 + 1)];
  id v5 = objc_alloc(NSNumber);
  LODWORD(v4) = *((_DWORD *)v32 + 39);
  id v11 = (id)[v5 initWithFloat:v4];
  if (v12) {
    [*((id *)this + 488) setObject:v11 forKey:v12];
  }

  *((void *)this + 486) = v25;
}

void sub_1BA458DB0()
{
  _Unwind_Resume(v0);
}

void AABC::_UpdateEsensorTrusted(AABC *this, float a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  int v54 = this;
  float v53 = a2;
  float v52 = -1.0;
  float v51 = a2;
  *((unsigned char *)this + 316) = 0;
  if (([*((id *)this + 37) isRearALSSupported] & 1) != 0
    && ([*((id *)this + 37) started] & 1) != 0)
  {
    *(void *)&double v2 = LODWORD(v53);
    float v50 = v53;
    if (*((_DWORD *)this + 130) || *((_DWORD *)this + 169)) {
      float v50 = -1.0;
    }
    *(float *)&double v2 = v50;
    [*((id *)this + 37) checkSensorEnablementConditions:v2];
    id v49 = 0;
    id v49 = (id)[*((id *)this + 37) copyParam:@"lux"];
    if (v49)
    {
      [v49 floatValue];
      float v48 = v3;

      float v47 = 0.0;
      float v47 = fminf(fmaxf(AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 802, v50, fminf(v50, *((float *)this + 1007))), *((float *)this + 180)), *((float *)this + 182));
      float v46 = 0.0;
      [*((id *)this + 37) nitsRatio];
      float v46 = v4;
      float v45 = v4 * v47;
      float v45 = fminf(v4 * v47, *((float *)this + 182));
      float v44 = AABC::LuminanceToIlluminance((uint64_t)this, (float *)this + 802, v45);
      float v48 = fminf(v48, 8079.0);
      char v43 = 0;
      *(float *)&double v5 = v50;
      *(float *)&double v6 = v48;
      *(float *)&double v7 = v44;
      char v43 = [*((id *)this + 37) shouldUseRearLuxFrontLux:v5 rearLux:v6 andCap:v7] & 1;
      if (v43)
      {
        float v52 = fminf(v48, v44);
        float v53 = v48;
        *((unsigned char *)this + 316) = 1;
      }
      if (v52 != *((float *)this + 78))
      {
        *((float *)this + 78) = v52;
        if (*((float *)this + 136) == v53 && v53 >= 0.001)
        {
          float v8 = v53 - 0.001;
          float v53 = v8;
        }
      }
      if (*((void *)this + 48))
      {
        id v42 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
        context = (void *)MEMORY[0x1BA9ECAE0]();
        *(float *)&double v9 = v50;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v9), @"frontLux");
        *(float *)&double v10 = v48;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v10), @"rearLux");
        *(float *)&double v11 = v47;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v11), @"frontNits-Default");
        *(float *)&double v12 = v45;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v12), @"rearNits-Default");
        *(float *)&double v13 = v53;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v13), @"finalLux");
        *(float *)&double v14 = v52;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v14), @"cappedLuxForAAB");
        int v41 = 0;
        *(float *)&double v15 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, v50, fminf(v50, *((float *)this + 1007)));
        int v41 = LODWORD(v15);
        float v40 = -1.0;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v15), @"frontNits");
        if (*((unsigned char *)this + 316))
        {
          *(float *)&double v16 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, v52, fminf(v52, *((float *)this + 1007)));
          float v40 = *(float *)&v16;
        }
        else
        {
          LODWORD(v16) = v41;
        }
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v16), @"finalNits");
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithBool:", *((unsigned char *)this + 316) & 1), @"rearLuxInUse");
        *(float *)&double v17 = v40;
        objc_msgSend(v42, "setObject:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v17), @"rearNits");
        id v39 = 0;
        id v39 = (id)[*((id *)this + 37) copyParam:@"GainChanged"];
        if (v39) {
          [v42 setObject:v39 forKey:@"gainChanged"];
        }
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"RLuxStats", v42);
        if (*((void *)this + 44)) {
          (*((void (**)(void, __CFString *, id))this + 44))(*((void *)this + 45), @"RLuxStats", v42);
        }
      }
    }
    else
    {
      BOOL v38 = 0;
      if (_logHandle)
      {
        unint64_t v28 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        unint64_t v28 = inited;
      }
      BOOL v38 = v28;
      char v37 = 2;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        log = v38;
        os_log_type_t type = v37;
        __os_log_helper_16_0_0(v36);
        _os_log_debug_impl(&dword_1BA438000, log, type, "AABRear: Lux not available", v36, 2u);
      }
    }
  }
  char v35 = 0;
  if (!float_equal(*((float *)this + 136), v53))
  {
    *((float *)this + 136) = v53;
    *(float *)&v34[1] = v53;
    v34[0] = 2;
    DisplayUpdateAAPState(*((void *)this + 51), (uint64_t)v34, 1, 1);
    *((float *)this + 139) = fminf(*((float *)this + 136), *((float *)this + 1007));
    if (v52 >= 0.0) {
      *((float *)this + 139) = fminf(*((float *)this + 139), v52);
    }
    if (*((unsigned char *)this + 3936)) {
      float v24 = v53;
    }
    else {
      float v24 = truncf(v53);
    }
    float v33 = fmaxf(v24, 0.0);
    if (vabds_f32(v33, *((float *)this + 138)) > 0.001)
    {
      *((float *)this + 138) = v33;
      char v35 = 1;
      if (*((void *)this + 44))
      {
        CFNumberRef v32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 552);
        if (v32)
        {
          (*((void (**)(void, __CFString *, CFNumberRef))this + 44))(*((void *)this + 45), @"TrustedLux", v32);
          CFRelease(v32);
        }
      }
    }
    AABC::_UpdateSemanticAmbientLightLevel((uint64_t)this, 255);
    if (*((unsigned char *)this + 4084))
    {
      if (*((float *)this + 136) <= *((float *)this + 1022) && *((float *)this + 123) >= 1.0)
      {
        if (*((float *)this + 136) < (float)(*((float *)this + 1022) - 100.0)
          && *((float *)this + 136) < (float)(*((float *)this + 1022) * 0.1))
        {
          *((_DWORD *)this + 1022) = *((_DWORD *)this + 136);
          if (!*((_DWORD *)this + 130))
          {
            if (_logHandle)
            {
              char v21 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v20 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v20 = init_default_corebrightness_log();
              }
              char v21 = v20;
            }
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v56, COERCE__INT64(*((float *)this + 136)));
              _os_log_debug_impl(&dword_1BA438000, v21, OS_LOG_TYPE_DEBUG, "Resetting weak cap in lux = %f\n", v56, 0xCu);
            }
            DisplayUpdateWeakCapOnSignificantAmbientChange(*((void *)this + 51));
          }
        }
      }
      else
      {
        *((_DWORD *)this + 1022) = *((_DWORD *)this + 136);
        if (_logHandle)
        {
          int v23 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v22 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v22 = init_default_corebrightness_log();
          }
          int v23 = v22;
        }
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v57, COERCE__INT64(*((float *)this + 136)));
          _os_log_debug_impl(&dword_1BA438000, v23, OS_LOG_TYPE_DEBUG, "Updating weak cap Emax = %f\n", v57, 0xCu);
        }
      }
    }
  }
  if (*((float *)this + 137) != v51)
  {
    float v51 = fminf(v51, *((float *)this + 1007));
    if (*((void *)this + 44))
    {
      if (*((int *)this + 137) != SLODWORD(v51))
      {
        char v35 = 1;
        CFNumberRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 548);
        if (cf)
        {
          (*((void (**)(void, __CFString *, CFNumberRef))this + 44))(*((void *)this + 45), @"TrustedFrontLux", cf);
          CFRelease(cf);
        }
      }
    }
    *((float *)this + 137) = v51;
  }
  if (v35)
  {
    if (_logHandle)
    {
      int v19 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v18 = init_default_corebrightness_log();
      }
      int v19 = v18;
    }
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v55, COERCE__INT64(*((float *)this + 136)), COERCE__INT64(*((float *)this + 137)), COERCE__INT64(*((float *)this + 139)));
      _os_log_impl(&dword_1BA438000, v19, OS_LOG_TYPE_DEFAULT, "trusted Lux: %f, trusted front Lux: %f, trusted capped Lux: %f", v55, 0x20u);
    }
  }
}

float AABC::IlluminanceToLuminance(uint64_t a1, float *a2, float a3, float a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  float v8 = a4;
  if (a2[25] > 0.0) {
    float v8 = fminf(a2[25], a3);
  }
  if (_logHandle)
  {
    double v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    double v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v12, COERCE__INT64(a3), COERCE__INT64(a4), COERCE__INT64(a2[25]), COERCE__INT64(v8));
    _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "E %f, Ecapped %f, EmaxCap %f => finalE %f", v12, 0x2Au);
  }
  return AABC::IlluminanceToLuminance(a1, a2, v8);
}

uint64_t __os_log_helper_16_2_1_8_64(uint64_t result, uint64_t a2)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 1;
  *(unsigned char *)(result + 2) = 64;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  return result;
}

uint64_t convertMachToNanoSeconds(uint64_t a1)
{
  if (!dword_1E9F73AEC) {
    mach_timebase_info((mach_timebase_info_t)&convertMachToNanoSeconds_sTimebaseInfo);
  }
  return a1 * (convertMachToNanoSeconds_sTimebaseInfo / dword_1E9F73AEC);
}

float CFXGetWPFromMatrix(uint64_t a1, float *a2, void *a3, _DWORD *a4)
{
  if (a1) {
    return _CFXGetWPFromMatrix(a1, a2, a3, a4);
  }
  return result;
}

void AABC::_UpdateSemanticAmbientLightLevel(uint64_t a1, int a2)
{
  if (a2 == 255)
  {
    if (*(float *)(a1 + 544) < 10000.0)
    {
      if (*(float *)(a1 + 544) < 2000.0)
      {
        if (*(float *)(a1 + 544) < 300.0)
        {
          if (*(float *)(a1 + 544) < 30.0) {
            int v4 = 1;
          }
          else {
            int v4 = 2;
          }
        }
        else
        {
          int v4 = 3;
        }
      }
      else
      {
        int v4 = 4;
      }
    }
    else
    {
      int v4 = 5;
    }
  }
  else
  {
    int v4 = a2;
  }
  if (*(_DWORD *)(a1 + 588) != v4)
  {
    *(_DWORD *)(a1 + 588) = v4;
    if (*(void *)(a1 + 352))
    {
      CFNumberRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(a1 + 588));
      if (cf)
      {
        (*(void (**)(void, __CFString *, CFNumberRef))(a1 + 352))(*(void *)(a1 + 360), @"SemanticAmbientLightLevel", cf);
        CFRelease(cf);
      }
    }
  }
}

void DisplayUpdateAAPState(uint64_t a1, uint64_t a2, char a3, char a4)
{
  uint64_t v16 = a1;
  uint64_t v15 = a2;
  char v14 = a3 & 1;
  char v13 = a4 & 1;
  if ((a4 & 1) != 0 && *(void *)(v16 + 144))
  {
    int v4 = *(NSObject **)(v16 + 144);
    double v5 = (void (*)(void))MEMORY[0x1E4F143A8];
    int v6 = -1073741824;
    int v7 = 0;
    float v8 = __DisplayUpdateAAPState_block_invoke;
    double v9 = &__block_descriptor_49_e5_v8__0l;
    uint64_t v10 = v16;
    uint64_t v11 = v15;
    char v12 = v14 & 1;
    disp_dispatch_sync(v4, &v5);
  }
  else if ((v13 & 1) == 0)
  {
    __DisplayUpdateAAPStateInternal(v16, v15, v14 & 1);
  }
}

float AABC::LuminanceToIlluminance(uint64_t a1, float *a2, float a3)
{
  return fmaxf(0.0, AAB::LuminanceToIlluminance(a3, a1, a2));
}

float AAB::LuminanceToIlluminance(float a1, uint64_t a2, float *a3)
{
  float v6 = 0.0;
  if (a1 >= a3[3])
  {
    if (a1 >= a3[7])
    {
      float v5 = a3[21];
      float v4 = a3[7] - (float)(v5 * a3[5]);
    }
    else
    {
      float v5 = (float)(a3[7] - a3[6]) / (float)(a3[5] - a3[4]);
      float v4 = a3[6];
    }
  }
  else
  {
    float v5 = (float)(a3[3] - a3[1]) / (float)(a3[2] - *a3);
    float v4 = a3[1];
  }
  if (v5 != 0.0) {
    return (float)(a1 - v4) / v5;
  }
  return v6;
}

void AABC::HandleProxEvent(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unint64_t v28 = this;
  os_log_t v27 = a2;
  os_log_type_t v26 = a3;
  int IntegerValue = IOHIDEventGetIntegerValue();
  if (AABC::ignoreProxEventsInAOD((uint64_t)this, [+[CBAODState sharedInstance] AODState]))
  {
    float v24 = 0;
    if (_logHandle)
    {
      uint64_t v15 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v15 = inited;
    }
    float v24 = v15;
    os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      log = v24;
      os_log_type_t type = v23;
      __os_log_helper_16_0_0(v22);
      _os_log_impl(&dword_1BA438000, log, type, "Ongoing AOD transition IN/OUT -> Ignoring Prox Events!!", v22, 2u);
    }
  }
  else if ((IntegerValue & 0x200) != 0 || (IntegerValue & 0x40) != 0 || (IntegerValue & 0x100) != 0)
  {
    os_log_t v21 = 0;
    if (_logHandle)
    {
      uint64_t v11 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v10 = init_default_corebrightness_log();
      }
      uint64_t v11 = v10;
    }
    os_log_t v21 = v11;
    os_log_type_t v20 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_4_0_4_0((uint64_t)v30, 64, IntegerValue);
      _os_log_debug_impl(&dword_1BA438000, v21, v20, "[%x]: setting _proxState = kProxTriggered (proxMask=%x)", v30, 0xEu);
    }
    *((_DWORD *)this + 987) = 1;
    if (*((unsigned char *)this + 3937))
    {
      if (*((float *)this + 154) < *((float *)this + 155))
      {
        int v19 = 0;
        if (_logHandle)
        {
          double v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v8 = init_default_corebrightness_log();
          }
          double v9 = v8;
        }
        int v19 = v9;
        os_log_type_t v18 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          float v6 = v19;
          os_log_type_t v7 = v18;
          __os_log_helper_16_0_0(v17);
          _os_log_impl(&dword_1BA438000, v6, v7, "Cancel ramp, prox. mitigation", v17, 2u);
        }
        AABC::CancelRamp(this);
      }
      DisplayCancelRestrictionFactorFade(*((void *)this + 51), 1);
    }
  }
  else
  {
    if (_logHandle)
    {
      float v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v4 = init_default_corebrightness_log();
      }
      float v5 = v4;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_4_0_4_0((uint64_t)v29, 64, IntegerValue);
      _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "[%x]: setting _proxState = kProxReleased (proxMask=%x)", v29, 0xEu);
    }
    if (*((_DWORD *)this + 169))
    {
      *((_DWORD *)this + 987) = 0;
    }
    else
    {
      *((_DWORD *)this + 987) = 2;
      float v3 = (double)(unint64_t)IOHIDEventGetTimeStamp() * *(double *)&AABC::_sMachTimebaseFactor;
      *((float *)this + 986) = v3;
    }
  }
}

BOOL AABC::ignoreProxEventsInAOD(uint64_t a1, uint64_t a2)
{
  BOOL v3 = 1;
  if (a2 != 2)
  {
    BOOL v3 = 1;
    if (a2 != 3) {
      return a2 == 1;
    }
  }
  return v3;
}

float AABC::IlluminanceToLuminance(uint64_t a1, float *a2, float a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v45 = a1;
  float v44 = a3;
  char v43 = a2;
  if (*(unsigned char *)(a1 + 136))
  {
    float v42 = 0.0;
    os_log_t v41 = 0;
    if (_logHandle)
    {
      os_log_type_t v23 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      os_log_type_t v23 = inited;
    }
    os_log_t v41 = v23;
    os_log_type_t v40 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v54, *(_DWORD *)(a1 + 1384));
      _os_log_debug_impl(&dword_1BA438000, v41, v40, "CustomCurveA size %d", v54, 8u);
    }
    os_log_t v39 = 0;
    if (_logHandle)
    {
      os_log_t v21 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v20 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v20 = init_default_corebrightness_log();
      }
      os_log_t v21 = v20;
    }
    os_log_t v39 = v21;
    os_log_type_t v38 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v53, *(_DWORD *)(a1 + 1548));
      _os_log_debug_impl(&dword_1BA438000, v39, v38, "CustomCurveB size %d", v53, 8u);
    }
    if (*(_DWORD *)(a1 + 2876))
    {
      os_log_t v37 = 0;
      if (_logHandle)
      {
        int v19 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v18 = init_default_corebrightness_log();
        }
        int v19 = v18;
      }
      os_log_t v37 = v19;
      os_log_type_t v36 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v52, COERCE__INT64(*(float *)(a1 + 1304 + 4 * (*(_DWORD *)(a1 + 1384) - 1))));
        _os_log_debug_impl(&dword_1BA438000, v37, v36, "Max L point of CustomCurveA is %f", v52, 0xCu);
      }
      os_log_t v35 = 0;
      if (_logHandle)
      {
        double v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v16 = init_default_corebrightness_log();
        }
        double v17 = v16;
      }
      os_log_t v35 = v17;
      os_log_type_t v34 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v51, COERCE__INT64(*(float *)(a1 + 1224 + 4 * (*(_DWORD *)(a1 + 1384) - 1))));
        _os_log_debug_impl(&dword_1BA438000, v35, v34, "Max E point of CustomCurveA is %f", v51, 0xCu);
      }
      os_log_t v33 = 0;
      if (_logHandle)
      {
        uint64_t v15 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v14 = init_default_corebrightness_log();
        }
        uint64_t v15 = v14;
      }
      os_log_t v33 = v15;
      os_log_type_t v32 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v50, COERCE__INT64(v44));
        _os_log_debug_impl(&dword_1BA438000, v33, v32, "CustomCurve E=%f", v50, 0xCu);
      }
      return AAB::IlluminanceToLuminance((AAB *)(a1 + 1224), v44, v3);
    }
    else
    {
      os_log_t oslog = 0;
      if (_logHandle)
      {
        char v13 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v12 = init_default_corebrightness_log();
        }
        char v13 = v12;
      }
      os_log_t oslog = v13;
      os_log_type_t v30 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v49, COERCE__INT64(*(float *)(a1 + 1468 + 4 * (*(_DWORD *)(a1 + 1548) - 1))));
        _os_log_debug_impl(&dword_1BA438000, oslog, v30, "Max L point of CustomCurveB is %f", v49, 0xCu);
      }
      os_log_t v29 = 0;
      if (_logHandle)
      {
        uint64_t v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v10 = init_default_corebrightness_log();
        }
        uint64_t v11 = v10;
      }
      os_log_t v29 = v11;
      os_log_type_t v28 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v48, COERCE__INT64(*(float *)(a1 + 1388 + 4 * (*(_DWORD *)(a1 + 1548) - 1))));
        _os_log_debug_impl(&dword_1BA438000, v29, v28, "Max E point of CustomCurveB is %f", v48, 0xCu);
      }
      os_log_t v27 = 0;
      if (_logHandle)
      {
        double v9 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v8 = init_default_corebrightness_log();
        }
        double v9 = v8;
      }
      os_log_t v27 = v9;
      os_log_type_t v26 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v47, COERCE__INT64(v44));
        _os_log_debug_impl(&dword_1BA438000, v27, v26, "CustomCurve E=%f", v47, 0xCu);
      }
      return AAB::IlluminanceToLuminance((AAB *)(a1 + 1388), v44, v4);
    }
  }
  else if (AABC::isAODCurveActive(a1, [+[CBAODState sharedInstance] AODState]))
  {
    return AABC::IlluminanceToLuminanceAggregated_AOD(a1, (AAB *)(a1 + 2540), (float *)(a1 + 1048), v44);
  }
  else if (*(void *)(a1 + 4056) && ([*(id *)(a1 + 4056) isActive] & 1) != 0)
  {
    os_log_type_t v7 = *(void **)(a1 + 4056);
    if (v7) {
      [v7 curve];
    }
    else {
      memset(__b, 0, 0xA4uLL);
    }
    return AAB::IlluminanceToLuminance((AAB *)__b, v44, v5);
  }
  else
  {
    return AAB::IlluminanceToLuminance(a1, v43, v44);
  }
}

BOOL AABC::isAODCurveActive(uint64_t a1, uint64_t a2)
{
  BOOL v3 = 1;
  if (a2 != 1) {
    return a2 == 3;
  }
  return v3;
}

float AAB::IlluminanceToLuminance(uint64_t a1, float *a2, float a3)
{
  (*(void (**)(uint64_t, const char *, ...))(*(void *)a1 + 16))(a1, "%s: inputs: (_E1 = %0.2f, _L1 = %0.4f) (_E2 = %0.2f, _L2 = %0.4f) E=%0.2f", "IlluminanceToLuminance", a2[4], a2[6], a2[5], a2[7], a3);
  (*(void (**)(uint64_t, const char *, ...))(*(void *)a1 + 16))(a1, "%s:    dark (E0a = %0.2f, L0a = %0.4f) (E0b = %0.2f, L0b = %0.4f)", "IlluminanceToLuminance", *a2, a2[1], a2[2], a2[3]);
  if (a3 >= a2[2])
  {
    if (a3 >= a2[5])
    {
      float v6 = a2[21];
      float v5 = a2[7] - (float)(v6 * a2[5]);
    }
    else
    {
      float v6 = (float)(a2[7] - a2[6]) / (float)(a2[5] - a2[4]);
      float v5 = a2[6];
    }
  }
  else
  {
    float v6 = (float)(a2[3] - a2[1]) / (float)(a2[2] - *a2);
    float v5 = a2[1];
  }
  float v7 = fmaxf(v5 + (float)(v6 * a3), 0.0);
  (*(void (**)(uint64_t, const char *, ...))(*(void *)a1 + 16))(a1, "%s: (E2=%f) E=%f * slope=%f + offset=%f  L=%f", "IlluminanceToLuminance", a2[5], a3, v6, v5, v7);
  (*(void (**)(uint64_t, const char *, ...))(*(void *)a1 + 16))(a1, "%s: outputs: L=%f", "IlluminanceToLuminance", v7);
  return v7;
}

uint64_t __os_log_helper_16_2_2_8_64_8_64(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 64;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 64;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  return result;
}

void sub_1BA462E68()
{
  _Unwind_Resume(v0);
}

uint64_t DisplaySetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = a1;
  uint64_t v21 = a2;
  uint64_t v20 = a3;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  int v17 = 0x20000000;
  int v18 = 32;
  char v19 = 1;
  BOOL v3 = *(NSObject **)(a1 + 144);
  float v6 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v7 = -1073741824;
  int v8 = 0;
  double v9 = __DisplaySetProperty_block_invoke;
  uint64_t v10 = &unk_1E621A580;
  uint64_t v12 = a3;
  uint64_t v13 = a2;
  uint64_t v14 = v22;
  uint64_t v11 = &v15;
  disp_dispatch_sync(v3, &v6);
  unsigned int v5 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  return v5;
}

void sub_1BA466688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 56), 8);
  _Unwind_Resume(a1);
}

void *AABC::getPropertyForClient(AABC *this, const __CFString *a2, const void *a3)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  v60 = this;
  int v59 = a2;
  uint64_t v58 = a3;
  os_log_t v57 = 0;
  if (_logHandle)
  {
    uint64_t v25 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v25 = inited;
  }
  os_log_t v57 = v25;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v71, 4);
    _os_log_debug_impl(&dword_1BA438000, v57, type, "[%x]: ", v71, 8u);
  }
  os_log_t v55 = 0;
  if (_logHandle)
  {
    os_log_type_t v23 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v22 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v22 = init_default_corebrightness_log();
    }
    os_log_type_t v23 = v22;
  }
  os_log_t v55 = v23;
  os_log_type_t v54 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_2_4_0_8_64((uint64_t)v70, 2, (uint64_t)v59);
    _os_log_debug_impl(&dword_1BA438000, v55, v54, "[%x]: %@", v70, 0x12u);
  }
  float v53 = 0;
  if (*((_DWORD *)this + 94))
  {
    if (CFEqual(v59, @"ALSUserPreference"))
    {
      *((_DWORD *)this + 286) = (*(uint64_t (**)(void))(**((void **)this + 8) + 104))(*((void *)this + 8));
      CFDictionaryRef CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 1048);
      MutableCopy = 0;
      MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, CurveDictionary);
      CFRelease(CurveDictionary);
      if (*((unsigned char *)this + 3401))
      {
        *((_DWORD *)this + 748) = (*(uint64_t (**)(void))(**((void **)this + 8) + 104))(*((void *)this + 8));
        CFDictionaryRef CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 2896);
        CFDictionaryAddValue(MutableCopy, @"ReplacementCurve", CurveDictionary);
        CFRelease(CurveDictionary);
        *((_DWORD *)this + 774) = (*(uint64_t (**)(void))(**((void **)this + 8) + 112))(*((void *)this + 8));
        CFDictionaryRef CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 3000);
        CFDictionaryAddValue(MutableCopy, @"AlternativeCurve", CurveDictionary);
        os_log_t v50 = 0;
        if (_logHandle)
        {
          uint64_t v21 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v20 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v20 = init_default_corebrightness_log();
          }
          uint64_t v21 = v20;
        }
        os_log_t v50 = v21;
        os_log_type_t v49 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_1_8_64((uint64_t)v69, (uint64_t)CurveDictionary);
          _os_log_impl(&dword_1BA438000, v50, v49, "Get ALSUserPreference - AlternativeCurve = %@ ", v69, 0xCu);
        }
        CFRelease(CurveDictionary);
        *((_DWORD *)this + 800) = (*(uint64_t (**)(void))(**((void **)this + 8) + 112))(*((void *)this + 8));
        CFDictionaryRef CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 3104);
        CFDictionaryAddValue(MutableCopy, @"AlternativeReplacementCurve", CurveDictionary);
        os_log_t v48 = 0;
        if (_logHandle)
        {
          char v19 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v18 = init_default_corebrightness_log();
          }
          char v19 = v18;
        }
        os_log_t v48 = v19;
        os_log_type_t v47 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_1_8_64((uint64_t)v68, (uint64_t)CurveDictionary);
          _os_log_impl(&dword_1BA438000, v48, v47, "Get ALSUserPreference - AlternativeReplacementCurve = %@ ", v68, 0xCu);
        }
        CFRelease(CurveDictionary);
        AAB::GetCurveUpdates(this, (uint64_t)v46);
        if (!std::list<AAB::CurveUpdate>::empty[abi:ne180100]())
        {
          context = (void *)MEMORY[0x1BA9ECAE0]();
          uint64_t v45 = (void *)[MEMORY[0x1E4F1CA48] array];
          v44[1] = v46;
          v44[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v46);
          uint64_t v43 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
          while (std::operator!=[abi:ne180100](v44, &v43))
          {
            uint64_t v42 = std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
            uint64_t v16 = v45;
            v66[0] = @"Lux";
            LODWORD(v3) = *(_DWORD *)v42;
            v67[0] = [NSNumber numberWithFloat:v3];
            v66[1] = @"Nits";
            LODWORD(v4) = *(_DWORD *)(v42 + 4);
            v67[1] = [NSNumber numberWithFloat:v4];
            v66[2] = @"Timestamp";
            v67[2] = [NSNumber numberWithLongLong:*(void *)(v42 + 8)];
            objc_msgSend(v16, "addObject:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v67, v66, 3));
            std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v44);
          }
          CFDictionaryAddValue(MutableCopy, @"CurveUpdates", v45);
        }
        (*(void (**)(void))(**((void **)this + 8) + 96))(*((void *)this + 8));
        std::list<AAB::CurveUpdate>::~list((uint64_t)v46);
      }
      if (*((unsigned char *)this + 3368))
      {
        CFDictionaryRef CurveDictionary = AABC::createCurveDictionary((uint64_t)this, (char *)this + 2896);
        CFDictionaryAddValue(MutableCopy, @"ReplacementCurve", CurveDictionary);
        CFRelease(CurveDictionary);
        value = AABC::createCurveDescriptorDictionary((uint64_t)this, (_DWORD *)this + 832);
        CFDictionaryAddValue(MutableCopy, @"Descriptor", value);
        CFRelease(value);
        if (!v58)
        {
          if (AABC::isCurveGood((uint64_t)this, (uint64_t)this + 1048)) {
            AABC::writeOutlierRemovalPreferences((uint64_t)this, 0);
          }
          else {
            *((unsigned char *)this + 3400) = 1;
          }
        }
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"ALSUserPreference", MutableCopy);
      float v53 = MutableCopy;
      CFRelease(MutableCopy);
      goto LABEL_154;
    }
    if (CFEqual(v59, @"OutlierRemoval"))
    {
      if (!CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 48), @"OutlierRemoval", (const void **)&v53)) {
        float v53 = 0;
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSRequiresProx"))
    {
      float v53 = (void *)*MEMORY[0x1E4F1CFD0];
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSDimPolicy"))
    {
      float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"ALSDimPolicy");
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSSpikeFilterDuration"))
    {
      float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"ALSSpikeFilterDuration");
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSMaxBrightenDuration"))
    {
      float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"ALSMaxBrightenDuration");
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSInternalSettings"))
    {
      float v53 = (void *)*((void *)this + 49);
      goto LABEL_154;
    }
    if (CFEqual(v59, @"BrightnessCurveLevel"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)this + 3404);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"BrightnessCurveLevel", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"BrightnessCurveLevel");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"AutoBrightnessLuxFilter"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)this + 3456);
      goto LABEL_154;
    }
    if (CFEqual(v59, @"SemanticAmbientLightLevel"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)this + 588);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"SemanticAmbientLightLevel", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 48), @"SemanticAmbientLightLevel");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"TrustedLux32"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, (char *)this + 544);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"TrustedLux32", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"TrustedLux32");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"TrustedLux"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 544);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"TrustedLux", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"TrustedLux");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"TrustedFrontLux"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 548);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"TrustedFrontLux", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"TrustedFrontLux");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"Lux") || CFEqual(v59, @"AggregatedLux"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 536);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"Lux", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"Lux");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"VirtualLux"))
    {
      float valuePtr = 0.0;
      float valuePtr = AABC::LuminanceToIlluminance((uint64_t)this, (float *)this + 262, *((float *)this + 155));
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"VirtualLux", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"VirtualLux");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSCurveInfo"))
    {
      int v39 = 2;
      memcpy(__dst, off_1E621A9E0, sizeof(__dst));
      memset(__b, 0, sizeof(__b));
      __b[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v39);
      __b[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 1064);
      __b[2] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 1072);
      __b[3] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 1068);
      __b[4] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 1076);
      __b[5] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 1048);
      __b[6] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 1052);
      __b[7] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 1056);
      __b[8] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 1060);
      _DWORD __b[9] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 28);
      __b[10] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 20);
      __b[11] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 24);
      __b[12] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 32);
      __b[13] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 36);
      __b[14] = AABC::createCurvePrefsDictionary((uint64_t)this, (char *)this + 1080);
      CFDictionaryRef theDict = 0;
      CFDictionaryRef theDict = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __dst, __b, 15, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFRelease(__b[14]);
      CFRelease(__b[13]);
      CFRelease(__b[12]);
      CFRelease(__b[11]);
      CFRelease(__b[10]);
      CFRelease(__b[9]);
      CFRelease(__b[8]);
      CFRelease(__b[7]);
      CFRelease(__b[6]);
      CFRelease(__b[5]);
      CFRelease(__b[4]);
      CFRelease(__b[3]);
      CFRelease(__b[2]);
      CFRelease(__b[1]);
      CFRelease(__b[0]);
      if (*((unsigned char *)this + 3368))
      {
        CFMutableDictionaryRef v37 = 0;
        CFMutableDictionaryRef v37 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theDict);
        CFRelease(theDict);
        CFTypeRef cf = AABC::createCurveDescriptorDictionary((uint64_t)this, (_DWORD *)this + 832);
        CFDictionaryAddValue(v37, @"Descriptor", cf);
        CFRelease(cf);
        CFDictionaryRef theDict = v37;
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"ALSCurveInfo", theDict);
      float v53 = theDict;
      CFRelease(theDict);
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSAlternativeCurveInfo"))
    {
      int v35 = 2;
      memcpy(keys, off_1E621AA58, sizeof(keys));
      memset(values, 0, sizeof(values));
      values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v35);
      values[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3016);
      values[2] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3024);
      values[3] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3020);
      values[4] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3028);
      values[5] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3000);
      values[6] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3004);
      values[7] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3008);
      values[8] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3012);
      values[9] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 28);
      values[10] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 20);
      values[11] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 24);
      values[12] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 32);
      values[13] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 36);
      values[14] = AABC::createCurvePrefsDictionary((uint64_t)this, (char *)this + 3032);
      CFTypeRef v34 = 0;
      CFTypeRef v34 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, values, 15, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      CFRelease(values[14]);
      CFRelease(values[13]);
      CFRelease(values[12]);
      CFRelease(values[11]);
      CFRelease(values[10]);
      CFRelease(values[9]);
      CFRelease(values[8]);
      CFRelease(values[7]);
      CFRelease(values[6]);
      CFRelease(values[5]);
      CFRelease(values[4]);
      CFRelease(values[3]);
      CFRelease(values[2]);
      CFRelease(values[1]);
      CFRelease(values[0]);
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"ALSAlternativeCurveInfo", v34);
      float v53 = (void *)v34;
      CFRelease(v34);
      goto LABEL_154;
    }
    if (CFEqual(v59, @"AODDarkerCurve"))
    {
      if (*((int *)this + 716) > 0)
      {
        id v33 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        id v32 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        for (int i = 0; i < *((_DWORD *)this + 716); ++i)
        {
          id v30 = 0;
          id v15 = objc_alloc(NSNumber);
          LODWORD(v5) = *((_DWORD *)this + i + 676);
          id v30 = (id)[v15 initWithFloat:v5];
          id v29 = 0;
          id v14 = objc_alloc(NSNumber);
          LODWORD(v6) = *((_DWORD *)this + i + 696);
          id v29 = (id)[v14 initWithFloat:v6];
          [v33 addObject:v30];
          [v32 addObject:v29];
        }
        os_log_type_t v28 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v33, @"lux", v32, @"nits", 0);
        float v53 = v28;

        if (v28)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"AODDarkerCurve", v53);
          CFRelease(v53);
          float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"AODDarkerCurve");
        }
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSDefaultCurves")) {
      goto LABEL_153;
    }
    if (CFEqual(v59, @"EcoMode"))
    {
      if (*((unsigned char *)this + 3416)) {
        uint64_t v13 = (void *)*MEMORY[0x1E4F1CFD0];
      }
      else {
        uint64_t v13 = (void *)*MEMORY[0x1E4F1CFC8];
      }
      float v53 = v13;
      goto LABEL_154;
    }
    if (CFEqual(v59, @"CBAutoBrightnessAvailable"))
    {
      if (*((_DWORD *)this + 129)) {
        uint64_t v12 = (void *)*MEMORY[0x1E4F1CFD0];
      }
      else {
        uint64_t v12 = (void *)*MEMORY[0x1E4F1CFC8];
      }
      float v53 = v12;
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSBrightenPdeltaSlow"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 4000);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSBrightenPdeltaSlow", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"ALSBrightenPdeltaSlow");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSBrightenPdeltaFast"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3996);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSBrightenPdeltaFast", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"ALSBrightenPdeltaFast");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ALSDimPdeltaSlow"))
    {
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3988);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSDimPdeltaSlow", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"ALSDimPdeltaSlow");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"Aggressivity"))
    {
      float v27 = 0.0;
      float v27 = (float)*((unsigned int *)this + 142);
      float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v27);
      if (v53)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"Aggressivity", v53);
        CFRelease(v53);
        float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"Aggressivity");
      }
      goto LABEL_154;
    }
    if (CFEqual(v59, @"ProxMitigationTriggered"))
    {
      if (*((void *)this + 60) && (*((unsigned char *)this + 3937) & 1) != 0 && *((_DWORD *)this + 987)) {
        uint64_t v11 = (void *)*MEMORY[0x1E4F1CFD0];
      }
      else {
        uint64_t v11 = (void *)*MEMORY[0x1E4F1CFC8];
      }
      float v53 = v11;
      goto LABEL_154;
    }
    if (CFEqual(v59, @"TouchMitigationTriggered"))
    {
      if (*((void *)this + 57) && (AABC::ALS::isTouchObstructed(*((id **)this + 57)) & 1) != 0) {
        uint64_t v10 = (void *)*MEMORY[0x1E4F1CFD0];
      }
      else {
        uint64_t v10 = (void *)*MEMORY[0x1E4F1CFC8];
      }
      float v53 = v10;
      goto LABEL_154;
    }
    if (CFEqual(v59, @"BrightnessCapabilities"))
    {
      float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"BrightnessCapabilities");
      goto LABEL_154;
    }
    if (!CFEqual(v59, @"ALSIntegrationMode"))
    {
LABEL_153:
      float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 48), v59);
      goto LABEL_154;
    }
    float v53 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)this + 668);
    if (v53)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSIntegrationMode", v53);
      CFRelease(v53);
      float v53 = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 49), @"ALSIntegrationMode");
    }
  }
LABEL_154:
  if (_logHandle)
  {
    double v9 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v8 = init_default_corebrightness_log();
    }
    double v9 = v8;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v61, 2, (uint64_t)v59, (uint64_t)v53);
    _os_log_debug_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEBUG, "[%x]: %@ result=%@", v61, 0x1Cu);
  }
  return v53;
}

void sub_1BA469B7C()
{
  _Unwind_Resume(v0);
}

float AABC::calculateMovingAverage(AABC *this, float a2)
{
  unint64_t v10 = *((void *)this + 35);
  if (v10 >= std::array<float,3ul>::size[abi:ne180100]())
  {
    unint64_t v8 = *((void *)this + 35);
    unint64_t v2 = std::array<float,3ul>::size[abi:ne180100]();
    *((float *)this + 72) = *((float *)this + 72)
                          - *(float *)std::array<float,3ul>::operator[][abi:ne180100]((uint64_t)this + 268, v8 % v2);
  }
  unint64_t v6 = *((void *)this + 35);
  unint64_t v3 = std::array<float,3ul>::size[abi:ne180100]();
  *(float *)std::array<float,3ul>::operator[][abi:ne180100]((uint64_t)this + 268, v6 % v3) = a2;
  ++*((void *)this + 35);
  *((float *)this + 72) = *((float *)this + 72) + a2;
  unint64_t v7 = *((void *)this + 35);
  if (v7 < std::array<float,3ul>::size[abi:ne180100]()) {
    return *((float *)this + 72) / (float)*((unint64_t *)this + 35);
  }
  float v5 = *((float *)this + 72);
  return v5 / (float)(unint64_t)std::array<float,3ul>::size[abi:ne180100]();
}

uint64_t std::array<float,3ul>::size[abi:ne180100]()
{
  return 3;
}

uint64_t std::array<float,3ul>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1 + 4 * a2;
}

uint64_t DisplayCopyProperty(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  uint64_t v13 = 0;
  id v14 = &v13;
  int v15 = 0x20000000;
  int v16 = 32;
  uint64_t v17 = 0;
  unint64_t v2 = *(NSObject **)(a1 + 144);
  float v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  unint64_t v8 = __DisplayCopyProperty_block_invoke;
  double v9 = &unk_1E62194F0;
  unint64_t v10 = &v13;
  uint64_t v11 = v19;
  uint64_t v12 = a2;
  disp_dispatch_sync(v2, &v5);
  uint64_t v4 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA46C310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __SetBLDriverProperty(const __CFString *a1, const void *a2, uint64_t a3)
{
  return IORegistryEntrySetCFProperty(*(_DWORD *)(a3 + 80), a1, a2);
}

uint64_t DisplayStartFastEDRRamp(uint64_t a1, float a2, double a3)
{
  uint64_t v15 = a1;
  float v14 = a2;
  double v13 = a3;
  unint64_t v3 = *(NSObject **)(a1 + 144);
  float v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  unint64_t v8 = __DisplayStartFastEDRRamp_block_invoke;
  double v9 = &__block_descriptor_52_e5_v8__0l;
  double v10 = a3;
  uint64_t v11 = v15;
  float v12 = a2;
  disp_dispatch_sync(v3, &v5);
  return 1;
}

void ___Z33DisplayRefPropertyChangedCallbackPvPK10__CFStringPKv_block_invoke(id *a1)
{
  char v9 = 1;
  if (*((void *)a1[4] + 5))
  {
    uint64_t v6 = [*((id *)a1[4] + 5) getDisplayType];
    if (v6 == [*((id *)a1[4] + 5) CBDispTypeIntegrated])
    {
      if (([a1[5] isEqualToString:@"TrustedLux"] & 1) != 0
        || ([a1[5] isEqualToString:@"FrameSynchronizedBrightnessTransaction"] & 1) != 0
        || ([a1[5] isEqualToString:@"CPMS.UPO.Cap"] & 1) != 0
        || ([a1[5] isEqualToString:@"CPMS.CLTM.Cap"] & 1) != 0
        || ([a1[5] isEqualToString:@"CPMS.HDR.Cap"] & 1) != 0
        || ([a1[5] isEqualToString:@"CPMSCurrentCap"] & 1) != 0
        || ([a1[5] isEqualToString:@"DisplayOn"] & 1) != 0
        || ([a1[5] isEqualToString:@"AuroraFactor"] & 1) != 0
        || ([a1[5] isEqualToString:@"AuroraRampInProgress"] & 1) != 0)
      {
        [a1[4] handleNotificationForKey:a1[5] withProperty:a1[6]];
      }
      else if ([a1[5] isEqualToString:@"DisplayBrightness"])
      {
        char v9 = 0;
        [a1[4] handleNotificationForKey:a1[5] withProperty:a1[6]];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          context = (void *)MEMORY[0x1BA9ECAE0]();
          id v8 = (id)[a1[6] mutableCopy];
          objc_msgSend((id)objc_msgSend(v8, "objectForKey:"), "floatValue");
          *(float *)&double v2 = v1 * *((float *)a1[4] + 36);
          objc_msgSend(v8, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v2), @"NitsPhysical");
          LODWORD(v3) = *((_DWORD *)a1[4] + 36);
          objc_msgSend(v8, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v3), @"EDRHeadroom");
          LODWORD(v4) = *((_DWORD *)a1[4] + 54);
          objc_msgSend(v8, "setValue:forKey:", objc_msgSend(NSNumber, "numberWithFloat:", v4), @"HDRRTPLCCap");
          _DisplaySetInternalDictionaryProperty(*((void *)a1[4] + 35), @"DisplayBrightness", (uint64_t)v8);
          _DisplaySetInternalDictionaryProperty(*((void *)a1[4] + 35), @"DisplayNitsKey", (uint64_t)v8);
          char v9 = 0;
          [a1[4] sendNotificationForKey:a1[5] withValue:v8];
        }
      }
    }
  }
  if (v9) {
    [a1[4] sendNotificationForKey:a1[5] withValue:a1[6]];
  }
  if (a1[5]) {
    CFRelease(a1[5]);
  }
  if (a1[6]) {
    CFRelease(a1[6]);
  }
}

void _DisplaySetInternalDictionaryProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  double v3 = *(NSObject **)(a1 + 144);
  double v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  int v7 = ___DisplaySetInternalDictionaryProperty_block_invoke;
  id v8 = &__block_descriptor_56_e5_v8__0l;
  uint64_t v9 = v14;
  uint64_t v10 = a2;
  uint64_t v11 = a3;
  disp_dispatch_sync(v3, &v4);
}

void DisplaySetABBrightnessForPowerReport(uint64_t a1, char a2, float a3)
{
  uint64_t v14 = a1;
  float v13 = a3;
  char v12 = a2 & 1;
  double v3 = *(NSObject **)(a1 + 144);
  double v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  int v7 = __DisplaySetABBrightnessForPowerReport_block_invoke;
  id v8 = &__block_descriptor_45_e5_v8__0l;
  uint64_t v9 = v14;
  float v10 = a3;
  char v11 = a2 & 1;
  disp_dispatch_sync(v3, &v4);
}

void DisplaySetCurrentAmbient(uint64_t a1, float a2)
{
  uint64_t v11 = a1;
  float v10 = a2;
  if (a1)
  {
    if (*(void *)(v11 + 144))
    {
      double v2 = *(NSObject **)(v11 + 144);
      double v3 = (void (*)(void))MEMORY[0x1E4F143A8];
      int v4 = -1073741824;
      int v5 = 0;
      int v6 = __DisplaySetCurrentAmbient_block_invoke;
      int v7 = &__block_descriptor_44_e5_v8__0l;
      uint64_t v8 = v11;
      float v9 = v10;
      disp_dispatch_sync(v2, &v3);
    }
  }
}

void AABC::_UpdateNitsRestrictions(AABC *this, float a2, float a3, char a4)
{
  if (*((unsigned char *)this + 3589)) {
    AABC::_UpdateNitsRestrictionsMultiPoint(this, a2, a3, a4 & 1);
  }
  else {
    AABC::_UpdateNitsRestrictionsSinglePoint(this, fminf(a2, *((float *)this + 1007)), a3, a4 & 1);
  }
}

void AABC::_UpdateNitsRestrictionsMultiPoint(AABC *this, float a2, float a3, char a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  int v59 = this;
  float v58 = a2;
  float v57 = a3;
  char v56 = a4 & 1;
  float v55 = a2;
  float v54 = a2;
  int v53 = 0;
  if (a2 < 0.0)
  {
    float v54 = 0.0;
    float v55 = 0.0;
  }
  if (*((_DWORD *)this + 130) || !*((_DWORD *)this + 129)) {
    int v53 = 1;
  }
  if (*((unsigned char *)this + 3472))
  {
    float v52 = 0.0;
    for (int i = 0; i < 6 && v58 > *((float *)this + 12 * v53 + i + 873); ++i)
      ;
    if (i)
    {
      if (i == 6)
      {
        float v52 = *((float *)this + 12 * v53 + 884);
      }
      else
      {
        float v50 = 0.0;
        float v50 = *((float *)this + 12 * v53 + i + 873) - *((float *)this + 12 * v53 + i + 872);
        float v49 = 0.0;
        float v49 = *((float *)this + 12 * v53 + i + 879) - *((float *)this + 12 * v53 + i + 878);
        float v48 = 0.0;
        float v48 = (float)(v58 - *((float *)this + 12 * v53 + i + 872)) / v50;
        float v52 = *((float *)this + 12 * v53 + i + 878) + (float)(v48 * v49);
      }
    }
    else
    {
      float v52 = *((float *)this + 12 * v53 + 879);
    }
    float RestrictionFactorTarget = 0.0;
    float RestrictionFactorTarget = DisplayGetRestrictionFactorTarget(*((void *)this + 51), 1);
    float v46 = v52 - RestrictionFactorTarget;
    char v45 = 0;
    char isTrustedOccluded = 0;
    if ((float)(v52 - RestrictionFactorTarget) < 0.0) {
      char isTrustedOccluded = AABC::isTrustedOccluded((id **)this);
    }
    char v45 = isTrustedOccluded & 1;
    if ((v56 & 1) != 0 || fabsf(v46) >= 0.01 && (v45 & 1) == 0)
    {
      char v44 = 1;
      if (v52 > *((float *)this + 12 * v53 + 879) + 0.005
        && v52 < *((float *)this + 12 * v53 + 884) - 0.005
        && (v56 & 1) == 0
        && (float)(fabsf(v46) / RestrictionFactorTarget) < 0.1)
      {
        uint64_t v43 = 0;
        if (_logHandle)
        {
          uint64_t v21 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t inited = init_default_corebrightness_log();
          }
          uint64_t v21 = inited;
        }
        uint64_t v43 = v21;
        char v42 = 2;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          log = v43;
          os_log_type_t type = v42;
          __os_log_helper_16_0_0(v41);
          _os_log_debug_impl(&dword_1BA438000, log, type, "Skipping set of minimum restriction due to relative threshold\n", v41, 2u);
        }
        char v44 = 0;
      }
      if (v44)
      {
        os_log_t v40 = 0;
        if (_logHandle)
        {
          uint64_t v17 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v16 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v16 = init_default_corebrightness_log();
          }
          uint64_t v17 = v16;
        }
        os_log_t v40 = v17;
        os_log_type_t v39 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v61, COERCE__INT64(v52), COERCE__INT64(v54));
          _os_log_impl(&dword_1BA438000, v40, v39, "Set minimum restriction %f for E=%f\n", v61, 0x16u);
        }
        float v38 = v57;
        if (v57 < 0.0)
        {
          if (v46 <= 0.0) {
            float v15 = *((float *)this + 872);
          }
          else {
            float v15 = *((float *)this + 871);
          }
          float v38 = v15;
        }
        uint64_t v5 = *((void *)this + 51);
        uint64_t v37 = *((void *)this + 433);
        DisplaySetRestrictionFactorWithFade(v5, 1, v52, v38, *(float *)&v37, *((float *)&v37 + 1));
      }
    }
  }
  if (*((unsigned char *)this + 3588))
  {
    float v36 = 0.0;
    for (int j = 0; j < 6 && v58 > *((float *)this + 12 * v53 + j + 902); ++j)
      ;
    if (j)
    {
      if (j == 6)
      {
        float v36 = *((float *)this + 12 * v53 + 913);
      }
      else
      {
        int v6 = this;
        float v34 = 0.0;
        float v34 = *((float *)v6 + 12 * v53 + j + 902) - *((float *)v6 + 12 * v53 + j + 901);
        float v33 = 0.0;
        float v33 = *((float *)v6 + 12 * v53 + j + 908) - *((float *)v6 + 12 * v53 + j + 907);
        float v32 = 0.0;
        float v32 = (float)(v58 - *((float *)this + 12 * v53 + j + 901)) / v34;
        float v36 = *((float *)this + 12 * v53 + j + 907) + (float)(v32 * v33);
      }
    }
    else
    {
      float v36 = *((float *)this + 12 * v53 + 908);
    }
    float v31 = 0.0;
    float v31 = DisplayGetRestrictionFactorTarget(*((void *)this + 51), 0);
    float v30 = v36 - v31;
    char v29 = 0;
    char v14 = 0;
    if ((float)(v36 - v31) < 0.0) {
      char v14 = AABC::isTrustedOccluded((id **)this);
    }
    char v29 = v14 & 1;
    if ((v56 & 1) != 0 || fabsf(v30) >= 0.01 && (v29 & 1) == 0)
    {
      char v28 = 1;
      if (v36 > *((float *)this + 12 * v53 + 908) + 0.005
        && v36 < *((float *)this + 12 * v53 + 913) - 0.005
        && (v56 & 1) == 0
        && (float)(fabsf(v30) / v31) < 0.1)
      {
        float v27 = 0;
        if (_logHandle)
        {
          float v13 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v12 = init_default_corebrightness_log();
          }
          float v13 = v12;
        }
        float v27 = v13;
        char v26 = 2;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          float v10 = v27;
          os_log_type_t v11 = v26;
          __os_log_helper_16_0_0(v25);
          _os_log_debug_impl(&dword_1BA438000, v10, v11, "Skipping set of maximum restriction due to relative threshold\n", v25, 2u);
        }
        char v28 = 0;
      }
      if (v28)
      {
        if (_logHandle)
        {
          float v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v8 = init_default_corebrightness_log();
          }
          float v9 = v8;
        }
        if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v60, COERCE__INT64(v36), COERCE__INT64(v55));
          _os_log_impl(&dword_1BA438000, v9, OS_LOG_TYPE_INFO, "Set maximum restriction %f for E=%f\n", v60, 0x16u);
        }
        float v24 = v57;
        if (v57 < 0.0)
        {
          if (v30 <= 0.0)
          {
            float v24 = *((float *)this + 901);
          }
          else
          {
            float v24 = *((float *)this + 900);
            LOBYTE(v7) = 0;
            if ((std::__math::isnan[abi:ne180100]() & 1) == 0) {
              int v7 = std::__math::isnan[abi:ne180100]() ^ 1;
            }
            if ((v7 & 1) != 0 && v36 >= *((float *)this + 898)) {
              float v24 = *((float *)this + 899);
            }
          }
        }
        DisplaySetRestrictionFactorWithFade(*((void *)this + 51), 0, v36, v24, COERCE_FLOAT(*((void *)this + 433)), COERCE_FLOAT(HIDWORD(*((void *)this + 433))));
      }
    }
  }
}

float DisplayGetRestrictionFactorTarget(uint64_t a1, char a2)
{
  uint64_t v19 = a1;
  char v18 = a2 & 1;
  uint64_t v13 = 0;
  char v14 = (float *)&v13;
  int v15 = 0x20000000;
  int v16 = 32;
  int v17 = 0;
  double v2 = *(NSObject **)(a1 + 144);
  uint64_t v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  uint64_t v8 = __DisplayGetRestrictionFactorTarget_block_invoke;
  float v9 = &unk_1E621A5A8;
  float v10 = &v13;
  char v12 = a2 & 1;
  uint64_t v11 = v19;
  disp_dispatch_sync(v2, &v5);
  float v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA46EEAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t AABC::UpdateDisplayBrightness_Block6(uint64_t a1, int a2, int a3, char a4, float a5)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  char v54 = a4 & 1;
  if (_logHandle)
  {
    uint64_t v37 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v37 = inited;
  }
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v67, 4);
    _os_log_debug_impl(&dword_1BA438000, v37, OS_LOG_TYPE_DEBUG, "[%x]: ", v67, 8u);
  }
  if (_logHandle)
  {
    int v35 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v34 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v34 = init_default_corebrightness_log();
    }
    int v35 = v34;
  }
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
  {
    if (a2) {
      uint64_t v5 = "true";
    }
    else {
      uint64_t v5 = "false";
    }
    __os_log_helper_16_2_6_4_0_8_0_8_32_8_32_8_0_4_0((uint64_t)v66, 512, COERCE__INT64(a5), (uint64_t)v5, (uint64_t)(&kDimRestrictionStr)[a3], COERCE__INT64(*(float *)(a1 + 544)), v54 & 1);
    _os_log_debug_impl(&dword_1BA438000, v35, OS_LOG_TYPE_DEBUG, "[%x]: inputs: L=%f (shouldRamp=%s dimRestriction=%s _Esensor_trusted=%f) curveChanged=%d", v66, 0x36u);
  }
  if (*(_DWORD *)(a1 + 676) && (v54 & 1) == 0) {
    a3 = 0;
  }
  char v53 = 0;
  if (*(_DWORD *)(a1 + 512) && *(_DWORD *)(a1 + 508) && *(_DWORD *)(a1 + 516))
  {
    char v52 = (v54 & 1) != 0;
    float v51 = 0.0;
    if (*(float *)(a1 + 620) == 0.0) {
      *(_DWORD *)(a1 + 620) = *(_DWORD *)(a1 + 720);
    }
    float v50 = a5;
    float WeakCap = *(float *)(a1 + 728);
    if (*(unsigned char *)(a1 + 4084))
    {
      float WeakCap = DisplayGetWeakCap(*(void *)(a1 + 408));
      if (_logHandle)
      {
        float v33 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v32 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v32 = init_default_corebrightness_log();
        }
        float v33 = v32;
      }
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v65, COERCE__INT64(WeakCap));
        _os_log_debug_impl(&dword_1BA438000, v33, OS_LOG_TYPE_DEBUG, "Weak cap read at %f", v65, 0xCu);
      }
      float v50 = fminf(a5, WeakCap);
    }
    if (a2)
    {
      if (_logHandle)
      {
        float v31 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v30 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v30 = init_default_corebrightness_log();
        }
        float v31 = v30;
      }
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_6_4_0_4_0_8_32_8_0_8_0_8_0((uint64_t)v64, 512, *(_DWORD *)(a1 + 676), (uint64_t)(&kDimRestrictionStr)[a3], COERCE__INT64(v50), COERCE__INT64(*(float *)(a1 + 620)), COERCE__INT64(*(float *)(a1 + 604)));
        _os_log_debug_impl(&dword_1BA438000, v31, OS_LOG_TYPE_DEBUG, "[%x]: _fastRampMode=%x dimRestriction=%s L_newtarget=%f _L_current=%f _L_minimum=%f", v64, 0x36u);
      }
      if (a3)
      {
        if (a3 == 1) {
          float v50 = fmaxf(v50, *(float *)(a1 + 604));
        }
      }
      else
      {
        float v50 = fmaxf(v50, *(float *)(a1 + 616));
      }
      float v48 = DisplayLuminanceToPerceptualLuminance(*(void *)(a1 + 408), v50);
      float v47 = DisplayLuminanceToPerceptualLuminance(*(void *)(a1 + 408), *(float *)(a1 + 616));
      if ([+[CBAODState sharedInstance] isAODActive])
      {
        [+[CBAODState sharedInstance] minAODNits];
        float v27 = v6;
        [+[CBAODState sharedInstance] maxAODNits];
        float v48 = BULuminanceToPerceptual(v50, v27, v7);
        float v29 = *(float *)(a1 + 616);
        [+[CBAODState sharedInstance] minAODNits];
        float v28 = v8;
        [+[CBAODState sharedInstance] maxAODNits];
        float v47 = BULuminanceToPerceptual(v29, v28, v9);
      }
      float VirtualBrightness = DisplayGetVirtualBrightness(*(float **)(a1 + 408));
      float v45 = DisplayLuminanceToPerceptualLuminance(*(void *)(a1 + 408), VirtualBrightness);
      float v44 = v48 - v47;
      float v43 = vabds_f32(*(float *)(a1 + 544), *(float *)(a1 + 624));
      if (*(float *)(a1 + 624) == 0.0) {
        float v26 = *(float *)(a1 + 544);
      }
      else {
        float v26 = *(float *)(a1 + 544) / *(float *)(a1 + 624);
      }
      float v42 = *(float *)(a1 + 4008);
      if (*(_DWORD *)(a1 + 676) && *(float *)(a1 + 624) == 0.0) {
        float v42 = fmaxf(v42, 2.0);
      }
      if (v43 > v42 || (*(unsigned char *)(a1 + 4092) & 1) != 0)
      {
        char v25 = 1;
        if ((v54 & 1) == 0) {
          char v25 = (*(uint64_t (**)(void, void, void, float, float, float, float, float))(**(void **)(a1 + 4016) + 8))(*(void *)(a1 + 4016), *(unsigned char *)(a1 + 628) & 1, *(unsigned char *)(a1 + 316) & 1, v47, v45, v48, v43, v26);
        }
        char v52 = v25 & 1;
        if ((*(unsigned char *)(a1 + 4084) & 1) != 0 && v44 > 0.0 && v50 >= WeakCap) {
          char v52 = 1;
        }
      }
      if (*(unsigned char *)(a1 + 4092)) {
        char v52 = 1;
      }
      if (*(unsigned char *)(a1 + 4160))
      {
        char v52 = 1;
        *(unsigned char *)(a1 + 4160) = 0;
      }
      AABC::RecordLuminance((AABC *)a1, v50);
      if (_logHandle)
      {
        float v24 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v23 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v23 = init_default_corebrightness_log();
        }
        float v24 = v23;
      }
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        if (v52) {
          float v10 = "systemShallUpdateBacklight";
        }
        else {
          float v10 = "";
        }
        __os_log_helper_16_2_6_4_0_8_0_8_0_8_0_8_0_8_32((uint64_t)v63, 512, COERCE__INT64(*(float *)(a1 + 616)), COERCE__INT64(v48), COERCE__INT64(v47), COERCE__INT64(v44), (uint64_t)v10);
        _os_log_debug_impl(&dword_1BA438000, v24, OS_LOG_TYPE_DEBUG, "[%x]: _L_target=%f Pnewtarget=%f Ptarget=%f Pdelta=%f  %s", v63, 0x3Au);
      }
      if (v52)
      {
        *(float *)(a1 + 620) = VirtualBrightness;
        float v41 = v48 - v45;
        if (v54)
        {
          float v51 = 0.5;
        }
        else if (*(_DWORD *)(a1 + 676))
        {
          if (v41 >= 0.15) {
            float v51 = *(float *)(a1 + 696);
          }
          else {
            float v51 = PerceptualLuminanceThresholding::DurationFromPerceptualDelta(*(PerceptualLuminanceThresholding **)(a1 + 4016), v41)/ 5.0;
          }
          if (_logHandle)
          {
            uint64_t v22 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v21 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v21 = init_default_corebrightness_log();
            }
            uint64_t v22 = v21;
          }
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v62, 512, COERCE__INT64(v51));
            _os_log_debug_impl(&dword_1BA438000, v22, OS_LOG_TYPE_DEBUG, "[%x]: FAST RAMP (timeConstant=%0.2f", v62, 0x12u);
          }
        }
        else
        {
          float v51 = PerceptualLuminanceThresholding::DurationFromPerceptualDelta(*(PerceptualLuminanceThresholding **)(a1 + 4016), v41);
        }
        if (v41 < 0.0) {
          ++*(_DWORD *)(a1 + 3984);
        }
      }
    }
    else
    {
      AABC::RecordLuminance((AABC *)a1, v50);
      char v52 = 1;
      if (_logHandle)
      {
        uint64_t v20 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v19 = init_default_corebrightness_log();
        }
        uint64_t v20 = v19;
      }
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_4_4_0_8_32_8_0_8_0((uint64_t)v61, 512, (uint64_t)"false", COERCE__INT64(*(float *)(a1 + 620)), COERCE__INT64(v50));
        _os_log_debug_impl(&dword_1BA438000, v20, OS_LOG_TYPE_DEBUG, "[%x]: MANUAL isSensorChange=%s _L_current=%f L_target=%f", v61, 0x26u);
      }
    }
    if (_logHandle)
    {
      char v18 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v17 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v17 = init_default_corebrightness_log();
      }
      char v18 = v17;
    }
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      if (v52) {
        uint64_t v11 = "true";
      }
      else {
        uint64_t v11 = "false";
      }
      __os_log_helper_16_2_4_4_0_8_32_8_0_8_0((uint64_t)v60, 512, (uint64_t)v11, COERCE__INT64(v50), COERCE__INT64(v51));
      _os_log_debug_impl(&dword_1BA438000, v18, OS_LOG_TYPE_DEBUG, "[%x]: systemShallUpdateBacklight=%s L_target=%f timeConstant=%f", v60, 0x26u);
    }
    if (*(float *)(a1 + 492) == 0.0 || *(float *)(a1 + 492) == 1.0) && (v52)
    {
      *(_DWORD *)(a1 + 624) = *(_DWORD *)(a1 + 544);
      *(float *)(a1 + 616) = v50;
      if (v51 != 0.0) {
        *(unsigned char *)(a1 + 628) = 1;
      }
      char v53 = 1;
      if (_logHandle)
      {
        int v16 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v15 = init_default_corebrightness_log();
        }
        int v16 = v15;
      }
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v59, COERCE__INT64(v50), COERCE__INT64(v51), COERCE__INT64(*(float *)(a1 + 544)));
        _os_log_impl(&dword_1BA438000, v16, OS_LOG_TYPE_INFO, "Begin ramp: L_target=%0.4f timeConstant=%0.4f _Esensor_trusted=%0.4f", v59, 0x20u);
      }
      AABC::SetBrightness((AABC *)a1, *(float *)(a1 + 616), v51, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
      float BrightnessMaxPhysical = _DisplayGetBrightnessMaxPhysical(*(void *)(a1 + 408));
      float BrightnessMinPhysical = _DisplayGetBrightnessMinPhysical(*(void *)(a1 + 408));
      if (_logHandle)
      {
        char v14 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v13 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v13 = init_default_corebrightness_log();
        }
        char v14 = v13;
      }
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v58, (uint64_t)"ALS", COERCE__INT64(v50), COERCE__INT64(BrightnessMaxPhysical), COERCE__INT64(BrightnessMinPhysical), COERCE__INT64(v51), COERCE__INT64(*(float *)(a1 + 544)));
        _os_log_impl(&dword_1BA438000, v14, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: Begin ramp: L_target=%0.4f Lmax=%f Lmin=%f timeConstant=%0.4f _Esensor_trusted=%0.4f", v58, 0x3Eu);
      }
    }
  }
  *(unsigned char *)(a1 + 4092) = 0;
  return v53 & 1;
}

float DisplayLuminanceToPerceptualLuminance(uint64_t a1, float a2)
{
  uint64_t v19 = a1;
  float v18 = a2;
  uint64_t v13 = 0;
  char v14 = (float *)&v13;
  int v15 = 0x20000000;
  int v16 = 32;
  int v17 = 0;
  double v2 = *(NSObject **)(a1 + 144);
  uint64_t v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  float v8 = __DisplayLuminanceToPerceptualLuminance_block_invoke;
  float v9 = &unk_1E621A430;
  float v10 = &v13;
  uint64_t v11 = v19;
  float v12 = a2;
  disp_dispatch_sync(v2, &v5);
  float v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA4702F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

void disp_dispatch_sync(NSObject *a1, void (**a2)(void))
{
  if (a1) {
    dispatch_sync(a1, a2);
  }
  else {
    a2[2]();
  }
}

float AABC::RecordLuminance(AABC *this, float result)
{
  if (*((void *)this + 497))
  {
    *(float *)(*((void *)this + 497) + 4 * *((unsigned int *)this + 988)) = result;
    *((_DWORD *)this + 988) = (*((_DWORD *)this + 988) + 1) % *((_DWORD *)this + 990);
    if (*((_DWORD *)this + 989) < *((_DWORD *)this + 990)) {
      ++*((_DWORD *)this + 989);
    }
    float v3 = *((float *)this + 182);
    for (unsigned int i = 0; i < *((_DWORD *)this + 989); ++i)
      float v3 = fminf(v3, *(float *)(*((void *)this + 497) + 4 * (int)i));
    float result = v3;
    *((float *)this + 151) = v3;
  }
  return result;
}

float DisplayGetVirtualBrightness(float *a1)
{
  if (*((_DWORD *)a1 + 10)) {
    return a1[372];
  }
  else {
    return a1[314];
  }
}

uint64_t PerceptualLuminanceThresholding_legacy::shallUpdateBacklight(PerceptualLuminanceThresholding_legacy *this, float a2, float a3, float a4, char a5, char a6, float a7, float a8)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v32 = this;
  float v31 = a2;
  float v30 = a3;
  float v29 = a4;
  char v28 = a5 & 1;
  char v27 = a6 & 1;
  float v26 = a7;
  float v25 = a8;
  float v24 = a4 - a2;
  char v23 = 0;
  float v22 = 0.0;
  float v22 = *((float *)this + 6);
  float v21 = 0.0;
  float v21 = *((float *)this + 7);
  if (*((_DWORD *)this + 10))
  {
    float v21 = *((float *)this + 7) * *((float *)this + 12);
    if (v31 > *((float *)this + 6))
    {
      float v22 = *((float *)this + 6) * *((float *)this + 11);
      os_log_t v20 = 0;
      if (*((void *)this + 2))
      {
        char v14 = *((void *)this + 2);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        char v14 = inited;
      }
      os_log_t v20 = v14;
      os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v33, COERCE__INT64(*((float *)this + 6)), COERCE__INT64(v22), COERCE__INT64(v31));
        _os_log_debug_impl(&dword_1BA438000, v20, v19, "%f %f %f", v33, 0x20u);
      }
      if (v25 < *((float *)this + 14) && v26 > *((float *)this + 13))
      {
        os_log_t oslog = 0;
        if (*((void *)this + 2))
        {
          uint64_t v12 = *((void *)this + 2);
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v11 = init_default_corebrightness_log();
          }
          uint64_t v12 = v11;
        }
        os_log_t oslog = v12;
        os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          float v9 = oslog;
          os_log_type_t v10 = v17;
          __os_log_helper_16_0_0(v16);
          _os_log_debug_impl(&dword_1BA438000, v9, v10, "Double aggressivity", v16, 2u);
        }
        float v22 = v22 / 2.0;
      }
    }
  }
  if (v28)
  {
    if (v29 < 0.97 || v24 <= 0.0)
    {
      if (v24 <= v21)
      {
        if (v24 < (float)-v22 && (v25 <= 0.85 || v25 >= 1.15 || (v27 & 1) != 0)) {
          char v23 = 1;
        }
      }
      else if (v25 <= 0.85 || v25 >= 1.15 || (v27 & 1) != 0)
      {
        char v23 = 1;
      }
    }
    else
    {
      char v23 = 1;
    }
  }
  else if (v29 < 0.97 || v24 <= 0.0)
  {
    if (v24 <= v21)
    {
      if (v24 < (float)-v22) {
        char v23 = 1;
      }
    }
    else
    {
      char v23 = 1;
    }
  }
  else
  {
    char v23 = 1;
  }
  return v23 & 1;
}

uint64_t AABC::isTrustedOccluded(id **this)
{
  if (!this[60] || (*((unsigned char *)this + 3937) & 1) == 0 || (char v3 = 1, !*((_DWORD *)this + 987)))
  {
    char isTouchObstructed = 0;
    if (this[57]) {
      char isTouchObstructed = AABC::ALS::isTouchObstructed(this[57]);
    }
    char v3 = isTouchObstructed;
  }
  return v3 & 1;
}

uint64_t __os_log_helper_16_2_3_8_64_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 3;
  *(unsigned char *)(result + 2) = 64;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  return result;
}

uint64_t APDSGrimaldiCallback(void **a1, const void **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      if (*a2)
      {
        (*((void (**)(void))*a2 + 2))();
        _Block_release(*a2);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        if (os_log_type_enabled(inited, OS_LOG_TYPE_FAULT))
        {
          __os_log_helper_16_2_2_8_32_4_0((uint64_t)v7, (uint64_t)"APDSGrimaldiCallback", 86);
          _os_log_fault_impl(&dword_1BA438000, inited, OS_LOG_TYPE_FAULT, "%s:%d callbackData->responseBlock is NULL", v7, 0x12u);
        }
      }
      free(a2);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        float v4 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        float v4 = init_default_corebrightness_log();
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      {
        __os_log_helper_16_2_2_8_32_4_0((uint64_t)v8, (uint64_t)"APDSGrimaldiCallback", 82);
        _os_log_fault_impl(&dword_1BA438000, v4, OS_LOG_TYPE_FAULT, "%s:%d callbackData is NULL", v8, 0x12u);
      }
    }
    free(*a1);
    free(a1[2]);
    free(a1[1]);
    free(a1[3]);
    free(a1);
  }
  return 0;
}

void sub_1BA473748()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_8_64_8_0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 64;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  return result;
}

uint64_t AABCCallback(void *a1, const __CFString *a2, const void *a3)
{
  id v12 = a1;
  CFStringRef v11 = a2;
  os_log_type_t v10 = a3;
  if (!a1 || !v11 || !v10)
  {
    uint64_t v9 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v9 = inited;
    char v8 = 16;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      log = v9;
      os_log_type_t type = v8;
      __os_log_helper_16_0_0(v7);
      _os_log_error_impl(&dword_1BA438000, log, type, "error: invalid parameters", v7, 2u);
    }
  }
  return [v12 sendNotificationForKey:v11 withValue:v10];
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
}

uint64_t __Block_byref_object_dispose__17(uint64_t a1)
{
  return std::list<AAB::CurveUpdate>::~list(a1 + 48);
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
}

void __Block_byref_object_dispose__21(uint64_t a1)
{
}

uint64_t __DisplayUpdateAAPState_block_invoke(uint64_t a1)
{
  return __DisplayUpdateAAPStateInternal(*(void *)(a1 + 32), *(void *)(a1 + 40), *(unsigned char *)(a1 + 48) & 1);
}

uint64_t __DisplayUpdateAAPStateInternal(uint64_t result, uint64_t a2, char a3)
{
  if (*(unsigned char *)(result + 12282)) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(result + 12472))(result, a2, a3 & 1);
  }
  return result;
}

void __DisplayUpdateAAPStateLookup(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  char v30 = a3 & 1;
  BOOL v29 = 0;
  if (*(_DWORD *)a2)
  {
    switch(*(_DWORD *)a2)
    {
      case 1:
        *(_DWORD *)(a1 + 12304) = *(_DWORD *)(a2 + 4);
        BOOL v29 = (*(unsigned char *)(a1 + 12280) & 1) != 0;
        break;
      case 2:
        if ((float)((float)(vabds_f32(*(float *)(a2 + 4), *(float *)(a1 + 12300)) / *(float *)(a1 + 12300)) * 100.0) > *(float *)(a1 + 12268))
        {
          *(_DWORD *)(a1 + 12300) = *(_DWORD *)(a2 + 4);
          BOOL v29 = (*(unsigned char *)(a1 + 12280) & 1) != 0;
        }
        break;
      case 3:
        *(_DWORD *)(a1 + 12296) = *(_DWORD *)(a2 + 4);
        *(unsigned char *)(a1 + 12285) = *(float *)(a1 + 12296) != 1.0;
        BOOL v29 = (*(unsigned char *)(a1 + 12285) & 1) != 0;
        break;
    }
  }
  else
  {
    char v13 = 1;
    if ((*(unsigned char *)(a2 + 4) & 1) == 0) {
      char v13 = *(unsigned char *)(a1 + 12284);
    }
    *(unsigned char *)(a1 + 12280) = v13 & 1;
    if (*(unsigned char *)(a1 + 12280)) {
      BOOL v29 = 1;
    }
    else {
      __DisplaySetAAPFactorWithFade(a1, 0, 0, 0.0, *(float *)(a1 + 12252));
    }
  }
  if (v29)
  {
    float v23 = *(float *)(a1 + 12304);
    float v22 = *(float *)(a1 + 12300);
    int IndexFromValue = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 12312) - 1, *(void *)(a1 + 12320), v23);
    float PercentageFromIndex = __DisplayGetPercentageFromIndex(IndexFromValue, *(_DWORD *)(a1 + 12312) - 1, *(float **)(a1 + 12320), v23);
    if (IndexFromValue != *(_DWORD *)(a1 + 12288) || (v30 & 1) != 0)
    {
      int v27 = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 12328) - 1, *(void *)(a1 + 12336), v22);
      float v24 = __DisplayGetPercentageFromIndex(v27, *(_DWORD *)(a1 + 12328) - 1, *(float **)(a1 + 12336), v22);
      *(_DWORD *)(a1 + 12288) = IndexFromValue;
      if (v24 == 0.0) {
        float v12 = *(float *)(*(void *)(a1 + 12352) + 272 * v27 + 4 * IndexFromValue);
      }
      else {
        float v12 = *(float *)(*(void *)(a1 + 12352) + 272 * (v27 + 1) + 4 * IndexFromValue);
      }
      if (PercentageFromIndex == 0.0) {
        float v11 = *(float *)(*(void *)(a1 + 12352) + 272 * v27 + 4 * IndexFromValue);
      }
      else {
        float v11 = *(float *)(*(void *)(a1 + 12352) + 272 * v27 + 4 * (IndexFromValue + 1));
      }
      if (v24 == 0.0 || PercentageFromIndex == 0.0) {
        float v10 = *(float *)(*(void *)(a1 + 12352) + 272 * v27 + 4 * IndexFromValue);
      }
      else {
        float v10 = *(float *)(*(void *)(a1 + 12352) + 272 * (v27 + 1) + 4 * (IndexFromValue + 1));
      }
      float v20 = *(float *)(*(void *)(a1 + 12352) + 272 * v27 + 4 * IndexFromValue);
      float v18 = (float)(v20 + (float)((float)(v12 - v20) * v24))
          + (float)((float)((float)(v11 + (float)((float)(v10 - v11) * v24))
                          - (float)(v20 + (float)((float)(v12 - v20) * v24)))
                  * PercentageFromIndex);
      if (*(unsigned char *)(a1 + 12285) & 1) != 0 && (*(unsigned char *)(a1 + 12292))
      {
        float v15 = *(float *)(a1 + 12296);
        int v17 = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 12360) - 1, *(void *)(a1 + 12368), v15);
        if (v17 && v17 != *(_DWORD *)(a1 + 12360) - 1)
        {
          float v26 = *(float *)(*(void *)(a1 + 12368) + 4 * v17);
          float v16 = (float)(v15 - v26) / (float)(*(float *)(*(void *)(a1 + 12368) + 4 * (v17 + 1)) - v26);
        }
        else
        {
          float v16 = 0.0;
        }
        if (v16 == 0.0) {
          float v9 = *(float *)(*(void *)(a1 + 12384) + 4 * v17);
        }
        else {
          float v9 = *(float *)(*(void *)(a1 + 12384) + 4 * (v17 + 1));
        }
        float v21 = *(float *)(*(void *)(a1 + 12384) + 4 * v17);
        float v14 = v21 + (float)((float)(v9 - v21) * v16);
        if (_logHandle)
        {
          char v8 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t inited = init_default_corebrightness_log();
          }
          char v8 = inited;
        }
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v34, COERCE__INT64(v18), COERCE__INT64(v14), COERCE__INT64((float)(v18 * v14)), COERCE__INT64(v22), COERCE__INT64(v23));
          _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "Starting New HDR Ramp with LUT: UnScaledFactor:=%0.4f HDRScale:=%0.4f ScaledFactor:=%0.4f Lux:=%0.4f Nits:=%0.4f\n", v34, 0x34u);
        }
        float v18 = v18 * v14;
      }
      else if (*(unsigned char *)(a1 + 12285) & 1) == 0 || (*(unsigned char *)(a1 + 12292))
      {
        if (_logHandle)
        {
          float v4 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v3 = init_default_corebrightness_log();
          }
          float v4 = v3;
        }
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v32, COERCE__INT64(v18), COERCE__INT64(v22), COERCE__INT64(v23));
          _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "Starting New AAP Ramp: Factor:=%0.4f Lux:=%0.4f Nits:=%0.4f\n", v32, 0x20u);
        }
      }
      else
      {
        if (_logHandle)
        {
          int v6 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v5 = init_default_corebrightness_log();
          }
          int v6 = v5;
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v33, COERCE__INT64(v18), COERCE__INT64(v22), COERCE__INT64(v23), COERCE__INT64(*(float *)(a1 + 12296)));
          _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "Starting New HDR AAP Ramp: Factor:=%0.4f Lux:=%0.4f Nits:=%0.4f HDRFactor:=%0.4f\n", v33, 0x2Au);
        }
      }
      float v19 = (float)(v18 - 1.0) / 15.0;
      if (*(float *)(a1 + 12392) >= v19) {
        __DisplaySetAAPFactorWithFade(a1, 0, 0, v19, *(float *)(a1 + 12276));
      }
      else {
        __DisplaySetAAPFactorWithFade(a1, 0, 0, v19, *(float *)(a1 + 12272));
      }
    }
  }
}

void DisplaySetEDRForTargetYcompensation(uint64_t a1, float a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 12596) == 1)
  {
    float v10 = *(float *)(a1 + 1544);
    CFXFindBrightnessCompAlpha(v10);
    float v9 = v2;
    float v3 = (float)(v9 * a2) + 1.0 - v9;
    float v8 = v3;
    *(float *)(a1 + 12528) = v3;
    float v7 = *(float *)(a1 + 1500);
    float v6 = _DisplayComputeEDRNitsCap(a1);
    if (_logHandle)
    {
      uint64_t v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v13, COERCE__INT64(a2), COERCE__INT64(v10), COERCE__INT64(v9), COERCE__INT64(v8), COERCE__INT64(v7), COERCE__INT64(*(float *)(a1 + 1192)), COERCE__INT64(v6));
      _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "EDR Color brightness compensation (SetLibEDRBrightness) TargetYCompensation: %f, inputL: %f, alpha: %f, Ycomp: %f. L_device: %f, currentLux: %f, nitsCapEDR: %f", v13, 0x48u);
    }
    SetLibEDRBrightness(a1, v7, v6, *(float *)(a1 + 1192), v8);
  }
}

void SetLibEDRBrightness(uint64_t a1, float a2, float a3, float a4, float a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 12596))
  {
    if (_logHandle)
    {
      float v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v6 = inited;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v12, COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(a4), COERCE__INT64(a5));
      _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "SetLibEDRBrightness to currentBrightness=%f, maxBrightness=%f, currentLux=%f, compensationBoost=%f", v12, 0x2Au);
    }
    CBEDRServerDisplayBrightness(*(_DWORD *)(a1 + 12592), a2, a3, a4, a5);
  }
}

void CBEDRServerDisplayBrightness(unsigned int a1, float a2, float a3, float a4, float a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (edrServerSetDisplayBrightnessFunction)
  {
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_6_8_32_4_0_8_0_8_0_8_0_8_0((uint64_t)v13, (uint64_t)"CBEDRServerDisplayBrightness", a1, COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(a4), COERCE__INT64(a5));
      _os_log_debug_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_DEBUG, "%s: display: %u | target: %f | max: %f | ambient: %f | boost=%f", v13, 0x3Au);
    }
    edrServerSetDisplayBrightnessFunction(a1, a2, a3, a4, a5);
  }
  else
  {
    uint64_t v5 = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v12, (uint64_t)"CBEDRServerDisplayBrightness");
      _os_log_error_impl(&dword_1BA438000, v5, OS_LOG_TYPE_ERROR, "%s: missing edrServerSetDisplayBrightnessFunction ", v12, 0xCu);
    }
  }
}

float _DisplayComputeEDRNitsCap(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  float v9 = *(float *)(a1 + 1544);
  if (*(unsigned char *)(a1 + 1517))
  {
    if (_DisplayBDMAvailable(a1)) {
      float v9 = *(float *)(a1 + 1168);
    }
    float v10 = fmaxf(v9, *(float *)(a1 + 1320));
    if (*(float *)(a1 + 12104) != 0.0)
    {
      float v8 = *(float *)(a1 + 12108);
      unsigned int APLColumnOrDefault = DisplayGetAPLColumnOrDefault(a1, 0x64u);
      float CPMSPowerConstraint = __DisplayGetCPMSPowerConstraint(a1);
      float v10 = fminf(v10, fmaxf(v8, DisplayPowerToPhysicalBrightness(a1, APLColumnOrDefault, CPMSPowerConstraint)));
    }
    if (_logHandle)
    {
      uint64_t v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v14, COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(*(float *)(a1 + 528)), COERCE__INT64(*(float *)(a1 + 1320)), COERCE__INT64(*(float *)(a1 + 12108)), COERCE__INT64(v10));
      _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "Superbright EDR restrictions [would be]: CLTM %f, UPO %f, bottom [lower] restriction %f, nits cap hdr: %f, after BDM: %f", v14, 0x34u);
    }
  }
  else
  {
    float v11 = fminf(fminf(v9, *(float *)(a1 + 464)), *(float *)(a1 + 528));
    if (*(float *)(a1 + 1140) < 1.0) {
      float v11 = *(float *)(a1 + 1320) + (float)(*(float *)(a1 + 1140) * (float)(v11 - *(float *)(a1 + 1320)));
    }
    if ((*(unsigned char *)(a1 + 12512) & 1) == 0 && (*(unsigned char *)(a1 + 12515) & 1) == 0) {
      *(float *)(a1 + 12528) = 1.0;
    }
    float v10 = fmaxf(v11, *(float *)(a1 + 1320));
    if (*(float *)(a1 + 12104) != 0.0)
    {
      float v12 = *(float *)(a1 + 12108);
      unsigned int v6 = DisplayGetAPLColumnOrDefault(a1, 0x64u);
      float v2 = __DisplayGetCPMSPowerConstraint(a1);
      float v10 = fmaxf(v12, DisplayPowerToPhysicalBrightness(a1, v6, v2));
    }
  }
  if (*(_DWORD *)(a1 + 224)) {
    float v10 = fminf(v10, *(float *)(a1 + 724));
  }
  *(_DWORD *)(a1 + 1132) = (int)(float)(v10 * 65536.0);
  return v10;
}

float __DisplayGetCPMSPowerConstraint(uint64_t a1)
{
  if (*(float *)(a1 + 528) <= *(float *)(a1 + 524))
  {
    float v4 = *(float *)(a1 + 12076);
  }
  else
  {
    unsigned int APLColumnOrDefault = DisplayGetAPLColumnOrDefault(a1, 0x64u);
    float v4 = DisplayPhysicalBrightnessToPower(a1, APLColumnOrDefault, *(float *)(a1 + 528));
  }
  if (*(unsigned char *)(a1 + 12080)) {
    return *(float *)(a1 + 12072);
  }
  else {
    return fminf(*(float *)(a1 + 12072), v4);
  }
}

float DisplayPowerToPhysicalBrightness(uint64_t a1, unsigned int a2, float a3)
{
  return __DisplayPowerToPhysicalBrightnessInternal(a1, a2, a3);
}

float __DisplayPowerToPhysicalBrightnessInternal(uint64_t a1, unsigned int a2, float a3)
{
  if (!*(_DWORD *)(a1 + 1660)) {
    return 0.0;
  }
  int APLIndex = DisplayGetAPLIndex(a1, a2);
  int IndexFromValue = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 1660) - 1, a1 + 2068 + 200 * APLIndex, a3);
  float PercentageFromIndex = __DisplayGetPercentageFromIndex(IndexFromValue, *(_DWORD *)(a1 + 1660) - 1, (float *)(a1 + 2068 + 200 * APLIndex), a3);
  if (IndexFromValue == *(_DWORD *)(a1 + 1660) - 1) {
    float v4 = *(float *)(a1 + 1868 + 4 * IndexFromValue);
  }
  else {
    float v4 = *(float *)(a1 + 1868 + 4 * IndexFromValue)
  }
       + (float)(PercentageFromIndex
               * (float)(*(float *)(a1 + 1868 + 4 * (IndexFromValue + 1))
                       - *(float *)(a1 + 1868 + 4 * IndexFromValue)));
  float v8 = v4;
  if (v4 > *(float *)(a1 + 1664) * 0.95) {
    return fmaxf(v4, *(float *)(a1 + 1544));
  }
  return v8;
}

uint64_t __DisplayGetIndexFromValue(int a1, int a2, uint64_t a3, float a4)
{
  if (a1 >= 0 && a2 >= 0)
  {
    if (a1 < a2)
    {
      int v5 = (a1 + a2) / 2;
      if (*(float *)(a3 + 4 * v5) <= a4)
      {
        if (a4 >= *(float *)(a3 + 4 * (v5 + 1))) {
          return __DisplayGetIndexFromValue((v5 + 1), a2, a3, a4);
        }
        else {
          return ((a1 + a2) / 2);
        }
      }
      else
      {
        return __DisplayGetIndexFromValue(a1, v5, a3, a4);
      }
    }
    else
    {
      return a2;
    }
  }
  else
  {
    return 0;
  }
}

float __DisplayGetPercentageFromIndex(int a1, int a2, float *a3, float a4)
{
  if (a4 < *a3 || a1 == a2) {
    return 0.0;
  }
  else {
    return (float)(a4 - a3[a1]) / (float)(a3[a1 + 1] - a3[a1]);
  }
}

uint64_t DisplayGetAPLIndex(uint64_t a1, unsigned int a2)
{
  return __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 1656) - 1, a1 + 1668, (float)a2);
}

uint64_t DisplayGetAPLColumnOrDefault(uint64_t a1, unsigned int a2)
{
  unsigned int APLColumn = DisplayGetAPLColumn(a1);
  if (APLColumn == -1) {
    return a2;
  }
  else {
    return APLColumn;
  }
}

uint64_t DisplayGetAPLColumn(uint64_t a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  int v5 = __DisplayGetAPLColumn_block_invoke;
  unsigned int v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = a1;
  float v10 = &DisplayGetAPLColumn_token;
  float v9 = &v2;
  if (DisplayGetAPLColumn_token != -1) {
    dispatch_once(v10, v9);
  }
  return DisplayGetAPLColumn_column;
}

void CFXFindBrightnessCompAlpha(float a1)
{
}

float _CFXFindBrightnessCompAlpha(float *a1, int a2, float a3)
{
  float v6 = 0.0;
  if (a3 <= *a1) {
    return a1[a2];
  }
  if (a3 >= a1[a2 - 1]) {
    return a1[2 * a2 - 1];
  }
  for (int i = 1; i < a2; ++i)
  {
    if (a3 < a1[i])
    {
      float v4 = (float)(a1[i] - a3) / (float)(a1[i] - a1[i - 1]);
      return (float)((float)(1.0 - v4) * a1[a2 + i]) + (float)(v4 * a1[a2 - 1 + i]);
    }
  }
  return v6;
}

float __DisplaySetAAPFactorWithFade(uint64_t a1, void (*a2)(uint64_t), uint64_t a3, float a4, float a5)
{
  if (*(unsigned char *)(a1 + 380)) {
    a5 = *(float *)(a1 + 376);
  }
  *(double *)(a1 + 12400) = a5;
  if (*(double *)(a1 + 12400) == 0.0)
  {
    *(float *)(a1 + 12424) = a4;
    *(float *)(a1 + 12416) = a4;
    *(float *)(a1 + 12420) = a4;
    __DisplaySetAAPFactor((unsigned char *)a1, a4);
    if (a2) {
      a2(a3);
    }
  }
  else
  {
    float result = *(float *)(a1 + 12392);
    if (result != a4)
    {
      *(void *)(a1 + 12440) = a2;
      *(void *)(a1 + 12448) = a3;
      *(CFAbsoluteTime *)(a1 + 12408) = CFAbsoluteTimeGetCurrent();
      double v7 = *(float *)(a1 + 12488);
      if (v7 == 0.0) {
        double v7 = 0.100000001;
      }
      *(_DWORD *)(a1 + 12420) = *(_DWORD *)(a1 + 12392);
      *(_DWORD *)(a1 + 12424) = *(_DWORD *)(a1 + 12392);
      *(float *)(a1 + 12416) = a4;
      float v6 = v7;
      __DisplayStartFade((unsigned char *)a1, v6);
    }
  }
  return result;
}

uint64_t init_default_corebrightness_log()
{
  _COREBRIGHTNESS_LOG_DEFAULT = (uint64_t)os_log_create("com.apple.CoreBrightness", "default");
  if (!_COREBRIGHTNESS_LOG_DEFAULT)
  {
    int v5 = MEMORY[0x1E4F14500];
    char v4 = 16;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      log = v5;
      os_log_type_t type = v4;
      __os_log_helper_16_0_0(v3);
      _os_log_error_impl(&dword_1BA438000, log, type, "Failed to create CoreBrightness default log", v3, 2u);
    }
    _COREBRIGHTNESS_LOG_DEFAULT = MEMORY[0x1E4F14500];
  }
  return _COREBRIGHTNESS_LOG_DEFAULT;
}

void _CFXClampToCurve(uint64_t a1, int a2, float *a3)
{
  uint64_t v25 = a1;
  int v24 = a2;
  float v23 = a3;
  int v22 = a2;
  *(void *)float v21 = 0;
  uint64_t v20 = 0;
  if (*a3 >= 0.0)
  {
    float v17 = 0.0;
    int v16 = -1;
    double v15 = 100000.0;
    for (int i = 0; i < v22; ++i)
    {
      float v13 = *(float *)(v25 + 4 * i) - *v23;
      float v3 = *(float *)(v25 + 4 * (i + v22)) - v23[1];
      float v12 = (float)(v13 * v13) + (float)(v3 * v3);
      if (v12 < v15)
      {
        double v15 = v12;
        int v16 = i;
      }
    }
    if (v16 >= 0) {
      float v17 = *(float *)(v25 + 4 * v16);
    }
    if (*v23 < v17 && v16 > 0 || v16 == v24)
    {
      int v19 = v16 - 1;
      int v18 = v16;
    }
    else
    {
      int v19 = v16;
      int v18 = v16 + 1;
    }
    v21[0] = *(float *)(v25 + 4 * v19);
    v21[1] = *(float *)(v25 + 4 * (v19 + v22));
    LODWORD(v20) = *(_DWORD *)(v25 + 4 * v18);
    HIDWORD(v20) = *(_DWORD *)(v25 + 4 * (v18 + v22));
    float v4 = compute_projection(v21, (float *)&v20, v23);
    if (v4 >= v21[0] || v19 <= 0)
    {
      if (v4 <= *(float *)&v20)
      {
        *(void *)float v23 = __PAIR64__(v5, LODWORD(v4));
      }
      else
      {
        v21[0] = *(float *)(v25 + 4 * (v19 + 1));
        v21[1] = *(float *)(v25 + 4 * (v19 + 1 + v22));
        LODWORD(v20) = *(_DWORD *)(v25 + 4 * (v19 + 2));
        HIDWORD(v20) = *(_DWORD *)(v25 + 4 * (v19 + 2 + v22));
        float v10 = v23;
        float v8 = compute_projection(v21, (float *)&v20, v23);
        *(void *)float v10 = __PAIR64__(v9, LODWORD(v8));
        if (*v23 < v21[0] && v19 > 0) {
          *(void *)float v23 = *(void *)v21;
        }
      }
    }
    else
    {
      v21[0] = *(float *)(v25 + 4 * (v19 - 1));
      v21[1] = *(float *)(v25 + 4 * (v19 - 1 + v22));
      LODWORD(v20) = *(_DWORD *)(v25 + 4 * v19);
      HIDWORD(v20) = *(_DWORD *)(v25 + 4 * (v19 + v22));
      float v11 = v23;
      float v6 = compute_projection(v21, (float *)&v20, v23);
      *(void *)float v11 = __PAIR64__(v7, LODWORD(v6));
      if (*v23 > *(float *)&v20) {
        *(void *)float v23 = v20;
      }
    }
  }
}

float compute_projection(float *a1, float *a2, float *a3)
{
  float v4 = 0.0;
  if (a1 && a2 && a3) {
    return *a3
  }
         - (float)((float)((float)-(float)((float)((float)(*a2 - *a1) * (float)(a3[1] - a1[1]))
                                         - (float)((float)(a2[1] - a1[1]) * (float)(*a3 - *a1)))
                         / (float)((float)((float)(a2[1] - a1[1]) * (float)(a2[1] - a1[1]))
                                 + (float)((float)(*a2 - *a1) * (float)(*a2 - *a1))))
                 * (float)(a2[1] - a1[1]));
  syslog(1, "%s: Invalid input params: p1=>0x%x, p2=>0x%x, p=>0x%x\n", "compute_projection", a1, a2, a3);
  return v4;
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__11(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__14(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
}

void *__Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
  return std::list<AAB::CurveUpdate>::list((void *)(a1 + 48), (uint64_t *)(a2 + 48));
}

void __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_copy__21(uint64_t a1, uint64_t a2)
{
}

void sub_1BA4780B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object)
{
}

uint64_t __os_log_helper_16_0_1_4_0(uint64_t result, int a2)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1) = 1;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  return result;
}

void sub_1BA4790D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, _Unwind_Exception *exception_object)
{
}

uint64_t _CFXSetTarget(uint64_t a1, float *a2, char a3, char a4, float a5, float a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a1;
  int v24 = a2;
  float v23 = a5;
  char v22 = a3 & 1;
  char v21 = a4 & 1;
  float v20 = a6;
  if (*(float *)(a1 + 2252) >= 0.0) {
    float v23 = *(float *)(v25 + 2252);
  }
  double Current = CFAbsoluteTimeGetCurrent();
  BOOL v18 = 0;
  BOOL v18 = Current < *(double *)(v25 + 136);
  if (*(void *)(v25 + 96) && (*(unsigned char *)(*(void *)(v25 + 96) + 303) & 1) != 0)
  {
    if (*(float *)(*(void *)(v25 + 96) + 332) == *(float *)(*(void *)(v25 + 96) + 336))
    {
      double v15 = MEMORY[0x1E4F14500];
      os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v9 = v15;
        os_log_type_t v10 = v14;
        __os_log_helper_16_0_0(v13);
        _os_log_impl(&dword_1BA438000, v9, v10, "BaselineHarmony: Update WP, NO change in ALS strength", v13, 2u);
      }
    }
    else
    {
      *(unsigned char *)(*(void *)(v25 + 96) + 328) = 0;
      *(_DWORD *)(*(void *)(v25 + 96) + 340) = *(_DWORD *)(*(void *)(v25 + 96) + 336);
      *(_DWORD *)(*(void *)(v25 + 96) + 332) = *(_DWORD *)(*(void *)(v25 + 96) + 332);
      *(double *)(*(void *)(v25 + 96) + 320) = Current;
      *(double *)(*(void *)(v25 + 96) + 312) = v23;
      os_log_t v17 = (os_log_t)MEMORY[0x1E4F14500];
      os_log_type_t v16 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v26, COERCE__INT64(*(float *)(*(void *)(v25 + 96) + 336)), COERCE__INT64(*(float *)(*(void *)(v25 + 96) + 332)));
        _os_log_impl(&dword_1BA438000, v17, v16, "BaselineHarmony: Set new target, alsStrength current = %f, target: %f", v26, 0x16u);
      }
    }
  }
  if (!v18 || v23 == 0.0 || (v22 & 1) != 0 || (*(unsigned char *)(v25 + 144) & 1) != 0)
  {
    *(_DWORD *)(v25 + 192) = 9;
    __memcpy_chk();
    __memcpy_chk();
    __memcpy_chk();
    int v12 = 0;
    _CFXGetWPFromMatrix(v25, v24, (void *)(v25 + 200), &v12);
    *(float *)(v25 + 152) = v23;
    *(float *)(v25 + 196) = v20;
    *(unsigned char *)(v25 + 144) = (v22 ^ 1) & 1;
    *(double *)(v25 + 136) = Current + v23;
    char v11 = 0;
    if (*(unsigned char *)(v25 + 364))
    {
      __memcpy_chk();
      __memcpy_chk();
      *(double *)(v25 + 368) = *(float *)(v25 + 152);
      *(double *)(v25 + 376) = Current;
      char v11 = 1;
      *(unsigned char *)(v25 + 384) = 0;
    }
    if (*(void *)(v25 + 328))
    {
      unsigned int v7 = *(void (**)(uint64_t, uint64_t))(v25 + 328);
      uint64_t v8 = *(void *)(v25 + 336);
      if (v11) {
        v7(v8, 0);
      }
      else {
        v7(v8, v25 + 152);
      }
    }
  }
  return 1;
}

void *ColorRampCallback(void *result, uint64_t a2)
{
  if (result) {
    return (void *)[result colorRampRoutine:a2];
  }
  return result;
}

{
  if (result) {
    return (void *)[result colorRampRoutine:a2];
  }
  return result;
}

void ColorRampCallback_0(unsigned char *a1, float *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  BOOL v29 = a1;
  char v28 = a2;
  uint64_t v27 = 0;
  if (a1)
  {
    uint64_t v27 = v29;
    if (v28)
    {
      if (*((_DWORD *)v27 + 3149) == 1)
      {
        uint64_t v26 = 0;
        float v25 = 0.0;
        float v24 = 0.0;
        CFXGetWPFromMatrix(*((void *)v27 + 1563), v28 + 1, &v26, &v25);
        float v24 = 1.0 / v25;
        float v23 = 0.0;
        float v23 = *((float *)v27 + 386);
        CFXFindBrightnessCompAlpha(v23);
        float v22 = v2;
        float v3 = (float)(v22 * v24) + 1.0 - v22;
        float v21 = v3;
        *((float *)v27 + 3132) = v3;
        float v20 = 0.0;
        float v20 = *((float *)v27 + 375);
        float v19 = _DisplayComputeEDRNitsCap((uint64_t)v27);
        os_log_t oslog = 0;
        if (_logHandle)
        {
          float v6 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t inited = init_default_corebrightness_log();
          }
          float v6 = inited;
        }
        os_log_t oslog = v6;
        os_log_type_t type = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_8_0((uint64_t)v32, COERCE__INT64(v20), COERCE__INT64(v19), *((_DWORD *)v27 + 3150), COERCE__INT64(*((float *)v27 + 298)), COERCE__INT64(*((float *)v27 + 3132)));
          _os_log_debug_impl(&dword_1BA438000, oslog, type, "Night Shift/Harmony - SetLibEDRBrightness - physicalBrightness:%f, maxLum: %f, edrState: %d, lux: %f, brightness boost: %f\n", v32, 0x30u);
        }
        SetLibEDRBrightness((uint64_t)v27, v20, v19, *((float *)v27 + 298), v21);
      }
      CFMutableArrayRef theArray = 0;
      CFMutableArrayRef theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *((unsigned int *)v28 + 10), MEMORY[0x1E4F1D510]);
      if (theArray)
      {
        for (unsigned int i = 0; i < *((_DWORD *)v28 + 10); ++i)
        {
          value = 0;
          value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v28[i + 1]);
          if (value)
          {
            CFArrayAppendValue(theArray, value);
            CFRelease(value);
          }
        }
        CFMutableArrayRef Mutable = 0;
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D510]);
        if (Mutable)
        {
          CFTypeRef cf = 0;
          CFTypeRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, v28 + 12);
          if (cf)
          {
            CFArrayAppendValue(Mutable, cf);
            CFRelease(cf);
          }
          CFTypeRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, v28 + 13);
          if (cf)
          {
            CFArrayAppendValue(Mutable, cf);
            CFRelease(cf);
          }
          float valuePtr = 0.0;
          float valuePtr = *v28;
          float v4 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
          CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
          CFNumberRef v9 = CFNumberCreate(*v4, kCFNumberFloatType, v28 + 11);
          if (v10)
          {
            if (v9)
            {
              keys[0] = xmmword_1E621A668;
              keys[1] = xmmword_1E621A678;
              values[0] = theArray;
              values[1] = v10;
              values[2] = v9;
              values[3] = Mutable;
              CFDictionaryRef v8 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)values, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              if (v8)
              {
                if (*((void *)v27 + 2)) {
                  (*((void (**)(void, __CFString *, CFDictionaryRef))v27 + 2))(*((void *)v27 + 3), @"ColorRamp", v8);
                }
                CFRelease(v8);
              }
            }
          }
          if (v10) {
            CFRelease(v10);
          }
          if (v9) {
            CFRelease(v9);
          }
          CFRelease(Mutable);
        }
        CFRelease(theArray);
      }
      v27[12521] = 0;
    }
    else
    {
      v27[12521] = 1;
      double Current = CFAbsoluteTimeGetCurrent();
      if (*((void *)v27 + 1563))
      {
        if (v27[12521])
        {
          v27[12521] = CFXUpdateColorFade(*((void *)v27 + 1563), Current) & 1;
          if (v27[12521]) {
            __DisplayStartFade(v27, 1.0 / 60.0);
          }
        }
      }
    }
  }
}

unsigned char *__os_log_helper_16_0_0(unsigned char *result)
{
  *float result = 0;
  result[1] = 0;
  return result;
}

uint64_t __os_log_helper_16_0_2_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  return result;
}

void sub_1BA47BFA0()
{
  _Unwind_Resume(v0);
}

float mach_time_now_in_seconds()
{
  uint64_t v0 = mach_absolute_time();
  return mach_time_to_seconds(v0);
}

float mach_time_to_seconds(unint64_t a1)
{
  return mach_time_to_nanoseconds(a1) / 1000000000.0;
}

float mach_time_to_nanoseconds(unint64_t a1)
{
  if (mach_time_to_nanoseconds::token != -1) {
    dispatch_once(&mach_time_to_nanoseconds::token, &__block_literal_global_6);
  }
  return (float)a1 * *(float *)&mach_time_to_nanoseconds::machTimeBaseFactor;
}

uint64_t std::__math::isnan[abi:ne180100]()
{
  return 0;
}

float mach_time_now_in_milliseconds()
{
  uint64_t v0 = mach_absolute_time();
  return mach_time_to_milliseconds(v0);
}

float mach_time_to_milliseconds(unint64_t a1)
{
  return mach_time_to_nanoseconds(a1) / 1000000.0;
}

uint64_t __os_log_helper_16_2_8_8_0_8_0_8_0_8_0_8_0_8_0_8_32_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 8;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  *(unsigned char *)(result + 42) = 0;
  *(unsigned char *)(result + 43) = 8;
  *(void *)(result + 44) = a6;
  *(unsigned char *)(result + 52) = 0;
  *(unsigned char *)(result + 53) = 8;
  *(void *)(result + 54) = a7;
  *(unsigned char *)(result + 62) = 32;
  *(unsigned char *)(result + 63) = 8;
  *(void *)(result + 64) = a8;
  *(unsigned char *)(result + 72) = 0;
  *(unsigned char *)(result + 73) = 8;
  *(void *)(result + 74) = a9;
  return result;
}

uint64_t __os_log_helper_16_2_5_8_32_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1) = 5;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  *(unsigned char *)(result + 42) = 0;
  *(unsigned char *)(result + 43) = 8;
  *(void *)(result + 44) = a6;
  return result;
}

uint64_t __os_log_helper_16_2_22_8_0_8_0_8_0_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  uint64_t result = a13;
  *(unsigned char *)a1 = 2;
  *(unsigned char *)(a1 + 1) = 22;
  *(unsigned char *)(a1 + 2) = 0;
  *(unsigned char *)(a1 + 3) = 8;
  *(void *)(a1 + 4) = a2;
  *(unsigned char *)(a1 + 12) = 0;
  *(unsigned char *)(a1 + 13) = 8;
  *(void *)(a1 + 14) = a3;
  *(unsigned char *)(a1 + 22) = 0;
  *(unsigned char *)(a1 + 23) = 8;
  *(void *)(a1 + 24) = a4;
  *(unsigned char *)(a1 + 32) = 32;
  *(unsigned char *)(a1 + 33) = 8;
  *(void *)(a1 + 34) = a5;
  *(unsigned char *)(a1 + 42) = 0;
  *(unsigned char *)(a1 + 43) = 8;
  *(void *)(a1 + 44) = a6;
  *(unsigned char *)(a1 + 52) = 0;
  *(unsigned char *)(a1 + 53) = 8;
  *(void *)(a1 + 54) = a7;
  *(unsigned char *)(a1 + 62) = 0;
  *(unsigned char *)(a1 + 63) = 8;
  *(void *)(a1 + 64) = a8;
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 73) = 8;
  *(void *)(a1 + 74) = a9;
  *(unsigned char *)(a1 + 82) = 0;
  *(unsigned char *)(a1 + 83) = 8;
  *(void *)(a1 + 84) = a10;
  *(unsigned char *)(a1 + 92) = 0;
  *(unsigned char *)(a1 + 93) = 8;
  *(void *)(a1 + 94) = a11;
  *(unsigned char *)(a1 + 102) = 0;
  *(unsigned char *)(a1 + 103) = 8;
  *(void *)(a1 + 104) = a12;
  *(unsigned char *)(a1 + 112) = 32;
  *(unsigned char *)(a1 + 113) = 8;
  *(void *)(a1 + 114) = a13;
  *(unsigned char *)(a1 + 122) = 0;
  *(unsigned char *)(a1 + 123) = 8;
  *(void *)(a1 + 124) = a14;
  *(unsigned char *)(a1 + 132) = 32;
  *(unsigned char *)(a1 + 133) = 8;
  *(void *)(a1 + 134) = a15;
  *(unsigned char *)(a1 + 142) = 0;
  *(unsigned char *)(a1 + 143) = 8;
  *(void *)(a1 + 144) = a16;
  *(unsigned char *)(a1 + 152) = 32;
  *(unsigned char *)(a1 + 153) = 8;
  *(void *)(a1 + 154) = a17;
  *(unsigned char *)(a1 + 162) = 0;
  *(unsigned char *)(a1 + 163) = 8;
  *(void *)(a1 + 164) = a18;
  *(unsigned char *)(a1 + 172) = 0;
  *(unsigned char *)(a1 + 173) = 8;
  *(void *)(a1 + 174) = a19;
  *(unsigned char *)(a1 + 182) = 0;
  *(unsigned char *)(a1 + 183) = 8;
  *(void *)(a1 + 184) = a20;
  *(unsigned char *)(a1 + 192) = 0;
  *(unsigned char *)(a1 + 193) = 8;
  *(void *)(a1 + 194) = a21;
  *(unsigned char *)(a1 + 202) = 0;
  *(unsigned char *)(a1 + 203) = 8;
  *(void *)(a1 + 204) = a22;
  *(unsigned char *)(a1 + 212) = 0;
  *(unsigned char *)(a1 + 213) = 8;
  *(void *)(a1 + 214) = a23;
  return result;
}

uint64_t CBU_IsSecureIndicatorSupported()
{
  if (CBU_IsSecureIndicatorSupported_onceToken != -1) {
    dispatch_once(&CBU_IsSecureIndicatorSupported_onceToken, &__block_literal_global_66);
  }
  return CBU_IsSecureIndicatorSupported_supported & 1;
}

uint64_t ___ZN4AABC14enumerateALSesEU13block_pointerFvP20__IOHIDServiceClientPNS_3ALSEE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3) {
      return (*(uint64_t (**)(void))(*(void *)(result + 32) + 16))();
    }
  }
  return result;
}

void ___ZN4AABC20HandleDigitizerEventEP20__IOHIDServiceClientP12__IOHIDEvent_block_invoke(void *a1, uint64_t a2, id *a3)
{
  double v15 = a1;
  uint64_t v14 = a2;
  float v13 = a3;
  int v12 = a1;
  unsigned int v7 = (AABC *)a1[4];
  if (a3)
  {
    if (v13[3])
    {
      char v11 = 0;
      char v11 = [[CBHIDEvent alloc] initWithHIDEvent:a1[5] andService:a1[6]];
      [v13[3] filterEvent:v11];

      if ((AABC::ALS::isTouchObstructed(v13) & 1) != 0 && v13 == *((id **)v7 + 57))
      {
        if (*((float *)v7 + 154) < *((float *)v7 + 155))
        {
          CFNumberRef v10 = 0;
          if (_logHandle)
          {
            float v6 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t inited = init_default_corebrightness_log();
            }
            float v6 = inited;
          }
          CFNumberRef v10 = v6;
          os_log_type_t v9 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            log = v10;
            os_log_type_t type = v9;
            __os_log_helper_16_0_0(v8);
            _os_log_impl(&dword_1BA438000, log, type, "Cancel ramp, touch mitigation", v8, 2u);
          }
          AABC::CancelRamp(v7);
        }
        DisplayCancelRestrictionFactorFade(*((void *)v7 + 51), 1);
      }
    }
  }
}

CBDigitizerFilter *___ZN4AABC15registerServiceEP20__IOHIDServiceClient_block_invoke(CBDigitizerFilter *result, uint64_t a2, const AABC::ALS *a3)
{
  if (a3)
  {
    if (!*((void *)a3 + 3))
    {
      uint64_t result = AABC::newDigitizerFilterForALS((AABC *)result->super._notificationBlock, a3);
      *((void *)a3 + 3) = result;
    }
  }
  return result;
}

id getMLFeatureValueClass()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLFeatureValueClass_softClass;
  uint64_t v13 = getMLFeatureValueClass_softClass;
  if (!getMLFeatureValueClass_softClass)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLFeatureValueClass_block_invoke;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLFeatureValueClass_block_invoke((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLFeatureValueClass_0()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLFeatureValueClass_softClass_0;
  uint64_t v13 = getMLFeatureValueClass_softClass_0;
  if (!getMLFeatureValueClass_softClass_0)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLFeatureValueClass_block_invoke_0;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLFeatureValueClass_block_invoke_0((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLFeatureValueClass_1()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLFeatureValueClass_softClass_1;
  uint64_t v13 = getMLFeatureValueClass_softClass_1;
  if (!getMLFeatureValueClass_softClass_1)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLFeatureValueClass_block_invoke_1;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLFeatureValueClass_block_invoke_1((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLFeatureValueClass_2()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLFeatureValueClass_softClass_2;
  uint64_t v13 = getMLFeatureValueClass_softClass_2;
  if (!getMLFeatureValueClass_softClass_2)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLFeatureValueClass_block_invoke_2;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLFeatureValueClass_block_invoke_2((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLFeatureValueClass_3()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLFeatureValueClass_softClass_3;
  uint64_t v13 = getMLFeatureValueClass_softClass_3;
  if (!getMLFeatureValueClass_softClass_3)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLFeatureValueClass_block_invoke_3;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLFeatureValueClass_block_invoke_3((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

float clamp(float a1, float a2, float a3)
{
  if (a1 < a2) {
    return a2;
  }
  if (a1 <= a3) {
    return a1;
  }
  else {
    return a3;
  }
}

id getMLPredictionOptionsClass()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLPredictionOptionsClass_softClass;
  uint64_t v13 = getMLPredictionOptionsClass_softClass;
  if (!getMLPredictionOptionsClass_softClass)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLPredictionOptionsClass_block_invoke;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLPredictionOptionsClass_0()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLPredictionOptionsClass_softClass_0;
  uint64_t v13 = getMLPredictionOptionsClass_softClass_0;
  if (!getMLPredictionOptionsClass_softClass_0)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLPredictionOptionsClass_block_invoke_0;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke_0((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLPredictionOptionsClass_1()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLPredictionOptionsClass_softClass_1;
  uint64_t v13 = getMLPredictionOptionsClass_softClass_1;
  if (!getMLPredictionOptionsClass_softClass_1)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLPredictionOptionsClass_block_invoke_1;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke_1((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLPredictionOptionsClass_2()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLPredictionOptionsClass_softClass_2;
  uint64_t v13 = getMLPredictionOptionsClass_softClass_2;
  if (!getMLPredictionOptionsClass_softClass_2)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLPredictionOptionsClass_block_invoke_2;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke_2((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLPredictionOptionsClass_3()
{
  uint64_t v9 = 0;
  CFNumberRef v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLPredictionOptionsClass_softClass_3;
  uint64_t v13 = getMLPredictionOptionsClass_softClass_3;
  if (!getMLPredictionOptionsClass_softClass_3)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    unsigned int v5 = __getMLPredictionOptionsClass_block_invoke_3;
    float v6 = &unk_1E6219058;
    unsigned int v7 = &v9;
    __getMLPredictionOptionsClass_block_invoke_3((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

void __DisplayStartFastEDRRamp_block_invoke(uint64_t a1)
{
  if (*(double *)(a1 + 32) <= 0.0)
  {
    int v2 = *(_DWORD *)(*(void *)(a1 + 40) + 1328) | 1;
    *(_DWORD *)(*(void *)(a1 + 40) + 12624) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(void *)(a1 + 40) + 12628) = *(_DWORD *)(*(void *)(a1 + 40) + 12624);
    *(void *)(*(void *)(a1 + 40) + 12608) = 0;
    __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 40), v2 | 0x40, *(float *)(*(void *)(a1 + 40) + 1256));
  }
  else
  {
    *(void *)(*(void *)(a1 + 40) + 12608) = *(void *)(a1 + 32);
    *(_DWORD *)(*(void *)(a1 + 40) + 12624) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(void *)(a1 + 40) + 12632) = *(_DWORD *)(*(void *)(a1 + 40) + 12628);
    *(CFAbsoluteTime *)(*(void *)(a1 + 40) + 12616) = CFAbsoluteTimeGetCurrent();
    *(void *)(*(void *)(a1 + 40) + 12640) = 0;
    __DisplayStartFade(*(unsigned char **)(a1 + 40), 0.0083333);
  }
}

void __DisplaySetLogicalBrightnessInternal(const void *a1, int a2, float a3)
{
  uint64_t v206 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = a1;
  float v181 = a3;
  int v180 = a2;
  float v179 = 0.0;
  if ((a2 & 0x8000u) != 0)
  {
    *((_DWORD *)cf + 319) = *((_DWORD *)cf + 314);
    *((_DWORD *)cf + 374) = *((_DWORD *)cf + 372);
    *((_DWORD *)cf + 320) = *((_DWORD *)cf + 315);
    *((_DWORD *)cf + 3140) = *((_DWORD *)cf + 3138);
  }
  *((float *)cf + 3138) = v181;
  *((float *)cf + 314) = v181;
  if (!*((_DWORD *)cf + 10)) {
    *((float *)cf + 372) = v181;
  }
  if ((*((unsigned char *)cf + 12548) & 1) == 0)
  {
    if ((*((unsigned char *)cf + 1144) & 1) != 0 && *((float *)cf + 287) != 0.0) {
      float v181 = *((float *)cf + 287);
    }
    if (getClientOverrideState((uint64_t)cf, 0) && *((float *)cf + 241) != 0.0) {
      float v181 = *((float *)cf + 241);
    }
    float v178 = __DisplayLogicalToPhysicalBrightness((uint64_t)cf, v181);
    if (*((float *)cf + 87) == 1.0
      && *((float *)cf + 314) < *((float *)cf + 131)
      && *((float *)cf + 131) > *((float *)cf + 100)
      && *((float *)cf + 132) > *((float *)cf + 131))
    {
      double Current = CFAbsoluteTimeGetCurrent();
      double v176 = 0.0;
      float v3 = Current - *((double *)cf + 72) - *((double *)cf + 71);
      double v176 = fmaxf(v3, 0.0);
      if (v176 > 0.0)
      {
        *((void *)cf + 74) = 0;
        *((_DWORD *)cf + 132) = *((_DWORD *)cf + 131);
        float v175 = 0.0;
        float v175 = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)cf, *((float *)cf + 131));
        *((float *)cf + 153) = v175;
        *((float *)cf + 154) = v175;
        *((float *)cf + 152) = v175;
        os_log_t oslog = 0;
        if (_logHandle)
        {
          v77 = _logHandle;
        }
        else
        {
          uint64_t v76 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          v77 = v76;
        }
        os_log_t oslog = v77;
        os_log_type_t type = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v205, COERCE__INT64(*((float *)cf + 132)), COERCE__INT64(*((float *)cf + 314)));
          _os_log_debug_impl(&dword_1BA438000, oslog, type, "Display: Update weak cap to %f on low brightness %f", v205, 0x16u);
        }
      }
    }
    float v178 = fminf(v178, *((float *)cf + 132));
    float valuePtr = v178;
    if ((*((unsigned char *)cf + 1144) & 1) == 0)
    {
      int v75 = *((_DWORD *)cf + 160);
      if (v75 == 1)
      {
        if (*((float *)cf + 162) != 1.0)
        {
          float valuePtr = valuePtr * *((float *)cf + 162);
          os_log_t v171 = 0;
          if (_logHandle)
          {
            int v74 = _logHandle;
          }
          else
          {
            uint64_t v73 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            int v74 = v73;
          }
          os_log_t v171 = v74;
          os_log_type_t v170 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_8_0_8_0((uint64_t)v204, COERCE__INT64(*((float *)cf + 162)), COERCE__INT64(valuePtr));
            _os_log_debug_impl(&dword_1BA438000, v171, v170, "EcoModeFactor: %0.2f -> L_device: %f\n", v204, 0x16u);
          }
        }
      }
      else if (v75 == 2)
      {
        float v169 = 0.0;
        float v169 = *((float *)cf + 195);
        if ((*((_DWORD *)cf + 55) || *((double *)cf + 98) != 0.0) && valuePtr > v169)
        {
          os_log_t v168 = 0;
          if (_logHandle)
          {
            uint64_t v72 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t inited = init_default_corebrightness_log();
            }
            uint64_t v72 = inited;
          }
          os_log_t v168 = v72;
          os_log_type_t v167 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_8_0_8_0((uint64_t)v203, COERCE__INT64(v169), COERCE__INT64(valuePtr));
            _os_log_debug_impl(&dword_1BA438000, v168, v167, "EcoModeLimit: %f -> L_device: %f\n", v203, 0x16u);
          }
          float valuePtr = v169;
        }
      }
    }
    if (*((void *)cf + 41))
    {
      if ([*((id *)cf + 41) isActive])
      {
        float valuePtr = valuePtr * *(float *)([*((id *)cf + 41) fade] + 20);
        if (*(float *)([*((id *)cf + 41) fade] + 20) != 1.0)
        {
          os_log_t v166 = 0;
          if (_logHandle)
          {
            uint64_t v70 = _logHandle;
          }
          else
          {
            uint64_t v69 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            uint64_t v70 = v69;
          }
          os_log_t v166 = v70;
          os_log_type_t v165 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_8_0_8_0((uint64_t)v202, COERCE__INT64(*(float *)([*((id *)cf + 41) fade] + 20)), COERCE__INT64(valuePtr));
            _os_log_debug_impl(&dword_1BA438000, v166, v165, "SoftWakeFactor: %0.2f -> L_device: %f", v202, 0x16u);
          }
        }
      }
    }
    float v164 = 0.0;
    float v164 = *((float *)cf + 244);
    float v163 = 0.0;
    float v163 = *((float *)cf + 245);
    if ((*((unsigned char *)cf + 1144) & 1) == 0)
    {
      if (v164 == v163 || (*((unsigned char *)cf + 1048) & 1) != 0 || (*((unsigned char *)cf + 1120) & 1) != 0)
      {
        if (valuePtr > v164 || valuePtr == 0.0)
        {
          if (valuePtr > v164 && (*((unsigned char *)cf + 1120) & 1) == 0)
          {
            float v151 = 0.0;
            float v151 = (float)(v164 - (float)(*((float *)cf + 264) * *((float *)cf + 328)))
                 / (float)(v164 - *((float *)cf + 328));
            float valuePtr = v164 - (float)(v151 * (float)(v164 - valuePtr));
            os_log_t v150 = 0;
            if (_logHandle)
            {
              uint64_t v62 = _logHandle;
            }
            else
            {
              uint64_t v61 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              uint64_t v62 = v61;
            }
            os_log_t v150 = v62;
            os_log_type_t v149 = OS_LOG_TYPE_DEBUG;
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v198, COERCE__INT64(v151), COERCE__INT64(valuePtr), COERCE__INT64(*((float *)cf + 264)));
              _os_log_debug_impl(&dword_1BA438000, v150, v149, "Min scaler: %f  %f %f", v198, 0x20u);
            }
          }
        }
        else if ((*((unsigned char *)cf + 1048) & 1) == 0)
        {
          float v154 = 0.0;
          float v154 = (float)(v164 - (float)(*((float *)cf + 246) * *((float *)cf + 330)))
               / (float)(v164 - *((float *)cf + 330));
          float valuePtr = v164 - (float)(v154 * (float)(v164 - valuePtr));
          os_log_t v153 = 0;
          if (_logHandle)
          {
            uint64_t v64 = _logHandle;
          }
          else
          {
            uint64_t v63 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            uint64_t v64 = v63;
          }
          os_log_t v153 = v64;
          os_log_type_t v152 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v199, COERCE__INT64(v154), COERCE__INT64(valuePtr), COERCE__INT64(*((float *)cf + 246)));
            _os_log_debug_impl(&dword_1BA438000, v153, v152, "Min scaler: %f  %f %f", v199, 0x20u);
          }
        }
      }
      else if (valuePtr > 0.0)
      {
        float v162 = valuePtr;
        float v161 = 0.0;
        if (valuePtr > v163)
        {
          float v161 = (float)(v163 - (float)(*((float *)cf + 264) * *((float *)cf + 328)))
               / (float)(v163 - *((float *)cf + 328));
          float v162 = v163 - (float)(v161 * (float)(v163 - valuePtr));
        }
        if (v162 <= v164)
        {
          float v158 = 0.0;
          float v157 = 0.0;
          float v157 = (float)(v164 - (float)(*((float *)cf + 246) * *((float *)cf + 330)))
               / (float)(v164 - *((float *)cf + 330));
          float v158 = v164 - (float)(v157 * (float)(v164 - v162));
          os_log_t v156 = 0;
          if (_logHandle)
          {
            os_log_t v66 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v65 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v65 = init_default_corebrightness_log();
            }
            os_log_t v66 = v65;
          }
          os_log_t v156 = v66;
          os_log_type_t v155 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v200, COERCE__INT64(valuePtr), COERCE__INT64(v158), COERCE__INT64(v157), COERCE__INT64(*((float *)cf + 246)));
            _os_log_debug_impl(&dword_1BA438000, v156, v155, "Pivoting - LEFT restriction: L_device %f -> %f, ScalerMin = %f, Fmin = %f", v200, 0x2Au);
          }
          float valuePtr = v158;
        }
        else
        {
          os_log_t v160 = 0;
          if (_logHandle)
          {
            uint64_t v68 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v67 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v67 = init_default_corebrightness_log();
            }
            uint64_t v68 = v67;
          }
          os_log_t v160 = v68;
          os_log_type_t v159 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v201, COERCE__INT64(valuePtr), COERCE__INT64(v162), COERCE__INT64(v161), COERCE__INT64(*((float *)cf + 264)));
            _os_log_debug_impl(&dword_1BA438000, v160, v159, "Pivoting - RIGHT restriction: L_device %f -> %f, ScalerMax = %f, Fmax = %f", v201, 0x2Au);
          }
          float valuePtr = v162;
        }
      }
    }
    if (valuePtr > 0.0)
    {
      if (!*((_DWORD *)cf + 57) && *((double *)cf + 105) != 0.0) {
        *((float *)cf + 214) = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)cf, valuePtr);
      }
      if (*((_DWORD *)cf + 57) || *((double *)cf + 105) != 0.0) {
        float valuePtr = fminf(valuePtr, *((float *)cf + 208));
      }
    }
    float v148 = 0.0;
    float v148 = *((float *)cf + 328);
    if ((*((unsigned char *)cf + 1120) & 1) == 0) {
      float v148 = v148 * *((float *)cf + 264);
    }
    float v148 = fminf(fminf(v148, *((float *)cf + 116)), *((float *)cf + 132));
    if (*((float *)cf + 285) < 1.0) {
      float v148 = *((float *)cf + 330) + (float)(*((float *)cf + 285) * (float)(v148 - *((float *)cf + 330)));
    }
    if (!getClientOverrideState((uint64_t)cf, 0))
    {
      float valuePtr = valuePtr * *((float *)cf + 3236);
      float v148 = v148 * *((float *)cf + 3236);
    }
    float v147 = 0.0;
    float v147 = *((float *)cf + 181);
    if ((*((_DWORD *)cf + 56) || *((double *)cf + 91) != 0.0) && valuePtr > v147)
    {
      os_log_t v146 = 0;
      if (_logHandle)
      {
        v60 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v59 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v59 = init_default_corebrightness_log();
        }
        v60 = v59;
      }
      os_log_t v146 = v60;
      os_log_type_t v145 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v197, COERCE__INT64(v147), COERCE__INT64(valuePtr));
        _os_log_debug_impl(&dword_1BA438000, v146, v145, "Domino ModeLimit: %f -> L_device: %f\n", v197, 0x16u);
      }
      float valuePtr = v147;
      float v148 = fminf(v148, v147);
    }
    int v144 = (int)(v148 * 65536.0);
    float v179 = _DisplayComputeEDRNitsCap((uint64_t)cf);
    int v143 = (int)(v179 * 65536.0);
    os_log_t v142 = 0;
    if (_logHandle)
    {
      float v58 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v57 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v57 = init_default_corebrightness_log();
      }
      float v58 = v57;
    }
    os_log_t v142 = v58;
    os_log_type_t v141 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
    {
      if (*((unsigned char *)cf + 1120)) {
        float v56 = 0.0;
      }
      else {
        float v56 = *((float *)cf + 264);
      }
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v196, COERCE__INT64(*((float *)cf + 116)), COERCE__INT64(*((float *)cf + 132)), COERCE__INT64(*((float *)cf + 285)), COERCE__INT64(v56), COERCE__INT64(v179));
      _os_log_debug_impl(&dword_1BA438000, v142, v141, "SetLogicalBrightnessInternal caps: cltm %f,  weakcap: %f, gl.scalar: %f, dyn.sl: %f, edrcap: %f", v196, 0x34u);
    }
    os_log_t v140 = 0;
    if (_logHandle)
    {
      float v55 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v54 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v54 = init_default_corebrightness_log();
      }
      float v55 = v54;
    }
    os_log_t v140 = v55;
    os_log_type_t v139 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v195, COERCE__INT64(v148), COERCE__INT64(v179));
      _os_log_debug_impl(&dword_1BA438000, v140, v139, "Caps after global scaling: nitsCap=%f nitsCapEDR=%f", v195, 0x16u);
    }
    float v138 = 0.0;
    float v138 = (float)*((int *)cf + 283) / 65536.0;
    if (*((_DWORD *)cf + 3150) == 2)
    {
      os_log_t v137 = 0;
      if (_logHandle)
      {
        char v53 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v52 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v52 = init_default_corebrightness_log();
        }
        char v53 = v52;
      }
      os_log_t v137 = v53;
      os_log_type_t v136 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v194, COERCE__INT64(v138), COERCE__INT64(v179));
        _os_log_debug_impl(&dword_1BA438000, v137, v136, "SLBI EDR_ENABLED current=%f, calculated=%f", v194, 0x16u);
      }
    }
    else if (*((_DWORD *)cf + 3150) == 1)
    {
      os_log_t v135 = 0;
      if (_logHandle)
      {
        float v51 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v50 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v50 = init_default_corebrightness_log();
        }
        float v51 = v50;
      }
      os_log_t v135 = v51;
      os_log_type_t v134 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v193, COERCE__INT64(v138), COERCE__INT64(v179));
        _os_log_debug_impl(&dword_1BA438000, v135, v134, "SLBI EDR_DISABLED_RAMP_PENDING current=%f, calculated=%f", v193, 0x16u);
      }
    }
    else
    {
      os_log_t v133 = 0;
      if (_logHandle)
      {
        float v49 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v48 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v48 = init_default_corebrightness_log();
        }
        float v49 = v48;
      }
      os_log_t v133 = v49;
      os_log_type_t v132 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v192, COERCE__INT64(v138), COERCE__INT64(v179));
        _os_log_debug_impl(&dword_1BA438000, v133, v132, "SLBI other current=%f, calculated=%f", v192, 0x16u);
      }
    }
    if (*((_DWORD *)cf + 3150) == 2 || *((_DWORD *)cf + 3150) == 1)
    {
      if (v143 != *((_DWORD *)cf + 283))
      {
        os_log_t v131 = 0;
        if (_logHandle)
        {
          float v47 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v46 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v46 = init_default_corebrightness_log();
          }
          float v47 = v46;
        }
        os_log_t v131 = v47;
        os_log_type_t v130 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v191, COERCE__INT64((float)((float)v143 / 65536.0)));
          _os_log_debug_impl(&dword_1BA438000, v131, v130, "SetBLDriverNitsCap for EDR_ENABLED | EDR_DISABLED_RAMP_PENDING in setlogicalbrightnessinternal to %f", v191, 0xCu);
        }
        if ((*((unsigned char *)cf + 1517) & 1) == 0) {
          SetBLDriverNitsCapIfNotInLPM((uint64_t)cf, v143);
        }
        *((_DWORD *)cf + 283) = v143;
      }
      if (v144 != *((_DWORD *)cf + 282)) {
        *((_DWORD *)cf + 282) = v144;
      }
    }
    else if (v144 != *((_DWORD *)cf + 282))
    {
      os_log_t v129 = 0;
      if (_logHandle)
      {
        float v45 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v44 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v44 = init_default_corebrightness_log();
        }
        float v45 = v44;
      }
      os_log_t v129 = v45;
      os_log_type_t v128 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v190, COERCE__INT64(v148));
        _os_log_debug_impl(&dword_1BA438000, v129, v128, "Changing nitsCap to %f\n", v190, 0xCu);
      }
      os_log_t v127 = 0;
      if (_logHandle)
      {
        float v43 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v42 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v42 = init_default_corebrightness_log();
        }
        float v43 = v42;
      }
      os_log_t v127 = v43;
      os_log_type_t v126 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
      {
        os_log_t v40 = v127;
        os_log_type_t v41 = v126;
        __os_log_helper_16_0_0(v125);
        _os_log_debug_impl(&dword_1BA438000, v40, v41, "SetBLDriverNitsCap for !EDR_ENABLED in setlogicalbrightnessinternal", v125, 2u);
      }
      SetBLDriverNitsCapIfNotInLPM((uint64_t)cf, v144);
      *((_DWORD *)cf + 282) = v144;
    }
    if (*((float *)cf + 87) > 0.0)
    {
      if (_DisplayCLTMRev2Applicable((uint64_t)cf))
      {
        if (*((_DWORD *)cf + 389) == 1 && *((float *)cf + 388) == 0.0 && *((float *)cf + 123) == 0.0)
        {
          float valuePtr = 0.0;
        }
        else
        {
          float valuePtr = fminf(valuePtr, *((float *)cf + 116));
          float valuePtr = fmaxf(valuePtr, *((float *)cf + 100));
          float valuePtr = fmaxf(valuePtr, *((float *)cf + 330));
          float valuePtr = fminf(valuePtr, *((float *)cf + 328));
        }
      }
      else
      {
        float valuePtr = fmaxf(valuePtr, *((float *)cf + 100));
        if (float_equal(*((float *)cf + 3236), 1.0) || *((float *)cf + 116) < *((float *)cf + 3254)) {
          float valuePtr = fminf(valuePtr, *((float *)cf + 116));
        }
        if (*((float *)cf + 285) < 1.0)
        {
          float valuePtr = *((float *)cf + 330) + (float)(*((float *)cf + 285) * (float)(valuePtr - *((float *)cf + 330)));
          os_log_t v124 = 0;
          if (_logHandle)
          {
            os_log_type_t v39 = _logHandle;
          }
          else
          {
            uint64_t v38 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            os_log_type_t v39 = v38;
          }
          os_log_t v124 = v39;
          os_log_type_t v123 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_1_8_0((uint64_t)v189, COERCE__INT64(valuePtr));
            _os_log_debug_impl(&dword_1BA438000, v124, v123, "Brightness after global scaling: %f", v189, 0xCu);
          }
        }
        if ([+[CBAODState sharedInstance] isAODActive])
        {
          float valuePtr = fmaxf(valuePtr, *((float *)cf + 385));
        }
        else
        {
          float valuePtr = fmaxf(valuePtr, *((float *)cf + 330));
        }
        if (float_equal(*((float *)cf + 3236), 1.0))
        {
          float valuePtr = fminf(valuePtr, *((float *)cf + 328));
          float valuePtr = fminf(valuePtr, *((float *)cf + 132));
        }
        else
        {
          float valuePtr = fminf(valuePtr, *((float *)cf + 386));
        }
      }
    }
    if ((*((unsigned char *)cf + 972) & 1) != 0
      && valuePtr != 0.0
      && (*((unsigned char *)cf + 1284) & 1) == 0
      && (v180 & 0x100) == 0
      && (v180 & 0x8000u) == 0
      && (v180 & 0x1000) == 0
      && ((*((unsigned char *)cf + 321) & 1) == 0 || (v180 & 0x40) == 0)
      && vabds_f32(*((float *)cf + 317), valuePtr) <= 0.003 * *((float *)cf + 317)
      && (*((unsigned char *)cf + 12712) & 1) == 0)
    {
      os_log_t v122 = 0;
      if (_logHandle)
      {
        uint64_t v37 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v36 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v36 = init_default_corebrightness_log();
        }
        uint64_t v37 = v36;
      }
      os_log_t v122 = v37;
      os_log_type_t v121 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v188, COERCE__INT64(*((float *)cf + 317)), COERCE__INT64(valuePtr));
        _os_log_debug_impl(&dword_1BA438000, v122, v121, "Skip processing of backlight update - L = %f -> %f", v188, 0x16u);
      }
      if ((*((unsigned char *)cf + 321) & 1) == 0
        && (CBU_ForceUpdateFrequencyAndFrameSkip() & 1) != 0
        && !*((_DWORD *)cf + 3150))
      {
        *((_DWORD *)cf + 317) = 0;
      }
      return;
    }
    if ((v180 & 0x8000u) == 0) {
      *((float *)cf + 317) = valuePtr;
    }
    os_log_t v120 = 0;
    if (_logHandle)
    {
      uint64_t v35 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v34 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v34 = init_default_corebrightness_log();
      }
      uint64_t v35 = v34;
    }
    os_log_t v120 = v35;
    os_log_type_t v119 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v187, COERCE__INT64(*((float *)cf + 87)), COERCE__INT64(*((float *)cf + 314)), COERCE__INT64(*((float *)cf + 116)), COERCE__INT64(*((float *)cf + 100)), COERCE__INT64(*((float *)cf + 328)), COERCE__INT64(*((float *)cf + 330)), COERCE__INT64(valuePtr));
      _os_log_debug_impl(&dword_1BA438000, v120, v119, "Factor=%f Lcurrent=%f maxRestriction=%f minRestriction=%f maxPanel=%f minPanel=%f L_device=%f", v187, 0x48u);
    }
    if ((v180 & 0x8000u) != 0) {
      float valuePtr = *((float *)cf + 3138);
    }
    int v118 = (int)(float)(valuePtr * 65536.0);
    *((float *)cf + 315) = valuePtr;
    if ((v180 & 0x8000u) == 0)
    {
      uint64_t v117 = 0;
      HIDWORD(v117) = *((_DWORD *)cf + 315);
      LODWORD(v117) = 1;
      __DisplayUpdateAAPStateInternal((uint64_t)cf, (uint64_t)&v117, 0);
    }
    value = 0;
    if ((v180 & 0x2000) != 0)
    {
      float v115 = 0.0;
      float v115 = __DisplayLogicalToPhysicalBrightness((uint64_t)cf, *((float *)cf + 318));
      if (*((float *)cf + 162) != 1.0)
      {
        float v115 = v115 * *((float *)cf + 162);
        os_log_t v114 = 0;
        if (_logHandle)
        {
          uint64_t v33 = _logHandle;
        }
        else
        {
          uint64_t v32 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          uint64_t v33 = v32;
        }
        os_log_t v114 = v33;
        os_log_type_t v113 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v186, COERCE__INT64(*((float *)cf + 162)), COERCE__INT64(v115));
          _os_log_debug_impl(&dword_1BA438000, v114, v113, "EcoModeFactor: %0.2f -> L_physicalVirtual: %f\n", v186, 0x16u);
        }
      }
      if (*((float *)cf + 87) > 0.0) {
        float v115 = fminf(fmaxf(fminf(fminf(fmaxf(v115, *((float *)cf + 100)), *((float *)cf + 116)), *((float *)cf + 132)), *((float *)cf + 330)), *((float *)cf + 328));
      }
      int v112 = (int)(float)(v115 * 65536.0);
      CFTypeRef v29 = cf;
      float v4 = DisplayNits2milliAmps((uint64_t)cf, v112);
      float v111 = DisplayMilliAmpsToMilliWatts((uint64_t)v29, v4);
      CFTypeRef v30 = cf;
      float v5 = DisplayNits2milliAmps((uint64_t)cf, v118);
      float v110 = DisplayMilliAmpsToMilliWatts((uint64_t)v30, v5);
      char v109 = 0;
      char v31 = 0;
      if (*((_DWORD *)cf + 3179) == 1) {
        char v31 = *((unsigned char *)cf + 12181) ^ 1;
      }
      char v109 = v31 & 1;
      if (*((unsigned char *)cf + 12181))
      {
        unsigned int APLColumnOrDefault = 100;
        if (*((_DWORD *)cf + 3179) == 1) {
          unsigned int APLColumnOrDefault = 50;
        }
        unsigned int APLColumnOrDefault = DisplayGetAPLColumnOrDefault((uint64_t)cf, APLColumnOrDefault);
        float v111 = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)cf, APLColumnOrDefault, v115);
        float v110 = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)cf, APLColumnOrDefault, valuePtr);
      }
      os_log_t v107 = 0;
      if (_logHandle)
      {
        char v28 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v27 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v27 = init_default_corebrightness_log();
        }
        char v28 = v27;
      }
      os_log_t v107 = v28;
      os_log_type_t v106 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v185, COERCE__INT64(v115), COERCE__INT64(valuePtr));
        _os_log_debug_impl(&dword_1BA438000, v107, v106, "PowerNitsAB = %f, PowerNitsReal = %f", v185, 0x16u);
      }
      CFAllocatorRef v6 = CFGetAllocator(cf);
      if (v109) {
        value = CFNumberCreate(v6, kCFNumberFloatType, &valuePtr);
      }
      else {
        value = CFNumberCreate(v6, kCFNumberFloatType, &v110);
      }
      if (value)
      {
        CFTypeRef v105 = 0;
        CFAllocatorRef v7 = CFGetAllocator(cf);
        if (v109) {
          CFTypeRef v105 = CFNumberCreate(v7, kCFNumberFloatType, &v115);
        }
        else {
          CFTypeRef v105 = CFNumberCreate(v7, kCFNumberFloatType, &v111);
        }
        if (v105)
        {
          CFMutableDictionaryRef theDict = 0;
          CFMutableDictionaryRef theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (theDict)
          {
            if (v109)
            {
              CFDictionaryAddValue(theDict, @"BacklightPowerNitsRealSub", value);
              CFDictionaryAddValue(theDict, @"BacklightPowerNitsABSub", v105);
            }
            else
            {
              CFDictionaryAddValue(theDict, @"BacklightPowerMilliWattsRealSub", value);
              CFDictionaryAddValue(theDict, @"BacklightPowerMilliWattsABSub", v105);
            }
            if (*((void *)cf + 18))
            {
              uint64_t v8 = *((void *)cf + 18);
              uint64_t block = MEMORY[0x1E4F143A8];
              int v97 = -1073741824;
              int v98 = 0;
              int v99 = ____DisplaySetLogicalBrightnessInternal_block_invoke;
              uint64_t v100 = &__block_descriptor_49_e5_v8__0l;
              CFTypeRef v101 = cf;
              char v103 = v109 & 1;
              CFMutableDictionaryRef v102 = theDict;
              dispatch_async(v8, &block);
            }
            else
            {
              CFRelease(theDict);
            }
          }
          CFRelease(v105);
        }
        CFRelease(value);
      }
      if (*((void *)cf + 1563)) {
        CFXUpdateCompensatedBacklight(*((void *)cf + 1563), valuePtr);
      }
    }
    char v95 = 0;
    if ((v180 & 0x4000) == 0)
    {
      if (*((_DWORD *)cf + 3149) == 1 && (v180 & 0x8000u) == 0)
      {
        if (*((_DWORD *)cf + 3150) == 2 || *((_DWORD *)cf + 3150) == 1)
        {
          os_log_t v94 = 0;
          if (_logHandle)
          {
            uint64_t v26 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v25 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v25 = init_default_corebrightness_log();
            }
            uint64_t v26 = v25;
          }
          os_log_t v94 = v26;
          os_log_type_t v93 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_4_8_0_8_0_4_0_8_0((uint64_t)v184, COERCE__INT64(valuePtr), COERCE__INT64(v179), *((_DWORD *)cf + 3150), COERCE__INT64(*((float *)cf + 298)));
            _os_log_debug_impl(&dword_1BA438000, v94, v93, "EDR SetDisplayBrightness - physicalBrightness:%f, maxLum: %f, edrState: %d, lux: %f\n", v184, 0x26u);
          }
          SetLibEDRBrightness((uint64_t)cf, valuePtr, v179, *((float *)cf + 298), *((float *)cf + 3132));
          int v92 = (int)(float)(_DisplayLogicalToSliderBrightnessInternal((uint64_t)cf, valuePtr) * 65536.0);
          if (!v92) {
            int v92 = valuePtr > 0.0;
          }
          CFAllocatorRef v9 = CFGetAllocator(cf);
          CFTypeRef v91 = CFNumberCreate(v9, kCFNumberSInt32Type, &v92);
          if (v91)
          {
            __DisplaySetBLDriverProperty((uint64_t)cf, @"DisplayBrightnessSliderPosition", v91);
            CFRelease(v91);
          }
          CFTypeRef v24 = cf;
          float v10 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v178);
          float v90 = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v24, v10);
          float v11 = (float)*((int *)cf + 312) / 65536.0;
          __DisplayUpdateSlider((float *)cf, v90, v178, v11);
          *((float *)cf + 375) = valuePtr;
          return;
        }
        os_log_t v89 = 0;
        if (_logHandle)
        {
          float v23 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v22 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v22 = init_default_corebrightness_log();
          }
          float v23 = v22;
        }
        os_log_t v89 = v23;
        os_log_type_t v88 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_4_8_0_8_0_4_0_8_0((uint64_t)v183, COERCE__INT64(valuePtr), COERCE__INT64(v179), *((_DWORD *)cf + 3150), COERCE__INT64(*((float *)cf + 298)));
          _os_log_debug_impl(&dword_1BA438000, v89, v88, "EDR SetDisplayBrightness - physicalBrightness:%f, maxLum: %f, edrState: %d, lux: %f\n", v183, 0x26u);
        }
        SetLibEDRBrightness((uint64_t)cf, valuePtr, v179, *((float *)cf + 298), *((float *)cf + 3132));
        *((float *)cf + 375) = valuePtr;
      }
      if (*((_DWORD *)cf + 71))
      {
        if (*((unsigned char *)cf + 288))
        {
          BOOL v87 = 0;
          BOOL v87 = valuePtr > (float)*((unsigned int *)cf + 71);
          if ((*((unsigned char *)cf + 289) & 1) != v87) {
            __DisplaySendPLCUpdate((uint64_t)cf, v87);
          }
        }
      }
      if (v118 != *((_DWORD *)cf + 312) || (*((unsigned char *)cf + 1284) & 1) != 0 || (*((unsigned char *)cf + 12712) & 1) != 0)
      {
        *((_DWORD *)cf + 312) = v118;
        unsigned int v86 = DisplayGetAPLColumnOrDefault((uint64_t)cf, 0x64u);
        float v85 = 0.0;
        float v12 = (double)*((int *)cf + 312) / 65536.0;
        float v85 = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)cf, v86, v12);
        CFTypeRef v84 = 0;
        CFTypeRef v84 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v85);
        if (v84)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), @"CPMSCurrentPower", v84);
          CFRelease(v84);
        }
        SetBLDriverNitsValueIfNotInLPM((uint64_t)cf, *((_DWORD *)cf + 312));
        char v95 = 1;
        if (*((_DWORD *)cf + 3149) == 1 && (v180 & 0x8000u) != 0)
        {
          float v83 = 0.0;
          float v83 = __DisplayLogicalToPhysicalBrightness((uint64_t)cf, *((float *)cf + 319));
          float v83 = fminf(v83, *((float *)cf + 132));
          CFTypeRef v21 = cf;
          float v13 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v83);
          float v82 = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v21, v13);
          float v14 = (float)*((int *)cf + 312) / 65536.0;
          __DisplayUpdateSlider((float *)cf, v82, v83, v14);
        }
      }
      if ((v180 & 0x8000u) != 0)
      {
        *((_DWORD *)cf + 314) = *((_DWORD *)cf + 319);
        *((_DWORD *)cf + 372) = *((_DWORD *)cf + 374);
        *((_DWORD *)cf + 315) = *((_DWORD *)cf + 320);
        *((_DWORD *)cf + 3138) = *((_DWORD *)cf + 3140);
      }
    }
    if ((*((unsigned char *)cf + 232) & 1) == 0 && (v95 & 1) == 0 && ((v180 & 0x40) != 0 || (v180 & 0x100) != 0)) {
      SendSyncDBVNotification((uint64_t)cf, 0, valuePtr);
    }
    if ((v180 & 0x1000) != 0)
    {
      int v81 = (int)(float)(_DisplayLogicalToSliderBrightnessInternal((uint64_t)cf, valuePtr) * 65536.0);
      if (!v81) {
        int v81 = valuePtr > 0.0;
      }
      CFAllocatorRef v15 = CFGetAllocator(cf);
      CFNumberRef v80 = CFNumberCreate(v15, kCFNumberSInt32Type, &v81);
      if (v80)
      {
        __DisplaySetBLDriverProperty((uint64_t)cf, @"DisplayBrightnessSliderPosition", v80);
        CFRelease(v80);
      }
    }
    if ((v180 & 8) != 0 || _DisplayCLTMRev2Applicable((uint64_t)cf) && *((_DWORD *)cf + 390))
    {
      CFTypeRef v20 = cf;
      float v16 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v178);
      float v79 = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v20, v16);
      __DisplayUpdateSlider((float *)cf, v79, v178, valuePtr);
    }
    if (_DisplaySendNotificationForEDRHeadroom((uint64_t)cf, v180))
    {
      CFTypeRef v19 = cf;
      float v17 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v178);
      float v78 = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v19, v17);
      float v18 = (float)*((int *)cf + 312) / 65536.0;
      __DisplayUpdateSlider((float *)cf, v78, v178, v18);
    }
  }
}

void SendSyncDBVNotification(uint64_t a1, char a2, float a3)
{
  uint64_t v14 = a1;
  float v13 = a3;
  char v12 = a2 & 1;
  if (*(unsigned char *)(a1 + 321))
  {
    if (*(unsigned char *)(v14 + 232) & 1) == 0 || (v12)
    {
      float v3 = *(NSObject **)(v14 + 120);
      float v4 = (void (*)(void))MEMORY[0x1E4F143A8];
      int v5 = -1073741824;
      int v6 = 0;
      CFAllocatorRef v7 = __SendSyncDBVNotification_block_invoke;
      uint64_t v8 = &__block_descriptor_45_e5_v8__0l;
      uint64_t v9 = v14;
      float v10 = v13;
      char v11 = v12 & 1;
      disp_dispatch_async(v3, &v4);
    }
    else
    {
      *(_DWORD *)(v14 + 236) = (int)(float)(v13 * 65536.0);
    }
  }
}

void disp_dispatch_async(NSObject *a1, void (**a2)(void))
{
  if (a1) {
    dispatch_async(a1, a2);
  }
  else {
    a2[2]();
  }
}

float __DisplayLogicalToPhysicalBrightness(uint64_t a1, float a2)
{
  float v5 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2) * *(float *)(a1 + 348);
  float v4 = 0.0;
  if (*(float *)(a1 + 348) > 0.0)
  {
    if (*(float *)(a1 + 348) < 1.0) {
      return _DisplayPerceptualLuminanceToLuminanceInternal(a1, v5);
    }
    else {
      return a2;
    }
  }
  return v4;
}

uint64_t __DisplayLuminanceToPerceptualLuminance_block_invoke(uint64_t a1)
{
  float v1 = _DisplayLuminanceToPerceptualLuminanceInternal(*(void *)(a1 + 40), *(float *)(a1 + 48));
  uint64_t result = a1;
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v1;
  return result;
}

float _DisplayLuminanceToPerceptualLuminanceInternal(uint64_t a1, float a2)
{
  float v4 = fminf(fmaxf(a2, *(float *)(a1 + 1320)), *(float *)(a1 + 1312));
  float v3 = logf(*(float *)(a1 + 1312) / *(float *)(a1 + 1320));
  return (float)(logf(v4 / *(float *)(a1 + 1312)) / v3) + 1.0;
}

float _DisplayLogicalToSliderBrightnessInternal(uint64_t a1, float a2)
{
  float v7 = 0.0;
  if (a2 > 0.0)
  {
    float v6 = a2;
    if (a2 < *(float *)(a1 + 1316))
    {
      if (**(float **)(a1 + 72) <= *(float *)(a1 + 1320)) {
        float v6 = __interpolate(*(float *)(a1 + 1320), *(float *)(a1 + 1308), *(float *)(a1 + 1316), *(float *)(a1 + 1304), a2);
      }
    }
    else
    {
      float v6 = __interpolate(*(float *)(a1 + 1316), *(float *)(a1 + 1304), *(float *)(a1 + 1312), *(float *)(a1 + 1300), a2);
    }
    int v5 = 0;
    unsigned int v4 = *(_DWORD *)(a1 + 64);
    while (v4)
    {
      unsigned int v3 = v4 / 2 + v5;
      if (v3 == *(_DWORD *)(a1 + 64) - 1) {
        return fmaxf(*(float *)(a1 + 344), *(float *)(a1 + 340));
      }
      if (v6 >= *(float *)(*(void *)(a1 + 72) + 4 * v3) && v6 < *(float *)(*(void *)(a1 + 72) + 4 * (v3 + 1))) {
        return fmaxf((float)((float)v3 / (float)((float)*(unsigned int *)(a1 + 64) - 1.0))+ (float)((float)((float)(v6 - *(float *)(*(void *)(a1 + 72) + 4 * v3))/ (float)(*(float *)(*(void *)(a1 + 72) + 4 * (v3 + 1))- *(float *)(*(void *)(a1 + 72) + 4 * v3)))* (float)(1.0 / (float)(*(_DWORD *)(a1 + 64) - 1))), *(float *)(a1 + 340));
      }
      if (v6 <= *(float *)(*(void *)(a1 + 72) + 4 * v3))
      {
        v4 /= 2u;
      }
      else
      {
        v5 += v4 / 2 + 1;
        unsigned int v4 = (v4 - 1) / 2;
      }
      if (!v3) {
        return fmaxf(*(float *)(a1 + 340), *(float *)(a1 + 340));
      }
    }
    return fmaxf(0.0, *(float *)(a1 + 340));
  }
  return v7;
}

float __interpolate(float a1, float a2, float a3, float a4, float a5)
{
  return a2 + (float)((float)((float)(a4 - a2) / (float)(a3 - a1)) * (float)(a5 - a1));
}

BOOL getClientOverrideState(uint64_t a1, char a2)
{
  return (*(unsigned __int8 *)(a1 + 960) & (1 << a2)) != 0;
}

float __DisplayPhysicalToLogicalBrightness(uint64_t a1, float a2)
{
  float v4 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
  float v3 = 0.0;
  if (*(float *)(a1 + 348) > 0.0)
  {
    if (*(float *)(a1 + 348) < 1.0) {
      return _DisplayPerceptualLuminanceToLuminanceInternal(a1, v4 / *(float *)(a1 + 348));
    }
    else {
      return a2;
    }
  }
  return v3;
}

BOOL _DisplaySendNotificationForEDRHeadroom(uint64_t a1, __int16 a2)
{
  return (a2 & 8) == 0 && (a2 & 0x4000) != 0 && (a2 & 0x40) != 0;
}

BOOL _DisplayCLTMRev2Applicable(uint64_t a1)
{
  BOOL v2 = 0;
  if (a1) {
    return (*(unsigned char *)(a1 + 312) & 1) != 0;
  }
  return v2;
}

uint64_t __os_log_helper_16_2_4_8_32_8_0_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 4;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 32;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  return result;
}

uint64_t CBU_IsR2RSupported()
{
  CBU_IsR2RSupported_uint64_t result = 1;
  if (CBU_IsR2RSupported_once != -1) {
    dispatch_once(&CBU_IsR2RSupported_once, &__block_literal_global_92);
  }
  return CBU_IsR2RSupported_result & 1;
}

float load_fixed_float_from_edt(io_registry_entry_t a1, const __CFString *a2)
{
  io_registry_entry_t v7 = a1;
  CFStringRef v6 = a2;
  float v5 = NAN;
  CFTypeRef cf = 0;
  CFTypeRef cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (cf)
  {
    int v3 = 0;
    if (get_integer_from_cfdata(cf, &v3)) {
      float v5 = (float)v3 / 65536.0;
    }
    CFRelease(cf);
  }
  return v5;
}

uint64_t load_int_from_edt(io_registry_entry_t a1, const __CFString *a2, _DWORD *a3)
{
  char v5 = 0;
  CFTypeRef cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (cf)
  {
    char v5 = get_integer_from_cfdata(cf, a3) & 1;
    CFRelease(cf);
  }
  return v5 & 1;
}

uint64_t get_integer_from_cfdata(const void *a1, _DWORD *a2)
{
  CFTypeRef v7 = a1;
  CFStringRef v6 = a2;
  char v5 = 0;
  *(_DWORD *)buffer = 0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(v7);
    if (v3 == CFDataGetTypeID() && CFDataGetLength((CFDataRef)v7) == 4)
    {
      uint64_t v9 = 0;
      uint64_t v8 = 4;
      uint64_t v10 = 0;
      uint64_t v11 = 4;
      v12.location = 0;
      v12.length = 4;
      CFDataGetBytes((CFDataRef)v7, v12, buffer);
      char v5 = 1;
    }
  }
  *CFStringRef v6 = *(_DWORD *)buffer;
  return v5 & 1;
}

uint64_t AABC::getALSSensorTypeFromService(id *this, __IOHIDServiceClient *a2)
{
  uint64_t v3 = objc_msgSend(this[53], "objectForKey:", a2, 0, a2, this);
  if (v3) {
    return *(unsigned int *)(v3 + 8);
  }
  else {
    return 0;
  }
}

uint64_t __os_log_helper_16_0_1_8_0(uint64_t result, uint64_t a2)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1) = 1;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  return result;
}

void DisplaySetCurrentEDRHeadroom(uint64_t a1, float a2)
{
  uint64_t v11 = a1;
  float v10 = a2;
  BOOL v2 = *(NSObject **)(a1 + 144);
  uint64_t v3 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  CFStringRef v6 = __DisplaySetCurrentEDRHeadroom_block_invoke;
  CFTypeRef v7 = &__block_descriptor_44_e5_v8__0l;
  uint64_t v8 = v11;
  float v9 = a2;
  disp_dispatch_sync(v2, &v3);
}

uint64_t __os_log_helper_16_2_2_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 32;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  return result;
}

void __SendSyncDBVNotification_block_invoke(uint64_t a1)
{
  uint64_t v54 = a1;
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  uint64_t v73 = a1;
  uint64_t v72 = a1;
  int v53 = 0;
  float v71 = 0.0;
  float v71 = *(float *)(*(void *)(a1 + 32) + 12944);
  BOOL v70 = !float_equal(v71, 1.0);
  float v69 = 0.0;
  float v69 = (float)*(int *)(*(void *)(v54 + 32) + 1128) / 65536.0;
  float v68 = 0.0;
  float v68 = *(float *)(v54 + 40);
  if (((*(unsigned char *)(*(void *)(v54 + 32) + 322) & 1) != 0 || *(double *)(*(void *)(v54 + 32) + 12608) > 0.0)
    && (*(unsigned char *)(*(void *)(v54 + 32) + 1517) & 1) != 0)
  {
    float v69 = (float)*(int *)(*(void *)(v54 + 32) + 1132) / 65536.0;
    if (_DisplayBDMAvailable(*(void *)(v54 + 32))) {
      float v69 = fminf(v69, *(float *)(*(void *)(v54 + 32) + 1168));
    }
  }
  float v67 = 0.0;
  float v67 = *(float *)(*(void *)(v54 + 32) + 1312) * *(float *)(*(void *)(v54 + 32) + 1056);
  if (*(unsigned char *)(*(void *)(v54 + 32) + 1120)) {
    float v67 = *(float *)(*(void *)(v54 + 32) + 1312);
  }
  int v66 = 0;
  int v66 = *(_DWORD *)(*(void *)(v54 + 32) + 12676);
  if (*(unsigned char *)(v54 + 44))
  {
    if (v70)
    {
      float v69 = fmaxf(v69, *(float *)(*(void *)(v54 + 32) + 240));
      float v68 = fmaxf(*(float *)(v54 + 40), (float)*(int *)(*(void *)(v54 + 32) + 236) / 65536.0);
    }
    else
    {
      float v69 = *(float *)(*(void *)(v54 + 32) + 240);
    }
  }
  int v65 = 0;
  if (*(float *)(*(void *)(v54 + 32) + 12468) >= 0.0) {
    int v52 = *(_DWORD *)(*(void *)(v54 + 32) + 12468);
  }
  else {
    int v52 = *(_DWORD *)(*(void *)(v54 + 32) + 12392);
  }
  int v65 = v52;
  os_log_t oslog = 0;
  if (_logHandle)
  {
    os_log_t v51 = (os_log_t)_logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    os_log_t v51 = inited;
  }
  os_log_t oslog = v51;
  os_log_type_t type = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
  {
    os_log_t log = oslog;
    *(_DWORD *)uint64_t v48 = type;
    float v1 = (float)*(int *)(*(void *)(v54 + 32) + 1128);
    float v39 = 65536.0;
    *(double *)&uint64_t v40 = (float)(v1 / 65536.0);
    *(double *)&uint64_t v41 = *(float *)(*(void *)(v54 + 32) + 464);
    *(double *)&uint64_t v42 = *(float *)(*(void *)(v54 + 32) + 528);
    *(double *)&uint64_t v43 = *(float *)(*(void *)(v54 + 32) + 1140);
    *(double *)&uint64_t v44 = *(float *)(*(void *)(v54 + 32) + 1056);
    char v2 = *(unsigned char *)(*(void *)(v54 + 32) + 1120);
    uint64_t v37 = "NO";
    uint64_t v3 = "YES";
    uint64_t v38 = "YES";
    if ((v2 & 1) == 0) {
      uint64_t v3 = "NO";
    }
    float v45 = v3;
    char v4 = _DisplayBDMAvailable(*(void *)(v54 + 32));
    uint64_t v5 = (uint64_t)v38;
    if (v4) {
      uint64_t v6 = (uint64_t)v38;
    }
    else {
      uint64_t v6 = (uint64_t)v37;
    }
    *(double *)&uint64_t v7 = *(float *)(*(void *)(v54 + 32) + 1168);
    if (*(unsigned char *)(*(void *)(v54 + 32) + 1517)) {
      uint64_t v8 = (uint64_t)v38;
    }
    else {
      uint64_t v8 = (uint64_t)v37;
    }
    if (*(unsigned char *)(*(void *)(v54 + 32) + 322)) {
      uint64_t v9 = (uint64_t)v38;
    }
    else {
      uint64_t v9 = (uint64_t)v37;
    }
    *(double *)&uint64_t v10 = (float)((float)*(int *)(*(void *)(v54 + 32) + 1132) / v39);
    uint64_t v11 = *(void *)(*(void *)(v54 + 32) + 12608);
    *(double *)&uint64_t v12 = *(float *)(*(void *)(v54 + 32) + 1312);
    if (v70) {
      uint64_t v13 = (uint64_t)v38;
    }
    else {
      uint64_t v13 = (uint64_t)v37;
    }
    if (*(unsigned char *)(v54 + 44)) {
      uint64_t v14 = (uint64_t)v38;
    }
    else {
      uint64_t v14 = (uint64_t)v37;
    }
    if ((*(unsigned char *)(*(void *)(v54 + 32) + 232) & 1) == 0) {
      uint64_t v5 = (uint64_t)v37;
    }
    *(double *)&uint64_t v15 = *(float *)(*(void *)(v54 + 32) + 240);
    *(double *)&uint64_t v16 = (float)((float)*(int *)(*(void *)(v54 + 32) + 236) / v39);
    uint64_t v46 = &v27;
    buf = v74;
    __os_log_helper_16_2_18_8_0_8_0_8_0_8_0_8_0_8_32_8_32_8_0_8_32_8_32_8_0_8_0_8_0_8_32_8_32_8_32_8_0_8_0((uint64_t)v74, v40, v41, v42, v43, v44, (uint64_t)v45, v6, v7, v8, v9, v10, v11, v12, v13, v14, v5, v15, v16);
    _os_log_impl(&dword_1BA438000, log, v48[0], "SyncDBV Composition | Nits.Cap=%f MaxRestriction.Cap=%f WeakRestriction.Cap=%f PAAB.Scalar=%f RightFactor.Current=%f RightFactor.Overriden=%s BrightDotMitigation.Enabled=%s BrightDotMitigation.Cap=%f EDR.Enabled=%s EDR.IsEngaged=%s EDR.Cap=%f EDR.FadePeriod=%f Panel.Max=%f Aurora.IsBoostingBrightness=%s PreStrobe.Changed=%s PreStrobe.IsActive=%s PreStrobe.Cap=%f PreStrobe.CachedNits=%f", buf, 0xB6u);
  }
  context = (void *)MEMORY[0x1BA9ECAE0]();
  id v62 = 0;
  id v35 = (id)MEMORY[0x1E4F1CA60];
  unint64_t v29 = 0x1E4F28000uLL;
  *(float *)&double v17 = v68;
  uint64_t v34 = [NSNumber numberWithFloat:v17];
  LODWORD(v18) = *(_DWORD *)(*(void *)(v54 + 32) + 12628);
  uint64_t v30 = [*(id *)(v29 + 3792) numberWithFloat:v18];
  *(float *)&double v19 = v69;
  uint64_t v31 = [*(id *)(v29 + 3792) numberWithFloat:v19];
  *(float *)&double v20 = v67;
  uint64_t v32 = [*(id *)(v29 + 3792) numberWithFloat:v20];
  LODWORD(v21) = v66;
  uint64_t v33 = [*(id *)(v29 + 3792) numberWithFloat:v21];
  *(float *)&double v22 = v71;
  uint64_t v23 = [*(id *)(v29 + 3792) numberWithFloat:v22];
  uint64_t v36 = &v27;
  id v62 = (id)objc_msgSend(v35, "dictionaryWithObjectsAndKeys:", v34, @"NitsPhysical", v30, @"EDRHeadroom", v31, @"NitsCap", v32, @"DynSliderCap", v33, @"HDRRTPLCHeadroomCap", v23, @"AuroraFactor", 0);
  if ((*(unsigned char *)(*(void *)(v54 + 32) + 321) & 1) != 0
    && (CBU_PassContrastEnhancerStrengthThroughSyncDBV() & 1) != 0)
  {
    LODWORD(v24) = v65;
    uint64_t v25 = [NSNumber numberWithFloat:v24];
    [v62 setObject:v25 forKeyedSubscript:@"ContrastEnhancerStrength"];
  }
  uint64_t v26 = *(NSObject **)(*(void *)(v54 + 32) + 144);
  uint64_t block = MEMORY[0x1E4F143A8];
  int v56 = -1073741824;
  int v57 = 0;
  float v58 = __SendSyncDBVNotification_block_invoke_27;
  uint64_t v59 = &unk_1E6219538;
  uint64_t v61 = *(void *)(v54 + 32);
  id v60 = v62;
  dispatch_async(v26, &block);
}

uint64_t __os_log_helper_16_2_18_8_0_8_0_8_0_8_0_8_0_8_32_8_32_8_0_8_32_8_32_8_0_8_0_8_0_8_32_8_32_8_32_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  uint64_t result = a9;
  *(unsigned char *)a1 = 2;
  *(unsigned char *)(a1 + 1) = 18;
  *(unsigned char *)(a1 + 2) = 0;
  *(unsigned char *)(a1 + 3) = 8;
  *(void *)(a1 + 4) = a2;
  *(unsigned char *)(a1 + 12) = 0;
  *(unsigned char *)(a1 + 13) = 8;
  *(void *)(a1 + 14) = a3;
  *(unsigned char *)(a1 + 22) = 0;
  *(unsigned char *)(a1 + 23) = 8;
  *(void *)(a1 + 24) = a4;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 33) = 8;
  *(void *)(a1 + 34) = a5;
  *(unsigned char *)(a1 + 42) = 0;
  *(unsigned char *)(a1 + 43) = 8;
  *(void *)(a1 + 44) = a6;
  *(unsigned char *)(a1 + 52) = 32;
  *(unsigned char *)(a1 + 53) = 8;
  *(void *)(a1 + 54) = a7;
  *(unsigned char *)(a1 + 62) = 32;
  *(unsigned char *)(a1 + 63) = 8;
  *(void *)(a1 + 64) = a8;
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 73) = 8;
  *(void *)(a1 + 74) = a9;
  *(unsigned char *)(a1 + 82) = 32;
  *(unsigned char *)(a1 + 83) = 8;
  *(void *)(a1 + 84) = a10;
  *(unsigned char *)(a1 + 92) = 32;
  *(unsigned char *)(a1 + 93) = 8;
  *(void *)(a1 + 94) = a11;
  *(unsigned char *)(a1 + 102) = 0;
  *(unsigned char *)(a1 + 103) = 8;
  *(void *)(a1 + 104) = a12;
  *(unsigned char *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 113) = 8;
  *(void *)(a1 + 114) = a13;
  *(unsigned char *)(a1 + 122) = 0;
  *(unsigned char *)(a1 + 123) = 8;
  *(void *)(a1 + 124) = a14;
  *(unsigned char *)(a1 + 132) = 32;
  *(unsigned char *)(a1 + 133) = 8;
  *(void *)(a1 + 134) = a15;
  *(unsigned char *)(a1 + 142) = 32;
  *(unsigned char *)(a1 + 143) = 8;
  *(void *)(a1 + 144) = a16;
  *(unsigned char *)(a1 + 152) = 32;
  *(unsigned char *)(a1 + 153) = 8;
  *(void *)(a1 + 154) = a17;
  *(unsigned char *)(a1 + 162) = 0;
  *(unsigned char *)(a1 + 163) = 8;
  *(void *)(a1 + 164) = a18;
  *(unsigned char *)(a1 + 172) = 0;
  *(unsigned char *)(a1 + 173) = 8;
  *(void *)(a1 + 174) = a19;
  return result;
}

uint64_t CBU_PassContrastEnhancerStrengthThroughSyncDBV()
{
  if (CBU_PassContrastEnhancerStrengthThroughSyncDBV_once != -1) {
    dispatch_once(&CBU_PassContrastEnhancerStrengthThroughSyncDBV_once, &__block_literal_global_53);
  }
  return CBU_PassContrastEnhancerStrengthThroughSyncDBV_pass & 1;
}

float __DisplaySetCurrentEDRHeadroom_block_invoke(uint64_t a1)
{
  float result = *(float *)(a1 + 40);
  *(float *)(*(void *)(a1 + 32) + 12628) = result;
  return result;
}

void __DisplayOpen_block_invoke(uint64_t a1, int a2)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v66 = a1;
  int v65 = a2;
  uint64_t v64 = a1;
  if (a2 == 1)
  {
    *(_DWORD *)(*(void *)(a1 + 64) + 12600) = 2;
    uint64_t v63 = 0;
    if (_logHandle)
    {
      uint64_t v31 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v31 = inited;
    }
    uint64_t v63 = v31;
    os_log_type_t v62 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t log = v63;
      os_log_type_t type = v62;
      __os_log_helper_16_0_0(v61);
      _os_log_impl(&dword_1BA438000, log, type, "Received kEDRNotificationEDREnabled\n", v61, 2u);
    }
    *(unsigned char *)(*(void *)(a1 + 64) + 12081) = 0;
    *(unsigned char *)(*(void *)(a1 + 64) + 12082) = 0;
    __DisplayStartAPLCPMSTimer(*(dispatch_object_t **)(a1 + 64), 1.0);
  }
  else if (a2 == 2)
  {
    id v60 = 0;
    if (_logHandle)
    {
      uint64_t v27 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v26 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v26 = init_default_corebrightness_log();
      }
      uint64_t v27 = v26;
    }
    id v60 = v27;
    os_log_type_t v59 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      double v24 = v60;
      os_log_type_t v25 = v59;
      __os_log_helper_16_0_0(v58);
      _os_log_impl(&dword_1BA438000, v24, v25, "Received kEDRNotificationEDRDisabled, process brightness until headroom 1.0\n", v58, 2u);
    }
    *(_DWORD *)(*(void *)(a1 + 64) + 12600) = 1;
    if (*(void *)(*(void *)(a1 + 64) + 12112))
    {
      __DisplayProcessHDRStatusForCoreAnalytics(*(void *)(a1 + 64));
      dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 64) + 12112));
      *(void *)(*(void *)(a1 + 64) + 12112) = 0;
      *(void *)(*(void *)(a1 + 64) + 12088) = 0;
      *(void *)(*(void *)(a1 + 64) + 12096) = 0;
    }
  }
  else if (a2 == 3 {
         && (*(unsigned char *)(*(void *)(a1 + 64) + 12548) & 1) == 0
  }
         && (*(_DWORD *)(*(void *)(a1 + 64) + 12600) == 2 || *(_DWORD *)(*(void *)(a1 + 64) + 12600) == 1))
  {
    int v57 = 0;
    CBEDRServerGetCurrentDisplayPropertiesForDisplay(*(_DWORD *)(*(void *)(a1 + 64) + 12592), (float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), (float *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), (float *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), (float *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), (float *)&v57);
    float v56 = 0.0;
    if (*(float *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) == 0.0) {
      float v23 = 0.0;
    }
    else {
      float v23 = 1.0 / *(float *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    }
    float v56 = v23;
    os_log_t v55 = 0;
    if (_logHandle)
    {
      double v22 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v21 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v21 = init_default_corebrightness_log();
      }
      double v22 = v21;
    }
    os_log_t v55 = v22;
    os_log_type_t v54 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v69, COERCE__INT64(*(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)), COERCE__INT64(v56), COERCE__INT64(*(float *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)), COERCE__INT64(*(float *)(*(void *)(a1 + 64) + 1140)));
      _os_log_debug_impl(&dword_1BA438000, v55, v54, "EDR Notification: BL brightness: %f, headroom: %f, lux: %f (gl sc: %f)\n", v69, 0x2Au);
    }
    *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = fminf(*(float *)(*(void *)(*(void *)(a1 + 32) + 8)+ 24), *(float *)(*(void *)(a1 + 64) + 1544));
    LODWORD(v53[0]) = 3;
    v53[1] = v56;
    __DisplayUpdateAAPStateInternal(*(void *)(a1 + 64), (uint64_t)v53, 0);
    float v52 = 0.0;
    float v2 = (float)*(int *)(*(void *)(a1 + 64) + 1128) / 65536.0;
    float v52 = v2;
    float v51 = 0.0;
    float v3 = (float)*(int *)(*(void *)(a1 + 64) + 1132) / 65536.0;
    float v51 = v3;
    os_log_t v50 = 0;
    if (_logHandle)
    {
      double v20 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v19 = init_default_corebrightness_log();
      }
      double v20 = v19;
    }
    os_log_t v50 = v20;
    os_log_type_t v49 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v68, COERCE__INT64(v52), COERCE__INT64(v51), COERCE__INT64(*(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)));
      _os_log_impl(&dword_1BA438000, v50, v49, "EDR caps when enabling: currentNitsCap=%f, nitsCapEDR=%f (backlightBrightness %f)", v68, 0x20u);
    }
    BOOL v48 = 0;
    BOOL v48 = *(float *)(*(void *)(a1 + 64) + 12208) == *(float *)(*(void *)(a1 + 64) + 12212);
    char v47 = 1;
    BOOL v46 = 0;
    BOOL v18 = (*(unsigned char *)(*(void *)(a1 + 64) + 1517) & 1) != 0
       || *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) <= v51;
    BOOL v46 = v18;
    char v45 = 0;
    if (*(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= v52 && v46 && v48)
    {
      os_log_t oslog = 0;
      if (_logHandle)
      {
        double v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v16 = init_default_corebrightness_log();
        }
        double v17 = v16;
      }
      os_log_t oslog = v17;
      os_log_type_t v43 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v67, COERCE__INT64(*(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)), COERCE__INT64(v52), COERCE__INT64(v51));
        _os_log_debug_impl(&dword_1BA438000, oslog, v43, "Changing BL cap to %f (currentNitsCap was %f, nitsCapEDR was %f)\n", v67, 0x20u);
      }
      int v42 = 0;
      int v42 = (int)(*(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) * 65536.0);
      os_log_t v41 = 0;
      if (_logHandle)
      {
        uint64_t v15 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v14 = init_default_corebrightness_log();
        }
        uint64_t v15 = v14;
      }
      os_log_t v41 = v15;
      os_log_type_t v40 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        uint64_t v12 = v41;
        os_log_type_t v13 = v40;
        __os_log_helper_16_0_0(v39);
        _os_log_impl(&dword_1BA438000, v12, v13, "SetBLDriverNitsCap for edrNotificationBrightness EDR_ENABLED/EDR_DISABLED_RAMP_PENDING", v39, 2u);
      }
      SetBLDriverNitsCapIfNotInLPM(*(void *)(a1 + 64), v42);
      char v45 = 1;
    }
    __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 64), 0x8000, *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    if (*(_DWORD *)(*(void *)(a1 + 64) + 12600) == 1 && v56 == 1.0)
    {
      os_log_t v38 = 0;
      if (_logHandle)
      {
        uint64_t v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v10 = init_default_corebrightness_log();
        }
        uint64_t v11 = v10;
      }
      os_log_t v38 = v11;
      os_log_type_t v37 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        uint64_t v8 = v38;
        os_log_type_t v9 = v37;
        __os_log_helper_16_0_0(v36);
        _os_log_impl(&dword_1BA438000, v8, v9, "SetBLDriverNitsCap for edrNotificationBrightness EDR_DISABLED_RAMP_PENDING, headroom=1", v36, 2u);
      }
      SetBLDriverNitsCapIfNotInLPM(*(void *)(a1 + 64), *(_DWORD *)(*(void *)(a1 + 64) + 1128));
      *(_DWORD *)(*(void *)(a1 + 64) + 12600) = 0;
      os_log_t v35 = 0;
      if (_logHandle)
      {
        uint64_t v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v6 = init_default_corebrightness_log();
        }
        uint64_t v7 = v6;
      }
      os_log_t v35 = v7;
      os_log_type_t v34 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        char v4 = v35;
        os_log_type_t v5 = v34;
        __os_log_helper_16_0_0(v33);
        _os_log_debug_impl(&dword_1BA438000, v4, v5, "EDR disabled\n", v33, 2u);
      }
      char v45 = 1;
    }
    if ((v45 & 1) == 0 && (*(unsigned char *)(*(void *)(a1 + 64) + 1517) & 1) == 0) {
      SetBLDriverNitsCapIfNotInLPM(*(void *)(a1 + 64), *(_DWORD *)(*(void *)(a1 + 64) + 1128));
    }
  }
}

void AABC::setPropertyForClient(AABC *this, const __CFString *a2, const void *a3, const void *a4)
{
  char v4 = (void *)MEMORY[0x1F4188790](this, a2, a3, a4);
  v549 = &v575;
  v550 = (void (*)(void *))AABC::_RampDoneCallback;
  CFDictionaryApplierFunction v551 = (CFDictionaryApplierFunction)AABC::_setInternalProperty;
  CFDictionaryApplierFunction applier = (CFDictionaryApplierFunction)AABC::UpdateSensorOverride;
  uint64_t v643 = *MEMORY[0x1E4F143B8];
  v621 = v4;
  uint64_t v620 = v5;
  uint64_t v619 = v6;
  uint64_t v618 = v7;
  context = v4;
  uint64_t v617 = 0;
  if (_logHandle)
  {
    uint64_t v548 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT)
    {
      uint64_t v547 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else
    {
      uint64_t inited = init_default_corebrightness_log();
      uint64_t v547 = inited;
    }
    uint64_t v548 = v547;
  }
  uint64_t v8 = (os_log_t *)v549;
  *((void *)v549 + 104) = v548;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v8[104], OS_LOG_TYPE_DEBUG))
  {
    os_log_t log = (os_log_t)*((void *)v549 + 104);
    *(_DWORD *)v544 = type;
    buf = v642;
    __os_log_helper_16_0_1_4_0((uint64_t)v642, 4);
    _os_log_debug_impl(&dword_1BA438000, log, v544[0], "[%x]: ", v642, 8u);
  }
  int v542 = CFEqual(*((CFTypeRef *)v549 + 107), @"IOHIDEventSystemClientIsUnresponsive");
  if (!(_BYTE)v542 && *((_DWORD *)context + 94))
  {
    int v541 = CFEqual(*((CFTypeRef *)v549 + 107), @"AABSensorOverride");
    if ((_BYTE)v541)
    {
      if (*((void *)v549 + 106)) {
        CFDictionaryApplyFunction(*((CFDictionaryRef *)context + 53), applier, *((void **)v549 + 106));
      }
      return;
    }
    int v540 = CFEqual(*((CFTypeRef *)v549 + 107), @"ALSInternalSettings");
    if ((_BYTE)v540)
    {
      if (*((void *)v549 + 106))
      {
        CFTypeID v539 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID TypeID = CFDictionaryGetTypeID();
        if (v539 == TypeID) {
          CFDictionaryApplyFunction(*((CFDictionaryRef *)v549 + 106), v551, context);
        }
      }
      return;
    }
    int v537 = CFEqual(*((CFTypeRef *)v549 + 107), @"CBSoftWakeActive");
    if ((_BYTE)v537)
    {
      if (*((void *)context + 507))
      {
        if (*((void *)v549 + 106))
        {
          uint64_t v535 = *((void *)v549 + 106);
          uint64_t v536 = objc_opt_class();
          int isKindOfClass = objc_opt_isKindOfClass();
          if (isKindOfClass)
          {
            os_log_type_t v9 = (id *)v549;
            *((_DWORD *)v549 + 206) = 0;
            int v533 = [v9[106] intValue];
            uint64_t v10 = v549;
            uint64_t v11 = (id *)context;
            *((_DWORD *)v549 + 206) = v533;
            if (![v11[507] action:*((int *)v10 + 206)])
            {
              float v531 = AABC::IlluminanceToLuminance((uint64_t)context, (float *)context + 262, *((float *)context + 156));
              AABC::UpdateDisplayBrightness_Block6((uint64_t)context, 1, 2, 1, v531);
            }
          }
        }
      }
      return;
    }
    int v530 = CFEqual(*((CFTypeRef *)v549 + 107), @"CBHasExternalDisplay");
    if ((_BYTE)v530)
    {
      if (*((void *)v549 + 106))
      {
        uint64_t v528 = *((void *)v549 + 106);
        uint64_t v529 = objc_opt_class();
        int v527 = objc_opt_isKindOfClass();
        if ((v527 & 1) != 0
          && *((void *)context + 508)
          && (objc_msgSend(*((id *)context + 508), "setActive:", objc_msgSend(*((id *)v549 + 106), "BOOLValue") & 1) & 1) != 0)
        {
          AABC::_UpdateNitsRestrictions((AABC *)context, -1.0, 1.5, 1);
        }
      }
      return;
    }
    int v526 = CFEqual(*((CFTypeRef *)v549 + 107), @"BrightnessCurveLevel");
    if ((_BYTE)v526)
    {
      if (*((void *)v549 + 106))
      {
        CFTypeID v525 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v524 = CFNumberGetTypeID();
        if (v525 == v524)
        {
          uint64_t v12 = (CFNumberRef *)v549;
          *((_DWORD *)v549 + 205) = 0;
          int Value = CFNumberGetValue(v12[106], kCFNumberIntType, valuePtr);
          if ((_BYTE)Value)
          {
            if (*((_DWORD *)v549 + 205) > 2u)
            {
              *((void *)v549 + 101) = 0;
              if (_logHandle)
              {
                uint64_t v522 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  uint64_t v521 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v520 = init_default_corebrightness_log();
                  uint64_t v521 = v520;
                }
                uint64_t v522 = v521;
              }
              os_log_type_t v13 = (os_log_t *)v549;
              *((void *)v549 + 101) = v522;
              os_log_type_t v614 = OS_LOG_TYPE_DEBUG;
              if (os_log_type_enabled(v13[101], OS_LOG_TYPE_DEBUG))
              {
                os_log_t v517 = (os_log_t)*((void *)v549 + 101);
                *(_DWORD *)v518 = v614;
                v519 = v641;
                __os_log_helper_16_0_1_4_0((uint64_t)v641, 2);
                _os_log_debug_impl(&dword_1BA438000, v517, v518[0], "[%x]: invalid curve level - setting to default.", v641, 8u);
              }
              *((_DWORD *)context + 851) = 1;
            }
            else if (*((_DWORD *)v549 + 205) != *((_DWORD *)context + 851))
            {
              *((_DWORD *)context + 851) = *((_DWORD *)v549 + 205);
            }
            +[CBAnalytics cuveLevel:*((unsigned int *)context + 851)];
            memcpy((char *)context + 1048, (char *)context + 104 * *((unsigned int *)context + 851) + 736, 0x68uLL);
            memcpy((char *)context + 2540, (char *)context + 164 * *((unsigned int *)context + 851) + 2048, 0xA4uLL);
            if (*((void *)context + 521)) {
              [*((id *)context + 521) sendCommand:229 inputBuffer:(char *)context + 3404 inputBufferSize:4];
            }
            if (*((_DWORD *)context + 717) != 1)
            {
              AABC::CancelRamp((AABC *)context);
              uint64_t v14 = (float *)context;
              *((_DWORD *)v549 + 200) = 0;
              float v516 = AABC::IlluminanceToLuminance((uint64_t)v14, v14 + 262, v14[156]);
              uint64_t v15 = (float *)context;
              uint64_t v16 = (float *)v549;
              *((float *)v549 + 200) = v516;
              float v515 = clamp(v16[200], v15[180], v15[182]);
              double v17 = context;
              BOOL v18 = (float *)v549;
              *((float *)v549 + 200) = v515;
              AABC::UpdateDisplayBrightness_Block6((uint64_t)v17, 1, 2, 1, v18[200]);
            }
          }
        }
      }
      return;
    }
    int v514 = CFEqual(*((CFTypeRef *)v549 + 107), @"CBAOTStateUpdate");
    if ((_BYTE)v514)
    {
      uint64_t v19 = v549;
      *((_DWORD *)v549 + 199) = 0;
      *((_DWORD *)v19 + 199) = 255;
      *((_DWORD *)v19 + 198) = 0;
      *((_DWORD *)v19 + 198) = 0;
      if (*((void *)v19 + 106)
        && (v513 = CFGetTypeID(*((CFTypeRef *)v549 + 106)), CFTypeID v512 = CFNumberGetTypeID(), v513 == v512))
      {
        CFNumberGetValue(*((CFNumberRef *)v549 + 106), kCFNumberIntType, v613);
        *((float *)v549 + 198) = 1.0;
      }
      else if (*((void *)v549 + 106))
      {
        CFTypeID v511 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v510 = CFDictionaryGetTypeID();
        if (v511 == v510)
        {
          double v20 = (CFDictionaryRef *)v549;
          *((void *)v549 + 98) = 0;
          v509 = CFDictionaryGetValue(v20[106], @"AOTState");
          uint64_t v21 = v549;
          *((void *)v549 + 98) = v509;
          *((void *)v21 + 97) = 0;
          v508 = CFDictionaryGetValue(*((CFDictionaryRef *)v21 + 106), @"AOTTransitionTime");
          double v22 = v549;
          *((void *)v549 + 97) = v508;
          if (*((void *)v22 + 98))
          {
            CFTypeID v507 = CFGetTypeID(*((CFTypeRef *)v549 + 98));
            CFTypeID v506 = CFNumberGetTypeID();
            if (v507 == v506) {
              CFNumberGetValue(*((CFNumberRef *)v549 + 98), kCFNumberIntType, v613);
            }
          }
          if (*((void *)v549 + 97))
          {
            CFTypeID v505 = CFGetTypeID(*((CFTypeRef *)v549 + 97));
            CFTypeID v504 = CFNumberGetTypeID();
            if (v505 == v504) {
              CFNumberGetValue(*((CFNumberRef *)v549 + 97), kCFNumberFloatType, v612);
            }
          }
        }
      }
      if (*((_DWORD *)v549 + 199) != *((_DWORD *)context + 717))
      {
        *((void *)v549 + 96) = 0;
        if (_logHandle)
        {
          uint64_t v503 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            uint64_t v502 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            uint64_t v501 = init_default_corebrightness_log();
            uint64_t v502 = v501;
          }
          uint64_t v503 = v502;
        }
        float v23 = (os_log_t *)v549;
        *((void *)v549 + 96) = v503;
        os_log_type_t v611 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v23[96], OS_LOG_TYPE_DEFAULT))
        {
          os_log_t v498 = (os_log_t)*((void *)v549 + 96);
          *(_DWORD *)v499 = v611;
          if (*((_DWORD *)v549 + 199)) {
            double v24 = "Entering AOT";
          }
          else {
            double v24 = "Exiting AOT";
          }
          *(double *)&uint64_t v25 = *((float *)v549 + 198);
          v500 = v640;
          __os_log_helper_16_2_2_8_32_8_0((uint64_t)v640, (uint64_t)v24, v25);
          _os_log_impl(&dword_1BA438000, v498, v499[0], "AOT State update, %s, transitionTime: %f", v640, 0x16u);
        }
        if (*((void *)context + 521)
          && *((void *)context + 41)
          && (*((unsigned char *)context + 2888) & 1) == 0
          && (*((_DWORD *)context + 717) != 2 || *((_DWORD *)v549 + 199) != 1)
          && (*((_DWORD *)context + 717) != 3 || *((_DWORD *)v549 + 199)))
        {
          if ((*((unsigned char *)context + 4176) & 1) == 0)
          {
            DisplaySetDCPPowerAssertionForAOT(*((void *)context + 51), 1);
            *((unsigned char *)context + 4176) = 1;
          }
          AABC::handleAODStateUpdateProperty((uint64_t)context, *((_DWORD *)v549 + 199), *((float *)v549 + 198));
        }
      }
      return;
    }
    int v497 = CFEqual(*((CFTypeRef *)v549 + 107), @"AOTCurve");
    if ((_BYTE)v497)
    {
      v496 = (void *)MEMORY[0x1BA9ECAE0]();
      if (*((void *)v549 + 106))
      {
        CFTypeID v495 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v494 = CFDictionaryGetTypeID();
        if (v495 == v494)
        {
          *((void *)v549 + 94) = 0;
          if (_logHandle)
          {
            uint64_t v493 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              uint64_t v492 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              uint64_t v491 = init_default_corebrightness_log();
              uint64_t v492 = v491;
            }
            uint64_t v493 = v492;
          }
          uint64_t v26 = (os_log_t *)v549;
          *((void *)v549 + 94) = v493;
          os_log_type_t v610 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v26[94], OS_LOG_TYPE_DEFAULT))
          {
            os_log_t v488 = (os_log_t)*((void *)v549 + 94);
            *(_DWORD *)v489 = v610;
            uint64_t v27 = *((void *)v549 + 106);
            v490 = v639;
            __os_log_helper_16_2_1_8_66((uint64_t)v639, v27);
            _os_log_impl(&dword_1BA438000, v488, v489[0], "Custom Curve: %{public}@", v639, 0xCu);
          }
          char v28 = v549;
          *((void *)v549 + 92) = 0;
          *((void *)v28 + 92) = *((void *)v28 + 106);
          *((void *)v28 + 91) = 0;
          uint64_t v487 = [MEMORY[0x1E4F1CA60] dictionaryWithCapacity:3];
          unint64_t v29 = v549;
          uint64_t v30 = context;
          *((void *)v549 + 91) = v487;
          *((void *)v29 + 87) = 0;
          *((void *)v29 + 88) = v609;
          *((_DWORD *)v29 + 178) = 0x20000000;
          *((_DWORD *)v29 + 179) = 32;
          *((_DWORD *)v29 + 180) = 0;
          *((_DWORD *)v29 + 180) = 0;
          uint64_t v31 = (void *)*((void *)v29 + 92);
          *((void *)v29 + 80) = MEMORY[0x1E4F143A8];
          *((_DWORD *)v29 + 162) = -1073741824;
          *((_DWORD *)v29 + 163) = 0;
          *((void *)v29 + 82) = ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke;
          *((void *)v29 + 83) = &unk_1E621AB00;
          *((void *)v29 + 86) = v30;
          *((void *)v29 + 85) = v609;
          *((void *)v29 + 84) = *((void *)v29 + 91);
          objc_msgSend(v31, "enumerateKeysAndObjectsUsingBlock:");
          if (*((void *)context + 521)) {
            AABC::sendAOTCurvesToDCP((AABC *)context);
          }
          memcpy((char *)context + 2540, (char *)context + 164 * *((unsigned int *)context + 851) + 2048, 0xA4uLL);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)context + 48), *((const void **)v549 + 107), *((const void **)v549 + 106));
          _Block_object_dispose(v609, 8);
        }
      }
      return;
    }
    int v486 = CFEqual(*((CFTypeRef *)v549 + 107), @"DelayedALSOverride");
    if ((_BYTE)v486)
    {
      if (*((void *)v549 + 106))
      {
        CFTypeID v485 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v484 = CFDictionaryGetTypeID();
        if (v485 == v484)
        {
          uint64_t v32 = v549;
          *((void *)v549 + 77) = 0;
          *((void *)v32 + 76) = 0;
          *((void *)v32 + 76) = *((void *)v32 + 106);
          *((void *)v32 + 75) = 0;
          uint64_t v483 = [*((id *)v32 + 76) objectForKey:@"AABSensorOverrideOrientation"];
          uint64_t v33 = v549;
          *((void *)v549 + 75) = v483;
          *((void *)v33 + 74) = 0;
          uint64_t v482 = [*((id *)v33 + 76) objectForKey:@"AABSensorOverrideValue"];
          os_log_type_t v34 = v549;
          *((void *)v549 + 74) = v482;
          *((void *)v34 + 73) = 0;
          uint64_t v481 = [*((id *)v34 + 76) objectForKey:@"OverrideDelay"];
          os_log_t v35 = v549;
          *((void *)v549 + 73) = v481;
          *((_DWORD *)v35 + 145) = 0;
          [*((id *)v35 + 74) floatValue];
          float v480 = v36;
          os_log_type_t v37 = v549;
          *((_DWORD *)v549 + 145) = (int)(float)(v36 * 65536.0);
          *((_DWORD *)v37 + 144) = 0;
          [*((id *)v37 + 73) floatValue];
          float v479 = v38;
          float v39 = v549;
          *((_DWORD *)v549 + 144) = (int)(float)(v38 * 65536.0);
          *((void *)v39 + 71) = 0;
          id v478 = objc_alloc(NSNumber);
          uint64_t v477 = [v478 initWithInt:*((unsigned int *)v549 + 145)];
          os_log_type_t v40 = v549;
          *((void *)v549 + 71) = v477;
          *((void *)v40 + 70) = 0;
          id v476 = objc_alloc(NSNumber);
          uint64_t v475 = [v476 initWithInt:*((unsigned int *)v549 + 144)];
          os_log_t v41 = (id *)v549;
          *((void *)v549 + 70) = v475;
          [v41[74] floatValue];
          float v474 = v42;
          if (v42 == -1.0)
          {
            id v473 = objc_alloc(NSNumber);
            uint64_t v472 = [v473 initWithInt:0];
            *((void *)v549 + 77) = v472;
          }
          else
          {
            id v471 = objc_alloc(NSNumber);
            uint64_t v470 = [v471 initWithInt:1];
            *((void *)v549 + 77) = v470;
          }
          *((void *)v549 + 69) = 0;
          id v469 = objc_alloc(MEMORY[0x1E4F1C9E8]);
          uint64_t v43 = *((void *)v549 + 77);
          uint64_t v44 = *((void *)v549 + 75);
          uint64_t v45 = *((void *)v549 + 71);
          uint64_t v46 = *((void *)v549 + 70);
          v467 = v185;
          uint64_t v468 = objc_msgSend(v469, "initWithObjectsAndKeys:", v43, @"ALSOverrideState", v44, @"AABSensorOverrideOrientation", v45, @"AABSensorOverrideValue", v46, @"OverrideDelay", 0);
          char v47 = context;
          *((void *)v549 + 69) = v468;
          if (v47[41]) {
            IOHIDServiceClientSetProperty(*((IOHIDServiceClientRef *)context + 41), @"DelayedALSOverride", *((CFTypeRef *)v549 + 69));
          }
        }
      }
      return;
    }
    int v466 = CFEqual(*((CFTypeRef *)v549 + 107), @"ALSResetCurve");
    if ((_BYTE)v466)
    {
      AABC::CreateDefaultCurves((AABC *)context);
      AAB::Reset((AAB *)context);
      AABC::writeOutlierRemovalPreferences((uint64_t)context, 0);
      *((void *)v549 + 68) = 0;
      if (_logHandle)
      {
        uint64_t v465 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          uint64_t v464 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          uint64_t v463 = init_default_corebrightness_log();
          uint64_t v464 = v463;
        }
        uint64_t v465 = v464;
      }
      BOOL v48 = (os_log_t *)v549;
      *((void *)v549 + 68) = v465;
      os_log_type_t v608 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v48[68], OS_LOG_TYPE_DEFAULT))
      {
        os_log_t v460 = (os_log_t)*((void *)v549 + 68);
        *(_DWORD *)v461 = v608;
        *(double *)&uint64_t v49 = *((float *)context + 266);
        *(double *)&uint64_t v50 = *((float *)context + 268);
        *(double *)&uint64_t v51 = *((float *)context + 267);
        *(double *)&uint64_t v52 = *((float *)context + 269);
        int v53 = *((_DWORD *)context + 286);
        v462 = v638;
        __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_4_0((uint64_t)v638, v49, v50, v51, v52, v53);
        _os_log_impl(&dword_1BA438000, v460, v461[0], "Reseted curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f Type: %d", v638, 0x30u);
      }
      *((void *)v549 + 66) = 0;
      if (_logHandle)
      {
        uint64_t v459 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          uint64_t v458 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          uint64_t v457 = init_default_corebrightness_log();
          uint64_t v458 = v457;
        }
        uint64_t v459 = v458;
      }
      os_log_type_t v54 = (os_log_t *)v549;
      *((void *)v549 + 66) = v459;
      os_log_type_t v607 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v54[66], OS_LOG_TYPE_DEFAULT))
      {
        os_log_t v454 = (os_log_t)*((void *)v549 + 66);
        *(_DWORD *)v455 = v607;
        *(double *)&uint64_t v55 = *((float *)context + 262);
        *(double *)&uint64_t v56 = *((float *)context + 263);
        *(double *)&uint64_t v57 = *((float *)context + 264);
        *(double *)&uint64_t v58 = *((float *)context + 265);
        v456 = v637;
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v637, v55, v56, v57, v58);
        _os_log_impl(&dword_1BA438000, v454, v455[0], "Reseted dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v637, 0x2Au);
      }
      *((void *)v549 + 64) = 0;
      if (_logHandle)
      {
        uint64_t v453 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          uint64_t v452 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          uint64_t v451 = init_default_corebrightness_log();
          uint64_t v452 = v451;
        }
        uint64_t v453 = v452;
      }
      os_log_type_t v59 = (os_log_t *)v549;
      *((void *)v549 + 64) = v453;
      os_log_type_t v606 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v59[64], OS_LOG_TYPE_DEFAULT))
      {
        os_log_t v448 = (os_log_t)*((void *)v549 + 64);
        *(_DWORD *)v449 = v606;
        *(double *)&uint64_t v60 = *((float *)context + 754);
        *(double *)&uint64_t v61 = *((float *)context + 756);
        *(double *)&uint64_t v62 = *((float *)context + 755);
        *(double *)&uint64_t v63 = *((float *)context + 757);
        int v64 = *((_DWORD *)context + 774);
        v450 = v636;
        __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_4_0((uint64_t)v636, v60, v61, v62, v63, v64);
        _os_log_impl(&dword_1BA438000, v448, v449[0], "Reseted alternative curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f Type: %d", v636, 0x30u);
      }
      *((void *)v549 + 62) = 0;
      if (_logHandle)
      {
        uint64_t v447 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          uint64_t v446 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          uint64_t v445 = init_default_corebrightness_log();
          uint64_t v446 = v445;
        }
        uint64_t v447 = v446;
      }
      int v65 = (os_log_t *)v549;
      *((void *)v549 + 62) = v447;
      os_log_type_t v605 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v65[62], OS_LOG_TYPE_DEFAULT))
      {
        os_log_t v442 = (os_log_t)*((void *)v549 + 62);
        *(_DWORD *)v443 = v605;
        *(double *)&uint64_t v66 = *((float *)context + 750);
        *(double *)&uint64_t v67 = *((float *)context + 751);
        *(double *)&uint64_t v68 = *((float *)context + 752);
        *(double *)&uint64_t v69 = *((float *)context + 753);
        v444 = v635;
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v635, v66, v67, v68, v69);
        _os_log_impl(&dword_1BA438000, v442, v443[0], "Reseted alternative dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v635, 0x2Au);
      }
      return;
    }
    int v441 = CFEqual(*((CFTypeRef *)v549 + 107), @"ALSUserPreference");
    if ((_BYTE)v441)
    {
      if (*((void *)v549 + 106))
      {
        CFTypeID v440 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v439 = CFDictionaryGetTypeID();
        if (v440 == v439 && !*((_DWORD *)context + 162))
        {
          AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v549 + 106), (float *)context + 262);
          uint64_t v70 = (CFDictionaryRef *)v549;
          *((void *)v549 + 60) = 0;
          v438 = CFDictionaryGetValue(v70[106], @"AlternativeCurve");
          float v71 = v549;
          *((void *)v549 + 60) = v438;
          if (*((void *)v71 + 60))
          {
            CFTypeID v437 = CFGetTypeID(*((CFTypeRef *)v549 + 60));
            CFTypeID v436 = CFDictionaryGetTypeID();
            if (v437 == v436)
            {
              AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v549 + 60), (float *)context + 750);
              *((void *)v549 + 59) = 0;
              if (_logHandle)
              {
                uint64_t v435 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  uint64_t v434 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v433 = init_default_corebrightness_log();
                  uint64_t v434 = v433;
                }
                uint64_t v435 = v434;
              }
              uint64_t v72 = (os_log_t *)v549;
              *((void *)v549 + 59) = v435;
              os_log_type_t v604 = OS_LOG_TYPE_INFO;
              if (os_log_type_enabled(v72[59], OS_LOG_TYPE_INFO))
              {
                os_log_t v430 = (os_log_t)*((void *)v549 + 59);
                *(_DWORD *)v431 = v604;
                uint64_t v73 = *((void *)v549 + 60);
                v432 = v634;
                __os_log_helper_16_2_1_8_64((uint64_t)v634, v73);
                _os_log_impl(&dword_1BA438000, v430, v431[0], "Set kIOHIDALSUserPreferenceKey: AlternativeCurve = %@", v634, 0xCu);
              }
              AABC::AlignCurveTypeWithStrategy((uint64_t)context, (_DWORD *)context + 262, (_DWORD *)context + 750);
            }
          }
          *((void *)v549 + 57) = 0;
          if (_logHandle)
          {
            uint64_t v429 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT)
            {
              uint64_t v428 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else
            {
              uint64_t v427 = init_default_corebrightness_log();
              uint64_t v428 = v427;
            }
            uint64_t v429 = v428;
          }
          int v74 = (os_log_t *)v549;
          *((void *)v549 + 57) = v429;
          os_log_type_t v603 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v74[57], OS_LOG_TYPE_DEFAULT))
          {
            os_log_t v423 = (os_log_t)*((void *)v549 + 57);
            *(_DWORD *)v424 = v603;
            int v425 = *((_DWORD *)context + 286);
            int v426 = (*(uint64_t (**)(void))(**((void **)context + 8) + 104))(*((void *)context + 8));
            int v421 = *((_DWORD *)context + 774);
            int v422 = (*(uint64_t (**)(void))(**((void **)context + 8) + 112))(*((void *)context + 8));
            v420 = v633;
            __os_log_helper_16_0_4_4_0_4_0_4_0_4_0((uint64_t)v633, v425, v426, v421, v422);
            _os_log_impl(&dword_1BA438000, v423, v424[0], "Curve os_log_type_t type = %d (%d), Alternative curve os_log_type_t type = %d (%d)", v633, 0x1Au);
          }
          int v419 = (*(uint64_t (**)(void))(**((void **)context + 8) + 104))(*((void *)context + 8));
          uint64_t v75 = (void **)context;
          *((_DWORD *)context + 286) = v419;
          int v418 = (*(uint64_t (**)(void *))(*v75[8] + 112))(v75[8]);
          uint64_t v76 = context;
          *((_DWORD *)context + 774) = v418;
          if (v76[3401])
          {
            v77 = (CFDictionaryRef *)v549;
            *((void *)v549 + 55) = 0;
            v417 = CFDictionaryGetValue(v77[106], @"CurveUpdates");
            float v78 = v549;
            *((void *)v549 + 55) = v417;
            if (*((void *)v78 + 55))
            {
              CFTypeID v416 = CFGetTypeID(*((CFTypeRef *)v549 + 55));
              CFTypeID v415 = CFArrayGetTypeID();
              if (v416 == v415)
              {
                *((void *)v549 + 54) = 0;
                if (_logHandle)
                {
                  uint64_t v414 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    uint64_t v413 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    uint64_t v412 = init_default_corebrightness_log();
                    uint64_t v413 = v412;
                  }
                  uint64_t v414 = v413;
                }
                float v79 = (os_log_t *)v549;
                *((void *)v549 + 54) = v414;
                os_log_type_t v602 = OS_LOG_TYPE_DEFAULT;
                if (os_log_type_enabled(v79[54], OS_LOG_TYPE_DEFAULT))
                {
                  os_log_t v409 = (os_log_t)*((void *)v549 + 54);
                  *(_DWORD *)v410 = v602;
                  uint64_t v80 = *((void *)v549 + 55);
                  v411 = v632;
                  __os_log_helper_16_2_1_8_64((uint64_t)v632, v80);
                  _os_log_impl(&dword_1BA438000, v409, v410[0], "Set kIOHIDALSUserPreferenceKey: CurveUpdates = %@", v632, 0xCu);
                }
                AABC::getCurveUpdatesFromArray((AABC *)context, *((objc_object **)v549 + 55), v601);
                AAB::SetCurveUpdates((uint64_t)context, (uint64_t)v601);
                std::list<AAB::CurveUpdate>::~list((uint64_t)v601);
              }
            }
            int v81 = (CFDictionaryRef *)v549;
            *((void *)v549 + 49) = 0;
            v408 = CFDictionaryGetValue(v81[106], @"ReplacementCurve");
            float v82 = v549;
            *((void *)v549 + 49) = v408;
            if (*((void *)v82 + 49))
            {
              CFTypeID v407 = CFGetTypeID(*((CFTypeRef *)v549 + 49));
              CFTypeID v406 = CFDictionaryGetTypeID();
              if (v407 == v406)
              {
                AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v549 + 49), (float *)context + 724);
                *((void *)v549 + 48) = 0;
                if (_logHandle)
                {
                  uint64_t v405 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT)
                  {
                    uint64_t v404 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else
                  {
                    uint64_t v403 = init_default_corebrightness_log();
                    uint64_t v404 = v403;
                  }
                  uint64_t v405 = v404;
                }
                float v83 = (os_log_t *)v549;
                *((void *)v549 + 48) = v405;
                os_log_type_t v600 = OS_LOG_TYPE_DEFAULT;
                if (os_log_type_enabled(v83[48], OS_LOG_TYPE_DEFAULT))
                {
                  os_log_t v400 = (os_log_t)*((void *)v549 + 48);
                  *(_DWORD *)float v401 = v600;
                  uint64_t v84 = *((void *)v549 + 49);
                  v402 = v631;
                  __os_log_helper_16_2_1_8_64((uint64_t)v631, v84);
                  _os_log_impl(&dword_1BA438000, v400, v401[0], "Set kIOHIDALSUserPreferenceKey: ReplacementCurve = %@", v631, 0xCu);
                }
              }
            }
            float v85 = (CFDictionaryRef *)v549;
            *((void *)v549 + 46) = 0;
            v399 = CFDictionaryGetValue(v85[106], @"AlternativeReplacementCurve");
            unsigned int v86 = v549;
            *((void *)v549 + 46) = v399;
            if (*((void *)v86 + 46)
              && (v398 = CFGetTypeID(*((CFTypeRef *)v549 + 46)), CFTypeID v397 = CFDictionaryGetTypeID(), v398 == v397))
            {
              AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v549 + 46), (float *)context + 776);
              *((void *)v549 + 45) = 0;
              if (_logHandle)
              {
                uint64_t v396 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  uint64_t v395 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v394 = init_default_corebrightness_log();
                  uint64_t v395 = v394;
                }
                uint64_t v396 = v395;
              }
              BOOL v87 = (os_log_t *)v549;
              *((void *)v549 + 45) = v396;
              os_log_type_t v599 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v87[45], OS_LOG_TYPE_DEFAULT))
              {
                os_log_t v391 = (os_log_t)*((void *)v549 + 45);
                *(_DWORD *)unsigned __int8 v392 = v599;
                uint64_t v88 = *((void *)v549 + 46);
                v393 = v630;
                __os_log_helper_16_2_1_8_64((uint64_t)v630, v88);
                _os_log_impl(&dword_1BA438000, v391, v392[0], "Set kIOHIDALSUserPreferenceKey: AlternativeReplacementCurve = %@", v630, 0xCu);
              }
              AABC::AlignCurveTypeWithStrategy((uint64_t)context, (_DWORD *)context + 724, (_DWORD *)context + 776);
            }
            else
            {
              memcpy((char *)context + 3104, (char *)context + 2896, 0x68uLL);
            }
            *((void *)v549 + 43) = 0;
            if (_logHandle)
            {
              uint64_t v390 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT)
              {
                uint64_t v389 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else
              {
                uint64_t v388 = init_default_corebrightness_log();
                uint64_t v389 = v388;
              }
              uint64_t v390 = v389;
            }
            os_log_t v89 = (os_log_t *)v549;
            *((void *)v549 + 43) = v390;
            os_log_type_t v598 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v89[43], OS_LOG_TYPE_DEFAULT))
            {
              os_log_t v384 = (os_log_t)*((void *)v549 + 43);
              *(_DWORD *)os_log_type_t v385 = v598;
              int v386 = *((_DWORD *)context + 748);
              int v387 = (*(uint64_t (**)(void))(**((void **)context + 8) + 104))(*((void *)context + 8));
              int v382 = *((_DWORD *)context + 800);
              int v383 = (*(uint64_t (**)(void))(**((void **)context + 8) + 112))(*((void *)context + 8));
              uint64_t v381 = v629;
              __os_log_helper_16_0_4_4_0_4_0_4_0_4_0((uint64_t)v629, v386, v387, v382, v383);
              _os_log_impl(&dword_1BA438000, v384, v385[0], "Good curve os_log_type_t type = %d (%d), Alternative good curve os_log_type_t type = %d (%d)", v629, 0x1Au);
            }
            int v380 = (*(uint64_t (**)(void))(**((void **)context + 8) + 104))(*((void *)context + 8));
            float v90 = (void **)context;
            *((_DWORD *)context + 748) = v380;
            int v379 = (*(uint64_t (**)(void *))(*v90[8] + 112))(v90[8]);
            CFTypeRef v91 = context;
            *((_DWORD *)context + 800) = v379;
            AABC::revertToGoodCurve((uint64_t)v91, 2u);
          }
          if (*((unsigned char *)context + 3368))
          {
            int v92 = (CFDictionaryRef *)v549;
            *((void *)v549 + 41) = 0;
            v378 = CFDictionaryGetValue(v92[106], @"ReplacementCurve");
            os_log_type_t v93 = v549;
            *((void *)v549 + 41) = v378;
            if (*((void *)v93 + 41))
            {
              CFTypeID v377 = CFGetTypeID(*((CFTypeRef *)v549 + 41));
              CFTypeID v376 = CFDictionaryGetTypeID();
              if (v377 == v376) {
                AABC::readCurveFromDictionary((uint64_t)context, *((const __CFDictionary **)v549 + 41), (float *)context + 724);
              }
            }
            v375 = CFDictionaryGetValue(*((CFDictionaryRef *)v549 + 106), @"Descriptor");
            os_log_t v94 = v549;
            *((void *)v549 + 41) = v375;
            if (*((void *)v94 + 41))
            {
              CFTypeID v374 = CFGetTypeID(*((CFTypeRef *)v549 + 41));
              CFTypeID v373 = CFDictionaryGetTypeID();
              if (v374 == v373) {
                AABC::readCurveDescriptorFromDictionary((uint64_t)context, *((const __CFDictionary **)v549 + 41), (_DWORD *)context + 832);
              }
            }
            AABC::readOutlierRemovalPreferences((AABC *)context);
            if (*((_DWORD *)context + 832) && *((_DWORD *)context + 832) < *((_DWORD *)context + 843))
            {
              AABC::revertToGoodCurve((uint64_t)context, 4u);
              *((_DWORD *)context + 840) = 1;
            }
            *((unsigned char *)context + 401) = 1;
          }
          *((unsigned char *)context + 400) = 1;
        }
      }
      return;
    }
    int v372 = CFEqual(*((CFTypeRef *)v549 + 107), @"CurveUpdates");
    if ((_BYTE)v372)
    {
      if (*((void *)v549 + 106))
      {
        CFTypeID v371 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v370 = CFArrayGetTypeID();
        if (v371 == v370)
        {
          AABC::getCurveUpdatesFromArray((AABC *)context, *((objc_object **)v549 + 106), v597);
          AAB::SetCurveUpdates((uint64_t)context, (uint64_t)v597);
          AABC::revertToGoodCurve((uint64_t)context, 1u);
          std::list<AAB::CurveUpdate>::~list((uint64_t)v597);
        }
      }
      return;
    }
    int v369 = CFEqual(*((CFTypeRef *)v549 + 107), @"OutlierRemoval");
    if ((_BYTE)v369)
    {
      if (*((void *)v549 + 106))
      {
        CFTypeID v368 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v367 = CFDictionaryGetTypeID();
        if (v368 == v367)
        {
          AABC::readOutlierRemovalFromDictionary((uint64_t)context, *((const __CFDictionary **)v549 + 106), (BOOL *)context + 3368);
          char v95 = context;
          *((void *)v549 + 37) = 0;
          CFDictionaryRef OutlierRemovalDictionary = AABC::createOutlierRemovalDictionary((uint64_t)v95, v95 + 3368);
          CFTypeID v96 = (const void **)v549;
          int v97 = (CFMutableDictionaryRef *)context;
          *((void *)v549 + 37) = OutlierRemovalDictionary;
          CFDictionarySetValue(v97[48], v96[107], v96[37]);
          CFRelease(*((CFTypeRef *)v549 + 37));
        }
      }
      return;
    }
    int v365 = CFEqual(*((CFTypeRef *)v549 + 107), @"ALSLockScreenAutoBrightness");
    if ((_BYTE)v365)
    {
      int CFBooleanValue = GetCFBooleanValue(*((const __CFNumber **)v549 + 106));
      int v98 = v549;
      *((_DWORD *)context + 860) = CFBooleanValue;
      *((void *)v98 + 36) = 0;
      if (_logHandle)
      {
        uint64_t v363 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          uint64_t v362 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          uint64_t v361 = init_default_corebrightness_log();
          uint64_t v362 = v361;
        }
        uint64_t v363 = v362;
      }
      int v99 = (os_log_t *)v549;
      *((void *)v549 + 36) = v363;
      os_log_type_t v596 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v99[36], OS_LOG_TYPE_DEBUG))
      {
        os_log_t v358 = (os_log_t)*((void *)v549 + 36);
        *(_DWORD *)int v359 = v596;
        int v100 = *((_DWORD *)context + 860);
        unsigned __int8 v360 = v628;
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v628, 2, v100);
        _os_log_debug_impl(&dword_1BA438000, v358, v359[0], "[%x]: _settings._internal._lockScreenAutoBrightness=%x", v628, 0xEu);
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)context + 48), *((const void **)v549 + 107), *((const void **)v549 + 106));
      return;
    }
    int v357 = CFEqual(*((CFTypeRef *)v549 + 107), @"ALSAccessoryAbsoluteThreshold");
    if ((_BYTE)v357)
    {
      CFTypeID v356 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      CFTypeID v355 = CFNumberGetTypeID();
      if (v356 == v355)
      {
        CFTypeRef v101 = v549;
        CFMutableDictionaryRef v102 = context;
        *((_DWORD *)v549 + 70) = 0;
        *((_DWORD *)v101 + 70) = v102[35];
        int v354 = CFNumberGetValue(*((CFNumberRef *)v101 + 106), kCFNumberFloatType, v595);
        if ((_BYTE)v354) {
          *((_DWORD *)context + 35) = *((_DWORD *)v549 + 70);
        }
      }
      return;
    }
    int v353 = CFEqual(*((CFTypeRef *)v549 + 107), @"LogLevel");
    if ((_BYTE)v353)
    {
      *((void *)v549 + 34) = 0;
      if (_logHandle)
      {
        uint64_t v352 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          uint64_t v351 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          uint64_t v350 = init_default_corebrightness_log();
          uint64_t v351 = v350;
        }
        uint64_t v352 = v351;
      }
      char v103 = (os_log_t *)v549;
      *((void *)v549 + 34) = v352;
      os_log_type_t v594 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v103[34], OS_LOG_TYPE_DEBUG))
      {
        os_log_t v347 = (os_log_t)*((void *)v549 + 34);
        *(_DWORD *)v348 = v594;
        *(double *)&uint64_t v104 = *((float *)context + 266);
        *(double *)&uint64_t v105 = *((float *)context + 268);
        *(double *)&uint64_t v106 = *((float *)context + 267);
        *(double *)&uint64_t v107 = *((float *)context + 269);
        unsigned __int8 v349 = v627;
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v627, v104, v105, v106, v107);
        _os_log_debug_impl(&dword_1BA438000, v347, v348[0], "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f", v627, 0x2Au);
      }
      *((void *)v549 + 32) = 0;
      if (_logHandle)
      {
        uint64_t v346 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT)
        {
          uint64_t v345 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else
        {
          uint64_t v344 = init_default_corebrightness_log();
          uint64_t v345 = v344;
        }
        uint64_t v346 = v345;
      }
      v108 = (os_log_t *)v549;
      *((void *)v549 + 32) = v346;
      os_log_type_t v593 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v108[32], OS_LOG_TYPE_DEBUG))
      {
        os_log_t v341 = (os_log_t)*((void *)v549 + 32);
        *(_DWORD *)float v342 = v593;
        *(double *)&uint64_t v109 = *((float *)context + 262);
        *(double *)&uint64_t v110 = *((float *)context + 263);
        *(double *)&uint64_t v111 = *((float *)context + 264);
        *(double *)&uint64_t v112 = *((float *)context + 265);
        unsigned __int8 v343 = v626;
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v626, v109, v110, v111, v112);
        _os_log_debug_impl(&dword_1BA438000, v341, v342[0], "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v626, 0x2Au);
      }
      return;
    }
    int v340 = CFEqual(*((CFTypeRef *)v549 + 107), @"AutoBrightnessProxEnabled");
    if ((_BYTE)v340)
    {
      *((unsigned char *)context + 3937) = GetCFBooleanValue(*((const __CFNumber **)v549 + 106)) != 0;
      return;
    }
    int v339 = CFEqual(*((CFTypeRef *)v549 + 107), @"AutoBrightnessProxDelay");
    if ((_BYTE)v339)
    {
      CFTypeID v338 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      CFTypeID v337 = CFNumberGetTypeID();
      if (v338 == v337)
      {
        os_log_type_t v113 = v549;
        os_log_t v114 = (float *)context;
        *((_DWORD *)v549 + 62) = 0;
        *((_DWORD *)v113 + 62) = (int)v114[985];
        int v336 = CFNumberGetValue(*((CFNumberRef *)v113 + 106), kCFNumberFloatType, v592);
        if ((_BYTE)v336) {
          *((float *)context + 985) = (float)*((int *)v549 + 62);
        }
      }
      return;
    }
    int v335 = CFEqual(*((CFTypeRef *)v549 + 107), @"AutoBrightnessTouchEnabled");
    if ((_BYTE)v335 || (int v334 = CFEqual(*((CFTypeRef *)v549 + 107), @"AutoBrightnessTouchDelay"), (_BYTE)v334))
    {
      float v115 = context;
      v116 = v549;
      *((void *)v549 + 25) = MEMORY[0x1E4F143A8];
      *((_DWORD *)v116 + 52) = -1073741824;
      *((_DWORD *)v116 + 53) = 0;
      *((void *)v116 + 27) = ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_709;
      *((void *)v116 + 28) = &__block_descriptor_48_e35_v24__0____IOHIDServiceClient__8_v16l;
      *((void *)v116 + 29) = *((void *)v116 + 106);
      *((void *)v116 + 30) = *((void *)v116 + 107);
      AABC::enumerateALSes((uint64_t)v115, (uint64_t)v591);
      return;
    }
    int v333 = CFEqual(*((CFTypeRef *)v549 + 107), @"AutoBrightnessLogMask");
    if ((_BYTE)v333)
    {
      CFTypeID v332 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      CFTypeID v331 = CFNumberGetTypeID();
      if (v332 == v331)
      {
        uint64_t v117 = v549;
        int v118 = context;
        *((_DWORD *)v549 + 49) = 0;
        *((_DWORD *)v117 + 49) = v118[81];
        int v330 = CFNumberGetValue(*((CFNumberRef *)v117 + 106), kCFNumberIntType, v590);
        if ((_BYTE)v330) {
          *((_DWORD *)context + 81) = *((_DWORD *)v549 + 49) | 1;
        }
      }
      return;
    }
    int v329 = CFEqual(*((CFTypeRef *)v549 + 107), @"AutoBrightnessLuxFilter");
    if ((_BYTE)v329)
    {
      CFTypeID v328 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      CFTypeID v327 = CFNumberGetTypeID();
      if (v328 == v327)
      {
        os_log_type_t v119 = v549;
        os_log_t v120 = context;
        *((_DWORD *)v549 + 48) = 0;
        *((_DWORD *)v119 + 48) = v120[864];
        int v326 = CFNumberGetValue(*((CFNumberRef *)v119 + 106), kCFNumberIntType, v589);
        if ((_BYTE)v326)
        {
          if (*((_DWORD *)v549 + 48) < 4u) {
            *((_DWORD *)context + 864) = *((_DWORD *)v549 + 48);
          }
        }
      }
      return;
    }
    int v325 = CFEqual(*((CFTypeRef *)v549 + 107), @"ALSIntPeriod");
    if ((_BYTE)v325) {
      return;
    }
    int v324 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayBrightnessAuto");
    if ((_BYTE)v324)
    {
      AABC::UpdateAutoBrightnessEnabledStatus((AABC *)context, *((const __CFNumber **)v549 + 106));
      return;
    }
    int v323 = CFEqual(*((CFTypeRef *)v549 + 107), @"CBDisplayPresetDisableAutoBrightness");
    if ((_BYTE)v323)
    {
      BOOL v588 = 0;
      int v322 = GetCFBooleanValue(*((const __CFNumber **)v549 + 106));
      BOOL v588 = (_BYTE)v322 == 0;
      if (((_BYTE)v322 == 0) != *((_DWORD *)context + 129))
      {
        os_log_type_t v121 = (AABC *)context;
        *((_DWORD *)context + 129) = v588;
        AABC::_UpdateNitsRestrictions(v121, 0.0, 0.0, 1);
        if (v588)
        {
          os_log_t v122 = (float *)context;
          *((_DWORD *)v549 + 46) = 0;
          float v321 = AABC::IlluminanceToLuminance((uint64_t)v122, v122 + 262, v122[136], v122[139]);
          os_log_type_t v123 = (float *)context;
          os_log_t v124 = (float *)v549;
          *((float *)v549 + 46) = v321;
          v124[46] = fmaxf(v124[46], v123[180]);
          v124[46] = fminf(v124[46], v123[182]);
          AABC::UpdateDisplayBrightness_Block6((uint64_t)v123, 1, 2, 1, v124[46]);
        }
        if (*((void *)context + 44)) {
          (*((void (**)(void, __CFString *, uint64_t))context + 44))(*((void *)context + 45), @"CBAutoBrightnessAvailable", [NSNumber numberWithBool:v588]);
        }
      }
      return;
    }
    int v320 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayOrientation");
    if ((_BYTE)v320)
    {
      CFTypeID v319 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      CFTypeID v318 = CFNumberGetTypeID();
      if (v319 == v318)
      {
        os_log_t v125 = (CFNumberRef *)v549;
        *((_DWORD *)v549 + 45) = 0;
        CFNumberGetValue(v125[106], kCFNumberIntType, v587);
        AABC::SetDisplayOrientation((uint64_t)context, *((_DWORD *)v549 + 45));
      }
      return;
    }
    int v317 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayBrightness");
    if ((_BYTE)v317)
    {
      CFTypeID v316 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      CFTypeID v315 = CFDictionaryGetTypeID();
      if (v316 == v315)
      {
        os_log_type_t v126 = v549;
        os_log_t v127 = context;
        *((_DWORD *)v549 + 44) = 0;
        *((_DWORD *)v126 + 44) = v127[133];
        *((_DWORD *)v126 + 43) = 0;
        *((_DWORD *)v126 + 43) = 0;
        *((void *)v126 + 20) = 0;
        unint64_t v314 = CFDictionaryGetValue(*((CFDictionaryRef *)v126 + 106), @"Brightness");
        os_log_type_t v128 = v549;
        *((void *)v549 + 20) = v314;
        if (*((void *)v128 + 20))
        {
          CFTypeID v313 = CFNumberGetTypeID();
          CFTypeID v312 = CFGetTypeID(*((CFTypeRef *)v549 + 20));
          if (v313 == v312) {
            CFNumberGetValue(*((CFNumberRef *)v549 + 20), kCFNumberFloatType, v586);
          }
        }
        os_log_t v129 = (CFDictionaryRef *)v549;
        *((void *)v549 + 19) = 0;
        int v311 = CFDictionaryGetValue(v129[106], @"Commit");
        os_log_type_t v130 = v549;
        *((void *)v549 + 19) = v311;
        if (*((void *)v130 + 19))
        {
          int v310 = GetCFBooleanValue(*((const __CFNumber **)v549 + 19));
          *((_DWORD *)v549 + 43) = v310;
        }
        AABC::SetUserBrightness((AABC *)context, *((float *)v549 + 44), *((_DWORD *)v549 + 43));
        if ((*((unsigned char *)context + 3417) & 1) == 0 && *((_DWORD *)v549 + 43))
        {
          float v309 = DisplaySliderToLogicalBrightness(*((void *)context + 51), *((float *)context + 133));
          *((float *)context + 855) = v309;
        }
        if (*((_DWORD *)v549 + 43)) {
          AABC::setAABCurveUpdateReason((uint64_t)context, 0);
        }
      }
      else
      {
        CFTypeID v308 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v307 = CFNumberGetTypeID();
        if (v308 == v307)
        {
          os_log_t v131 = v549;
          os_log_type_t v132 = context;
          *((_DWORD *)v549 + 37) = 0;
          *((_DWORD *)v131 + 37) = v132[133];
          CFNumberGetValue(*((CFNumberRef *)v131 + 106), kCFNumberFloatType, v585);
          AABC::SetUserBrightness((AABC *)context, *((float *)v549 + 37), 1);
          if ((*((unsigned char *)context + 3417) & 1) == 0) {
            *((float *)context + 855) = DisplaySliderToLogicalBrightness(*((void *)context + 51), *((float *)context + 133));
          }
        }
      }
      return;
    }
    int v306 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayNitsKey");
    if ((_BYTE)v306)
    {
      CFTypeID v305 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      CFTypeID v304 = CFDictionaryGetTypeID();
      if (v305 == v304)
      {
        os_log_t v133 = v549;
        os_log_type_t v134 = context;
        *((_DWORD *)v549 + 36) = 0;
        *((_DWORD *)v133 + 36) = v134[133];
        *((_DWORD *)v133 + 35) = 0;
        *((_DWORD *)v133 + 35) = 0;
        *((void *)v133 + 16) = 0;
        v303 = CFDictionaryGetValue(*((CFDictionaryRef *)v133 + 106), @"Brightness");
        os_log_t v135 = v549;
        *((void *)v549 + 16) = v303;
        if (*((void *)v135 + 16))
        {
          CFTypeID v302 = CFNumberGetTypeID();
          CFTypeID v301 = CFGetTypeID(*((CFTypeRef *)v549 + 16));
          if (v302 == v301)
          {
            os_log_type_t v136 = (CFNumberRef *)v549;
            *((_DWORD *)v549 + 31) = 0;
            int v300 = CFNumberGetValue(v136[16], kCFNumberFloatType, v584);
            if ((_BYTE)v300)
            {
              float v299 = DisplayLogicalToSliderBrightness(*((void *)context + 51), *((float *)v549 + 31));
              *((float *)v549 + 36) = v299;
            }
          }
        }
        os_log_t v137 = (CFDictionaryRef *)v549;
        *((void *)v549 + 14) = 0;
        char v298 = CFDictionaryGetValue(v137[106], @"Commit");
        float v138 = v549;
        *((void *)v549 + 14) = v298;
        if (*((void *)v138 + 14))
        {
          int v297 = GetCFBooleanValue(*((const __CFNumber **)v549 + 14));
          *((_DWORD *)v549 + 35) = v297;
        }
        AABC::SetUserBrightness((AABC *)context, *((float *)v549 + 36), *((_DWORD *)v549 + 35));
      }
      else
      {
        CFTypeID v296 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        CFTypeID v295 = CFNumberGetTypeID();
        if (v296 == v295)
        {
          os_log_type_t v139 = (CFNumberRef *)v549;
          *((_DWORD *)v549 + 27) = 0;
          int v294 = CFNumberGetValue(v139[106], kCFNumberFloatType, v583);
          if ((_BYTE)v294)
          {
            float v293 = DisplayLogicalToSliderBrightness(*((void *)context + 51), *((float *)v549 + 27));
            AABC::SetUserBrightness((AABC *)context, v293, 1);
            if (*((float *)context + 855) < *((float *)context + 180)) {
              *((_DWORD *)context + 855) = *((_DWORD *)v549 + 27);
            }
          }
        }
      }
      return;
    }
    int v292 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayAutoBrightnessStatus");
    if ((_BYTE)v292)
    {
      CFTypeID v291 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      CFTypeID v290 = CFDictionaryGetTypeID();
      if (v291 == v290)
      {
        os_log_t v140 = v549;
        *((_DWORD *)v549 + 26) = 0;
        *((_DWORD *)v140 + 26) = 0;
        *((_DWORD *)v140 + 25) = 0;
        *((_DWORD *)v140 + 25) = 0;
        *((void *)v140 + 11) = 0;
        os_log_t v289 = CFDictionaryGetValue(*((CFDictionaryRef *)v140 + 106), @"DisplayAutoBrightnessActive");
        os_log_type_t v141 = v549;
        *((void *)v549 + 11) = v289;
        if (*((void *)v141 + 11))
        {
          CFTypeID v288 = CFGetTypeID(*((CFTypeRef *)v549 + 11));
          CFTypeID v287 = CFBooleanGetTypeID();
          if (v288 == v287)
          {
            int v286 = CFBooleanGetValue(*((CFBooleanRef *)v549 + 11));
            *((_DWORD *)v549 + 26) = v286;
          }
        }
        int v285 = CFDictionaryGetValue(*((CFDictionaryRef *)v549 + 106), @"DisplayAutoBrightnessDelay");
        os_log_t v142 = v549;
        *((void *)v549 + 11) = v285;
        if (*((void *)v142 + 11))
        {
          CFTypeID v284 = CFGetTypeID(*((CFTypeRef *)v549 + 11));
          CFTypeID v283 = CFNumberGetTypeID();
          if (v284 == v283) {
            CFNumberGetValue(*((CFNumberRef *)v549 + 11), kCFNumberFloatType, v582);
          }
        }
        AABC::SetAutoBrightnessStatus((AABC *)context, *((_DWORD *)v549 + 26), *((float *)v549 + 25));
      }
      return;
    }
    int v282 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayBrightnessFadePeriod");
    if ((_BYTE)v282)
    {
      CFTypeID v281 = CFNumberGetTypeID();
      CFTypeID v280 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      if (v281 == v280)
      {
        CFNumberGetValue(*((CFNumberRef *)v549 + 106), kCFNumberFloatType, (char *)context + 500);
        *((void *)v549 + 10) = 0;
        if (_logHandle)
        {
          uint64_t v279 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT)
          {
            uint64_t v278 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else
          {
            uint64_t v277 = init_default_corebrightness_log();
            uint64_t v278 = v277;
          }
          uint64_t v279 = v278;
        }
        int v143 = (os_log_t *)v549;
        *((void *)v549 + 10) = v279;
        os_log_type_t v581 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v143[10], OS_LOG_TYPE_DEBUG))
        {
          os_log_t v274 = (os_log_t)*((void *)v549 + 10);
          *(_DWORD *)v275 = v581;
          *(double *)&uint64_t v144 = *((float *)context + 125);
          v276 = v625;
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v625, 2, v144);
          _os_log_debug_impl(&dword_1BA438000, v274, v275[0], "[%x]: _fadePeriod=%f", v625, 0x12u);
        }
      }
      return;
    }
    int v273 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayBrightnessFactorWithFade");
    if ((_BYTE)v273)
    {
      CFTypeID v272 = CFNumberGetTypeID();
      CFTypeID v271 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      if (v272 == v271)
      {
        os_log_type_t v145 = v549;
        os_log_t v146 = context;
        *((_DWORD *)v549 + 18) = 0;
        *((_DWORD *)v145 + 18) = v146[124];
        CFNumberGetValue(*((CFNumberRef *)v145 + 106), kCFNumberFloatType, v580);
        AABC::SetDisplayFactor((AABC *)context, *((float *)v549 + 18), 0);
      }
      else if (*((void *)v549 + 106))
      {
        CFTypeID v270 = CFDictionaryGetTypeID();
        CFTypeID v269 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        if (v270 == v269)
        {
          float v147 = (CFDictionaryRef *)v549;
          *((void *)v549 + 8) = 0;
          v268 = CFDictionaryGetValue(v147[106], @"DisplayBrightnessFadePeriod");
          float v148 = v549;
          *((void *)v549 + 8) = v268;
          if (*((void *)v148 + 8))
          {
            CFTypeID v267 = CFNumberGetTypeID();
            CFTypeID v266 = CFGetTypeID(*((CFTypeRef *)v549 + 8));
            if (v267 == v266)
            {
              CFNumberGetValue(*((CFNumberRef *)v549 + 8), kCFNumberFloat32Type, (char *)context + 500);
              *((void *)v549 + 7) = 0;
              if (_logHandle)
              {
                uint64_t v265 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  uint64_t v264 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v263 = init_default_corebrightness_log();
                  uint64_t v264 = v263;
                }
                uint64_t v265 = v264;
              }
              os_log_type_t v149 = (os_log_t *)v549;
              *((void *)v549 + 7) = v265;
              os_log_type_t v579 = OS_LOG_TYPE_DEBUG;
              if (os_log_type_enabled(v149[7], OS_LOG_TYPE_DEBUG))
              {
                os_log_t v260 = (os_log_t)*((void *)v549 + 7);
                *(_DWORD *)int v261 = v579;
                *(double *)&uint64_t v150 = *((float *)context + 125);
                v262 = v624;
                __os_log_helper_16_0_2_4_0_8_0((uint64_t)v624, 2, v150);
                _os_log_debug_impl(&dword_1BA438000, v260, v261[0], "[%x]: _fadePeriod=%f", v624, 0x12u);
              }
            }
          }
          float v151 = (CFDictionaryRef *)v549;
          *((void *)v549 + 5) = 0;
          uint64_t v259 = CFDictionaryGetValue(v151[106], @"DisplayBrightnessFactor");
          os_log_type_t v152 = v549;
          *((void *)v549 + 5) = v259;
          if (*((void *)v152 + 5))
          {
            CFTypeID v258 = CFNumberGetTypeID();
            CFTypeID v257 = CFGetTypeID(*((CFTypeRef *)v549 + 5));
            if (v258 == v257)
            {
              os_log_t v153 = v549;
              float v154 = context;
              *((_DWORD *)v549 + 9) = 0;
              *((_DWORD *)v153 + 9) = v154[124];
              CFNumberGetValue(*((CFNumberRef *)v153 + 5), kCFNumberFloat32Type, v578);
              AABC::SetDisplayFactor((AABC *)context, *((float *)v549 + 9), 0);
            }
          }
        }
      }
LABEL_381:
      AABC::NotifyCPMSWhenDisplayChangeState((AABC *)context, *((float *)context + 124) > 0.0);
      return;
    }
    int v256 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayBrightnessFactor");
    if ((_BYTE)v256)
    {
      CFTypeID v255 = CFNumberGetTypeID();
      CFTypeID v254 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      if (v255 == v254)
      {
        os_log_type_t v155 = v549;
        os_log_t v156 = context;
        *((_DWORD *)v549 + 8) = 0;
        *((_DWORD *)v155 + 8) = v156[124];
        CFNumberGetValue(*((CFNumberRef *)v155 + 106), kCFNumberFloatType, v577);
        AABC::SetDisplayFactor((AABC *)context, *((float *)v549 + 8), 0);
      }
      goto LABEL_381;
    }
    int v253 = CFEqual(*((CFTypeRef *)v549 + 107), @"DominoStateUpdate");
    if ((_BYTE)v253)
    {
      CFTypeID v252 = CFBooleanGetTypeID();
      CFTypeID v251 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
      if (v252 == v251)
      {
        char v576 = 0;
        int v250 = CFBooleanGetValue(*((CFBooleanRef *)v549 + 106));
        char v576 = v250;
        if ((*((unsigned char *)context + 3417) & 1) != v250)
        {
          float v157 = context;
          *((unsigned char *)context + 3417) = v576 != 0;
          if (v157[3417])
          {
            os_log_t v168 = context;
            *((unsigned char *)context + 3418) = *((_DWORD *)context + 130) == 0;
            float LogicalBrightness = DisplayGetLogicalBrightness(v168[51]);
            float v169 = (AABC *)context;
            *((float *)context + 855) = LogicalBrightness;
            AABC::UpdateAutoBrightnessEnabledStatus(v169, (const __CFNumber *)*MEMORY[0x1E4F1CFD0]);
            DisplaySetProperty(*((void *)context + 51), @"DisplayBrightnessAuto", MEMORY[0x1E4F1CC38]);
            os_log_type_t v170 = (float *)context;
            *((_DWORD *)v549 + 1) = 0;
            float v246 = AABC::IlluminanceToLuminance((uint64_t)v170, v170 + 262, v170[136], v170[139]);
            os_log_t v171 = (float *)context;
            os_log_t v172 = v549;
            *((float *)v549 + 1) = v246;
            *(_DWORD *)os_log_t v172 = 0;
            float v245 = AABC::IlluminanceToLuminance((uint64_t)v171, v171 + 802, v171[136], v171[139]);
            int v173 = context;
            v174 = (float *)v549;
            *(float *)v549 = v245;
            v174[1] = fminf(v174[1], *v174);
            if ((v173[3418] & 1) == 0) {
              *((float *)v549 + 1) = fminf(*((float *)context + 855), *((float *)v549 + 1));
            }
            float v175 = (float *)context;
            double v176 = (float *)v549;
            *((float *)v549 + 1) = fmaxf(*((float *)v549 + 1), *((float *)context + 180));
            v176[1] = fminf(v176[1], v175[182]);
            AABC::UpdateDisplayBrightness_Block6((uint64_t)v175, 1, 2, 1, v176[1]);
          }
          else
          {
            if (*((unsigned char *)context + 3418))
            {
              float v161 = (float *)context;
              *((_DWORD *)v549 + 5) = 0;
              float v249 = AABC::IlluminanceToLuminance((uint64_t)v161, v161 + 262, v161[136], v161[139]);
              float v162 = (float *)context;
              float v163 = (float *)v549;
              *((float *)v549 + 5) = v249;
              v163[5] = fmaxf(v163[5], v162[180]);
              v163[5] = fminf(v163[5], v162[182]);
              AABC::UpdateDisplayBrightness_Block6((uint64_t)v162, 1, 2, 1, v163[5]);
            }
            else
            {
              AABC::CancelRamp((AABC *)context);
              float v158 = (float *)context;
              os_log_type_t v159 = v550;
              os_log_t v160 = v549;
              *((_DWORD *)v549 + 6) = 0;
              *((_DWORD *)v160 + 6) = 10;
              AABC::SetBrightness((AABC *)v158, v158[855], 0.5, *((_DWORD *)v160 + 6), v159, (uint64_t)v158);
            }
            float v164 = v549;
            os_log_type_t v165 = context;
            *((_DWORD *)v549 + 4) = 0;
            *((_DWORD *)v164 + 4) = v165[3418] & 1;
            *((void *)v164 + 1) = 0;
            if (*((_DWORD *)v164 + 4)) {
              uint64_t v248 = *MEMORY[0x1E4F1CFD0];
            }
            else {
              uint64_t v248 = *MEMORY[0x1E4F1CFC8];
            }
            os_log_t v166 = (AABC *)context;
            os_log_type_t v167 = (const __CFNumber **)v549;
            *((void *)v549 + 1) = v248;
            AABC::UpdateAutoBrightnessEnabledStatus(v166, v167[1]);
            DisplaySetProperty(*((void *)context + 51), @"DisplayBrightnessAuto", [NSNumber numberWithInt:*((unsigned int *)v549 + 4)]);
          }
        }
      }
    }
    else
    {
      int v244 = CFEqual(*((CFTypeRef *)v549 + 107), @"ActivateALS");
      if ((_BYTE)v244)
      {
        CFTypeID v243 = CFBooleanGetTypeID();
        CFTypeID v242 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
        if (v243 == v242)
        {
          Boolean v574 = 0;
          Boolean v574 = CFBooleanGetValue(*((CFBooleanRef *)v549 + 106));
          float v573 = 0.0;
          double v177 = 1.0;
          if (!v574) {
            double v177 = 0.0;
          }
          float v178 = v177;
          float v573 = v178;
          AABC::SetDisplayFactor((AABC *)context, v178, 1);
        }
      }
      else
      {
        int v241 = CFEqual(*((CFTypeRef *)v549 + 107), @"DisplayBrightnessFactorPending");
        if (!(_BYTE)v241)
        {
          int v240 = CFEqual(*((CFTypeRef *)v549 + 107), @"UserInteractedWithUI");
          if ((_BYTE)v240)
          {
            double Current = CFAbsoluteTimeGetCurrent();
            double v572 = Current;
            if (*((double *)context + 85) + 3.0 >= Current)
            {
              os_log_t v568 = 0;
              if (_logHandle)
              {
                os_log_t v232 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v231 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v230 = init_default_corebrightness_log();
                  v231 = v230;
                }
                os_log_t v232 = v231;
              }
              os_log_t v568 = v232;
              os_log_type_t v567 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v232, OS_LOG_TYPE_DEFAULT))
              {
                os_log_t v227 = v568;
                *(_DWORD *)int v228 = v567;
                v229 = v623;
                __os_log_helper_16_0_1_8_0((uint64_t)v623, 0x4008000000000000);
                _os_log_impl(&dword_1BA438000, v568, v567, "User interacted with UI in first %f sec of fast ramp mode -> postpone switching to slow mode.", v623, 0xCu);
              }
              *((double *)context + 86) = *((double *)context + 85) + 3.0;
            }
            else
            {
              os_log_t oslog = 0;
              if (_logHandle)
              {
                os_log_t v238 = (os_log_t)_logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT)
                {
                  v237 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else
                {
                  uint64_t v236 = init_default_corebrightness_log();
                  v237 = v236;
                }
                os_log_t v238 = v237;
              }
              os_log_t oslog = v238;
              os_log_type_t v570 = OS_LOG_TYPE_INFO;
              if (os_log_type_enabled(v238, OS_LOG_TYPE_INFO))
              {
                os_log_t v233 = oslog;
                *(_DWORD *)uint64_t v234 = v570;
                double v235 = v569;
                __os_log_helper_16_0_0(v569);
                _os_log_impl(&dword_1BA438000, v233, v234[0], "User interacted with UI -> end fast ramp mode", v569, 2u);
              }
              if (*((unsigned char *)context + 443))
              {
                AABC::CancelFastRampMode((CFAbsoluteTime *)context);
              }
              else if (*((_DWORD *)context + 169))
              {
                *((void *)context + 86) = *((void *)context + 85);
              }
            }
            *((unsigned char *)context + 3320) = 1;
          }
          else
          {
            int v226 = CFEqual(*((CFTypeRef *)v549 + 107), @"ALSTurnOn");
            if ((_BYTE)v226)
            {
              int v566 = 0;
              CFTypeID v225 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
              CFTypeID v224 = CFBooleanGetTypeID();
              if (v225 == v224)
              {
                int v566 = CFBooleanGetValue(*((CFBooleanRef *)v549 + 106));
                if (v566 != *((_DWORD *)context + 131))
                {
                  float v179 = (float *)context;
                  *((_DWORD *)context + 131) = v566;
                  *((_DWORD *)v179 + 160) = v566 != 0;
                  v179[104] = 1.0;
                  AABC::UpdateALSState((CFDictionaryRef *)v179, 4);
                }
              }
            }
            else
            {
              int v223 = CFEqual(*((CFTypeRef *)v549 + 107), @"IOHIDALSTestMode");
              if ((_BYTE)v223)
              {
                CFTypeID v222 = CFNumberGetTypeID();
                CFTypeID v221 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
                if (v222 == v221)
                {
                  int v180 = (char *)context;
                  float v181 = (CFNumberRef *)v549;
                  *((_DWORD *)context + 160) = 0;
                  CFNumberGetValue(v181[106], kCFNumberSInt32Type, v180 + 640);
                  AABC::UpdateALSState((CFDictionaryRef *)context, 4);
                }
              }
              else
              {
                int v220 = CFEqual(*((CFTypeRef *)v549 + 107), @"Aggressivity");
                if ((_BYTE)v220)
                {
                  CFTypeID v219 = CFNumberGetTypeID();
                  CFTypeID v218 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
                  if (v219 == v218)
                  {
                    unsigned int v565 = 0;
                    unsigned int v565 = *((_DWORD *)context + 142);
                    CFNumberGetValue(*((CFNumberRef *)v549 + 106), kCFNumberIntType, &v565);
                    PerceptualLuminanceThresholding::SetAggressivity(*((PerceptualLuminanceThresholding **)context + 502), v565);
                  }
                }
                else
                {
                  int v217 = CFEqual(*((CFTypeRef *)v549 + 107), @"EcoMode");
                  if ((_BYTE)v217)
                  {
                    CFTypeID v216 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
                    CFTypeID v215 = CFBooleanGetTypeID();
                    if (v216 == v215)
                    {
                      int v214 = CFBooleanGetValue(*((CFBooleanRef *)v549 + 106));
                      AABC::_UpdateEcoModeState(context, (_BYTE)v214 != 0);
                    }
                    else
                    {
                      CFTypeID v213 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
                      CFTypeID v212 = CFNumberGetTypeID();
                      if (v213 == v212)
                      {
                        int v564 = 0;
                        CFNumberGetValue(*((CFNumberRef *)v549 + 106), kCFNumberIntType, &v564);
                        AABC::_UpdateEcoModeState(context, v564 != 0);
                      }
                    }
                  }
                  else
                  {
                    int v211 = CFEqual(*((CFTypeRef *)v549 + 107), @"PreStrobe");
                    if ((_BYTE)v211)
                    {
                      if (*((void *)v549 + 106))
                      {
                        CFTypeID v210 = CFNumberGetTypeID();
                        CFTypeID v209 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
                        if (v210 == v209)
                        {
                          int v563 = 0;
                          CFNumberGetValue(*((CFNumberRef *)v549 + 106), kCFNumberIntType, &v563);
                          if (*((void *)context + 59))
                          {
                            IOHIDServiceClientRef service = (IOHIDServiceClientRef)*((void *)context + 59);
                            if (v563) {
                              CFTypeRef property = (CFTypeRef)*MEMORY[0x1E4F1CFD0];
                            }
                            else {
                              CFTypeRef property = (CFTypeRef)*MEMORY[0x1E4F1CFC8];
                            }
                            IOHIDServiceClientSetProperty(service, @"MuonEnabled", property);
                          }
                          *((unsigned char *)context + 506) = v563 != 0;
                        }
                      }
                    }
                    else if (*((void *)v549 + 106) {
                           && (int v206 = CFEqual(*((CFTypeRef *)v549 + 107), @"BrightnessWeakCap"), (_BYTE)v206))
                    }
                    {
                      CFTypeID v205 = CFNumberGetTypeID();
                      CFTypeID v204 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
                      if (v205 == v204)
                      {
                        float v562 = 100.0;
                        CFNumberGetValue(*((CFNumberRef *)v549 + 106), kCFNumberFloatType, &v562);
                        AABC::CancelRamp((AABC *)context);
                        if (v562 >= 100.0)
                        {
                          os_log_t v183 = context;
                          *((_DWORD *)context + 1020) = *((_DWORD *)context + 182);
                          v183[4084] = 0;
                        }
                        else
                        {
                          float v203 = DisplaySliderToLogicalBrightness(*((void *)context + 51), v562);
                          v182 = context;
                          *((float *)context + 1020) = v203;
                          v182[4084] = 1;
                          *((_DWORD *)v182 + 1022) = *((_DWORD *)v182 + 136);
                          os_log_t v561 = 0;
                          if (_logHandle)
                          {
                            os_log_t v202 = (os_log_t)_logHandle;
                          }
                          else
                          {
                            if (_COREBRIGHTNESS_LOG_DEFAULT) {
                              os_log_t v201 = _COREBRIGHTNESS_LOG_DEFAULT;
                            }
                            else {
                              os_log_t v201 = init_default_corebrightness_log();
                            }
                            os_log_t v202 = v201;
                          }
                          os_log_t v561 = v202;
                          os_log_type_t v560 = OS_LOG_TYPE_INFO;
                          if (os_log_type_enabled(v202, OS_LOG_TYPE_INFO))
                          {
                            os_log_t v198 = v561;
                            *(_DWORD *)float v199 = v560;
                            int v200 = v559;
                            __os_log_helper_16_0_0(v559);
                            _os_log_impl(&dword_1BA438000, v198, v199[0], "Enabling weak cap\n", v559, 2u);
                          }
                        }
                        *((unsigned char *)context + 4092) = 1;
                      }
                    }
                    else if (*((void *)v549 + 106) {
                           && (int v197 = CFEqual(*((CFTypeRef *)v549 + 107), @"RLuxEnable"), (_BYTE)v197))
                    }
                    {
                      CFTypeID v196 = CFBooleanGetTypeID();
                      CFTypeID v195 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
                      if (v196 == v195)
                      {
                        int v558 = 0;
                        int v194 = CFBooleanGetValue(*((CFBooleanRef *)v549 + 106));
                        int v558 = v194;
                        BOOL v193 = (_BYTE)v194 == 0;
                        v557[0] = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)context + 304, 2);
                        v557[1] = v184;
                        std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v557, (_BYTE)v194 == 0);
                        AABC::evaluateAABRearConditions((id *)context);
                      }
                    }
                    else if (*((void *)v549 + 106) {
                           && (int v192 = CFEqual(*((CFTypeRef *)v549 + 107), @"AliasingMitigationFilterDuration"),
                    }
                               (_BYTE)v192))
                    {
                      CFTypeID v191 = CFNumberGetTypeID();
                      CFTypeID v190 = CFGetTypeID(*((CFTypeRef *)v549 + 106));
                      if (v191 == v190)
                      {
                        int v556 = 0;
                        CFNumberGetValue(*((CFNumberRef *)v549 + 106), kCFNumberIntType, &v556);
                        AABC::resetFilter((uint64_t)context, (uint64_t *)context + 27);
                        if (v556 < 0) {
                          AABC::setFilterDuration((uint64_t)context, (uint64_t)context + 216, 5);
                        }
                        else {
                          AABC::setFilterDuration((uint64_t)context, (uint64_t)context + 216, v556);
                        }
                      }
                    }
                    else
                    {
                      os_log_t v555 = 0;
                      if (_logHandle)
                      {
                        os_log_t v189 = (os_log_t)_logHandle;
                      }
                      else
                      {
                        if (_COREBRIGHTNESS_LOG_DEFAULT)
                        {
                          v188 = _COREBRIGHTNESS_LOG_DEFAULT;
                        }
                        else
                        {
                          uint64_t v187 = init_default_corebrightness_log();
                          v188 = v187;
                        }
                        os_log_t v189 = v188;
                      }
                      os_log_t v555 = v189;
                      os_log_type_t v554 = OS_LOG_TYPE_DEBUG;
                      if (os_log_type_enabled(v189, OS_LOG_TYPE_DEBUG))
                      {
                        v185[10] = (_Unwind_Exception *)v555;
                        *(_DWORD *)v186 = v554;
                        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v622, 1, *((void *)v549 + 107), *((void *)v549 + 106));
                        _os_log_debug_impl(&dword_1BA438000, v555, v554, "[%x]: unknown key=%@ property=%@", v622, 0x1Cu);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void sub_1BA493460()
{
  _Unwind_Resume(v0);
}

void sub_1BA493A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 56), 8);
  _Unwind_Resume(a1);
}

void AABC::registerService(AABC *this, __IOHIDServiceClient *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v33 = this;
  IOHIDServiceClientRef v32 = a2;
  os_log_t v31 = 0;
  if (_logHandle)
  {
    uint64_t v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v10 = inited;
  }
  os_log_t v31 = v10;
  os_log_type_t v30 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v36, 4);
    _os_log_debug_impl(&dword_1BA438000, v31, v30, "[%x]: ", v36, 8u);
  }
  if (v32)
  {
    CFTypeRef v29 = IOHIDServiceClientCopyProperty(v32, @"Built-In");
    if (v29)
    {
      if (v29 == (CFTypeRef)*MEMORY[0x1E4F1CFD0])
      {
        CFTypeRef v28 = IOHIDServiceClientCopyProperty(v32, @"DeviceUsagePairs");
        if (v28)
        {
          CFTypeID v8 = CFGetTypeID(v28);
          if (v8 == CFArrayGetTypeID())
          {
            char v27 = 0;
            CFArrayRef theArray = (CFArrayRef)v28;
            for (int i = 0; ; ++i)
            {
              CFIndex v7 = i;
              if (v7 >= CFArrayGetCount(theArray)) {
                break;
              }
              if (IOHIDServiceClientConformsTo(v32, 0xFF00u, 4u))
              {
                value = 0;
                operator new();
              }
              if (IOHIDServiceClientConformsTo(v32, 0xFF00u, 8u))
              {
                int v23 = 1;
                CFTypeRef v22 = IOHIDServiceClientCopyProperty(v32, @"Placement");
                if (v22)
                {
                  CFTypeID v6 = CFGetTypeID(v22);
                  if (v6 == CFNumberGetTypeID()) {
                    CFNumberGetValue((CFNumberRef)v22, kCFNumberSInt32Type, &v23);
                  }
                }
                if (v22) {
                  CFRelease(v22);
                }
                if (v23 == 1)
                {
                  *((void *)this + 60) = v32;
                  os_log_t v21 = 0;
                  if (_logHandle)
                  {
                    uint64_t v5 = _logHandle;
                  }
                  else
                  {
                    uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                    uint64_t v5 = v4;
                  }
                  os_log_t v21 = v5;
                  os_log_type_t v20 = OS_LOG_TYPE_DEBUG;
                  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
                  {
                    __os_log_helper_16_2_3_4_0_8_64_8_32((uint64_t)v35, 8, (uint64_t)v32, (uint64_t)(&kDimPolicyStr)[*((unsigned int *)this + 859)]);
                    _os_log_debug_impl(&dword_1BA438000, v21, v20, "[%x]: _prox=%@ _settings._internal._dimPolicy=%s", v35, 0x1Cu);
                  }
                }
              }
              if (IOHIDServiceClientConformsTo(v32, 0xDu, 4u) || IOHIDServiceClientConformsTo(v32, 0xDu, 0xCu))
              {
                *((void *)this + 59) = v32;
                char v27 = 1;
                os_log_t v19 = 0;
                if (_logHandle)
                {
                  float v3 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT) {
                    uint64_t v2 = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else {
                    uint64_t v2 = init_default_corebrightness_log();
                  }
                  float v3 = v2;
                }
                os_log_t v19 = v3;
                os_log_type_t v18 = OS_LOG_TYPE_DEBUG;
                if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
                {
                  __os_log_helper_16_2_2_4_0_8_64((uint64_t)v34, 32, *((void *)this + 59));
                  _os_log_debug_impl(&dword_1BA438000, v19, v18, "[%x]: _digitizer=%@", v34, 0x12u);
                }
              }
            }
            if (v27)
            {
              uint64_t v12 = MEMORY[0x1E4F143A8];
              int v13 = -1073741824;
              int v14 = 0;
              uint64_t v15 = ___ZN4AABC15registerServiceEP20__IOHIDServiceClient_block_invoke;
              uint64_t v16 = &__block_descriptor_40_e35_v24__0____IOHIDServiceClient__8_v16l;
              double v17 = this;
              AABC::enumerateALSes((uint64_t)this, (uint64_t)&v12);
            }
          }
        }
        if (v28) {
          CFRelease(v28);
        }
      }
      CFRelease(v29);
    }
  }
}

void sub_1BA4971C0()
{
  _Unwind_Resume(v0);
}

uint64_t __DisplayCopyProperty_block_invoke(uint64_t a1)
{
  uint64_t result = _DisplayCopyPropertyInternal(*(void *)(a1 + 40), *(const void **)(a1 + 48));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t _DisplayCopyPropertyInternal(uint64_t a1, const void *a2)
{
  int Value = 0;
  if (CFEqual(a2, @"PendingDisplayNits"))
  {
    int Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (const void *)(a1 + 1252));
  }
  else if (CFEqual(a2, @"ThermalMitigationLimitingBrightness"))
  {
    if (*(float *)(a1 + 1256) < *(float *)(a1 + 464)) {
      float v3 = (void *)*MEMORY[0x1E4F1CFC8];
    }
    else {
      float v3 = (void *)*MEMORY[0x1E4F1CFD0];
    }
    int Value = v3;
  }
  else if (CFEqual(a2, @"EcoModeFactor"))
  {
    int Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (const void *)(a1 + 648));
  }
  else if (CFEqual(a2, @"AAPLuxDelta"))
  {
    int Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (const void *)(a1 + 12268));
  }
  else if (CFEqual(a2, @"DominoFactor"))
  {
    int Value = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(a1 + 224));
  }
  if (!Value)
  {
    int Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 192), a2);
    if (Value) {
      return [Value copy];
    }
  }
  return (uint64_t)Value;
}

void __DisplayUpdateSlider(float *a1, float a2, float a3, float a4)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = a1;
  float valuePtr = a2;
  float v61 = a3;
  float v60 = a4;
  if (a1[70] >= 0.0) {
    float valuePtr = *((float *)cf + 70);
  }
  if (*((unsigned char *)cf + 312))
  {
    os_log_type_t v59 = 0;
    if (*((_DWORD *)cf + 77)) {
      os_log_type_t v59 = @"DisplayTypeIcon";
    }
    else {
      os_log_type_t v59 = @"DisplayTypeSiri";
    }
    if ((*((unsigned char *)cf + 312) & 1) != 0 && *((float *)cf + 79) != -1.0)
    {
      float v61 = *((float *)cf + 79);
      float v60 = v61;
      float v4 = __DisplayPhysicalToLogicalBrightness((uint64_t)cf, v61);
      float valuePtr = _DisplayLogicalToSliderBrightnessInternal((uint64_t)cf, v4);
    }
    *((float *)cf + 316) = v60;
    v76[0] = xmmword_1E621A730;
    v76[1] = xmmword_1E621A740;
    long long v74 = 0u;
    long long v75 = 0u;
    CFAllocatorRef v5 = CFGetAllocator(cf);
    *(void *)&long long v74 = CFNumberCreate(v5, kCFNumberFloatType, &valuePtr);
    int v23 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    *((void *)&v74 + 1) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &v61);
    *(void *)&long long v75 = CFNumberCreate(*v23, kCFNumberFloat32Type, &v60);
    *((void *)&v75 + 1) = v59;
    CFAllocatorRef v6 = CFGetAllocator(cf);
    value = CFDictionaryCreate(v6, (const void **)v76, (const void **)&v74, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (value)
    {
      os_log_t oslog = 0;
      if (_logHandle)
      {
        CFTypeRef v22 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        CFTypeRef v22 = inited;
      }
      os_log_t oslog = v22;
      os_log_type_t type = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v73, COERCE__INT64(valuePtr));
        _os_log_debug_impl(&dword_1BA438000, oslog, type, "S=%f", v73, 0xCu);
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), @"DisplayBrightness", value);
      CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), @"DisplayNitsKey", value);
      *((unsigned char *)cf + 272) = 1;
      CFIndex v7 = *((void *)cf + 18);
      uint64_t block = MEMORY[0x1E4F143A8];
      int v50 = -1073741824;
      int v51 = 0;
      uint64_t v52 = ____DisplayUpdateSlider_block_invoke;
      int v53 = &__block_descriptor_48_e5_v8__0l;
      CFTypeRef v54 = cf;
      uint64_t v55 = value;
      dispatch_async(v7, &block);
    }
    if ((void)v74) {
      CFRelease((CFTypeRef)v74);
    }
    if (*((void *)&v74 + 1)) {
      CFRelease(*((CFTypeRef *)&v74 + 1));
    }
    if ((void)v75) {
      CFRelease((CFTypeRef)v75);
    }
  }
  else
  {
    *((float *)cf + 316) = v60;
    BOOL v48 = 0;
    if (*((unsigned char *)cf + 321))
    {
      int v47 = 0;
      float v46 = 0.0;
      BOOL v45 = 0;
      BOOL v20 = 1;
      if ((*((unsigned char *)cf + 322) & 1) == 0) {
        BOOL v20 = *((double *)cf + 1576) > 0.0;
      }
      BOOL v45 = v20;
      if (v20)
      {
        int v47 = *((_DWORD *)cf + 283);
        if (*((unsigned char *)cf + 1517) & 1) != 0 && (_DisplayBDMAvailable((uint64_t)cf)) {
          int v47 = (int)(float)(*((float *)cf + 292) * 65536.0);
        }
      }
      else
      {
        int v47 = *((_DWORD *)cf + 282);
      }
      float numValues_4 = (float)v47 / 65536.0;
      if (*((unsigned char *)cf + 1120)) {
        float v46 = *((float *)cf + 328);
      }
      else {
        float v46 = *((float *)cf + 328) * *((float *)cf + 264);
      }
      memcpy(__dst, &off_1E621A750, sizeof(__dst));
      memset(__b, 0, sizeof(__b));
      CFAllocatorRef v8 = CFGetAllocator(cf);
      __b[0] = CFNumberCreate(v8, kCFNumberFloatType, &valuePtr);
      os_log_t v19 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
      __b[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &v61);
      __b[2] = CFNumberCreate(*v19, kCFNumberFloat32Type, &v60);
      __b[3] = CFNumberCreate(*v19, kCFNumberFloat32Type, &v60);
      __b[4] = CFNumberCreate(*v19, kCFNumberFloat32Type, (char *)cf + 12628);
      __b[5] = CFNumberCreate(*v19, kCFNumberFloat32Type, &numValues_4);
      __b[6] = CFNumberCreate(*v19, kCFNumberFloat32Type, &v46);
      __b[7] = CFNumberCreate(*v19, kCFNumberFloat32Type, (char *)cf + 12944);
      int numValues = 8;
      CFAllocatorRef v9 = CFGetAllocator(cf);
      BOOL v48 = CFDictionaryCreate(v9, __dst, __b, 8, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v48)
      {
        os_log_t v42 = 0;
        if (_logHandle)
        {
          os_log_type_t v18 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v17 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v17 = init_default_corebrightness_log();
          }
          os_log_type_t v18 = v17;
        }
        os_log_t v42 = v18;
        os_log_type_t v41 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v70, COERCE__INT64(valuePtr));
          _os_log_debug_impl(&dword_1BA438000, v42, v41, "S=%f", v70, 0xCu);
        }
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), @"DisplayBrightness", v48);
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), @"DisplayNitsKey", v48);
        *((unsigned char *)cf + 272) = 1;
        kdebug_trace();
        uint64_t v10 = *((void *)cf + 18);
        uint64_t v34 = MEMORY[0x1E4F143A8];
        int v35 = -1073741824;
        int v36 = 0;
        uint64_t v37 = ____DisplayUpdateSlider_block_invoke_1042;
        float v38 = &__block_descriptor_48_e5_v8__0l;
        CFTypeRef v39 = cf;
        os_log_type_t v40 = v48;
        dispatch_async(v10, &v34);
      }
      for (int i = 0; i < numValues; ++i)
      {
        if (__b[i]) {
          CFRelease(__b[i]);
        }
      }
    }
    else
    {
      long long v68 = xmmword_1E621A790;
      uint64_t v69 = @"NitsPhysical";
      CFTypeRef v65 = 0;
      CFTypeRef v66 = 0;
      CFTypeRef v67 = 0;
      CFAllocatorRef v11 = CFGetAllocator(cf);
      CFTypeRef v65 = CFNumberCreate(v11, kCFNumberFloatType, &valuePtr);
      uint64_t v16 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
      CFTypeRef v66 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, &v61);
      CFTypeRef v67 = CFNumberCreate(*v16, kCFNumberFloat32Type, &v60);
      CFAllocatorRef v12 = CFGetAllocator(cf);
      BOOL v48 = CFDictionaryCreate(v12, (const void **)&v68, &v65, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (v48)
      {
        os_log_t v32 = 0;
        if (_logHandle)
        {
          uint64_t v15 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v14 = init_default_corebrightness_log();
          }
          uint64_t v15 = v14;
        }
        os_log_t v32 = v15;
        os_log_type_t v31 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v64, COERCE__INT64(valuePtr));
          _os_log_debug_impl(&dword_1BA438000, v32, v31, "S=%f", v64, 0xCu);
        }
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), @"DisplayBrightness", v48);
        CFDictionarySetValue(*((CFMutableDictionaryRef *)cf + 24), @"DisplayNitsKey", v48);
        *((unsigned char *)cf + 272) = 1;
        kdebug_trace();
        int v13 = *((void *)cf + 18);
        uint64_t v24 = MEMORY[0x1E4F143A8];
        int v25 = -1073741824;
        int v26 = 0;
        char v27 = ____DisplayUpdateSlider_block_invoke_1044;
        CFTypeRef v28 = &__block_descriptor_48_e5_v8__0l;
        CFTypeRef v29 = cf;
        os_log_type_t v30 = v48;
        dispatch_async(v13, &v24);
      }
      if (v65) {
        CFRelease(v65);
      }
      if (v66) {
        CFRelease(v66);
      }
      if (v67) {
        CFRelease(v67);
      }
    }
  }
}

void __DisplaySetProperty_block_invoke(uint64_t a1)
{
  uint64_t v657 = *MEMORY[0x1E4F143B8];
  uint64_t v590 = a1;
  uint64_t v589 = a1;
  float v588 = 0.0;
  if (*(void *)(a1 + 40) && CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightness"))
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      float v588 = *(float *)(*(void *)(a1 + 56) + 336);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
      os_log_t v587 = 0;
      if (_logHandle)
      {
        uint64_t v277 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v277 = inited;
      }
      os_log_t v587 = v277;
      os_log_type_t v586 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v277, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v656, (uint64_t)"DisplayBrightness", COERCE__INT64(v588));
        _os_log_debug_impl(&dword_1BA438000, v587, v586, "DisplaySetProperty: %s = %f\n", v656, 0x16u);
      }
      v585[0] = 1;
      *(float *)&v585[1] = v588;
      __DisplayUpdateAAPStateInternal(*(void *)(a1 + 56), (uint64_t)v585, 1);
      float v584 = 0.0;
      float v584 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), v588);
      if (v584 > *(float *)(*(void *)(a1 + 56) + 528)) {
        _DisplaySetBrightnessWeakCapWithFade(*(unsigned char **)(a1 + 56), 0, v584, 0.0);
      }
      __DisplaySetBrightnessWithFade(*(void *)(a1 + 56), 0x3008u, v588, 0.0);
    }
    else
    {
      CFTypeID v275 = CFDictionaryGetTypeID();
      if (v275 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        CFTypeRef Value = 0;
        CFTypeRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"Brightness");
        v582 = 0;
        v582 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"Commit");
        CFTypeRef v581 = 0;
        CFTypeRef v581 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"Period");
        if (Value)
        {
          CFTypeID v274 = CFGetTypeID(Value);
          if (v274 == CFNumberGetTypeID())
          {
            float v580 = 0.0;
            float v580 = *(float *)(*(void *)(a1 + 56) + 276);
            if (v581)
            {
              CFTypeID v273 = CFGetTypeID(v581);
              if (v273 == CFNumberGetTypeID())
              {
                if (CFNumberIsFloatType((CFNumberRef)v581)) {
                  CFNumberGetValue((CFNumberRef)v581, kCFNumberFloat32Type, &v580);
                }
              }
            }
            float v588 = *(float *)(*(void *)(a1 + 56) + 336);
            CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, &v588);
            v579[0] = 1;
            *(float *)&v579[1] = v588;
            __DisplayUpdateAAPStateInternal(*(void *)(a1 + 56), (uint64_t)v579, v582 == (const void *)*MEMORY[0x1E4F1CFD0]);
            float v578 = 0.0;
            float v578 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), v588);
            if (v578 > *(float *)(*(void *)(a1 + 56) + 528)) {
              _DisplaySetBrightnessWeakCapWithFade(*(unsigned char **)(a1 + 56), 0, v578, v580);
            }
            os_log_t v577 = 0;
            if (_logHandle)
            {
              CFTypeID v272 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v271 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v271 = init_default_corebrightness_log();
              }
              CFTypeID v272 = v271;
            }
            os_log_t v577 = v272;
            os_log_type_t v576 = OS_LOG_TYPE_DEBUG;
            if (os_log_type_enabled(v272, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v655, (uint64_t)"DisplayBrightness", COERCE__INT64(v588), COERCE__INT64(v578));
              _os_log_debug_impl(&dword_1BA438000, v577, v576, "DisplaySetProperty: %s = %f (nits=%f)\n", v655, 0x20u);
            }
            if (v582 == (const void *)*MEMORY[0x1E4F1CFD0]) {
              __DisplayReportCommit(*(NSObject ***)(a1 + 56), v588);
            }
            unsigned int v575 = 0;
            if (v582 == (const void *)*MEMORY[0x1E4F1CFD0]) {
              unsigned int v1 = 12296;
            }
            else {
              unsigned int v1 = 8200;
            }
            unsigned int v575 = v1;
            if (*(unsigned char *)(*(void *)(a1 + 56) + 323))
            {
              float v574 = v580;
              float v573 = 0.0;
              float v573 = _DisplayLuminanceToPerceptualLuminanceInternal(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 1256));
              float v572 = 0.0;
              float v572 = _DisplayLuminanceToPerceptualLuminanceInternal(*(void *)(a1 + 56), v578);
              float v571 = v572 - v573;
              if ((float)(v572 - v573) < 0.0 && v574 <= 0.0) {
                float v574 = 0.4;
              }
              if (v574 <= 0.0)
              {
                *(float *)(*(void *)(a1 + 56) + 280) = -1.0;
              }
              else
              {
                float v571 = fminf(fmaxf(fabsf(v571), 0.0), 1.0);
                *(float *)(*(void *)(a1 + 56) + 280) = v588;
                v575 |= 0x80u;
                float v580 = v574 * v571;
              }
            }
            __DisplaySetBrightnessWithFade(*(void *)(a1 + 56), v575, v588, v580);
            if (v582 == (const void *)*MEMORY[0x1E4F1CFD0])
            {
              os_log_t v570 = 0;
              if (_logHandle)
              {
                CFTypeID v270 = _logHandle;
              }
              else
              {
                uint64_t v269 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                CFTypeID v270 = v269;
              }
              os_log_t v570 = v270;
              os_log_type_t v569 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v270, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_2_5_8_32_8_0_8_0_8_0_4_0((uint64_t)v654, (uint64_t)"User change", COERCE__INT64(v588), COERCE__INT64(v578), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 1260)), v582 == (const void *)*MEMORY[0x1E4F1CFD0]);
                _os_log_impl(&dword_1BA438000, v570, v569, "[BRT update: %s]: slider value = %f, nits = %f, nits physical = %f, commit = %d", v654, 0x30u);
              }
            }
          }
        }
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  else if (*(void *)(a1 + 40) && CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayNitsKey"))
  {
    CFTypeID v268 = CFNumberGetTypeID();
    if (v268 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      float v588 = *(float *)(*(void *)(a1 + 56) + 1256);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
      os_log_t v568 = 0;
      if (_logHandle)
      {
        CFTypeID v267 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v266 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v266 = init_default_corebrightness_log();
        }
        CFTypeID v267 = v266;
      }
      os_log_t v568 = v267;
      os_log_type_t v567 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v267, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v653, (uint64_t)"DisplayNitsKey", COERCE__INT64(v588));
        _os_log_debug_impl(&dword_1BA438000, v568, v567, "DisplaySetProperty: %s = %f\n", v653, 0x16u);
      }
      _DisplaySetLogicalBrightnessWithFade(*(void *)(a1 + 56), 0x3008u, 0, 0, v588, 0.0);
    }
    else
    {
      CFTypeID v265 = CFDictionaryGetTypeID();
      if (v265 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        CFTypeRef v566 = 0;
        CFTypeRef v566 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"Brightness");
        unsigned int v565 = 0;
        unsigned int v565 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"Commit");
        CFTypeRef v564 = 0;
        CFTypeRef v564 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"Period");
        if (v566)
        {
          CFTypeID v264 = CFGetTypeID(v566);
          if (v264 == CFNumberGetTypeID())
          {
            float v563 = 0.0;
            float v563 = *(float *)(*(void *)(a1 + 56) + 276);
            if (v564)
            {
              CFTypeID v263 = CFGetTypeID(v564);
              if (v263 == CFNumberGetTypeID())
              {
                if (CFNumberIsFloatType((CFNumberRef)v564)) {
                  CFNumberGetValue((CFNumberRef)v564, kCFNumberFloat32Type, &v563);
                }
              }
            }
            float v588 = *(float *)(*(void *)(a1 + 56) + 1256);
            CFNumberGetValue((CFNumberRef)v566, kCFNumberFloatType, &v588);
            if (v565 == (const void *)*MEMORY[0x1E4F1CFD0])
            {
              float v562 = 0.0;
              float v562 = _DisplayLogicalToSliderBrightnessInternal(*(void *)(a1 + 56), v588);
              __DisplayReportCommit(*(NSObject ***)(a1 + 56), v562);
            }
            os_log_t v561 = 0;
            if (_logHandle)
            {
              v262 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v261 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v261 = init_default_corebrightness_log();
              }
              v262 = v261;
            }
            os_log_t v561 = v262;
            os_log_type_t v560 = OS_LOG_TYPE_DEBUG;
            if (os_log_type_enabled(v262, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_2_2_8_32_8_0((uint64_t)v652, (uint64_t)"DisplayNitsKey", COERCE__INT64(v588));
              _os_log_debug_impl(&dword_1BA438000, v561, v560, "DisplaySetProperty: %s = %f\n", v652, 0x16u);
            }
            if (v565 == (const void *)*MEMORY[0x1E4F1CFD0]) {
              unsigned int v2 = 12296;
            }
            else {
              unsigned int v2 = 8200;
            }
            _DisplaySetLogicalBrightnessWithFade(*(void *)(a1 + 56), v2, 0, 0, v588, v563);
          }
        }
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"kIOHIDDisplaySliderMovementFadePeriodKey"))
  {
    CFTypeID v260 = CFNumberGetTypeID();
    if (v260 == CFGetTypeID(*(CFTypeRef *)(a1 + 40))
      && CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588))
    {
      *(float *)(*(void *)(a1 + 56) + 276) = v588;
      os_log_t v559 = 0;
      if (_logHandle)
      {
        uint64_t v259 = _logHandle;
      }
      else
      {
        uint64_t v258 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        uint64_t v259 = v258;
      }
      os_log_t v559 = v259;
      os_log_type_t v558 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v259, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v651, (uint64_t)"kIOHIDDisplaySliderMovementFadePeriodKey", COERCE__INT64(v588));
        _os_log_debug_impl(&dword_1BA438000, v559, v558, "DisplaySetProperty: %s = %f\n", v651, 0x16u);
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CPMSToggleHDRCap"))
  {
    CFTypeID v257 = CFBooleanGetTypeID();
    if (v257 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      BOOL v557 = 0;
      BOOL v557 = *(void *)(a1 + 40) == *MEMORY[0x1E4F1CFD0];
      if (v557)
      {
        *(unsigned char *)(*(void *)(a1 + 56) + 12081) = 0;
        *(unsigned char *)(*(void *)(a1 + 56) + 12082) = 0;
        __DisplayStartAPLCPMSTimer(*(dispatch_object_t **)(a1 + 56), 1.0);
      }
      else if (*(void *)(*(void *)(a1 + 56) + 12112))
      {
        __DisplayProcessHDRStatusForCoreAnalytics(*(void *)(a1 + 56));
        dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 56) + 12112));
        *(void *)(*(void *)(a1 + 56) + 12112) = 0;
        *(void *)(*(void *)(a1 + 56) + 12088) = 0;
        *(void *)(*(void *)(a1 + 56) + 12096) = 0;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CPMSPowerAccumulator"))
  {
    uint64_t v552 = 0;
    v553 = &v552;
    int v554 = 0x20000000;
    int v555 = 32;
    uint64_t v556 = 0;
    if (DisplayHasDCP(*(void *)(a1 + 56)))
    {
      v548[0] = 0;
      v548[1] = v548;
      int v549 = 0x20000000;
      int v550 = 32;
      uint64_t v551 = 0;
      float v3 = *(NSObject **)(*(void *)(a1 + 56) + 152);
      uint64_t v540 = MEMORY[0x1E4F143A8];
      int v541 = -1073741824;
      int v542 = 0;
      v543 = __DisplaySetProperty_block_invoke_456;
      v544 = &unk_1E621A540;
      v545 = &v552;
      uint64_t v547 = *(void *)(a1 + 56);
      v546 = v548;
      dispatch_sync(v3, &v540);
      _Block_object_dispose(v548, 8);
    }
    else
    {
      v553[3] = __DisplayGetPowerAccumulator(*(void *)(a1 + 56));
    }
    CFNumberRef v539 = 0;
    CFNumberRef v539 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberLongLongType, v553 + 3);
    if (v539)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 192), @"CPMSPowerAccumulatorValue", v539);
      CFRelease(v539);
    }
    _Block_object_dispose(&v552, 8);
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CoreBrightnessBDMEnabled"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v256 = CFNumberGetTypeID();
      if (v256 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        int v538 = 0;
        int v538 = *(unsigned char *)(*(void *)(a1 + 56) + 1176) & 1;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v538);
        *(unsigned char *)(*(void *)(a1 + 56) + 1176) = v538 != 0;
        os_log_t v537 = 0;
        if (_logHandle)
        {
          CFTypeID v255 = _logHandle;
        }
        else
        {
          uint64_t v254 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          CFTypeID v255 = v254;
        }
        os_log_t v537 = v255;
        os_log_type_t v536 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v255, OS_LOG_TYPE_DEBUG))
        {
          if (v538) {
            float v4 = "enabled";
          }
          else {
            float v4 = "disabled";
          }
          __os_log_helper_16_2_1_8_32((uint64_t)v650, (uint64_t)v4);
          _os_log_debug_impl(&dword_1BA438000, v537, v536, "BrightDotMitigation %s", v650, 0xCu);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayInitialBrightness"))
  {
    CFTypeID v253 = CFNumberGetTypeID();
    if (v253 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      float v588 = *(float *)(*(void *)(a1 + 56) + 336);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
      os_log_t v535 = 0;
      if (_logHandle)
      {
        CFTypeID v252 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v251 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v251 = init_default_corebrightness_log();
        }
        CFTypeID v252 = v251;
      }
      os_log_t v535 = v252;
      os_log_type_t v534 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v252, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v649, (uint64_t)"DisplayInitialBrightness", COERCE__INT64(v588));
        _os_log_debug_impl(&dword_1BA438000, v535, v534, "DisplaySetProperty: %s = %f\n", v649, 0x16u);
      }
      if (*(float *)(*(void *)(a1 + 56) + 348) == 0.0)
      {
        _DisplaySetBrightness(*(void *)(a1 + 56), v588);
      }
      else if (*(double *)(*(void *)(a1 + 56) + 1384) != 0.0 && *(float *)(*(void *)(a1 + 56) + 1400) == 0.0)
      {
        *(float *)(*(void *)(a1 + 56) + 12496) = v588;
        *(_DWORD *)(*(void *)(a1 + 56) + 12500) = 4096;
      }
    }
    else
    {
      CFTypeID v250 = CFDictionaryGetTypeID();
      if (v250 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        CFTypeRef v533 = 0;
        CFTypeRef v533 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"Brightness");
        v532 = 0;
        v532 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"Commit");
        if (v533)
        {
          CFTypeID v249 = CFGetTypeID(v533);
          if (v249 == CFNumberGetTypeID())
          {
            float v588 = *(float *)(*(void *)(a1 + 56) + 336);
            CFNumberGetValue((CFNumberRef)v533, kCFNumberFloatType, &v588);
            os_log_t v531 = 0;
            if (_logHandle)
            {
              uint64_t v248 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v247 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v247 = init_default_corebrightness_log();
              }
              uint64_t v248 = v247;
            }
            os_log_t v531 = v248;
            os_log_type_t v530 = OS_LOG_TYPE_DEBUG;
            if (os_log_type_enabled(v248, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_2_2_8_32_8_0((uint64_t)v648, (uint64_t)"DisplayInitialBrightness", COERCE__INT64(v588));
              _os_log_debug_impl(&dword_1BA438000, v531, v530, "DisplaySetProperty: %s = %f\n", v648, 0x16u);
            }
            if (*(float *)(*(void *)(a1 + 56) + 348) == 0.0)
            {
              if (v532 == (const void *)*MEMORY[0x1E4F1CFD0]) {
                unsigned int v5 = 4096;
              }
              else {
                unsigned int v5 = 0;
              }
              __DisplaySetBrightness(*(void *)(a1 + 56), v5, v588);
            }
            else if (*(double *)(*(void *)(a1 + 56) + 1384) != 0.0 {
                   && *(float *)(*(void *)(a1 + 56) + 1400) == 0.0)
            }
            {
              *(float *)(*(void *)(a1 + 56) + 12496) = v588;
              if (v532 == (const void *)*MEMORY[0x1E4F1CFD0]) {
                int v6 = 4096;
              }
              else {
                int v6 = 0;
              }
              *(_DWORD *)(*(void *)(a1 + 56) + 12500) = v6;
            }
          }
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AmbientAdaptiveDimming"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v246 = CFDictionaryGetTypeID();
      if (v246 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        int v529 = 0;
        CFNumberRef v528 = 0;
        CFNumberRef v528 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"AmbientAdaptiveDimmingEnable");
        if (v528)
        {
          CFTypeID v245 = CFNumberGetTypeID();
          if (v245 == CFGetTypeID(v528)) {
            CFNumberGetValue(v528, kCFNumberIntType, &v529);
          }
        }
        float v527 = 0.0;
        CFNumberRef v526 = 0;
        CFNumberRef v526 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"AmbientAdaptiveDimmingPeriod");
        if (v526)
        {
          CFTypeID v244 = CFNumberGetTypeID();
          if (v244 == CFGetTypeID(v526)) {
            CFNumberGetValue(v526, kCFNumberFloatType, &v527);
          }
        }
        os_log_t v525 = 0;
        if (_logHandle)
        {
          CFTypeID v243 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v242 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v242 = init_default_corebrightness_log();
          }
          CFTypeID v243 = v242;
        }
        os_log_t v525 = v243;
        os_log_type_t v524 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v647, v529, COERCE__INT64(v527));
          _os_log_impl(&dword_1BA438000, v525, v524, "AutoDim request received with enable:%i, period:%f", v647, 0x12u);
        }
        if (*(_DWORD *)(*(void *)(a1 + 56) + 228) != v529)
        {
          *(_DWORD *)(*(void *)(a1 + 56) + 228) = v529;
          float v523 = 0.0;
          if (v529) {
            float v241 = 100.0;
          }
          else {
            float v241 = *(float *)(*(void *)(a1 + 56) + 1312);
          }
          float v523 = v241;
          _DisplaySetAdaptiveDimmingLimitWithFade(*(void *)(a1 + 56), v241, v527);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"UserInteractedWithUI"))
  {
    if (*(_DWORD *)(*(void *)(a1 + 56) + 36))
    {
      __DisplayUpdateAmbientProperties(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 336));
      float v522 = 0.0;
      float v522 = __DisplayCalculateBrightnessAtAmbient(*(float **)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 1184));
      __DisplaySetLogicalBrightnessLegacy(*(float **)(a1 + 56), 2u, v522, -1.0);
      os_log_t v521 = 0;
      if (_logHandle)
      {
        int v240 = _logHandle;
      }
      else
      {
        uint64_t v239 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        int v240 = v239;
      }
      os_log_t v521 = v240;
      os_log_type_t v520 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v240, OS_LOG_TYPE_DEBUG))
      {
        if (*(float *)(*(void *)(a1 + 56) + 1204) == 0.0) {
          CFIndex v7 = "false";
        }
        else {
          CFIndex v7 = "true";
        }
        __os_log_helper_16_2_2_8_32_8_32((uint64_t)v646, (uint64_t)"UserInteractedWithUI", (uint64_t)v7);
        _os_log_debug_impl(&dword_1BA438000, v521, v520, "DisplaySetProperty: %s = %s\n", v646, 0x16u);
      }
    }
    *(unsigned char *)(*(void *)(a1 + 56) + 584) = 1;
    v519 = 0;
    if (_logHandle)
    {
      os_log_t v238 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v237 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v237 = init_default_corebrightness_log();
      }
      os_log_t v238 = v237;
    }
    v519 = v238;
    os_log_type_t v518 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v238, OS_LOG_TYPE_DEFAULT))
    {
      double v235 = v519;
      os_log_type_t v236 = v518;
      __os_log_helper_16_0_0(v517);
      _os_log_impl(&dword_1BA438000, v235, v236, "Weak cap: user interacted\n", v517, 2u);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessAuto"))
  {
    char CFBooleanValue = GetCFBooleanValue(*(const __CFNumber **)(a1 + 40));
    double v8 = 1.0;
    if (!CFBooleanValue) {
      double v8 = 0.0;
    }
    float v9 = v8;
    float v588 = v9;
    if (v9 == 1.0 && !(MGGetBoolAnswer() & 1))
    {
      float v515 = 0;
      if (_logHandle)
      {
        os_log_t v233 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v232 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v232 = init_default_corebrightness_log();
        }
        os_log_t v233 = v232;
      }
      float v515 = v233;
      char v514 = 16;
      if (os_log_type_enabled(v233, OS_LOG_TYPE_ERROR))
      {
        uint64_t v230 = v515;
        os_log_type_t v231 = v514;
        __os_log_helper_16_0_0(v513);
        _os_log_error_impl(&dword_1BA438000, v230, v231, "Refuse to turn on AAB without ALS", v513, 2u);
      }
      float v588 = 0.0;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
    if (v588 != *(float *)(*(void *)(a1 + 56) + 1204))
    {
      CFMutableDictionaryRef theDict = *(__CFDictionary **)(*(void *)(a1 + 56) + 192);
      if (v588 == 0.0) {
        CFDictionarySetValue(theDict, @"DisplayBrightnessAuto", (const void *)*MEMORY[0x1E4F1CFC8]);
      }
      else {
        CFDictionarySetValue(theDict, @"DisplayBrightnessAuto", (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      *(float *)(*(void *)(a1 + 56) + 1204) = v588;
      __DisplayUpdateAmbientProperties(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 336));
      if (*(_DWORD *)(*(void *)(a1 + 56) + 36))
      {
        float v512 = 0.0;
        float v512 = __DisplayCalculateBrightnessAtAmbient(*(float **)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 1184));
        __DisplaySetLogicalBrightnessLegacy(*(float **)(a1 + 56), 2u, v512, -1.0);
        os_log_t v511 = 0;
        if (_logHandle)
        {
          int v228 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v227 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v227 = init_default_corebrightness_log();
          }
          int v228 = v227;
        }
        os_log_t v511 = v228;
        os_log_type_t v510 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v228, OS_LOG_TYPE_DEFAULT))
        {
          if (*(float *)(*(void *)(a1 + 56) + 1204) == 0.0) {
            uint64_t v10 = "false";
          }
          else {
            uint64_t v10 = "true";
          }
          __os_log_helper_16_2_2_8_32_8_32((uint64_t)v645, (uint64_t)"DisplayBrightnessAuto", (uint64_t)v10);
          _os_log_impl(&dword_1BA438000, v511, v510, "DisplaySetProperty: %s = %s\n", v645, 0x16u);
        }
      }
      else
      {
        *(_DWORD *)(*(void *)(a1 + 56) + 40) = v588 < 1.0;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"kCoreBrightnessDisplayPresetNitsOverride"))
  {
    float v509 = 0.0;
    [*(id *)(a1 + 40) floatValue];
    float v509 = v11;
    if (v11 == 0.0)
    {
      *(unsigned char *)(*(void *)(a1 + 56) + 1144) = 0;
    }
    else
    {
      *(float *)(*(void *)(a1 + 56) + 1148) = v509;
      *(unsigned char *)(*(void *)(a1 + 56) + 1144) = 1;
      __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 56), 28682, *(float *)(*(void *)(a1 + 56) + 1256));
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"ClientBrightnessOverride"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v226 = CFDictionaryGetTypeID();
      if (v226 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        Boolean v508 = 0;
        CFBooleanRef v507 = 0;
        CFBooleanRef v507 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"ClientBrightnessOverrideEnable");
        if (v507)
        {
          CFTypeID v225 = CFBooleanGetTypeID();
          if (v225 == CFGetTypeID(v507)) {
            Boolean v508 = CFBooleanGetValue(v507);
          }
        }
        CFNumberRef v506 = 0;
        CFNumberRef v506 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"ClientBrightnessOverrideNits");
        if (v506)
        {
          CFTypeID v224 = CFNumberGetTypeID();
          if (v224 == CFGetTypeID(v506)) {
            CFNumberGetValue(v506, kCFNumberFloatType, &v588);
          }
        }
        int v505 = 0;
        CFNumberRef v504 = 0;
        CFNumberRef v504 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"ClientBrightnessOverrideType");
        if (v504)
        {
          CFTypeID v223 = CFNumberGetTypeID();
          if (v223 == CFGetTypeID(v504)) {
            CFNumberGetValue(v504, kCFNumberIntType, &v505);
          }
        }
        setClientOverrideState(*(void *)(a1 + 56), v505, v508 != 0);
        if (v505)
        {
          if (v505 == 1) {
            *(float *)(*(void *)(a1 + 56) + 968) = v588;
          }
        }
        else
        {
          *(float *)(*(void *)(a1 + 56) + 964) = v588;
        }
        unsigned int v503 = 0;
        unsigned int v503 = evaluateClientOverrides(*(void *)(a1 + 56));
        if (v503)
        {
          uint64_t v13 = v503;
          char v12 = 1;
        }
        else
        {
          uint64_t v13 = 0;
          char v12 = 0;
        }
        if ((v12 & 1) == 0)
        {
          switch(v13)
          {
            case 0:
              break;
            case 1:
              _DisplaySetBrightnessMinPhysicalWithFade(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 968), 0.0);
              break;
            case 2:
              _DisplaySetBrightnessMinPhysicalWithFade(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 964), 0.0);
              break;
            case 3:
              _DisplaySetBrightnessMinPhysicalWithFade(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 1532), 0.0);
              *(_DWORD *)(*(void *)(a1 + 56) + 400) = *(_DWORD *)(*(void *)(a1 + 56) + 396);
              *(unsigned char *)(*(void *)(a1 + 56) + 960) = 0;
              *(_DWORD *)(*(void *)(a1 + 56) + 964) = 0;
              *(_DWORD *)(*(void *)(a1 + 56) + 968) = 0;
              break;
            default:
              JUMPOUT(0);
          }
        }
        __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 56), 12298, *(float *)(*(void *)(a1 + 56) + 1256));
        os_log_t v502 = 0;
        if (_logHandle)
        {
          CFTypeID v222 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v221 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v221 = init_default_corebrightness_log();
          }
          CFTypeID v222 = v221;
        }
        os_log_t v502 = v222;
        os_log_type_t v501 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v222, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_2_6_8_32_4_0_8_0_8_0_8_0_8_0((uint64_t)v644, (uint64_t)"ClientBrightnessOverride", *(unsigned __int8 *)(*(void *)(a1 + 56) + 960), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 964)), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 968)), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 396)), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 400)));
          _os_log_debug_impl(&dword_1BA438000, v502, v501, "DisplaySetProperty: %s activeFlags = %#x overrideL = %f overrideLmin = %f Lmin = %f Lmindouble Current = %f", v644, 0x3Au);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"ForceModuleUpdate"))
  {
    os_log_t v500 = 0;
    if (_logHandle)
    {
      int v220 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v219 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v219 = init_default_corebrightness_log();
      }
      int v220 = v219;
    }
    os_log_t v500 = v220;
    os_log_type_t v499 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v220, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v643, (uint64_t)"ForceModuleUpdate");
      _os_log_debug_impl(&dword_1BA438000, v500, v499, "DisplaySetProperty: %s\n", v643, 0xCu);
    }
    __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 56), 12298, *(float *)(*(void *)(a1 + 56) + 1256));
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessMin"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 340);
    CFTypeID v218 = CFNumberGetTypeID();
    if (v218 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
    if (v588 != *(float *)(*(void *)(a1 + 56) + 340))
    {
      *(float *)(*(void *)(a1 + 56) + 340) = v588;
      os_log_t v498 = 0;
      if (_logHandle)
      {
        int v217 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v216 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v216 = init_default_corebrightness_log();
        }
        int v217 = v216;
      }
      os_log_t v498 = v217;
      os_log_type_t v497 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v217, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v642, (uint64_t)"DisplayBrightnessMin", COERCE__INT64(v588));
        _os_log_debug_impl(&dword_1BA438000, v498, v497, "DisplaySetProperty: %s = %f\n", v642, 0x16u);
      }
      _DisplaySetBrightness(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 336));
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessMax"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 344);
    CFTypeID v215 = CFNumberGetTypeID();
    if (v215 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
    if (v588 != *(float *)(*(void *)(a1 + 56) + 344))
    {
      *(float *)(*(void *)(a1 + 56) + 344) = v588;
      os_log_t v496 = 0;
      if (_logHandle)
      {
        int v214 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v213 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v213 = init_default_corebrightness_log();
        }
        int v214 = v213;
      }
      os_log_t v496 = v214;
      os_log_type_t v495 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v214, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v641, (uint64_t)"DisplayBrightnessMax", COERCE__INT64(v588));
        _os_log_debug_impl(&dword_1BA438000, v496, v495, "DisplaySetProperty: %s = %f\n", v641, 0x16u);
      }
      _DisplaySetBrightness(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 336));
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessAutoWeightMax"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 1200);
    CFTypeID v212 = CFNumberGetTypeID();
    if (v212 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
    if (v588 != *(float *)(*(void *)(a1 + 56) + 1200))
    {
      *(float *)(*(void *)(a1 + 56) + 1200) = v588;
      __DisplayUpdateAmbientProperties(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 336));
      _DisplaySetAmbient(*(void *)(a1 + 56), 0, *(float *)(*(void *)(a1 + 56) + 1184));
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessAutoWeightMin"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 1196);
    CFTypeID v211 = CFNumberGetTypeID();
    if (v211 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
    if (v588 != *(float *)(*(void *)(a1 + 56) + 1196))
    {
      *(float *)(*(void *)(a1 + 56) + 1196) = v588;
      __DisplayUpdateAmbientProperties(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 336));
      _DisplaySetAmbient(*(void *)(a1 + 56), 0, *(float *)(*(void *)(a1 + 56) + 1184));
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"IOHIDDisplayHandleAmbient"))
  {
    *(_DWORD *)(*(void *)(a1 + 56) + 36) = GetCFBooleanValue(*(const __CFNumber **)(a1 + 40));
    if (*(_DWORD *)(*(void *)(a1 + 56) + 36)) {
      pthread_once(&__displayThreadInit, (void (*)(void))__DisplayBrightnessThreadInit);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"EcoMode"))
  {
    if (!*(_DWORD *)(*(void *)(a1 + 56) + 36))
    {
      CFTypeID v210 = CFBooleanGetTypeID();
      if (v210 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        int v494 = 0;
        int v494 = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 40));
        if (*(_DWORD *)(*(void *)(a1 + 56) + 220) != v494)
        {
          *(_DWORD *)(*(void *)(a1 + 56) + 220) = v494;
          int v209 = *(_DWORD *)(*(void *)(a1 + 56) + 640);
          if (v209)
          {
            if (v209 == 1)
            {
              float v493 = 0.0;
              if (*(_DWORD *)(*(void *)(a1 + 56) + 220)) {
                double v208 = *(double *)(*(void *)(a1 + 56) + 656);
              }
              else {
                double v208 = 1.0;
              }
              float v14 = v208;
              float v493 = v14;
              _DisplaySetBrightnessEcoModeFactorWithFade(*(void *)(a1 + 56), v14, 0.5);
            }
            else if (v209 == 2)
            {
              float v492 = 0.0;
              if (*(_DWORD *)(*(void *)(a1 + 56) + 220)) {
                float v207 = *(float *)(*(void *)(a1 + 56) + 776);
              }
              else {
                float v207 = *(float *)(*(void *)(a1 + 56) + 1312);
              }
              float v492 = v207;
              _DisplaySetBrightnessEcoModeLimitWithFade(*(void *)(a1 + 56), v207, 0.5);
            }
            else
            {
              os_log_t v488 = (os_log_t)_logHandle;
              os_log_type_t v487 = OS_LOG_TYPE_FAULT;
              if (os_log_type_enabled((os_log_t)_logHandle, OS_LOG_TYPE_FAULT))
              {
                __os_log_helper_16_0_1_4_0((uint64_t)v640, *(_DWORD *)(*(void *)(a1 + 56) + 640));
                _os_log_fault_impl(&dword_1BA438000, v488, v487, "Unexpected eco mode behaviour = %d, ignoring", v640, 8u);
              }
            }
          }
          else
          {
            uint64_t v491 = 0;
            if (_logHandle)
            {
              int v206 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v205 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v205 = init_default_corebrightness_log();
              }
              int v206 = v205;
            }
            uint64_t v491 = v206;
            char v490 = 2;
            if (os_log_type_enabled(v206, OS_LOG_TYPE_DEBUG))
            {
              float v203 = v491;
              os_log_type_t v204 = v490;
              __os_log_helper_16_0_0(v489);
              _os_log_debug_impl(&dword_1BA438000, v203, v204, "Eco mode is not enabled on this device - ignoring", v489, 2u);
            }
          }
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"EcoModeFactorUpdate"))
  {
    if (!*(_DWORD *)(*(void *)(a1 + 56) + 36))
    {
      if (*(void *)(a1 + 40))
      {
        CFTypeID v202 = CFNumberGetTypeID();
        if (v202 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
        {
          double v486 = 0.0;
          CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberDoubleType, &v486);
          *(double *)(*(void *)(a1 + 56) + 656) = 1.0 - v486 / 100.0;
          if (*(_DWORD *)(*(void *)(a1 + 56) + 220))
          {
            float v15 = *(double *)(*(void *)(a1 + 56) + 656);
            _DisplaySetBrightnessEcoModeFactorWithFade(*(void *)(a1 + 56), v15, 0.5);
          }
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DominoStateUpdate"))
  {
    CFTypeID v201 = CFBooleanGetTypeID();
    if (v201 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      int v485 = 0;
      int v485 = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 40));
      if (*(_DWORD *)(*(void *)(a1 + 56) + 224) != v485)
      {
        *(_DWORD *)(*(void *)(a1 + 56) + 224) = v485;
        os_log_t v484 = 0;
        if (_logHandle)
        {
          int v200 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v199 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v199 = init_default_corebrightness_log();
          }
          int v200 = v199;
        }
        os_log_t v484 = v200;
        os_log_type_t v483 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v200, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_4_0((uint64_t)v639, v485);
          _os_log_impl(&dword_1BA438000, v484, v483, "Domino State Change: %d", v639, 8u);
        }
        float v482 = 0.0;
        if (*(_DWORD *)(*(void *)(a1 + 56) + 224)) {
          float v198 = *(float *)(*(void *)(a1 + 56) + 720);
        }
        else {
          float v198 = *(float *)(*(void *)(a1 + 56) + 1312);
        }
        float v482 = v198;
        _DisplaySetBrightnessDominoModeLimitWithFade(*(void *)(a1 + 56), v198, 0.5);
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessFactor"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 348);
    CFTypeID v197 = CFNumberGetTypeID();
    if (v197 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
    __DisplayCancelFactorFade(*(void *)(a1 + 56));
    if (v588 != *(float *)(*(void *)(a1 + 56) + 348))
    {
      _DisplayUpdateWeakCapOnFactorChange(*(void *)(a1 + 56), v588);
      _DisplaySetBrightnessFactor(*(void *)(a1 + 56), v588);
      if (*(_DWORD *)(*(void *)(a1 + 56) + 36))
      {
        uint64_t v195 = *(void *)(a1 + 56);
        float v196 = __DisplayCalculateBrightnessFromFactorChange(v195, *(_DWORD *)(v195 + 204));
        __DisplaySetLogicalBrightnessLegacy((float *)v195, 7u, v196, 0.0);
        *(_DWORD *)(*(void *)(a1 + 56) + 356) = *(_DWORD *)(*(void *)(a1 + 56) + 352);
      }
      else
      {
        int v481 = 4098;
        if (*(float *)(*(void *)(a1 + 56) + 348) == 1.0) {
          v481 |= 8u;
        }
        float v480 = 0.0;
        float v480 = *(float *)(*(void *)(a1 + 56) + 1252);
        float v479 = 0.0;
        float v479 = *(float *)(*(void *)(a1 + 56) + 1492);
        if (*(float *)(*(void *)(a1 + 56) + 348) <= 0.0)
        {
          if (*(unsigned char *)(*(void *)(a1 + 56) + 12282)) {
            __DisplayCancelAAPFade(*(unsigned char **)(a1 + 56));
          }
          else {
            __DisplayCancelReflectedBrightnessFadeInternal(*(void *)(a1 + 56));
          }
          *(_DWORD *)(*(void *)(a1 + 56) + 12300) = 0;
        }
        else
        {
          float v480 = fmaxf(v480, *(float *)(*(void *)(a1 + 56) + 1320));
          float v479 = fmaxf(v479, *(float *)(*(void *)(a1 + 56) + 1320));
          *(float *)(*(void *)(a1 + 56) + 1488) = v479;
        }
        os_log_t v478 = 0;
        if (_logHandle)
        {
          int v194 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v193 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v193 = init_default_corebrightness_log();
          }
          int v194 = v193;
        }
        os_log_t v478 = v194;
        os_log_type_t v477 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_4_8_32_8_0_8_0_8_0((uint64_t)v638, (uint64_t)"DisplayBrightnessFactor", COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 348)), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 1252)), COERCE__INT64(v480));
          _os_log_impl(&dword_1BA438000, v478, v477, "%s = %f Lpending: %f L_logical: %f", v638, 0x2Au);
        }
        __DisplaySetLogicalBrightnessWithFadeInternal(*(void *)(a1 + 56), v481 | 0x2000, 0, 0, v480, 0.0);
        *(_DWORD *)(*(void *)(a1 + 56) + 12392) = 0;
        os_log_t v476 = 0;
        if (_logHandle)
        {
          int v192 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v191 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v191 = init_default_corebrightness_log();
          }
          int v192 = v191;
        }
        os_log_t v476 = v192;
        os_log_type_t v475 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v637, (uint64_t)"Factor", COERCE__INT64(v588), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 1260)));
          _os_log_impl(&dword_1BA438000, v476, v475, "[BRT update: %s]: value = %f, nits = %f", v637, 0x20u);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"MinNits"))
  {
    CFTypeID v190 = CFDictionaryGetTypeID();
    if (v190 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      float v474 = 0.0;
      float v474 = *(float *)(*(void *)(a1 + 56) + 1256);
      float v473 = 0.0;
      CFNumberRef v472 = 0;
      CFNumberRef v472 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"period");
      if (v472)
      {
        CFTypeID v189 = CFNumberGetTypeID();
        if (v189 == CFGetTypeID(v472)) {
          CFNumberGetValue(v472, kCFNumberFloatType, &v473);
        }
      }
      CFNumberRef v471 = 0;
      CFNumberRef v471 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"nits");
      if (v471)
      {
        CFTypeID v188 = CFNumberGetTypeID();
        if (v188 == CFGetTypeID(v471)) {
          CFNumberGetValue(v471, kCFNumberFloatType, &v474);
        }
      }
      if (getClientOverrideState(*(void *)(a1 + 56), 1)) {
        float v474 = fmaxf(v474, *(float *)(*(void *)(a1 + 56) + 968));
      }
      _DisplaySetBrightnessMinPhysicalWithFade(*(void *)(a1 + 56), v474, v473);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessFactorWithFade"))
  {
    kdebug_trace();
    float v588 = *(float *)(*(void *)(a1 + 56) + 348);
    CFTypeID v187 = CFDictionaryGetTypeID();
    if (v187 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      CFNumberRef v470 = 0;
      CFNumberRef v470 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"DisplayBrightnessFadePeriod");
      if (v470)
      {
        CFTypeID v186 = CFNumberGetTypeID();
        if (v186 == CFGetTypeID(v470)) {
          CFNumberGetValue(v470, kCFNumberFloat32Type, (void *)(*(void *)(a1 + 56) + 372));
        }
      }
      CFNumberRef v469 = 0;
      CFNumberRef v469 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"DisplayBrightnessFactor");
      if (v469)
      {
        CFTypeID v185 = CFNumberGetTypeID();
        if (v185 == CFGetTypeID(v469))
        {
          CFNumberGetValue(v469, kCFNumberFloat32Type, &v588);
          BOOL v468 = 0;
          BOOL v468 = *(double *)(*(void *)(a1 + 56) + 1384) > 0.0;
          if (v588 != *(float *)(*(void *)(a1 + 56) + 348) || v468)
          {
            if (*(_DWORD *)(*(void *)(a1 + 56) + 36))
            {
              _DisplaySetBrightnessFactor(*(void *)(a1 + 56), v588);
              uint64_t v183 = *(void *)(a1 + 56);
              float v184 = __DisplayCalculateBrightnessFromFactorChange(v183, *(_DWORD *)(v183 + 204));
              __DisplaySetLogicalBrightnessLegacy((float *)v183, 6u, v184, *(float *)(*(void *)(a1 + 56) + 372));
              *(_DWORD *)(*(void *)(a1 + 56) + 356) = *(_DWORD *)(*(void *)(a1 + 56) + 352);
            }
            else
            {
              if (v588 == 0.0)
              {
                if (*(unsigned char *)(*(void *)(a1 + 56) + 12282)) {
                  __DisplayCancelAAPFade(*(unsigned char **)(a1 + 56));
                }
                else {
                  __DisplayCancelReflectedBrightnessFadeInternal(*(void *)(a1 + 56));
                }
                if ((*(unsigned char *)(*(void *)(a1 + 56) + 12282) & 1) == 0) {
                  *(_DWORD *)(*(void *)(a1 + 56) + 12392) = 0;
                }
                *(_DWORD *)(*(void *)(a1 + 56) + 12300) = 0;
              }
              _DisplayUpdateWeakCapOnFactorChange(*(void *)(a1 + 56), v588);
              _DisplaySetFactorWithFade(*(void *)(a1 + 56), v588, *(float *)(*(void *)(a1 + 56) + 372));
              os_log_t v467 = 0;
              if (_logHandle)
              {
                v182 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT) {
                  uint64_t v181 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else {
                  uint64_t v181 = init_default_corebrightness_log();
                }
                v182 = v181;
              }
              os_log_t v467 = v182;
              os_log_type_t v466 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v182, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v636, (uint64_t)"Factor", COERCE__INT64(v588), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 372)));
                _os_log_impl(&dword_1BA438000, v467, v466, "[BRT update: %s]: value = %f with fade period = %f", v636, 0x20u);
              }
            }
            *(_DWORD *)(*(void *)(a1 + 56) + 356) = *(_DWORD *)(*(void *)(a1 + 56) + 352);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 192), @"DisplayBrightnessFactor", v469);
          }
        }
      }
    }
    else
    {
      CFTypeID v180 = CFNumberGetTypeID();
      if (v180 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
        BOOL v465 = 0;
        BOOL v465 = *(double *)(*(void *)(a1 + 56) + 1384) > 0.0;
        if (v588 != *(float *)(*(void *)(a1 + 56) + 348) || v465)
        {
          if (*(_DWORD *)(*(void *)(a1 + 56) + 36))
          {
            _DisplaySetBrightnessFactor(*(void *)(a1 + 56), v588);
            uint64_t v178 = *(void *)(a1 + 56);
            float v179 = __DisplayCalculateBrightnessFromFactorChange(v178, *(_DWORD *)(v178 + 204));
            __DisplaySetLogicalBrightnessLegacy((float *)v178, 6u, v179, *(float *)(*(void *)(a1 + 56) + 372));
            *(_DWORD *)(*(void *)(a1 + 56) + 356) = *(_DWORD *)(*(void *)(a1 + 56) + 352);
          }
          else
          {
            if (v588 == 0.0)
            {
              if (*(unsigned char *)(*(void *)(a1 + 56) + 12282)) {
                __DisplayCancelAAPFade(*(unsigned char **)(a1 + 56));
              }
              else {
                __DisplayCancelReflectedBrightnessFadeInternal(*(void *)(a1 + 56));
              }
              *(_DWORD *)(*(void *)(a1 + 56) + 12300) = 0;
              if ((*(unsigned char *)(*(void *)(a1 + 56) + 12282) & 1) == 0) {
                *(_DWORD *)(*(void *)(a1 + 56) + 12392) = 0;
              }
            }
            _DisplayUpdateWeakCapOnFactorChange(*(void *)(a1 + 56), v588);
            _DisplaySetFactorWithFade(*(void *)(a1 + 56), v588, *(float *)(*(void *)(a1 + 56) + 372));
            os_log_t v464 = 0;
            if (_logHandle)
            {
              double v177 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v176 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v176 = init_default_corebrightness_log();
              }
              double v177 = v176;
            }
            os_log_t v464 = v177;
            os_log_type_t v463 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v177, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v635, (uint64_t)"Factor", COERCE__INT64(v588), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 372)));
              _os_log_impl(&dword_1BA438000, v464, v463, "[BRT update: %s]: value = %f with fade period = %f", v635, 0x20u);
            }
          }
          *(_DWORD *)(*(void *)(a1 + 56) + 356) = *(_DWORD *)(*(void *)(a1 + 56) + 352);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 192), @"DisplayBrightnessFactor", *(const void **)(a1 + 40));
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessFadePeriod"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 372);
    CFTypeID v175 = CFNumberGetTypeID();
    if (v175 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
    *(float *)(*(void *)(a1 + 56) + 372) = v588;
    os_log_t v462 = 0;
    if (_logHandle)
    {
      v174 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v173 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v173 = init_default_corebrightness_log();
      }
      v174 = v173;
    }
    os_log_t v462 = v174;
    os_log_type_t v461 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_2_8_32_8_0((uint64_t)v634, (uint64_t)"DisplayBrightnessFadePeriod", COERCE__INT64(v588));
      _os_log_debug_impl(&dword_1BA438000, v462, v461, "DisplaySetProperty: %s = %f\n", v634, 0x16u);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"LogLevel"))
  {
    int v460 = 0;
    int v460 = *(_DWORD *)(*(void *)(a1 + 56) + 200);
    CFTypeID v172 = CFNumberGetTypeID();
    if (v172 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v460);
    os_log_t v459 = 0;
    if (_logHandle)
    {
      os_log_t v171 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v170 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v170 = init_default_corebrightness_log();
      }
      os_log_t v171 = v170;
    }
    os_log_t v459 = v171;
    os_log_type_t v458 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v171, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v633, (uint64_t)"LogLevel", v460);
      _os_log_impl(&dword_1BA438000, v459, v458, "DisplaySetProperty: %s = %x\n", v633, 0x12u);
    }
    if (*(_DWORD *)(*(void *)(a1 + 56) + 200) != v460) {
      *(_DWORD *)(*(void *)(a1 + 56) + 200) = v460;
    }
    __DisplaySetBLDriverProperty(*(void *)(a1 + 56), *(const __CFString **)(a1 + 48), *(const void **)(a1 + 40));
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"PLCEnable"))
  {
    BOOL v457 = 0;
    BOOL v457 = (*(unsigned char *)(*(void *)(a1 + 56) + 288) & 1) != 0;
    CFTypeID v169 = CFNumberGetTypeID();
    if (v169 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v457);
    if (v457)
    {
      if (*(_DWORD *)(*(void *)(a1 + 56) + 284)
        && *(float *)(*(void *)(a1 + 56) + 1260) > (float)*(unsigned int *)(*(void *)(a1 + 56) + 284))
      {
        __DisplaySendPLCUpdate(*(void *)(a1 + 56), 1);
      }
    }
    else if (*(unsigned char *)(*(void *)(a1 + 56) + 289))
    {
      __DisplaySendPLCUpdate(*(void *)(a1 + 56), 0);
      int v456 = 0;
      int v456 = (int)(*(float *)(*(void *)(a1 + 56) + 1260) * 65536.0);
      SetBLDriverNitsValueIfNotInLPM(*(void *)(a1 + 56), v456);
    }
    *(unsigned char *)(*(void *)(a1 + 56) + 288) = v457;
    os_log_t v455 = 0;
    if (_logHandle)
    {
      os_log_t v168 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v167 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v167 = init_default_corebrightness_log();
      }
      os_log_t v168 = v167;
    }
    os_log_t v455 = v168;
    os_log_type_t v454 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v168, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v632, *(unsigned char *)(*(void *)(a1 + 56) + 288) & 1);
      _os_log_impl(&dword_1BA438000, v455, v454, "PLCEnabled=%d", v632, 8u);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessFadeSlope"))
  {
    CFTypeID v166 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v166 == CFNumberGetTypeID())
    {
      float v453 = 0.0;
      float v453 = *(float *)(*(void *)(a1 + 56) + 1228);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v453);
      os_log_t v452 = 0;
      if (_logHandle)
      {
        os_log_type_t v165 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v164 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v164 = init_default_corebrightness_log();
        }
        os_log_type_t v165 = v164;
      }
      os_log_t v452 = v165;
      os_log_type_t v451 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v631, COERCE__INT64(v453));
        _os_log_debug_impl(&dword_1BA438000, v452, v451, "display->brightness.als.duration.customSlope = %f\n", v631, 0xCu);
      }
      *(float *)(*(void *)(a1 + 56) + 1228) = v453;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayMedianFilterLength"))
  {
    CFTypeID v163 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v163 == CFNumberGetTypeID())
    {
      int v450 = 0;
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v450);
      if (v450 <= 50)
      {
        *(_DWORD *)(*(void *)(a1 + 56) + 12736) = v450;
        *(_DWORD *)(*(void *)(a1 + 56) + 12732) = 0;
        *(_DWORD *)(*(void *)(a1 + 56) + 12728) = 0;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CabalFactorOverride"))
  {
    CFTypeID v162 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v162 == CFNumberGetTypeID())
    {
      float v449 = -1.0;
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v449);
      DisplaySetCabalFactorOverride(*(void *)(a1 + 56), v449);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayAAPFactor"))
  {
    CFTypeID v161 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v161 == CFNumberGetTypeID())
    {
      float v448 = 0.0;
      float v448 = *(float *)(*(void *)(a1 + 56) + 12392);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v448);
      os_log_t v447 = 0;
      if (_logHandle)
      {
        os_log_t v160 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v159 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v159 = init_default_corebrightness_log();
        }
        os_log_t v160 = v159;
      }
      os_log_t v447 = v160;
      os_log_type_t v446 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v630, (uint64_t)"DisplayAAPFactor", COERCE__INT64(v448));
        _os_log_impl(&dword_1BA438000, v447, v446, "%s = %f\n", v630, 0x16u);
      }
      __DisplaySetAAPFactor(*(unsigned char **)(a1 + 56), v448);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayAAPFactorMin"))
  {
    CFTypeID v158 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v158 == CFNumberGetTypeID())
    {
      float v445 = 0.0;
      float v445 = *(float *)(*(void *)(a1 + 56) + 12456);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v445);
      os_log_t v444 = 0;
      if (_logHandle)
      {
        float v157 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v156 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v156 = init_default_corebrightness_log();
        }
        float v157 = v156;
      }
      os_log_t v444 = v157;
      os_log_type_t v443 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v629, (uint64_t)"DisplayAAPFactorMin", COERCE__INT64(v445));
        _os_log_impl(&dword_1BA438000, v444, v443, "%s = %f\n", v629, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12456) = v445;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayAAPFactorMax"))
  {
    CFTypeID v155 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v155 == CFNumberGetTypeID())
    {
      float v442 = 0.0;
      float v442 = *(float *)(*(void *)(a1 + 56) + 12460);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v442);
      os_log_t v441 = 0;
      if (_logHandle)
      {
        float v154 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v153 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v153 = init_default_corebrightness_log();
        }
        float v154 = v153;
      }
      os_log_t v441 = v154;
      os_log_type_t v440 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v628, (uint64_t)"DisplayAAPFactorMax", COERCE__INT64(v442));
        _os_log_impl(&dword_1BA438000, v441, v440, "%s = %f\n", v628, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12460) = v442;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPDBMin"))
  {
    CFTypeID v152 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v152 == CFNumberGetTypeID())
    {
      float v439 = 0.0;
      float v439 = *(float *)(*(void *)(a1 + 56) + 12256);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v439);
      os_log_t v438 = 0;
      if (_logHandle)
      {
        float v151 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v150 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v150 = init_default_corebrightness_log();
        }
        float v151 = v150;
      }
      os_log_t v438 = v151;
      os_log_type_t v437 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v627, (uint64_t)"AAPDBMin", COERCE__INT64(v439));
        _os_log_debug_impl(&dword_1BA438000, v438, v437, "%s = %f\n", v627, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12256) = v439;
      uint64_t v436 = 1;
      HIDWORD(v436) = *(_DWORD *)(*(void *)(a1 + 56) + 12304);
      __DisplayUpdateAAPStateInternal(*(void *)(a1 + 56), (uint64_t)&v436, 0);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPK_0"))
  {
    CFTypeID v149 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v149 == CFNumberGetTypeID())
    {
      float v435 = 0.0;
      float v435 = *(float *)(*(void *)(a1 + 56) + 12260);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v435);
      os_log_t v434 = 0;
      if (_logHandle)
      {
        float v148 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v147 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v147 = init_default_corebrightness_log();
        }
        float v148 = v147;
      }
      os_log_t v434 = v148;
      os_log_type_t v433 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v148, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v626, (uint64_t)"AAPK_0", COERCE__INT64(v435));
        _os_log_debug_impl(&dword_1BA438000, v434, v433, "%s = %f\n", v626, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12260) = v435;
      uint64_t v432 = 2;
      HIDWORD(v432) = *(_DWORD *)(*(void *)(a1 + 56) + 12300);
      __DisplayUpdateAAPStateInternal(*(void *)(a1 + 56), (uint64_t)&v432, 0);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPK_1"))
  {
    CFTypeID v146 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v146 == CFNumberGetTypeID())
    {
      float v431 = 0.0;
      float v431 = *(float *)(*(void *)(a1 + 56) + 12264);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v431);
      os_log_t v430 = 0;
      if (_logHandle)
      {
        os_log_type_t v145 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v144 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v144 = init_default_corebrightness_log();
        }
        os_log_type_t v145 = v144;
      }
      os_log_t v430 = v145;
      os_log_type_t v429 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v625, (uint64_t)"AAPK_1", COERCE__INT64(v431));
        _os_log_debug_impl(&dword_1BA438000, v430, v429, "%s = %f\n", v625, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12264) = v431;
      uint64_t v428 = 2;
      HIDWORD(v428) = *(_DWORD *)(*(void *)(a1 + 56) + 12300);
      __DisplayUpdateAAPStateInternal(*(void *)(a1 + 56), (uint64_t)&v428, 0);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPManualB"))
  {
    CFTypeID v143 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v143 == CFNumberGetTypeID())
    {
      BOOL v427 = 0;
      BOOL v427 = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 40)) != 0;
      os_log_t v426 = 0;
      if (_logHandle)
      {
        os_log_t v142 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v141 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v141 = init_default_corebrightness_log();
        }
        os_log_t v142 = v141;
      }
      os_log_t v426 = v142;
      os_log_type_t v425 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v142, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_4_0((uint64_t)v624, (uint64_t)"AAPManualB", v427);
        _os_log_debug_impl(&dword_1BA438000, v426, v425, "%s = %d\n", v624, 0x12u);
      }
      *(unsigned char *)(*(void *)(a1 + 56) + 12284) = v427;
      uint64_t v424 = 0;
      BYTE4(v424) = *(unsigned char *)(*(void *)(a1 + 56) + 1232) & 1;
      __DisplayUpdateAAPStateInternal(*(void *)(a1 + 56), (uint64_t)&v424, 0);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPHDRMode"))
  {
    CFTypeID v140 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v140 == CFBooleanGetTypeID())
    {
      BOOL v423 = 0;
      BOOL v423 = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 40)) != 0;
      os_log_t v422 = 0;
      if (_logHandle)
      {
        os_log_type_t v139 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v138 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v138 = init_default_corebrightness_log();
        }
        os_log_type_t v139 = v138;
      }
      os_log_t v422 = v139;
      os_log_type_t v421 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v139, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_4_0((uint64_t)v623, (uint64_t)"AAPHDRMode", v423);
        _os_log_debug_impl(&dword_1BA438000, v422, v421, "%s = %d\n", v623, 0x12u);
      }
      *(unsigned char *)(*(void *)(a1 + 56) + 12292) = v423;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPLuxDelta"))
  {
    CFTypeID v137 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v137 == CFNumberGetTypeID())
    {
      float v420 = 0.0;
      float v420 = *(float *)(*(void *)(a1 + 56) + 12268);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v420);
      os_log_t v419 = 0;
      if (_logHandle)
      {
        os_log_type_t v136 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v135 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v135 = init_default_corebrightness_log();
        }
        os_log_type_t v136 = v135;
      }
      os_log_t v419 = v136;
      os_log_type_t v418 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v622, (uint64_t)"AAPLuxDelta", COERCE__INT64(v420));
        _os_log_debug_impl(&dword_1BA438000, v419, v418, "%s = %f\n", v622, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12268) = v420;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPRampUpTime"))
  {
    CFTypeID v134 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v134 == CFNumberGetTypeID())
    {
      float v417 = 0.0;
      float v417 = *(float *)(*(void *)(a1 + 56) + 12272);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v417);
      os_log_t v416 = 0;
      if (_logHandle)
      {
        os_log_t v133 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v132 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v132 = init_default_corebrightness_log();
        }
        os_log_t v133 = v132;
      }
      os_log_t v416 = v133;
      os_log_type_t v415 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v621, (uint64_t)"AAPRampUpTime", COERCE__INT64(v417));
        _os_log_debug_impl(&dword_1BA438000, v416, v415, "%s = %f\n", v621, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12272) = v417;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPRampDownTime"))
  {
    CFTypeID v131 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v131 == CFNumberGetTypeID())
    {
      float v414 = 0.0;
      float v414 = *(float *)(*(void *)(a1 + 56) + 12276);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v414);
      os_log_t v413 = 0;
      if (_logHandle)
      {
        os_log_type_t v130 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v129 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v129 = init_default_corebrightness_log();
        }
        os_log_type_t v130 = v129;
      }
      os_log_t v413 = v130;
      os_log_type_t v412 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v130, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v620, (uint64_t)"AAPRampDownTime", COERCE__INT64(v414));
        _os_log_debug_impl(&dword_1BA438000, v413, v412, "%s = %f\n", v620, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12276) = v414;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AAPRampDisableTime"))
  {
    CFTypeID v128 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v128 == CFNumberGetTypeID())
    {
      float v411 = 0.0;
      float v411 = *(float *)(*(void *)(a1 + 56) + 12252);
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v411);
      os_log_t v410 = 0;
      if (_logHandle)
      {
        os_log_t v127 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v126 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v126 = init_default_corebrightness_log();
        }
        os_log_t v127 = v126;
      }
      os_log_t v410 = v127;
      os_log_type_t v409 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v619, (uint64_t)"AAPRampDisableTime", COERCE__INT64(v411));
        _os_log_debug_impl(&dword_1BA438000, v410, v409, "%s = %f\n", v619, 0x16u);
      }
      *(float *)(*(void *)(a1 + 56) + 12252) = v411;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"MaxBrightness"))
  {
    CFTypeID v125 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v125 == CFNumberGetTypeID())
    {
      float v408 = 100.0;
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v408);
      float v408 = v408 / 100.0;
      os_log_t v407 = 0;
      if (_logHandle)
      {
        os_log_t v124 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v123 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v123 = init_default_corebrightness_log();
        }
        os_log_t v124 = v123;
      }
      os_log_t v407 = v124;
      os_log_type_t v406 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v618, COERCE__INT64(v408));
        _os_log_impl(&dword_1BA438000, v407, v406, "Set MaxBrightness=%f", v618, 0xCu);
      }
      if (v408 >= 0.0)
      {
        float v405 = 0.0;
        if (_DisplayCLTMRev2Applicable(*(void *)(a1 + 56)))
        {
          int v404 = 0;
          if (v408 <= 0.95)
          {
            if (v408 <= 0.15) {
              int v404 = 2;
            }
            else {
              int v404 = 1;
            }
          }
          else
          {
            int v404 = 0;
          }
          os_log_t v403 = 0;
          if (_logHandle)
          {
            os_log_t v122 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v121 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v121 = init_default_corebrightness_log();
            }
            os_log_t v122 = v121;
          }
          os_log_t v403 = v122;
          os_log_type_t v402 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_0_1_4_0((uint64_t)v617, v404);
            _os_log_impl(&dword_1BA438000, v403, v402, "CLTM mode=%d", v617, 8u);
          }
          if (v404 != *(_DWORD *)(*(void *)(a1 + 56) + 1560))
          {
            uint64_t v616 = 0x1F13F7B50;
            CFNumberRef v615 = 0;
            CFNumberRef v615 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v404);
            if (v616)
            {
              if (v615)
              {
                CFDictionaryRef v401 = 0;
                CFAllocatorRef allocator = CFGetAllocator(*(CFTypeRef *)(a1 + 56));
                CFDictionaryRef v401 = CFDictionaryCreate(allocator, (const void **)&v616, (const void **)&v615, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (v401)
                {
                  uint64_t v16 = *(NSObject **)(*(void *)(a1 + 56) + 144);
                  uint64_t v394 = MEMORY[0x1E4F143A8];
                  int v395 = -1073741824;
                  int v396 = 0;
                  CFTypeID v397 = __DisplaySetProperty_block_invoke_592;
                  CFTypeID v398 = &__block_descriptor_48_e5_v8__0l;
                  uint64_t v399 = *(void *)(a1 + 56);
                  CFDictionaryRef v400 = v401;
                  dispatch_async(v16, &v394);
                }
              }
            }
            if (v615) {
              CFRelease(v615);
            }
          }
          *(_DWORD *)(*(void *)(a1 + 56) + 1560) = v404;
          CFNumberRef v393 = 0;
          CFNumberRef v393 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(*(void *)(a1 + 56) + 1560));
          if (v393)
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 192), @"BrightnessCLTMMode", v393);
            CFRelease(v393);
          }
          *(float *)(*(void *)(a1 + 56) + 1552) = v408;
          if (v408 == 0.0)
          {
            float v405 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), v408);
            _DisplaySetBrightnessMaxPhysicalZeroWithFade(*(void *)(a1 + 56), (uint64_t)_DisplayRampDoneCallback, *(void *)(a1 + 56), v405, 4.0);
          }
          else
          {
            float v405 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), v408);
            _DisplaySetBrightnessMaxPhysicalWithFade(*(void *)(a1 + 56), v405, 4.0);
          }
        }
        else
        {
          float v405 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), v408);
          _DisplaySetBrightnessMaxPhysicalWithFade(*(void *)(a1 + 56), v405, 0.0);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"BrightnessCLTM"))
  {
    if (_DisplayCLTMRev2Applicable(*(void *)(a1 + 56)))
    {
      CFTypeID v119 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v119 == CFDictionaryGetTypeID())
      {
        float v392 = 0.0;
        BOOL v391 = 1;
        CFTypeRef v390 = 0;
        CFTypeRef v390 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"BrightnessCLTMEnable");
        if (v390)
        {
          CFTypeID v118 = CFGetTypeID(v390);
          if (v118 == CFBooleanGetTypeID()) {
            BOOL v391 = CFBooleanGetValue((CFBooleanRef)v390) != 0;
          }
        }
        *(_DWORD *)(*(void *)(a1 + 56) + 1556) = v391;
        float v389 = 0.0;
        CFTypeRef v388 = 0;
        CFTypeRef v388 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"BrightnessCLTMRampRate");
        if (v388)
        {
          CFTypeID v117 = CFGetTypeID(v388);
          if (v117 == CFNumberGetTypeID()) {
            CFNumberGetValue((CFNumberRef)v388, kCFNumberFloatType, &v389);
          }
        }
        os_log_t v387 = 0;
        if (_logHandle)
        {
          v116 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v115 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v115 = init_default_corebrightness_log();
          }
          v116 = v115;
        }
        os_log_t v387 = v116;
        os_log_type_t v386 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
        {
          if (*(_DWORD *)(*(void *)(a1 + 56) + 1556)) {
            uint64_t v17 = "Enable";
          }
          else {
            uint64_t v17 = "Disable";
          }
          __os_log_helper_16_2_2_8_32_8_0((uint64_t)v614, (uint64_t)v17, COERCE__INT64(v389));
          _os_log_impl(&dword_1BA438000, v387, v386, "%s CLTM with period %f", v614, 0x16u);
        }
        if (v391)
        {
          float v392 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), *(float *)(*(void *)(a1 + 56) + 1552));
          if (*(float *)(*(void *)(a1 + 56) + 1552) == 0.0) {
            _DisplaySetBrightnessMaxPhysicalZeroWithFade(*(void *)(a1 + 56), (uint64_t)_DisplayRampDoneCallback, *(void *)(a1 + 56), v392, v389);
          }
          else {
            _DisplaySetBrightnessMaxPhysicalWithFade(*(void *)(a1 + 56), v392, v389);
          }
        }
        else
        {
          float v385 = 0.0;
          float v385 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), 1.0);
          _DisplaySetBrightnessMaxPhysicalWithFade(*(void *)(a1 + 56), v385, v389);
        }
        long long v613 = xmmword_1E621A568;
        CFNumberRef v611 = 0;
        CFNumberRef v612 = 0;
        CFNumberRef v611 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(*(void *)(a1 + 56) + 1556));
        CFNumberRef v612 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v389);
        CFDictionaryRef v384 = 0;
        CFAllocatorRef v114 = CFGetAllocator(*(CFTypeRef *)(a1 + 56));
        CFDictionaryRef v384 = CFDictionaryCreate(v114, (const void **)&v613, (const void **)&v611, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (v384)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 192), @"BrightnessCLTM", v384);
          CFRelease(v384);
        }
        if (v611) {
          CFRelease(v611);
        }
        if (v612) {
          CFRelease(v612);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"BrightnessWeakCap"))
  {
    CFTypeID v113 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
    if (v113 == CFNumberGetTypeID())
    {
      float v383 = 100.0;
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v383);
      float v383 = v383 / 100.0;
      os_log_t v382 = 0;
      if (_logHandle)
      {
        uint64_t v112 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v111 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v111 = init_default_corebrightness_log();
        }
        uint64_t v112 = v111;
      }
      os_log_t v382 = v112;
      os_log_type_t v381 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v610, COERCE__INT64(v383));
        _os_log_impl(&dword_1BA438000, v382, v381, "Set BrightnessWeakCap=%f", v610, 0xCu);
      }
      if (v383 >= 0.0)
      {
        float v380 = 0.0;
        float v380 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), v383);
        float v379 = 0.0;
        if (v380 < *(float *)(*(void *)(a1 + 56) + 528)) {
          float v379 = 7.0;
        }
        else {
          float v379 = 2.5;
        }
        _DisplaySetBrightnessWeakCapWithFade(*(unsigned char **)(a1 + 56), 1, v380, v379);
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"BrightnessMinPhysicalWithFade"))
  {
    if (*(unsigned char *)(*(void *)(a1 + 56) + 320))
    {
      CFTypeID v110 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v110 == CFNumberGetTypeID())
      {
        float v378 = 0.0;
        float v378 = *(float *)(*(void *)(a1 + 56) + 396);
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v378);
        os_log_t v377 = 0;
        if (_logHandle)
        {
          uint64_t v109 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v108 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v108 = init_default_corebrightness_log();
          }
          uint64_t v109 = v108;
        }
        os_log_t v377 = v109;
        os_log_type_t v376 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_2_2_8_32_8_0((uint64_t)v609, (uint64_t)"BrightnessMinPhysicalWithFade", COERCE__INT64(v378));
          _os_log_debug_impl(&dword_1BA438000, v377, v376, "DisplaySetProperty: %s = %f\n", v609, 0x16u);
        }
        if (getClientOverrideState(*(void *)(a1 + 56), 1)) {
          float v378 = fmaxf(v378, *(float *)(*(void *)(a1 + 56) + 968));
        }
        _DisplaySetBrightnessMinPhysicalWithFade(*(void *)(a1 + 56), v378, *(float *)(*(void *)(a1 + 56) + 372));
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessFactorRamp"))
  {
    CFTypeID v107 = CFDictionaryGetTypeID();
    if (v107 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      CFTypeRef v375 = 0;
      CFTypeRef v375 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"DisplayBrightnessFactorCoeffA");
      if (v375)
      {
        CFTypeID v106 = CFGetTypeID(v375);
        if (v106 == CFNumberGetTypeID())
        {
          float v588 = *(float *)(*(void *)(a1 + 56) + 1420);
          CFNumberGetValue((CFNumberRef)v375, kCFNumberFloatType, &v588);
          *(float *)(*(void *)(a1 + 56) + 1420) = v588;
          *(float *)(*(void *)(a1 + 56) + 1416) = 1.0 - *(float *)(*(void *)(a1 + 56) + 1420);
          *(_DWORD *)(*(void *)(a1 + 56) + 1412) = 0;
          os_log_t v374 = 0;
          if (_logHandle)
          {
            uint64_t v105 = _logHandle;
          }
          else
          {
            uint64_t v104 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            uint64_t v105 = v104;
          }
          os_log_t v374 = v105;
          os_log_type_t v373 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v608, COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 1420)), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 1416)), COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 1412)));
            _os_log_debug_impl(&dword_1BA438000, v374, v373, "DisplaySetProperty: Changing Factor ramp to: %fx^2 + %fx + %f\n", v608, 0x20u);
          }
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"PreStrobeDimPeriod"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v103 = CFNumberGetTypeID();
      if (v103 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        int v372 = 0;
        int v372 = *(_DWORD *)(*(void *)(a1 + 56) + 244);
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v372);
        *(_DWORD *)(*(void *)(a1 + 56) + 244) = v372;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CBSoftWakeActive"))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    if (*(void *)(*(void *)(a1 + 56) + 328))
    {
      if (*(void *)(a1 + 40))
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          int v371 = 0;
          int v371 = [*(id *)(a1 + 40) intValue];
          if (![*(id *)(*(void *)(a1 + 56) + 328) action:v371])
          {
            __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 56), 4098, *(float *)(*(void *)(a1 + 56) + 1256));
            *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
          }
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CBSoftWakeFactorWithFadeKey"))
  {
    if (*(void *)(*(void *)(a1 + 56) + 328))
    {
      if ([*(id *)(*(void *)(a1 + 56) + 328) isActive])
      {
        if (*(void *)(a1 + 40))
        {
          CFTypeID v102 = CFDictionaryGetTypeID();
          if (v102 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
          {
            id v370 = 0;
            id v370 = *(id *)(a1 + 40);
            id v369 = (id)[v370 objectForKeyedSubscript:@"DisplayBrightnessFactor"];
            id v368 = (id)[v370 objectForKeyedSubscript:@"DisplayBrightnessFadePeriod"];
            if (v369)
            {
              if (v368)
              {
                int v100 = *(void **)(*(void *)(a1 + 56) + 328);
                [v369 floatValue];
                int v101 = v18;
                [v368 floatValue];
                LODWORD(v20) = v19;
                LODWORD(v21) = v101;
                if (![v100 setFactor:v21 withFade:v20]) {
                  __DisplayStartFade(*(unsigned char **)(a1 + 56), 0.016667);
                }
              }
            }
          }
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"PreStrobeConfig"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v99 = CFDictionaryGetTypeID();
      if (v99 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        CFDictionaryRef v367 = 0;
        CFDictionaryRef v367 = *(CFDictionaryRef *)(a1 + 40);
        if (*(_DWORD *)(*(void *)(a1 + 56) + 248))
        {
          char v365 = 0;
          char v364 = 0;
          CFTypeRef v366 = CFDictionaryGetValue(v367, @"PreStrobeConfigCurrent");
          if (v366 && (CFTypeID v98 = CFNumberGetTypeID(), v98 == CFGetTypeID(v366)))
          {
            char v365 = 1;
            char v364 = 1;
          }
          else
          {
            CFTypeRef v366 = CFDictionaryGetValue(v367, @"PreStrobeConfigNits");
            if (v366)
            {
              CFTypeID v97 = CFNumberGetTypeID();
              if (v97 == CFGetTypeID(v366)) {
                char v364 = 1;
              }
            }
          }
          if (v364)
          {
            float v363 = -1.0;
            if (CFNumberGetValue((CFNumberRef)v366, kCFNumberFloatType, &v363))
            {
              int v362 = (int)(float)(v363 * 65536.0);
              CFNumberRef v361 = 0;
              CFNumberRef v361 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v362);
              if (v361)
              {
                if (v365) {
                  CFStringRef v22 = @"PreStrobeConfigCurrent";
                }
                else {
                  CFStringRef v22 = @"PreStrobeConfigNits";
                }
                __DisplaySetBLDriverProperty(*(void *)(a1 + 56), v22, v361);
                if ((v365 & 1) == 0) {
                  *(_DWORD *)(*(void *)(a1 + 56) + 256) = v362;
                }
                CFRelease(v361);
              }
            }
          }
          else
          {
            *(_DWORD *)(*(void *)(a1 + 56) + 256) = *(_DWORD *)(*(void *)(a1 + 56) + 252);
            int v360 = -1;
            CFNumberRef v359 = 0;
            CFNumberRef v359 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v360);
            if (v359)
            {
              __DisplaySetBLDriverProperty(*(void *)(a1 + 56), @"PreStrobeConfigCurrent", v359);
              CFRelease(v359);
            }
          }
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"PreStrobe"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v96 = CFNumberGetTypeID();
      if (v96 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        float v358 = 0.0;
        float v358 = *(float *)(*(void *)(a1 + 56) + 244);
        int v357 = 0;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v357);
        float v356 = 0.0;
        if (v357) {
          float v95 = 0.0;
        }
        else {
          float v95 = fmaxf(0.0, v358);
        }
        float v356 = v95;
        if (v358 >= 0.0)
        {
          float v352 = 0.0;
          if (v357) {
            float v93 = *(float *)(*(void *)(a1 + 56) + 1312);
          }
          else {
            float v93 = 0.0;
          }
          float v352 = v93;
          if (*(_DWORD *)(*(void *)(a1 + 56) + 248))
          {
            __DisplaySetBLDriverProperty(*(void *)(a1 + 56), @"PreStrobe", *(const void **)(a1 + 40));
            SetPreStrobeState(*(unsigned char **)(a1 + 56), v357 != 0);
          }
          int v351 = 0;
          if (v357) {
            int v92 = (int)(float)(*(float *)(*(void *)(a1 + 56) + 1312) * 65536.0);
          }
          else {
            int v92 = *(_DWORD *)(*(void *)(a1 + 56) + 1128);
          }
          int v351 = v92;
          uint64_t v350 = 0;
          if (_logHandle)
          {
            CFTypeRef v91 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v90 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v90 = init_default_corebrightness_log();
            }
            CFTypeRef v91 = v90;
          }
          uint64_t v350 = v91;
          char v349 = 2;
          if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v88 = v350;
            os_log_type_t v89 = v349;
            __os_log_helper_16_0_0(v348);
            _os_log_debug_impl(&dword_1BA438000, v88, v89, "SetBLDriverNitsCap for preStrobe", v348, 2u);
          }
          SetBLDriverNitsCapIfNotInLPM(*(void *)(a1 + 56), v351);
          _DisplaySetBrightnessMinPhysicalWithFade(*(void *)(a1 + 56), v352, v356);
        }
        else
        {
          if (v357 && *(int *)(*(void *)(a1 + 56) + 252) > 0)
          {
            int v355 = 0;
            int v94 = *(_DWORD *)(*(void *)(a1 + 56) + 256) < *(_DWORD *)(*(void *)(a1 + 56) + 252)
                ? 44236800
                : *(_DWORD *)(*(void *)(a1 + 56) + 252);
            int v355 = v94;
            if (*(_DWORD *)(*(void *)(a1 + 56) + 260) != v94)
            {
              *(_DWORD *)(*(void *)(a1 + 56) + 256) = v355;
              *(_DWORD *)(*(void *)(a1 + 56) + 260) = v355;
              CFNumberRef v354 = 0;
              CFNumberRef v354 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v355);
              if (v354)
              {
                __DisplaySetBLDriverProperty(*(void *)(a1 + 56), @"PreStrobeConfigNits", v354);
                CFRelease(v354);
                float v353 = 0.0;
                float v353 = (float)v355 / (float)*(int *)(*(void *)(a1 + 56) + 252);
                CFNumberRef v354 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v353);
                if (v354)
                {
                  CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 192), @"PreStrobeBrightnessRatio", v354);
                  CFRelease(v354);
                }
              }
            }
          }
          __DisplaySetBLDriverProperty(*(void *)(a1 + 56), @"PreStrobe", *(const void **)(a1 + 40));
          SetPreStrobeState(*(unsigned char **)(a1 + 56), v357 != 0);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"ColorFadesEnabled"))
  {
    if (*(void *)(a1 + 40))
    {
      BOOL v347 = 0;
      char v346 = 0;
      CFTypeID v87 = CFNumberGetTypeID();
      if (v87 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        int v345 = 0;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v345);
        BOOL v347 = v345 != 0;
        char v346 = 1;
      }
      else
      {
        CFTypeID v86 = CFBooleanGetTypeID();
        if (v86 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
        {
          BOOL v347 = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 40)) != 0;
          char v346 = 1;
        }
      }
      if ((v346 & 1) == 1 && *(void *)(*(void *)(a1 + 56) + 12504)) {
        CFXEnableFades(*(void *)(*(void *)(a1 + 56) + 12504), v347);
      }
      else {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CarryLogEnabled"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v85 = CFNumberGetTypeID();
      if (v85 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        int v344 = 0;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v344);
        CFXEnableLog(*(void *)(*(void *)(a1 + 56) + 12504), v344 != 0);
        if (CFPreferencesAppSynchronize((CFStringRef)*MEMORY[0x1E4F1D3D8])) {
          CFPreferencesSetAppValue(@"CBCarryLogEnabled", *(CFPropertyListRef *)(a1 + 40), (CFStringRef)*MEMORY[0x1E4F1D3D8]);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CarryLogComment"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v84 = CFStringGetTypeID();
      if (v84 == CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
        CFXStoreComment(*(void *)(*(void *)(a1 + 56) + 12504), *(const __CFString **)(a1 + 40));
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CarryLogCommit"))
  {
    CFXForceLogCommit(*(FILE **)(*(void *)(a1 + 56) + 12504));
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"FreezeBrightness"))
  {
    if (*(_DWORD *)(*(void *)(a1 + 56) + 36))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
    else if (*(void *)(a1 + 40))
    {
      CFTypeID v83 = CFDictionaryGetTypeID();
      if (v83 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
      {
        CFNumberRef v343 = 0;
        CFNumberRef v343 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"FreezeBrightnessPeriod");
        if (v343)
        {
          CFTypeID v82 = CFNumberGetTypeID();
          if (v82 == CFGetTypeID(v343)) {
            CFNumberGetValue(v343, kCFNumberFloatType, (void *)(*(void *)(a1 + 56) + 12544));
          }
        }
        BOOL v342 = 0;
        CFNumberRef v343 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"FreezeBrightnessEnable");
        if (v343 && (CFTypeID v81 = CFNumberGetTypeID(), v81 == CFGetTypeID(v343)))
        {
          int v341 = 0;
          CFNumberGetValue(v343, kCFNumberIntType, &v341);
          BOOL v342 = v341 != 0;
        }
        else if (v343)
        {
          CFTypeID v80 = CFBooleanGetTypeID();
          if (v80 == CFGetTypeID(v343)) {
            BOOL v342 = CFBooleanGetValue(v343) != 0;
          }
        }
        CFIndex Count = 0;
        if (*(void *)(*(void *)(a1 + 56) + 12536)) {
          CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 56) + 12536));
        }
        uint64_t v339 = Count;
        if (Count > 0 || v342)
        {
          CFNumberRef v343 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), @"FreezeBrightnessRequestors");
          if (v343)
          {
            CFTypeID v79 = CFArrayGetTypeID();
            if (v79 == CFGetTypeID(v343))
            {
              CFArrayRef v338 = v343;
              CFIndex v337 = CFArrayGetCount(v343);
              if (v337 > 0)
              {
                if (v342 && !*(void *)(*(void *)(a1 + 56) + 12536)) {
                  *(void *)(*(void *)(a1 + 56) + 12536) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v337, MEMORY[0x1E4F1D510]);
                }
                if (*(void *)(*(void *)(a1 + 56) + 12536))
                {
                  ValueAtIndex = 0;
                  for (CFIndex i = 0; i < v337; ++i)
                  {
                    ValueAtIndex = CFArrayGetValueAtIndex(v338, i);
                    if (ValueAtIndex)
                    {
                      char v334 = 0;
                      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 56) + 12536));
                      for (CFIndex j = 0; j < Count; ++j)
                      {
                        CFTypeRef v332 = 0;
                        CFTypeRef v332 = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(void *)(a1 + 56) + 12536), j);
                        if (CFEqual(ValueAtIndex, v332))
                        {
                          char v334 = 1;
                          if (!v342)
                          {
                            CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(void *)(a1 + 56) + 12536), j);
                            break;
                          }
                        }
                      }
                      if (v342 && (v334 & 1) == 0) {
                        CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(a1 + 56) + 12536), ValueAtIndex);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (*(void *)(*(void *)(a1 + 56) + 12536)) {
          CFIndex v78 = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 56) + 12536));
        }
        else {
          CFIndex v78 = 0;
        }
        CFIndex Count = v78;
        if (v339 || Count <= 0)
        {
          if (v339 > 0 && !Count)
          {
            *(_DWORD *)(*(void *)(a1 + 56) + 1256) = *(_DWORD *)(*(void *)(a1 + 56) + 12556);
            *(unsigned char *)(*(void *)(a1 + 56) + 12548) = 0;
            BOOL v329 = 0;
            BOOL v329 = *(float *)(*(void *)(a1 + 56) + 12552) >= *(float *)(*(void *)(a1 + 56) + 1256);
            float v328 = 0.0;
            float v23 = 2.5;
            if (!v329) {
              float v23 = 5.0;
            }
            float v328 = v23;
            long long v605 = xmmword_1BA613274;
            int v606 = -1820426635;
            long long v603 = xmmword_1BA613288;
            int v604 = -937652876;
            BOOL v327 = (MGIsDeviceOneOfType() & 1) != 0;
            long long v601 = xmmword_1BA61329C;
            int v602 = 1874287171;
            long long v599 = xmmword_1BA6132B0;
            int v600 = -781324731;
            if (MGIsDeviceOneOfType()) {
              BOOL v327 = 1;
            }
            if (v327)
            {
              CFBooleanRef v326 = 0;
              CFBooleanRef v326 = (CFBooleanRef)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 56) + 192), @"CBStoreDemoModeIsPresent");
              if (v326)
              {
                if (CFBooleanGetValue(v326))
                {
                  os_log_t v325 = 0;
                  if (_logHandle)
                  {
                    long long v75 = _logHandle;
                  }
                  else
                  {
                    if (_COREBRIGHTNESS_LOG_DEFAULT) {
                      uint64_t v74 = _COREBRIGHTNESS_LOG_DEFAULT;
                    }
                    else {
                      uint64_t v74 = init_default_corebrightness_log();
                    }
                    long long v75 = v74;
                  }
                  os_log_t v325 = v75;
                  os_log_type_t v324 = OS_LOG_TYPE_DEFAULT;
                  if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
                  {
                    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v598, COERCE__INT64(v328), 0);
                    _os_log_impl(&dword_1BA438000, v325, v324, "Store Demo is present! The unfreeze period will be altered: %f -> %f.", v598, 0x16u);
                  }
                  float v328 = 0.0;
                }
              }
            }
            os_log_t v323 = 0;
            if (_logHandle)
            {
              uint64_t v73 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v72 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v72 = init_default_corebrightness_log();
              }
              uint64_t v73 = v72;
            }
            os_log_t v323 = v73;
            os_log_type_t v322 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v597, COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 12552)));
              _os_log_impl(&dword_1BA438000, v323, v322, "The brightness has been unfrozen. L cached = %f", v597, 0xCu);
            }
            _DisplaySetLogicalBrightnessWithFade(*(void *)(a1 + 56), 0x4Au, 0, 0, *(float *)(*(void *)(a1 + 56) + 12552), v328);
          }
        }
        else
        {
          *(unsigned char *)(*(void *)(a1 + 56) + 12548) = 1;
          *(_DWORD *)(*(void *)(a1 + 56) + 12556) = *(_DWORD *)(*(void *)(a1 + 56) + 1256);
          os_log_t v331 = 0;
          if (_logHandle)
          {
            uint64_t v77 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v76 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v76 = init_default_corebrightness_log();
            }
            uint64_t v77 = v76;
          }
          os_log_t v331 = v77;
          os_log_type_t v330 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_0_1_8_0((uint64_t)v607, COERCE__INT64(*(float *)(*(void *)(a1 + 56) + 12556)));
            _os_log_impl(&dword_1BA438000, v331, v330, "The brightness has been frozen. L = %f", v607, 0xCu);
          }
        }
        CFMutableArrayRef Mutable = 0;
        CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        if (Mutable)
        {
          if (*(void *)(*(void *)(a1 + 56) + 12536)
            && CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 56) + 12536)) > 0)
          {
            CFDictionarySetValue(Mutable, @"FreezeBrightnessRequestors", *(const void **)(*(void *)(a1 + 56) + 12536));
          }
          CFNumberRef v320 = 0;
          CFNumberRef v320 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (const void *)(*(void *)(a1 + 56) + 12544));
          if (v320)
          {
            CFDictionarySetValue(Mutable, @"FreezeBrightnessPeriod", v320);
            CFRelease(v320);
          }
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 192), *(const void **)(a1 + 48), Mutable);
          CFRelease(Mutable);
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"PowerLogReportInterval"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v71 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v71 == CFNumberGetTypeID())
      {
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, (void *)(*(void *)(a1 + 56) + 12584));
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"ColorRampPeriodOverride"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v70 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v70 == CFNumberGetTypeID())
      {
        float v319 = -1.0;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v319);
        CFXOverrideRampPeriod(*(void *)(*(void *)(a1 + 56) + 12504), v319);
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DynamicSliderEnable"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v69 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v69 == CFNumberGetTypeID())
      {
        int v318 = 1;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v318);
        *(unsigned char *)(*(void *)(a1 + 56) + 1048) = v318 == 0;
        *(unsigned char *)(*(void *)(a1 + 56) + 1120) = v318 == 0;
        if (!v318)
        {
          if (*(double *)(*(void *)(a1 + 56) + 1064) > 0.0)
          {
            *(_DWORD *)(*(void *)(a1 + 56) + 1056) = *(_DWORD *)(*(void *)(a1 + 56) + 1080);
            *(void *)(*(void *)(a1 + 56) + 1064) = 0;
          }
          if (*(double *)(*(void *)(a1 + 56) + 992) > 0.0)
          {
            *(_DWORD *)(*(void *)(a1 + 56) + 984) = *(_DWORD *)(*(void *)(a1 + 56) + 1008);
            *(void *)(*(void *)(a1 + 56) + 992) = 0;
          }
        }
        __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 56), 12290, *(float *)(*(void *)(a1 + 56) + 1256));
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessForceUpdates"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v68 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v68 == CFNumberGetTypeID())
      {
        int v317 = 1;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberIntType, &v317);
        *(unsigned char *)(*(void *)(a1 + 56) + 1284) = v317 != 0;
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"BrightnessGlobalScalar"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v67 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v67 == CFDictionaryGetTypeID())
      {
        float GlobalScalarFromDictionary = 0.0;
        float GlobalScalarFromDictionary = _DisplayGetGlobalScalarFromDictionary(*(void *)(a1 + 56), *(_DWORD *)(*(void *)(a1 + 56) + 80), *(const __CFDictionary **)(a1 + 40));
        if (GlobalScalarFromDictionary > 0.0) {
          *(float *)(*(void *)(a1 + 56) + 1140) = GlobalScalarFromDictionary;
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      }
    }
  }
  else if (*(void *)(a1 + 40) && CFEqual(*(CFTypeRef *)(a1 + 48), @"ProductTypeAccessory"))
  {
    CFTypeID v66 = CFBooleanGetTypeID();
    if (v66 == CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      *(unsigned char *)(*(void *)(a1 + 56) + 312) = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 40)) != 0;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"PCCEnable"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v65 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v65 == CFNumberGetTypeID())
      {
        float v315 = -1.0;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v315);
        if (v315 >= 0.0) {
          __DisplaySetBLDriverProperty(*(void *)(a1 + 56), @"pcc-enable", (const void *)*MEMORY[0x1E4F1CFD0]);
        }
        else {
          __DisplaySetBLDriverProperty(*(void *)(a1 + 56), @"pcc-enable", (const void *)*MEMORY[0x1E4F1CFC8]);
        }
        os_log_t v314 = 0;
        if (_logHandle)
        {
          int v64 = _logHandle;
        }
        else
        {
          uint64_t v63 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          int v64 = v63;
        }
        os_log_t v314 = v64;
        os_log_type_t v313 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          if (v315 == 0.0) {
            uint64_t v24 = "disabled";
          }
          else {
            uint64_t v24 = "enabled";
          }
          __os_log_helper_16_2_1_8_32((uint64_t)v596, (uint64_t)v24);
          _os_log_impl(&dword_1BA438000, v314, v313, "PCC %s", v596, 0xCu);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"PCCBrightness"))
  {
    if (*(void *)(a1 + 40))
    {
      CFTypeID v62 = CFGetTypeID(*(CFTypeRef *)(a1 + 40));
      if (v62 == CFNumberGetTypeID())
      {
        float v312 = -1.0;
        CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v312);
        if (v312 >= 0.0)
        {
          os_log_t v311 = 0;
          if (_logHandle)
          {
            float v61 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v60 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v60 = init_default_corebrightness_log();
            }
            float v61 = v60;
          }
          os_log_t v311 = v61;
          os_log_type_t v310 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_0_1_8_0((uint64_t)v595, COERCE__INT64(v312));
            _os_log_impl(&dword_1BA438000, v311, v310, "Set PCC brightness = %f", v595, 0xCu);
          }
          int v309 = (int)(float)(v312 * 65536.0);
          CFNumberRef v308 = 0;
          CFAllocatorRef v59 = CFGetAllocator(*(CFTypeRef *)(a1 + 56));
          CFNumberRef v308 = CFNumberCreate(v59, kCFNumberSInt32Type, &v309);
          if (v308)
          {
            __DisplaySetBLDriverProperty(*(void *)(a1 + 56), @"pcc-brightness", v308);
            CFRelease(v308);
          }
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"CoreBrightnessFeaturesDisabled"))
  {
    id v307 = 0;
    id v307 = *(id *)(a1 + 40);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ([v307 objectForKey:@"OverrideBrightnessWithFixedNits"]
        || [v307 objectForKey:@"OverrideBrightnessWithFixedSliderPosition"])
      {
        id v306 = (id)[v307 objectForKey:@"OverrideBrightnessWithFixedNits"];
        id v305 = (id)[v307 objectForKey:@"OverrideBrightnessWithFixedSliderPosition"];
        float v304 = 0.0;
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          [v306 floatValue];
          float v304 = v25;
        }
        else
        {
          float v303 = 1.0;
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            [v305 floatValue];
            float v303 = v26;
          }
          else
          {
            float v303 = 1.0;
          }
          float v304 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 56), v303);
        }
        *(unsigned char *)(*(void *)(a1 + 56) + 1504) = 1;
        int v302 = 0;
        int v302 = (int)(float)(*(float *)(*(void *)(a1 + 56) + 1312) * 65536.0);
        SetBLDriverNitsCap(*(const void **)(a1 + 56), v302);
        int v301 = (int)(float)(v304 * 65536.0);
        os_log_t v300 = 0;
        if (_logHandle)
        {
          uint64_t v58 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v57 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v57 = init_default_corebrightness_log();
          }
          uint64_t v58 = v57;
        }
        os_log_t v300 = v58;
        os_log_type_t v299 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v594, COERCE__INT64(v304));
          _os_log_impl(&dword_1BA438000, v300, v299, "Display.m CoreBrightnessFeaturesDisabled overriden brightness, desired fixed brightness is = %f", v594, 0xCu);
        }
        SetBLDriverNitsValue(*(float **)(a1 + 56), v301);
      }
      else
      {
        *(unsigned char *)(*(void *)(a1 + 56) + 1504) = 0;
        SetBLDriverNitsCapIfNotInLPM(*(void *)(a1 + 56), *(_DWORD *)(*(void *)(a1 + 56) + 1512));
        SetBLDriverNitsValueIfNotInLPM(*(void *)(a1 + 56), *(_DWORD *)(*(void *)(a1 + 56) + 1508));
        char v298 = 0;
        if (_logHandle)
        {
          uint64_t v56 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v55 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v55 = init_default_corebrightness_log();
          }
          uint64_t v56 = v55;
        }
        char v298 = v56;
        os_log_type_t v297 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          int v53 = v298;
          os_log_type_t v54 = v297;
          __os_log_helper_16_0_0(v296);
          _os_log_impl(&dword_1BA438000, v53, v54, "Display.m CoreBrightnessFeaturesDisabled brightness override off", v296, 2u);
        }
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"BrightDotsMitigationParameters"))
  {
    id v295 = 0;
    id v295 = *(id *)(a1 + 40);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ([v295 objectForKey:@"brightDotsMitigationLux1"]
        && [v295 objectForKey:@"brightDotsMitigationLux2"]
        && [v295 objectForKey:@"brightDotsMitigationNits1"]
        && [v295 objectForKey:@"brightDotsMitigationNits2"])
      {
        objc_msgSend((id)objc_msgSend(v295, "objectForKey:", @"brightDotsMitigationLux1"), "floatValue");
        *(_DWORD *)(*(void *)(a1 + 56) + 1152) = v27;
        objc_msgSend((id)objc_msgSend(v295, "objectForKey:", @"brightDotsMitigationLux2"), "floatValue");
        *(_DWORD *)(*(void *)(a1 + 56) + 1160) = v28;
        objc_msgSend((id)objc_msgSend(v295, "objectForKey:", @"brightDotsMitigationNits1"), "floatValue");
        *(_DWORD *)(*(void *)(a1 + 56) + 1156) = v29;
        objc_msgSend((id)objc_msgSend(v295, "objectForKey:", @"brightDotsMitigationNits2"), "floatValue");
        *(_DWORD *)(*(void *)(a1 + 56) + 1164) = v30;
      }
      if (*(void *)(*(void *)(a1 + 56) + 192))
      {
        id v294 = 0;
        id v294 = *(id *)(*(void *)(a1 + 56) + 192);
        [v294 setObject:v295 forKey:@"BrightDotsMitigationParameters"];
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"FullBrightnessRangeOverrideEnabled"))
  {
    id v293 = 0;
    id v293 = *(id *)(a1 + 40);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if ([v293 objectForKey:@"Status"]
        && (objc_msgSend((id)objc_msgSend(v293, "objectForKey:", @"Status"), "BOOLValue") & 1) != 0)
      {
        DisplayEnableFullBrightnessRangeAccessOverride(*(void *)(a1 + 56), 1);
      }
      else
      {
        DisplayEnableFullBrightnessRangeAccessOverride(*(void *)(a1 + 56), 0);
      }
      if (*(void *)(*(void *)(a1 + 56) + 192))
      {
        id v292 = 0;
        id v292 = *(id *)(*(void *)(a1 + 56) + 192);
        [v292 setObject:v293 forKey:@"FullBrightnessRangeOverrideEnabled"];
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplaySyncBrightnessTransactions"))
  {
    CFTypeID v52 = CFBooleanGetTypeID();
    if (v52 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      *(unsigned char *)(*(void *)(a1 + 56) + 321) = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 40)) != 0;
      if (*(unsigned char *)(*(void *)(a1 + 56) + 321))
      {
        *(_DWORD *)(*(void *)(a1 + 56) + 136) = 0;
        *(void *)(*(void *)(a1 + 56) + 208) = [[CBFrameLink alloc] initWithDisplay:*(void *)(a1 + 56) andQueue:*(void *)(*(void *)(a1 + 56) + 144)];
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayFasterEDREngaged"))
  {
    CFTypeID v51 = CFBooleanGetTypeID();
    if (v51 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)) && (*(unsigned char *)(*(void *)(a1 + 56) + 321) & 1) != 0)
    {
      *(unsigned char *)(*(void *)(a1 + 56) + 322) = CFBooleanGetValue(*(CFBooleanRef *)(a1 + 40)) != 0;
      if (*(unsigned char *)(*(void *)(a1 + 56) + 322))
      {
        __DisplayStartAPLCPMSTimer(*(dispatch_object_t **)(a1 + 56), 1.0);
      }
      else if (*(void *)(*(void *)(a1 + 56) + 12112))
      {
        __DisplayProcessHDRStatusForCoreAnalytics(*(void *)(a1 + 56));
        dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 56) + 12112));
        *(void *)(*(void *)(a1 + 56) + 12112) = 0;
        *(void *)(*(void *)(a1 + 56) + 12088) = 0;
        *(void *)(*(void *)(a1 + 56) + 12096) = 0;
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessMinRefreshRate"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 384);
    CFTypeID v50 = CFNumberGetTypeID();
    if (v50 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
    *(float *)(*(void *)(a1 + 56) + 384) = v588;
    os_log_t oslog = 0;
    if (_logHandle)
    {
      uint64_t v49 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v48 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v48 = init_default_corebrightness_log();
      }
      uint64_t v49 = v48;
    }
    os_log_t oslog = v49;
    os_log_type_t v290 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_2_8_32_8_0((uint64_t)v593, (uint64_t)"DisplayBrightnessMinRefreshRate", COERCE__INT64(v588));
      _os_log_debug_impl(&dword_1BA438000, oslog, v290, "MinRefreshRate: %s = %f\n", v593, 0x16u);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessMaxRefreshRate"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 388);
    CFTypeID v47 = CFNumberGetTypeID();
    if (v47 != CFGetTypeID(*(CFTypeRef *)(a1 + 40))) {
      return;
    }
    CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v588);
    *(float *)(*(void *)(a1 + 56) + 388) = v588;
    os_log_t v289 = 0;
    if (_logHandle)
    {
      float v46 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v45 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v45 = init_default_corebrightness_log();
      }
      float v46 = v45;
    }
    os_log_t v289 = v46;
    os_log_type_t v288 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_2_8_32_8_0((uint64_t)v592, (uint64_t)"DisplayBrightnessMaxRefreshRate", COERCE__INT64(v588));
      _os_log_debug_impl(&dword_1BA438000, v289, v288, "MaxRefreshRate: %s = %f\n", v592, 0x16u);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AuroraRamp"))
  {
    float v588 = *(float *)(*(void *)(a1 + 56) + 12944);
    float v287 = 0.0;
    id v286 = 0;
    id v286 = *(id *)(a1 + 40);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v285 = (id)[v286 objectForKey:@"Factor"];
      if (v285)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          [v285 floatValue];
          float v588 = v31;
        }
      }
      id v284 = (id)[v286 objectForKey:@"Period"];
      if (v284)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          [v284 floatValue];
          float v287 = v32;
        }
      }
      _DisplaySetAuroraFactorWithFade(*(void *)(a1 + 56), v588, v287);
      if (*(void *)(*(void *)(a1 + 56) + 192))
      {
        id v283 = 0;
        id v283 = *(id *)(*(void *)(a1 + 56) + 192);
        [v283 setObject:v286 forKey:@"AuroraRamp"];
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AuroraCLTMActivationThreshold"))
  {
    CFTypeID v44 = CFNumberGetTypeID();
    if (v44 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      [*(id *)(a1 + 40) floatValue];
      *(_DWORD *)(*(void *)(a1 + 56) + 13016) = v33;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AuroraRampUpTimeSecondsPerStop"))
  {
    CFTypeID v43 = CFNumberGetTypeID();
    if (v43 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      [*(id *)(a1 + 40) floatValue];
      *(_DWORD *)(*(void *)(a1 + 56) + 13020) = v34;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"AuroraRampDownTimeSecondsPerStop"))
  {
    CFTypeID v42 = CFNumberGetTypeID();
    if (v42 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      [*(id *)(a1 + 40) floatValue];
      *(_DWORD *)(*(void *)(a1 + 56) + 13024) = v35;
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"ExternalRampIsRunning"))
  {
    uint64_t v282 = 0;
    uint64_t v282 = *(void *)(a1 + 40);
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      [*(id *)(*(void *)(a1 + 56) + 264) handleRampStart:v282];
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"ExternalRampHasFinished"))
  {
    uint64_t v281 = 0;
    uint64_t v281 = *(void *)(a1 + 40);
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      [*(id *)(*(void *)(a1 + 56) + 264) handleRampEnd:v281];
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayDisplayStartFade"))
  {
    CFTypeID v41 = CFNumberGetTypeID();
    if (v41 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      os_log_type_t v40 = *(unsigned char **)(a1 + 56);
      [*(id *)(a1 + 40) floatValue];
      __DisplayStartFade(v40, v36);
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayBrightnessFadePeriodOverride"))
  {
    float v280 = 0.0;
    float v280 = *(float *)(*(void *)(a1 + 56) + 376);
    CFTypeID v39 = CFNumberGetTypeID();
    if (v39 == CFGetTypeID(*(CFTypeRef *)(a1 + 40)))
    {
      CFNumberGetValue(*(CFNumberRef *)(a1 + 40), kCFNumberFloatType, &v280);
      if (v280 < 0.0)
      {
        *(float *)(*(void *)(a1 + 56) + 376) = v280;
        *(unsigned char *)(*(void *)(a1 + 56) + 380) = 0;
      }
      else
      {
        *(float *)(*(void *)(a1 + 56) + 376) = v280;
        *(unsigned char *)(*(void *)(a1 + 56) + 380) = 1;
      }
      if (_logHandle)
      {
        float v38 = _logHandle;
      }
      else
      {
        uint64_t v37 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        float v38 = v37;
      }
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_2_8_32_8_0((uint64_t)v591, (uint64_t)"DisplayBrightnessFadePeriodOverride", COERCE__INT64(v280));
        _os_log_debug_impl(&dword_1BA438000, v38, OS_LOG_TYPE_DEBUG, "FadePeriodOverride: %s = %f\n", v591, 0x16u);
      }
    }
  }
  else if (CFEqual(*(CFTypeRef *)(a1 + 48), @"DisplayPowerOff"))
  {
    __ShortcutAllRamps(*(unsigned char **)(a1 + 56));
    if (*(float *)(*(void *)(a1 + 56) + 1204) > 0.0) {
      *(_DWORD *)(*(void *)(a1 + 56) + 1256) = 0;
    }
  }
  else if (!CFEqual(*(CFTypeRef *)(a1 + 48), @"CBStoreDemoModeIsPresent"))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 1 && *(void *)(a1 + 40)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 192), *(const void **)(a1 + 48), *(const void **)(a1 + 40));
  }
  if (*(float *)(*(void *)(a1 + 56) + 348) == 0.0) {
    *(_DWORD *)(*(void *)(a1 + 56) + 356) = *(_DWORD *)(*(void *)(a1 + 56) + 336);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
}

void sub_1BA4A4A78()
{
  _Unwind_Resume(v0);
}

void *createCustomCurve@<X0>(const float *a1@<X0>, const float *a2@<X1>, unsigned int a3@<W2>, _DWORD *a4@<X8>)
{
  if (a3 >= 0x7FFFFFFF) {
    __assert_rtn("createCustomCurve", "CBSoftWake.mm", 19, "size < INT_MAX");
  }
  if (a3 >= 0x14) {
    __assert_rtn("createCustomCurve", "CBSoftWake.mm", 20, "size < 20");
  }
  memcpy(a4, a1, 4 * a3);
  uint64_t result = memcpy(a4 + 20, a2, 4 * a3);
  a4[40] = a3;
  return result;
}

uint64_t canTransition(uint64_t a1, uint64_t a2)
{
  if (a1 || (char v4 = 1, a2 != 1))
  {
    BOOL v3 = 0;
    if (a1 == 1) {
      BOOL v3 = a2 == 0;
    }
    char v4 = v3;
  }
  return v4 & 1;
}

void *dumpCArrayIntoDictionary(unint64_t a1, uint64_t a2)
{
  char v4 = (void *)[MEMORY[0x1E4F1CA60] dictionaryWithCapacity:a1];
  for (unint64_t i = 0; i < a1; ++i)
    [v4 setObject:(*(uint64_t (**)(uint64_t, unint64_t))(a2 + 16))(a2, i), objc_msgSend(NSString, "stringWithFormat:", @"%tu", i) forKey];
  return v4;
}

uint64_t __os_log_helper_16_2_11_8_32_8_32_4_0_4_0_4_0_4_0_8_0_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 11;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 32;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(unsigned char *)(result + 28) = 0;
  *(unsigned char *)(result + 29) = 4;
  *(_DWORD *)(result + 30) = a5;
  *(unsigned char *)(result + 34) = 0;
  *(unsigned char *)(result + 35) = 4;
  *(_DWORD *)(result + 36) = a6;
  *(unsigned char *)(result + 40) = 0;
  *(unsigned char *)(result + 41) = 4;
  *(_DWORD *)(result + 42) = a7;
  *(unsigned char *)(result + 46) = 0;
  *(unsigned char *)(result + 47) = 8;
  *(void *)(result + 48) = a8;
  *(unsigned char *)(result + 56) = 0;
  *(unsigned char *)(result + 57) = 8;
  *(void *)(result + 58) = a9;
  *(unsigned char *)(result + 66) = 0;
  *(unsigned char *)(result + 67) = 8;
  *(void *)(result + 68) = a10;
  *(unsigned char *)(result + 76) = 0;
  *(unsigned char *)(result + 77) = 8;
  *(void *)(result + 78) = a11;
  *(unsigned char *)(result + 86) = 0;
  *(unsigned char *)(result + 87) = 4;
  *(_DWORD *)(result + 88) = a12;
  return result;
}

uint64_t __os_log_helper_16_2_6_8_32_8_32_4_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 6;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 32;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(unsigned char *)(result + 28) = 0;
  *(unsigned char *)(result + 29) = 8;
  *(void *)(result + 30) = a5;
  *(unsigned char *)(result + 38) = 0;
  *(unsigned char *)(result + 39) = 8;
  *(void *)(result + 40) = a6;
  *(unsigned char *)(result + 48) = 0;
  *(unsigned char *)(result + 49) = 8;
  *(void *)(result + 50) = a7;
  return result;
}

double std::__math::fmax[abi:ne180100]<int,float,0>(int a1, float a2)
{
  return std::__math::fmax[abi:ne180100]<int>((double)a1, a2);
}

float std::__math::fmax[abi:ne180100](float a1, float a2)
{
  return fmaxf(a1, a2);
}

float std::__math::fmin[abi:ne180100](float a1, float a2)
{
  return fminf(a1, a2);
}

uint64_t __os_log_helper_16_2_2_8_32_4_0(uint64_t result, uint64_t a2, int a3)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  return result;
}

double std::__math::fmin[abi:ne180100]<int,unsigned int,0>(int a1, int a2, double a3, double a4)
{
  LODWORD(a4) = a2;
  return std::__math::fmin[abi:ne180100]<int>((double)a1, (double)*(unint64_t *)&a4);
}

void sub_1BA4ADEA4()
{
  _Unwind_Resume(v0);
}

void *std::valarray<float>::valarray(void *a1, float *a2, unint64_t a3)
{
  return a1;
}

{
  *a1 = 0;
  a1[1] = 0;
  std::valarray<float>::resize(a1, a3, *a2);
  return a1;
}

void *std::valarray<float>::~valarray(void *a1)
{
  return a1;
}

{
  uint64_t v3;

  BOOL v3 = std::valarray<float>::size[abi:ne180100](a1);
  std::valarray<float>::__clear((uint64_t)a1, v3);
  return a1;
}

void *std::valarray<float>::valarray(void *a1, unint64_t a2)
{
  return a1;
}

{
  void *v2;
  unint64_t i;
  char v6;
  unint64_t v7;
  void *v8;
  void *v9;

  double v8 = a1;
  CFIndex v7 = a2;
  float v9 = a1;
  *a1 = 0;
  a1[1] = 0;
  if (v7)
  {
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v6);
    unsigned int v2 = std::allocator<float>::allocate[abi:ne180100]((uint64_t)&v6, v7);
    a1[1] = v2;
    *a1 = v2;
    for (unint64_t i = v7; i; --i)
    {
      *(_DWORD *)a1[1] = 0;
      a1[1] += 4;
    }
  }
  return v9;
}

uint64_t std::valarray<float>::size[abi:ne180100](void *a1)
{
  return (a1[1] - *a1) / 4;
}

uint64_t std::valarray<float>::operator[][abi:ne180100](void *a1, uint64_t a2)
{
  return *a1 + 4 * a2;
}

{
  return *a1 + 4 * a2;
}

uint64_t std::operator/[abi:ne180100]<std::valarray<float>,0>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char v12 = a1;
  uint64_t v11 = a2;
  uint64_t v3 = std::valarray<float>::size[abi:ne180100](a1);
  std::__scalar_expr<float>::__scalar_expr[abi:ne180100](&v8, a2, v3);
  std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](v10, (uint64_t)&v9, (unint64_t)a1, &v8);
  return std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](a3, (uint64_t)v10);
}

float **std::valarray<float>::operator=<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>(float **a1, uint64_t a2)
{
  unint64_t v6 = std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::size[abi:ne180100](a2);
  if (std::valarray<float>::size[abi:ne180100](a1) != v6) {
    std::valarray<float>::resize(a1, v6, 0.0);
  }
  unsigned int v5 = *a1;
  for (uint64_t i = 0; i != v6; ++i)
    *v5++ = std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::operator[][abi:ne180100](a2, i);
  return a1;
}

void *std::operator/[abi:ne180100]<std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,0>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  uint64_t v3 = std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](a1);
  std::__scalar_expr<float>::__scalar_expr[abi:ne180100](&v8, a2, v3);
  std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100]((uint64_t)v10, (uint64_t)&v9, a1, &v8);
  return std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](a3, v10);
}

__n128 *std::operator-[abi:ne180100]<std::valarray<float>,std::valarray<float>,0>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X8>)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100]((uint64_t)&v6, (uint64_t)&v5, a1, a2);
  return std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](a3, &v6);
}

float **std::valarray<float>::operator=<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>(float **a1, uint64_t a2)
{
  unint64_t v6 = std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::size[abi:ne180100](a2);
  if (std::valarray<float>::size[abi:ne180100](a1) != v6) {
    std::valarray<float>::resize(a1, v6, 0.0);
  }
  char v5 = *a1;
  for (uint64_t i = 0; i != v6; ++i)
    *v5++ = std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::operator[][abi:ne180100](a2, i);
  return a1;
}

_DWORD *std::min[abi:ne180100]<int>(_DWORD *a1, _DWORD *a2)
{
  return std::min[abi:ne180100]<int,std::__less<void,void>>(a1, a2);
}

_DWORD *std::max[abi:ne180100]<int>(_DWORD *a1, _DWORD *a2)
{
  return std::max[abi:ne180100]<int,std::__less<void,void>>(a1, a2);
}

void *std::valarray<float>::valarray(void *a1, _DWORD *a2, unint64_t a3)
{
  return a1;
}

{
  void *v3;
  unint64_t i;
  char v7;
  unint64_t v8;
  _DWORD *v9;
  void *v10;
  void *v11;

  uint64_t v10 = a1;
  char v9 = a2;
  uint64_t v8 = a3;
  uint64_t v11 = a1;
  *a1 = 0;
  a1[1] = 0;
  if (v8)
  {
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v7);
    uint64_t v3 = std::allocator<float>::allocate[abi:ne180100]((uint64_t)&v7, v8);
    a1[1] = v3;
    *a1 = v3;
    for (uint64_t i = v8; i; --i)
    {
      *(_DWORD *)a1[1] = *v9;
      a1[1] += 4;
      ++v9;
    }
  }
  return v11;
}

__n128 *std::operator>[abi:ne180100]<std::valarray<float>,std::valarray<float>,0>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X8>)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100]((uint64_t)&v6, (uint64_t)&v5, a1, a2);
  return std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](a3, &v6);
}

BOOL std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::max[abi:ne180100](uint64_t a1)
{
  unint64_t v7 = std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](a1);
  if (v7) {
    BOOL v2 = std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::operator[][abi:ne180100](a1, 0);
  }
  else {
    BOOL v2 = 0;
  }
  BOOL v6 = v2;
  for (unint64_t i = 1; i < v7; ++i)
  {
    BOOL v4 = std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](a1, i);
    if (v6 < v4) {
      BOOL v6 = v4;
    }
  }
  return v6;
}

uint64_t __os_log_helper_16_0_12_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1) = 12;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  *(unsigned char *)(result + 42) = 0;
  *(unsigned char *)(result + 43) = 8;
  *(void *)(result + 44) = a6;
  *(unsigned char *)(result + 52) = 0;
  *(unsigned char *)(result + 53) = 8;
  *(void *)(result + 54) = a7;
  *(unsigned char *)(result + 62) = 0;
  *(unsigned char *)(result + 63) = 8;
  *(void *)(result + 64) = a8;
  *(unsigned char *)(result + 72) = 0;
  *(unsigned char *)(result + 73) = 8;
  *(void *)(result + 74) = a9;
  *(unsigned char *)(result + 82) = 0;
  *(unsigned char *)(result + 83) = 8;
  *(void *)(result + 84) = a10;
  *(unsigned char *)(result + 92) = 0;
  *(unsigned char *)(result + 93) = 8;
  *(void *)(result + 94) = a11;
  *(unsigned char *)(result + 102) = 0;
  *(unsigned char *)(result + 103) = 8;
  *(void *)(result + 104) = a12;
  *(unsigned char *)(result + 112) = 0;
  *(unsigned char *)(result + 113) = 8;
  *(void *)(result + 114) = a13;
  return result;
}

uint64_t *std::valarray<float>::operator=(uint64_t *a1, uint64_t *a2)
{
  if (a1 == a2) {
    return a1;
  }
  else {
    return std::valarray<float>::__assign_range(a1, (_DWORD *)*a2, (_DWORD *)a2[1]);
  }
}

CoreBrightness::MitigationState *CoreBrightness::MitigationState::MitigationState(CoreBrightness::MitigationState *this)
{
  return this;
}

double CoreBrightness::MitigationState::MitigationState(CoreBrightness::MitigationState *this)
{
  *(_DWORD *)this = 0;
  *((unsigned char *)this + 4) = 0;
  *((_DWORD *)this + 2) = 5;
  *((_DWORD *)this + 3) = 60;
  *((_DWORD *)this + 4) = 5;
  *((_DWORD *)this + 5) = 3;
  *((float *)this + 6) = 4.0;
  *((float *)this + 7) = 3.0;
  *((float *)this + 8) = 3.0;
  *((_DWORD *)this + 9) = 15;
  *((_DWORD *)this + 10) = 3;
  *((_DWORD *)this + 11) = *((_DWORD *)this + 9);
  *((_DWORD *)this + 12) = *((_DWORD *)this + 10);
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  double result = 0.0;
  *((_DWORD *)this + 26) = 0;
  return result;
}

double std::__math::fmax[abi:ne180100]<int>(double a1, double a2)
{
  return fmax(a1, a2);
}

double std::__math::fmin[abi:ne180100]<int>(double a1, double a2)
{
  return fmin(a1, a2);
}

void std::valarray<float>::resize(void *a1, unint64_t a2, float a3)
{
  uint64_t v10 = a1;
  unint64_t v9 = a2;
  float v8 = a3;
  uint64_t v3 = std::valarray<float>::size[abi:ne180100](a1);
  std::valarray<float>::__clear((uint64_t)a1, v3);
  if (v9)
  {
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v7);
    BOOL v4 = std::allocator<float>::allocate[abi:ne180100]((uint64_t)&v7, v9);
    a1[1] = v4;
    *a1 = v4;
    for (unint64_t i = v9; i; --i)
    {
      *(float *)a1[1] = v8;
      a1[1] += 4;
    }
  }
}

void std::valarray<float>::__clear(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1;
  uint64_t v4 = a2;
  if (*(void *)a1)
  {
    while (*(void *)(a1 + 8) != *(void *)a1)
      *(void *)(a1 + 8) -= 4;
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v3);
    std::allocator<float>::deallocate[abi:ne180100]((uint64_t)&v3, *(void **)a1);
    *(void *)(a1 + 8) = 0;
    *(void *)a1 = 0;
  }
}

uint64_t std::allocator<float>::allocator[abi:ne180100](uint64_t a1)
{
  return a1;
}

{
  std::__non_trivial_if<true>::__non_trivial_if[abi:ne180100]();
  return a1;
}

void __clang_call_terminate(void *a1)
{
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  unsigned int v1 = (void (*)(void *))MEMORY[0x1E4FBA1F8];
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(exception, MEMORY[0x1E4FBA350], v1);
}

void *std::__scalar_expr<float>::__scalar_expr[abi:ne180100](void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

__n128 *std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](__n128 *a1, uint64_t a2, unint64_t a3, __n128 *a4)
{
  return a1;
}

uint64_t std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1;
}

void *std::__scalar_expr<float>::__scalar_expr[abi:ne180100](void *result, uint64_t a2, uint64_t a3)
{
  *double result = a2;
  result[1] = a3;
  return result;
}

__n128 std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](__n128 *a1, uint64_t a2, unint64_t a3, __n128 *a4)
{
  a1->n128_u64[1] = a3;
  __n128 result = *a4;
  a1[1] = *a4;
  return result;
}

__n128 std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  *(__n128 *)(a1 + 16) = result;
  return result;
}

uint64_t std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::size[abi:ne180100](uint64_t a1)
{
  return std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::size[abi:ne180100](a1);
}

float std::__val_expr<std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::operator[][abi:ne180100](a1, a2);
}

uint64_t std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::size[abi:ne180100](uint64_t a1)
{
  return std::valarray<float>::size[abi:ne180100](*(void **)(a1 + 8));
}

float std::_BinaryOp<std::divides<float>,std::valarray<float>,std::__scalar_expr<float>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (float *)std::valarray<float>::operator[][abi:ne180100](*(void **)(a1 + 8), a2);
  BOOL v2 = (float *)std::__scalar_expr<float>::operator[][abi:ne180100](a1 + 16);
  return std::divides<float>::operator()[abi:ne180100](a1, v4, v2);
}

float std::divides<float>::operator()[abi:ne180100](uint64_t a1, float *a2, float *a3)
{
  return *a2 / *a3;
}

uint64_t std::__scalar_expr<float>::operator[][abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1;
}

__n128 *std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](__n128 *a1, __n128 *a2)
{
  return a1;
}

uint64_t std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  return result;
}

__n128 std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  return result;
}

uint64_t std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](uint64_t a1)
{
  return std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::size[abi:ne180100](a1);
}

uint64_t std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  return a1;
}

void *std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::__val_expr[abi:ne180100](void *a1, const void *a2)
{
  return a1;
}

{
  memcpy(a1, a2, 0x30uLL);
  return a1;
}

uint64_t std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::size[abi:ne180100](uint64_t a1)
{
  return std::valarray<float>::size[abi:ne180100](*(void **)(a1 + 8));
}

__n128 std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::_BinaryOp[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a3;
  *(void *)(a1 + 24) = *(void *)(a3 + 16);
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  return result;
}

uint64_t std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::size[abi:ne180100](uint64_t a1)
{
  return std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::size[abi:ne180100](a1);
}

float std::__val_expr<std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::operator[][abi:ne180100](a1, a2);
}

uint64_t std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::size[abi:ne180100](uint64_t a1)
{
  return std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](a1 + 8);
}

float std::_BinaryOp<std::divides<float>,std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>,std::__scalar_expr<float>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a1;
  uint64_t v6 = a2;
  float v5 = std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::operator[][abi:ne180100](a1 + 8, a2);
  BOOL v2 = (float *)std::__scalar_expr<float>::operator[][abi:ne180100](a1 + 32);
  return std::divides<float>::operator()[abi:ne180100](a1, &v5, v2);
}

float std::__val_expr<std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](a1, a2);
}

float std::_BinaryOp<std::minus<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (float *)std::valarray<float>::operator[][abi:ne180100](*(void **)(a1 + 8), a2);
  BOOL v2 = (float *)std::valarray<float>::operator[][abi:ne180100](*(void **)(a1 + 16), a2);
  return std::minus<float>::operator()[abi:ne180100](a1, v4, v2);
}

float std::minus<float>::operator()[abi:ne180100](uint64_t a1, float *a2, float *a3)
{
  return *a2 - *a3;
}

_DWORD *std::max[abi:ne180100]<int,std::__less<void,void>>(_DWORD *a1, _DWORD *a2)
{
  if (std::__less<void,void>::operator()[abi:ne180100]<int,int>((uint64_t)&v6, a1, a2)) {
    return a2;
  }
  else {
    return a1;
  }
}

BOOL std::__less<void,void>::operator()[abi:ne180100]<int,int>(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return *a2 < *a3;
}

_DWORD *std::min[abi:ne180100]<int,std::__less<void,void>>(_DWORD *a1, _DWORD *a2)
{
  if (std::__less<void,void>::operator()[abi:ne180100]<int,int>((uint64_t)&v6, a2, a1)) {
    return a2;
  }
  else {
    return a1;
  }
}

uint64_t std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1;
}

__n128 *std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](__n128 *a1, __n128 *a2)
{
  return a1;
}

uint64_t std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::_BinaryOp[abi:ne180100](uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  return result;
}

__n128 std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::__val_expr[abi:ne180100](__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  return result;
}

uint64_t std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::size[abi:ne180100](uint64_t a1)
{
  return std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::size[abi:ne180100](a1);
}

BOOL std::__val_expr<std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](a1, a2);
}

BOOL std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (float *)std::valarray<float>::operator[][abi:ne180100](*(void **)(a1 + 8), a2);
  BOOL v2 = (float *)std::valarray<float>::operator[][abi:ne180100](*(void **)(a1 + 16), a2);
  return std::greater<float>::operator()[abi:ne180100](a1, v4, v2);
}

uint64_t std::_BinaryOp<std::greater<float>,std::valarray<float>,std::valarray<float>>::size[abi:ne180100](uint64_t a1)
{
  return std::valarray<float>::size[abi:ne180100](*(void **)(a1 + 8));
}

BOOL std::greater<float>::operator()[abi:ne180100](uint64_t a1, float *a2, float *a3)
{
  return *a2 > *a3;
}

uint64_t *std::valarray<float>::__assign_range(uint64_t *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v10 = a1;
  unint64_t v9 = a2;
  float v8 = a3;
  unint64_t v7 = a3 - a2;
  if (std::valarray<float>::size[abi:ne180100](a1) == v7)
  {
    std::copy[abi:ne180100]<float const*,float *>((uint64_t)v9, (uint64_t)v8, *a1);
  }
  else
  {
    uint64_t v3 = std::valarray<float>::size[abi:ne180100](a1);
    std::valarray<float>::__clear((uint64_t)a1, v3);
    std::allocator<float>::allocator[abi:ne180100]((uint64_t)&v6);
    *a1 = (uint64_t)std::allocator<float>::allocate[abi:ne180100]((uint64_t)&v6, v7);
    a1[1] = *a1 + 4 * v7;
    std::uninitialized_copy[abi:ne180100]<float const*,float *>(v9, v8, *a1);
  }
  return a1;
}

uint64_t std::uninitialized_copy[abi:ne180100]<float const*,float *>(_DWORD *a1, _DWORD *a2, uint64_t a3)
{
  std::__uninitialized_copy[abi:ne180100]<float,float const*,float const*,float *,std::__always_false>(a1, a2, a3);
  return v3;
}

uint64_t std::copy[abi:ne180100]<float const*,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,float const*,float const*,float *>(a1, a2, a3);
  return v3;
}

uint64_t std::__uninitialized_copy[abi:ne180100]<float,float const*,float const*,float *,std::__always_false>(_DWORD *a1, _DWORD *a2, uint64_t a3)
{
  unint64_t v7 = a1;
  char v6 = a2;
  v5[1] = a3;
  for (v5[0] = a3; ; v5[0] += 4)
  {
    LOBYTE(v4) = 0;
    if (v7 != v6) {
      int v4 = std::__always_false::operator()[abi:ne180100]<float *&>() ^ 1;
    }
    if ((v4 & 1) == 0) {
      break;
    }
    v8[2] = v5[0];
    *(_DWORD *)v5[0] = *v7++;
  }
  std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(v8, &v7, v5);
  return v8[0];
}

uint64_t std::__always_false::operator()[abi:ne180100]<float *&>()
{
  return 0;
}

uint64_t std::__destroy[abi:ne180100]<float *>(uint64_t a1, uint64_t a2)
{
  while (a1 != a2)
  {
    std::__destroy_at[abi:ne180100]<float,0>();
    a1 += 4;
  }
  return a1;
}

void *std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(void *result, void *a2, void *a3)
{
  *__n128 result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,float const*,float const*,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,float const*,float const*,float *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,float const*,float const*,float *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,float const*,float const*,float *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,float const*,float const*,float *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v13 = (const void *)std::__unwrap_range[abi:ne180100]<float const*,float const*>(a1, a2);
  uint64_t v14 = v3;
  uint64_t v7 = v3;
  std::__unwrap_iter[abi:ne180100]<float *,std::__unwrap_iter_impl<float *,true>,0>();
  uint64_t v11 = std::__copy_trivial::operator()[abi:ne180100]<float const,float,0>((uint64_t)&v10, v13, v7, v4);
  uint64_t v12 = v5;
  uint64_t v9 = std::__rewrap_range[abi:ne180100]<float const*,float const*>(v17, v11);
  uint64_t v8 = std::__rewrap_iter[abi:ne180100]<float *,float *,std::__unwrap_iter_impl<float *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<float const*,float *>(&v9, &v8);
}

uint64_t std::__unwrap_range[abi:ne180100]<float const*,float const*>(uint64_t a1, uint64_t a2)
{
  v6[2] = a1;
  v6[1] = a2;
  std::__unwrap_iter[abi:ne180100]<float const*,std::__unwrap_iter_impl<float const*,true>,0>();
  v6[0] = v2;
  std::__unwrap_iter[abi:ne180100]<float const*,std::__unwrap_iter_impl<float const*,true>,0>();
  uint64_t v5 = v3;
  return std::make_pair[abi:ne180100]<float const*,float const*>(v6, &v5);
}

uint64_t std::__copy_trivial::operator()[abi:ne180100]<float const,float,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<float const,float>(a2, a3, a4);
}

uint64_t std::make_pair[abi:ne180100]<float const*,float *>(void *a1, void *a2)
{
  std::pair<float const*,float *>::pair[abi:ne180100]<float const*,float *,0>(&v3, a1, a2);
  return v3;
}

uint64_t std::__rewrap_range[abi:ne180100]<float const*,float const*>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<float const*,float const*,std::__unwrap_iter_impl<float const*,true>>(a1, a2);
}

uint64_t std::make_pair[abi:ne180100]<float const*,float const*>(void *a1, void *a2)
{
  std::pair<float const*,float const*>::pair[abi:ne180100]<float const*,float const*,0>(&v3, a1, a2);
  return v3;
}

void std::__unwrap_iter[abi:ne180100]<float const*,std::__unwrap_iter_impl<float const*,true>,0>()
{
}

void *std::pair<float const*,float const*>::pair[abi:ne180100]<float const*,float const*,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<float const*,float const*>::pair[abi:ne180100]<float const*,float const*,0>(void *result, void *a2, void *a3)
{
  *__n128 result = *a2;
  result[1] = *a3;
  return result;
}

void std::__unwrap_iter_impl<float const*,true>::__unwrap[abi:ne180100]()
{
}

uint64_t std::__copy_trivial_impl[abi:ne180100]<float const,float>(const void *a1, uint64_t a2, char *a3)
{
  v7[1] = a1;
  v7[0] = a2;
  char v6 = a3;
  uint64_t v5 = (a2 - (uint64_t)a1) / 4;
  std::__constexpr_memmove[abi:ne180100]<float,float const,0>(a3, a1, v5);
  int v4 = &v6[4 * v5];
  return std::make_pair[abi:ne180100]<float const*&,float *>(v7, &v4);
}

void *std::__constexpr_memmove[abi:ne180100]<float,float const,0>(void *a1, const void *a2, uint64_t a3)
{
  if (a3) {
    memmove(a1, a2, 4 * (a3 - 1) + 4);
  }
  return a1;
}

uint64_t std::make_pair[abi:ne180100]<float const*&,float *>(void *a1, void *a2)
{
  std::pair<float const*,float *>::pair[abi:ne180100]<float const*&,float *,0>(&v3, a1, a2);
  return v3;
}

void *std::pair<float const*,float *>::pair[abi:ne180100]<float const*&,float *,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<float const*,float *>::pair[abi:ne180100]<float const*&,float *,0>(void *result, void *a2, void *a3)
{
  *__n128 result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__rewrap_iter[abi:ne180100]<float const*,float const*,std::__unwrap_iter_impl<float const*,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<float const*,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::__unwrap_iter_impl<float const*,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__to_address[abi:ne180100]<float const>();
  return a1 + 4 * ((a2 - v2) / 4);
}

id getMLModelClass()
{
  uint64_t v9 = 0;
  char v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLModelClass_softClass;
  uint64_t v13 = getMLModelClass_softClass;
  if (!getMLModelClass_softClass)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    uint64_t v5 = __getMLModelClass_block_invoke;
    char v6 = &unk_1E6219058;
    uint64_t v7 = &v9;
    __getMLModelClass_block_invoke((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLArrayBatchProviderClass()
{
  uint64_t v9 = 0;
  char v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLArrayBatchProviderClass_softClass;
  uint64_t v13 = getMLArrayBatchProviderClass_softClass;
  if (!getMLArrayBatchProviderClass_softClass)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    uint64_t v5 = __getMLArrayBatchProviderClass_block_invoke;
    char v6 = &unk_1E6219058;
    uint64_t v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke(uint64_t a1)
{
  CoreMLLibrary();
  Class Class = objc_getClass("MLFeatureValue");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLFeatureValueClass_softClass Class = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary()
{
  uint64_t v1 = CoreMLLibraryCore();
  if (!v1) {
    abort_report_np();
  }
  return v1;
}

uint64_t CoreMLLibraryCore()
{
  if (!CoreMLLibraryCore_frameworkLibrary) {
    __CoreMLLibraryCore_block_invoke();
  }
  return CoreMLLibraryCore_frameworkLibrary;
}

uint64_t __CoreMLLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreMLLibraryCore_frameworkLibrary = result;
  return result;
}

uint64_t __getMLModelClass_block_invoke(uint64_t a1)
{
  CoreMLLibrary();
  Class Class = objc_getClass("MLModel");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLModelClass_softClass Class = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke(uint64_t a1)
{
  CoreMLLibrary();
  Class Class = objc_getClass("MLPredictionOptions");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLPredictionOptionsClass_softClass Class = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke(uint64_t a1)
{
  CoreMLLibrary();
  Class Class = objc_getClass("MLArrayBatchProvider");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLArrayBatchProviderClass_softClass Class = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

BOOL isBrightnessAdjustmentPossible(NSDictionary *a1)
{
  objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a1, "objectForKeyedSubscript:", @"MinNits"), "floatValue");
  float v4 = v1;
  objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a1, "objectForKeyedSubscript:", @"MaxNits"), "floatValue");
  return vabds_f32(v4, v2) > 0.5;
}

uint64_t __os_log_helper_16_2_2_8_32_8_32(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 32;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  return result;
}

void sub_1BA4B8ABC()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1) = 5;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  *(unsigned char *)(result + 42) = 0;
  *(unsigned char *)(result + 43) = 8;
  *(void *)(result + 44) = a6;
  return result;
}

void sub_1BA4BB890()
{
  _Unwind_Resume(v0);
}

void sub_1BA4BBA90(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
  *(void *)(v9 - 32) = a1;
  *(_DWORD *)(v9 - 36) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v9 - 32));
}

uint64_t __os_log_helper_16_2_4_8_32_8_32_8_32_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 4;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 32;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 32;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 64;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_32_8_64(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 64;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 3;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_32_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 3;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 32;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 32;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  return result;
}

uint64_t __os_log_helper_16_0_2_4_0_4_0(uint64_t result, int a2, int a3)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(unsigned char *)(result + 8) = 0;
  *(unsigned char *)(result + 9) = 4;
  *(_DWORD *)(result + 10) = a3;
  return result;
}

void sub_1BA4BE7E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object)
{
}

void sub_1BA4BE944(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object)
{
}

void sub_1BA4BEA54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object)
{
}

void sub_1BA4BEB00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object)
{
}

void sub_1BA4C10FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object)
{
}

void sub_1BA4C1A64(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  *(void *)(v10 - 24) = a1;
  *(_DWORD *)(v10 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 24));
}

void sub_1BA4C1D6C(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj)
{
  *(void *)(v11 - 24) = a1;
  *(_DWORD *)(v11 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v11 - 24));
}

void sub_1BA4C562C(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  *(void *)(v10 - 24) = a1;
  *(_DWORD *)(v10 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 24));
}

void sub_1BA4C6250(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id obj)
{
  *(void *)(v13 - 56) = a1;
  *(_DWORD *)(v13 - 60) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v13 - 56));
}

void sub_1BA4C6484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
}

uint64_t std::vector<float>::push_back[abi:ne180100](uint64_t *a1, float *a2)
{
  unint64_t v5 = a1[1];
  std::vector<float>::__end_cap[abi:ne180100]();
  if (v5 >= *v2)
  {
    uint64_t result = std::vector<float>::__push_back_slow_path<float const&>(a1, a2);
    uint64_t v6 = result;
  }
  else
  {
    uint64_t result = (uint64_t)std::vector<float>::__construct_one_at_end[abi:ne180100]<float const&>((uint64_t)a1, a2);
    uint64_t v6 = v5 + 4;
  }
  a1[1] = v6;
  return result;
}

uint64_t std::vector<float>::back[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 8) - 4;
}

uint64_t __os_log_helper_16_0_4_4_0_8_0_4_0_8_0(uint64_t result, int a2, uint64_t a3, int a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1) = 4;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(unsigned char *)(result + 8) = 0;
  *(unsigned char *)(result + 9) = 8;
  *(void *)(result + 10) = a3;
  *(unsigned char *)(result + 18) = 0;
  *(unsigned char *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  *(unsigned char *)(result + 24) = 0;
  *(unsigned char *)(result + 25) = 8;
  *(void *)(result + 26) = a5;
  return result;
}

uint64_t __os_log_helper_16_2_7_4_0_8_0_8_32_8_32_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1) = 7;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(unsigned char *)(result + 8) = 0;
  *(unsigned char *)(result + 9) = 8;
  *(void *)(result + 10) = a3;
  *(unsigned char *)(result + 18) = 32;
  *(unsigned char *)(result + 19) = 8;
  *(void *)(result + 20) = a4;
  *(unsigned char *)(result + 28) = 32;
  *(unsigned char *)(result + 29) = 8;
  *(void *)(result + 30) = a5;
  *(unsigned char *)(result + 38) = 0;
  *(unsigned char *)(result + 39) = 8;
  *(void *)(result + 40) = a6;
  *(unsigned char *)(result + 48) = 0;
  *(unsigned char *)(result + 49) = 8;
  *(void *)(result + 50) = a7;
  *(unsigned char *)(result + 58) = 0;
  *(unsigned char *)(result + 59) = 8;
  *(void *)(result + 60) = a8;
  return result;
}

BOOL std::vector<float>::empty[abi:ne180100](void *a1)
{
  return *a1 == a1[1];
}

uint64_t std::vector<float>::front[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

void *std::vector<float>::vector[abi:ne180100](void *a1)
{
  return a1;
}

{
  *a1 = 0;
  a1[1] = 0;
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  return a1;
}

void *std::vector<float>::__construct_one_at_end[abi:ne180100]<float const&>(uint64_t a1, float *a2)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, 1);
  std::vector<float>::__alloc[abi:ne180100]();
  uint64_t v5 = v2;
  std::__to_address[abi:ne180100]<float>();
  std::allocator_traits<std::allocator<float>>::construct[abi:ne180100]<float,float const&,void>(v5, v3, v8);
  v7 += 4;
  return std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1BA4C84F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
}

uint64_t std::vector<float>::__push_back_slow_path<float const&>(uint64_t *a1, float *a2)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  std::vector<float>::__alloc[abi:ne180100]();
  uint64_t v13 = v2;
  uint64_t v3 = std::vector<float>::size[abi:ne180100](a1);
  unint64_t v9 = std::vector<float>::__recommend[abi:ne180100](a1, v3 + 1);
  uint64_t v4 = std::vector<float>::size[abi:ne180100](a1);
  std::__split_buffer<float>::__split_buffer(v11, v9, v4, v13);
  uint64_t v10 = v13;
  std::__to_address[abi:ne180100]<float>();
  std::allocator_traits<std::allocator<float>>::construct[abi:ne180100]<float,float const&,void>(v10, v5, v14);
  v12 += 4;
  std::vector<float>::__swap_out_circular_buffer(a1, v11);
  uint64_t v7 = a1[1];
  std::__split_buffer<float>::~__split_buffer(v11);
  return v7;
}

void sub_1BA4C85DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, void *a16)
{
}

float std::allocator_traits<std::allocator<float>>::construct[abi:ne180100]<float,float const&,void>(uint64_t a1, _DWORD *a2, float *a3)
{
  return std::allocator<float>::construct[abi:ne180100]<float,float const&>(a1, a2, a3);
}

float std::allocator<float>::construct[abi:ne180100]<float,float const&>(uint64_t a1, _DWORD *a2, float *a3)
{
  float result = *a3;
  *a2 = *(_DWORD *)a3;
  return result;
}

unint64_t std::vector<float>::__recommend[abi:ne180100](void *a1, uint64_t a2)
{
  v7[1] = a1;
  v7[0] = a2;
  unint64_t v6 = std::vector<float>::max_size((uint64_t)a1);
  if (v7[0] > v6) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  unint64_t v5 = std::vector<float>::capacity[abi:ne180100](a1);
  if (v5 >= v6 / 2) {
    return v6;
  }
  uint64_t v4 = 2 * v5;
  return *std::max[abi:ne180100]<unsigned long>(&v4, v7);
}

void **std::__split_buffer<float>::__split_buffer(void **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v9;
  void v11[2];
  uint64_t v12;
  unint64_t v13;
  void **v14;
  void **v15;

  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  v11[1] = a4;
  uint64_t v15 = a1;
  v11[0] = 0;
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float> &>(a1 + 3, (uint64_t)v11, a4);
  if (v13)
  {
    uint64_t v4 = std::__split_buffer<float>::__alloc[abi:ne180100]((uint64_t)a1);
    *a1 = std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
    uint64_t v13 = v5;
  }
  else
  {
    *a1 = 0;
  }
  unint64_t v6 = (uint64_t)*a1 + 4 * v12;
  a1[2] = (void *)v6;
  a1[1] = (void *)v6;
  unint64_t v9 = (unint64_t)*a1 + 4 * v13;
  std::__split_buffer<float>::__end_cap[abi:ne180100]();
  *uint64_t v7 = v9;
  return v15;
}

void std::vector<float>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  std::vector<float>::__annotate_delete[abi:ne180100]();
  std::vector<float>::__alloc[abi:ne180100]();
  uint64_t v7 = v2;
  std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](v12, a1[1]);
  std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](v11, *a1);
  std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](v10, v14[1]);
  v13[0] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<float>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,float,void>(v7, v12[0], v12[1], v11[0], v11[1], v10[0], v10[1]);
  v13[1] = v3;
  uint64_t v4 = std::reverse_iterator<float *>::base[abi:ne180100]((uint64_t)v13);
  v14[1] = v4;
  std::swap[abi:ne180100]<float *>(a1, v14 + 1);
  std::swap[abi:ne180100]<float *>(a1 + 1, v14 + 2);
  std::vector<float>::__end_cap[abi:ne180100]();
  uint64_t v8 = v5;
  std::__split_buffer<float>::__end_cap[abi:ne180100]();
  std::swap[abi:ne180100]<float *>(v8, v6);
  *uint64_t v14 = v14[1];
  std::vector<float>::size[abi:ne180100](a1);
  std::vector<float>::__annotate_new[abi:ne180100]();
}

void **std::__split_buffer<float>::~__split_buffer(void **a1)
{
  return a1;
}

{
  uint64_t v2;
  void *v3;

  std::__split_buffer<float>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
  {
    uint64_t v2 = std::__split_buffer<float>::__alloc[abi:ne180100]((uint64_t)a1);
    uint64_t v3 = *a1;
    std::__split_buffer<float>::capacity[abi:ne180100](a1);
    std::allocator_traits<std::allocator<float>>::deallocate[abi:ne180100](v2, v3);
  }
  return a1;
}

void std::vector<float>::__throw_length_error[abi:ne180100]()
{
}

void *std::max[abi:ne180100]<unsigned long>(void *a1, void *a2)
{
  return std::max[abi:ne180100]<unsigned long,std::__less<void,void>>(a1, a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  float v1 = (void (*)(void *))MEMORY[0x1E4FBA1C8];
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6218B58, v1);
}

void sub_1BA4C8940(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  *(void *)(v11 - 16) = a1;
  *(_DWORD *)(v11 - 20) = a2;
  __cxa_free_exception(a11);
  _Unwind_Resume(*(_Unwind_Exception **)(v11 - 16));
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  return a1;
}

{
  std::logic_error *result;

  std::logic_error::logic_error(a1, a2);
  float result = a1;
  a1->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void *std::max[abi:ne180100]<unsigned long,std::__less<void,void>>(void *a1, void *a2)
{
  if (std::__less<void,void>::operator()[abi:ne180100]<unsigned long,unsigned long>((uint64_t)&v6, a1, a2)) {
    return a2;
  }
  else {
    return a1;
  }
}

void *std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<float> &>(void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

{
  std::__compressed_pair_elem<float *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<float> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<float> &,void>(a1 + 1, a3);
  return a1;
}

uint64_t std::__split_buffer<float>::__alloc[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair<float *>::second[abi:ne180100](a1 + 24);
}

void std::__split_buffer<float>::__end_cap[abi:ne180100]()
{
}

{
  std::__compressed_pair<float *>::first[abi:ne180100]();
}

void *std::__compressed_pair_elem<std::allocator<float> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<float> &,void>(void *result, uint64_t a2)
{
  *float result = a2;
  return result;
}

uint64_t std::__compressed_pair<float *>::second[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair_elem<std::allocator<float> &,1,false>::__get[abi:ne180100](a1 + 8);
}

uint64_t std::__compressed_pair_elem<std::allocator<float> &,1,false>::__get[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<float>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,float,void>(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return std::move[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(a2, a3, a4, a5, a6, a7);
}

void *std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

uint64_t std::reverse_iterator<float *>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t *std::swap[abi:ne180100]<float *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *float result = *a2;
  *a2 = v2;
  return result;
}

uint64_t std::move[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v13 = a1;
  unint64_t v14 = a2;
  uint64_t v11 = a3;
  uint64_t v12 = a4;
  uint64_t v9 = a5;
  uint64_t v10 = a6;
  std::__move[abi:ne180100]<std::_ClassicAlgPolicy,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>(a1, a2, a3, a4, a5, a6, &v7);
  return v8;
}

_OWORD *std::__move[abi:ne180100]<std::_ClassicAlgPolicy,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>(a1, a2, a3, a4, a5, a6, a7);
}

_OWORD *std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(a1, a2, a3, a4, a5, a6, a7);
}

_OWORD *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  v26.n128_u64[0] = a1;
  v26.n128_u64[1] = a2;
  *(void *)&long long v25 = a3;
  *((void *)&v25 + 1) = a4;
  *(void *)&long long v24 = a5;
  *((void *)&v24 + 1) = a6;
  __n128 v22 = v26;
  long long v21 = v25;
  std::__unwrap_range[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(a1, a2, a3, a4, v23);
  long long v18 = v23[0];
  long long v17 = v23[1];
  v14[1] = v24;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>,0>();
  unint64_t v15 = v7;
  unint64_t v16 = v8;
  std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>(v18, *((uint64_t *)&v18 + 1), v17, *((uint64_t *)&v17 + 1), v7, v8, &v19);
  void v13[2] = v26;
  v13[1] = v19;
  *(void *)&v14[0] = std::__rewrap_range[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(v26.n128_i64[0], v26.n128_i64[1], v19.n128_i64[0]);
  *((void *)&v14[0] + 1) = v9;
  v13[0].n128_u64[0] = std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>>(v24, *((uint64_t *)&v24 + 1), v20);
  v13[0].n128_u64[1] = v10;
  return std::make_pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(v14, v13, a7);
}

_OWORD *std::__unwrap_range[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  v15.n128_u64[0] = a1;
  v15.n128_u64[1] = a2;
  uint64_t v13 = a3;
  uint64_t v14 = a4;
  v11[1] = v15;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>,0>();
  *(void *)&long long v12 = v5;
  *((void *)&v12 + 1) = v6;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>,0>();
  v11[0].n128_u64[0] = v7;
  v11[0].n128_u64[1] = v8;
  return std::make_pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(&v12, v11, a5);
}

_OWORD *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, unint64_t a5@<X5>, unint64_t a6@<X6>, _OWORD *a7@<X8>)
{
  *(void *)&long long v12 = a1;
  *((void *)&v12 + 1) = a2;
  v11[0] = a3;
  v11[1] = a4;
  v10.n128_u64[0] = a5;
  v10.n128_u64[1] = a6;
  while (std::operator!=[abi:ne180100]<float *,float *>((uint64_t)&v12, (uint64_t)v11))
  {
    int v8 = *(_DWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<std::reverse_iterator<float *> &,0>((uint64_t)&v12);
    *(_DWORD *)std::reverse_iterator<float *>::operator*[abi:ne180100]((uint64_t)&v10) = v8;
    std::reverse_iterator<float *>::operator++[abi:ne180100]((uint64_t)&v12);
    std::reverse_iterator<float *>::operator++[abi:ne180100]((uint64_t)&v10);
  }
  return std::make_pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(&v12, &v10, a7);
}

void std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>,0>()
{
}

_OWORD *std::make_pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>@<X0>(_OWORD *a1@<X0>, __n128 *a2@<X1>, _OWORD *a3@<X8>)
{
  return std::pair<std::reverse_iterator<float *>,std::reverse_iterator<float *>>::pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(a3, a1, a2);
}

uint64_t std::__rewrap_range[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>>(a1, a2, a3);
}

uint64_t std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>::__rewrap[abi:ne180100](a1, a2, a3);
}

BOOL std::operator!=[abi:ne180100]<float *,float *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::reverse_iterator<float *>::base[abi:ne180100](a1);
  return v3 != std::reverse_iterator<float *>::base[abi:ne180100](a2);
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<std::reverse_iterator<float *> &,0>(uint64_t a1)
{
  return std::reverse_iterator<float *>::operator*[abi:ne180100](a1);
}

uint64_t std::reverse_iterator<float *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 8) - 4;
}

uint64_t std::reverse_iterator<float *>::operator++[abi:ne180100](uint64_t result)
{
  *(void *)(result + 8) -= 4;
  return result;
}

_OWORD *std::pair<std::reverse_iterator<float *>,std::reverse_iterator<float *>>::pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  return a1;
}

__n128 std::pair<std::reverse_iterator<float *>,std::reverse_iterator<float *>>::pair[abi:ne180100]<std::reverse_iterator<float *>,std::reverse_iterator<float *>,0>(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  *a1 = *a2;
  __n128 result = *a3;
  a1[1] = *a3;
  return result;
}

uint64_t std::__unwrap_iter_impl<std::reverse_iterator<float *>,false>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

void *std::reverse_iterator<float *>::reverse_iterator[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  result[1] = a2;
  return result;
}

void std::__split_buffer<float>::clear[abi:ne180100](uint64_t a1)
{
}

uint64_t std::__split_buffer<float>::capacity[abi:ne180100](void *a1)
{
  std::__split_buffer<float>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 4;
}

void std::__split_buffer<float>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
}

{
  while (a2 != *(void *)(a1 + 16))
  {
    std::__split_buffer<float>::__alloc[abi:ne180100](a1);
    *(void *)(a1 + 16) -= 4;
    std::__to_address[abi:ne180100]<float>();
    std::allocator_traits<std::allocator<float>>::destroy[abi:ne180100]<float,void>();
  }
}

void *std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(void *a1)
{
  return a1;
}

{
  std::__compressed_pair_elem<float *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<float>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

uint64_t std::__compressed_pair_elem<std::allocator<float>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  return a1;
}

void sub_1BA4CA93C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, _Unwind_Exception *exception_object)
{
}

uint64_t findBin(float *a1, uint64_t *a2)
{
  int v8 = a1;
  unint64_t v7 = a2;
  uint64_t v6 = a2;
  uint64_t v5 = std::vector<CBBOLTS::Bin>::begin[abi:ne180100](a2);
  uint64_t v4 = std::vector<CBBOLTS::Bin>::end[abi:ne180100]((uint64_t)v6);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin *>((uint64_t)&v5, (uint64_t)&v4))
  {
    uint64_t v3 = std::__wrap_iter<CBBOLTS::Bin *>::operator*[abi:ne180100]((uint64_t)&v5);
    if (CBBOLTS::Bin::curveUpdateSatisfiesCondition(v3, v8)) {
      return v3;
    }
    std::__wrap_iter<CBBOLTS::Bin *>::operator++[abi:ne180100](&v5);
  }
  return std::vector<CBBOLTS::Bin>::front[abi:ne180100]((uint64_t)v7);
}

uint64_t std::vector<CBBOLTS::Bin>::begin[abi:ne180100](uint64_t *a1)
{
  return std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

{
  return std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

uint64_t std::vector<CBBOLTS::Bin>::end[abi:ne180100](uint64_t a1)
{
  return std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100](a1, *(void *)(a1 + 8));
}

{
  return std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100](a1, *(void *)(a1 + 8));
}

BOOL std::operator!=[abi:ne180100]<CBBOLTS::Bin *>(uint64_t a1, uint64_t a2)
{
  return !std::operator==[abi:ne180100]<CBBOLTS::Bin *>(a1, a2);
}

uint64_t std::__wrap_iter<CBBOLTS::Bin *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

BOOL CBBOLTS::Bin::curveUpdateSatisfiesCondition(uint64_t a1, float *a2)
{
  BOOL v3 = 0;
  if (*a2 >= *(float *)(a1 + 24)) {
    return *a2 < *(float *)(a1 + 28);
  }
  return v3;
}

void *std::__wrap_iter<CBBOLTS::Bin *>::operator++[abi:ne180100](void *result)
{
  *result += 48;
  return result;
}

uint64_t std::vector<CBBOLTS::Bin>::front[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

void CBBOLTS::Bin::push(void *a1, unint64_t a2, unint64_t a3)
{
  v4.n128_u64[0] = a2;
  v4.n128_u64[1] = a3;
  while ((unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() >= a1[5])
    std::list<AAB::CurveUpdate>::pop_front((uint64_t)a1);
  std::list<AAB::CurveUpdate>::push_back(a1, &v4);
}

uint64_t std::list<AAB::CurveUpdate>::size[abi:ne180100]()
{
  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  return *(void *)v0;
}

void std::list<AAB::CurveUpdate>::pop_front(uint64_t a1)
{
  std::__list_imp<AAB::CurveUpdate>::__unlink_nodes(*(void *)(a1 + 8), *(void *)(a1 + 8));
  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  --*v1;
  std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
  std::__list_imp<AAB::CurveUpdate>::__delete_node[abi:ne180100]<>(a1, v2);
}

void std::list<AAB::CurveUpdate>::push_back(void *a1, __n128 *a2)
{
  std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate>((uint64_t)a1, 0, 0, a2);
  std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
  std::list<AAB::CurveUpdate>::__link_nodes_at_back(a1, v2, v2);
  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  ++*v3;
}

{
  uint64_t v2;
  void *v3;

  std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>((uint64_t)a1, 0, 0, a2);
  std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
  std::list<AAB::CurveUpdate>::__link_nodes_at_back(a1, v2, v2);
  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  ++*v3;
}

uint64_t *CBBOLTS::serializeBins@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  int v29 = a2;
  int v28 = a1;
  char v27 = 0;
  std::vector<AAB::CurveUpdate>::vector[abi:ne180100](a2);
  v26[1] = v28;
  v26[0] = std::vector<CBBOLTS::Bin>::begin[abi:ne180100](v28);
  uint64_t v25 = std::vector<CBBOLTS::Bin>::end[abi:ne180100]((uint64_t)v28);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin const*>((uint64_t)v26, (uint64_t)&v25))
  {
    long long v24 = (CBBOLTS::Bin *)std::__wrap_iter<CBBOLTS::Bin const*>::operator*[abi:ne180100]((uint64_t)v26);
    uint64_t i = 0;
    CBBOLTS::Bin::updates(v24, v22);
    uint64_t v4 = std::list<AAB::CurveUpdate>::size[abi:ne180100]();
    std::list<AAB::CurveUpdate>::~list((uint64_t)v22);
    for (uint64_t i = v4; ; ++i)
    {
      unint64_t v3 = i;
      if (v3 >= *(void *)(CBBOLTS::Bin::configuration(v24) + 16)) {
        break;
      }
      v21.n128_u64[0] = *(void *)(CBBOLTS::Bin::configuration(v24) + 8);
      v21.n128_u64[1] = -1;
      std::vector<AAB::CurveUpdate>::push_back[abi:ne180100](a2, &v21);
    }
    std::__wrap_iter<CBBOLTS::Bin const*>::operator++[abi:ne180100](v26);
  }
  std::vector<AAB::CurveUpdate>::vector[abi:ne180100](v20);
  __n128 v19 = v28;
  uint64_t v18 = std::vector<CBBOLTS::Bin>::begin[abi:ne180100](v28);
  uint64_t v17 = std::vector<CBBOLTS::Bin>::end[abi:ne180100]((uint64_t)v19);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin const*>((uint64_t)&v18, (uint64_t)&v17))
  {
    unint64_t v16 = (CBBOLTS::Bin *)std::__wrap_iter<CBBOLTS::Bin const*>::operator*[abi:ne180100]((uint64_t)&v18);
    CBBOLTS::Bin::updates(v16, v15);
    v15[3] = v15;
    uint64_t v14 = std::list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v15);
    uint64_t v13 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
    while (std::operator!=[abi:ne180100](&v14, &v13))
    {
      long long v12 = (__n128 *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
      std::vector<AAB::CurveUpdate>::push_back[abi:ne180100](v20, v12);
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v14);
    }
    std::list<AAB::CurveUpdate>::~list((uint64_t)v15);
    std::__wrap_iter<CBBOLTS::Bin const*>::operator++[abi:ne180100](&v18);
  }
  uint64_t v11 = std::vector<AAB::CurveUpdate>::begin[abi:ne180100](v20);
  uint64_t v10 = std::vector<AAB::CurveUpdate>::end[abi:ne180100]((uint64_t)v20);
  std::sort[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(v11, v10);
  uint64_t v8 = std::vector<AAB::CurveUpdate>::end[abi:ne180100]((uint64_t)a2);
  std::__wrap_iter<AAB::CurveUpdate const*>::__wrap_iter[abi:ne180100]<AAB::CurveUpdate*,0>(&v9, (uint64_t)&v8);
  uint64_t v7 = std::vector<AAB::CurveUpdate>::begin[abi:ne180100](v20);
  uint64_t v6 = std::vector<AAB::CurveUpdate>::end[abi:ne180100]((uint64_t)v20);
  std::vector<AAB::CurveUpdate>::insert<std::__wrap_iter<AAB::CurveUpdate*>,0>(a2, v9, v7, v6);
  char v27 = 1;
  __n128 result = std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](v20);
  if ((v27 & 1) == 0) {
    return std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](a2);
  }
  return result;
}

void *std::vector<AAB::CurveUpdate>::vector[abi:ne180100](void *a1)
{
  return a1;
}

{
  *a1 = 0;
  a1[1] = 0;
  std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  return a1;
}

BOOL std::operator!=[abi:ne180100]<CBBOLTS::Bin const*>(uint64_t a1, uint64_t a2)
{
  return !std::operator==[abi:ne180100]<CBBOLTS::Bin const*>(a1, a2);
}

uint64_t std::__wrap_iter<CBBOLTS::Bin const*>::operator*[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

void *CBBOLTS::Bin::updates@<X0>(CBBOLTS::Bin *this@<X0>, void *a2@<X8>)
{
  return std::list<AAB::CurveUpdate>::list(a2, (uint64_t)this);
}

uint64_t std::list<AAB::CurveUpdate>::~list(uint64_t a1)
{
  return a1;
}

{
  std::__list_imp<AAB::CurveUpdate>::~__list_imp(a1);
  return a1;
}

uint64_t CBBOLTS::Bin::configuration(CBBOLTS::Bin *this)
{
  return (uint64_t)this + 24;
}

uint64_t std::vector<AAB::CurveUpdate>::push_back[abi:ne180100](uint64_t *a1, __n128 *a2)
{
  unint64_t v5 = a1[1];
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  if (v5 >= *v2)
  {
    uint64_t result = std::vector<AAB::CurveUpdate>::__push_back_slow_path<AAB::CurveUpdate>(a1, a2);
    uint64_t v6 = result;
  }
  else
  {
    uint64_t result = (uint64_t)std::vector<AAB::CurveUpdate>::__construct_one_at_end[abi:ne180100]<AAB::CurveUpdate>((uint64_t)a1, a2);
    uint64_t v6 = v5 + 16;
  }
  a1[1] = v6;
  return result;
}

{
  unint64_t *v2;
  uint64_t result;
  unint64_t v5;
  uint64_t v6;

  unint64_t v5 = a1[1];
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  if (v5 >= *v2)
  {
    uint64_t result = std::vector<AAB::CurveUpdate>::__push_back_slow_path<AAB::CurveUpdate const&>(a1, a2);
    uint64_t v6 = result;
  }
  else
  {
    uint64_t result = (uint64_t)std::vector<AAB::CurveUpdate>::__construct_one_at_end[abi:ne180100]<AAB::CurveUpdate const&>((uint64_t)a1, a2);
    uint64_t v6 = v5 + 16;
  }
  a1[1] = v6;
  return result;
}

void *std::__wrap_iter<CBBOLTS::Bin const*>::operator++[abi:ne180100](void *result)
{
  *result += 48;
  return result;
}

uint64_t std::list<AAB::CurveUpdate>::begin[abi:ne180100](uint64_t a1)
{
  return std::__list_imp<AAB::CurveUpdate>::begin[abi:ne180100](a1);
}

{
  return std::__list_imp<AAB::CurveUpdate>::begin[abi:ne180100](a1);
}

uint64_t std::list<AAB::CurveUpdate>::end[abi:ne180100]()
{
  return std::__list_imp<AAB::CurveUpdate>::end[abi:ne180100]();
}

{
  return std::__list_imp<AAB::CurveUpdate>::end[abi:ne180100]();
}

BOOL std::operator!=[abi:ne180100](void *a1, void *a2)
{
  return !std::operator==[abi:ne180100](a1, a2);
}

{
  return !std::operator==[abi:ne180100](a1, a2);
}

uint64_t std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]()
{
  std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
  return std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v0);
}

uint64_t std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100](uint64_t result)
{
  *(void *)uint64_t result = *(void *)(*(void *)result + 8);
  return result;
}

void std::sort[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  uint64_t v3 = a2;
  std::__sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(a1, a2, (uint64_t)&v2);
}

uint64_t std::vector<AAB::CurveUpdate>::begin[abi:ne180100](uint64_t *a1)
{
  return std::vector<AAB::CurveUpdate>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

uint64_t std::vector<AAB::CurveUpdate>::end[abi:ne180100](uint64_t a1)
{
  return std::vector<AAB::CurveUpdate>::__make_iter[abi:ne180100](a1, *(void *)(a1 + 8));
}

uint64_t std::vector<AAB::CurveUpdate>::insert<std::__wrap_iter<AAB::CurveUpdate*>,0>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = std::distance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(a3, a4);
  return std::vector<AAB::CurveUpdate>::__insert_with_size[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>>(a1, a2, a3, a4, v4);
}

uint64_t *std::__wrap_iter<AAB::CurveUpdate const*>::__wrap_iter[abi:ne180100]<AAB::CurveUpdate*,0>(uint64_t *a1, uint64_t a2)
{
  return a1;
}

{
  uint64_t v2;
  uint64_t *result;

  char v2 = std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a2);
  uint64_t result = a1;
  *a1 = v2;
  return result;
}

uint64_t *std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](uint64_t *a1)
{
  return a1;
}

{
  uint64_t *v3[2];

  v3[1] = a1;
  std::vector<AAB::CurveUpdate>::__destroy_vector::__destroy_vector[abi:ne180100](v3, (uint64_t)a1);
  std::vector<AAB::CurveUpdate>::__destroy_vector::operator()[abi:ne180100](v3);
  return a1;
}

void CBBOLTS::addCurveUpdateToBuffer(uint64_t a1, unint64_t a2, unint64_t a3)
{
  v14.n128_u64[0] = a2;
  v14.n128_u64[1] = a3;
  uint64_t v13 = a1;
  if (!*(void *)(a1 + 24) || std::list<AAB::CurveUpdate>::empty[abi:ne180100]())
  {
    while ((unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() >= *(void *)(a1 + 80))
      std::list<AAB::CurveUpdate>::pop_front(a1 + 88);
    std::list<AAB::CurveUpdate>::push_back((void *)(a1 + 88), &v14);
  }
  else
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 24));
    dispatch_release(*(dispatch_object_t *)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    *(__n128 *)std::list<AAB::CurveUpdate>::back[abi:ne180100]() = v14;
  }
  if (*(void *)(a1 + 16))
  {
    *(void *)(a1 + 24) = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(a1 + 16));
    source = *(NSObject **)(a1 + 24);
    dispatch_time_t v3 = dispatch_time(0, 5000000000);
    dispatch_source_set_timer(source, v3, 0xFFFFFFFFFFFFFFFFLL, 0);
    uint64_t v4 = *(NSObject **)(a1 + 24);
    uint64_t handler = MEMORY[0x1E4F143A8];
    int v8 = -1073741824;
    int v9 = 0;
    uint64_t v10 = ___ZN7CBBOLTS22addCurveUpdateToBufferEN3AAB11CurveUpdateE_block_invoke;
    uint64_t v11 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v12 = a1;
    dispatch_source_set_event_handler(v4, &handler);
    dispatch_resume(*(dispatch_object_t *)(a1 + 24));
  }
}

BOOL std::list<AAB::CurveUpdate>::empty[abi:ne180100]()
{
  return std::__list_imp<AAB::CurveUpdate>::empty[abi:ne180100]();
}

uint64_t std::list<AAB::CurveUpdate>::back[abi:ne180100]()
{
  std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
  return std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v0);
}

void ___ZN7CBBOLTS22addCurveUpdateToBufferEN3AAB11CurveUpdateE_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 24));
  dispatch_release(*(dispatch_object_t *)(v1 + 24));
  *(void *)(v1 + 24) = 0;
}

BOOL CBBOLTS::binUpdates@<W0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v16 = a3;
  uint64_t v15 = a1;
  __n128 v14 = a2;
  char v13 = 0;
  std::vector<CBBOLTS::Bin>::vector[abi:ne180100](a3);
  unint64_t v3 = std::vector<CBBOLTS::BinConfiguration>::size[abi:ne180100](v14);
  std::vector<CBBOLTS::Bin>::reserve(a3, v3);
  v12[1] = v14;
  v12[0] = std::vector<CBBOLTS::BinConfiguration>::begin[abi:ne180100](v14);
  uint64_t v11 = std::vector<CBBOLTS::BinConfiguration>::end[abi:ne180100]((uint64_t)v14);
  while (std::operator!=[abi:ne180100]<CBBOLTS::BinConfiguration const*>((uint64_t)v12, (uint64_t)&v11))
  {
    uint64_t v10 = (__n128 *)std::__wrap_iter<CBBOLTS::BinConfiguration const*>::operator*[abi:ne180100]((uint64_t)v12);
    std::vector<CBBOLTS::Bin>::emplace_back<CBBOLTS::BinConfiguration const&>(a3, v10);
    std::__wrap_iter<CBBOLTS::BinConfiguration const*>::operator++[abi:ne180100](v12);
  }
  v9[1] = v15;
  v9[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100](v15);
  uint64_t v8 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (1)
  {
    BOOL result = std::operator!=[abi:ne180100](v9, &v8);
    if (!result) {
      break;
    }
    uint64_t v7 = std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    Bin = (void *)findBin((float *)v7, a3);
    CBBOLTS::Bin::push(Bin, *(void *)v7, *(void *)(v7 + 8));
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v9);
  }
  return result;
}

void *std::vector<CBBOLTS::Bin>::vector[abi:ne180100](void *a1)
{
  return a1;
}

{
  *a1 = 0;
  a1[1] = 0;
  std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  return a1;
}

void **std::vector<CBBOLTS::Bin>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v10 = a1;
  unint64_t v9 = a2;
  BOOL result = (void **)std::vector<CBBOLTS::Bin>::capacity[abi:ne180100](a1);
  if (a2 > (unint64_t)result)
  {
    if (v9 > std::vector<CBBOLTS::Bin>::max_size((uint64_t)a1)) {
      std::vector<CBBOLTS::Bin>::__throw_length_error[abi:ne180100]();
    }
    std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
    uint64_t v8 = v3;
    uint64_t v4 = std::vector<CBBOLTS::Bin>::size[abi:ne180100](a1);
    std::__split_buffer<CBBOLTS::Bin>::__split_buffer(v7, v9, v4, v8);
    std::vector<CBBOLTS::Bin>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CBBOLTS::Bin>::~__split_buffer(v7);
  }
  return result;
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::size[abi:ne180100](void *a1)
{
  return (a1[1] - *a1) / 24;
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::begin[abi:ne180100](uint64_t *a1)
{
  return std::vector<CBBOLTS::BinConfiguration>::__make_iter[abi:ne180100]((uint64_t)a1, *a1);
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::end[abi:ne180100](uint64_t a1)
{
  return std::vector<CBBOLTS::BinConfiguration>::__make_iter[abi:ne180100](a1, *(void *)(a1 + 8));
}

BOOL std::operator!=[abi:ne180100]<CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2)
{
  return !std::operator==[abi:ne180100]<CBBOLTS::BinConfiguration const*>(a1, a2);
}

uint64_t std::__wrap_iter<CBBOLTS::BinConfiguration const*>::operator*[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::vector<CBBOLTS::Bin>::emplace_back<CBBOLTS::BinConfiguration const&>(uint64_t *a1, __n128 *a2)
{
  unint64_t v5 = a1[1];
  std::vector<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  if (v5 >= *v2)
  {
    uint64_t result = std::vector<CBBOLTS::Bin>::__emplace_back_slow_path<CBBOLTS::BinConfiguration const&>(a1, a2);
    uint64_t v6 = result;
  }
  else
  {
    uint64_t result = (uint64_t)std::vector<CBBOLTS::Bin>::__construct_one_at_end[abi:ne180100]<CBBOLTS::BinConfiguration const&>((uint64_t)a1, a2);
    uint64_t v6 = v5 + 48;
  }
  a1[1] = v6;
  return result;
}

void *std::__wrap_iter<CBBOLTS::BinConfiguration const*>::operator++[abi:ne180100](void *result)
{
  *result += 24;
  return result;
}

uint64_t *std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](uint64_t *a1)
{
  return a1;
}

{
  uint64_t *v3[2];

  v3[1] = a1;
  std::vector<CBBOLTS::Bin>::__destroy_vector::__destroy_vector[abi:ne180100](v3, (uint64_t)a1);
  std::vector<CBBOLTS::Bin>::__destroy_vector::operator()[abi:ne180100](v3);
  return a1;
}

float CBBOLTS::setCurveBasedOnModelPrediction(uint64_t a1, void *a2, void *a3)
{
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:"), "floatValue");
  *(_DWORD *)a1 = v3;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:"), "floatValue");
  *(_DWORD *)(a1 + 8) = v4;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:"), "floatValue");
  *(_DWORD *)(a1 + 20) = v5;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:"), "floatValue");
  float v12 = v6;
  objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", 0), "floatValue");
  *(_DWORD *)(a1 + 4) = v7;
  objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", 1), "floatValue");
  *(_DWORD *)(a1 + 12) = v8;
  objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", 2), "floatValue");
  *(_DWORD *)(a1 + 28) = v9;
  objc_msgSend((id)objc_msgSend(a3, "objectAtIndexedSubscript:", 3), "floatValue");
  *(_DWORD *)(a1 + 16) = 0;
  *(float *)(a1 + 24) = *(float *)(a1 + 12)
                      - (float)((float)((float)(*(float *)(a1 + 28) - *(float *)(a1 + 12))
                                      / (float)(*(float *)(a1 + 20) - *(float *)(a1 + 8)))
                              * *(float *)(a1 + 8));
  *(float *)(a1 + 84) = (float)(v10 - *(float *)(a1 + 28)) / (float)(v12 - *(float *)(a1 + 20));
  *(_DWORD *)(a1 + 32) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(CFAbsoluteTime *)(a1 + 88) = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)(a1 + 96) = 3;
  float result = 150000.0;
  *(_DWORD *)(a1 + 100) = 1209170944;
  return result;
}

uint64_t CBBOLTS::CBBOLTS(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v23 = a1;
  id v22 = a2;
  uint64_t v21 = a3;
  long long v20 = a4;
  uint64_t v24 = a1;
  AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy((AAB::PreferenceUpdateCurveStrategy *)a1);
  *(void *)a1 = &unk_1F13F1058;
  *(void *)(a1 + 8) = os_log_create("com.apple.CoreBrightness.CBBOLTS", "default");
  *(void *)(a1 + 16) = dispatch_queue_create("CBBOLTS", 0);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100]((void *)(a1 + 56), a4);
  *(void *)(a1 + 80) = v21;
  std::list<AAB::CurveUpdate>::list[abi:ne180100]((void *)(a1 + 88));
  if (!*(void *)(a1 + 8))
  {
    __n128 v19 = 0;
    uint64_t v11 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
    __n128 v19 = v11;
    char v18 = 16;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v19;
      os_log_type_t type = v18;
      __os_log_helper_16_0_0(v17);
      _os_log_error_impl(&dword_1BA438000, log, type, "Failed to create CBBOLTS log handle", v17, 2u);
    }
  }
  if (!*(void *)(a1 + 16))
  {
    unint64_t v16 = 0;
    if (*(void *)(a1 + 8))
    {
      int v8 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v8 = inited;
    }
    unint64_t v16 = v8;
    char v15 = 16;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v5 = v16;
      os_log_type_t v6 = v15;
      __os_log_helper_16_0_0(v14);
      _os_log_error_impl(&dword_1BA438000, v5, v6, "Failed to create CBBOLTS queue", v14, 2u);
    }
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = v22;
  *(unsigned char *)(a1 + 216) = 0;
  return v24;
}

{
  CBBOLTS::CBBOLTS(a1, a2, a3, a4);
  return a1;
}

{
  NSObject *v5;
  os_log_type_t v6;
  uint64_t inited;
  NSObject *v8;
  NSObject *log;
  os_log_type_t type;
  NSObject *v11;
  uint8_t v14[7];
  char v15;
  NSObject *v16;
  uint8_t v17[3];
  char v18;
  NSObject *v19;
  void *v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  uint64_t v24;

  uint64_t v23 = a1;
  id v22 = a2;
  uint64_t v21 = a3;
  long long v20 = a4;
  uint64_t v24 = a1;
  AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy((AAB::PreferenceUpdateCurveStrategy *)a1);
  *(void *)a1 = &unk_1F13F1058;
  *(void *)(a1 + 8) = os_log_create("com.apple.CoreBrightness.CBBOLTS", "default");
  *(void *)(a1 + 16) = dispatch_queue_create("CBBOLTS", 0);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100]((void *)(a1 + 56), a4);
  *(void *)(a1 + 80) = v21;
  std::list<AAB::CurveUpdate>::list[abi:ne180100]((void *)(a1 + 88));
  if (!*(void *)(a1 + 8))
  {
    __n128 v19 = 0;
    uint64_t v11 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
    __n128 v19 = v11;
    char v18 = 16;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v19;
      os_log_type_t type = v18;
      __os_log_helper_16_0_0(v17);
      _os_log_error_impl(&dword_1BA438000, log, type, "Failed to create CBBOLTS log handle", v17, 2u);
    }
  }
  if (!*(void *)(a1 + 16))
  {
    unint64_t v16 = 0;
    if (*(void *)(a1 + 8))
    {
      int v8 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v8 = inited;
    }
    unint64_t v16 = v8;
    char v15 = 16;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v5 = v16;
      os_log_type_t v6 = v15;
      __os_log_helper_16_0_0(v14);
      _os_log_error_impl(&dword_1BA438000, v5, v6, "Failed to create CBBOLTS queue", v14, 2u);
    }
  }
  *(void *)(a1 + 48) = v22;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  return v24;
}

{
  CBBOLTS::CBBOLTS(a1, a2, a3, a4);
  return a1;
}

AAB::PreferenceUpdateCurveStrategy *AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy(AAB::PreferenceUpdateCurveStrategy *this)
{
  AAB::UpdateCurveStrategy::UpdateCurveStrategy(this);
  float result = this;
  *(void *)this = &unk_1F13F1168;
  return result;
}

{
  AAB::PreferenceUpdateCurveStrategy::PreferenceUpdateCurveStrategy(this);
  return this;
}

void *std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100](void *a1, void *a2)
{
  return a1;
}

{
  uint64_t *v2;
  void *v3;
  void *v4;
  void *v5;
  void *result;
  uint64_t v7;

  *a1 = 0;
  a1[1] = 0;
  std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::BinConfiguration>>(a1 + 2);
  *a1 = *a2;
  a1[1] = a2[1];
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  int v7 = *v2;
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  *int v3 = v7;
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  int v5 = v4;
  float result = a1;
  *int v5 = 0;
  a2[1] = 0;
  *a2 = 0;
  return result;
}

void *std::list<AAB::CurveUpdate>::list[abi:ne180100](void *a1)
{
  return a1;
}

{
  std::__list_imp<AAB::CurveUpdate>::__list_imp(a1);
  return a1;
}

uint64_t *std::vector<CBBOLTS::BinConfiguration>::~vector[abi:ne180100](uint64_t *a1)
{
  return a1;
}

{
  uint64_t *v3[2];

  v3[1] = a1;
  std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](v3, (uint64_t)a1);
  std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::operator()[abi:ne180100](v3);
  return a1;
}

void AAB::PreferenceUpdateCurveStrategy::~PreferenceUpdateCurveStrategy(AAB::PreferenceUpdateCurveStrategy *this)
{
}

{
  AAB::PreferenceUpdateCurveStrategy::~PreferenceUpdateCurveStrategy(this);
}

{
  AAB::PreferenceUpdateCurveStrategy::~PreferenceUpdateCurveStrategy(this);
  MEMORY[0x1BA9EC4A0](this, 0x81C40B8603338);
}

void CBBOLTS::~CBBOLTS(CBBOLTS *this)
{
  int v9 = this;
  float v10 = this;
  *(void *)this = &unk_1F13F1058;
  if (*((void *)this + 2))
  {
    uint64_t v1 = *((void *)this + 2);
    uint64_t block = MEMORY[0x1E4F143A8];
    int v4 = -1073741824;
    int v5 = 0;
    os_log_type_t v6 = ___ZN7CBBOLTSD2Ev_block_invoke;
    int v7 = &__block_descriptor_40_e5_v8__0l;
    int v8 = this;
    dispatch_sync(v1, &block);
    dispatch_release(*((dispatch_object_t *)this + 2));
    *((void *)this + 2) = 0;
  }
  else
  {
    if (*((void *)this + 3))
    {
      dispatch_source_cancel(*((dispatch_source_t *)this + 3));
      dispatch_release(*((dispatch_object_t *)this + 3));
      *((void *)this + 3) = 0;
    }
    if (*((void *)this + 4))
    {
      dispatch_source_cancel(*((dispatch_source_t *)this + 4));
      dispatch_release(*((dispatch_object_t *)this + 4));
      *((void *)this + 4) = 0;
    }
  }
  std::list<AAB::CurveUpdate>::~list((uint64_t)this + 88);
  std::vector<CBBOLTS::BinConfiguration>::~vector[abi:ne180100]((uint64_t *)this + 7);
  AAB::PreferenceUpdateCurveStrategy::~PreferenceUpdateCurveStrategy(this);
}

{
  CBBOLTS::~CBBOLTS(this);
}

{
  CBBOLTS::~CBBOLTS(this);
  MEMORY[0x1BA9EC4A0](this, 0x10A1C40123D1288);
}

void ___ZN7CBBOLTSD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 24))
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 24));
    dispatch_release(*(dispatch_object_t *)(v1 + 24));
    *(void *)(v1 + 24) = 0;
  }
  if (*(void *)(v1 + 32))
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 32));
    dispatch_release(*(dispatch_object_t *)(v1 + 32));
    *(void *)(v1 + 32) = 0;
  }
}

void CBBOLTS::createUsingModelURL(CBBOLTS *this, NSURL *a2)
{
}

void sub_1BA4CDBCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, __int16 a16, char a17, char a18, int a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a18) {
    MEMORY[0x1BA9EC4A0](a15, a14);
  }
  _Unwind_Resume(a1);
}

void *std::vector<CBBOLTS::BinConfiguration>::vector[abi:ne180100](void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

{
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned char v10[23];
  uint64_t v11;
  void *v12;
  void v13[2];
  void *v14;

  v13[0] = a2;
  v13[1] = a3;
  float v12 = a1;
  __n128 v14 = a1;
  *a1 = 0;
  a1[1] = 0;
  uint64_t v11 = 0;
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](&v9, (uint64_t)a1);
  std::__make_exception_guard[abi:ne180100]<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>(v9, (uint64_t)v10);
  if (std::initializer_list<CBBOLTS::BinConfiguration>::size[abi:ne180100]((uint64_t)v13))
  {
    int v3 = std::initializer_list<CBBOLTS::BinConfiguration>::size[abi:ne180100]((uint64_t)v13);
    std::vector<CBBOLTS::BinConfiguration>::__vallocate[abi:ne180100](a1, v3);
    os_log_type_t v6 = std::initializer_list<CBBOLTS::BinConfiguration>::begin[abi:ne180100]((uint64_t)v13);
    int v7 = std::initializer_list<CBBOLTS::BinConfiguration>::end[abi:ne180100](v13);
    int v4 = std::initializer_list<CBBOLTS::BinConfiguration>::size[abi:ne180100]((uint64_t)v13);
    std::vector<CBBOLTS::BinConfiguration>::__construct_at_end<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>((uint64_t)a1, v6, v7, v4);
  }
  std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__complete[abi:ne180100]((uint64_t)v10);
  std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v10);
  return v14;
}

uint64_t CBBOLTS::loadModel(CBBOLTS *this)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v30 = this;
  if (!*((void *)this + 5))
  {
    int v29 = 0;
    if (*((void *)this + 1))
    {
      uint64_t v17 = *((void *)this + 1);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v17 = inited;
    }
    int v29 = v17;
    char v28 = 1;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      os_log_t log = v29;
      os_log_type_t type = v28;
      __os_log_helper_16_0_0(v27);
      _os_log_impl(&dword_1BA438000, log, type, "Loading BOLTS ML model.", v27, 2u);
    }
    __n128 v26 = 0;
    if (*((void *)this + 1))
    {
      char v13 = *((void *)this + 1);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v12 = init_default_corebrightness_log();
      }
      char v13 = v12;
    }
    __n128 v26 = v13;
    char v25 = 1;
    unint64_t v24 = 0xEEEEB0B5B2B2EEEELL;
    if (os_signpost_enabled(v13))
    {
      int v9 = v26;
      os_signpost_type_t v10 = v25;
      os_signpost_id_t spid = v24;
      __os_log_helper_16_0_0(v23);
      _os_signpost_emit_with_name_impl(&dword_1BA438000, v9, v10, spid, "LoadBOLTSModel", (const char *)&unk_1BA61B929, v23, 2u);
    }
    *((void *)this + 5) = CBBOLTS::initializeMLABModelFromURL(*((CBBOLTS **)this + 6), v1);
    id v22 = 0;
    if (*((void *)this + 1))
    {
      int v8 = *((void *)this + 1);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v7 = init_default_corebrightness_log();
      }
      int v8 = v7;
    }
    id v22 = v8;
    char v21 = 2;
    unint64_t v20 = 0xEEEEB0B5B2B2EEEELL;
    if (os_signpost_enabled(v8))
    {
      int v4 = v22;
      os_signpost_type_t v5 = v21;
      os_signpost_id_t v6 = v20;
      __os_log_helper_16_0_0(v19);
      _os_signpost_emit_with_name_impl(&dword_1BA438000, v4, v5, v6, "LoadBOLTSModel", (const char *)&unk_1BA61B929, v19, 2u);
    }
  }
  if (*((void *)this + 5))
  {
    char v31 = 1;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      int v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      int v3 = init_default_corebrightness_log();
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_64((uint64_t)v32, *((void *)this + 6));
      _os_log_error_impl(&dword_1BA438000, v3, OS_LOG_TYPE_ERROR, "Failed to create model using URL %@", v32, 0xCu);
    }
    char v31 = 0;
  }
  return v31 & 1;
}

MLAB *CBBOLTS::initializeMLABModelFromURL(CBBOLTS *this, NSURL *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v8 = this;
  uint64_t v7 = 0;
  id v6 = objc_alloc_init((Class)getMLModelConfigurationClass());
  [v6 setComputeUnits:0];
  char v2 = [MLAB alloc];
  os_signpost_type_t v5 = [(MLAB *)v2 initWithContentsOfURL:v8 configuration:v6 error:&v7];

  if (v5 && !v7) {
    return v5;
  }
  if (_COREBRIGHTNESS_LOG_DEFAULT) {
    uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
  }
  else {
    uint64_t inited = init_default_corebrightness_log();
  }
  if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
  {
    __os_log_helper_16_2_1_8_64((uint64_t)v10, v7);
    _os_log_error_impl(&dword_1BA438000, inited, OS_LOG_TYPE_ERROR, "Error during model initialisation: %@", v10, 0xCu);
  }

  return 0;
}

void CBBOLTS::unloadModel(dispatch_source_t *this, float a2)
{
  char v13 = this;
  float v12 = a2;
  if (this[4])
  {
    dispatch_source_cancel(this[4]);
    dispatch_release(this[4]);
    this[4] = 0;
  }
  if (this[2])
  {
    this[4] = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, this[2]);
    source = this[4];
    dispatch_time_t v2 = dispatch_time(0, (uint64_t)(float)(v12 * 1000000000.0));
    dispatch_source_set_timer(source, v2, 0xFFFFFFFFFFFFFFFFLL, 0);
    int v3 = this[4];
    uint64_t handler = MEMORY[0x1E4F143A8];
    int v7 = -1073741824;
    int v8 = 0;
    int v9 = ___ZN7CBBOLTS11unloadModelEf_block_invoke;
    os_signpost_type_t v10 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v11 = this;
    dispatch_source_set_event_handler(v3, &handler);
    dispatch_resume(this[4]);
  }
}

void ___ZN7CBBOLTS11unloadModelEf_block_invoke(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v9 = a1;
  uint64_t v5 = *(void *)(a1 + 32);
  dispatch_source_cancel(*(dispatch_source_t *)(v5 + 32));
  dispatch_release(*(dispatch_object_t *)(v5 + 32));
  *(void *)(v5 + 32) = 0;
  if (*(void *)(v5 + 40))
  {
    int v8 = 0;
    if (*(void *)(v5 + 8))
    {
      int v4 = *(NSObject **)(v5 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v4 = inited;
    }
    int v8 = v4;
    char v7 = 1;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      os_log_t log = v8;
      os_log_type_t type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_impl(&dword_1BA438000, log, type, "Unloading BOLTS ML model.", v6, 2u);
    }

    *(void *)(v5 + 40) = 0;
  }
}

uint64_t CBBOLTS::compileModel(CBBOLTS *this, NSString *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  char v28 = this;
  dispatch_semaphore_t v27 = dispatch_semaphore_create(0);
  if (v27)
  {
    uint64_t v17 = 0;
    char v18 = &v17;
    int v19 = 1375731712;
    int v20 = 48;
    char v21 = __Block_byref_object_copy__3;
    id v22 = __Block_byref_object_dispose__3;
    uint64_t v23 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = &v10;
    int v12 = 1375731712;
    int v13 = 48;
    __n128 v14 = __Block_byref_object_copy__3;
    char v15 = __Block_byref_object_dispose__3;
    uint64_t v16 = 0;
    objc_msgSend((id)getMLModelClass(), "compileModelAtURL:completionHandler:", objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:", v28));
    dsema = v27;
    dispatch_time_t v2 = dispatch_time(0, 2000000000);
    intptr_t v9 = dispatch_semaphore_wait(dsema, v2);
    if (!v18[5] || v11[5] || v9)
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v30, v11[5]);
        _os_log_error_impl(&dword_1BA438000, inited, OS_LOG_TYPE_ERROR, "Failed to compile model: %@", v30, 0xCu);
      }

      uint64_t v29 = 0;
    }
    else
    {

      uint64_t v29 = v18[5];
    }
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(&v17, 8);
  }
  else
  {
    __n128 v26 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      int v8 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      int v8 = init_default_corebrightness_log();
    }
    __n128 v26 = v8;
    char v25 = 16;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v26;
      os_log_type_t type = v25;
      __os_log_helper_16_0_0(v24);
      _os_log_error_impl(&dword_1BA438000, log, type, "Failed to create model compilation semaphore", v24, 2u);
    }
    return 0;
  }
  return v29;
}

void sub_1BA4CEA00()
{
  _Unwind_Resume(v0);
}

uint64_t getMLModelClass(void)
{
  uint64_t v8 = 0;
  intptr_t v9 = &v8;
  int v10 = 1375731712;
  int v11 = 48;
  int v12 = __Block_byref_object_copy__3;
  int v13 = __Block_byref_object_dispose__3;
  unint64_t v14 = 0;
  unint64_t v14 = std::atomic_load_explicit[abi:ne180100]<void *>((atomic_ullong *)&getMLModelClass(void)::softClass, 0);
  if (!v9[5])
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    uint64_t v5 = ___ZL15getMLModelClassv_block_invoke;
    id v6 = &unk_1E6219058;
    char v7 = &v8;
    ___ZL15getMLModelClassv_block_invoke((uint64_t)&v2);
  }
  uint64_t v1 = v9[5];
  _Block_object_dispose(&v8, 8);
  return v1;
}

intptr_t ___ZN7CBBOLTS12compileModelEP8NSString_block_invoke(uint64_t a1, void *a2, void *a3)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = a2;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) = a3;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void CBBOLTS::createFromUncompiledModelPath(CBBOLTS *this, NSString *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  int v4 = (CBBOLTS *)CBBOLTS::compileModel(this, a2);
  if (_COREBRIGHTNESS_LOG_DEFAULT) {
    uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
  }
  else {
    uint64_t inited = init_default_corebrightness_log();
  }
  if (os_log_type_enabled(inited, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_1_8_64((uint64_t)v5, (uint64_t)v4);
    _os_log_debug_impl(&dword_1BA438000, inited, OS_LOG_TYPE_DEBUG, "MLAB path %@", v5, 0xCu);
  }
  CBBOLTS::createUsingModelURL(v4, v2);
}

uint64_t CBBOLTS::makePrediction(uint64_t a1, uint64_t *a2, float a3)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v71 = a1;
  CFTypeID v70 = a2;
  float v69 = a3;
  CBBOLTS::serializeBins(a2, v68);
  CFTypeID v67 = 0;
  if (*(void *)(a1 + 8))
  {
    float v36 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    float v36 = inited;
  }
  CFTypeID v67 = v36;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    os_log_t log = v67;
    os_log_type_t v34 = type;
    __os_log_helper_16_0_0(v65);
    _os_log_impl(&dword_1BA438000, log, v34, "==== MLAB INPUT =====", v65, 2u);
  }
  int v64 = 0;
  if (*(void *)(a1 + 8))
  {
    float v32 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v31 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v31 = init_default_corebrightness_log();
    }
    float v32 = v31;
  }
  int v64 = v32;
  os_log_type_t v63 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v29 = v64;
    os_log_type_t v30 = v63;
    __os_log_helper_16_0_0(v62);
    _os_log_impl(&dword_1BA438000, v29, v30, "Lux Nits Timestamp", v62, 2u);
  }
  v61[1] = v68;
  v61[0] = std::vector<AAB::CurveUpdate>::begin[abi:ne180100](v68);
  uint64_t v60 = std::vector<AAB::CurveUpdate>::end[abi:ne180100]((uint64_t)v68);
  while (std::operator!=[abi:ne180100]<AAB::CurveUpdate *>((uint64_t)v61, (uint64_t)&v60))
  {
    uint64_t v59 = std::__wrap_iter<AAB::CurveUpdate *>::operator*[abi:ne180100]((uint64_t)v61);
    os_log_t v58 = 0;
    if (*(void *)(a1 + 8))
    {
      char v28 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v27 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v27 = init_default_corebrightness_log();
      }
      char v28 = v27;
    }
    os_log_t v58 = v28;
    os_log_type_t v57 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v82, COERCE__INT64(*(float *)v59), COERCE__INT64(*(float *)(v59 + 4)), *(void *)(v59 + 8));
      _os_log_impl(&dword_1BA438000, v58, v57, "%f %f %lld", v82, 0x20u);
    }
    std::__wrap_iter<AAB::CurveUpdate *>::operator++[abi:ne180100](v61);
  }
  uint64_t v56 = 0;
  if (*(void *)(a1 + 8))
  {
    __n128 v26 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v25 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v25 = init_default_corebrightness_log();
    }
    __n128 v26 = v25;
  }
  uint64_t v56 = v26;
  os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = v56;
    os_log_type_t v24 = v55;
    __os_log_helper_16_0_0(v54);
    _os_log_impl(&dword_1BA438000, v23, v24, "=====================", v54, 2u);
  }
  id v22 = objc_alloc((Class)getMLMultiArrayClass());
  v81[0] = &unk_1F1417C00;
  v81[1] = [NSNumber numberWithUnsignedLong:std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68)];
  v81[2] = &unk_1F1417C18;
  id v53 = (id)objc_msgSend(v22, "initWithShape:dataType:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v81, 3), 65568, 0);
  for (unint64_t i = 0; i < std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68); ++i)
  {
    int v20 = NSNumber;
    LODWORD(v3) = *(_DWORD *)std::vector<AAB::CurveUpdate>::operator[][abi:ne180100](v68, i);
    uint64_t v21 = [v20 numberWithFloat:v3];
    v80[0] = &unk_1F1417C30;
    v80[1] = [NSNumber numberWithUnsignedLong:i];
    v80[2] = &unk_1F1417C30;
    objc_msgSend(v53, "setObject:forKeyedSubscript:", v21, objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v80, 3));
    char v18 = NSNumber;
    LODWORD(v4) = *(_DWORD *)(std::vector<AAB::CurveUpdate>::operator[][abi:ne180100](v68, i) + 4);
    uint64_t v19 = [v18 numberWithFloat:v4];
    v79[0] = &unk_1F1417C30;
    v79[1] = [NSNumber numberWithUnsignedLong:i];
    v79[2] = &unk_1F1417C00;
    objc_msgSend(v53, "setObject:forKeyedSubscript:", v19, objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v79, 3));
    uint64_t v17 = objc_msgSend(NSNumber, "numberWithLongLong:", *(void *)(std::vector<AAB::CurveUpdate>::operator[][abi:ne180100](v68, i) + 8));
    v78[0] = &unk_1F1417C30;
    v78[1] = [NSNumber numberWithUnsignedLong:i];
    v78[2] = &unk_1F1417C48;
    objc_msgSend(v53, "setObject:forKeyedSubscript:", v17, objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v78, 3));
  }
  id v16 = objc_alloc((Class)getMLMultiArrayClass());
  v77[0] = &unk_1F1417C00;
  v77[1] = [NSNumber numberWithUnsignedLong:std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68)];
  id v51 = (id)objc_msgSend(v16, "initWithShape:dataType:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v77, 2), 65568, 0);
  id v15 = objc_alloc((Class)getMLMultiArrayClass());
  v76[0] = &unk_1F1417C00;
  v76[1] = [NSNumber numberWithUnsignedLong:std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68)];
  id v50 = (id)objc_msgSend(v15, "initWithShape:dataType:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v76, 2), 65568, 0);
  id v14 = objc_alloc((Class)getMLMultiArrayClass());
  v75[0] = &unk_1F1417C00;
  v75[1] = [NSNumber numberWithUnsignedLong:std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68)];
  id v49 = (id)objc_msgSend(v14, "initWithShape:dataType:error:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", v75, 2), 65568, 0);
  for (unint64_t j = 0; j < std::vector<AAB::CurveUpdate>::size[abi:ne180100](v68); ++j)
  {
    [v51 setObject:&unk_1F1417C30 atIndexedSubscript:j];
    [v50 setObject:&unk_1F1417C30 atIndexedSubscript:j];
    [v49 setObject:&unk_1F1417C30 atIndexedSubscript:j];
  }
  uint64_t v47 = 0;
  uint64_t v46 = 0;
  double Current = CFAbsoluteTimeGetCurrent();
  if (CBBOLTS::loadModel((CBBOLTS *)a1))
  {
    uint64_t v46 = objc_msgSend(*(id *)(a1 + 40), "predictionFromInput_x:target_lux:target_nits:target_weight:error:", v53, v50, v49, v51, &v47);
    if (v47)
    {
      os_log_t oslog = 0;
      if (*(void *)(a1 + 8))
      {
        int v13 = *(NSObject **)(a1 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v12 = init_default_corebrightness_log();
        }
        int v13 = v12;
      }
      os_log_t oslog = v13;
      os_log_type_t v43 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v74, v47);
        _os_log_error_impl(&dword_1BA438000, oslog, v43, "Failed to make a prediction: %@", v74, 0xCu);
      }
      uint64_t v72 = 0;
      int v42 = 1;
      goto LABEL_71;
    }
  }
  else
  {
    os_log_t v41 = 0;
    if (*(void *)(a1 + 8))
    {
      int v11 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v10 = init_default_corebrightness_log();
      }
      int v11 = v10;
    }
    os_log_t v41 = v11;
    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = v41;
      os_log_type_t v9 = v40;
      __os_log_helper_16_0_0(v39);
      _os_log_error_impl(&dword_1BA438000, v8, v9, "Failed to load model.", v39, 2u);
    }
  }
  CBBOLTS::unloadModel((dispatch_source_t *)a1, v69);
  double v38 = CFAbsoluteTimeGetCurrent();
  if (*(void *)(a1 + 8))
  {
    char v7 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v6 = init_default_corebrightness_log();
    }
    char v7 = v6;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v73, COERCE__INT64(v38 - Current));
    _os_log_impl(&dword_1BA438000, v7, OS_LOG_TYPE_INFO, "Loading ML model + prediction took %f seconds", v73, 0xCu);
  }
  uint64_t v72 = v46;
  int v42 = 1;
LABEL_71:
  std::vector<AAB::CurveUpdate>::~vector[abi:ne180100](v68);
  return v72;
}

void sub_1BA4CFBE8()
{
  _Unwind_Resume(v0);
}

BOOL std::operator!=[abi:ne180100]<AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  return !std::operator==[abi:ne180100]<AAB::CurveUpdate *>(a1, a2);
}

uint64_t std::__wrap_iter<AAB::CurveUpdate *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

void *std::__wrap_iter<AAB::CurveUpdate *>::operator++[abi:ne180100](void *result)
{
  *result += 16;
  return result;
}

uint64_t getMLMultiArrayClass(void)
{
  uint64_t v8 = 0;
  os_log_type_t v9 = &v8;
  int v10 = 1375731712;
  int v11 = 48;
  uint64_t v12 = __Block_byref_object_copy__3;
  int v13 = __Block_byref_object_dispose__3;
  unint64_t v14 = 0;
  unint64_t v14 = std::atomic_load_explicit[abi:ne180100]<void *>((atomic_ullong *)&getMLMultiArrayClass(void)::softClass, 0);
  if (!v9[5])
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    uint64_t v5 = ___ZL20getMLMultiArrayClassv_block_invoke;
    uint64_t v6 = &unk_1E6219058;
    char v7 = &v8;
    ___ZL20getMLMultiArrayClassv_block_invoke((uint64_t)&v2);
  }
  uint64_t v1 = v9[5];
  _Block_object_dispose(&v8, 8);
  return v1;
}

uint64_t std::vector<AAB::CurveUpdate>::size[abi:ne180100](void *a1)
{
  return (a1[1] - *a1) / 16;
}

uint64_t std::vector<AAB::CurveUpdate>::operator[][abi:ne180100](void *a1, uint64_t a2)
{
  return *a1 + 16 * a2;
}

uint64_t *CBBOLTS::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v47 = a1;
  uint64_t v46 = a2;
  uint64_t v45 = a3;
  CFTypeID v44 = a4;
  CBBOLTS::binUpdates(a2, (uint64_t *)(a1 + 56), v43);
  int v42 = 0;
  if (*(void *)(a1 + 8))
  {
    os_log_type_t v24 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    os_log_type_t v24 = inited;
  }
  int v42 = v24;
  char v41 = 1;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
  {
    os_log_t log = v42;
    os_log_type_t type = v41;
    __os_log_helper_16_0_0(v40);
    _os_log_impl(&dword_1BA438000, log, type, "----- Binning -----", v40, 2u);
  }
  CFTypeID v39 = 0;
  if (*(void *)(a1 + 8))
  {
    int v20 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v19 = init_default_corebrightness_log();
    }
    int v20 = v19;
  }
  CFTypeID v39 = v20;
  os_log_type_t v38 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    uint64_t v17 = v39;
    os_log_type_t v18 = v38;
    __os_log_helper_16_0_0(v37);
    _os_log_impl(&dword_1BA438000, v17, v18, "Bin Lux Nits Timestamp", v37, 2u);
  }
  for (unint64_t i = 0; ; ++i)
  {
    unint64_t v16 = i;
    if (v16 >= std::vector<CBBOLTS::Bin>::size[abi:ne180100](v43)) {
      break;
    }
    int v4 = (CBBOLTS::Bin *)std::vector<CBBOLTS::Bin>::operator[][abi:ne180100](v43, i);
    CBBOLTS::Bin::updates(v4, v35);
    v35[3] = v35;
    uint64_t v34 = std::list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v35);
    uint64_t v33 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
    while (std::operator!=[abi:ne180100](&v34, &v33))
    {
      uint64_t v32 = std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
      os_log_t oslog = 0;
      if (*(void *)(a1 + 8))
      {
        id v15 = *(NSObject **)(a1 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v14 = init_default_corebrightness_log();
        }
        id v15 = v14;
      }
      os_log_t oslog = v15;
      os_log_type_t v30 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v49, i, COERCE__INT64(*(float *)v32), COERCE__INT64(*(float *)(v32 + 4)), *(void *)(v32 + 8));
        _os_log_impl(&dword_1BA438000, oslog, v30, "%lu %f %f %lld", v49, 0x2Au);
      }
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v34);
    }
    std::list<AAB::CurveUpdate>::~list((uint64_t)v35);
  }
  os_log_t v29 = 0;
  if (*(void *)(a1 + 8))
  {
    int v13 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v12 = init_default_corebrightness_log();
    }
    int v13 = v12;
  }
  os_log_t v29 = v13;
  os_log_type_t v28 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    int v10 = v29;
    os_log_type_t v11 = v28;
    __os_log_helper_16_0_0(v27);
    _os_log_impl(&dword_1BA438000, v10, v11, "-------------------", v27, 2u);
  }
  v44[24] = 3;
  uint64_t v5 = memcpy((void *)(a1 + 224), v44, 0x68uLL);
  context = (void *)MEMORY[0x1BA9ECAE0](v5);
  Prediction = (void *)CBBOLTS::makePrediction(a1, v43, 5.0);
  if (Prediction)
  {
    CBBOLTS::setCurveBasedOnModelPrediction(a1 + 224, objc_msgSend(Prediction, "LTM_output_E"), objc_msgSend(Prediction, "LTM_output_L"));
    *(unsigned char *)(a1 + 216) = 1;
    if (*(void *)(a1 + 8))
    {
      uint64_t v8 = *(NSObject **)(a1 + 8);
    }
    else
    {
      uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      uint64_t v8 = v7;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v48, COERCE__INT64(*(float *)(a1 + 224)), COERCE__INT64(*(float *)(a1 + 232)), COERCE__INT64(*(float *)(a1 + 240)), COERCE__INT64(*(float *)(a1 + 244)), COERCE__INT64(*(float *)(a1 + 228)), COERCE__INT64(*(float *)(a1 + 236)), COERCE__INT64(*(float *)(a1 + 248)), COERCE__INT64(*(float *)(a1 + 252)), COERCE__INT64(*(float *)(a1 + 308)));
      _os_log_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEFAULT, "User adjustment -> predict LTM curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f", v48, 0x5Cu);
    }
  }
  return std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](v43);
}

void sub_1BA4D05F0()
{
  _Unwind_Resume(v0);
}

uint64_t std::vector<CBBOLTS::Bin>::size[abi:ne180100](void *a1)
{
  return (a1[1] - *a1) / 48;
}

uint64_t std::vector<CBBOLTS::Bin>::operator[][abi:ne180100](void *a1, uint64_t a2)
{
  return *a1 + 48 * a2;
}

uint64_t __os_log_helper_16_0_4_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1) = 4;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  return result;
}

uint64_t *CBBOLTS::UpdateCurveWithPrediction(uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  v40[4] = a1;
  uint8_t v40[3] = a2;
  CBBOLTS::binUpdates(a2, (uint64_t *)(a1 + 56), v40);
  CFTypeID v39 = 0;
  if (*(void *)(a1 + 8))
  {
    uint64_t v21 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v21 = inited;
  }
  CFTypeID v39 = v21;
  char v38 = 1;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
  {
    os_log_t log = v39;
    os_log_type_t type = v38;
    __os_log_helper_16_0_0(v37);
    _os_log_impl(&dword_1BA438000, log, type, "----- Binning -----", v37, 2u);
  }
  float v36 = 0;
  if (*(void *)(a1 + 8))
  {
    uint64_t v17 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v16 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v16 = init_default_corebrightness_log();
    }
    uint64_t v17 = v16;
  }
  float v36 = v17;
  char v35 = 1;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    uint64_t v14 = v36;
    os_log_type_t v15 = v35;
    __os_log_helper_16_0_0(v34);
    _os_log_impl(&dword_1BA438000, v14, v15, "Bin Lux Nits Timestamp", v34, 2u);
  }
  for (unint64_t i = 0; ; ++i)
  {
    unint64_t v13 = i;
    if (v13 >= std::vector<CBBOLTS::Bin>::size[abi:ne180100](v40)) {
      break;
    }
    uint64_t v2 = (CBBOLTS::Bin *)std::vector<CBBOLTS::Bin>::operator[][abi:ne180100](v40, i);
    CBBOLTS::Bin::updates(v2, v32);
    v32[3] = v32;
    uint64_t v31 = std::list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v32);
    uint64_t v30 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
    while (std::operator!=[abi:ne180100](&v31, &v30))
    {
      uint64_t v29 = std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
      os_log_t oslog = 0;
      if (*(void *)(a1 + 8))
      {
        uint64_t v12 = *(NSObject **)(a1 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v11 = init_default_corebrightness_log();
        }
        uint64_t v12 = v11;
      }
      os_log_t oslog = v12;
      os_log_type_t v27 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v42, i, COERCE__INT64(*(float *)v29), COERCE__INT64(*(float *)(v29 + 4)), *(void *)(v29 + 8));
        _os_log_impl(&dword_1BA438000, oslog, v27, "%lu %f %f %lld", v42, 0x2Au);
      }
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v31);
    }
    std::list<AAB::CurveUpdate>::~list((uint64_t)v32);
  }
  os_log_t v26 = 0;
  if (*(void *)(a1 + 8))
  {
    int v10 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v9 = init_default_corebrightness_log();
    }
    int v10 = v9;
  }
  os_log_t v26 = v10;
  os_log_type_t v25 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = v26;
    os_log_type_t v8 = v25;
    __os_log_helper_16_0_0(v24);
    _os_log_impl(&dword_1BA438000, v7, v8, "-------------------", v24, 2u);
  }
  context = (void *)MEMORY[0x1BA9ECAE0]();
  Prediction = (void *)CBBOLTS::makePrediction(a1, v40, 2.0);
  if (Prediction)
  {
    CBBOLTS::setCurveBasedOnModelPrediction(a1 + 224, objc_msgSend(Prediction, "LTM_output_E"), objc_msgSend(Prediction, "LTM_output_L"));
    *(unsigned char *)(a1 + 216) = 1;
    if (*(void *)(a1 + 8))
    {
      uint64_t v5 = *(NSObject **)(a1 + 8);
    }
    else
    {
      uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      uint64_t v5 = v4;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v41, COERCE__INT64(*(float *)(a1 + 224)), COERCE__INT64(*(float *)(a1 + 232)), COERCE__INT64(*(float *)(a1 + 240)), COERCE__INT64(*(float *)(a1 + 244)), COERCE__INT64(*(float *)(a1 + 228)), COERCE__INT64(*(float *)(a1 + 236)), COERCE__INT64(*(float *)(a1 + 248)), COERCE__INT64(*(float *)(a1 + 252)), COERCE__INT64(*(float *)(a1 + 308)));
      _os_log_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEFAULT, "Restore from user updates sequence -> predict LTM curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f", v41, 0x5Cu);
    }
  }
  return std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](v40);
}

void sub_1BA4D0E98()
{
  _Unwind_Resume(v0);
}

void CBBOLTS::UpdateCurves_Internal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v43 = a1;
  uint64_t v42 = a2;
  uint64_t v41 = a3;
  os_log_type_t v40 = 0;
  if (*(void *)(a1 + 8))
  {
    uint64_t v17 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v17 = inited;
  }
  os_log_type_t v40 = v17;
  char v39 = 1;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
  {
    os_log_t log = v40;
    os_log_type_t type = v39;
    __os_log_helper_16_0_0(v38);
    _os_log_impl(&dword_1BA438000, log, type, "+++++ User adjustments buffer +++++", v38, 2u);
  }
  uint64_t v37 = 0;
  if (*(void *)(a1 + 8))
  {
    unint64_t v13 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v12 = init_default_corebrightness_log();
    }
    unint64_t v13 = v12;
  }
  uint64_t v37 = v13;
  char v36 = 1;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    int v10 = v37;
    os_log_type_t v11 = v36;
    __os_log_helper_16_0_0(v35);
    _os_log_impl(&dword_1BA438000, v10, v11, "Lux Nits Timestamp", v35, 2u);
  }
  v34[1] = a1 + 88;
  v34[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100](a1 + 88);
  uint64_t v33 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (std::operator!=[abi:ne180100](v34, &v33))
  {
    uint64_t v32 = std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    os_log_t v31 = 0;
    if (*(void *)(a1 + 8))
    {
      uint64_t v9 = *(NSObject **)(a1 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v8 = init_default_corebrightness_log();
      }
      uint64_t v9 = v8;
    }
    os_log_t v31 = v9;
    os_log_type_t v30 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v44, COERCE__INT64(*(float *)v32), COERCE__INT64(*(float *)(v32 + 4)), *(void *)(v32 + 8));
      _os_log_impl(&dword_1BA438000, v31, v30, "%f %f %lld", v44, 0x20u);
    }
    std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v34);
  }
  uint64_t v29 = 0;
  if (*(void *)(a1 + 8))
  {
    uint64_t v7 = *(NSObject **)(a1 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v6 = init_default_corebrightness_log();
    }
    uint64_t v7 = v6;
  }
  uint64_t v29 = v7;
  char v28 = 1;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = v29;
    os_log_type_t v5 = v28;
    __os_log_helper_16_0_0(v27);
    _os_log_impl(&dword_1BA438000, v4, v5, "+++++++++++++++++++++++++++++++++++", v27, 2u);
  }
  int v3 = *(NSObject **)(a1 + 16);
  uint64_t block = MEMORY[0x1E4F143A8];
  int v20 = -1073741824;
  int v21 = 0;
  id v22 = ___ZN7CBBOLTS21UpdateCurves_InternalERN3AAB5CurveEPS1__block_invoke;
  uint64_t v23 = &__block_descriptor_56_e5_v8__0l;
  uint64_t v24 = a1;
  uint64_t v25 = v42;
  uint64_t v26 = v41;
  dispatch_async(v3, &block);
}

uint64_t std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]()
{
  std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
  return std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v0);
}

uint64_t std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100](uint64_t result)
{
  *(void *)float result = *(void *)(*(void *)result + 8);
  return result;
}

uint64_t *___ZN7CBBOLTS21UpdateCurves_InternalERN3AAB5CurveEPS1__block_invoke(uint64_t a1)
{
  return CBBOLTS::UpdateCurveAndCappedCurve(*(void *)(a1 + 32), *(void *)(a1 + 32) + 88, *(void *)(a1 + 40), *(_DWORD **)(a1 + 48));
}

void CBBOLTS::UpdateCurve(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5, float a6)
{
  unint64_t v21 = __PAIR64__(LODWORD(a5), LODWORD(a4));
  float v22 = a6;
  uint64_t v20 = a1;
  uint64_t v19 = a2;
  uint64_t v18 = a3;
  if (*(void *)(a1 + 16))
  {
    uint64_t v6 = *(NSObject **)(a1 + 16);
    uint64_t block = MEMORY[0x1E4F143A8];
    int v9 = -1073741824;
    int v10 = 0;
    os_log_type_t v11 = ___ZN7CBBOLTS11UpdateCurveEP3AABNS0_21CurveUpdateParametersERNS0_5CurveE_block_invoke;
    uint64_t v12 = &__block_descriptor_68_e5_v8__0l;
    uint64_t v13 = a1;
    unint64_t v16 = v21;
    float v17 = v22;
    uint64_t v14 = v19;
    uint64_t v15 = v18;
    dispatch_sync(v6, &block);
  }
}

void ___ZN7CBBOLTS11UpdateCurveEP3AABNS0_21CurveUpdateParametersERNS0_5CurveE_block_invoke(uint64_t a1)
{
  uint64_t v4 = *(NSObject ***)(a1 + 32);
  LODWORD(v5) = *(_DWORD *)(a1 + 56);
  HIDWORD(v5) = *(_DWORD *)(a1 + 64);
  unint64_t LocalizedTimestamp = getLocalizedTimestamp();
  CBBOLTS::addCurveUpdateToBuffer((uint64_t)v4, v5, LocalizedTimestamp);
  uint64_t v2 = *(void *)(a1 + 56);
  LODWORD(v1) = v2;
  AAB::PreferenceUpdateCurveStrategy::UpdateCurve(v1, *((float *)&v2 + 1), *(float *)(a1 + 64), (uint64_t)v4, *(void *)(a1 + 40), *(void *)(a1 + 48));
  CBBOLTS::UpdateCurves_Internal((uint64_t)v4, *(void *)(a1 + 48), 0);
  CBBOLTS::saveBufferToPreferences(v4);
}

uint64_t getLocalizedTimestamp(void)
{
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v0 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CAF0], "localTimeZone"), "secondsFromGMT");
  return (uint64_t)(Current + (double)v0 + *MEMORY[0x1E4F1CF78]);
}

void CBBOLTS::saveBufferToPreferences(NSObject **this)
{
  int v9 = (CBBOLTS *)this;
  if (this[2])
  {
    double v1 = this[2];
    uint64_t block = MEMORY[0x1E4F143A8];
    int v4 = -1073741824;
    int v5 = 0;
    uint64_t v6 = ___ZNK7CBBOLTS23saveBufferToPreferencesEv_block_invoke;
    uint64_t v7 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v8 = (CBBOLTS *)this;
    dispatch_async(v1, &block);
  }
}

void CBBOLTS::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float a6, float a7, float a8)
{
  unint64_t v27 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  float v28 = a8;
  uint64_t v26 = a1;
  uint64_t v25 = a2;
  uint64_t v24 = a3;
  uint64_t v23 = a4;
  uint64_t v22 = a5;
  if (*(void *)(a1 + 16))
  {
    uint64_t v8 = *(NSObject **)(a1 + 16);
    uint64_t block = MEMORY[0x1E4F143A8];
    int v11 = -1073741824;
    int v12 = 0;
    uint64_t v13 = ___ZN7CBBOLTS25UpdateCurveAndCappedCurveEP3AABNS0_21CurveUpdateParametersERNS0_5CurveERKNS0_8CurveCapES4__block_invoke;
    uint64_t v14 = &__block_descriptor_84_e5_v8__0l;
    uint64_t v15 = a1;
    unint64_t v20 = v27;
    float v21 = v28;
    uint64_t v16 = v25;
    uint64_t v17 = v24;
    uint64_t v18 = v22;
    uint64_t v19 = v23;
    dispatch_sync(v8, &block);
  }
}

void ___ZN7CBBOLTS25UpdateCurveAndCappedCurveEP3AABNS0_21CurveUpdateParametersERNS0_5CurveERKNS0_8CurveCapES4__block_invoke(uint64_t a1)
{
  int v5 = *(CBBOLTS **)(a1 + 32);
  LODWORD(v6) = *(_DWORD *)(a1 + 72);
  HIDWORD(v6) = *(_DWORD *)(a1 + 80);
  unint64_t LocalizedTimestamp = getLocalizedTimestamp();
  CBBOLTS::addCurveUpdateToBuffer((uint64_t)v5, v6, LocalizedTimestamp);
  if (CBBOLTS::useBOLTS(v5))
  {
    uint64_t v2 = *(void *)(a1 + 72);
    LODWORD(v1) = v2;
    AAB::PreferenceUpdateCurveStrategy::UpdateCurve(v1, *((float *)&v2 + 1), *(float *)(a1 + 80), (uint64_t)v5, *(void *)(a1 + 40), *(void *)(a1 + 48));
    CBBOLTS::UpdateCurves_Internal((uint64_t)v5, *(void *)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 72);
    LODWORD(v1) = v3;
    AAB::PreferenceUpdateCurveStrategy::UpdateCurveAndCappedCurve((uint64_t)v5, *(void *)(a1 + 40), *(void *)(a1 + 48), *(float **)(a1 + 64), *(void *)(a1 + 56), v1, *((float *)&v3 + 1), *(float *)(a1 + 80));
    *(_DWORD *)(*(void *)(a1 + 56) + 96) = 3;
    memcpy((char *)v5 + 224, *(const void **)(a1 + 56), 0x68uLL);
    memcpy((char *)v5 + 112, (char *)v5 + 224, 0x68uLL);
  }
  CBBOLTS::saveBufferToPreferences((NSObject **)v5);
}

BOOL CBBOLTS::useBOLTS(CBBOLTS *this)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = this;
  BOOL v18 = (unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() > 5;
  CBBOLTS::binUpdates((uint64_t)this + 88, (uint64_t *)this + 7, v17);
  int v16 = 0;
  v15[1] = v17;
  v15[0] = std::vector<CBBOLTS::Bin>::begin[abi:ne180100](v17);
  uint64_t v14 = std::vector<CBBOLTS::Bin>::end[abi:ne180100]((uint64_t)v17);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin *>((uint64_t)v15, (uint64_t)&v14))
  {
    uint64_t v13 = (CBBOLTS::Bin *)std::__wrap_iter<CBBOLTS::Bin *>::operator*[abi:ne180100]((uint64_t)v15);
    CBBOLTS::Bin::updates(v13, v12);
    BOOL v9 = std::list<AAB::CurveUpdate>::size[abi:ne180100]() == 0;
    std::list<AAB::CurveUpdate>::~list((uint64_t)v12);
    if (!v9) {
      ++v16;
    }
    std::__wrap_iter<CBBOLTS::Bin *>::operator++[abi:ne180100](v15);
  }
  BOOL v11 = v16 > 2;
  if (*((void *)this + 1))
  {
    uint64_t v8 = *((void *)this + 1);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v6 = 0;
    if (v18) {
      BOOL v6 = v11;
    }
    double v1 = "Use";
    if (!v6) {
      double v1 = "Don't use";
    }
    uint64_t v5 = (uint64_t)v1;
    int v2 = std::list<AAB::CurveUpdate>::size[abi:ne180100]();
    __os_log_helper_16_2_3_8_32_4_0_4_0((uint64_t)v20, v5, v2, v16);
    _os_log_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEFAULT, "%s the BOLTS curve update strategy. Num of adjustments = %d; Num of updated Bins = %d",
      v20,
      0x18u);
  }
  BOOL v4 = 0;
  if (v18) {
    BOOL v4 = v11;
  }
  std::vector<CBBOLTS::Bin>::~vector[abi:ne180100](v17);
  return v4;
}

void sub_1BA4D1C48()
{
  _Unwind_Resume(v0);
}

void *CBBOLTS::curveUpdates@<X0>(CBBOLTS *this@<X0>, void *a2@<X8>)
{
  return std::list<AAB::CurveUpdate>::list(a2, (uint64_t)this + 88);
}

void *std::list<AAB::CurveUpdate>::list(void *a1, uint64_t a2)
{
  return a1;
}

{
  __n128 *v3;
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  void *v9;
  void *v10;

  BOOL v9 = a1;
  uint64_t v8 = a2;
  int v10 = a1;
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::select_on_container_copy_construction[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,void,void>();
  std::__list_imp<AAB::CurveUpdate>::__list_imp(a1, (uint64_t)&v7);
  BOOL v6 = std::list<AAB::CurveUpdate>::begin[abi:ne180100](v8);
  uint64_t v5 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (std::operator!=[abi:ne180100](&v6, &v5))
  {
    uint64_t v3 = (__n128 *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    std::list<AAB::CurveUpdate>::push_back(a1, v3);
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v6);
  }
  return v10;
}

void CBBOLTS::SetCurveUpdates(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = a1;
  uint64_t v10 = a2;
  std::list<AAB::CurveUpdate>::operator=(a1 + 88, a2);
  while ((unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() > *(void *)(a1 + 80))
    std::list<AAB::CurveUpdate>::pop_front(a1 + 88);
  int v2 = *(NSObject **)(a1 + 16);
  uint64_t block = MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  uint64_t v7 = ___ZN7CBBOLTS15SetCurveUpdatesERNSt3__14listIN3AAB11CurveUpdateENS0_9allocatorIS3_EEEE_block_invoke;
  uint64_t v8 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v9 = a1;
  dispatch_async(v2, &block);
}

uint64_t std::list<AAB::CurveUpdate>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    std::__list_imp<AAB::CurveUpdate>::__copy_assign_alloc[abi:ne180100]();
    uint64_t v5 = std::list<AAB::CurveUpdate>::begin[abi:ne180100](a2);
    uint64_t v4 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
    std::list<AAB::CurveUpdate>::assign<std::__list_const_iterator<AAB::CurveUpdate,void *>>(a1, v5, v4);
  }
  return a1;
}

BOOL ___ZN7CBBOLTS15SetCurveUpdatesERNSt3__14listIN3AAB11CurveUpdateENS0_9allocatorIS3_EEEE_block_invoke(uint64_t a1)
{
  int v2 = *(CBBOLTS **)(a1 + 32);
  if (CBBOLTS::useBOLTS(v2))
  {
    CBBOLTS::UpdateCurveWithPrediction((uint64_t)v2, (uint64_t)v2 + 88);
    memcpy((char *)v2 + 112, (char *)v2 + 224, 0x68uLL);
  }
  CBBOLTS::saveBufferToPreferences((NSObject **)v2);
  BOOL result = CBBOLTS::useBOLTS(v2);
  if (!result) {
    *((unsigned char *)v2 + 216) = 0;
  }
  return result;
}

uint64_t CBBOLTS::cappedCurve(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  int v15 = 0x20000000;
  int v16 = 32;
  char v17 = 0;
  int v2 = *(NSObject **)(a1 + 16);
  uint64_t block = MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  uint64_t v8 = ___ZN7CBBOLTS11cappedCurveERN3AAB5CurveE_block_invoke;
  uint64_t v9 = &unk_1E62194F0;
  uint64_t v11 = v19;
  uint64_t v12 = a2;
  uint64_t v10 = &v13;
  dispatch_sync(v2, &block);
  char v4 = *((unsigned char *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v4 & 1;
}

void **___ZN7CBBOLTS11cappedCurveERN3AAB5CurveE_block_invoke(void **result)
{
  double v1 = result;
  int v2 = (char *)result[5];
  if (v2[216])
  {
    BOOL result = (void **)memcpy(result[6], v2 + 112, 0x68uLL);
    *(unsigned char *)(*((void *)v1[4] + 1) + 24) = 1;
  }
  return result;
}

void CBBOLTS::setCappedCurve(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = a1;
  uint64_t v10 = a2;
  int v2 = *(NSObject **)(a1 + 16);
  uint64_t v3 = MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  int v6 = ___ZN7CBBOLTS14setCappedCurveERN3AAB5CurveE_block_invoke;
  int v7 = &__block_descriptor_48_e5_v8__0l;
  uint64_t v8 = v11;
  uint64_t v9 = a2;
  dispatch_sync(v2, &v3);
}

void ___ZN7CBBOLTS14setCappedCurveERN3AAB5CurveE_block_invoke(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  memcpy((void *)(v3 + 112), *(const void **)(a1 + 40), 0x68uLL);
  *(_DWORD *)(v3 + 208) = 3;
  memcpy((void *)(v3 + 224), (const void *)(v3 + 112), 0x68uLL);
  if (*(void *)(v3 + 8))
  {
    int v2 = *(NSObject **)(v3 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v4, COERCE__INT64(*(float *)(v3 + 112)), COERCE__INT64(*(float *)(v3 + 120)), COERCE__INT64(*(float *)(v3 + 128)), COERCE__INT64(*(float *)(v3 + 132)), COERCE__INT64(*(float *)(v3 + 116)), COERCE__INT64(*(float *)(v3 + 124)), COERCE__INT64(*(float *)(v3 + 136)), COERCE__INT64(*(float *)(v3 + 140)), COERCE__INT64(*(float *)(v3 + 196)));
    _os_log_impl(&dword_1BA438000, v2, OS_LOG_TYPE_DEFAULT, "Setting capped LTM curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f", v4, 0x5Cu);
  }
}

void CBBOLTS::preservePreferences(NSObject **this)
{
  uint64_t v9 = (CBBOLTS *)this;
  int v2 = this[2];
  uint64_t v3 = MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  int v6 = ___ZN7CBBOLTS19preservePreferencesEv_block_invoke;
  int v7 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v8 = (CBBOLTS *)this;
  dispatch_async(v2, &v3);
}

void ___ZN7CBBOLTS19preservePreferencesEv_block_invoke(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  memcpy((void *)(v3 + 112), (const void *)(v3 + 224), 0x68uLL);
  if (*(void *)(v3 + 8))
  {
    int v2 = *(NSObject **)(v3 + 8);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_9_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v4, COERCE__INT64(*(float *)(v3 + 224)), COERCE__INT64(*(float *)(v3 + 232)), COERCE__INT64(*(float *)(v3 + 240)), COERCE__INT64(*(float *)(v3 + 244)), COERCE__INT64(*(float *)(v3 + 228)), COERCE__INT64(*(float *)(v3 + 236)), COERCE__INT64(*(float *)(v3 + 248)), COERCE__INT64(*(float *)(v3 + 252)), COERCE__INT64(*(float *)(v3 + 308)));
    _os_log_impl(&dword_1BA438000, v2, OS_LOG_TYPE_DEFAULT, "Preserve current LTM curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f", v4, 0x5Cu);
  }
}

uint64_t __os_log_helper_16_2_3_8_32_4_0_4_0(uint64_t result, uint64_t a2, int a3, int a4)
{
  *(unsigned char *)BOOL result = 2;
  *(unsigned char *)(result + 1) = 3;
  *(unsigned char *)(result + 2) = 32;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  *(unsigned char *)(result + 18) = 0;
  *(unsigned char *)(result + 19) = 4;
  *(_DWORD *)(result + 20) = a4;
  return result;
}

void CBBOLTS::Reset(NSObject **this)
{
  uint64_t v9 = (CBBOLTS *)this;
  uint64_t v8 = 0;
  if (this[1])
  {
    int v4 = this[1];
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v4 = inited;
  }
  uint64_t v8 = v4;
  os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    os_log_t log = v8;
    os_log_type_t type = v7;
    __os_log_helper_16_0_0(v6);
    _os_log_impl(&dword_1BA438000, log, type, "Reseting buffer", v6, 2u);
  }
  CBBOLTS::resetBuffer(this);
}

void CBBOLTS::resetBuffer(NSObject **this)
{
  uint64_t v9 = (CBBOLTS *)this;
  if (this[2])
  {
    double v1 = this[2];
    uint64_t block = MEMORY[0x1E4F143A8];
    int v4 = -1073741824;
    int v5 = 0;
    int v6 = ___ZN7CBBOLTS11resetBufferEv_block_invoke;
    os_log_type_t v7 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v8 = (CBBOLTS *)this;
    dispatch_sync(v1, &block);
  }
}

uint64_t CBBOLTS::switchModel(NSObject **this, NSURL *a2)
{
  uint64_t v14 = (CBBOLTS *)this;
  uint64_t v13 = (CBBOLTS *)a2;
  if (this[2])
  {
    uint64_t v12 = CBBOLTS::initializeMLABModelFromURL(v13, a2);
    if (v12)
    {
      int v2 = this[2];
      uint64_t block = MEMORY[0x1E4F143A8];
      int v6 = -1073741824;
      int v7 = 0;
      uint64_t v8 = ___ZN7CBBOLTS11switchModelEP5NSURL_block_invoke;
      uint64_t v9 = &unk_1E6219538;
      uint64_t v11 = (CBBOLTS *)this;
      uint64_t v10 = v12;
      dispatch_sync(v2, &block);
      char v15 = 1;
    }
    else
    {
      char v15 = 0;
    }
  }
  else
  {
    char v15 = 0;
  }
  return v15 & 1;
}

uint64_t ___ZN7CBBOLTS11switchModelEP5NSURL_block_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);

  uint64_t result = a1;
  *(void *)(v3 + 40) = *(void *)(a1 + 32);
  return result;
}

uint64_t ___ZN7CBBOLTS11resetBufferEv_block_invoke(uint64_t a1)
{
  float v5[3] = a1;
  void v5[2] = a1;
  uint64_t v2 = *(void *)(a1 + 32);
  *(unsigned char *)(v2 + 216) = 0;
  std::initializer_list<AAB::CurveUpdate>::initializer_list[abi:ne180100](v5);
  std::list<AAB::CurveUpdate>::operator=[abi:ne180100](v2 + 88, v5[0], v5[1]);
  uint64_t v3 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
  int v4 = (CFStringRef *)MEMORY[0x1E4F1D3C8];
  CFPreferencesSetValue(@"BOLTSBuffer", 0, @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  return CFPreferencesSynchronize(@"com.apple.CoreBrightness", *v3, *v4);
}

void *std::initializer_list<AAB::CurveUpdate>::initializer_list[abi:ne180100](void *a1)
{
  return a1;
}

uint64_t std::list<AAB::CurveUpdate>::operator=[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = a2;
  v7[1] = a3;
  int v5 = (__n128 *)std::initializer_list<AAB::CurveUpdate>::begin[abi:ne180100]((uint64_t)v7);
  uint64_t v3 = (__n128 *)std::initializer_list<AAB::CurveUpdate>::end[abi:ne180100](v7);
  std::list<AAB::CurveUpdate>::assign<AAB::CurveUpdate const*>(a1, v5, v3);
  return a1;
}

uint64_t getMLModelConfigurationClass(void)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  int v10 = 1375731712;
  int v11 = 48;
  uint64_t v12 = __Block_byref_object_copy__3;
  uint64_t v13 = __Block_byref_object_dispose__3;
  unint64_t v14 = 0;
  unint64_t v14 = std::atomic_load_explicit[abi:ne180100]<void *>((atomic_ullong *)&getMLModelConfigurationClass(void)::softClass, 0);
  if (!v9[5])
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    int v5 = ___ZL28getMLModelConfigurationClassv_block_invoke;
    int v6 = &unk_1E6219058;
    int v7 = &v8;
    ___ZL28getMLModelConfigurationClassv_block_invoke((uint64_t)&v2);
  }
  uint64_t v1 = v9[5];
  _Block_object_dispose(&v8, 8);
  return v1;
}

void ___ZNK7CBBOLTS23saveBufferToPreferencesEv_block_invoke(uint64_t a1)
{
  v15[3] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a1;
  uint64_t v12 = a1;
  uint64_t v7 = *(void *)(a1 + 32);
  context = (void *)MEMORY[0x1BA9ECAE0]();
  CFPropertyListRef v11 = (CFPropertyListRef)[MEMORY[0x1E4F1CA48] array];
  v10[1] = v7 + 88;
  v10[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100](v7 + 88);
  uint64_t v9 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (std::operator!=[abi:ne180100](v10, &v9))
  {
    uint64_t v8 = std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    int v5 = (void *)v11;
    v14[0] = @"Lux";
    LODWORD(v1) = *(_DWORD *)v8;
    v15[0] = [NSNumber numberWithFloat:v1];
    v14[1] = @"Nits";
    LODWORD(v2) = *(_DWORD *)(v8 + 4);
    v15[1] = [NSNumber numberWithFloat:v2];
    _OWORD v14[2] = @"Timestamp";
    void v15[2] = [NSNumber numberWithLongLong:*(void *)(v8 + 8)];
    objc_msgSend(v5, "addObject:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v15, v14, 3));
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v10);
  }
  int v3 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
  int v4 = (CFStringRef *)MEMORY[0x1E4F1D3C8];
  CFPreferencesSetValue(@"BOLTSBuffer", v11, @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  CFPreferencesSynchronize(@"com.apple.CoreBrightness", *v3, *v4);
}

void CBBOLTS::loadBufferFromPreferences(NSObject **this)
{
  uint64_t v9 = (CBBOLTS *)this;
  if (this[2])
  {
    double v1 = this[2];
    uint64_t block = MEMORY[0x1E4F143A8];
    int v4 = -1073741824;
    int v5 = 0;
    int v6 = ___ZN7CBBOLTS25loadBufferFromPreferencesEv_block_invoke;
    uint64_t v7 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v8 = (CBBOLTS *)this;
    dispatch_async(v1, &block);
  }
}

uint64_t *___ZN7CBBOLTS25loadBufferFromPreferencesEv_block_invoke(uint64_t a1)
{
  void v6[3] = a1;
  v6[2] = a1;
  double v2 = *(CBBOLTS **)(a1 + 32);
  std::initializer_list<AAB::CurveUpdate>::initializer_list[abi:ne180100](v6);
  std::list<AAB::CurveUpdate>::operator=[abi:ne180100]((uint64_t)v2 + 88, v6[0], v6[1]);
  int v3 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
  int v4 = (CFStringRef *)MEMORY[0x1E4F1D3C8];
  CFPreferencesSynchronize(@"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3C8]);
  int v5 = (void *)CFPreferencesCopyValue(@"BOLTSBuffer", @"com.apple.CoreBrightness", *v3, *v4);
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    objc_msgSend(v5, "enumerateObjectsUsingBlock:");
  }
  while ((unint64_t)std::list<AAB::CurveUpdate>::size[abi:ne180100]() > *((void *)v2 + 10))
    std::list<AAB::CurveUpdate>::pop_front((uint64_t)v2 + 88);

  uint64_t result = (uint64_t *)CBBOLTS::useBOLTS(v2);
  if (result) {
    return CBBOLTS::UpdateCurveWithPrediction((uint64_t)v2, (uint64_t)v2 + 88);
  }
  return result;
}

void ___ZN7CBBOLTS25loadBufferFromPreferencesEv_block_invoke_2(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a1;
  id v25 = a2;
  uint64_t v24 = a3;
  uint64_t v23 = a4;
  uint64_t v22 = a1;
  uint64_t v12 = *(void *)(a1 + 32);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    float v21 = 0.0;
    float v20 = 0.0;
    uint64_t v19 = -1;
    [v25 objectForKeyedSubscript:@"Lux"];
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && ([v25 objectForKeyedSubscript:@"Nits"],
          objc_opt_class(),
          (objc_opt_isKindOfClass() & 1) != 0)
      && ([v25 objectForKeyedSubscript:@"Timestamp"],
          objc_opt_class(),
          (objc_opt_isKindOfClass() & 1) != 0))
    {
      objc_msgSend((id)objc_msgSend(v25, "objectForKeyedSubscript:", @"Lux"), "floatValue");
      float v21 = v4;
      objc_msgSend((id)objc_msgSend(v25, "objectForKeyedSubscript:", @"Nits"), "floatValue");
      float v20 = v5;
      uint64_t v19 = objc_msgSend((id)objc_msgSend(v25, "objectForKeyedSubscript:", @"Timestamp"), "longLongValue");
      os_log_t oslog = 0;
      if (*(void *)(v12 + 8))
      {
        uint64_t v7 = *(NSObject **)(v12 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v7 = inited;
      }
      os_log_t oslog = v7;
      os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v27, COERCE__INT64(v21), COERCE__INT64(v20), v19);
        _os_log_debug_impl(&dword_1BA438000, oslog, v14, "Adding curve update from preferences: %f %f %lld", v27, 0x20u);
      }
      v13.n128_u64[0] = __PAIR64__(LODWORD(v20), LODWORD(v21));
      v13.n128_u64[1] = v19;
      std::list<AAB::CurveUpdate>::push_back((void *)(v12 + 88), &v13);
    }
    else
    {
      uint64_t v18 = 0;
      if (*(void *)(v12 + 8))
      {
        CFPropertyListRef v11 = *(NSObject **)(v12 + 8);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v10 = init_default_corebrightness_log();
        }
        CFPropertyListRef v11 = v10;
      }
      uint64_t v18 = v11;
      char v17 = 16;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        os_log_t log = v18;
        os_log_type_t type = v17;
        __os_log_helper_16_0_0(v16);
        _os_log_error_impl(&dword_1BA438000, log, type, "Wrongly formatted BOLTS buffer", v16, 2u);
      }
    }
  }
}

uint64_t AAB::UpdateCurveStrategy::UpdateAlternativeCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __n128 a6, __n128 a7, __n128 a8)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, __n128, __n128, __n128))(*(void *)a1 + 32))(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t AAB::UpdateCurveStrategy::alternativeCappedCurve()
{
  return 0;
}

uint64_t CBBOLTS::curveType(CBBOLTS *this)
{
  return 3;
}

uint64_t AAB::UpdateCurveStrategy::alternativeCurveType(AAB::UpdateCurveStrategy *this)
{
  return (*(uint64_t (**)(AAB::UpdateCurveStrategy *))(*(void *)this + 104))(this);
}

BOOL std::operator==[abi:ne180100]<CBBOLTS::Bin *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::__wrap_iter<CBBOLTS::Bin *>::base[abi:ne180100](a1);
  return v3 == std::__wrap_iter<CBBOLTS::Bin *>::base[abi:ne180100](a2);
}

uint64_t std::__wrap_iter<CBBOLTS::Bin *>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

BOOL std::operator==[abi:ne180100]<CBBOLTS::Bin const*>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::__wrap_iter<CBBOLTS::Bin const*>::base[abi:ne180100](a1);
  return v3 == std::__wrap_iter<CBBOLTS::Bin const*>::base[abi:ne180100](a2);
}

uint64_t std::__wrap_iter<CBBOLTS::Bin const*>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::~__list_imp(uint64_t a1)
{
  return a1;
}

void std::__list_imp<AAB::CurveUpdate>::clear(uint64_t a1)
{
  if (!std::__list_imp<AAB::CurveUpdate>::empty[abi:ne180100]())
  {
    uint64_t v5 = *(void *)(a1 + 8);
    float v4 = (uint64_t *)std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]();
    std::__list_imp<AAB::CurveUpdate>::__unlink_nodes(v5, *v4);
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *double v1 = 0;
    while ((uint64_t *)v5 != v4)
    {
      std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
      uint64_t v5 = *(void *)(v5 + 8);
      std::__list_imp<AAB::CurveUpdate>::__delete_node[abi:ne180100]<>(a1, v2);
    }
  }
}

BOOL std::__list_imp<AAB::CurveUpdate>::empty[abi:ne180100]()
{
  std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
  return *v0 == 0;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]()
{
  std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]();
  std::__list_node_pointer_traits<AAB::CurveUpdate,void *>::__unsafe_link_pointer_cast[abi:ne180100]();
  return result;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::__unlink_nodes(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)result + 8) = *(void *)(a2 + 8);
  **(void **)(a2 + 8) = *(void *)result;
  return result;
}

void std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]()
{
}

{
  std::__compressed_pair<unsigned long>::first[abi:ne180100]();
}

void std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]()
{
}

void std::__list_imp<AAB::CurveUpdate>::__delete_node[abi:ne180100]<>(uint64_t a1, void *a2)
{
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  uint64_t v3 = v2;
  std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100]((uint64_t)a2);
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::destroy[abi:ne180100]<AAB::CurveUpdate,void,void>();
  std::__destroy_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,0>((uint64_t)a2);
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::deallocate[abi:ne180100](v3, a2);
}

void std::__compressed_pair<unsigned long>::first[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<unsigned long,0,false>::__get[abi:ne180100]();
}

void std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]()
{
}

void std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]()
{
}

{
  std::__compressed_pair<unsigned long>::second[abi:ne180100]();
}

void std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::destroy[abi:ne180100]<AAB::CurveUpdate,void,void>()
{
}

uint64_t std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](uint64_t a1)
{
  return a1 + 16;
}

uint64_t std::__destroy_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,0>(uint64_t a1)
{
  return std::__list_node<AAB::CurveUpdate,void *>::~__list_node[abi:ne180100](a1);
}

void std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

void std::__compressed_pair<unsigned long>::second[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__get[abi:ne180100]();
}

uint64_t std::__list_node<AAB::CurveUpdate,void *>::~__list_node[abi:ne180100](uint64_t a1)
{
  return a1;
}

void std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

BOOL std::operator==[abi:ne180100]<CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::__wrap_iter<CBBOLTS::BinConfiguration const*>::base[abi:ne180100](a1);
  return v3 == std::__wrap_iter<CBBOLTS::BinConfiguration const*>::base[abi:ne180100](a2);
}

uint64_t std::__wrap_iter<CBBOLTS::BinConfiguration const*>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

void *AAB::UpdateCurveStrategy::UpdateCurveStrategy(void *this)
{
  *this = &unk_1F13F10E0;
  return this;
}

void AAB::UpdateCurveStrategy::~UpdateCurveStrategy(AAB::UpdateCurveStrategy *this)
{
}

{
  __break(1u);
}

uint64_t AAB::UpdateCurveStrategy::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, __n128 a6, __n128 a7, __n128 a8)
{
  unint64_t v14 = __PAIR64__(a7.n128_u32[0], a6.n128_u32[0]);
  float v15 = a8.n128_f32[0];
  (*(void (**)(uint64_t, uint64_t, uint64_t, __n128, __n128, __n128))(*(void *)a1 + 24))(a1, a2, a3, a6, a7, a8);
  float CapForE = AAB::findCapForE(a4, *((float *)&v14 + 1));
  if (v15 > CapForE) {
    float v15 = CapForE;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, float, float, float))(*(void *)a1 + 24))(a1, a2, a5, *(float *)&v14, *((float *)&v14 + 1), v15);
}

void *AAB::UpdateCurveStrategy::curveUpdates@<X0>(void *a1@<X8>)
{
  return std::list<AAB::CurveUpdate>::list[abi:ne180100](a1);
}

uint64_t AAB::UpdateCurveStrategy::cappedCurve()
{
  return 0;
}

unint64_t std::atomic_load_explicit[abi:ne180100]<void *>(atomic_ullong *a1, int a2)
{
  return std::__atomic_base<void *,false>::load[abi:ne180100](a1, a2);
}

unint64_t *___ZL15getMLModelClassv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = objc_getClass("MLModel");
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    abort_report_np();
  }
  return std::atomic_store_explicit[abi:ne180100]<void *>(&getMLModelClass(void)::softClass, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), 0);
}

unint64_t CoreMLLibrary(void)
{
  uint64_t v2 = 0;
  unint64_t v1 = CoreMLLibraryCore(&v2);
  if (!v1) {
    abort_report_np();
  }
  if (v2) {
    free(v2);
  }
  return v1;
}

unint64_t *std::atomic_store_explicit[abi:ne180100]<void *>(unint64_t *a1, unint64_t a2, int a3)
{
  return std::__atomic_base<void *,false>::store[abi:ne180100](a1, a2, a3);
}

unint64_t std::__atomic_base<void *,false>::load[abi:ne180100](atomic_ullong *a1, int a2)
{
  return std::__cxx_atomic_load[abi:ne180100]<void *>(a1, a2);
}

unint64_t std::__cxx_atomic_load[abi:ne180100]<void *>(atomic_ullong *a1, int a2)
{
  if (a2 == 2 || a2 == 1) {
    return atomic_load_explicit(a1, memory_order_acquire);
  }
  if (a2 != 5) {
    return *a1;
  }
  return atomic_load((unint64_t *)a1);
}

unint64_t CoreMLLibraryCore(char **a1)
{
  return std::atomic_load_explicit[abi:ne180100]<void *>((atomic_ullong *)&CoreMLLibraryCore(char **)::frameworkLibrary, 0);
}

unint64_t *___ZL17CoreMLLibraryCorePPc_block_invoke()
{
  unint64_t v0 = _sl_dlopen();
  return std::atomic_store_explicit[abi:ne180100]<void *>(&CoreMLLibraryCore(char **)::frameworkLibrary, v0, 0);
}

unint64_t *std::__atomic_base<void *,false>::store[abi:ne180100](unint64_t *a1, unint64_t a2, int a3)
{
  return std::__cxx_atomic_store[abi:ne180100]<void *>(a1, a2, a3);
}

unint64_t *std::__cxx_atomic_store[abi:ne180100]<void *>(unint64_t *result, unint64_t a2, int a3)
{
  if (a3 == 3 || a3 == 5) {
    atomic_store(a2, result);
  }
  else {
    *uint64_t result = a2;
  }
  return result;
}

BOOL std::operator==[abi:ne180100]<AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a1);
  return v3 == std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a2);
}

uint64_t std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

unint64_t *___ZL20getMLMultiArrayClassv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = objc_getClass("MLMultiArray");
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    abort_report_np();
  }
  return std::atomic_store_explicit[abi:ne180100]<void *>(&getMLMultiArrayClass(void)::softClass, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), 0);
}

unint64_t *___ZL28getMLModelConfigurationClassv_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = objc_getClass("MLModelConfiguration");
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    abort_report_np();
  }
  return std::atomic_store_explicit[abi:ne180100]<void *>(&getMLModelConfigurationClass(void)::softClass, *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), 0);
}

void *std::__list_imp<AAB::CurveUpdate>::__list_imp(void *a1)
{
  float v4 = a1;
  std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](a1);
  int v3 = 0;
  std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::__default_init_tag>(a1 + 2, &v3);
  return a1;
}

void *std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](void *a1)
{
  return a1;
}

{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *result;

  std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]();
  std::__list_node_pointer_traits<AAB::CurveUpdate,void *>::__unsafe_link_pointer_cast[abi:ne180100]();
  *a1 = v1;
  std::__list_node_base<AAB::CurveUpdate,void *>::__self[abi:ne180100]();
  std::__list_node_pointer_traits<AAB::CurveUpdate,void *>::__unsafe_link_pointer_cast[abi:ne180100]();
  int v3 = v2;
  uint64_t result = a1;
  a1[1] = v3;
  return result;
}

void *std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::__default_init_tag>(void *a1, int *a2)
{
  return a1;
}

{
  std::__compressed_pair_elem<unsigned long,0,false>::__compressed_pair_elem[abi:ne180100]<int,void>(a1, a2);
  std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

void *std::__compressed_pair_elem<unsigned long,0,false>::__compressed_pair_elem[abi:ne180100]<int,void>(void *result, int *a2)
{
  *uint64_t result = *a2;
  return result;
}

uint64_t std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::allocator[abi:ne180100](uint64_t a1)
{
  return a1;
}

void *std::__list_imp<AAB::CurveUpdate>::__list_imp(void *a1, uint64_t a2)
{
  int v6 = a1;
  uint64_t v5 = a2;
  std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](a1);
  int v4 = 0;
  std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>(a1 + 2, &v4);
  return a1;
}

void *std::__compressed_pair<unsigned long>::__compressed_pair[abi:ne180100]<int,std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>(void *a1, int *a2)
{
  return a1;
}

{
  std::__compressed_pair_elem<unsigned long,0,false>::__compressed_pair_elem[abi:ne180100]<int,void>(a1, a2);
  std::__compressed_pair_elem<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,1,true>::__compressed_pair_elem[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,void>();
  return a1;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  v15[1] = a1;
  v15[0] = a2;
  uint64_t v14 = a3;
  __n128 v13 = a4;
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  uint64_t v12 = v4;
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__allocation_guard[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>((uint64_t)v11, 1);
  uint64_t v5 = (void *)std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100]((uint64_t)v11);
  std::__construct_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node<AAB::CurveUpdate,void *>*>(v5, v15, &v14);
  uint64_t v10 = v12;
  uint64_t v6 = std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100]((uint64_t)v11);
  uint64_t v7 = (__n128 *)std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v6);
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(v10, v7, v13);
  uint64_t v9 = std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__release_ptr[abi:ne180100]((uint64_t)v11);
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100]((uint64_t)v11);
  return v9;
}

void sub_1BA4D4840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17, _Unwind_Exception *exception_object)
{
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100](v18 - 64);
  _Unwind_Resume(a1);
}

void std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]()
{
}

uint64_t std::list<AAB::CurveUpdate>::__link_nodes_at_back(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]();
  *(void *)(a3 + 8) = result;
  *(void *)a2 = *a1;
  *(void *)(*(void *)a2 + 8) = a2;
  *a1 = a3;
  return result;
}

uint64_t std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__allocation_guard[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>(uint64_t a1, uint64_t a2)
{
  return a1;
}

{
  void *v2;
  uint64_t result;

  *(void *)(a1 + 8) = a2;
  uint64_t v2 = std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::allocate[abi:ne180100](a1, *(void *)(a1 + 8));
  uint64_t result = a1;
  *(void *)(a1 + 16) = v2;
  return result;
}

void *std::__construct_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node<AAB::CurveUpdate,void *>*>(void *a1, uint64_t *a2, uint64_t *a3)
{
  return a1;
}

uint64_t std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 16);
}

double std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(void *)&double result = std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&>(a1, a2, a3).n128_u64[0];
  return result;
}

uint64_t std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__release_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  return v2;
}

uint64_t std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100](uint64_t a1)
{
  return a1;
}

{
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__destroy[abi:ne180100](a1);
  return a1;
}

void *std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  return std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::allocate[abi:ne180100](a1, a2);
}

void *std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::max_size[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,void>()) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return std::__libcpp_allocate[abi:ne180100](32 * a2);
}

uint64_t std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::max_size[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>,void>()
{
  return std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::max_size[abi:ne180100]();
}

uint64_t std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::max_size[abi:ne180100]()
{
  return 0x7FFFFFFFFFFFFFFLL;
}

void *std::__list_node<AAB::CurveUpdate,void *>::__list_node[abi:ne180100](void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

{
  std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](a1, a2, a3);
  return a1;
}

void *std::__list_node_base<AAB::CurveUpdate,void *>::__list_node_base[abi:ne180100](void *result, uint64_t a2, uint64_t a3)
{
  *double result = a2;
  result[1] = a3;
  return result;
}

__n128 std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

void std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__destroy[abi:ne180100](uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::deallocate[abi:ne180100](a1, *(void **)(a1 + 16));
  }
}

uint64_t std::vector<CBBOLTS::Bin>::__make_iter[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__wrap_iter<CBBOLTS::Bin *>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

{
  uint64_t v3;

  std::__wrap_iter<CBBOLTS::Bin const*>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

void *std::__wrap_iter<CBBOLTS::Bin *>::__wrap_iter[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void *std::__wrap_iter<CBBOLTS::Bin *>::__wrap_iter[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate>(uint64_t a1, uint64_t a2, uint64_t a3, __n128 *a4)
{
  v15[1] = a1;
  v15[0] = a2;
  uint64_t v14 = a3;
  __n128 v13 = a4;
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  uint64_t v12 = v4;
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__allocation_guard[abi:ne180100]<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>((uint64_t)v11, 1);
  uint64_t v5 = (void *)std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100]((uint64_t)v11);
  std::__construct_at[abi:ne180100]<std::__list_node<AAB::CurveUpdate,void *>,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node_base<AAB::CurveUpdate,void *> *&,std::__list_node<AAB::CurveUpdate,void *>*>(v5, v15, &v14);
  uint64_t v10 = v12;
  uint64_t v6 = std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__get[abi:ne180100]((uint64_t)v11);
  uint64_t v7 = (__n128 *)std::__list_node<AAB::CurveUpdate,void *>::__get_value[abi:ne180100](v6);
  std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(v10, v7, v13);
  uint64_t v9 = std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::__release_ptr[abi:ne180100]((uint64_t)v11);
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100]((uint64_t)v11);
  return v9;
}

void sub_1BA4D4DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17, _Unwind_Exception *exception_object)
{
  std::__allocation_guard<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::~__allocation_guard[abi:ne180100](v18 - 64);
  _Unwind_Resume(a1);
}

double std::allocator_traits<std::allocator<std::__list_node<AAB::CurveUpdate,void *>>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(void *)&double result = std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a1, a2, a3).n128_u64[0];
  return result;
}

__n128 std::allocator<std::__list_node<AAB::CurveUpdate,void *>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

void *std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(void *a1)
{
  return a1;
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

void *std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(void *result)
{
  *__n128 result = 0;
  return result;
}

uint64_t std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t std::allocator<AAB::CurveUpdate>::allocator[abi:ne180100](uint64_t a1)
{
  return a1;
}

void *std::vector<AAB::CurveUpdate>::__destroy_vector::__destroy_vector[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void std::vector<AAB::CurveUpdate>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  if (**a1)
  {
    std::vector<AAB::CurveUpdate>::__clear[abi:ne180100](*a1);
    std::vector<AAB::CurveUpdate>::__annotate_delete[abi:ne180100]();
    std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
    uint64_t v3 = v1;
    uint64_t v2 = (void *)**a1;
    std::vector<AAB::CurveUpdate>::capacity[abi:ne180100](*a1);
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::deallocate[abi:ne180100](v3, v2);
  }
}

void *std::vector<AAB::CurveUpdate>::__destroy_vector::__destroy_vector[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void std::vector<AAB::CurveUpdate>::__clear[abi:ne180100](uint64_t *a1)
{
}

void std::allocator_traits<std::allocator<AAB::CurveUpdate>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

void std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]()
{
}

{
  std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100]();
}

uint64_t std::vector<AAB::CurveUpdate>::capacity[abi:ne180100](void *a1)
{
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 16;
}

void std::vector<AAB::CurveUpdate>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); a2 != i; i -= 16)
  {
    std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
    std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::destroy[abi:ne180100]<AAB::CurveUpdate,void>();
  }
  *(void *)(a1 + 8) = a2;
}

void std::allocator_traits<std::allocator<AAB::CurveUpdate>>::destroy[abi:ne180100]<AAB::CurveUpdate,void>()
{
}

void std::allocator<AAB::CurveUpdate>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

void std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate>,1,true>::__get[abi:ne180100]();
}

void std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]()
{
}

{
  std::__compressed_pair<AAB::CurveUpdate *>::first[abi:ne180100]();
}

void std::__compressed_pair<AAB::CurveUpdate *>::first[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__get[abi:ne180100]();
}

void *std::__wrap_iter<CBBOLTS::Bin const*>::__wrap_iter[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void *std::__wrap_iter<CBBOLTS::Bin const*>::__wrap_iter[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void *std::vector<AAB::CurveUpdate>::__construct_one_at_end[abi:ne180100]<AAB::CurveUpdate>(uint64_t a1, __n128 *a2)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, 1);
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  uint64_t v5 = v2;
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(v5, v3, v8);
  v7 += 16;
  return std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1BA4D54B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
}

uint64_t std::vector<AAB::CurveUpdate>::__push_back_slow_path<AAB::CurveUpdate>(uint64_t *a1, __n128 *a2)
{
  float v15 = a1;
  uint64_t v14 = a2;
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  uint64_t v13 = v2;
  uint64_t v3 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  unint64_t v9 = std::vector<AAB::CurveUpdate>::__recommend[abi:ne180100](a1, v3 + 1);
  uint64_t v4 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  std::__split_buffer<AAB::CurveUpdate>::__split_buffer(v11, v9, v4, v13);
  uint64_t v10 = v13;
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(v10, v5, v14);
  v12 += 16;
  std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(a1, v11);
  uint64_t v7 = a1[1];
  std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(v11);
  return v7;
}

void sub_1BA4D559C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, void *a16)
{
}

void *std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

double std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(void *)&double result = std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a1, a2, a3).n128_u64[0];
  return result;
}

void *std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](void *a1)
{
  return a1;
}

void *std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *result, uint64_t a2, uint64_t a3)
{
  *double result = a2;
  result[1] = *(void *)(a2 + 8);
  result[2] = *(void *)(a2 + 8) + 16 * a3;
  return result;
}

__n128 std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

void *std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](void *result)
{
  *(void *)(*result + 8) = result[1];
  return result;
}

unint64_t std::vector<AAB::CurveUpdate>::__recommend[abi:ne180100](void *a1, uint64_t a2)
{
  v7[1] = a1;
  v7[0] = a2;
  unint64_t v6 = std::vector<AAB::CurveUpdate>::max_size((uint64_t)a1);
  if (v7[0] > v6) {
    std::vector<AAB::CurveUpdate>::__throw_length_error[abi:ne180100]();
  }
  unint64_t v5 = std::vector<AAB::CurveUpdate>::capacity[abi:ne180100](a1);
  if (v5 >= v6 / 2) {
    return v6;
  }
  uint64_t v4 = 2 * v5;
  return *std::max[abi:ne180100]<unsigned long>(&v4, v7);
}

void **std::__split_buffer<AAB::CurveUpdate>::__split_buffer(void **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v9;
  void v11[2];
  uint64_t v12;
  unint64_t v13;
  void **v14;
  void **v15;

  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  v11[1] = a4;
  float v15 = a1;
  v11[0] = 0;
  std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<AAB::CurveUpdate> &>(a1 + 3, (uint64_t)v11, a4);
  if (v13)
  {
    uint64_t v4 = std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100]((uint64_t)a1);
    *a1 = std::__allocate_at_least[abi:ne180100]<std::allocator<AAB::CurveUpdate>>(v4, v13);
    uint64_t v13 = v5;
  }
  else
  {
    *a1 = 0;
  }
  unint64_t v6 = (uint64_t)*a1 + 16 * v12;
  a1[2] = (void *)v6;
  a1[1] = (void *)v6;
  unint64_t v9 = (unint64_t)*a1 + 16 * v13;
  std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  *uint64_t v7 = v9;
  return v15;
}

void std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  float v15 = a1;
  uint64_t v14 = a2;
  std::vector<AAB::CurveUpdate>::__annotate_delete[abi:ne180100]();
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  uint64_t v7 = v2;
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v12, a1[1]);
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v11, *a1);
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v10, v14[1]);
  v13[0] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::reverse_iterator<AAB::CurveUpdate*>,std::reverse_iterator<AAB::CurveUpdate*>,AAB::CurveUpdate,void>(v7, v12[0], v12[1], v11[0], v11[1], v10[0], v10[1]);
  v13[1] = v3;
  uint64_t v4 = std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100]((uint64_t)v13);
  v14[1] = v4;
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(a1, v14 + 1);
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(a1 + 1, v14 + 2);
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  uint64_t v8 = v5;
  std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(v8, v6);
  *uint64_t v14 = v14[1];
  std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  std::vector<AAB::CurveUpdate>::__annotate_new[abi:ne180100]();
}

void **std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(void **a1)
{
  return a1;
}

{
  uint64_t v2;
  void *v3;

  std::__split_buffer<AAB::CurveUpdate>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
  {
    uint64_t v2 = std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100]((uint64_t)a1);
    uint64_t v3 = *a1;
    std::__split_buffer<AAB::CurveUpdate>::capacity[abi:ne180100](a1);
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::deallocate[abi:ne180100](v2, v3);
  }
  return a1;
}

uint64_t std::vector<AAB::CurveUpdate>::max_size(uint64_t a1)
{
  v3[1] = a1;
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  v3[0] = std::allocator_traits<std::allocator<AAB::CurveUpdate>>::max_size[abi:ne180100]<std::allocator<AAB::CurveUpdate>,void>();
  uint64_t v2 = std::numeric_limits<long>::max[abi:ne180100]();
  return *std::min[abi:ne180100]<unsigned long>(v3, &v2);
}

void std::vector<AAB::CurveUpdate>::__throw_length_error[abi:ne180100]()
{
}

uint64_t std::allocator_traits<std::allocator<AAB::CurveUpdate>>::max_size[abi:ne180100]<std::allocator<AAB::CurveUpdate>,void>()
{
  return std::allocator<AAB::CurveUpdate>::max_size[abi:ne180100]();
}

uint64_t std::allocator<AAB::CurveUpdate>::max_size[abi:ne180100]()
{
  return 0xFFFFFFFFFFFFFFFLL;
}

void *std::__compressed_pair<AAB::CurveUpdate *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<AAB::CurveUpdate> &>(void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

{
  std::__compressed_pair_elem<AAB::CurveUpdate *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<AAB::CurveUpdate> &,void>(a1 + 1, a3);
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AAB::CurveUpdate>>(uint64_t a1, unint64_t a2)
{
  return std::allocator<AAB::CurveUpdate>::allocate[abi:ne180100](a1, a2);
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100](a1 + 24);
}

void std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]()
{
}

{
  std::__compressed_pair<AAB::CurveUpdate *>::first[abi:ne180100]();
}

void *std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<AAB::CurveUpdate> &,void>(void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void *std::allocator<AAB::CurveUpdate>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<AAB::CurveUpdate>>::max_size[abi:ne180100]<std::allocator<AAB::CurveUpdate>,void>()) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return std::__libcpp_allocate[abi:ne180100](16 * a2);
}

uint64_t std::__compressed_pair<AAB::CurveUpdate *>::second[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate> &,1,false>::__get[abi:ne180100](a1 + 8);
}

uint64_t std::__compressed_pair_elem<std::allocator<AAB::CurveUpdate> &,1,false>::__get[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::reverse_iterator<AAB::CurveUpdate*>,std::reverse_iterator<AAB::CurveUpdate*>,AAB::CurveUpdate,void>(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return std::move[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(a2, a3, a4, a5, a6, a7);
}

void *std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

uint64_t std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t *std::swap[abi:ne180100]<AAB::CurveUpdate *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *__n128 result = *a2;
  *a2 = v2;
  return result;
}

uint64_t std::move[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(unint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v13 = a1;
  unint64_t v14 = a2;
  uint64_t v11 = a3;
  uint64_t v12 = a4;
  uint64_t v9 = a5;
  uint64_t v10 = a6;
  std::__move[abi:ne180100]<std::_ClassicAlgPolicy,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(a1, a2, a3, a4, a5, a6, &v7);
  return v8;
}

_OWORD *std::__move[abi:ne180100]<std::_ClassicAlgPolicy,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(a1, a2, a3, a4, a5, a6, a7);
}

_OWORD *std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(a1, a2, a3, a4, a5, a6, a7);
}

_OWORD *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, _OWORD *a7@<X8>)
{
  v26.n128_u64[0] = a1;
  v26.n128_u64[1] = a2;
  *(void *)&long long v25 = a3;
  *((void *)&v25 + 1) = a4;
  *(void *)&long long v24 = a5;
  *((void *)&v24 + 1) = a6;
  __n128 v22 = v26;
  long long v21 = v25;
  std::__unwrap_range[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(a1, a2, a3, a4, v23);
  long long v18 = v23[0];
  long long v17 = v23[1];
  v14[1] = v24;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>,0>();
  unint64_t v15 = v7;
  unint64_t v16 = v8;
  std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(v18, *((uint64_t *)&v18 + 1), v17, *((uint64_t *)&v17 + 1), v7, v8, &v19);
  void v13[2] = v26;
  v13[1] = v19;
  *(void *)&v14[0] = std::__rewrap_range[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(v26.n128_i64[0], v26.n128_i64[1], v19.n128_i64[0]);
  *((void *)&v14[0] + 1) = v9;
  v13[0].n128_u64[0] = std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>>(v24, *((uint64_t *)&v24 + 1), v20);
  v13[0].n128_u64[1] = v10;
  return std::make_pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(v14, v13, a7);
}

_OWORD *std::__unwrap_range[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _OWORD *a5@<X8>)
{
  v15.n128_u64[0] = a1;
  v15.n128_u64[1] = a2;
  uint64_t v13 = a3;
  uint64_t v14 = a4;
  v11[1] = v15;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>,0>();
  *(void *)&long long v12 = v5;
  *((void *)&v12 + 1) = v6;
  std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>,0>();
  v11[0].n128_u64[0] = v7;
  v11[0].n128_u64[1] = v8;
  return std::make_pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(&v12, v11, a5);
}

_OWORD *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, unint64_t a5@<X5>, unint64_t a6@<X6>, _OWORD *a7@<X8>)
{
  *(void *)&long long v12 = a1;
  *((void *)&v12 + 1) = a2;
  v11[0] = a3;
  v11[1] = a4;
  v10.n128_u64[0] = a5;
  v10.n128_u64[1] = a6;
  while (std::operator!=[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>((uint64_t)&v12, (uint64_t)v11))
  {
    unint64_t v8 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *> &,0>((uint64_t)&v12);
    *(_OWORD *)std::reverse_iterator<AAB::CurveUpdate *>::operator*[abi:ne180100]((uint64_t)&v10) = *v8;
    std::reverse_iterator<AAB::CurveUpdate *>::operator++[abi:ne180100]((uint64_t)&v12);
    std::reverse_iterator<AAB::CurveUpdate *>::operator++[abi:ne180100]((uint64_t)&v10);
  }
  return std::make_pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(&v12, &v10, a7);
}

void std::__unwrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>,0>()
{
}

_OWORD *std::make_pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>@<X0>(_OWORD *a1@<X0>, __n128 *a2@<X1>, _OWORD *a3@<X8>)
{
  return std::pair<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>::pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(a3, a1, a2);
}

uint64_t std::__rewrap_range[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>>(a1, a2, a3);
}

uint64_t std::__rewrap_iter[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>::__rewrap[abi:ne180100](a1, a2, a3);
}

BOOL std::operator!=[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100](a1);
  return v3 != std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100](a2);
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *> &,0>(uint64_t a1)
{
  return std::reverse_iterator<AAB::CurveUpdate *>::operator*[abi:ne180100](a1);
}

uint64_t std::reverse_iterator<AAB::CurveUpdate *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 8) - 16;
}

uint64_t std::reverse_iterator<AAB::CurveUpdate *>::operator++[abi:ne180100](uint64_t result)
{
  *(void *)(result + 8) -= 16;
  return result;
}

_OWORD *std::pair<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>::pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  return a1;
}

__n128 std::pair<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>>::pair[abi:ne180100]<std::reverse_iterator<AAB::CurveUpdate *>,std::reverse_iterator<AAB::CurveUpdate *>,0>(_OWORD *a1, _OWORD *a2, __n128 *a3)
{
  *a1 = *a2;
  __n128 result = *a3;
  a1[1] = *a3;
  return result;
}

uint64_t std::__unwrap_iter_impl<std::reverse_iterator<AAB::CurveUpdate *>,false>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

void *std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  result[1] = a2;
  return result;
}

void std::__split_buffer<AAB::CurveUpdate>::clear[abi:ne180100](uint64_t a1)
{
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::capacity[abi:ne180100](void *a1)
{
  std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 16;
}

void std::__split_buffer<AAB::CurveUpdate>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
}

{
  while (a2 != *(void *)(a1 + 16))
  {
    std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100](a1);
    *(void *)(a1 + 16) -= 16;
    std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::destroy[abi:ne180100]<AAB::CurveUpdate,void>();
  }
}

uint64_t std::__list_imp<AAB::CurveUpdate>::begin[abi:ne180100](uint64_t a1)
{
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v2, *(void *)(a1 + 8));
  return v2;
}

{
  uint64_t v2;

  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v2, *(void *)(a1 + 8));
  return v2;
}

void *std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void *std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

uint64_t std::__list_imp<AAB::CurveUpdate>::end[abi:ne180100]()
{
  uint64_t v0 = std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]();
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v2, v0);
  return v2;
}

{
  uint64_t v0;
  uint64_t v2;

  uint64_t v0 = std::__list_imp<AAB::CurveUpdate>::__end_as_link[abi:ne180100]();
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v2, v0);
  return v2;
}

BOOL std::operator==[abi:ne180100](void *a1, void *a2)
{
  return *a1 == *a2;
}

{
  return *a1 == *a2;
}

void *std::vector<AAB::CurveUpdate>::__construct_one_at_end[abi:ne180100]<AAB::CurveUpdate const&>(uint64_t a1, __n128 *a2)
{
  uint64_t v9 = a1;
  unint64_t v8 = a2;
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, 1);
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  uint64_t v5 = v2;
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(v5, v3, v8);
  v7 += 16;
  return std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1BA4D68C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
}

uint64_t std::vector<AAB::CurveUpdate>::__push_back_slow_path<AAB::CurveUpdate const&>(uint64_t *a1, __n128 *a2)
{
  __n128 v15 = a1;
  uint64_t v14 = a2;
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  uint64_t v13 = v2;
  uint64_t v3 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  unint64_t v9 = std::vector<AAB::CurveUpdate>::__recommend[abi:ne180100](a1, v3 + 1);
  uint64_t v4 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  std::__split_buffer<AAB::CurveUpdate>::__split_buffer(v11, v9, v4, v13);
  uint64_t v10 = v13;
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(v10, v5, v14);
  v12 += 16;
  std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(a1, v11);
  uint64_t v7 = a1[1];
  std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(v11);
  return v7;
}

void sub_1BA4D69AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, void *a16)
{
}

double std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(void *)&double result = std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&>(a1, a2, a3).n128_u64[0];
  return result;
}

__n128 std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate const&>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t std::vector<AAB::CurveUpdate>::__make_iter[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__wrap_iter<AAB::CurveUpdate *>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

void *std::__wrap_iter<AAB::CurveUpdate *>::__wrap_iter[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void *std::__wrap_iter<AAB::CurveUpdate *>::__wrap_iter[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void std::__sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__debug_randomize_range[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>>();
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a1);
  uint64_t v5 = v3;
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a2);
  std::__sort_dispatch[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(v5, v4, a3);
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a1);
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a2);
  std::__check_strict_weak_ordering_sorted[abi:ne180100]<AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>();
}

void std::__sort_dispatch[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  uint64_t v3 = std::__log2i[abi:ne180100]<long>(a2 - a1);
  std::__introsort<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,false>(a1, a2, a3, 2 * v3, 1);
}

void std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(uint64_t a1)
{
}

uint64_t std::__log2i[abi:ne180100]<long>(unint64_t a1)
{
  if (a1) {
    return 63 - (int)std::__libcpp_clz[abi:ne180100](a1);
  }
  else {
    return 0;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,false>(__n128 *a1, __n128 *a2, uint64_t a3, uint64_t a4, char a5)
{
  __n128 v19 = a1;
  long long v18 = a2;
  uint64_t v17 = a3;
  uint64_t v16 = a4;
  char v15 = a5 & 1;
  uint64_t v14 = 24;
  uint64_t v13 = 128;
  while (1)
  {
    uint64_t v12 = v18 - v19;
    if (v12)
    {
      uint64_t v6 = v12;
      char v5 = 1;
    }
    else
    {
      uint64_t v6 = 0;
      char v5 = 0;
    }
    if ((v5 & 1) == 0) {
      break;
    }
    if (v12 < 24)
    {
      if (v15) {
        std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((BOOL)v19, v18, v17);
      }
      else {
        std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((uint64_t)v19, (uint64_t)v18, v17);
      }
      return;
    }
    if (!v16)
    {
      std::__partial_sort[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate *>(v19, v18, v18, v17);
      return;
    }
    --v16;
    uint64_t v11 = v12 / 2;
    if (v12 <= 128)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(&v19[v11], v19, v18 - 1, v17);
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v19, &v19[v11], v18 - 1, v17);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v19 + 1, &v19[v11 - 1], v18 - 2, v17);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v19 + 2, &v19[v11 + 1], v18 - 3, v17);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(&v19[v11 - 1], &v19[v11], &v19[v11 + 1], v17);
      uint64_t v10 = &v19[v11];
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *>(&v19, &v10);
    }
    if ((v15 & 1) != 0
      || CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v17, (uint64_t)&v19[-1], (uint64_t)v19))
    {
      unint64_t v9 = (__n128 *)std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(v19, v18, v17);
      if ((v7 & 1) == 0) {
        goto LABEL_31;
      }
      BOOL v8 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v19, v9, v17);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v9 + 1, v18, v17))
      {
        if (v8) {
          return;
        }
        long long v18 = v9;
      }
      else if (v8)
      {
        __n128 v19 = v9 + 1;
      }
      else
      {
LABEL_31:
        std::__introsort<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,false>(v19, v9, v17, v16, v15 & 1);
        char v15 = 0;
        __n128 v19 = v9 + 1;
      }
    }
    else
    {
      __n128 v19 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(v19, v18, v17);
    }
  }
  switch(v6)
  {
    case 0:
    case 1:
      return;
    case 2:
      if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v17, (uint64_t)--v18, (uint64_t)v19)) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v19, &v18);
      }
      break;
    case 3:
      std::__sort3_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(v19, v19 + 1, --v18, v17);
      break;
    case 4:
      std::__sort4_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(v19, v19 + 1, v19 + 2, --v18, v17);
      break;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(v19, v19 + 1, v19 + 2, v19 + 3, --v18, v17);
      break;
    default:
      JUMPOUT(0);
  }
}

unint64_t std::__libcpp_clz[abi:ne180100](unint64_t a1)
{
  return __clz(a1);
}

{
  return __clz(a1);
}

BOOL CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(void *)(a2 + 8) < *(void *)(a3 + 8);
}

double std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(__n128 **a1, __n128 **a2)
{
  return std::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(*a1, *a2);
}

uint64_t std::__sort3_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4)
{
  return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a4);
}

double std::__sort4_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, uint64_t a5)
{
  return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a4, a5);
}

double std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, uint64_t a6)
{
  return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a4, a5, a6);
}

BOOL std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(BOOL result, _OWORD *a2, uint64_t a3)
{
  uint64_t v11 = (_OWORD *)result;
  uint64_t v10 = a2;
  uint64_t v9 = a3;
  if ((_OWORD *)result != a2)
  {
    for (uint64_t i = v11 + 1; i != v10; ++i)
    {
      char v7 = i - 1;
      __n128 result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)i, (uint64_t)(i - 1));
      if (result)
      {
        long long v6 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&i);
        char v5 = v7;
        char v7 = i;
        do
        {
          uint64_t v3 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v5);
          *char v7 = *v3;
          char v7 = v5;
          __n128 result = 0;
          BOOL v4 = 0;
          if (v5 != v11)
          {
            __n128 result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)&v6, (uint64_t)--v5);
            BOOL v4 = result;
          }
        }
        while (v4);
        *char v7 = v6;
      }
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = result;
  uint64_t v9 = a2;
  uint64_t v8 = a3;
  if (result != a2)
  {
    v7[1] = v10 - 16;
    for (v7[0] = v10 + 16; v7[0] != v9; v7[0] += 16)
    {
      long long v6 = (_OWORD *)(v7[0] - 16);
      __n128 result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v8, v7[0], v7[0] - 16);
      if (result)
      {
        long long v5 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)v7);
        BOOL v4 = v6;
        long long v6 = (_OWORD *)v7[0];
        do
        {
          uint64_t v3 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v4);
          *long long v6 = *v3;
          long long v6 = v4--;
          __n128 result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v8, (uint64_t)&v5, (uint64_t)v4);
        }
        while ((result & 1) != 0);
        *long long v6 = v5;
      }
    }
  }
  return result;
}

uint64_t std::__partial_sort[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4)
{
  if (a1 == a2) {
    return std::_IterOps<std::_ClassicAlgPolicy>::next[abi:ne180100]<AAB::CurveUpdate *>((uint64_t)a2, (uint64_t)a3);
  }
  std::__debug_randomize_range[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *>();
  long long v5 = std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3, a4);
  std::__debug_randomize_range[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *>();
  return (uint64_t)v5;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4)
{
  uint64_t v10 = a1;
  uint64_t v9 = a2;
  uint64_t v8 = a3;
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)a2, (uint64_t)a1))
  {
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)v8, (uint64_t)v9))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v8);
      return 1;
    }
    else
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v9);
      unsigned int v6 = 1;
      if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)v8, (uint64_t)v9))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v9, &v8);
        return 2;
      }
      return v6;
    }
  }
  else if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)v8, (uint64_t)v9))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v9, &v8);
    unsigned int v5 = 1;
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a4, (uint64_t)v9, (uint64_t)v10))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v9);
      return 2;
    }
    return v5;
  }
  else
  {
    return 0;
  }
}

double std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *>(__n128 **a1, __n128 **a2)
{
  return std::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(*a1, *a2);
}

__n128 *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  uint64_t v10 = a3;
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  __n128 v7 = *(__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v12);
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)&v11[-1]))
  {
    do
      ++v12;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v12));
  }
  else
  {
    do
    {
      ++v12;
      LOBYTE(v5) = 0;
      if (v12 < v11) {
        BOOL v5 = !CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v12);
      }
    }
    while (v5);
  }
  if (v12 < v11)
  {
    do
      --v11;
    while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v11));
  }
  while (v12 < v11)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v12, &v11);
    do
      ++v12;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v12));
    do
      --v11;
    while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v10, (uint64_t)&v7, (uint64_t)v11));
  }
  unsigned int v6 = v12 - 1;
  if (v9 != &v12[-1])
  {
    uint64_t v3 = (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v6);
    *uint64_t v9 = *v3;
  }
  *unsigned int v6 = v7;
  return v12;
}

uint64_t std::__bitset_partition[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  long long v18 = a1;
  uint64_t v17 = a2;
  uint64_t v16 = a3;
  char v15 = a1;
  uint64_t v14 = a2;
  __n128 v13 = *(__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v18);
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v13, (uint64_t)&v17[-1]))
  {
    do
      ++v18;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v13, (uint64_t)v18));
  }
  else
  {
    do
    {
      ++v18;
      LOBYTE(v7) = 0;
      if (v18 < v17) {
        BOOL v7 = !CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v13, (uint64_t)v18);
      }
    }
    while (v7);
  }
  if (v18 < v17)
  {
    do
      --v17;
    while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v16, (uint64_t)&v13, (uint64_t)v17));
  }
  BOOL v12 = v18 >= v17;
  if (v18 < v17)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v18, &v17);
    ++v18;
  }
  uint64_t v11 = v17 - 1;
  unint64_t v10 = 0;
  unint64_t v9 = 0;
  while (v11 - v18 >= 127)
  {
    if (!v10) {
      std::__populate_left_bitset[abi:ne180100]<CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>((BOOL)v18, v16, (uint64_t)&v13, &v10);
    }
    if (!v9) {
      std::__populate_right_bitset[abi:ne180100]<CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>((BOOL)v11, v16, (uint64_t)&v13, &v9);
    }
    std::__swap_bitmap_pos[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>((uint64_t)v18, (uint64_t)v11, &v10, &v9);
    if (v10) {
      uint64_t v3 = 0;
    }
    else {
      uint64_t v3 = 64;
    }
    v18 += v3;
    if (v9) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = 64;
    }
    v11 -= v4;
  }
  std::__bitset_partition_partial_blocks[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>((uint64_t *)&v18, (uint64_t *)&v11, v16, (uint64_t)&v13, &v10, &v9);
  std::__swap_bitmap_pos_within[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>(&v18, &v11, &v10, &v9);
  uint64_t v8 = v18 - 1;
  if (v15 != &v18[-1])
  {
    BOOL v5 = (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v8);
    *char v15 = *v5;
  }
  *uint64_t v8 = v13;
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &>(&v8, &v12);
}

uint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  __n128 v13 = a1;
  BOOL v12 = a2;
  uint64_t v11 = a3;
  unint64_t v10 = a1;
  unint64_t v9 = a2;
  __n128 v8 = *(__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v13);
  do
    ++v13;
  while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v13, (uint64_t)&v8));
  if (v10 == &v13[-1])
  {
    do
    {
      LOBYTE(v5) = 0;
      if (v13 < v12) {
        BOOL v5 = !CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)--v12, (uint64_t)&v8);
      }
    }
    while (v5);
  }
  else
  {
    do
      --v12;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v12, (uint64_t)&v8));
  }
  BOOL v7 = v13 >= v12;
  while (v13 < v12)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v13, &v12);
    do
      ++v13;
    while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v13, (uint64_t)&v8));
    do
      --v12;
    while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v12, (uint64_t)&v8));
  }
  unsigned int v6 = v13 - 1;
  if (v10 != &v13[-1])
  {
    uint64_t v3 = (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v6);
    *unint64_t v10 = *v3;
  }
  *unsigned int v6 = v8;
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &>(&v6, &v7);
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, uint64_t a3)
{
  uint64_t v16 = a1;
  char v15 = a2;
  uint64_t v14 = a3;
  if (a2 - a1)
  {
    uint64_t v4 = a2 - a1;
    char v3 = 1;
  }
  else
  {
    uint64_t v4 = 0;
    char v3 = 0;
  }
  if (v3)
  {
    __n128 v13 = v16 + 2;
    std::__sort3_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(v16, v16 + 1, v16 + 2, v14);
    int v12 = 8;
    int v11 = 0;
    for (uint64_t i = v16 + 3; i != v15; ++i)
    {
      if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v14, (uint64_t)i, (uint64_t)v13))
      {
        __n128 v9 = *(__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&i);
        __n128 v8 = v13;
        __n128 v13 = i;
        do
        {
          BOOL v5 = (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v8);
          __n128 *v13 = *v5;
          __n128 v13 = v8;
          BOOL v7 = 0;
          if (v8 != v16) {
            BOOL v7 = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v14, (uint64_t)&v9, (uint64_t)--v8);
          }
        }
        while (v7);
        __n128 *v13 = v9;
        if (++v11 == 8) {
          return ++i == v15;
        }
      }
      __n128 v13 = i;
    }
    return 1;
  }
  else
  {
    switch(v4)
    {
      case 0:
      case 1:
        BOOL v17 = 1;
        break;
      case 2:
        if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v14, (uint64_t)--v15, (uint64_t)v16))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v16, &v15);
        }
        BOOL v17 = 1;
        break;
      case 3:
        std::__sort3_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(v16, v16 + 1, v15 - 1, v14);
        BOOL v17 = 1;
        break;
      case 4:
        std::__sort4_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(v16, v16 + 1, v16 + 2, v15 - 1, v14);
        BOOL v17 = 1;
        break;
      case 5:
        std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,0>(v16, v16 + 1, v16 + 2, v16 + 3, v15 - 1, v14);
        BOOL v17 = 1;
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v17;
}

double std::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2)
{
  *(void *)&double result = std::swap[abi:ne180100]<AAB::CurveUpdate>(a1, a2).n128_u64[0];
  return result;
}

__n128 std::swap[abi:ne180100]<AAB::CurveUpdate>(__n128 *a1, __n128 *a2)
{
  __n128 v3 = *a1;
  *a1 = *a2;
  __n128 result = v3;
  *a2 = v3;
  return result;
}

double std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, uint64_t a5)
{
  unint64_t v10 = a1;
  __n128 v9 = a2;
  __n128 v8 = a3;
  BOOL v7 = a4;
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a5);
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a5, (uint64_t)v7, (uint64_t)v8))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v8, &v7);
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a5, (uint64_t)v8, (uint64_t)v9))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v9, &v8);
      if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a5, (uint64_t)v9, (uint64_t)v10)) {
        return std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v9);
      }
    }
  }
  return result;
}

double std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, uint64_t a6)
{
  int v12 = a1;
  int v11 = a2;
  unint64_t v10 = a3;
  __n128 v9 = a4;
  __n128 v8 = a5;
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a2, a3, a4, a6);
  if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a6, (uint64_t)v8, (uint64_t)v9))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v9, &v8);
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a6, (uint64_t)v9, (uint64_t)v10))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v10, &v9);
      if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a6, (uint64_t)v10, (uint64_t)v11))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v11, &v10);
        if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a6, (uint64_t)v11, (uint64_t)v12)) {
          return std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v12, &v11);
        }
      }
    }
  }
  return result;
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::next[abi:ne180100]<AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  return a2;
}

__n128 *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate *>(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4)
{
  unint64_t v10 = a1;
  __n128 v9 = a2;
  __n128 v8 = a3;
  uint64_t v7 = a4;
  if (a1 == a2) {
    return (__n128 *)std::_IterOps<std::_ClassicAlgPolicy>::next[abi:ne180100]<AAB::CurveUpdate *>((uint64_t)v9, (uint64_t)v8);
  }
  std::__make_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((uint64_t)v10, (uint64_t)v9, v7);
  uint64_t v6 = v9 - v10;
  for (uint64_t i = v9; i != v8; ++i)
  {
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v7, (uint64_t)i, (uint64_t)v10))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&i, &v10);
      std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((uint64_t)v10, v7, v6, v10);
    }
  }
  std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>((uint64_t)v10, v9, v7);
  return i;
}

void std::__make_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (a2 - a1) / 16;
  if (v4 > 1)
  {
    for (uint64_t i = (v4 - 2) / 2; i >= 0; --i)
      std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(a1, a3, v4, (_OWORD *)(a1 + 16 * i));
  }
}

double std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  uint64_t v10 = a3;
  __n128 v9 = a4;
  uint64_t v8 = ((uint64_t)a4 - a1) / 16;
  if (a3 >= 2 && (v10 - 2) / 2 >= v8)
  {
    uint64_t v8 = 2 * v8 + 1;
    uint64_t v7 = (_OWORD *)(v12 + 16 * v8);
    if (v8 + 1 < v10
      && CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v7, (uint64_t)(v7 + 1)))
    {
      ++v7;
      ++v8;
    }
    if (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v7, (uint64_t)v9))
    {
      long long v6 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v9);
      do
      {
        BOOL v5 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v7);
        *__n128 v9 = *v5;
        __n128 v9 = v7;
        if ((v10 - 2) / 2 < v8) {
          break;
        }
        uint64_t v8 = 2 * v8 + 1;
        uint64_t v7 = (_OWORD *)(v12 + 16 * v8);
        if (v8 + 1 < v10
          && CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v7, (uint64_t)(v7 + 1)))
        {
          ++v7;
          ++v8;
        }
      }
      while (!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v11, (uint64_t)v7, (uint64_t)&v6));
      double result = *(double *)&v6;
      *__n128 v9 = v6;
    }
  }
  return result;
}

void std::__sort_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  BOOL v5 = a2;
  for (uint64_t i = ((uint64_t)a2 - a1) / 16; i > 1; --i)
    std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0,AAB::CurveUpdate *>(a1, v5--, a3, i);
  std::__check_strict_weak_ordering_sorted[abi:ne180100]<AAB::CurveUpdate *,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0>();
}

double std::__pop_heap[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0,AAB::CurveUpdate *>(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a1;
  __n128 v9 = a2;
  if (a4 > 1)
  {
    long long v6 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v10);
    BOOL v5 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v10, a3, a4);
    if (v5 == --v9)
    {
      double result = *(double *)&v6;
      *BOOL v5 = v6;
    }
    else
    {
      *BOOL v5 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v9);
      *__n128 v9 = v6;
      return std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(v10, v5 + 1, a3, ((uint64_t)v5 - v10 + 16) / 16);
    }
  }
  return result;
}

_OWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = a1;
  uint64_t v9 = a2;
  uint64_t v8 = a3;
  uint64_t v7 = (_OWORD *)a1;
  long long v6 = (_OWORD *)a1;
  uint64_t v5 = 0;
  do
  {
    v6 += v5 + 1;
    uint64_t v5 = 2 * v5 + 1;
    if (v5 + 1 < v8
      && CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)v6, (uint64_t)(v6 + 1)))
    {
      ++v6;
      ++v5;
    }
    __n128 v3 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v6);
    *uint64_t v7 = *v3;
    uint64_t v7 = v6;
  }
  while (v5 <= (v8 - 2) / 2);
  return v7;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *>(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a1;
  uint64_t v10 = a2;
  uint64_t v9 = a3;
  uint64_t v8 = a4;
  if (a4 > 1)
  {
    uint64_t v8 = (v8 - 2) / 2;
    uint64_t v7 = (_OWORD *)(v11 + 16 * v8);
    if (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)v7, (uint64_t)--v10))
    {
      *(_OWORD *)long long v6 = *(_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v10);
      do
      {
        uint64_t v5 = (_OWORD *)std::_IterOps<std::_ClassicAlgPolicy>::__iter_move[abi:ne180100]<AAB::CurveUpdate *&,0>((uint64_t)&v7);
        *uint64_t v10 = *v5;
        uint64_t v10 = v7;
        if (!v8) {
          break;
        }
        uint64_t v8 = (v8 - 1) / 2;
        uint64_t v7 = (_OWORD *)(v11 + 16 * v8);
      }
      while (CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(v9, (uint64_t)v7, (uint64_t)v6));
      double result = v6[0];
      *uint64_t v10 = *(_OWORD *)v6;
    }
  }
  return result;
}

BOOL std::__populate_left_bitset[abi:ne180100]<CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>(BOOL result, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = result;
  for (int i = 0; i < 64; ++i)
  {
    double result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a2, v5, a3);
    *a4 |= (unint64_t)!result << i;
    v5 += 16;
  }
  return result;
}

BOOL std::__populate_right_bitset[abi:ne180100]<CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>(BOOL result, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = result;
  for (int i = 0; i < 64; ++i)
  {
    double result = CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a2, v5, a3);
    *a4 |= (unint64_t)result << i;
    v5 -= 16;
  }
  return result;
}

void std::__swap_bitmap_pos[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  uint64_t v11 = a4;
  while (1)
  {
    BOOL v6 = 0;
    if (*v12) {
      BOOL v6 = *v11 != 0;
    }
    if (!v6) {
      break;
    }
    uint64_t v10 = (int)std::__libcpp_ctz[abi:ne180100](*v12);
    uint64_t v4 = std::__libcpp_blsr[abi:ne180100](*v12);
    *uint64_t v12 = v4;
    uint64_t v9 = (int)std::__libcpp_ctz[abi:ne180100](*v11);
    uint64_t v5 = std::__libcpp_blsr[abi:ne180100](*v11);
    unint64_t *v11 = v5;
    uint64_t v8 = (__n128 *)(v14 + 16 * v10);
    uint64_t v7 = (__n128 *)(v13 - 16 * v9);
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v8, &v7);
  }
}

void std::__bitset_partition_partial_blocks[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0 &,AAB::CurveUpdate *,AAB::CurveUpdate>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t *a5, unint64_t *a6)
{
  uint64_t v14 = (*a2 - *a1) / 16 + 1;
  if (*a5 || *a6)
  {
    if (*a5)
    {
      uint64_t v13 = 64;
      uint64_t v12 = (*a2 - *a1) / 16 - 63;
    }
    else
    {
      uint64_t v13 = (*a2 - *a1) / 16 - 63;
      uint64_t v12 = 64;
    }
  }
  else
  {
    uint64_t v13 = v14 / 2;
    uint64_t v12 = v14 - v14 / 2;
  }
  if (!*a5)
  {
    uint64_t v11 = *a1;
    for (int i = 0; i < v13; ++i)
    {
      *a5 |= (unint64_t)!CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a3, v11, a4) << i;
      v11 += 16;
    }
  }
  if (!*a6)
  {
    uint64_t v9 = *a2;
    for (int j = 0; j < v12; ++j)
    {
      *a6 |= (unint64_t)CBBOLTS::serializeBins(std::vector<CBBOLTS::Bin> const&)::$_0::operator()(a3, v9, a4) << j;
      v9 -= 16;
    }
  }
  std::__swap_bitmap_pos[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>(*a1, *a2, a5, a6);
  if (*a5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v13;
  }
  *a1 += 16 * v7;
  if (*a6) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v12;
  }
  *a2 -= 16 * v6;
}

void std::__swap_bitmap_pos_within[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *>(__n128 **a1, __n128 **a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v13 = a1;
  uint64_t v12 = a2;
  uint64_t v11 = a3;
  uint64_t v10 = a4;
  if (*a3)
  {
    while (*v11)
    {
      int v4 = std::__libcpp_clz[abi:ne180100](*v11);
      uint64_t v9 = 63 - v4;
      *v11 &= (1 << (63 - v4)) - 1;
      uint64_t v8 = &(*v13)[v9];
      if (v8 != *v12) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v8, v12);
      }
      --*v12;
    }
    __n128 *v13 = *v12 + 1;
  }
  else if (*v10)
  {
    while (*v10)
    {
      int v5 = std::__libcpp_clz[abi:ne180100](*v10);
      uint64_t v7 = 63 - v5;
      *v10 &= (1 << (63 - v5)) - 1;
      uint64_t v6 = &(*v12)[-v7];
      if (v6 != *v13) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(&v6, v13);
      }
      ++*v13;
    }
  }
}

uint64_t std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &>(void *a1, unsigned char *a2)
{
  std::pair<AAB::CurveUpdate *,BOOL>::pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &,0>((uint64_t)&v3, a1, a2);
  return v3;
}

unint64_t std::__libcpp_ctz[abi:ne180100](unint64_t a1)
{
  return __clz(__rbit64(a1));
}

uint64_t std::__libcpp_blsr[abi:ne180100](uint64_t a1)
{
  return a1 ^ a1 & -a1;
}

double std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(__n128 **a1, __n128 **a2)
{
  return std::iter_swap[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(*a1, *a2);
}

uint64_t std::pair<AAB::CurveUpdate *,BOOL>::pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &,0>(uint64_t a1, void *a2, unsigned char *a3)
{
  return a1;
}

uint64_t std::pair<AAB::CurveUpdate *,BOOL>::pair[abi:ne180100]<AAB::CurveUpdate *&,BOOL &,0>(uint64_t result, void *a2, unsigned char *a3)
{
  *(void *)double result = *a2;
  *(unsigned char *)(result + 8) = *a3 & 1;
  return result;
}

void std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>::__unwrap[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = a1;
  std::__to_address[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,void>(&v1);
}

void std::__to_address[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,void>(uint64_t *a1)
{
}

void std::__to_address_helper<std::__wrap_iter<AAB::CurveUpdate *>,void>::__call[abi:ne180100](uint64_t *a1)
{
}

void std::pointer_traits<std::__wrap_iter<AAB::CurveUpdate *>>::to_address[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = a1;
  std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100]((uint64_t)&v1);
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
}

uint64_t std::vector<AAB::CurveUpdate>::__insert_with_size[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v32 = a2;
  uint64_t v31 = a3;
  uint64_t v30 = a4;
  uint64_t v29 = a1;
  uint64_t v28 = a5;
  uint64_t v27 = a5;
  uint64_t v12 = *a1;
  uint64_t v25 = std::vector<AAB::CurveUpdate>::begin[abi:ne180100](a1);
  uint64_t v26 = v12 + 16 * std::operator-[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate*>((uint64_t)&v32, (uint64_t)&v25);
  if (v28 > 0)
  {
    uint64_t v10 = v28;
    std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
    if (v10 > (*v5 - a1[1]) / 16)
    {
      std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
      uint64_t v14 = v6;
      uint64_t v7 = std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
      unint64_t v8 = std::vector<AAB::CurveUpdate>::__recommend[abi:ne180100](a1, v7 + v28);
      std::__split_buffer<AAB::CurveUpdate>::__split_buffer(v13, v8, (v26 - *a1) / 16, v14);
      std::__split_buffer<AAB::CurveUpdate>::__construct_at_end_with_size<std::__wrap_iter<AAB::CurveUpdate*>>((uint64_t)v13, v31, v27);
      uint64_t v26 = std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(a1, v13, v26);
      std::__split_buffer<AAB::CurveUpdate>::~__split_buffer(v13);
    }
    else
    {
      uint64_t v24 = v28;
      unint64_t v23 = a1[1];
      uint64_t v21 = v31;
      std::next[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,0>();
      uint64_t v22 = v21;
      uint64_t v20 = (a1[1] - v26) / 16;
      if (v28 > v20)
      {
        uint64_t v22 = v31;
        uint64_t v19 = (a1[1] - v26) / 16;
        std::advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,long,long,void>(&v22);
        uint64_t v18 = v22;
        uint64_t v17 = v30;
        std::vector<AAB::CurveUpdate>::__construct_at_end<std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>>((uint64_t)a1, v22, v30, v28 - v19);
        uint64_t v28 = v20;
      }
      if (v28 > 0)
      {
        std::vector<AAB::CurveUpdate>::__move_range((uint64_t)a1, v26, v23, v26 + 16 * v24);
        uint64_t v16 = v31;
        uint64_t v15 = v22;
        std::copy[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(v31, v22, v26);
      }
    }
  }
  return std::vector<AAB::CurveUpdate>::__make_iter[abi:ne180100]((uint64_t)a1, v26);
}

uint64_t std::distance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(uint64_t a1, uint64_t a2)
{
  return std::__distance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(a1, a2);
}

uint64_t std::operator-[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate*>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::__wrap_iter<AAB::CurveUpdate const*>::base[abi:ne180100](a1);
  return (v3 - std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a2)) / 16;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> std::next[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,0>()
{
  std::advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,long,long,void>(&v0);
}

void *std::advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,long,long,void>(void *a1)
{
  std::__convert_to_integral[abi:ne180100]();
  return std::__advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(a1, v1);
}

void *std::vector<AAB::CurveUpdate>::__construct_at_end<std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a2;
  uint64_t v10 = a3;
  uint64_t v9 = a1;
  uint64_t v8 = a4;
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, a4);
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  uint64_t v7 = std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>,AAB::CurveUpdate*>(v4, v11, v10, v7);
  return std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1BA4D9930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15, uint64_t a16, uint64_t a17)
{
}

uint64_t std::vector<AAB::CurveUpdate>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  unint64_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = *(void *)(a1 + 8);
  uint64_t v12 = (v13 - a4) / 16;
  uint64_t v11 = (__n128 *)(a2 + 16 * v12);
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v9, a1, (uint64_t)(a3 - (void)v11) / 16);
  uint64_t v8 = v10;
  while ((unint64_t)v11 < v15)
  {
    std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
    uint64_t v7 = v4;
    std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,void>(v7, v5, v11++);
    v8 += 16;
    uint64_t v10 = v8;
  }
  std::vector<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v9);
  return std::move_backward[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v16, v16 + 16 * v12, v13);
}

uint64_t std::copy[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(a1, a2, a3);
  return v3;
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::__construct_at_end_with_size<std::__wrap_iter<AAB::CurveUpdate*>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = a2;
  v9[4] = a1;
  v9[3] = a3;
  std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](v9, (void *)(a1 + 16), a3);
  while (v9[0] != v9[1])
  {
    uint64_t v7 = std::__split_buffer<AAB::CurveUpdate>::__alloc[abi:ne180100](a1);
    std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
    uint64_t v6 = v3;
    uint64_t v4 = (__n128 *)std::__wrap_iter<AAB::CurveUpdate *>::operator*[abi:ne180100]((uint64_t)&v10);
    std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate&,void>(v7, v6, v4);
    v9[0] += 16;
    std::__wrap_iter<AAB::CurveUpdate *>::operator++[abi:ne180100](&v10);
  }
  return std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100]((uint64_t)v9);
}

uint64_t std::vector<AAB::CurveUpdate>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v21 = a1;
  uint64_t v20 = a2;
  uint64_t v19 = a3;
  std::vector<AAB::CurveUpdate>::__annotate_delete[abi:ne180100]();
  uint64_t v18 = v20[1];
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  uint64_t v11 = v3;
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v16, v19);
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v15, *a1);
  std::reverse_iterator<AAB::CurveUpdate *>::reverse_iterator[abi:ne180100](v14, v20[1]);
  v17[0] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::reverse_iterator<AAB::CurveUpdate*>,std::reverse_iterator<AAB::CurveUpdate*>,AAB::CurveUpdate,void>(v11, v16[0], v16[1], v15[0], v15[1], v14[0], v14[1]);
  v17[1] = v4;
  uint64_t v5 = std::reverse_iterator<AAB::CurveUpdate *>::base[abi:ne180100]((uint64_t)v17);
  v20[1] = v5;
  std::vector<AAB::CurveUpdate>::__alloc[abi:ne180100]();
  uint64_t v7 = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,AAB::CurveUpdate*,AAB::CurveUpdate*,AAB::CurveUpdate,void>(v6, v19, a1[1], v20[2]);
  v20[2] = v7;
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(a1, v20 + 1);
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(a1 + 1, v20 + 2);
  std::vector<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  uint64_t v12 = v8;
  std::__split_buffer<AAB::CurveUpdate>::__end_cap[abi:ne180100]();
  std::swap[abi:ne180100]<AAB::CurveUpdate *>(v12, v9);
  *uint64_t v20 = v20[1];
  std::vector<AAB::CurveUpdate>::size[abi:ne180100](a1);
  std::vector<AAB::CurveUpdate>::__annotate_new[abi:ne180100]();
  return v18;
}

uint64_t std::__wrap_iter<AAB::CurveUpdate const*>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

void *std::__advance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(void *a1, uint64_t a2)
{
  return std::__wrap_iter<AAB::CurveUpdate *>::operator+=[abi:ne180100](a1, a2);
}

void *std::__wrap_iter<AAB::CurveUpdate *>::operator+=[abi:ne180100](void *result, uint64_t a2)
{
  *result += 16 * a2;
  return result;
}

uint64_t std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<AAB::CurveUpdate>,std::__wrap_iter<AAB::CurveUpdate*>,std::__wrap_iter<AAB::CurveUpdate*>,AAB::CurveUpdate*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = std::__unwrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(a2, a3);
  uint64_t v8 = v4;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  uint64_t v6 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<AAB::CurveUpdate>,AAB::CurveUpdate,AAB::CurveUpdate,AAB::CurveUpdate,(void *)0>(a1, v9, v8, v5);
  return std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(a4, v6);
}

uint64_t std::__unwrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  v5[1] = a1;
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(a1);
  uint64_t v6 = v2;
  std::__unwrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>,0>(v7);
  v5[0] = v3;
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v6, v5);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<AAB::CurveUpdate>,AAB::CurveUpdate,AAB::CurveUpdate,AAB::CurveUpdate,(void *)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::copy[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a2, a3, a4);
}

void std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>()
{
}

uint64_t std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<AAB::CurveUpdate *,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(void *a1, void *a2)
{
  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,0>(&v3, a1, a2);
  return v3;
}

void *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,0>(void *result, void *a2, void *a3)
{
  *double result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::copy[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
  return v3;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v13 = (const void *)std::__unwrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2);
  uint64_t v14 = v3;
  uint64_t v7 = v3;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  uint64_t v11 = std::__copy_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>((uint64_t)&v10, v13, v7, v4);
  uint64_t v12 = v5;
  uint64_t v9 = std::__rewrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v17, v11);
  uint64_t v8 = std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v9, &v8);
}

uint64_t std::__unwrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  v6[2] = a1;
  v6[1] = a2;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  v6[0] = v2;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  uint64_t v5 = v3;
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v6, &v5);
}

uint64_t std::__copy_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a2, a3, a4);
}

uint64_t std::__rewrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(a1, a2);
}

uint64_t std::__copy_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(const void *a1, uint64_t a2, char *a3)
{
  v7[1] = a1;
  v7[0] = a2;
  uint64_t v6 = a3;
  uint64_t v5 = (a2 - (uint64_t)a1) / 16;
  std::__constexpr_memmove[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(a3, a1, v5);
  uint64_t v4 = &v6[16 * v5];
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *>(v7, &v4);
}

void *std::__constexpr_memmove[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(void *a1, const void *a2, uint64_t a3)
{
  if (a3) {
    memmove(a1, a2, 16 * (a3 - 1) + 16);
  }
  return a1;
}

uint64_t std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *>(void *a1, void *a2)
{
  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *,0>(&v3, a1, a2);
  return v3;
}

void *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *,0>(void *result, void *a2, void *a3)
{
  *double result = *a2;
  result[1] = *a3;
  return result;
}

void std::__unwrap_iter_impl<AAB::CurveUpdate *,true>::__unwrap[abi:ne180100]()
{
}

uint64_t std::__unwrap_iter_impl<AAB::CurveUpdate *,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__to_address[abi:ne180100]<AAB::CurveUpdate>();
  return a1 + 16 * ((a2 - v2) / 16);
}

uint64_t std::move_backward[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__move_backward[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
  return v3;
}

uint64_t std::__move_backward[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v13 = (const void *)std::__unwrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2);
  uint64_t v14 = v3;
  uint64_t v7 = v3;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  uint64_t v11 = std::__move_backward_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>((uint64_t)&v10, v13, v7, v4);
  uint64_t v12 = v5;
  uint64_t v9 = std::__rewrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v17, v11);
  uint64_t v8 = std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v9, &v8);
}

uint64_t std::__move_backward_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return std::__copy_backward_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a2, a3, a4);
}

uint64_t std::__copy_backward_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(const void *a1, uint64_t a2, uint64_t a3)
{
  v6[1] = a1;
  v6[0] = a2;
  uint64_t v4 = (a2 - (uint64_t)a1) / 16;
  uint64_t v5 = (void *)(a3 - 16 * v4);
  std::__constexpr_memmove[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(v5, a1, v4);
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(v6, &v5);
}

uint64_t std::make_pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&>(void *a1, void *a2)
{
  std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&,0>(&v3, a1, a2);
  return v3;
}

void *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<AAB::CurveUpdate *,AAB::CurveUpdate *>::pair[abi:ne180100]<AAB::CurveUpdate *&,AAB::CurveUpdate *&,0>(void *result, void *a2, void *a3)
{
  *double result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<AAB::CurveUpdate *>,std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  uint64_t v17 = a3;
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v15 = (const void *)std::__unwrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(a1, a2);
  uint64_t v16 = v3;
  uint64_t v7 = v3;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  uint64_t v11 = std::__copy_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>((uint64_t)&v10, v15, v7, v4);
  uint64_t v12 = v5;
  v8[1] = v19;
  uint64_t v9 = std::__rewrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(v19, v11);
  v8[0] = std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(v17, v12);
  return std::make_pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(&v9, v8);
}

uint64_t std::make_pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(void *a1, void *a2)
{
  std::pair<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>::pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(&v3, a1, a2);
  return v3;
}

uint64_t std::__rewrap_range[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>>(a1, a2);
}

void *std::pair<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>::pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *>::pair[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,0>(void *result, void *a2, void *a3)
{
  *double result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__rewrap_iter[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,AAB::CurveUpdate *,std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::__unwrap_iter_impl<std::__wrap_iter<AAB::CurveUpdate *>,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1;
  std::__to_address[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>,void>(&v5);
  return std::__wrap_iter<AAB::CurveUpdate *>::operator+[abi:ne180100](&v5, (a2 - v2) / 16);
}

uint64_t std::__wrap_iter<AAB::CurveUpdate *>::operator+[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  std::__wrap_iter<AAB::CurveUpdate *>::operator+=[abi:ne180100](&v3, a2);
  return v3;
}

void *std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *a1, void *a2, uint64_t a3)
{
  return a1;
}

double std::allocator_traits<std::allocator<AAB::CurveUpdate>>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate&,void>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  *(void *)&double result = std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate&>(a1, a2, a3).n128_u64[0];
  return result;
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](uint64_t a1)
{
  return a1;
}

void *std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *result, void *a2, uint64_t a3)
{
  *double result = *a2;
  result[1] = *a2 + 16 * a3;
  result[2] = a2;
  return result;
}

__n128 std::allocator<AAB::CurveUpdate>::construct[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate&>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t std::__split_buffer<AAB::CurveUpdate>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](uint64_t result)
{
  **(void **)(result + 16) = *(void *)result;
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<AAB::CurveUpdate>,AAB::CurveUpdate*,AAB::CurveUpdate*,AAB::CurveUpdate,void>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::move[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a2, a3, a4);
}

uint64_t std::move[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__move[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
  return v3;
}

uint64_t std::__move[abi:ne180100]<std::_ClassicAlgPolicy,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,AAB::CurveUpdate *,AAB::CurveUpdate *,AAB::CurveUpdate *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v13 = (const void *)std::__unwrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(a1, a2);
  uint64_t v14 = v3;
  uint64_t v7 = v3;
  std::__unwrap_iter[abi:ne180100]<AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>,0>();
  uint64_t v11 = std::__move_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>((uint64_t)&v10, v13, v7, v4);
  uint64_t v12 = v5;
  uint64_t v9 = std::__rewrap_range[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(v17, v11);
  uint64_t v8 = std::__rewrap_iter[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *,std::__unwrap_iter_impl<AAB::CurveUpdate *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(&v9, &v8);
}

uint64_t std::__move_trivial::operator()[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<AAB::CurveUpdate,AAB::CurveUpdate>(a2, a3, a4);
}

uint64_t std::__distance[abi:ne180100]<std::__wrap_iter<AAB::CurveUpdate *>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  uint64_t v3 = a2;
  return std::operator-[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>((uint64_t)&v3, (uint64_t)&v4);
}

uint64_t std::operator-[abi:ne180100]<AAB::CurveUpdate *,AAB::CurveUpdate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a1);
  return (v3 - std::__wrap_iter<AAB::CurveUpdate *>::base[abi:ne180100](a2)) / 16;
}

void *std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(void *a1)
{
  return a1;
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

void *std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(void *result)
{
  *__n128 result = 0;
  return result;
}

uint64_t std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t std::allocator<CBBOLTS::Bin>::allocator[abi:ne180100](uint64_t a1)
{
  return a1;
}

void *std::vector<CBBOLTS::Bin>::__destroy_vector::__destroy_vector[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void std::vector<CBBOLTS::Bin>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  if (**a1)
  {
    std::vector<CBBOLTS::Bin>::__clear[abi:ne180100](*a1);
    std::vector<CBBOLTS::Bin>::__annotate_delete[abi:ne180100]();
    std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
    uint64_t v3 = v1;
    uint64_t v2 = (void *)**a1;
    std::vector<CBBOLTS::Bin>::capacity[abi:ne180100](*a1);
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::deallocate[abi:ne180100](v3, v2);
  }
}

void *std::vector<CBBOLTS::Bin>::__destroy_vector::__destroy_vector[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void std::vector<CBBOLTS::Bin>::__clear[abi:ne180100](uint64_t *a1)
{
}

void std::allocator_traits<std::allocator<CBBOLTS::Bin>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

void std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]()
{
}

{
  std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100]();
}

uint64_t std::vector<CBBOLTS::Bin>::capacity[abi:ne180100](void *a1)
{
  std::vector<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 48;
}

void std::vector<CBBOLTS::Bin>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); a2 != i; i -= 48)
  {
    std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
    uint64_t v4 = v2;
    std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::destroy[abi:ne180100]<CBBOLTS::Bin,void>(v4, v3);
  }
  *(void *)(a1 + 8) = a2;
}

void std::allocator_traits<std::allocator<CBBOLTS::Bin>>::destroy[abi:ne180100]<CBBOLTS::Bin,void>(uint64_t a1, CBBOLTS::Bin *a2)
{
}

void std::allocator<CBBOLTS::Bin>::destroy[abi:ne180100](uint64_t a1, CBBOLTS::Bin *a2)
{
}

void CBBOLTS::Bin::~Bin(CBBOLTS::Bin *this)
{
}

{
  std::list<AAB::CurveUpdate>::~list((uint64_t)this);
}

void std::allocator<CBBOLTS::Bin>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

void std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin>,1,true>::__get[abi:ne180100]();
}

void std::vector<CBBOLTS::Bin>::__end_cap[abi:ne180100]()
{
}

{
  std::__compressed_pair<CBBOLTS::Bin *>::first[abi:ne180100]();
}

void std::__compressed_pair<CBBOLTS::Bin *>::first[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__get[abi:ne180100]();
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__get[abi:ne180100]();
}

uint64_t std::vector<CBBOLTS::Bin>::max_size(uint64_t a1)
{
  v3[1] = a1;
  std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
  v3[0] = std::allocator_traits<std::allocator<CBBOLTS::Bin>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::Bin>,void>();
  uint64_t v2 = std::numeric_limits<long>::max[abi:ne180100]();
  return *std::min[abi:ne180100]<unsigned long>(v3, &v2);
}

void std::vector<CBBOLTS::Bin>::__throw_length_error[abi:ne180100]()
{
}

void **std::__split_buffer<CBBOLTS::Bin>::__split_buffer(void **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1;
}

{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v9;
  void v11[2];
  uint64_t v12;
  unint64_t v13;
  void **v14;
  void **v15;

  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  v11[1] = a4;
  uint64_t v15 = a1;
  v11[0] = 0;
  std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::Bin> &>(a1 + 3, (uint64_t)v11, a4);
  if (v13)
  {
    uint64_t v4 = std::__split_buffer<CBBOLTS::Bin>::__alloc[abi:ne180100]((uint64_t)a1);
    *a1 = std::__allocate_at_least[abi:ne180100]<std::allocator<CBBOLTS::Bin>>(v4, v13);
    uint64_t v13 = v5;
  }
  else
  {
    *a1 = 0;
  }
  uint64_t v6 = (uint64_t)*a1 + 48 * v12;
  a1[2] = (void *)v6;
  a1[1] = (void *)v6;
  uint64_t v9 = (unint64_t)*a1 + 48 * v13;
  std::__split_buffer<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  *uint64_t v7 = v9;
  return v15;
}

void std::vector<CBBOLTS::Bin>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  std::vector<CBBOLTS::Bin>::__annotate_delete[abi:ne180100]();
  std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
  uint64_t v7 = v2;
  std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](v12, a1[1]);
  std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](v11, *a1);
  std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](v10, v14[1]);
  v13[0] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>,std::reverse_iterator<CBBOLTS::Bin*>,std::reverse_iterator<CBBOLTS::Bin*>>(v7, v12[0], v12[1], v11[0], v11[1], v10[0], v10[1]);
  v13[1] = v3;
  uint64_t v4 = std::reverse_iterator<CBBOLTS::Bin *>::base[abi:ne180100]((uint64_t)v13);
  v14[1] = v4;
  std::swap[abi:ne180100]<CBBOLTS::Bin *>(a1, v14 + 1);
  std::swap[abi:ne180100]<CBBOLTS::Bin *>(a1 + 1, v14 + 2);
  std::vector<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  uint64_t v8 = v5;
  std::__split_buffer<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  std::swap[abi:ne180100]<CBBOLTS::Bin *>(v8, v6);
  *uint64_t v14 = v14[1];
  std::vector<CBBOLTS::Bin>::size[abi:ne180100](a1);
  std::vector<CBBOLTS::Bin>::__annotate_new[abi:ne180100]();
}

void **std::__split_buffer<CBBOLTS::Bin>::~__split_buffer(void **a1)
{
  return a1;
}

{
  uint64_t v2;
  void *v3;

  std::__split_buffer<CBBOLTS::Bin>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
  {
    uint64_t v2 = std::__split_buffer<CBBOLTS::Bin>::__alloc[abi:ne180100]((uint64_t)a1);
    uint64_t v3 = *a1;
    std::__split_buffer<CBBOLTS::Bin>::capacity[abi:ne180100](a1);
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::deallocate[abi:ne180100](v2, v3);
  }
  return a1;
}

uint64_t std::allocator_traits<std::allocator<CBBOLTS::Bin>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::Bin>,void>()
{
  return std::allocator<CBBOLTS::Bin>::max_size[abi:ne180100]();
}

uint64_t std::allocator<CBBOLTS::Bin>::max_size[abi:ne180100]()
{
  return 0x555555555555555;
}

void *std::__compressed_pair<CBBOLTS::Bin *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::Bin> &>(void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

{
  std::__compressed_pair_elem<CBBOLTS::Bin *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<CBBOLTS::Bin> &,void>(a1 + 1, a3);
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CBBOLTS::Bin>>(uint64_t a1, unint64_t a2)
{
  return std::allocator<CBBOLTS::Bin>::allocate[abi:ne180100](a1, a2);
}

uint64_t std::__split_buffer<CBBOLTS::Bin>::__alloc[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100](a1 + 24);
}

void std::__split_buffer<CBBOLTS::Bin>::__end_cap[abi:ne180100]()
{
}

{
  std::__compressed_pair<CBBOLTS::Bin *>::first[abi:ne180100]();
}

void *std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin> &,1,false>::__compressed_pair_elem[abi:ne180100]<std::allocator<CBBOLTS::Bin> &,void>(void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void *std::allocator<CBBOLTS::Bin>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<CBBOLTS::Bin>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::Bin>,void>()) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return std::__libcpp_allocate[abi:ne180100](48 * a2);
}

uint64_t std::__compressed_pair<CBBOLTS::Bin *>::second[abi:ne180100](uint64_t a1)
{
  return std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin> &,1,false>::__get[abi:ne180100](a1 + 8);
}

uint64_t std::__compressed_pair_elem<std::allocator<CBBOLTS::Bin> &,1,false>::__get[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>,std::reverse_iterator<CBBOLTS::Bin*>,std::reverse_iterator<CBBOLTS::Bin*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v18[0] = a2;
  v18[1] = a3;
  v17[0] = a4;
  v17[1] = a5;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  uint64_t v15 = a1;
  long long v14 = v16;
  std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::_AllocatorDestroyRangeReverse[abi:ne180100](&v12, a1, (uint64_t)&v14, (uint64_t)&v16);
  std::__make_exception_guard[abi:ne180100]<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>(&v12, v13);
  while (std::operator!=[abi:ne180100]<CBBOLTS::Bin *,CBBOLTS::Bin *>((uint64_t)v18, (uint64_t)v17))
  {
    uint64_t v9 = v15;
    std::__to_address[abi:ne180100]<std::reverse_iterator<CBBOLTS::Bin *>,void>((uint64_t)&v16);
    uint64_t v10 = v7;
    uint64_t v11 = std::reverse_iterator<CBBOLTS::Bin *>::operator*[abi:ne180100]((uint64_t)v18);
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::Bin,void>(v9, v10, v11);
    std::reverse_iterator<CBBOLTS::Bin *>::operator++[abi:ne180100]((uint64_t)v18);
    std::reverse_iterator<CBBOLTS::Bin *>::operator++[abi:ne180100]((uint64_t)&v16);
  }
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__complete[abi:ne180100]((uint64_t)v13);
  long long v19 = v16;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v19;
}

void *std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t *std::swap[abi:ne180100]<CBBOLTS::Bin *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *__n128 result = *a2;
  *a2 = v2;
  return result;
}

__n128 *std::__make_exception_guard[abi:ne180100]<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>@<X0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  uint64_t v6 = a2;
  uint64_t v5 = a1;
  __n128 v3 = *a1;
  unint64_t v4 = a1[1].n128_u64[0];
  return std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__exception_guard_exceptions[abi:ne180100](a2, &v3);
}

void *std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::_AllocatorDestroyRangeReverse[abi:ne180100](void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1;
}

BOOL std::operator!=[abi:ne180100]<CBBOLTS::Bin *,CBBOLTS::Bin *>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = std::reverse_iterator<CBBOLTS::Bin *>::base[abi:ne180100](a1);
  return v3 != std::reverse_iterator<CBBOLTS::Bin *>::base[abi:ne180100](a2);
}

uint64_t std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::Bin,void>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::allocator<CBBOLTS::Bin>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::Bin>(a1, a2, a3);
}

void std::__to_address[abi:ne180100]<std::reverse_iterator<CBBOLTS::Bin *>,void>(uint64_t a1)
{
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::operator*[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 8) - 48;
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::operator++[abi:ne180100](uint64_t result)
{
  *(void *)(result + 8) -= 48;
  return result;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__complete[abi:ne180100](uint64_t result)
{
  *(unsigned char *)(result + 24) = 1;
  return result;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  return a1;
}

{
  if ((*(unsigned char *)(a1 + 24) & 1) == 0) {
    std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

__n128 *std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__exception_guard_exceptions[abi:ne180100](__n128 *a1, __n128 *a2)
{
  return a1;
}

__n128 std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>>::__exception_guard_exceptions[abi:ne180100](__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a1[1].n128_u8[8] = 0;
  return result;
}

void *std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::_AllocatorDestroyRangeReverse[abi:ne180100](void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *__n128 result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

uint64_t std::allocator<CBBOLTS::Bin>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::Bin>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CBBOLTS::Bin::Bin(a2, a3);
}

uint64_t CBBOLTS::Bin::Bin(uint64_t a1, uint64_t a2)
{
  return a1;
}

__n128 CBBOLTS::Bin::Bin(uint64_t a1, uint64_t a2)
{
  std::list<AAB::CurveUpdate>::list((void *)a1, (uint64_t *)a2);
  __n128 result = *(__n128 *)(a2 + 24);
  *(__n128 *)(a1 + 24) = result;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  return result;
}

void *std::list<AAB::CurveUpdate>::list(void *a1, uint64_t *a2)
{
  return a1;
}

{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  void *v8;

  uint64_t v8 = a1;
  uint64_t v7 = a2;
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  std::__list_imp<AAB::CurveUpdate>::__list_imp(a1, v2);
  uint64_t v5 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v6, &v5);
  std::list<AAB::CurveUpdate>::splice((uint64_t)a1, v6, v7);
  return a1;
}

void std::list<AAB::CurveUpdate>::splice(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!std::list<AAB::CurveUpdate>::empty[abi:ne180100]())
  {
    uint64_t v8 = (void *)a3[1];
    uint64_t v7 = *a3;
    std::__list_imp<AAB::CurveUpdate>::__unlink_nodes((uint64_t)v8, *a3);
    std::list<AAB::CurveUpdate>::__link_nodes(a2, v8, v7);
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    uint64_t v6 = *v3;
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *v4 += v6;
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *uint64_t v5 = 0;
  }
}

void *std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](void *a1, void *a2)
{
  return a1;
}

uint64_t std::list<AAB::CurveUpdate>::__link_nodes(uint64_t result, void *a2, uint64_t a3)
{
  *(void *)(*(void *)result + 8) = a2;
  *a2 = *(void *)result;
  *(void *)__n128 result = a3;
  *(void *)(a3 + 8) = result;
  return result;
}

void *std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](void *result, void *a2)
{
  *__n128 result = *a2;
  return result;
}

void std::__to_address_helper<std::reverse_iterator<CBBOLTS::Bin *>,void>::__call[abi:ne180100](uint64_t a1)
{
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::operator->[abi:ne180100](uint64_t a1)
{
  return std::reverse_iterator<CBBOLTS::Bin *>::operator*[abi:ne180100](a1);
}

BOOL std::_AllocatorDestroyRangeReverse<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<CBBOLTS::Bin*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)a1;
  std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100]((uint64_t)v5, **(void **)(a1 + 16), *(void *)(*(void *)(a1 + 16) + 8));
  std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100]((uint64_t)v4, **(void **)(a1 + 8), *(void *)(*(void *)(a1 + 8) + 8));
  return std::__allocator_destroy[abi:ne180100]<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin*>>,std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin*>>>(v3, (uint64_t)v5, (uint64_t)v4);
}

BOOL std::__allocator_destroy[abi:ne180100]<std::allocator<CBBOLTS::Bin>,std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin*>>,std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  while (1)
  {
    BOOL result = std::operator!=[abi:ne180100]<std::reverse_iterator<CBBOLTS::Bin *>,std::reverse_iterator<CBBOLTS::Bin *>>(a2, a3);
    if (!result) {
      break;
    }
    std::__to_address[abi:ne180100]<std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>,void>(a2);
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::destroy[abi:ne180100]<CBBOLTS::Bin,void>(a1, v4);
    std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator++[abi:ne180100](a2);
  }
  return result;
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100](uint64_t a1, unint64_t a2, unint64_t a3)
{
  return a1;
}

BOOL std::operator!=[abi:ne180100]<std::reverse_iterator<CBBOLTS::Bin *>,std::reverse_iterator<CBBOLTS::Bin *>>(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  v6[0] = std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::base[abi:ne180100](a1);
  v6[1] = v2;
  v5[0] = std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::base[abi:ne180100](v7);
  v5[1] = v3;
  return std::operator!=[abi:ne180100]<CBBOLTS::Bin *,CBBOLTS::Bin *>((uint64_t)v6, (uint64_t)v5);
}

void std::__to_address[abi:ne180100]<std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>,void>(uint64_t a1)
{
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator++[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::base[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void std::__to_address_helper<std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>,void>::__call[abi:ne180100](uint64_t a1)
{
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator->[abi:ne180100](uint64_t a1)
{
  return std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator*[abi:ne180100](a1);
}

uint64_t std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::operator*[abi:ne180100](uint64_t a1)
{
  uint64_t v4 = a1;
  long long v3 = *(_OWORD *)(a1 + 24);
  uint64_t v1 = std::reverse_iterator<CBBOLTS::Bin *>::operator--[abi:ne180100]((uint64_t)&v3);
  return std::reverse_iterator<CBBOLTS::Bin *>::operator*[abi:ne180100](v1);
}

uint64_t std::reverse_iterator<CBBOLTS::Bin *>::operator--[abi:ne180100](uint64_t result)
{
  *(void *)(result + 8) += 48;
  return result;
}

__n128 std::reverse_iterator<std::reverse_iterator<CBBOLTS::Bin *>>::reverse_iterator[abi:ne180100](uint64_t a1, unint64_t a2, unint64_t a3)
{
  v4.n128_u64[0] = a2;
  v4.n128_u64[1] = a3;
  *(__n128 *)(a1 + 8) = v4;
  __n128 result = v4;
  *(__n128 *)(a1 + 24) = v4;
  return result;
}

void *std::reverse_iterator<CBBOLTS::Bin *>::reverse_iterator[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  result[1] = a2;
  return result;
}

void std::__split_buffer<CBBOLTS::Bin>::clear[abi:ne180100](uint64_t a1)
{
}

uint64_t std::__split_buffer<CBBOLTS::Bin>::capacity[abi:ne180100](void *a1)
{
  std::__split_buffer<CBBOLTS::Bin>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 48;
}

void std::__split_buffer<CBBOLTS::Bin>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
}

{
  CBBOLTS::Bin *v2;
  uint64_t v3;

  while (a2 != *(void *)(a1 + 16))
  {
    long long v3 = std::__split_buffer<CBBOLTS::Bin>::__alloc[abi:ne180100](a1);
    *(void *)(a1 + 16) -= 48;
    std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
    std::allocator_traits<std::allocator<CBBOLTS::Bin>>::destroy[abi:ne180100]<CBBOLTS::Bin,void>(v3, v2);
  }
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::__make_iter[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__wrap_iter<CBBOLTS::BinConfiguration const*>::__wrap_iter[abi:ne180100](&v3, a2);
  return v3;
}

void *std::__wrap_iter<CBBOLTS::BinConfiguration const*>::__wrap_iter[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void *std::__wrap_iter<CBBOLTS::BinConfiguration const*>::__wrap_iter[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void *std::vector<CBBOLTS::Bin>::__construct_one_at_end[abi:ne180100]<CBBOLTS::BinConfiguration const&>(uint64_t a1, __n128 *a2)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  std::vector<CBBOLTS::Bin>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, 1);
  std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
  uint64_t v5 = v2;
  std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
  std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&,void>(v5, v3, v8);
  v7 += 48;
  return std::vector<CBBOLTS::Bin>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1BA4DC8E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
}

uint64_t std::vector<CBBOLTS::Bin>::__emplace_back_slow_path<CBBOLTS::BinConfiguration const&>(uint64_t *a1, __n128 *a2)
{
  uint64_t v15 = a1;
  long long v14 = a2;
  std::vector<CBBOLTS::Bin>::__alloc[abi:ne180100]();
  uint64_t v13 = v2;
  uint64_t v3 = std::vector<CBBOLTS::Bin>::size[abi:ne180100](a1);
  unint64_t v9 = std::vector<CBBOLTS::Bin>::__recommend[abi:ne180100](a1, v3 + 1);
  uint64_t v4 = std::vector<CBBOLTS::Bin>::size[abi:ne180100](a1);
  std::__split_buffer<CBBOLTS::Bin>::__split_buffer(v11, v9, v4, v13);
  uint64_t v10 = v13;
  std::__to_address[abi:ne180100]<CBBOLTS::Bin>();
  std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&,void>(v10, v5, v14);
  v12 += 48;
  std::vector<CBBOLTS::Bin>::__swap_out_circular_buffer(a1, v11);
  uint64_t v7 = a1[1];
  std::__split_buffer<CBBOLTS::Bin>::~__split_buffer(v11);
  return v7;
}

void sub_1BA4DC9D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, void *a16)
{
}

void *std::vector<CBBOLTS::Bin>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t std::allocator_traits<std::allocator<CBBOLTS::Bin>>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&,void>(uint64_t a1, uint64_t a2, __n128 *a3)
{
  return std::allocator<CBBOLTS::Bin>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&>(a1, a2, a3);
}

void *std::vector<CBBOLTS::Bin>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](void *a1)
{
  return a1;
}

void *std::vector<CBBOLTS::Bin>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *result, uint64_t a2, uint64_t a3)
{
  *__n128 result = a2;
  result[1] = *(void *)(a2 + 8);
  result[2] = *(void *)(a2 + 8) + 48 * a3;
  return result;
}

uint64_t std::allocator<CBBOLTS::Bin>::construct[abi:ne180100]<CBBOLTS::Bin,CBBOLTS::BinConfiguration const&>(uint64_t a1, uint64_t a2, __n128 *a3)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  uint64_t v6 = a3;
  __n128 v4 = *a3;
  unint64_t v5 = a3[1].n128_u64[0];
  return CBBOLTS::Bin::Bin(a2, &v4);
}

uint64_t CBBOLTS::Bin::Bin(uint64_t a1, __n128 *a2)
{
  return a1;
}

__n128 CBBOLTS::Bin::Bin(uint64_t a1, __n128 *a2)
{
  std::list<AAB::CurveUpdate>::list[abi:ne180100]((void *)a1);
  __n128 result = *a2;
  *(__n128 *)(a1 + 24) = *a2;
  *(void *)(a1 + 40) = a2[1].n128_u64[0];
  return result;
}

void *std::vector<CBBOLTS::Bin>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](void *result)
{
  *(void *)(*result + 8) = result[1];
  return result;
}

unint64_t std::vector<CBBOLTS::Bin>::__recommend[abi:ne180100](void *a1, uint64_t a2)
{
  v7[1] = a1;
  v7[0] = a2;
  unint64_t v6 = std::vector<CBBOLTS::Bin>::max_size((uint64_t)a1);
  if (v7[0] > v6) {
    std::vector<CBBOLTS::Bin>::__throw_length_error[abi:ne180100]();
  }
  unint64_t v5 = std::vector<CBBOLTS::Bin>::capacity[abi:ne180100](a1);
  if (v5 >= v6 / 2) {
    return v6;
  }
  uint64_t v4 = 2 * v5;
  return *std::max[abi:ne180100]<unsigned long>(&v4, v7);
}

void std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]()
{
}

{
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::second[abi:ne180100]();
}

void *std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::allocator<CBBOLTS::BinConfiguration>>(void *a1)
{
  return a1;
}

{
  std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__compressed_pair_elem[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,void>();
  return a1;
}

void std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]()
{
}

{
  std::__compressed_pair<CBBOLTS::BinConfiguration *>::first[abi:ne180100]();
}

void std::__compressed_pair<CBBOLTS::BinConfiguration *>::second[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__get[abi:ne180100]();
}

void *std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(void *result)
{
  *__n128 result = 0;
  return result;
}

void std::__compressed_pair<CBBOLTS::BinConfiguration *>::first[abi:ne180100]()
{
}

{
  std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__get[abi:ne180100]();
}

void *std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::operator()[abi:ne180100](uint64_t **a1)
{
  if (**a1)
  {
    std::vector<CBBOLTS::BinConfiguration>::__clear[abi:ne180100](*a1);
    std::vector<CBBOLTS::BinConfiguration>::__annotate_delete[abi:ne180100]();
    std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
    uint64_t v3 = v1;
    uint64_t v2 = (void *)**a1;
    std::vector<CBBOLTS::BinConfiguration>::capacity[abi:ne180100](*a1);
    std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::deallocate[abi:ne180100](v3, v2);
  }
}

void *std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::__destroy_vector[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void std::vector<CBBOLTS::BinConfiguration>::__clear[abi:ne180100](uint64_t *a1)
{
}

void std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::capacity[abi:ne180100](void *a1)
{
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  return (*v1 - *a1) / 24;
}

void std::vector<CBBOLTS::BinConfiguration>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); a2 != i; i -= 24)
  {
    std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
    std::__to_address[abi:ne180100]<CBBOLTS::BinConfiguration>();
    std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::destroy[abi:ne180100]<CBBOLTS::BinConfiguration,void>();
  }
  *(void *)(a1 + 8) = a2;
}

void std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::destroy[abi:ne180100]<CBBOLTS::BinConfiguration,void>()
{
}

void std::allocator<CBBOLTS::BinConfiguration>::deallocate[abi:ne180100](uint64_t a1, void *a2)
{
}

void *std::__compressed_pair<CBBOLTS::BinConfiguration *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(void *a1)
{
  return a1;
}

{
  std::__compressed_pair_elem<CBBOLTS::BinConfiguration *,0,false>::__compressed_pair_elem[abi:ne180100]<decltype(nullptr),void>(a1);
  std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__compressed_pair_elem[abi:ne180100]((uint64_t)a1);
  return a1;
}

uint64_t std::__make_exception_guard[abi:ne180100]<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](a2, a1);
}

uint64_t std::initializer_list<CBBOLTS::BinConfiguration>::size[abi:ne180100](uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void std::vector<CBBOLTS::BinConfiguration>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 > std::vector<CBBOLTS::BinConfiguration>::max_size((uint64_t)a1)) {
    std::vector<CBBOLTS::BinConfiguration>::__throw_length_error[abi:ne180100]();
  }
  std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
  uint64_t v7 = std::__allocate_at_least[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>>(v2, a2);
  *a1 = v7;
  a1[1] = v7;
  uint64_t v5 = *a1 + 24 * v3;
  std::vector<CBBOLTS::BinConfiguration>::__end_cap[abi:ne180100]();
  *uint64_t v4 = v5;
  std::vector<CBBOLTS::BinConfiguration>::__annotate_new[abi:ne180100]();
}

void *std::vector<CBBOLTS::BinConfiguration>::__construct_at_end<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a1;
  uint64_t v10 = a2;
  uint64_t v9 = a3;
  uint64_t v8 = a4;
  std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v6, a1, a4);
  std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
  uint64_t v7 = std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(v4, v10, v9, v7);
  return std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v6);
}

void sub_1BA4DD54C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object, uint64_t a15)
{
}

uint64_t std::initializer_list<CBBOLTS::BinConfiguration>::begin[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::initializer_list<CBBOLTS::BinConfiguration>::end[abi:ne180100](void *a1)
{
  return *a1 + 24 * a1[1];
}

uint64_t std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__complete[abi:ne180100](uint64_t result)
{
  *(unsigned char *)(result + 8) = 1;
  return result;
}

uint64_t std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  return a1;
}

{
  if ((*(unsigned char *)(a1 + 8) & 1) == 0) {
    std::vector<CBBOLTS::BinConfiguration>::__destroy_vector::operator()[abi:ne180100]((uint64_t **)a1);
  }
  return a1;
}

uint64_t std::__compressed_pair_elem<std::allocator<CBBOLTS::BinConfiguration>,1,true>::__compressed_pair_elem[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t std::allocator<CBBOLTS::BinConfiguration>::allocator[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t std::__exception_guard_exceptions<std::vector<CBBOLTS::BinConfiguration>::__destroy_vector>::__exception_guard_exceptions[abi:ne180100](uint64_t result, uint64_t a2)
{
  *(void *)__n128 result = a2;
  *(unsigned char *)(result + 8) = 0;
  return result;
}

uint64_t std::vector<CBBOLTS::BinConfiguration>::max_size(uint64_t a1)
{
  v3[1] = a1;
  std::vector<CBBOLTS::BinConfiguration>::__alloc[abi:ne180100]();
  v3[0] = std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,void>();
  uint64_t v2 = std::numeric_limits<long>::max[abi:ne180100]();
  return *std::min[abi:ne180100]<unsigned long>(v3, &v2);
}

void std::vector<CBBOLTS::BinConfiguration>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>>(uint64_t a1, unint64_t a2)
{
  return std::allocator<CBBOLTS::BinConfiguration>::allocate[abi:ne180100](a1, a2);
}

uint64_t std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,void>()
{
  return std::allocator<CBBOLTS::BinConfiguration>::max_size[abi:ne180100]();
}

uint64_t std::allocator<CBBOLTS::BinConfiguration>::max_size[abi:ne180100]()
{
  return 0xAAAAAAAAAAAAAAALL;
}

void *std::allocator<CBBOLTS::BinConfiguration>::allocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 > std::allocator_traits<std::allocator<CBBOLTS::BinConfiguration>>::max_size[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,void>()) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return std::__libcpp_allocate[abi:ne180100](24 * a2);
}

void *std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t std::__uninitialized_allocator_copy[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = std::__unwrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(a2, a3);
  uint64_t v8 = v4;
  std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>,0>();
  uint64_t v6 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration,CBBOLTS::BinConfiguration,(void *)0>(a1, v9, v8, v5);
  return std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>>(a4, v6);
}

void *std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](void *a1)
{
  return a1;
}

void *std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *result, uint64_t a2, uint64_t a3)
{
  *__n128 result = a2;
  result[1] = *(void *)(a2 + 8);
  result[2] = *(void *)(a2 + 8) + 24 * a3;
  return result;
}

uint64_t std::__unwrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2)
{
  void v6[2] = a1;
  v6[1] = a2;
  std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>,0>();
  v6[0] = v2;
  std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>,0>();
  uint64_t v5 = v3;
  return std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(v6, &v5);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CBBOLTS::BinConfiguration>,CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration,CBBOLTS::BinConfiguration,(void *)0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return std::copy[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(a2, a3, a4);
}

void std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>,0>()
{
}

uint64_t std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(void *a1, void *a2)
{
  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,0>(&v3, a1, a2);
  return v3;
}

void std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>,0>()
{
}

void *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,0>(void *result, void *a2, void *a3)
{
  *__n128 result = *a2;
  result[1] = *a3;
  return result;
}

void std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>::__unwrap[abi:ne180100]()
{
}

uint64_t std::copy[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(a1, a2, a3);
  return v3;
}

uint64_t std::__copy[abi:ne180100]<std::_ClassicAlgPolicy,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(a1, a2, a3);
}

uint64_t std::__dispatch_copy_or_move[abi:ne180100]<std::_ClassicAlgPolicy,std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(a1, a2, a3);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v13 = (const void *)std::__unwrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(a1, a2);
  uint64_t v14 = v3;
  uint64_t v7 = v3;
  std::__unwrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>,0>();
  uint64_t v11 = std::__copy_trivial::operator()[abi:ne180100]<CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration,0>((uint64_t)&v10, v13, v7, v4);
  uint64_t v12 = v5;
  uint64_t v9 = std::__rewrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(v17, v11);
  uint64_t v8 = std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration *,CBBOLTS::BinConfiguration *,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>>(v15, v12);
  return std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(&v9, &v8);
}

uint64_t std::__copy_trivial::operator()[abi:ne180100]<CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration,0>(uint64_t a1, const void *a2, uint64_t a3, char *a4)
{
  return std::__copy_trivial_impl[abi:ne180100]<CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration>(a2, a3, a4);
}

uint64_t std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>(void *a1, void *a2)
{
  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(&v3, a1, a2);
  return v3;
}

uint64_t std::__rewrap_range[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*>(uint64_t a1, uint64_t a2)
{
  return std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>>(a1, a2);
}

uint64_t std::__copy_trivial_impl[abi:ne180100]<CBBOLTS::BinConfiguration const,CBBOLTS::BinConfiguration>(const void *a1, uint64_t a2, char *a3)
{
  v7[1] = a1;
  v7[0] = a2;
  uint64_t v6 = a3;
  uint64_t v5 = (a2 - (uint64_t)a1) / 24;
  std::__constexpr_memmove[abi:ne180100]<CBBOLTS::BinConfiguration,CBBOLTS::BinConfiguration const,0>(a3, a1, v5);
  uint64_t v4 = &v6[24 * v5];
  return std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*>(v7, &v4);
}

void *std::__constexpr_memmove[abi:ne180100]<CBBOLTS::BinConfiguration,CBBOLTS::BinConfiguration const,0>(void *a1, const void *a2, uint64_t a3)
{
  if (a3) {
    memmove(a1, a2, 24 * (a3 - 1) + 24);
  }
  return a1;
}

uint64_t std::make_pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*>(void *a1, void *a2)
{
  std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*,0>(&v3, a1, a2);
  return v3;
}

void *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*&,CBBOLTS::BinConfiguration*,0>(void *result, void *a2, void *a3)
{
  *__n128 result = *a2;
  result[1] = *a3;
  return result;
}

void *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(void *a1, void *a2, void *a3)
{
  return a1;
}

void *std::pair<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*>::pair[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration*,0>(void *result, void *a2, void *a3)
{
  *__n128 result = *a2;
  result[1] = *a3;
  return result;
}

uint64_t std::__rewrap_iter[abi:ne180100]<CBBOLTS::BinConfiguration const*,CBBOLTS::BinConfiguration const*,std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>>(uint64_t a1, uint64_t a2)
{
  return std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>::__rewrap[abi:ne180100](a1, a2);
}

uint64_t std::__unwrap_iter_impl<CBBOLTS::BinConfiguration const*,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__to_address[abi:ne180100]<CBBOLTS::BinConfiguration const>();
  return a1 + 24 * ((a2 - v2) / 24);
}

void std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>::__unwrap[abi:ne180100]()
{
}

uint64_t std::__unwrap_iter_impl<CBBOLTS::BinConfiguration *,true>::__rewrap[abi:ne180100](uint64_t a1, uint64_t a2)
{
  std::__to_address[abi:ne180100]<CBBOLTS::BinConfiguration>();
  return a1 + 24 * ((a2 - v2) / 24);
}

void *std::vector<CBBOLTS::BinConfiguration>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](void *result)
{
  *(void *)(*result + 8) = result[1];
  return result;
}

void *std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](void *a1, uint64_t a2)
{
  return a1;
}

void *std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](void *result, uint64_t a2)
{
  *__n128 result = a2;
  return result;
}

void std::__list_imp<AAB::CurveUpdate>::__copy_assign_alloc[abi:ne180100]()
{
}

void *std::list<AAB::CurveUpdate>::assign<std::__list_const_iterator<AAB::CurveUpdate,void *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return std::list<AAB::CurveUpdate>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<AAB::CurveUpdate,void *>,std::__list_const_iterator<AAB::CurveUpdate,void *>>(a1, a2, a3);
}

void *std::list<AAB::CurveUpdate>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<AAB::CurveUpdate,void *>,std::__list_const_iterator<AAB::CurveUpdate,void *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  v11[1] = a1;
  v11[0] = std::list<AAB::CurveUpdate>::begin[abi:ne180100](a1);
  uint64_t v10 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (1)
  {
    BOOL v5 = 0;
    if (std::operator!=[abi:ne180100](&v13, &v12)) {
      BOOL v5 = std::operator!=[abi:ne180100](v11, &v10);
    }
    if (!v5) {
      break;
    }
    uint64_t v4 = (_OWORD *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    *(_OWORD *)std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]() = *v4;
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v13);
    std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)v11);
  }
  if (std::operator==[abi:ne180100](v11, &v10))
  {
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v9, &v10);
    void v8[3] = v13;
    void v8[2] = v12;
    __n128 result = std::list<AAB::CurveUpdate>::__insert_with_sentinel[abi:ne180100]<std::__list_const_iterator<AAB::CurveUpdate,void *>,std::__list_const_iterator<AAB::CurveUpdate,void *>>(a1, v9, v13, v12);
    v8[1] = (uint64_t)result;
  }
  else
  {
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](v8, v11);
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v7, &v10);
    return (void *)std::list<AAB::CurveUpdate>::erase(a1, v8[0], v7);
  }
  return result;
}

void *std::list<AAB::CurveUpdate>::__insert_with_sentinel[abi:ne180100]<std::__list_const_iterator<AAB::CurveUpdate,void *>,std::__list_const_iterator<AAB::CurveUpdate,void *>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = a2;
  uint64_t v18 = a3;
  uint64_t v17 = a4;
  uint64_t v16 = a1;
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v20, a2);
  if (std::operator!=[abi:ne180100](&v18, &v17))
  {
    uint64_t v4 = (__n128 *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
    v14[1] = std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(a1, 0, 0, v4);
    uint64_t v15 = 1;
    std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
    std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](v14, v5);
    uint64_t v20 = (void *)v14[0];
    uint64_t v13 = v14[0];
    std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v18);
    while (std::operator!=[abi:ne180100](&v18, &v17))
    {
      uint64_t v11 = v13;
      uint64_t v6 = (__n128 *)std::__list_const_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]();
      std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(a1, v11, 0, v6);
      std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
      *(void *)(v13 + 8) = v7;
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v18);
      std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v13);
      ++v15;
    }
    std::list<AAB::CurveUpdate>::__link_nodes(v19, v20, v13);
    uint64_t v10 = v15;
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *v8 += v10;
  }
  return v20;
}

uint64_t std::list<AAB::CurveUpdate>::erase(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v8 = a2;
  uint64_t v7 = a3;
  if (std::operator!=[abi:ne180100](&v8, &v7))
  {
    std::__list_imp<AAB::CurveUpdate>::__unlink_nodes(v8, *v7);
    while (std::operator!=[abi:ne180100](&v8, &v7))
    {
      std::__list_const_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v8);
      std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
      --*v3;
      std::__list_node_base<AAB::CurveUpdate,void *>::__as_node[abi:ne180100]();
      std::__list_imp<AAB::CurveUpdate>::__delete_node[abi:ne180100]<>(a1, v4);
    }
  }
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v9, (uint64_t)v7);
  return v9;
}

void *std::initializer_list<AAB::CurveUpdate>::initializer_list[abi:ne180100](void *result)
{
  *__n128 result = 0;
  result[1] = 0;
  return result;
}

void *std::list<AAB::CurveUpdate>::assign<AAB::CurveUpdate const*>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  return std::list<AAB::CurveUpdate>::__assign_with_sentinel[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate const*>(a1, a2, a3);
}

uint64_t std::initializer_list<AAB::CurveUpdate>::begin[abi:ne180100](uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::initializer_list<AAB::CurveUpdate>::end[abi:ne180100](void *a1)
{
  return *a1 + 16 * a1[1];
}

void *std::list<AAB::CurveUpdate>::__assign_with_sentinel[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate const*>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  uint64_t v11 = std::list<AAB::CurveUpdate>::begin[abi:ne180100](a1);
  uint64_t v10 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  while (1)
  {
    BOOL v5 = 0;
    if (v13 != v12) {
      BOOL v5 = std::operator!=[abi:ne180100](&v11, &v10);
    }
    if (!v5) {
      break;
    }
    uint64_t v4 = v13;
    *(__n128 *)std::__list_iterator<AAB::CurveUpdate,void *>::operator*[abi:ne180100]() = *v4;
    ++v13;
    std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v11);
  }
  if (std::operator==[abi:ne180100](&v11, &v10))
  {
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v9, &v10);
    __n128 result = std::list<AAB::CurveUpdate>::__insert_with_sentinel[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate const*>(a1, v9, v13, v12);
    v8[1] = (uint64_t)result;
  }
  else
  {
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](v8, &v11);
    std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v7, &v10);
    return (void *)std::list<AAB::CurveUpdate>::erase(a1, v8[0], v7);
  }
  return result;
}

void *std::list<AAB::CurveUpdate>::__insert_with_sentinel[abi:ne180100]<AAB::CurveUpdate const*,AAB::CurveUpdate const*>(uint64_t a1, uint64_t a2, __n128 *a3, __n128 *a4)
{
  uint64_t v16 = a2;
  uint64_t v15 = a1;
  uint64_t v14 = a3;
  uint64_t v13 = a4;
  std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](&v17, a2);
  if (v14 != v13)
  {
    v11[1] = std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(a1, 0, 0, v14);
    uint64_t v12 = 1;
    std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
    std::__list_iterator<AAB::CurveUpdate,void *>::__list_iterator[abi:ne180100](v11, v4);
    uint64_t v17 = (void *)v11[0];
    uint64_t v10 = v11[0];
    ++v14;
    while (v14 != v13)
    {
      std::__list_imp<AAB::CurveUpdate>::__create_node[abi:ne180100]<AAB::CurveUpdate const&>(a1, v10, 0, v14);
      std::__list_node<AAB::CurveUpdate,void *>::__as_link[abi:ne180100]();
      *(void *)(v10 + 8) = v5;
      ++v14;
      std::__list_iterator<AAB::CurveUpdate,void *>::operator++[abi:ne180100]((uint64_t)&v10);
      ++v12;
    }
    std::list<AAB::CurveUpdate>::__link_nodes(v16, v17, v10);
    uint64_t v8 = v12;
    std::__list_imp<AAB::CurveUpdate>::__sz[abi:ne180100]();
    *v6 += v8;
  }
  return v17;
}

void sub_1BA4DEE1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id obj, int a12, int a13, _Unwind_Exception *exception_object)
{
}

void sub_1BA4DEF0C(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
  *(void *)(v9 - 24) = a1;
  *(_DWORD *)(v9 - 28) = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v9 - 24));
}

void sub_1BA4DFAF8()
{
  _Unwind_Resume(v0);
}

void sub_1BA4DFD58()
{
  _Unwind_Resume(v0);
}

void sub_1BA4DFFC0()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_2_8_0_4_0(uint64_t result, uint64_t a2, int a3)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 1) = 2;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 4;
  *(_DWORD *)(result + 14) = a3;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_64_8_64_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1) = 4;
  *(unsigned char *)(result + 2) = 64;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 64;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 8;
  *(void *)(result + 24) = a4;
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 33) = 8;
  *(void *)(result + 34) = a5;
  return result;
}

float BULuminanceToPerceptual(float a1, float a2, float a3)
{
  float v4 = logf(fmaxf(a1, a2) / a3);
  return (float)(v4 / logf(a3 / a2)) + 1.0;
}

float BUPerceptualToLuminance(float a1, float a2, float a3)
{
  return a3 * powf(a3 / a2, a1 - 1.0);
}

float BUIlluminanceToLuminance(uint64_t a1, float a2)
{
  float v5 = 0.0;
  if (*(int *)(a1 + 160) <= 1)
  {
    if (*(_DWORD *)(a1 + 160) == 1) {
      float v3 = *(float *)(a1 + 80);
    }
    else {
      float v3 = 0.0;
    }
    float v5 = v3;
  }
  else
  {
    for (int i = 0; i < *(_DWORD *)(a1 + 160) - 1; ++i)
    {
      if (a2 <= *(float *)(a1 + 4 * (i + 1)))
      {
        if ((float)(*(float *)(a1 + 4 * (i + 1)) - *(float *)(a1 + 4 * i)) != 0.0) {
          float v5 = *(float *)(a1 + 80 + 4 * i)
        }
             + (float)((float)((float)(*(float *)(a1 + 80 + 4 * (i + 1)) - *(float *)(a1 + 80 + 4 * i))
                             / (float)(*(float *)(a1 + 4 * (i + 1)) - *(float *)(a1 + 4 * i)))
                     * (float)(a2 - *(float *)(a1 + 4 * i)));
        return fmaxf(fmaxf(v5, 0.0), *(float *)(a1 + 80));
      }
      if (i == *(_DWORD *)(a1 + 160) - 2)
      {
        float v5 = *(float *)(a1 + 80 + 4 * (i + 1));
        return fmaxf(fmaxf(v5, 0.0), *(float *)(a1 + 80));
      }
    }
  }
  return fmaxf(fmaxf(v5, 0.0), *(float *)(a1 + 80));
}

float BULuminanceToIlluminance(float *a1, float a2)
{
  float v6 = 0.0;
  if (*((int *)a1 + 40) <= 1)
  {
    if (*((_DWORD *)a1 + 40) == 1) {
      float v3 = *a1;
    }
    else {
      float v3 = 0.0;
    }
    float v6 = v3;
  }
  else
  {
    for (int i = 0; i < *((_DWORD *)a1 + 40) - 1; ++i)
    {
      if (a2 <= a1[i + 21])
      {
        if ((float)(a1[i + 1] - a1[i]) != 0.0)
        {
          float v5 = (float)(a1[i + 21] - a1[i + 20]) / (float)(a1[i + 1] - a1[i]);
          if (v5 == 0.0) {
            float v6 = fminf(a1[i], 20000.0);
          }
          else {
            float v6 = fminf((float)((float)(a2 - a1[i + 20]) + (float)(a1[i] * v5)) / v5, 20000.0);
          }
        }
        return fmaxf(v6, 0.0);
      }
      if (i == *((_DWORD *)a1 + 40) - 2) {
        return fmaxf(fminf(a1[i + 1], 20000.0), 0.0);
      }
    }
  }
  return fmaxf(v6, 0.0);
}

void PerceptualLuminanceThresholding::PerceptualLuminanceThresholding(PerceptualLuminanceThresholding *this, float a2, float a3, char a4, float a5)
{
  char v6 = a4 & 1;
  *(void *)this = &unk_1F13F0EB0;
  *((float *)this + 2) = a5;
  *((void *)this + 2) = os_log_create("com.apple.CoreBrightness.AABC", "PLT");
  *((_DWORD *)this + 6) = 1045220557;
  *((_DWORD *)this + 7) = 1036831949;
  *((float *)this + 8) = a3;
  *((float *)this + 9) = a2;
  *((unsigned char *)this + 164) = v6 & 1;
}

unint64_t PerceptualLuminanceThresholding::_reconfigureTimeConstantTable(unint64_t this)
{
  unint64_t v2 = this;
  if (*(unsigned char *)(this + 164))
  {
    for (unsigned int i = 0; ; ++i)
    {
      this = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::size[abi:ne180100]();
      BOOL v1 = 0;
      if (i < this)
      {
        this = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100](v2 + 60, i);
        BOOL v1 = *(float *)this < 0.0;
      }
      if (!v1) {
        break;
      }
      *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100](v2 + 60, i)+ 4) = 5.0;
    }
  }
  return this;
}

uint64_t std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::size[abi:ne180100]()
{
  return 13;
}

uint64_t std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1 + 8 * a2;
}

{
  return a1 + 8 * a2;
}

void *PerceptualLuminanceThresholding::UpdateTimeConstantTable(PerceptualLuminanceThresholding *this, unsigned int a2)
{
  uint64_t v21 = this;
  unsigned int v20 = a2;
  int v19 = 0;
  int v19 = *((_DWORD *)this + 9);
  float v18 = 0.0;
  float v18 = *((float *)this + 8);
  __b[0] = -1027080192;
  __b[1] = v19;
  __b[2] = -1.0;
  __b[3] = v19;
  __b[4] = -1097229926;
  __b[5] = v19;
  __b[6] = -1102263091;
  __b[7] = v19;
  __b[8] = -1110651699;
  _DWORD __b[9] = v19;
  __b[10] = 0;
  __b[11] = v19;
  __b[12] = 0;
  *(float *)&__b[13] = v18 * 2.0;
  __b[14] = 1025758986;
  *(float *)&__b[15] = v18 * 2.0;
  __b[16] = 1036831949;
  *(float *)&__b[17] = v18 * 1.714;
  __b[18] = 1045220557;
  *(float *)&__b[19] = v18 * 1.143;
  __b[20] = 1050253722;
  *(float *)&__b[21] = v18;
  __b[22] = 1.0;
  *(float *)&__b[23] = v18;
  __b[24] = 1120403456;
  *(float *)&__b[25] = v18;
  if (a2)
  {
    unint64_t v2 = (float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 1);
    float v12 = (float)-*v2 / (float)v20;
    uint64_t v3 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 1);
    *(float *)(v3 + 4) = *(float *)(v3 + 4) * v12;
    float v4 = (float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 2);
    float v13 = (float)-*v4 / (float)v20;
    uint64_t v5 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 2);
    *(float *)(v5 + 4) = *(float *)(v5 + 4) * v13;
    char v6 = (float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 3);
    float v14 = (float)-*v6 / (float)v20;
    uint64_t v7 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 3);
    *(float *)(v7 + 4) = *(float *)(v7 + 4) * v14;
    uint64_t v8 = (float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 4);
    float v15 = (float)-*v8 / (float)v20;
    uint64_t v9 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 4);
    *(float *)(v9 + 4) = *(float *)(v9 + 4) * v15;
    float v10 = 5.0 / (float)v20;
    *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)__b, 5)+ 4) = v10;
  }
  __n128 result = memcpy((char *)this + 60, __b, 0x68uLL);
  if (*((unsigned char *)this + 164)) {
    return (void *)PerceptualLuminanceThresholding::_reconfigureTimeConstantTable((unint64_t)this);
  }
  return result;
}

void *PerceptualLuminanceThresholding::SetAggressivity(PerceptualLuminanceThresholding *this, unsigned int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 10) = a2;
  if (a2) {
    double v6 = 1.0 / (float)(*((float *)this + 2) * (float)a2);
  }
  else {
    double v6 = 1.0;
  }
  float v2 = v6;
  *((float *)this + 11) = v2;
  *((float *)this + 12) = (float)a2;
  *((_DWORD *)this + 13) = 1128792064;
  *((_DWORD *)this + 14) = 1060320051;
  if (*((void *)this + 2))
  {
    uint64_t v5 = *((void *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v5 = inited;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_5_4_0_8_0_8_0_8_0_8_0((uint64_t)v9, a2, COERCE__INT64(*((float *)this + 11)), COERCE__INT64(*((float *)this + 12)), COERCE__INT64(*((float *)this + 13)), COERCE__INT64(*((float *)this + 14)));
    _os_log_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEFAULT, "Setting aggressivity %d, Parameters: %f, %f, %f, %f", v9, 0x30u);
  }
  return PerceptualLuminanceThresholding::UpdateTimeConstantTable(this, a2);
}

uint64_t __os_log_helper_16_0_5_4_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 1) = 5;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 4;
  *(_DWORD *)(result + 4) = a2;
  *(unsigned char *)(result + 8) = 0;
  *(unsigned char *)(result + 9) = 8;
  *(void *)(result + 10) = a3;
  *(unsigned char *)(result + 18) = 0;
  *(unsigned char *)(result + 19) = 8;
  *(void *)(result + 20) = a4;
  *(unsigned char *)(result + 28) = 0;
  *(unsigned char *)(result + 29) = 8;
  *(void *)(result + 30) = a5;
  *(unsigned char *)(result + 38) = 0;
  *(unsigned char *)(result + 39) = 8;
  *(void *)(result + 40) = a6;
  return result;
}

float PerceptualLuminanceThresholding::DurationFromPerceptualDelta(PerceptualLuminanceThresholding *this, float a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  float v16 = 0.0;
  for (int i = 0;
        i < (unint64_t)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::size[abi:ne180100]();
        ++i)
  {
    if (a2 <= *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i))
    {
      if (i)
      {
        float v10 = a2
            - *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1);
        float v9 = *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i);
        float v14 = v10
            / (float)(v9
                    - *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1));
        float v11 = *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i)+ 4);
        float v12 = v11
            - *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1)+ 4);
        float v16 = *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1)+ 4)+ (float)(v14 * v12);
      }
      else
      {
        float v16 = *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, 0)+ 4);
      }
      if (*((void *)this + 2))
      {
        uint64_t v8 = *((void *)this + 2);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v8 = inited;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(double *)&uint64_t v4 = *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1);
        *(double *)&uint64_t v5 = *(float *)std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i);
        *(double *)&uint64_t v6 = *(float *)(std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i - 1)+ 4);
        uint64_t v2 = std::array<PerceptualLuminanceThresholding::TimeConstantTableEntry,13ul>::operator[][abi:ne180100]((uint64_t)this + 60, i);
        __os_log_helper_16_0_7_8_0_8_0_4_0_8_0_8_0_8_0_8_0((uint64_t)v18, COERCE__INT64(a2), COERCE__INT64(v16), i, v4, v5, v6, COERCE__INT64(*(float *)(v2 + 4)));
        _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "Pdelta=%f timeConstant=%f i=%d  Pdeltas={%f, %f}  Ts={%f, %f}", v18, 0x44u);
      }
      return v16;
    }
  }
  return v16;
}

uint64_t __os_log_helper_16_0_7_8_0_8_0_4_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 1) = 7;
  *(unsigned char *)(result + 2) = 0;
  *(unsigned char *)(result + 3) = 8;
  *(void *)(result + 4) = a2;
  *(unsigned char *)(result + 12) = 0;
  *(unsigned char *)(result + 13) = 8;
  *(void *)(result + 14) = a3;
  *(unsigned char *)(result + 22) = 0;
  *(unsigned char *)(result + 23) = 4;
  *(_DWORD *)(result + 24) = a4;
  *(unsigned char *)(result + 28) = 0;
  *(unsigned char *)(result + 29) = 8;
  *(void *)(result + 30) = a5;
  *(unsigned char *)(result + 38) = 0;
  *(unsigned char *)(result + 39) = 8;
  *(void *)(result + 40) = a6;
  *(unsigned char *)(result + 48) = 0;
  *(unsigned char *)(result + 49) = 8;
  *(void *)(result + 50) = a7;
  *(unsigned char *)(result + 58) = 0;
  *(unsigned char *)(result + 59) = 8;
  *(void *)(result + 60) = a8;
  return result;
}

void PerceptualLuminanceThresholding_1nit::PerceptualLuminanceThresholding_1nit(PerceptualLuminanceThresholding_1nit *this, unsigned int a2, float a3, float a4, char a5)
{
  uint64_t v17 = this;
  unsigned int v16 = a2;
  float v15 = a3;
  float v14 = a4;
  char v13 = a5 & 1;
  float v18 = this;
  PerceptualLuminanceThresholding::PerceptualLuminanceThresholding(this, a3, a4, a5 & 1, 1.0);
  *(void *)this = &unk_1F13F0EE0;
  *((float *)this + 42) = 0.25;
  *((_DWORD *)this + 43) = 1052602532;
  *((_DWORD *)this + 44) = 1036831949;
  float v12 = 0;
  if (*((void *)this + 2))
  {
    uint64_t v8 = *((void *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v8 = inited;
  }
  float v12 = v8;
  os_log_type_t v11 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    os_log_t log = v12;
    os_log_type_t type = v11;
    __os_log_helper_16_0_0(v10);
    _os_log_impl(&dword_1BA438000, log, type, "Using 1nit PLT logic", v10, 2u);
  }
  PerceptualLuminanceThresholding::SetPthresholdDim((uint64_t)this, 0.1);
  PerceptualLuminanceThresholding::SetAggressivity(this, v16);
}

{
  PerceptualLuminanceThresholding_1nit::PerceptualLuminanceThresholding_1nit(this, a2, a3, a4, a5 & 1);
}

uint64_t PerceptualLuminanceThresholding::SetPthresholdDim(uint64_t this, float a2)
{
  *(float *)(this + 24) = a2;
  return this;
}

void PerceptualLuminanceThresholding::~PerceptualLuminanceThresholding(PerceptualLuminanceThresholding *this)
{
}

{
  __break(1u);
}

{
  __break(1u);
}

uint64_t PerceptualLuminanceThresholding_1nit::shallUpdateBacklight(PerceptualLuminanceThresholding_1nit *this, float a2, float a3, float a4, char a5, char a6, float a7, float a8)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v59 = this;
  float v58 = a2;
  float v57 = a3;
  float v56 = a4;
  char v55 = a5 & 1;
  char v54 = a6 & 1;
  float v53 = a7;
  float v52 = a8;
  float v51 = a4 - a2;
  float v50 = 0.0;
  float v49 = 1.0;
  float v48 = 1.0;
  if (a3 > *((float *)this + 42))
  {
    if (v57 > *((float *)this + 43)) {
      float v50 = *((float *)this + 44);
    }
    else {
      float v50 = linear_interpolation(v57, *((float *)this + 42), *((float *)this + 42), *((float *)this + 43), *((float *)this + 44));
    }
  }
  else
  {
    float v50 = *((float *)this + 42);
  }
  if (*((_DWORD *)this + 10))
  {
    float v48 = *((float *)this + 12);
    if (v58 > v50)
    {
      float v49 = *((float *)this + 11);
      if (v52 < *((float *)this + 14) && v53 > *((float *)this + 13)) {
        float v49 = v49 / 2.0;
      }
    }
  }
  float v47 = v50 * v49;
  float v46 = 0.0;
  float v46 = *((float *)this + 7) * v48;
  os_log_t v45 = 0;
  if (*((void *)this + 2))
  {
    uint64_t v27 = *((void *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v27 = inited;
  }
  os_log_t v45 = v27;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_14_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v65, (uint64_t)"shallUpdateBacklight", COERCE__INT64(v58), COERCE__INT64(v57), COERCE__INT64(v56), COERCE__INT64(v51), COERCE__INT64(v47), COERCE__INT64(v50), COERCE__INT64(v49), COERCE__INT64(v46), COERCE__INT64(*((float *)this + 7)), COERCE__INT64(v48), COERCE__INT64(*((float *)this + 42)), COERCE__INT64(*((float *)this + 43)), COERCE__INT64(*((float *)this + 44)));
    _os_log_debug_impl(&dword_1BA438000, v45, type, "%s: Pstart=%f Pcurrent=%f Pnewtarget=%f Pdelta=%f Pthreshold_dim=%f (%f * %f) Pthreshold_brighten=%f (%f * %f) plt_x=%f plt_y=%f plt_z=%f", v65, 0x8Eu);
  }
  if (v56 >= 0.97 && v51 > 0.0)
  {
    os_log_t oslog = 0;
    if (*((void *)this + 2))
    {
      uint64_t v25 = *((void *)this + 2);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v24 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v24 = init_default_corebrightness_log();
      }
      uint64_t v25 = v24;
    }
    os_log_t oslog = v25;
    os_log_type_t v42 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v22 = oslog;
      os_log_type_t v23 = v42;
      __os_log_helper_16_0_0(v41);
      _os_log_debug_impl(&dword_1BA438000, v22, v23, "Forcing backlight update due to (Pnewtarget >= 0.97f && Pdelta > 0)", v41, 2u);
    }
    char v60 = 1;
    return v60 & 1;
  }
  BOOL v40 = 0;
  BOOL v21 = 1;
  if (v51 <= v46) {
    BOOL v21 = v51 < (float)-v47;
  }
  BOOL v40 = v21;
  if ((v55 & 1) == 0 && v40)
  {
    os_log_t v39 = 0;
    if (*((void *)this + 2))
    {
      unsigned int v20 = *((void *)this + 2);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v19 = init_default_corebrightness_log();
      }
      unsigned int v20 = v19;
    }
    os_log_t v39 = v20;
    os_log_type_t v38 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v64, COERCE__INT64((float)-v47), COERCE__INT64(v46));
      _os_log_debug_impl(&dword_1BA438000, v39, v38, "Ramp is not in progress. Thresholds (%f, %f) are satisfied", v64, 0x16u);
    }
    char v60 = 1;
    return v60 & 1;
  }
  if ((v55 & 1) != 0 && v40)
  {
    int v37 = 1041865114;
    BOOL v36 = vabds_f32(v52, 1.0) > 0.15;
    if (v36 || (v54 & 1) != 0)
    {
      os_log_t v35 = 0;
      if (*((void *)this + 2))
      {
        float v18 = *((void *)this + 2);
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v17 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v17 = init_default_corebrightness_log();
        }
        float v18 = v17;
      }
      os_log_t v35 = v18;
      os_log_type_t v34 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v63, COERCE__INT64((float)-v47), COERCE__INT64(v46), 0x402E000020000000, COERCE__INT64(v52));
        _os_log_debug_impl(&dword_1BA438000, v35, v34, "Ramp in progress. Thresholds (%f,%f) are satisfied. Lux change is bigger than %.1f%% (ratio %.3f)", v63, 0x2Au);
      }
      char v60 = 1;
      return v60 & 1;
    }
  }
  int v33 = 1030590824;
  BOOL v32 = fabsf(v51) > 0.058;
  if ((v55 & 1) == 0 || v58 > *((float *)this + 42) || v56 > *((float *)this + 42)) {
    goto LABEL_87;
  }
  os_log_t v31 = 0;
  if (*((void *)this + 2))
  {
    unsigned int v16 = *((void *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v15 = init_default_corebrightness_log();
    }
    unsigned int v16 = v15;
  }
  os_log_t v31 = v16;
  os_log_type_t v30 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    char v13 = v31;
    os_log_type_t v14 = v30;
    __os_log_helper_16_0_0(v29);
    _os_log_debug_impl(&dword_1BA438000, v13, v14, "1nit PLT extension", v29, 2u);
  }
  if (v56 > v57)
  {
    if (*((void *)this + 2))
    {
      float v12 = *((void *)this + 2);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v11 = init_default_corebrightness_log();
      }
      float v12 = v11;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v62, COERCE__INT64(v56), COERCE__INT64(v57));
      _os_log_debug_impl(&dword_1BA438000, v12, OS_LOG_TYPE_DEBUG, "Not changing ramp target, because Pnewtarget=%f > Pcurrent=%f", v62, 0x16u);
    }
    char v60 = 0;
    return v60 & 1;
  }
  if (!v32)
  {
LABEL_87:
    char v60 = 0;
    return v60 & 1;
  }
  if (*((void *)this + 2))
  {
    float v10 = *((void *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v9 = init_default_corebrightness_log();
    }
    float v10 = v9;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v61, 0xBFADB22D00000000, 0x3FADB22D00000000);
    _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "Ramp to stuck zone in progress. Thresholds (%f,%f) are satisfied.", v61, 0x16u);
  }
  char v60 = 1;
  return v60 & 1;
}

uint64_t __os_log_helper_16_2_14_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 14;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 0;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  *(unsigned char *)(result + 82)  = 0;
  *(unsigned char *)(result + 83)  = 8;
  *(void *)(result + 84)  = a10;
  *(unsigned char *)(result + 92)  = 0;
  *(unsigned char *)(result + 93)  = 8;
  *(void *)(result + 94)  = a11;
  *(unsigned char *)(result + 102)  = 0;
  *(unsigned char *)(result + 103)  = 8;
  *(void *)(result + 104)  = a12;
  *(unsigned char *)(result + 112)  = 0;
  *(unsigned char *)(result + 113)  = 8;
  *(void *)(result + 114)  = a13;
  *(unsigned char *)(result + 122)  = 0;
  *(unsigned char *)(result + 123)  = 8;
  *(void *)(result + 124)  = a14;
  *(unsigned char *)(result + 132)  = 0;
  *(unsigned char *)(result + 133)  = 8;
  *(void *)(result + 134)  = a15;
  return result;
}

void PerceptualLuminanceThresholding_1nit::SetFloatProperty(PerceptualLuminanceThresholding_1nit *this, NSString *a2, float a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  os_log_type_t v14 = this;
  id v13 = a2;
  float v12 = a3;
  if (*((void *)this + 2))
  {
    float v10 = *((void *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    float v10 = inited;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_2_8_64_8_0((uint64_t)v18, (uint64_t)v13, COERCE__INT64(v12));
    _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "Received property %@  = %f", v18, 0x16u);
  }
  if ([v13 isEqualToString:@"PLT_X"])
  {
    if (v12 >= *((float *)this + 43))
    {
      if (*((void *)this + 2))
      {
        uint64_t v8 = *((void *)this + 2);
      }
      else
      {
        uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        uint64_t v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v17, COERCE__INT64(v12), COERCE__INT64(*((float *)this + 43)));
        _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "Clamping PLT_X=%f to PLT_Y=%f (X can't be larger than Y)", v17, 0x16u);
      }
    }
    *((float *)this + 42)  = *std::min[abi:ne180100]<float>(&v12, (float *)this + 43);
  }
  else if ([v13 isEqualToString:@"PLT_Y"])
  {
    if (v12 <= *((float *)this + 42))
    {
      if (*((void *)this + 2))
      {
        uint64_t v6 = *((void *)this + 2);
      }
      else
      {
        uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        uint64_t v6 = v5;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v16, COERCE__INT64(v12), COERCE__INT64(*((float *)this + 42)));
        _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "Clamping PLT_Y=%f to PLT_X=%f (Y can't be smaller than X)", v16, 0x16u);
      }
    }
    *((float *)this + 43)  = *std::max[abi:ne180100]<float>(&v12, (float *)this + 42);
  }
  else if ([v13 isEqualToString:@"PLT_Z"])
  {
    *((float *)this + 44)  = v12;
  }
  if (*((void *)this + 2))
  {
    uint64_t v4 = *((void *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v3 = init_default_corebrightness_log();
    }
    uint64_t v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v15, COERCE__INT64(*((float *)this + 42)), COERCE__INT64(*((float *)this + 43)), COERCE__INT64(*((float *)this + 44)));
    _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "PLT_X=%f PLT_Y=%f PLT_Z=%f", v15, 0x20u);
  }
}

float *std::min[abi:ne180100]<float>(float *a1, float *a2)
{
  return std::min[abi:ne180100]<float,std::__less<void,void>>(a1, a2);
}

float *std::max[abi:ne180100]<float>(float *a1, float *a2)
{
  return std::max[abi:ne180100]<float,std::__less<void,void>>(a1, a2);
}

void PerceptualLuminanceThresholding_legacy::PerceptualLuminanceThresholding_legacy(PerceptualLuminanceThresholding_legacy *this, unsigned int a2, float a3, float a4, char a5)
{
  uint64_t v17 = this;
  unsigned int v16 = a2;
  float v15 = a3;
  float v14 = a4;
  char v13 = a5 & 1;
  float v18 = this;
  PerceptualLuminanceThresholding::PerceptualLuminanceThresholding(this, a3, a4, a5 & 1, 2.0);
  *(void *)this  = &unk_1F13F0F10;
  float v12 = 0;
  if (*((void *)this + 2))
  {
    uint64_t v8 = *((void *)this + 2);
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v8 = inited;
  }
  float v12 = v8;
  os_log_type_t v11 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    os_log_t log = v12;
    os_log_type_t type = v11;
    __os_log_helper_16_0_0(v10);
    _os_log_impl(&dword_1BA438000, log, type, "Using legacy PLT logic", v10, 2u);
  }
  PerceptualLuminanceThresholding::SetAggressivity(this, v16);
}

{
  PerceptualLuminanceThresholding_legacy::PerceptualLuminanceThresholding_legacy(this, a2, a3, a4, a5 & 1);
}

void PerceptualLuminanceThresholding_legacy::SetFloatProperty(PerceptualLuminanceThresholding_legacy *this, NSString *a2, float a3)
{
}

void PerceptualLuminanceThresholding_1nit::~PerceptualLuminanceThresholding_1nit(PerceptualLuminanceThresholding_1nit *this)
{
}

{
  PerceptualLuminanceThresholding_1nit::~PerceptualLuminanceThresholding_1nit(this);
  MEMORY[0x1BA9EC4A0](this, 0x1081C40BE6C51FCLL);
}

{
  PerceptualLuminanceThresholding::~PerceptualLuminanceThresholding(this);
}

void PerceptualLuminanceThresholding_legacy::~PerceptualLuminanceThresholding_legacy(PerceptualLuminanceThresholding_legacy *this)
{
}

{
  PerceptualLuminanceThresholding_legacy::~PerceptualLuminanceThresholding_legacy(this);
  MEMORY[0x1BA9EC4A0](this, 0x1081C40B823A476);
}

{
  PerceptualLuminanceThresholding::~PerceptualLuminanceThresholding(this);
}

float *std::min[abi:ne180100]<float,std::__less<void,void>>(float *a1, float *a2)
{
  if (std::__less<void,void>::operator()[abi:ne180100]<float,float>((uint64_t)&v6, a2, a1)) {
    return a2;
  }
  else {
    return a1;
  }
}

BOOL std::__less<void,void>::operator()[abi:ne180100]<float,float>(uint64_t a1, float *a2, float *a3)
{
  return *a2 < *a3;
}

float *std::max[abi:ne180100]<float,std::__less<void,void>>(float *a1, float *a2)
{
  if (std::__less<void,void>::operator()[abi:ne180100]<float,float>((uint64_t)&v6, a1, a2)) {
    return a2;
  }
  else {
    return a1;
  }
}

char *strstr[abi:ne180100](char *a1, const char *a2)
{
  return strstr(a1, a2);
}

uint64_t __os_log_helper_16_0_4_8_0_4_0_8_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  return result;
}

uint64_t __os_log_helper_16_0_8_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 1)  = 8;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 0;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  return result;
}

void sub_1BA4E6AEC()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_3_8_64_8_64_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 64;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 64;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

void sub_1BA4E7838()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_4_0_8_64(uint64_t result, int a2, uint64_t a3)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 64;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  return result;
}

void sub_1BA4E9FB0()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  return result;
}

void sub_1BA4EE724()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_3_8_64_8_64_8_34(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 64;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 34;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_64_8_0_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 64;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

void sub_1BA4EED7C()
{
  _Unwind_Resume(v0);
}

void sub_1BA4EEF58()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_8_0_8_64(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 64;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_64_8_64_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 64;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 32;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

void sub_1BA4F0410()
{
  _Unwind_Resume(v0);
}

void sub_1BA4F157C()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_4_8_32_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_64_8_64_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(unsigned char *)__n128 result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 64;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_0_3_8_0_4_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

uint64_t keyboardUsesAdjustedBrightnessCurve(int a1)
{
  char v2 = 0;
  if (a1 == 630 || a1 == 631 || a1 == 632 || a1 == 633 || a1 == 634 || a1 == 635 || a1 == 636 || a1 == 637) {
    char v2 = 1;
  }
  return v2 & 1;
}

uint64_t __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)__n128 result = 0;
  *(unsigned char *)(result + 1)  = 7;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  return result;
}

id getMLModelClass_0()
{
  uint64_t v9 = 0;
  float v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLModelClass_softClass_0;
  uint64_t v13 = getMLModelClass_softClass_0;
  if (!getMLModelClass_softClass_0)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    uint64_t v5 = __getMLModelClass_block_invoke_0;
    char v6 = &unk_1E6219058;
    uint64_t v7 = &v9;
    __getMLModelClass_block_invoke_0((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLArrayBatchProviderClass_0()
{
  uint64_t v9 = 0;
  float v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLArrayBatchProviderClass_softClass_0;
  uint64_t v13 = getMLArrayBatchProviderClass_softClass_0;
  if (!getMLArrayBatchProviderClass_softClass_0)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    uint64_t v5 = __getMLArrayBatchProviderClass_block_invoke_0;
    char v6 = &unk_1E6219058;
    uint64_t v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke_0((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke_0(uint64_t a1)
{
  CoreMLLibrary_0();
  Class Class = objc_getClass("MLFeatureValue");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLFeatureValueClass_softClass_0  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary_0()
{
  uint64_t v1 = CoreMLLibraryCore_0();
  if (!v1) {
    abort_report_np();
  }
  return v1;
}

uint64_t CoreMLLibraryCore_0()
{
  if (!CoreMLLibraryCore_frameworkLibrary_0) {
    __CoreMLLibraryCore_block_invoke_0();
  }
  return CoreMLLibraryCore_frameworkLibrary_0;
}

uint64_t __CoreMLLibraryCore_block_invoke_0()
{
  uint64_t result = _sl_dlopen();
  CoreMLLibraryCore_frameworkLibrary_0  = result;
  return result;
}

uint64_t __getMLModelClass_block_invoke_0(uint64_t a1)
{
  CoreMLLibrary_0();
  Class Class = objc_getClass("MLModel");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLModelClass_softClass_0  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke_0(uint64_t a1)
{
  CoreMLLibrary_0();
  Class Class = objc_getClass("MLPredictionOptions");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLPredictionOptionsClass_softClass_0  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke_0(uint64_t a1)
{
  CoreMLLibrary_0();
  Class Class = objc_getClass("MLArrayBatchProvider");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLArrayBatchProviderClass_softClass_0  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void CBHybridUpdateCurveStrategy::CBHybridUpdateCurveStrategy(CBHybridUpdateCurveStrategy *this, AAB::UpdateCurveStrategy *a2, AAB::UpdateCurveStrategy *a3)
{
  uint64_t v24 = this;
  os_log_type_t v23 = a2;
  uint64_t v22 = a3;
  uint64_t v25 = this;
  AAB::UpdateCurveStrategy::UpdateCurveStrategy(this);
  *(void *)this  = &unk_1F13F0FD0;
  *((void *)this + 1)  = os_log_create("com.apple.CoreBrightness.CBHybridUpdateCurveStrategy", "default");
  if (!*((void *)this + 1))
  {
    BOOL v21 = 0;
    int v11 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
    BOOL v21 = v11;
    char v20 = 16;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v21;
      os_log_type_t type = v20;
      __os_log_helper_16_0_0(v19);
      _os_log_error_impl(&dword_1BA438000, log, type, "Failed to create CBHybridUpdateCurveStrategy log handle", v19, 2u);
    }
  }
  if (!v23)
  {
    float v18 = 0;
    uint64_t v8 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
    float v18 = v8;
    char v17 = 16;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      char v6 = v18;
      os_log_type_t v7 = v17;
      __os_log_helper_16_0_0(v16);
      _os_log_error_impl(&dword_1BA438000, v6, v7, "Baseline strategy is null.", v16, 2u);
    }
  }
  if (!v22)
  {
    float v15 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    float v15 = inited;
    char v14 = 16;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      int v3 = v15;
      os_log_type_t v4 = v14;
      __os_log_helper_16_0_0(v13);
      _os_log_error_impl(&dword_1BA438000, v3, v4, "Alternative strategy is null.", v13, 2u);
    }
  }
  *((void *)this + 2)  = v23;
  *((void *)this + 3)  = v22;
}

{
  CBHybridUpdateCurveStrategy::CBHybridUpdateCurveStrategy(this, a2, a3);
}

void CBHybridUpdateCurveStrategy::~CBHybridUpdateCurveStrategy(CBHybridUpdateCurveStrategy *this)
{
  *(void *)this  = &unk_1F13F0FD0;
  if (*((void *)this + 2))
  {
    uint64_t v2 = *((void *)this + 2);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  if (*((void *)this + 3))
  {
    uint64_t v1 = *((void *)this + 3);
    if (v1) {
      (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
    }
  }
  if (*((void *)this + 1))
  {

    *((void *)this + 1)  = 0;
  }
  AAB::UpdateCurveStrategy::~UpdateCurveStrategy(this);
}

{
  CBHybridUpdateCurveStrategy::~CBHybridUpdateCurveStrategy(this);
}

{
  CBHybridUpdateCurveStrategy::~CBHybridUpdateCurveStrategy(this);
  MEMORY[0x1BA9EC4A0](this, 0xA1C40711E6FFCLL);
}

void CBHybridUpdateCurveStrategy::UpdateCurve(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5, float a6)
{
  unint64_t v18 = __PAIR64__(LODWORD(a5), LODWORD(a4));
  float v19 = a6;
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  if (*(void *)(a1 + 16))
  {
    uint64_t v6 = *(void *)(a1 + 16);
    unint64_t v13 = v18;
    float v14 = v19;
    (*(void (**)(uint64_t, uint64_t, uint64_t, float, float, float))(*(void *)v6 + 24))(v6, v16, v15, *(float *)&v18, *((float *)&v18 + 1), v19);
  }
  else
  {
    os_log_t oslog = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    os_log_t oslog = inited;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = oslog;
      os_log_type_t v8 = type;
      __os_log_helper_16_0_0(v10);
      _os_log_error_impl(&dword_1BA438000, log, v8, "Baseline strategy were not initialized.", v10, 2u);
    }
  }
}

void CBHybridUpdateCurveStrategy::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float a6, float a7, float a8)
{
  unint64_t v22 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  float v23 = a8;
  uint64_t v21 = a1;
  uint64_t v20 = a2;
  uint64_t v19 = a3;
  uint64_t v18 = a4;
  uint64_t v17 = a5;
  if (*(void *)(a1 + 16))
  {
    uint64_t v8 = *(void *)(a1 + 16);
    unint64_t v15 = v22;
    float v16 = v23;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(*(void *)v8 + 32))(v8, v20, v19, v18, v17, *(float *)&v22, *((float *)&v22 + 1), v23);
  }
  else
  {
    os_log_t oslog = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    os_log_t oslog = inited;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = oslog;
      os_log_type_t v10 = type;
      __os_log_helper_16_0_0(v12);
      _os_log_error_impl(&dword_1BA438000, log, v10, "Baseline strategy were not initialized.", v12, 2u);
    }
  }
}

void CBHybridUpdateCurveStrategy::UpdateAlternativeCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float a6, float a7, float a8)
{
  unint64_t v22 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  float v23 = a8;
  uint64_t v21 = a1;
  uint64_t v20 = a2;
  uint64_t v19 = a3;
  uint64_t v18 = a4;
  uint64_t v17 = a5;
  if (*(void *)(a1 + 24))
  {
    uint64_t v8 = *(void *)(a1 + 24);
    unint64_t v15 = v22;
    float v16 = v23;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(*(void *)v8 + 32))(v8, v20, v19, v18, v17, *(float *)&v22, *((float *)&v22 + 1), v23);
  }
  else
  {
    os_log_t oslog = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    os_log_t oslog = inited;
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = oslog;
      os_log_type_t v10 = type;
      __os_log_helper_16_0_0(v12);
      _os_log_error_impl(&dword_1BA438000, log, v10, "Alternative strategy were not initialized.", v12, 2u);
    }
  }
}

uint64_t CBHybridUpdateCurveStrategy::curveUpdates@<X0>(CBHybridUpdateCurveStrategy *this@<X0>, void *a2@<X8>)
{
  uint64_t v9 = a2;
  uint64_t v8 = this;
  char v7 = 0;
  std::list<AAB::CurveUpdate>::list[abi:ne180100](a2);
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 2) + 48))(v6);
  std::list<AAB::CurveUpdate>::operator=((uint64_t)a2, v6);
  std::list<AAB::CurveUpdate>::~list((uint64_t)v6);
  uint64_t result = std::list<AAB::CurveUpdate>::empty[abi:ne180100]();
  if (result)
  {
    (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 3) + 48))(v5);
    std::list<AAB::CurveUpdate>::operator=((uint64_t)a2, v5);
    return std::list<AAB::CurveUpdate>::~list((uint64_t)v5);
  }
  return result;
}

uint64_t std::list<AAB::CurveUpdate>::operator=(uint64_t a1, uint64_t *a2)
{
  return a1;
}

uint64_t CBHybridUpdateCurveStrategy::SetCurveUpdates(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (*(void *)(result + 16)) {
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(result + 16) + 56))(*(void *)(result + 16), a2);
  }
  if (*(void *)(v2 + 24)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 24) + 56))(*(void *)(v2 + 24), a2);
  }
  return result;
}

uint64_t CBHybridUpdateCurveStrategy::Reset(uint64_t this)
{
  uint64_t v1 = this;
  if (*(void *)(this + 16)) {
    this  = (*(uint64_t (**)(void))(**(void **)(this + 16) + 16))(*(void *)(this + 16));
  }
  if (*(void *)(v1 + 24)) {
    return (*(uint64_t (**)(void))(**(void **)(v1 + 24) + 16))(*(void *)(v1 + 24));
  }
  return this;
}

uint64_t CBHybridUpdateCurveStrategy::alternativeCappedCurve(uint64_t a1, uint64_t a2)
{
  char v3 = 0;
  if (*(void *)(a1 + 24)) {
    char v3 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 64))(*(void *)(a1 + 24), a2) & 1;
  }
  return v3 & 1;
}

uint64_t CBHybridUpdateCurveStrategy::cappedCurve(uint64_t a1, uint64_t a2)
{
  char v3 = 0;
  if (*(void *)(a1 + 16)) {
    char v3 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 64))(*(void *)(a1 + 16), a2) & 1;
  }
  return v3 & 1;
}

uint64_t CBHybridUpdateCurveStrategy::setCappedCurve(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 16)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(result + 16) + 80))(*(void *)(result + 16), a2);
  }
  return result;
}

uint64_t CBHybridUpdateCurveStrategy::setAlternativeCappedCurve(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 24)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(result + 24) + 80))(*(void *)(result + 24), a2);
  }
  return result;
}

uint64_t CBHybridUpdateCurveStrategy::preservePreferences(uint64_t this)
{
  uint64_t v1 = this;
  if (*(void *)(this + 16)) {
    this  = (*(uint64_t (**)(void))(**(void **)(this + 16) + 96))(*(void *)(this + 16));
  }
  if (*(void *)(v1 + 24)) {
    return (*(uint64_t (**)(void))(**(void **)(v1 + 24) + 96))(*(void *)(v1 + 24));
  }
  return this;
}

uint64_t CBHybridUpdateCurveStrategy::curveType(CBHybridUpdateCurveStrategy *this)
{
  if (*((void *)this + 2)) {
    return (*(uint64_t (**)(void))(**((void **)this + 2) + 104))(*((void *)this + 2));
  }
  else {
    return 0;
  }
}

uint64_t CBHybridUpdateCurveStrategy::alternativeCurveType(CBHybridUpdateCurveStrategy *this)
{
  if (*((void *)this + 3)) {
    return (*(uint64_t (**)(void))(**((void **)this + 3) + 104))(*((void *)this + 3));
  }
  else {
    return 0;
  }
}

void std::list<AAB::CurveUpdate>::__move_assign(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = a1;
  uint64_t v5 = a2;
  std::list<AAB::CurveUpdate>::clear[abi:ne180100](a1);
  std::__list_imp<AAB::CurveUpdate>::__move_assign_alloc[abi:ne180100]();
  uint64_t v3 = std::list<AAB::CurveUpdate>::end[abi:ne180100]();
  std::__list_const_iterator<AAB::CurveUpdate,void *>::__list_const_iterator[abi:ne180100](&v4, &v3);
  std::list<AAB::CurveUpdate>::splice(a1, v4, v5);
}

void std::list<AAB::CurveUpdate>::clear[abi:ne180100](uint64_t a1)
{
}

void std::__list_imp<AAB::CurveUpdate>::__move_assign_alloc[abi:ne180100]()
{
}

{
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
  std::__list_imp<AAB::CurveUpdate>::__node_alloc[abi:ne180100]();
}

uint64_t __os_log_helper_16_0_4_8_0_4_0_4_0_4_0(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 4;
  *(_DWORD *)(result + 20)  = a4;
  *(unsigned char *)(result + 24)  = 0;
  *(unsigned char *)(result + 25)  = 4;
  *(_DWORD *)(result + 26)  = a5;
  return result;
}

CFStringRef createAmmoliteKey(const char *a1, int a2)
{
  if (a2 >= 0) {
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%s-%d", a1, a2);
  }
  alloc  = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  SystemEncoding  = CFStringGetSystemEncoding();
  return CFStringCreateWithCString(alloc, a1, SystemEncoding);
}

BOOL CFXAmmoliteSupported(io_registry_entry_t a1)
{
  io_registry_entry_t v6 = a1;
  int v5 = 0;
  int v4 = 0;
  if (!readExactDataFromIOService(a1, @"pab-scaler-index", (UInt8 *)&v5, 4)) {
    int v5 = -1;
  }
  CFStringRef cf = createAmmoliteKey("aml-table-factor", v5);
  ExactDataFromIOService  = 0;
  if (cf)
  {
    ExactDataFromIOService  = readExactDataFromIOService(v6, cf, (UInt8 *)&v4, 4);
    CFRelease(cf);
  }
  if (!ExactDataFromIOService) {
    return readExactDataFromIOService(v6, @"aml-table-factor", (UInt8 *)&v4, 4);
  }
  return ExactDataFromIOService;
}

void *CFXAmmoliteCreate(io_registry_entry_t a1, uint64_t a2)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  entry  = a1;
  uint64_t v56 = a2;
  if (!a1) {
    return 0;
  }
  char v55 = 0;
  CFTypeRef v54 = os_log_create("com.apple.CBColorModule.Primary.Ammolite", "default");
  int v53 = 0;
  int v52 = 0;
  key  = 0;
  CFStringRef v48 = 0;
  CFStringRef v49 = 0;
  CFStringRef v50 = 0;
  AmmoliteKey  = 0;
  if (readExactDataFromIOService(entry, @"pab-scaler-index", (UInt8 *)&v53, 4))
  {
    os_log_t oslog = 0;
    if (v54) {
      uint64_t v19 = v54;
    }
    else {
      uint64_t v19 = MEMORY[0x1E4F14500];
    }
    os_log_t oslog = v19;
    os_log_type_t type = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v72, (uint64_t)"CFXAmmoliteCreate", v53);
      _os_log_debug_impl(&dword_1BA438000, oslog, type, "%s: Display vendor index is %d", v72, 0x12u);
    }
    if (v53 < 0)
    {
      int v53 = -1;
    }
    else
    {
      AmmoliteKey  = createAmmoliteKey("aml-table-factor", v53);
      if (AmmoliteKey && readExactDataFromIOService(entry, AmmoliteKey, (UInt8 *)&v52, 4))
      {
        os_log_t v44 = 0;
        if (v54) {
          uint64_t v18 = v54;
        }
        else {
          uint64_t v18 = MEMORY[0x1E4F14500];
        }
        os_log_t v44 = v18;
        os_log_type_t v43 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_2_8_32_4_0((uint64_t)v71, (uint64_t)"CFXAmmoliteCreate", v53);
          _os_log_impl(&dword_1BA438000, v44, v43, "%s: Ammolite configuration found for display vendor index: %d", v71, 0x12u);
        }
      }
      else
      {
        int v53 = -1;
      }
    }
  }
  else
  {
    int v53 = -1;
  }
  if (v53 < 0)
  {
    if (!readExactDataFromIOService(entry, @"aml-table-factor", (UInt8 *)&v52, 4))
    {
      if (AmmoliteKey)
      {
        os_log_t v40 = 0;
        if (v54) {
          float v16 = v54;
        }
        else {
          float v16 = MEMORY[0x1E4F14500];
        }
        os_log_t v40 = v16;
        os_log_type_t v39 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_3_8_32_8_66_8_32((uint64_t)v69, (uint64_t)"CFXAmmoliteCreate", (uint64_t)AmmoliteKey, (uint64_t)"aml-table-factor");
          _os_log_impl(&dword_1BA438000, v40, v39, "%s: Ammolite is not supported on this device (unable to find %{public}@ or %s in EDT)", v69, 0x20u);
        }
      }
      else
      {
        os_log_t v38 = 0;
        if (v54) {
          unint64_t v15 = v54;
        }
        else {
          unint64_t v15 = MEMORY[0x1E4F14500];
        }
        os_log_t v38 = v15;
        os_log_type_t v37 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_2_8_32_8_32((uint64_t)v68, (uint64_t)"CFXAmmoliteCreate", (uint64_t)"aml-table-factor");
          _os_log_impl(&dword_1BA438000, v38, v37, "%s: Ammolite is not supported on this device (unable to find %s in EDT)", v68, 0x16u);
        }
      }
      goto LABEL_113;
    }
    os_log_t v42 = 0;
    if (v54) {
      uint64_t v17 = v54;
    }
    else {
      uint64_t v17 = MEMORY[0x1E4F14500];
    }
    os_log_t v42 = v17;
    os_log_type_t v41 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v70, (uint64_t)"CFXAmmoliteCreate");
      _os_log_impl(&dword_1BA438000, v42, v41, "%s: Ammolite global configuration found (no display vendor specific config found)", v70, 0xCu);
    }
  }
  os_log_t v36 = 0;
  if (v54) {
    float v14 = v54;
  }
  else {
    float v14 = MEMORY[0x1E4F14500];
  }
  os_log_t v36 = v14;
  os_log_type_t v35 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_2_2_8_32_4_0((uint64_t)v67, (uint64_t)"CFXAmmoliteCreate", v52);
    _os_log_impl(&dword_1BA438000, v36, v35, "%s: Ammolite factor: %d", v67, 0x12u);
  }
  unsigned int v34 = 0;
  unsigned int v33 = 0;
  unsigned int v32 = 0;
  CFStringRef v50 = createAmmoliteKey("aml-abs-lux-thresh", v53);
  if (v50 && readExactDataFromIOService(entry, v50, (UInt8 *)&v34, 4))
  {
    CFStringRef v49 = createAmmoliteKey("aml-rel-lux-thresh", v53);
    if (v49 && readExactDataFromIOService(entry, v49, (UInt8 *)&v33, 4))
    {
      CFStringRef v48 = createAmmoliteKey("aml-period", v53);
      if (v48 && readExactDataFromIOService(entry, v48, (UInt8 *)&v32, 4))
      {
        float v31 = (float)v34 / 65536.0;
        float v30 = (float)v33 / 65536.0;
        float v29 = (float)v32 / 65536.0;
        if (v54) {
          os_log_type_t v10 = v54;
        }
        else {
          os_log_type_t v10 = MEMORY[0x1E4F14500];
        }
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_2_4_8_32_8_0_8_0_8_0((uint64_t)v63, (uint64_t)"CFXAmmoliteCreate", COERCE__INT64(v31), COERCE__INT64(v30), COERCE__INT64(v29));
          _os_log_impl(&dword_1BA438000, v10, OS_LOG_TYPE_INFO, "%s: Ammolite: absLux  = %f relLux  = %f period  = %f", v63, 0x2Au);
        }
        key  = createAmmoliteKey("aml-table", v53);
        if (key)
        {
          CFDataRef cf = (const __CFData *)IORegistryEntrySearchCFProperty(entry, "IOService", key, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
          if (cf && (CFTypeID v9 = CFGetTypeID(cf), v9 == CFDataGetTypeID()))
          {
            if (CFDataGetLength(cf) % 40) {
              __assert_rtn("CFXAmmoliteCreate", "Ammolite.c", 156, "CFDataGetLength(elemData) % rowSize == 0");
            }
            CFIndex v27 = CFDataGetLength(cf) / 40;
            BytePtr  = CFDataGetBytePtr(cf);
            uint64_t v25 = (float *)malloc_type_malloc(40 * v27, 0x10000400A747E1EuLL);
            for (int i = 0; i < v27; ++i)
            {
              LODWORD(v2)  = v52;
              double v2 = (double)*(unint64_t *)&v2;
              float v3 = (double)*(int *)&BytePtr[40 * i] / v2;
              v25[10 * i]  = v3;
              for (int j = 0; j < 3; ++j)
              {
                for (int k = 0; k < 3; ++k)
                {
                  LODWORD(v2)  = v52;
                  double v2 = (double)*(unint64_t *)&v2;
                  float v4 = (double)*(int *)&BytePtr[40 * i + 4 + 12 * j + 4 * k] / v2;
                  v25[10 * i + 1 + 3 * j + k]  = v4;
                }
              }
            }
            if (v54) {
              char v7 = v54;
            }
            else {
              char v7 = MEMORY[0x1E4F14500];
            }
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_2_1_8_32((uint64_t)v61, (uint64_t)"CFXAmmoliteCreate");
              _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "%s: Ammolite table:", v61, 0xCu);
            }
            for (m  = 0; m < v27; ++m)
            {
              if (v54) {
                io_registry_entry_t v6 = v54;
              }
              else {
                io_registry_entry_t v6 = MEMORY[0x1E4F14500];
              }
              if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
              {
                __os_log_helper_16_2_11_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v60, (uint64_t)"CFXAmmoliteCreate", COERCE__INT64(v25[10 * m]), COERCE__INT64(v25[10 * m + 1]), COERCE__INT64(v25[10 * m + 2]), COERCE__INT64(v25[10 * m + 3]), COERCE__INT64(v25[10 * m + 4]), COERCE__INT64(v25[10 * m + 5]), COERCE__INT64(v25[10 * m + 6]), COERCE__INT64(v25[10 * m + 7]), COERCE__INT64(v25[10 * m + 8]), COERCE__INT64(v25[10 * m + 9]));
                _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "%s: \t%f: %f %f %f %f %f %f %f %f %f", v60, 0x70u);
              }
            }
            char v55 = malloc_type_malloc(0x38uLL, 0x102004028F26F39uLL);
            v55[6]  = v54;
            v55[1]  = v27;
            *((unsigned char *)v55 + 24)  = 0;
            *((_DWORD *)v55 + 7)  = 0;
            *((float *)v55 + 8)  = v31;
            *((float *)v55 + 9)  = v30;
            *((float *)v55 + 10)  = v29;
            *char v55 = v25;
            v55[2]  = v56;
            CFRelease(cf);
          }
          else
          {
            if (cf) {
              CFRelease(cf);
            }
            if (v54) {
              uint64_t v8 = v54;
            }
            else {
              uint64_t v8 = MEMORY[0x1E4F14500];
            }
            if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            {
              __os_log_helper_16_2_1_8_32((uint64_t)v62, (uint64_t)"CFXAmmoliteCreate");
              _os_log_error_impl(&dword_1BA438000, v8, OS_LOG_TYPE_ERROR, "%s: Unable to read Ammolite table data from device tree", v62, 0xCu);
            }
          }
        }
      }
      else
      {
        if (v54) {
          int v11 = v54;
        }
        else {
          int v11 = MEMORY[0x1E4F14500];
        }
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          __os_log_helper_16_2_1_8_32((uint64_t)v64, (uint64_t)"CFXAmmoliteCreate");
          _os_log_error_impl(&dword_1BA438000, v11, OS_LOG_TYPE_ERROR, "%s: Unable to read Ammolite period from device tree", v64, 0xCu);
        }
      }
    }
    else
    {
      if (v54) {
        int v12 = v54;
      }
      else {
        int v12 = MEMORY[0x1E4F14500];
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_2_1_8_32((uint64_t)v65, (uint64_t)"CFXAmmoliteCreate");
        _os_log_error_impl(&dword_1BA438000, v12, OS_LOG_TYPE_ERROR, "%s: Unable to read Ammolite relative threshold from device tree", v65, 0xCu);
      }
    }
  }
  else
  {
    if (v54) {
      unint64_t v13 = v54;
    }
    else {
      unint64_t v13 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v66, (uint64_t)"CFXAmmoliteCreate");
      _os_log_error_impl(&dword_1BA438000, v13, OS_LOG_TYPE_ERROR, "%s: Unable to read Ammolite absolute threshold from device tree", v66, 0xCu);
    }
  }
LABEL_113:
  if (!v55 && v54) {
    CFRelease(v54);
  }
  __b[0]  = AmmoliteKey;
  __b[1]  = v50;
  __b[2]  = v49;
  __b[3]  = v48;
  __b[4]  = key;
  for (n  = 0; n < 5; ++n)
  {
    if (__b[n]) {
      CFRelease((CFTypeRef)__b[n]);
    }
  }
  return v55;
}

uint64_t __os_log_helper_16_2_3_8_32_8_66_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 32;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_11_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 11;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 0;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  *(unsigned char *)(result + 82)  = 0;
  *(unsigned char *)(result + 83)  = 8;
  *(void *)(result + 84)  = a10;
  *(unsigned char *)(result + 92)  = 0;
  *(unsigned char *)(result + 93)  = 8;
  *(void *)(result + 94)  = a11;
  *(unsigned char *)(result + 102)  = 0;
  *(unsigned char *)(result + 103)  = 8;
  *(void *)(result + 104)  = a12;
  return result;
}

void CFXAmmoliteFree(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(void *)(a1 + 48)) {
      uint64_t v1 = *(NSObject **)(a1 + 48);
    }
    else {
      uint64_t v1 = MEMORY[0x1E4F14500];
    }
    if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v3, (uint64_t)"CFXAmmoliteFree");
      _os_log_impl(&dword_1BA438000, v1, OS_LOG_TYPE_INFO, "%s: Turning Ammolite off", v3, 0xCu);
    }
    CFRelease(*(CFTypeRef *)(a1 + 48));
    free(*(void **)a1);
    free((void *)a1);
  }
}

uint64_t CFXAmmoliteFadeInternal(uint64_t a1, int a2, uint64_t a3, double a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  double v12 = a4 - *(double *)(a1 + 8);
  double v9 = v12 / *(double *)a1;
  char v8 = 0;
  if (*(double *)a1 == 0.0 || v9 >= 1.0 || v12 < 0.0)
  {
    memcpy(__dst, (const void *)(a1 + 20), sizeof(__dst));
    *(void *)a1  = 0;
    *(unsigned char *)(a1 + 16)  = 1;
  }
  else
  {
    double v10 = v9 * (float)(a2 - 1);
    double v11 = (1.0 - (v10 - (double)(int)v10)) * *(float *)(a3 + 4 * (int)v10)
        + (v10 - (double)(int)v10) * *(float *)(a3 + 4 * ((int)v10 + 1));
    for (int i = 0; i < 3; ++i)
    {
      for (int j = 0; j < 3; ++j)
      {
        float v4 = *(float *)(a1 + 92 + 12 * i + 4 * j)
           + v11 * (float)(*(float *)(a1 + 20 + 12 * i + 4 * j) - *(float *)(a1 + 92 + 12 * i + 4 * j));
        *(float *)&__dst[3 * i + j]  = v4;
      }
    }
    char v8 = 1;
  }
  __memcpy_chk();
  return v8 & 1;
}

uint64_t __os_log_helper_16_2_3_4_0_8_64_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 64;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

uint64_t __os_log_helper_16_0_2_4_0_8_0(uint64_t result, int a2, uint64_t a3)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_64_4_0_8_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  return result;
}

uint64_t __os_log_helper_16_0_3_4_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_4_4_0_8_66_8_66_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 66;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 66;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  return result;
}

void sub_1BA508324()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_5_8_64_8_0_8_64_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 64;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  return result;
}

float linear_interpolation(float a1, float a2, float a3, float a4, float a5)
{
  return a3 + (float)((float)((float)(a5 - a3) / (float)(a4 - a2)) * (float)(a1 - a2));
}

float *find_bound(float *result, unint64_t a2, float a3, unint64_t *a4, unint64_t *a5)
{
  if (result && a2)
  {
    if (a3 >= *result)
    {
      if (a3 < result[a2 - 1])
      {
        for (unint64_t i = 1; i < a2; ++i)
        {
          if (a3 >= result[i - 1] && a3 < result[i])
          {
            *a4  = i - 1;
            *a5  = i;
            return result;
          }
        }
      }
      else
      {
        *a4  = a2 - 2;
        *a5  = a2 - 1;
      }
    }
    else
    {
      *a4  = 0;
      *a5  = 1;
    }
  }
  else
  {
    *a4  = 0;
    *a5  = 0;
  }
  return result;
}

float matrix_element(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return *(float *)(a1 + 4 * (a2 * a4 + a3));
}

float two_dimensional_interpolation(float *a1, unint64_t a2, float *a3, unint64_t a4, uint64_t a5, float a6, float a7)
{
  float v30 = a6;
  float v29 = a7;
  uint64_t v28 = a1;
  unint64_t v27 = a2;
  uint64_t v26 = a3;
  unint64_t v25 = a4;
  uint64_t v24 = a5;
  if (!a1 || !v26 || !v24 || v27 < 2 || v25 < 2) {
    return NAN;
  }
  float v30 = clamp(v30, *v28, v28[v27 - 1]);
  float v29 = clamp(v29, *v26, v26[v25 - 1]);
  unint64_t v23 = 0;
  unint64_t v22 = 0;
  find_bound(v28, v27, v30, &v23, &v22);
  unint64_t v21 = 0;
  unint64_t v20 = 0;
  find_bound(v26, v25, v29, &v21, &v20);
  float v19 = v28[v23];
  float v18 = v28[v22];
  float v17 = v26[v21];
  float v16 = v26[v20];
  float v15 = 1.0;
  if (!float_equal((float)(v18 - v19) * (float)(v16 - v17), 0.0)) {
    float v15 = 1.0 / (float)((float)(v18 - v19) * (float)(v16 - v17));
  }
  float v14 = (float)((float)(v18 - v30) * (float)(v29 - v17)) * v15;
  float v13 = (float)((float)(v30 - v19) * (float)(v16 - v29)) * v15;
  float v12 = (float)((float)(v30 - v19) * (float)(v29 - v17)) * v15;
  float v9 = (float)((float)(v18 - v30) * (float)(v16 - v29)) * v15;
  float v8 = matrix_element(v24, v21, v23, v27);
  float v10 = (float)(v14 * matrix_element(v24, v20, v23, v27)) + (float)(v9 * v8);
  float v11 = v10 + (float)(v13 * matrix_element(v24, v21, v22, v27));
  return v11 + (float)(v12 * matrix_element(v24, v20, v22, v27));
}

float __mach_time_to_nanoseconds_block_invoke(uint64_t a1)
{
  uint64_t v4 = a1;
  uint64_t v3 = a1;
  mach_timebase_info(&info);
  float result = (float)info.numer / (float)info.denom;
  *(float *)&mach_time_to_nanoseconds::machTimeBaseFactor  = result;
  return result;
}

float mach_time_now_in_nanoseconds()
{
  uint64_t v0 = mach_absolute_time();
  return mach_time_to_nanoseconds(v0);
}

unint64_t create_integer_array_from_cfdata(const void *a1, UInt8 **a2)
{
  count  = 0;
  buffer  = 0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFDataGetTypeID())
    {
      count  = CFDataGetLength((CFDataRef)a1) / 4uLL;
      buffer  = (UInt8 *)malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
      if (buffer)
      {
        v8.location  = 0;
        v8.length  = 4 * count;
        CFDataGetBytes((CFDataRef)a1, v8, buffer);
      }
      else
      {
        count  = 0;
      }
    }
  }
  *a2  = buffer;
  return count;
}

uint64_t get_uint32_from_cfdata(const void *a1, unsigned int *a2)
{
  CFTypeRef v7 = a1;
  io_registry_entry_t v6 = a2;
  char v5 = 0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(v7);
    if (v3 == CFDataGetTypeID())
    {
      *(_DWORD *)buffer  = 0;
      if (CFDataGetLength((CFDataRef)v7) == 4)
      {
        uint64_t v9 = 0;
        uint64_t v8 = 4;
        uint64_t v10 = 0;
        uint64_t v11 = 4;
        v12.location  = 0;
        v12.length  = 4;
        CFDataGetBytes((CFDataRef)v7, v12, buffer);
        char v5 = 1;
        *io_registry_entry_t v6 = *(_DWORD *)buffer;
      }
    }
  }
  return v5 & 1;
}

uint64_t get_float_from_cfdata(const void *a1, _DWORD *a2)
{
  CFTypeRef v7 = a1;
  io_registry_entry_t v6 = a2;
  char v5 = 0;
  *(_DWORD *)buffer  = 2143289344;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(v7);
    if (v3 == CFDataGetTypeID() && CFDataGetLength((CFDataRef)v7) == 4)
    {
      uint64_t v9 = 0;
      uint64_t v8 = 4;
      uint64_t v10 = 0;
      uint64_t v11 = 4;
      v12.location  = 0;
      v12.length  = 4;
      CFDataGetBytes((CFDataRef)v7, v12, buffer);
      char v5 = 1;
    }
  }
  *io_registry_entry_t v6 = *(_DWORD *)buffer;
  return v5 & 1;
}

unint64_t load_integer_array_from_edt(io_registry_entry_t a1, const __CFString *a2, UInt8 **a3)
{
  CFTypeRef cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (cf)
  {
    integer_array_from_cfdata  = create_integer_array_from_cfdata(cf, a3);
    CFRelease(cf);
  }
  else
  {
    integer_array_from_cfdata  = 0;
    *a3  = 0;
  }
  return integer_array_from_cfdata;
}

unint64_t load_float_array_from_edt(io_registry_entry_t a1, const __CFString *a2, void *a3)
{
  io_registry_entry_t v9 = a1;
  CFStringRef v8 = a2;
  CFTypeRef v7 = a3;
  unint64_t v6 = 0;
  CFTypeRef cf = 0;
  CFTypeRef cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (cf)
  {
    uint64_t v4 = 0;
    unint64_t v6 = create_integer_array_from_cfdata(cf, &v4);
    *CFTypeRef v7 = v4;
    CFRelease(cf);
  }
  else
  {
    unint64_t v6 = 0;
    *CFTypeRef v7 = 0;
  }
  return v6;
}

float load_float_from_edt(io_registry_entry_t a1, const __CFString *a2)
{
  io_registry_entry_t v6 = a1;
  key  = a2;
  float v4 = NAN;
  CFTypeRef cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (cf)
  {
    get_float_from_cfdata(cf, &v4);
    CFRelease(cf);
  }
  return v4;
}

uint64_t load_uint_from_edt(io_registry_entry_t a1, const __CFString *a2, unsigned int *a3)
{
  char v5 = 0;
  CFTypeRef cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (cf)
  {
    char v5 = get_uint32_from_cfdata(cf, a3) & 1;
    CFRelease(cf);
  }
  return v5 & 1;
}

double scaleForExponent(int a1)
{
  double v4 = 1.0;
  if (a1 >= 8)
  {
    for (int i = 16; i > a1; --i)
      double v4 = v4 * 10.0;
  }
  else
  {
    for (int j = 0; j < a1; ++j)
      double v4 = v4 * 10.0;
    return 1.0 / v4;
  }
  return v4;
}

float LuminanceToPerceptual(float a1, float a2, float a3)
{
  float v4 = logf(fmaxf(a1, a2) / a3);
  return (float)(v4 / logf(a3 / a2)) + 1.0;
}

float PerceptualToLuminance(float a1, float a2, float a3)
{
  return a3 * powf(a3 / a2, a1 - 1.0);
}

uint64_t get_int_from_bootarg(char *a1, _DWORD *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  __s  = a1;
  CFStringRef v8 = a2;
  char v7 = 0;
  bzero(v10, 0x400uLL);
  size_t v6 = 1024;
  if (!sysctlbyname("kern.bootargs", v10, &v6, 0, 0))
  {
    char v5 = strstr[abi:ne180100](v10, __s);
    if (v5)
    {
      size_t v2 = strlen(__s);
      int v3 = strtol(&v5[v2 + 1], 0, 0);
      *CFStringRef v8 = v3;
      char v7 = 1;
    }
  }
  return v7 & 1;
}

uint64_t __os_log_helper_16_2_4_8_64_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  return result;
}

uint64_t CFXStoreComment(uint64_t result, const __CFString *a2)
{
  if (result)
  {
    if (a2) {
      return CFStringGetCString(a2, (char *)(result + 1820), 256, 0x8000100u);
    }
  }
  return result;
}

FILE *CFXForceLogCommit(FILE *result)
{
  if (result) {
    return _CFXCommitLog(result);
  }
  return result;
}

FILE *_CFXCommitLog(FILE *result)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  size_t v2 = result;
  if (SLODWORD(result[11]._offset) > 0)
  {
    __sprintf_chk(v3, 0, 0x100uLL, "%s/%s_%s.csv", "/var/mobile/Library/Logs/CrashReporter/harmony", "HarmonyLog", (const char *)&result[13]._ub._size + 5);
    mkdir("/var/mobile/Library/Logs/CrashReporter/harmony", 0x1EDu);
    float result = fopen(v3, "a");
    __stream  = result;
    if (result)
    {
      fwrite("date,time,orientation_s,nChannels_s,R_s,G_s,B_s,C_s,Y_s,x_s,y_s,CCT1_s,x_restricted,y_restricted,brightness_d,sample_ignored,adptLevel,x_algo,y_algo,R_wp,G_wp,B_wp,ramp_in_progress,ramp_period,transition_count,comments\n", 1uLL, 0xDBuLL, result);
      fwrite(*(const void **)&v2[11]._blksize, 1uLL, SLODWORD(v2[11]._offset), __stream);
      float result = (FILE *)fclose(__stream);
    }
    LODWORD(v2[11]._offset)  = 0;
  }
  return result;
}

uint64_t CFXEnableLog(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 1801)  = a2 & 1;
  }
  return result;
}

uint64_t CFXAnsiBinFromChromaticity(float *a1)
{
  return ansiBinFromChromaticity(a1);
}

uint64_t CFXSetTarget(uint64_t a1, float *a2, char a3, char a4, float a5, float a6)
{
  return _CFXSetTarget(a1, a2, a3 & 1, a4 & 1, a5, a6) & 1;
}

uint64_t CFXZeroSample(uint64_t result)
{
  if (result) {
    return __memset_chk();
  }
  return result;
}

void *CFXCreate()
{
  uint64_t v1 = malloc_type_malloc(0xA30uLL, 0x10F004054DC366FuLL);
  if (v1)
  {
    __memset_chk();
    *((void *)v1 + 14)  = &MemoryColorCoeff;
    *((CFAbsoluteTime *)v1 + 17)  = CFAbsoluteTimeGetCurrent();
    *((unsigned char *)v1 + 144)  = 1;
    *((float *)v1 + 49)  = 1.0;
    *((unsigned char *)v1 + 1800)  = 0;
    *((void *)v1 + 44)  = &rampProfile;
    *((_DWORD *)v1 + 90)  = 201;
    *((void *)v1 + 93)  = &CCT_Shifted_Table;
    *((_DWORD *)v1 + 188)  = 66;
    *((float *)v1 + 535)  = 1.0;
    _CFXInitStats((uint64_t)v1 + 760);
    *((void *)v1 + 8)  = &CCT_BB_Table;
    *((_DWORD *)v1 + 18)  = 813;
    *((void *)v1 + 282)  = 0;
    __memset_chk();
    *((unsigned char *)v1 + 2280)  = 1;
    *((float *)v1 + 579)  = 1.0;
    *((float *)v1 + 575)  = 1.0;
    *((float *)v1 + 571)  = 1.0;
    *((float *)v1 + 588)  = 1.0;
    *((float *)v1 + 584)  = 1.0;
    *((float *)v1 + 580)  = 1.0;
    *((float *)v1 + 597)  = 1.0;
    *((float *)v1 + 593)  = 1.0;
    *((float *)v1 + 589)  = 1.0;
    _CFXClearReport((uint64_t)v1);
    __memcpy_chk();
    *((_DWORD *)v1 + 529)  = 1050408072;
    *((_DWORD *)v1 + 530)  = 1050941587;
    __memcpy_chk();
    __memcpy_chk();
    __memcpy_chk();
    *((_DWORD *)v1 + 531)  = 1172084122;
    *((_DWORD *)v1 + 23)  = 1172084122;
    __memcpy_chk();
    _CFXIdentity((float *)v1 + 176);
    *((_DWORD *)v1 + 185)  = 0;
    *((float *)v1 + 563)  = -1.0;
    *((unsigned char *)v1 + 2448)  = 1;
    *((_DWORD *)v1 + 613)  = 0;
    *((_DWORD *)v1 + 614)  = 0;
    *((_DWORD *)v1 + 615)  = 0;
    *((unsigned char *)v1 + 2520)  = 0;
    *((_DWORD *)v1 + 631)  = 0;
    *((_DWORD *)v1 + 632)  = 0;
    *((_DWORD *)v1 + 633)  = 0;
    *((unsigned char *)v1 + 2552)  = 0;
    *((void *)v1 + 320)  = 0;
    *((void *)v1 + 321)  = 0;
    *((void *)v1 + 322)  = 0;
    *((void *)v1 + 323)  = 0;
    *((void *)v1 + 324)  = 0;
    *((_DWORD *)v1 + 650)  = 0;
  }
  return v1;
}

float _CFXInitStats(uint64_t a1)
{
  __memset_chk();
  *(void *)(a1 + 32)  = 0x404E000000000000;
  *(_DWORD *)a1  = -1;
  float result = 5.0;
  *(float *)(a1 + 44)  = 5.0;
  return result;
}

double _CFXClearReport(uint64_t a1)
{
  if (a1)
  {
    __memset_chk();
    uint64_t v2 = mach_absolute_time();
    *(void *)(a1 + 1016)  = v2;
    *(void *)(a1 + 1232)  = v2;
    *(_DWORD *)(a1 + 1228)  = *(_DWORD *)(a1 + 224);
    *(double *)(a1 + 1640)  = (double)v2;
    if (*(void *)(a1 + 104) && **(float **)(a1 + 104) > 0.0) {
      *(unsigned char *)(a1 + 1648)  = 1;
    }
    *(double *)(a1 + 1744)  = (double)v2;
    if (*(void *)(a1 + 96))
    {
      *(_DWORD *)(a1 + 1736)  = (int)(float)(**(float **)(a1 + 96) * 10.0);
      if (*(int *)(a1 + 1736) > 9) {
        *(_DWORD *)(a1 + 1736)  = 9;
      }
    }
    double result = (double)v2;
    *(double *)(a1 + 1776)  = (double)v2;
    *(void *)(a1 + 1616)  = v2;
  }
  return result;
}

void _CFXReleaseTwilightNightShiftAdaptation(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 2552))
  {
    if (*(void *)(a1 + 2568)) {
      free(*(void **)(a1 + 2568));
    }
    if (*(void *)(a1 + 2584)) {
      free(*(void **)(a1 + 2584));
    }
    if (*(void *)(a1 + 2592)) {
      free(*(void **)(a1 + 2592));
    }
  }
}

void CFXRelease(void **a1)
{
  if (a1)
  {
    _CFXClearStats((uint64_t)(a1 + 95));
    if (a1[12])
    {
      if (*((void *)a1[12] + 7)) {
        free(*((void **)a1[12] + 7));
      }
      if (*((void *)a1[12] + 12)) {
        free(*((void **)a1[12] + 12));
      }
      if (*((void *)a1[12] + 17)) {
        free(*((void **)a1[12] + 17));
      }
      free(a1[12]);
      _CFXCloseLog((uint64_t)a1);
    }
    if (a1[13]) {
      free(a1[13]);
    }
    _CFXReleaseTwilightNightShiftAdaptation((uint64_t)a1);
    free(a1);
  }
}

float _CFXClearStats(uint64_t a1)
{
  for (int i = *(void **)(a1 + 8); i; int i = v2)
  {
    uint64_t v2 = (void *)i[1];
    free(i);
  }
  *(void *)(a1 + 16)  = 0;
  *(void *)(a1 + 8)  = 0;
  *(_DWORD *)(a1 + 24)  = 0;
  *(_DWORD *)a1  = -1;
  *(_DWORD *)(a1 + 40)  = 0;
  float result = 5.0;
  *(float *)(a1 + 44)  = 5.0;
  return result;
}

void _CFXCloseLog(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 1808)) {
      _CFXCommitLog((FILE *)a1);
    }
    free(*(void **)(a1 + 1808));
  }
}

uint64_t CFXInstallCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    *(void *)(result + 328)  = a2;
    *(void *)(result + 336)  = a3;
  }
  return result;
}

void CFXSetWhitePointType(_DWORD *a1, int a2)
{
  if (a2 == 1)
  {
    __memcpy_chk();
    a1[23]  = 1170948096;
    a1[529]  = 1050680396;
    a1[530]  = 1051226834;
    __memcpy_chk();
    __memcpy_chk();
    __memcpy_chk();
    a1[531]  = 1170948096;
    __memcpy_chk();
    syslog(7, "D65 whitepoint");
  }
  else
  {
    syslog(7, "Legacy whitepoint");
  }
}

uint64_t CFXGetCurrentMatrix(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  char v4 = 0;
  if (a1)
  {
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_2_4_0_8_0((uint64_t)v5, *(unsigned char *)(*(void *)(a1 + 96) + 184) & 1, COERCE__INT64(**(float **)(a1 + 96)));
      _os_log_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_INFO, "ctx->harmony->adaptationEnabled: %i ctx->harmony->strength: %f", v5, 0x12u);
    }
    __memcpy_chk();
    char v4 = 1;
  }
  return v4 & 1;
}

uint64_t CFXSetABShift(uint64_t a1, _DWORD *a2)
{
  char v3 = 0;
  if (a1)
  {
    if (*(void *)(a1 + 96))
    {
      if (a2)
      {
        *(_DWORD *)(*(void *)(a1 + 96) + 292)  = *a2;
        *(_DWORD *)(*(void *)(a1 + 96) + 296)  = a2[1];
        char v3 = 1;
        *(unsigned char *)(*(void *)(a1 + 96) + 300)  = 1;
        if (*(void *)(a1 + 328)) {
          (*(void (**)(void, void))(a1 + 328))(*(void *)(a1 + 336), 0);
        }
      }
    }
  }
  return v3 & 1;
}

uint64_t CFXGetABShift(uint64_t a1, _DWORD *a2)
{
  char v3 = 0;
  if (a1 && *(void *)(a1 + 96) && a2)
  {
    *a2  = *(_DWORD *)(*(void *)(a1 + 96) + 292);
    a2[1]  = *(_DWORD *)(*(void *)(a1 + 96) + 296);
    char v3 = 1;
  }
  return v3 & 1;
}

uint64_t CFXGetMagicCoeff(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 112))
  {
    for (int i = 0; i < 6; ++i)
      *(_DWORD *)(a2 + 4 * i)  = *(_DWORD *)(*(void *)(a1 + 112) + 4 * i);
    char v4 = 1;
  }
  else
  {
    char v4 = 0;
  }
  return v4 & 1;
}

uint64_t CFXSetMagicCoeff(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (a2) {
      return __memcpy_chk();
    }
    else {
      *(void *)(result + 112)  = 0;
    }
  }
  return result;
}

uint64_t CFXColorRampEnableLogging(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 1800)  = a2 & 1;
  }
  return result;
}

uint64_t CFXInitializeAmbientAdaptation(uint64_t a1)
{
  char v6 = 0;
  if (!*(void *)(a1 + 96))
  {
    *(void *)(a1 + 96)  = malloc_type_malloc(0x158uLL, 0x10E004084D8D114uLL);
    if (*(void *)(a1 + 96))
    {
      __memset_chk();
      uint64_t v4 = *(void *)(a1 + 96);
      *(_DWORD *)uint64_t v4 = 0;
      *(_DWORD *)(v4 + 152)  = 994352038;
      *(_DWORD *)(v4 + 156)  = 1024416809;
      *(_DWORD *)(v4 + 180)  = 1114636288;
      *(float *)(v4 + 176)  = 20.0;
      *(float *)(v4 + 160)  = 5.0;
      *(float *)(v4 + 164)  = 5.0;
      *(float *)(v4 + 168)  = 5.0;
      *(float *)(v4 + 172)  = 5.0;
      *(float *)(v4 + 188)  = 2.0;
      *(_DWORD *)(v4 + 148)  = 18;
      *(void *)(v4 + 40)  = "k+OA";
      *(void *)(v4 + 48)  = &defaultPolygonLarge;
      *(void *)(v4 + 64)  = &AggressiveLUT_x;
      *(_DWORD *)(v4 + 72)  = 29;
      *(void *)(v4 + 80)  = &AggressiveLUT_y;
      *(_DWORD *)(v4 + 88)  = 55;
      *(void *)(v4 + 96)  = malloc_type_malloc(8 * *(int *)(v4 + 88), 0x80040B8603338uLL);
      if (*(void *)(v4 + 96))
      {
        for (int i = 0; i < *(_DWORD *)(v4 + 88); ++i)
          *(void *)(*(void *)(v4 + 96) + 8 * i)  = (char *)&AggressiveLUT + 116 * i;
      }
      *(void *)(v4 + 104)  = &RelaxedLUT_x;
      *(_DWORD *)(v4 + 112)  = 29;
      *(void *)(v4 + 120)  = &RelaxedLUT_y;
      *(_DWORD *)(v4 + 128)  = 55;
      *(void *)(v4 + 136)  = malloc_type_malloc(8 * *(int *)(v4 + 128), 0x80040B8603338uLL);
      if (*(void *)(v4 + 136))
      {
        for (int j = 0; j < *(_DWORD *)(v4 + 128); ++j)
          *(void *)(*(void *)(v4 + 136) + 8 * j)  = (char *)&RelaxedLUT + 116 * j;
      }
      *(unsigned char *)(v4 + 144)  = 1;
      *(unsigned char *)(v4 + 145)  = 1;
      *(float *)(v4 + 192)  = 10.0;
      *(float *)(v4 + 196)  = 15.0;
      *(float *)(v4 + 200)  = 25.0;
      *(_DWORD *)(v4 + 204)  = 1108082688;
      *(_DWORD *)(v4 + 208)  = 1167867904;
      *(_DWORD *)(v4 + 212)  = 1053027365;
      *(_DWORD *)(v4 + 216)  = 1053093869;
      __memcpy_chk();
      *(_DWORD *)(a1 + 92)  = 1170948096;
      *(_DWORD *)(a1 + 2116)  = 1050680396;
      *(_DWORD *)(a1 + 2120)  = 1051226834;
      __memcpy_chk();
      __memcpy_chk();
      __memcpy_chk();
      *(_DWORD *)(a1 + 2124)  = 1170948096;
      __memcpy_chk();
      *(_DWORD *)(v4 + 224)  = 0;
      *(_DWORD *)(v4 + 228)  = 1045220557;
      *(_DWORD *)(v4 + 232)  = 1045220557;
      *(_DWORD *)(v4 + 236)  = 1036831949;
      *(_DWORD *)(v4 + 240)  = 1036831949;
      *(_DWORD *)(v4 + 244)  = 1036831949;
      *(_DWORD *)(v4 + 248)  = 1;
      *(float *)(v4 + 252)  = 1.0;
      char v6 = 1;
      _CFXInitializeLog(a1);
      CFXEnableFades(a1, 1);
      *(unsigned char *)(v4 + 288)  = 1;
      *(unsigned char *)(a1 + 344)  = 1;
      *(_DWORD *)(v4 + 292)  = 0;
      *(_DWORD *)(v4 + 296)  = 0;
      *(unsigned char *)(v4 + 301)  = 0;
      *(unsigned char *)(v4 + 328)  = 1;
      *(_DWORD *)(v4 + 332)  = 1049247089;
      *(_DWORD *)(v4 + 336)  = 1049247089;
      *(_DWORD *)(v4 + 340)  = 1049247089;
      *(float *)(v4 + 308)  = fminf(*(float *)v4, *(float *)(v4 + 332));
    }
  }
  return v6 & 1;
}

uint64_t _CFXInitializeLog(uint64_t a1)
{
  *(void *)(a1 + 1808)  = 0;
  *(_DWORD *)(a1 + 1816)  = 0;
  uint64_t result = __memset_chk();
  *(unsigned char *)(a1 + 2076)  = 0;
  *(_DWORD *)(a1 + 2104)  = 0;
  return result;
}

float CFXEnableFades(uint64_t a1, char a2)
{
  if ((a2 & 1) != (*(unsigned char *)(a1 + 364) & 1))
  {
    *(unsigned char *)(a1 + 364)  = a2 & 1;
    if (a2)
    {
      _CFXIdentity((float *)(a1 + 496));
      _CFXIdentity((float *)(a1 + 460));
      _CFXIdentity((float *)(a1 + 388));
      _CFXIdentity((float *)(a1 + 424));
      *(unsigned char *)(a1 + 384)  = 1;
      _CFXIdentity((float *)(a1 + 628));
      _CFXIdentity((float *)(a1 + 556));
      float result = _CFXIdentity((float *)(a1 + 592));
      *(unsigned char *)(a1 + 552)  = 1;
      if (*(void *)(a1 + 96))
      {
        *(unsigned char *)(*(void *)(a1 + 96) + 272)  = 1;
        float result = **(float **)(a1 + 96);
        *(float *)(*(void *)(a1 + 96) + 276)  = result;
        *(float *)(*(void *)(a1 + 96) + 280)  = result;
        *(float *)(*(void *)(a1 + 96) + 284)  = result;
      }
    }
  }
  return result;
}

float CFXSetStrengthRampTweakFactor(uint64_t a1, float result)
{
  if (a1)
  {
    if (*(void *)(a1 + 96)) {
      *(float *)(*(void *)(a1 + 96) + 252)  = result;
    }
  }
  return result;
}

float CFXGetStrengthRampTweakFactor(uint64_t a1)
{
  float v2 = -1.0;
  if (a1 && *(void *)(a1 + 96)) {
    return *(float *)(*(void *)(a1 + 96) + 252);
  }
  return v2;
}

uint64_t CFXGetAdaptationModesMapping(uint64_t a1, uint64_t a2, int a3)
{
  char v4 = 0;
  if (a1 && *(void *)(a1 + 96) && a2 && a3 >= 6)
  {
    __memcpy_chk();
    char v4 = 1;
  }
  return v4 & 1;
}

uint64_t CFXSetAdaptationModesMapping(uint64_t a1, uint64_t a2, int a3)
{
  char v4 = 0;
  if (a1 && *(void *)(a1 + 96) && a2 && a3 >= 6)
  {
    __memcpy_chk();
    char v4 = 1;
  }
  return v4 & 1;
}

void CFXSetAmbientAdaptationMode(uint64_t a1, unsigned int a2, float a3)
{
  if (a1 && *(void *)(a1 + 96))
  {
    float v4 = _CFXGetStrengthFromMode(a1, a2);
    if (*(unsigned char *)(*(void *)(a1 + 96) + 184))
    {
      *(float *)&CFAbsoluteTime v3 = v4;
      CFXSetAmbientAdaptationStrength(a1, v3, a3);
    }
    *(_DWORD *)(*(void *)(a1 + 96) + 248)  = a2;
  }
}

CFAbsoluteTime CFXSuspendHarmony(uint64_t a1, char a2, CFAbsoluteTime result)
{
  float v4 = *(float *)&result;
  if (a1 && *(void *)(a1 + 96))
  {
    *(unsigned char *)(*(void *)(a1 + 96) + 301)  = a2 & 1;
    if (a2)
    {
      if (*(unsigned char *)(a1 + 364))
      {
        *(unsigned char *)(*(void *)(a1 + 96) + 272)  = 0;
        *(_DWORD *)(*(void *)(a1 + 96) + 284)  = *(_DWORD *)(*(void *)(a1 + 96) + 280);
        *(_DWORD *)(*(void *)(a1 + 96) + 276)  = 0;
        *(CFAbsoluteTime *)(*(void *)(a1 + 96) + 264)  = CFAbsoluteTimeGetCurrent();
        float result = v4;
        *(double *)(*(void *)(a1 + 96) + 256)  = v4;
        if (*(void *)(a1 + 328)) {
          (*(void (**)(void, void))(a1 + 328))(*(void *)(a1 + 336), 0);
        }
      }
    }
    else
    {
      int v3 = **(_DWORD **)(a1 + 96);
      **(_DWORD **)(a1 + 96)  = 0;
      return CFXSetAmbientAdaptationStrength(a1, COERCE_CFABSOLUTETIME((unint64_t)v3), *(float *)&result);
    }
  }
  return result;
}

void CFXEnableAmbientAdaptation(uint64_t a1, char a2)
{
  char v4 = a2 & 1;
  if (a1 && *(void *)(a1 + 96) && (a2 & 1) != (*(unsigned char *)(*(void *)(a1 + 96) + 184) & 1))
  {
    _CFXClearStats(a1 + 760);
    *(unsigned char *)(*(void *)(a1 + 96) + 184)  = v4 & 1;
    if (v4)
    {
      _CFXSetNativeWhitePointCorrection(a1, 1, 1, *(float *)(*(void *)(a1 + 96) + 188));
      *(float *)&CFAbsoluteTime v2 = _CFXGetStrengthFromMode(a1, *(_DWORD *)(*(void *)(a1 + 96) + 248));
      CFXSetAmbientAdaptationStrength(a1, v2, *(float *)(*(void *)(a1 + 96) + 188));
    }
    _CFXUpdateTarget(a1, (float *)(a1 + 80), 1, 0, *(float *)(*(void *)(a1 + 96) + 188));
    if ((v4 & 1) == 0)
    {
      CFXSetAmbientAdaptationStrength(a1, 0.0, *(float *)(*(void *)(a1 + 96) + 188));
      _CFXSetNativeWhitePointCorrection(a1, 0, 1, *(float *)(*(void *)(a1 + 96) + 188));
    }
  }
}

void _CFXSetNativeWhitePointCorrection(uint64_t a1, char a2, int a3, float a4)
{
  if (*(unsigned char *)(a1 + 2520))
  {
    if (a2) {
      *(_DWORD *)(a1 + 2524) |= a3;
    }
    else {
      *(_DWORD *)(a1 + 2524) &= ~a3;
    }
    double v4 = 1.0;
    if (!*(_DWORD *)(a1 + 2524)) {
      double v4 = 0.0;
    }
    float v5 = v4;
    float v11 = v5;
    if (*(float *)(a1 + 2252) >= 0.0) {
      a4  = *(float *)(a1 + 2252);
    }
    if (v5 == *(float *)(a1 + 2456)) {
      a4  = 0.0;
    }
    if ((a2 & 1) == 0 || (char v9 = 1, *(float *)(a1 + 2452) <= 0.0))
    {
      BOOL v8 = 0;
      if ((a2 & 1) == 0) {
        BOOL v8 = *(float *)(a1 + 2452) == 0.0;
      }
      char v9 = v8;
    }
    double Current = CFAbsoluteTimeGetCurrent();
    if (v9)
    {
      if (*(unsigned char *)(a1 + 2448)) {
        double v7 = 0.0;
      }
      else {
        double v7 = Current - *(float *)(a1 + 2460);
      }
      float v6 = v7;
      a4  = fmaxf(fminf(a4, v6), 0.0);
    }
    if (*(unsigned char *)(a1 + 364))
    {
      syslog(7, "NativeWPMatrixRamp to %f in %fs\n", v11, a4);
      *(unsigned char *)(a1 + 2448)  = 0;
      *(_DWORD *)(a1 + 2460)  = *(_DWORD *)(a1 + 2456);
      *(float *)(a1 + 2452)  = v11;
      *(double *)(a1 + 2432)  = a4;
      *(double *)(a1 + 2440)  = Current;
      if (*(void *)(a1 + 328)) {
        (*(void (**)(void, void))(a1 + 328))(*(void *)(a1 + 336), 0);
      }
    }
  }
}

uint64_t _CFXLogSample(uint64_t a1, char a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t v31 = a1;
  int v19 = 1;
  unsigned __int8 v30 = a2 & 1;
  *(void *)float v29 = 0;
  CFXTristimulus2Chromaticity((float *)(a1 + 80), v29);
  float v37 = (float)(*(float *)(v31 + 156) + *(float *)(v31 + 160)) + *(float *)(v31 + 164);
  float v38 = (float)(*(float *)(v31 + 168) + *(float *)(v31 + 172)) + *(float *)(v31 + 176);
  float v39 = (float)(*(float *)(v31 + 180) + *(float *)(v31 + 184)) + *(float *)(v31 + 188);
  BOOL v28 = 0;
  double v20 = *(double *)(v31 + 136);
  BOOL v28 = v20 - CFAbsoluteTimeGetCurrent() > 0.0;
  calendar  = CFCalendarCopyCurrent();
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  int v35 = 0;
  if (calendar)
  {
    uint64_t v17 = 0;
    at  = CFAbsoluteTimeGetCurrent();
    componentDesc  = "yMdHms";
    CFCalendarDecomposeAbsoluteTime(calendar, at, "yMdHms", &v32, (char *)&v32 + 4, &v33, (char *)&v33 + 4, &v34, (char *)&v34 + 4);
    CFAbsoluteTime v25 = 0.0;
    CFCalendarComposeAbsoluteTime(calendar, &v25, "yMdHms", v32, HIDWORD(v32), v33, HIDWORD(v33), v34, HIDWORD(v34));
    int v35 = (int)((at - v25) * 1000000.0);
    CFRelease(calendar);
  }
  int v15 = 0;
  __sprintf_chk((char *)(v31 + 2077), 0, 0x14uLL, "%04d-%02d-%02d_%02d-%02d-%02d", v32, HIDWORD(v32), v33, HIDWORD(v33), v34, HIDWORD(v34));
  int v24 = 0;
  int v2 = *(_DWORD *)(v31 + 24);
  int v3 = *(_DWORD *)(v31 + 52);
  float v16 = v13;
  int v24 = __sprintf_chk(v36, 0, 0x400uLL, "%04d/%02d/%02d,%02d:%02d:%02d.%06d,%d,%d,", v32, HIDWORD(v32), v33, HIDWORD(v33), v34, HIDWORD(v34), v35, v2, v3);
  for (int i = 0; i < *(_DWORD *)(v31 + 52); ++i)
  {
    int v4 = __sprintf_chk(&v36[v24], 0, 0xFFFFFFFFFFFFFFFFLL, "%.4f,", *(float *)(v31 + 28 + 4 * i));
    v24 += v4;
  }
  float v22 = -1.0;
  unint64_t v21 = 0xBF800000BF800000;
  if (v30)
  {
    float v22 = *(float *)(v31 + 2100);
    unint64_t v21 = *(void *)(v31 + 2108);
  }
  float v14 = v36;
  double v5 = *(float *)(v31 + 4);
  double v6 = *(float *)(v31 + 12);
  double v7 = *(float *)(v31 + 16);
  double v8 = *(float *)(v31 + 20);
  double v9 = *(float *)(v31 + 56);
  double v10 = *(float *)(v31 + 152);
  int v11 = *(_DWORD *)(v31 + 2104);
  v13[18]  = v13;
  __sprintf_chk(&v36[v24], 0, 0xFFFFFFFFFFFFFFFFLL, "%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%d,%.4f,%.4f,%.4f,%.4f,%.4f,%.4f,%d,%f,%d,%s\n", v5, v6, v7, v8, v29[0], v29[1], v9, (v30 ^ 1) & 1, v22, *(float *)&v21, *((float *)&v21 + 1), v37, v38, v39, v28,
    v10,
    v11,
    (const char *)(v31 + 1820));
  uint64_t result = _CFXLogString(v31, v14);
  *(unsigned char *)(v31 + 2076)  = 0;
  *(unsigned char *)(v31 + 1820)  = 0;
  *(_DWORD *)(v31 + 2104)  = 0;
  return result;
}

uint64_t CFXResetAdaptation(uint64_t result, float a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = result;
  if (result
    && (*(void *)(result + 104) && **(float **)(result + 104) > 0.0
     || *(void *)(result + 96) && (*(unsigned char *)(*(void *)(result + 96) + 184) & 1) != 0))
  {
    _CFXIdentity(v4);
    uint64_t result = _CFXSetTarget(v2, v4, 1, 0, 0.0, a2);
    *(unsigned char *)(v2 + 344)  = 1;
    if (*(void *)(v2 + 96)) {
      *(unsigned char *)(*(void *)(v2 + 96) + 220)  = 1;
    }
  }
  return result;
}

uint64_t CFXInitializeBlueLightReduction(uint64_t a1)
{
  char v3 = 0;
  if (!*(void *)(a1 + 104))
  {
    *(void *)(a1 + 104)  = malloc_type_malloc(0x34uLL, 0x1000040CC89259EuLL);
    if (*(void *)(a1 + 104))
    {
      **(_DWORD **)(a1 + 104)  = 0;
      *(float *)(*(void *)(a1 + 104) + 4)  = 2.0;
      *(_DWORD *)(*(void *)(a1 + 104) + 28)  = 1166024704;
      *(_DWORD *)(*(void *)(a1 + 104) + 32)  = 1169915904;
      *(_DWORD *)(*(void *)(a1 + 104) + 36)  = 1160298496;
      *(_DWORD *)(*(void *)(a1 + 104) + 40)  = 1166024704;
      *(void *)(*(void *)(a1 + 104) + 20)  = *(void *)(a1 + 2116);
      CFXChromaticity2Tristimulus((float *)(*(void *)(a1 + 104) + 20), (float *)(*(void *)(a1 + 104) + 8), 150.0);
      *(float *)(*(void *)(a1 + 104) + 44)  = -1.0;
      *(unsigned char *)(*(void *)(a1 + 104) + 48)  = 0;
      char v3 = 1;
    }
  }
  return v3 & 1;
}

uint64_t CFXInitializeTwilightNightShiftAdaptation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(unsigned char *)(a1 + 2552)  = 1;
  *(void *)(a1 + 2560)  = a3;
  *(void *)(a1 + 2568)  = a2;
  *(void *)(a1 + 2576)  = a5;
  *(void *)(a1 + 2584)  = a4;
  *(void *)(a1 + 2592)  = a6;
  return 1;
}

uint64_t CFXEnableBlueLightReduction(uint64_t result, char a2, float a3, float a4)
{
  char v10 = a2 & 1;
  uint64_t v9 = result;
  if (!*(void *)(result + 104)) {
    uint64_t result = CFXInitializeBlueLightReduction(result);
  }
  if (*(void *)(v9 + 104)
    && ((v10 & 1) != 0 || a3 != **(float **)(v9 + 104) || (*(unsigned char *)(*(void *)(v9 + 104) + 48) & 1) != 0))
  {
    if (a3 > 0.0 && (*(unsigned char *)(v9 + 1648) & 1) == 0 || a3 == 0.0 && (*(unsigned char *)(v9 + 1648) & 1) != 0)
    {
      uint64_t v8 = mach_absolute_time();
      double v7 = MachTimeToSeconds((unint64_t)((double)v8 - *(double *)(v9 + 1640)));
      if (*(unsigned char *)(v9 + 1648)) {
        *(double *)(v9 + 1624)  = *(double *)(v9 + 1624) + v7;
      }
      else {
        *(double *)(v9 + 1632)  = *(double *)(v9 + 1632) + v7;
      }
      *(double *)(v9 + 1640)  = (double)v8;
      *(unsigned char *)(v9 + 1648)  = a3 > 0.0;
    }
    **(float **)(v9 + 104)  = a3;
    float v6 = fminf(fmaxf(a3, 0.0), 1.0);
    if (*(float *)(*(void *)(v9 + 104) + 44) >= 0.0) {
      float v6 = *(float *)(*(void *)(v9 + 104) + 44);
    }
    float v4 = (float)(v6 * *(float *)(*(void *)(v9 + 104) + 28)) + (1.0 - v6) * *(float *)(v9 + 2124);
    _CFXCCT2xy_Shifted(v9, (float *)(*(void *)(v9 + 104) + 20), v4);
    CFXChromaticity2Tristimulus((float *)(*(void *)(v9 + 104) + 20), (float *)(*(void *)(v9 + 104) + 8), 150.0);
    if (a4 < 0.0) {
      float v5 = *(float *)(*(void *)(v9 + 104) + 4);
    }
    else {
      float v5 = a4;
    }
    _CFXSetNativeWhitePointCorrection(v9, a3 > 0.0, 2, v5);
    uint64_t result = _CFXUpdateBLRTarget(v9, v5);
    *(unsigned char *)(*(void *)(v9 + 104) + 48)  = 0;
  }
  return result;
}

float _CFXCCT2xy_Shifted(uint64_t a1, float *a2, float a3)
{
  return _CFXCCT2xy_Generic(a3, a1, *(void *)(a1 + 744), *(_DWORD *)(a1 + 752), a2);
}

uint64_t _CFXUpdateBLRTarget(uint64_t a1, float a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  char v3 = *(float **)(a1 + 104);
  _CFXIdentity(v6);
  if (v3 && (*v3 > 0.0 || v3[11] >= 0.0)) {
    _CFXGetTarget(a1, (float *)(*(void *)(a1 + 104) + 8), v6, 0, 0, 0, 0, 1, 1.0);
  }
  return _CFXSetBLRTarget(a1, v6, 1, 1, a2, 1.0);
}

float CFXGetBlueLightReductionTargetCCT(uint64_t a1)
{
  float v2 = 0.0;
  if (a1 && *(void *)(a1 + 104)) {
    return *(float *)(*(void *)(a1 + 104) + 28);
  }
  return v2;
}

float CFXOverrideBlueLightReductionCCTRange(uint64_t a1, float result, float a3, float a4)
{
  if (a1)
  {
    if (*(void *)(a1 + 104))
    {
      *(float *)(*(void *)(a1 + 104) + 36)  = a3;
      *(float *)(*(void *)(a1 + 104) + 32)  = result;
      uint64_t result = a4;
      *(float *)(*(void *)(a1 + 104) + 40)  = a4;
      *(float *)(*(void *)(a1 + 104) + 28)  = a4;
    }
  }
  return result;
}

float CFXGetBlueLightReductionCCTRange(uint64_t a1, _DWORD *a2, _DWORD *a3, float *a4)
{
  if (a1)
  {
    if (*(void *)(a1 + 104))
    {
      *a3  = *(_DWORD *)(*(void *)(a1 + 104) + 36);
      *a2  = *(_DWORD *)(*(void *)(a1 + 104) + 32);
      float result = *(float *)(*(void *)(a1 + 104) + 40);
      *a4  = result;
    }
  }
  return result;
}

uint64_t CFXSetBlueReductionFactorOverride(uint64_t result, float a2, float a3)
{
  uint64_t v7 = result;
  if (result && *(void *)(result + 104))
  {
    *(float *)(*(void *)(result + 104) + 44)  = a2;
    if (a2 >= 0.0) {
      float v5 = a2;
    }
    else {
      float v5 = **(float **)(result + 104);
    }
    float v6 = fminf(fmaxf(v5, 0.0), 1.0);
    float v3 = (float)(v6 * *(float *)(*(void *)(result + 104) + 28)) + (1.0 - v6) * *(float *)(result + 2124);
    _CFXCCT2xy_Shifted(result, (float *)(*(void *)(result + 104) + 20), v3);
    CFXChromaticity2Tristimulus((float *)(*(void *)(v7 + 104) + 20), (float *)(*(void *)(v7 + 104) + 8), 150.0);
    float v4 = fmax(a3, 0.0);
    return _CFXUpdateBLRTarget(v7, v4);
  }
  return result;
}

void CFXSetBlueLightReductionTargetCCT(uint64_t a1, char a2, float a3, float a4, float a5)
{
  char v10 = a2 & 1;
  if (a1 && *(void *)(a1 + 104))
  {
    float v5 = fmax(a3, *(float *)(*(void *)(a1 + 104) + 36));
    *(float *)(*(void *)(a1 + 104) + 28)  = fminf(v5, *(float *)(*(void *)(a1 + 104) + 32));
    float v8 = fminf(fmaxf(**(float **)(a1 + 104), 0.0), 1.0);
    if (a5 == 0.0)
    {
      *(float *)(*(void *)(a1 + 104) + 44)  = -1.0;
    }
    else
    {
      *(float *)(*(void *)(a1 + 104) + 44)  = 1.0;
      float v8 = 1.0;
    }
    float v6 = (float)(v8 * *(float *)(*(void *)(a1 + 104) + 28)) + (1.0 - v8) * *(float *)(a1 + 2124);
    _CFXCCT2xy_Shifted(a1, (float *)(*(void *)(a1 + 104) + 20), v6);
    CFXChromaticity2Tristimulus((float *)(*(void *)(a1 + 104) + 20), (float *)(*(void *)(a1 + 104) + 8), 150.0);
    if (a4 < 0.0) {
      float v7 = *(float *)(*(void *)(a1 + 104) + 4);
    }
    else {
      float v7 = a4;
    }
    if (v10)
    {
      *(unsigned char *)(*(void *)(a1 + 104) + 48)  = 1;
    }
    else
    {
      _CFXSetNativeWhitePointCorrection(a1, a5 != 0.0, 4, v7);
      _CFXUpdateBLRTarget(a1, v7);
    }
  }
}

void CFXCancelColorFade(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  uint64_t v4 = a1;
  if (a1)
  {
    uint64_t v3 = v4 + 368;
    if ((*(unsigned char *)(v4 + 384) & 1) == 0)
    {
      *(unsigned char *)(v3 + 16)  = 1;
      *(void *)uint64_t v3 = 0;
      __memcpy_chk();
      uint64_t v2 = 0;
      int v1 = 0;
      _CFXGetWPFromMatrix(v4, (float *)(v3 + 20), &v2, &v1);
      CFXChromaticity2uv((float *)&v2, v6);
      *(float *)(v4 + 120)  = v6[0];
      *(float *)(v4 + 124)  = v6[1];
    }
  }
}

BOOL _CFXIsIdentity(float *a1)
{
  BOOL v2 = 0;
  if (float_equal(*a1, 1.0))
  {
    BOOL v2 = 0;
    if (float_equal(a1[1], 0.0))
    {
      BOOL v2 = 0;
      if (float_equal(a1[2], 0.0))
      {
        BOOL v2 = 0;
        if (float_equal(a1[3], 0.0))
        {
          BOOL v2 = 0;
          if (float_equal(a1[4], 1.0))
          {
            BOOL v2 = 0;
            if (float_equal(a1[5], 0.0))
            {
              BOOL v2 = 0;
              if (float_equal(a1[6], 0.0))
              {
                BOOL v2 = 0;
                if (float_equal(a1[7], 0.0)) {
                  return float_equal(a1[8], 1.0);
                }
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

float _CFXCorrectForNativeWP(uint64_t a1, float *a2, float a3)
{
  if ((*(unsigned char *)(a1 + 2520) & 1) == 0) {
    return _CFXIdentity(a2);
  }
  float v9 = fminf(fmaxf(a3, 0.0), 1.0);
  float result = 1.0 - v9;
  float v8 = result;
  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < 3; ++j)
    {
      double v4 = 1.0;
      if (i != j) {
        double v4 = 0.0;
      }
      float v5 = v4;
      float result = (float)(v8 * v5) + (float)(v9 * *(float *)(a1 + 2472 + 12 * i + 4 * j));
      a2[3 * i + j]  = result;
    }
  }
  return result;
}

void _CFXGetXYZD50Matrix(uint64_t a1, float *a2, float *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a1;
  float v14 = a2;
  float v13 = a3;
  v12[10]  = v17;
  _CFXGetLMSD50Matrix(a1, a2);
  v12[11]  = v16;
  Mul33MatrixBy33Matrix((uint64_t)v17, (uint64_t)Mcat, (uint64_t)v16);
  Mul33MatrixBy33Matrix((uint64_t)&InvMcat, (uint64_t)v16, (uint64_t)v13);
  double v3 = *v13;
  double v4 = v13[1];
  double v5 = v13[2];
  double v6 = v13[3];
  double v7 = v13[4];
  double v8 = v13[5];
  double v9 = v13[6];
  double v10 = v13[7];
  double v11 = v13[8];
  v12[12]  = v12;
  syslog(7, "XYZD50M  = %f %f %f; %f %f %f; %f %f %f\n", v3, v4, v5, v6, v7, v8, v9, v10, v11);
}

void _CFXGetsRGBD50Matrix(uint64_t a1, float *a2, float *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a1;
  uint64_t v15 = a2;
  float v14 = a3;
  v13[10]  = v21;
  _CFXGetLMSD50Matrix(a1, a2);
  v13[11]  = v20;
  Mul33MatrixBy33Matrix((uint64_t)v21, v16 + 2144, (uint64_t)v20);
  Mul33MatrixBy33Matrix(v16 + 2180, (uint64_t)v20, (uint64_t)v14);
  v19[2]  = 1.0;
  v19[1]  = 1.0;
  v19[0]  = 1.0;
  v13[12]  = &v17;
  uint64_t v17 = 0;
  int v18 = 0;
  Mul33MatrixBy31Vector(v14, v19, (float *)&v17);
  v13[13]  = v14;
  float v3 = MaxOfVector((float *)&v17);
  Div33MatrixByScalar((uint64_t)v14, (uint64_t)v14, v3);
  double v4 = *v14;
  double v5 = v14[1];
  double v6 = v14[2];
  double v7 = v14[3];
  double v8 = v14[4];
  double v9 = v14[5];
  double v10 = v14[6];
  double v11 = v14[7];
  double v12 = v14[8];
  v13[14]  = v13;
  syslog(7, "sRGBD50M  = %f %f %f; %f %f %f; %f %f %f\n", v4, v5, v6, v7, v8, v9, v10, v11, v12);
}

void _CFXGetXYZMatrixWithLMSIlluminant(uint64_t a1, float *a2, float *a3, float *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  float v14 = a4;
  float v13[9] = v19;
  _CFXGetLMSMatrixWithLMSIlluminant(a1, a2, a3);
  v13[10]  = v18;
  Mul33MatrixBy33Matrix((uint64_t)v19, (uint64_t)Mcat, (uint64_t)v18);
  Mul33MatrixBy33Matrix((uint64_t)&InvMcat, (uint64_t)v18, (uint64_t)v14);
  double v4 = *v14;
  double v5 = v14[1];
  double v6 = v14[2];
  double v7 = v14[3];
  double v8 = v14[4];
  double v9 = v14[5];
  double v10 = v14[6];
  double v11 = v14[7];
  double v12 = v14[8];
  v13[11]  = v13;
  syslog(7, "XYZM  = %f %f %f; %f %f %f; %f %f %f\n", v4, v5, v6, v7, v8, v9, v10, v11, v12);
}

void _CFXGetsRGBMatrixWithLMSIlluminant(uint64_t a1, float *a2, float *a3, float *a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a1;
  uint64_t v17 = a2;
  uint64_t v16 = a3;
  uint64_t v15 = a4;
  v14[9]  = v23;
  _CFXGetLMSMatrixWithLMSIlluminant(a1, a2, a3);
  v14[10]  = v22;
  Mul33MatrixBy33Matrix((uint64_t)v23, v18 + 2144, (uint64_t)v22);
  Mul33MatrixBy33Matrix(v18 + 2180, (uint64_t)v22, (uint64_t)v15);
  v21[2]  = 1.0;
  v21[1]  = 1.0;
  v21[0]  = 1.0;
  v14[11]  = &v19;
  uint64_t v19 = 0;
  int v20 = 0;
  Mul33MatrixBy31Vector(v15, v21, (float *)&v19);
  v14[12]  = v15;
  float v4 = MaxOfVector((float *)&v19);
  Div33MatrixByScalar((uint64_t)v15, (uint64_t)v15, v4);
  double v5 = *v15;
  double v6 = v15[1];
  double v7 = v15[2];
  double v8 = v15[3];
  double v9 = v15[4];
  double v10 = v15[5];
  double v11 = v15[6];
  double v12 = v15[7];
  double v13 = v15[8];
  v14[13]  = v14;
  syslog(7, "sRGBM  = %f %f %f; %f %f %f; %f %f %f\n", v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

double CFXClearReport(uint64_t a1)
{
  if (a1) {
    return _CFXClearReport(a1);
  }
  return result;
}

double CFXGetReport(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    uint64_t v20 = mach_absolute_time();
    double v2 = MachTimeToSeconds(v20 - *(void *)(a1 + 1016));
    float v3 = (double *)(a1 + 808 + 8 * *(int *)(a1 + 1012));
    *float v3 = *v3 + v2;
    double v4 = MachTimeToSeconds(v20 - *(void *)(a1 + 1232));
    double v5 = (double *)(a1 + 1024 + 8 * *(int *)(a1 + 1228));
    *double v5 = *v5 + v4;
    double v6 = MachTimeToSeconds(v20 - *(void *)(a1 + 1616));
    double v7 = (double *)(a1 + 1240 + 8 * *(int *)(a1 + 1608));
    *double v7 = *v7 + v6;
    double v18 = MachTimeToSeconds((unint64_t)((double)v20 - *(double *)(a1 + 1640)));
    if (*(unsigned char *)(a1 + 1648)) {
      *(double *)(a1 + 1624)  = *(double *)(a1 + 1624) + v18;
    }
    else {
      *(double *)(a1 + 1632)  = *(double *)(a1 + 1632) + v18;
    }
    if (*(void *)(a1 + 96) && (*(unsigned char *)(*(void *)(a1 + 96) + 184) & 1) != 0)
    {
      double v8 = MachTimeToSeconds((unint64_t)((double)v20 - *(double *)(a1 + 1744)));
      double v9 = (double *)(a1 + 1656 + 8 * *(int *)(a1 + 1736));
      *double v9 = *v9 + v8;
    }
    double v19 = MachTimeToSeconds((unint64_t)((double)v20 - *(double *)(a1 + 1776)));
    *(double *)(a1 + 1752)  = *(double *)(a1 + 1752) + v19;
    *(double *)(a1 + 1760)  = *(double *)(a1 + 1760) + v19 * *(float *)(a1 + 1788);
    *(double *)(a1 + 1768)  = *(double *)(a1 + 1768) + v19 * *(float *)(a1 + 1784);
    if (*(void *)(a1 + 104)) {
      *(_DWORD *)(a1 + 1652)  = *(_DWORD *)(*(void *)(a1 + 104) + 28);
    }
    __memcpy_chk();
    int v17 = *(_DWORD *)(a1 + 1012);
    int v16 = *(_DWORD *)(a1 + 1228);
    int v15 = *(_DWORD *)(a1 + 1736);
    int v14 = *(_DWORD *)(a1 + 1608);
    char v13 = *(unsigned char *)(a1 + 1648) & 1;
    int v12 = *(_DWORD *)(a1 + 1788);
    int v11 = *(_DWORD *)(a1 + 1784);
    __memset_chk();
    *(void *)(a1 + 1016)  = v20;
    *(_DWORD *)(a1 + 1012)  = v17;
    *(void *)(a1 + 1232)  = v20;
    *(_DWORD *)(a1 + 1228)  = v16;
    *(double *)(a1 + 1640)  = (double)v20;
    *(unsigned char *)(a1 + 1648)  = v13 & 1;
    *(_DWORD *)(a1 + 1736)  = v15;
    *(double *)(a1 + 1744)  = (double)v20;
    *(_DWORD *)(a1 + 1788)  = v12;
    *(_DWORD *)(a1 + 1784)  = v11;
    double result = (double)v20;
    *(double *)(a1 + 1776)  = (double)v20;
    *(void *)(a1 + 1616)  = v20;
    *(_DWORD *)(a1 + 1608)  = v14;
  }
  return result;
}

double CFXUpdateCompensatedBacklight(uint64_t a1, float a2)
{
  uint64_t v2 = mach_absolute_time();
  *(float *)&double v3 = a2;
  return _CFXUpdateCompensatedBacklight(a1, v2, v3);
}

float CFXOverrideRampPeriod(uint64_t a1, float result)
{
  if (a1) {
    *(float *)(a1 + 2252)  = result;
  }
  return result;
}

uint64_t CFXGetLuxThreshold(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  if (a1 && a2 < 4)
  {
    *a3  = *(_DWORD *)(*(void *)(a1 + 96) + 192 + 4 * a2);
    char v4 = 1;
  }
  else
  {
    char v4 = 0;
  }
  return v4 & 1;
}

void CFXInitAmmolite(uint64_t a1, io_registry_entry_t a2)
{
  if (!CFXAmmoliteEnabled(a1))
  {
    syslog(7, "CFXInitAmmolite() - proceeding with enablement");
    if (*(void *)(a1 + 2256)) {
      __assert_rtn("CFXInitAmmolite", "ColorEffects.c", 3774, "cfx->ammolite == NULL");
    }
    *(void *)(a1 + 2256)  = CFXAmmoliteCreate(a2, a1 + 2264);
    if (CFXAmmoliteEnabled(a1)) {
      _CFXUpdateTarget(a1, (float *)(a1 + 80), 1, 0, *(float *)(*(void *)(a1 + 2256) + 40));
    }
  }
}

BOOL CFXAmmoliteEnabled(uint64_t a1)
{
  return *(void *)(a1 + 2256) != 0;
}

void CFXAmmoliteDisable(uint64_t a1)
{
  if (CFXAmmoliteEnabled(a1))
  {
    syslog(7, "CFXAmmoliteDisable() - proceeding with disablement");
    _CFXUpdateTarget(a1, (float *)(a1 + 80), 1, 0, *(float *)(*(void *)(a1 + 2256) + 40));
    *(unsigned char *)(a1 + 2280)  = 0;
    _CFXIdentity((float *)(a1 + 2284));
    __memcpy_chk();
    *(double *)(a1 + 2264)  = *(float *)(*(void *)(a1 + 2256) + 40);
    *(CFAbsoluteTime *)(a1 + 2272)  = CFAbsoluteTimeGetCurrent();
  }
  CFXAmmoliteFree(*(void *)(a1 + 2256));
  *(void *)(a1 + 2256)  = 0;
}

void CFXSetNativeWhitePoint(uint64_t a1, _DWORD *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a1;
  double v18 = a2;
  uint64_t v17 = a1;
  if (a1)
  {
    if (v18)
    {
      *(_DWORD *)(v17 + 2464)  = *v18;
      *(_DWORD *)(v17 + 2468)  = v18[1];
      char v13 = &v24;
      uint64_t v24 = 0;
      int v25 = 0;
      int v16 = (float *)&v22;
      uint64_t v22 = 0;
      int v23 = 0;
      float v12 = 1.0;
      CFXChromaticity2Tristimulus((float *)(v17 + 2116), (float *)&v24, 1.0);
      CFXChromaticity2Tristimulus((float *)(v17 + 2464), (float *)&v22, 1.0);
      int v14 = &v20;
      uint64_t v20 = 0;
      int v21 = 0;
      CFXTristimulus2lms((float *)&v22, (float *)&v20);
      _CFXGetMatrix(v17, (float *)&v24, v17 + 2472, (float *)&v20);
      double v2 = *(float *)(v17 + 2472);
      double v3 = *(float *)(v17 + 2476);
      double v4 = *(float *)(v17 + 2480);
      double v5 = *(float *)(v17 + 2484);
      double v6 = *(float *)(v17 + 2488);
      double v7 = *(float *)(v17 + 2492);
      double v8 = *(float *)(v17 + 2496);
      double v9 = *(float *)(v17 + 2500);
      double v10 = *(float *)(v17 + 2504);
      int v15 = &v11;
      syslog(7, "NativeWPMatrix  = %f %f %f; %f %f %f; %f %f %f\n", v2, v3, v4, v5, v6, v7, v8, v9, v10);
      Mul33MatrixBy31Vector(InvMrgb2xyzD65, v16, (float *)(v17 + 2508));
      *(unsigned char *)(v17 + 2520)  = 1;
    }
  }
}

void CFXSetOutputFormat(uint64_t a1, int a2, int a3, float *a4)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(_DWORD *)(a1 + 2528)  = a2;
    *(_DWORD *)(a1 + 2532)  = a3;
    if (a3 == 2)
    {
      if (a4)
      {
        uint64_t v5 = 0;
        float v6 = 0.0;
        CFXChromaticity2Tristimulus(a4, (float *)&v5, 1.0);
        CFXTristimulus2lms((float *)&v5, (float *)(a1 + 2536));
        syslog(7, "Custom Illuminant XYZ  = (%f, %f, %f), LMS  = (%f, %f, %f)\n", *(float *)&v5, *((float *)&v5 + 1), v6, *(float *)(a1 + 2536), *(float *)(a1 + 2540), *(float *)(a1 + 2544));
      }
    }
  }
}

uint64_t CFXEnableMitigations(uint64_t result, char a2)
{
  if (result)
  {
    if (*(void *)(result + 96)) {
      *(unsigned char *)(*(void *)(result + 96) + 303)  = a2 & 1;
    }
  }
  return result;
}

float CFXGetAdaptationStrength(uint64_t a1)
{
  if (a1 && *(void *)(a1 + 96)) {
    return *(float *)(*(void *)(a1 + 96) + 308);
  }
  else {
    return 0.0;
  }
}

float CFXEnableOverrides(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    char v5 = 0;
    if (a2)
    {
      char v5 = *(unsigned char *)(a2 + 1) & 1;
      if (v5)
      {
        if (*(void *)(a1 + 96))
        {
          uint64_t v4 = *(void *)(a1 + 96);
          *(_DWORD *)(v4 + 180)  = *(_DWORD *)(a2 + 4);
          *(_DWORD *)(v4 + 176)  = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(v4 + 160)  = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(v4 + 164)  = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(v4 + 168)  = *(_DWORD *)(a2 + 12);
          float result = *(float *)(a2 + 12);
          *(float *)(v4 + 172)  = result;
        }
      }
    }
    if ((v5 & 1) == 0)
    {
      if (*(void *)(a1 + 96))
      {
        uint64_t v3 = *(void *)(a1 + 96);
        *(_DWORD *)(v3 + 180)  = 1114636288;
        *(float *)(v3 + 176)  = 20.0;
        float result = 5.0;
        *(float *)(v3 + 160)  = 5.0;
        *(float *)(v3 + 164)  = 5.0;
        *(float *)(v3 + 168)  = 5.0;
        *(float *)(v3 + 172)  = 5.0;
      }
    }
  }
  return result;
}

float CFXGetTwilightStrength(uint64_t a1)
{
  return *(float *)(a1 + 2600);
}

uint64_t CFXSetTwilightStrength(uint64_t result, float a2)
{
  *(float *)(result + 2600)  = a2;
  return result;
}

uint64_t _CFXLogString(uint64_t result, const char *a2)
{
  uint64_t v4 = result;
  if (result)
  {
    if (!*(void *)(result + 1808))
    {
      *(void *)(result + 1808)  = malloc_type_malloc(0x32000uLL, 0xAFD7CAA4uLL);
      *(_DWORD *)(v4 + 1816)  = 0;
      mkdir("/var/mobile/Library/Logs/CrashReporter/harmony", 0x1EDu);
    }
    int v2 = strlen(a2);
    if (v2 + *(_DWORD *)(v4 + 1816) > 204800) {
      _CFXCommitLog((FILE *)v4);
    }
    float result = __memcpy_chk();
    *(_DWORD *)(v4 + 1816) += v2;
  }
  return result;
}

float _CFXCCT2xy_Generic(float a1, uint64_t a2, uint64_t a3, int a4, float *a5)
{
  int v9 = a4 / 3;
  for (int i = 0; i < v9 && a1 > *(float *)(a3 + 4 * i); ++i)
    ;
  if (i == v9)
  {
    float v11 = *(float *)(a3 + 4 * (2 * v9 - 1));
    float v10 = *(float *)(a3 + 4 * (3 * v9 - 1));
  }
  else if (i)
  {
    float v7 = *(float *)(a3 + 4 * i);
    float v6 = *(float *)(a3 + 4 * (i - 1));
    float v11 = (float)((float)((float)(a1 - v7) / (float)(v6 - v7)) * *(float *)(a3 + 4 * (i - 1 + v9)))
        + (float)((float)(1.0 - (float)((float)(a1 - v7) / (float)(v6 - v7))) * *(float *)(a3 + 4 * (i + v9)));
    float v10 = (float)((float)((float)(a1 - v7) / (float)(v6 - v7)) * *(float *)(a3 + 4 * (i - 1 + 2 * v9)))
        + (float)((float)(1.0 - (float)((float)(a1 - v7) / (float)(v6 - v7))) * *(float *)(a3 + 4 * (i + 2 * v9)));
  }
  else
  {
    float v11 = *(float *)(a3 + 4 * v9);
    float v10 = *(float *)(a3 + 8 * v9);
  }
  *a5  = v11;
  float result = v10;
  a5[1]  = v10;
  return result;
}

uint64_t _CFXSetBLRTarget(uint64_t a1, float *a2, char a3, char a4, float a5, float a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a1;
  unint64_t v27 = a2;
  float v26 = a5;
  char v25 = a3 & 1;
  char v24 = a4 & 1;
  float v23 = a6;
  if (*(float *)(a1 + 2252) >= 0.0) {
    float v26 = *(float *)(v28 + 2252);
  }
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v21 = mach_absolute_time();
  if (*(unsigned char *)(v28 + 364))
  {
    memcpy(__dst, v27, sizeof(__dst));
  }
  else
  {
    if (*(void *)(v28 + 112))
    {
      _CFXMagic(v27, __dst, *(float **)(v28 + 112));
      v33[2]  = 1.0;
      v33[1]  = 1.0;
      v33[0]  = 1.0;
      uint64_t v31 = 0;
      int v32 = 0;
      Mul33MatrixBy31Vector(__dst, v33, (float *)&v31);
      float v6 = MaxOfVector((float *)&v31);
      Div33MatrixByScalar((uint64_t)__dst, (uint64_t)__dst, v6);
    }
    else
    {
      memcpy(__dst, v27, sizeof(__dst));
    }
    int v20 = 0;
    *(void *)uint64_t v19 = 0;
    float v18 = 0.0;
    _CFXGetWPFromMatrix(v28, __dst, v19, &v18);
    float v7 = 1.0 / v18;
    *(float *)(v28 + 2140)  = v7;
    uint64_t v29 = 0;
    int v30 = 0;
    CFXChromaticity2Tristimulus(v19, (float *)&v29, 100.0);
    uint64_t v16 = 0;
    int v17 = 0;
    CFXTristimulus2Lab((float *)&v29, (float *)&v16);
    int v20 = binFromAb((float *)&v16 + 1);
    if (v20 != *(_DWORD *)(v28 + 1228))
    {
      double v15 = 0.0;
      double v15 = MachTimeToSeconds(v21 - *(void *)(v28 + 1232));
      int v9 = (double *)(v28 + 1024 + 8 * *(int *)(v28 + 1228));
      double v8 = *v9 + v15;
      *int v9 = v8;
      *(void *)(v28 + 1232)  = v21;
      *(_DWORD *)(v28 + 1228)  = v20;
      *(_DWORD *)(v28 + 320)  = v20;
    }
    LODWORD(v8)  = *(_DWORD *)(v28 + 1784);
    _CFXUpdateCompensatedBacklight(v28, v21, v8);
  }
  *(_DWORD *)(v28 + 288)  = 9;
  __memcpy_chk();
  __memcpy_chk();
  __memcpy_chk();
  int v14 = 0;
  _CFXGetWPFromMatrix(v28, __dst, (void *)(v28 + 296), &v14);
  *(float *)(v28 + 248)  = v26;
  *(float *)(v28 + 292)  = 1.0;
  *(unsigned char *)(v28 + 240)  = 0;
  *(double *)(v28 + 232)  = Current + v26;
  char v13 = 0;
  if (*(unsigned char *)(v28 + 364))
  {
    __memcpy_chk();
    __memcpy_chk();
    *(double *)(v28 + 536)  = *(float *)(v28 + 248);
    *(double *)(v28 + 544)  = Current;
    char v13 = 1;
    *(unsigned char *)(v28 + 552)  = 0;
  }
  if (*(void *)(v28 + 328))
  {
    float v11 = *(void (**)(uint64_t, uint64_t))(v28 + 328);
    uint64_t v12 = *(void *)(v28 + 336);
    if (v13) {
      v11(v12, 0);
    }
    else {
      v11(v12, v28 + 248);
    }
  }
  return 1;
}

uint64_t _CFXGetLMSMatrixWithLMSIlluminant(uint64_t a1, float *a2, float *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v8 = 0;
  int v9 = 0;
  CFXChromaticity2Tristimulus(a2, (float *)&v10, 1.0);
  CFXTristimulus2lms((float *)&v10, (float *)&v8);
  uint64_t v6 = 0;
  int v7 = 0;
  Div31VectorBy31Vector((float *)&v8, a3, (float *)&v6);
  memset(__b, 0, sizeof(__b));
  __b[4]  = HIDWORD(v6);
  __b[0]  = v6;
  __b[8]  = v7;
  return __memcpy_chk();
}

uint64_t _CFXGetLMSD50Matrix(uint64_t a1, float *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = 0x3F829D7C3F7F0EA2;
  int v4 = 1062305199;
  return _CFXGetLMSMatrixWithLMSIlluminant(a1, a2, (float *)&v3);
}

void StockholmALSCoExEnableNotificationHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  if (a2)
  {
    uint64_t v12 = v16;
    os_log_t oslog = 0;
    if (*(void *)(v16 + 8))
    {
      uint64_t v8 = *(NSObject **)(v12 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v8 = inited;
    }
    os_log_t oslog = v8;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t log = oslog;
      os_log_type_t v6 = type;
      __os_log_helper_16_0_0(v9);
      _os_log_impl(&dword_1BA438000, log, v6, "StockholmCoEx Color samples swallowing ON", v9, 2u);
    }
    *(unsigned char *)(v12 + 288)  = 1;
  }
}

void StockholmALSCoExDisableNotificationHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  if (a2)
  {
    uint64_t v12 = v16;
    os_log_t oslog = 0;
    if (*(void *)(v16 + 8))
    {
      uint64_t v8 = *(NSObject **)(v12 + 8);
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v8 = inited;
    }
    os_log_t oslog = v8;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t log = oslog;
      os_log_type_t v6 = type;
      __os_log_helper_16_0_0(v9);
      _os_log_impl(&dword_1BA438000, log, v6, "StockholmCoEx Color samples swallowing OFF", v9, 2u);
    }
    *(unsigned char *)(v12 + 288)  = 0;
  }
}

uint64_t __os_log_helper_16_2_3_8_66_8_66_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 64;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_64_4_0(uint64_t result, uint64_t a2, int a3)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  return result;
}

void sub_1BA51609C()
{
  _Unwind_Resume(v0);
}

void sub_1BA516480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, _Unwind_Exception *exception_object, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
}

uint64_t __os_log_helper_16_2_4_8_0_4_0_8_64_8_64(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 64;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 64;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  return result;
}

uint64_t __os_log_helper_16_0_3_4_0_4_0_4_0(uint64_t result, int a2, int a3, int a4)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 4;
  *(_DWORD *)(result + 10)  = a3;
  *(unsigned char *)(result + 14)  = 0;
  *(unsigned char *)(result + 15)  = 4;
  *(_DWORD *)(result + 16)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_66_8_66(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  return result;
}

void sub_1BA518E58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, int a19, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v20 - 72), 8);
  _Unwind_Resume(a1);
}

void sub_1BA51BD44(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  *(void *)(v10 - 24)  = a1;
  *(_DWORD *)(v10 - 28)  = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 24));
}

uint64_t __os_log_helper_16_2_3_8_66_8_66_8_66(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 66;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_66_8_64_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 64;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_0_4_4_0_4_0_4_0_4_0(uint64_t result, int a2, int a3, int a4, int a5)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 4;
  *(_DWORD *)(result + 10)  = a3;
  *(unsigned char *)(result + 14)  = 0;
  *(unsigned char *)(result + 15)  = 4;
  *(_DWORD *)(result + 16)  = a4;
  *(unsigned char *)(result + 20)  = 0;
  *(unsigned char *)(result + 21)  = 4;
  *(_DWORD *)(result + 22)  = a5;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_66_4_0(uint64_t result, uint64_t a2, int a3)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  return result;
}

void sub_1BA5204EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

float linearBrightnessToPerceptualBrightness(float a1)
{
  if (a1 < 0.0) {
    return 0.0;
  }
  float v2 = log2f(a1);
  return (float)(v2 / log2f(500.0)) + 1.0;
}

float perceptualBrightnessToLinearBrightness(float a1)
{
  if (a1 == 0.0) {
    return 0.0;
  }
  else {
    return powf(500.0, a1 - 1.0);
  }
}

float AAB::DefaultCurve@<S0>(uint64_t a1@<X0>, int a2@<W1>, char a3@<W2>, float *a4@<X3>, uint64_t a5@<X4>, float *a6@<X5>, uint64_t a7@<X8>, float a8@<S0>, float a9@<S1>, float a10@<S2>)
{
  if (a2)
  {
    if (a2 == 1)
    {
      float v17 = 1.0;
    }
    else if (a2 == 2)
    {
      float v17 = 2.0;
    }
    else
    {
      float v17 = 1.0;
    }
  }
  else
  {
    float v17 = 0.5;
  }
  *(_DWORD *)(a7 + 16)  = 0;
  *(float *)(a7 + 24)  = (float)((float)((float)(a9 - 100.0) / 420.0) * -30.0) + 100.0;
  *(_DWORD *)(a7 + 20)  = 1157234688;
  *(float *)(a7 + 28)  = (float)((float)((float)(a9 - 100.0) / 420.0) * 1970.0) + 100.0;
  *(_DWORD *)a7  = 0;
  *(float *)(a7 + 4)  = a8;
  *(float *)(a7 + 8)  = 30.0;
  *(float *)(a7 + 12)  = a8 + (float)((float)((float)(100.0 - a8) / 30.0) * (float)(*(float *)(a7 + 8) - 0.0));
  if (a3)
  {
    *(_DWORD *)(a7 + 20)  = 1142292480;
    *(_DWORD *)(a7 + 28)  = 1125515264;
    float v16 = (float)(*(float *)(a7 + 28) - *(float *)(a7 + 12)) / (float)(*(float *)(a7 + 20) - *(float *)(a7 + 8));
    *(_DWORD *)(a7 + 16)  = 0;
    *(float *)(a7 + 24)  = *(float *)(a7 + 28) - (float)((float)(*(float *)(a7 + 20) - *(float *)(a7 + 16)) * v16);
  }
  if (a5 && *(float *)(a5 + 4) >= 0.0) {
    *(_DWORD *)(a7 + 12)  = *(_DWORD *)(a5 + 4);
  }
  if (a6 && *a6 >= 0.0 && a6[1] >= 0.0)
  {
    *(float *)(a7 + 20)  = *a6;
    *(float *)(a7 + 28)  = a6[1];
    float v15 = (float)(*(float *)(a7 + 28) - *(float *)(a7 + 12)) / (float)(*(float *)(a7 + 20) - *(float *)(a7 + 8));
    *(_DWORD *)(a7 + 16)  = 0;
    *(float *)(a7 + 24)  = *(float *)(a7 + 28) - (float)((float)(*(float *)(a7 + 20) - *(float *)(a7 + 16)) * v15);
  }
  float v14 = -(float)(*(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) * v17));
  if (v17 == 2.0)
  {
    float v13 = (float)(*(float *)(a7 + 12) - *(float *)(a7 + 4)) / (float)(*(float *)(a7 + 8) - *(float *)a7);
    *(float *)(a7 + 24)  = *(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) * v17));
    *(float *)(a7 + 28)  = *(float *)(a7 + 28) + v14;
    *(_DWORD *)(a7 + 8)  = 1114636288;
    *(float *)(a7 + 12)  = *(float *)(a7 + 24)
                        + (float)((float)((float)(*(float *)(a7 + 28) - *(float *)(a7 + 24))
                                        / (float)(*(float *)(a7 + 20) - *(float *)(a7 + 16)))
                                * *(float *)(a7 + 8));
    *(float *)(a7 + 4)  = *(float *)(a7 + 12) - (float)(v13 * *(float *)(a7 + 8));
  }
  else if (v17 == 0.5)
  {
    *(float *)(a7 + 24)  = *(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) - (float)(*(float *)(a7 + 24) * v17));
    *(float *)(a7 + 28)  = *(float *)(a7 + 28) + v14;
    *(float *)(a7 + 4)  = *(float *)(a7 + 4) + v14;
    *(float *)(a7 + 12)  = *(float *)(a7 + 12) + v14;
  }
  (*(void (**)(uint64_t, const char *, ...))(*(void *)a1 + 16))(a1, "%s: curve: (_E1  = %0.2f, _L1  = %0.4f) (_E2  = %0.2f, _L2  = %0.4f)", "DefaultCurve", *(float *)(a7 + 16), *(float *)(a7 + 24), *(float *)(a7 + 20), *(float *)(a7 + 28));
  (*(void (**)(uint64_t, const char *, ...))(*(void *)a1 + 16))(a1, "%s:  dark  (E0a  = %0.2f, L0a  = %0.4f) (E0b  = %0.2f, L0b  = %0.4f)", "DefaultCurve", *(float *)a7, *(float *)(a7 + 4), *(float *)(a7 + 8), *(float *)(a7 + 12));
  *(_DWORD *)(a1 + 52)  = *(_DWORD *)(a7 + 28);
  *(_DWORD *)(a1 + 40)  = *(_DWORD *)(a7 + 4);
  *(_DWORD *)(a1 + 48)  = *(_DWORD *)(a7 + 20);
  *(_DWORD *)(a1 + 44)  = *(_DWORD *)a7;
  *(_DWORD *)(a7 + 68)  = 0;
  *(_DWORD *)(a7 + 72)  = 2;
  *(_DWORD *)(a7 + 76)  = 1;
  *(_DWORD *)(a7 + 32)  = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a7 + 44)  = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a7 + 36)  = 0;
  *(_DWORD *)(a7 + 48)  = 0;
  *(_DWORD *)(a7 + 40)  = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a7 + 52)  = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a7 + 64)  = -1;
  *(unsigned char *)(a7 + 80)  = 0;
  *(_DWORD *)(a7 + 56)  = 0;
  *(_DWORD *)(a7 + 60)  = 0;
  *(float *)(a7 + 100)  = -1.0;
  *(float *)(a1 + 56)  = a10;
  *(float *)(a1 + 60)  = a8;
  if (a4 && *a4 > 0.0 && a4[1] > 0.0)
  {
    float result = (float)(a4[1] - *(float *)(a7 + 28)) / (float)(*a4 - *(float *)(a7 + 20));
    *(float *)(a7 + 84)  = result;
  }
  else
  {
    float result = *(float *)(a7 + 28) / *(float *)(a7 + 20);
    *(float *)(a7 + 84)  = result;
  }
  return result;
}

float AAB::LuminanceToIlluminance(AAB *this, float a2, const CustomCurve *a3)
{
  float v7 = 0.0;
  if (a3->size <= 1)
  {
    if (a3->size == 1) {
      float v4 = a3->_E[0];
    }
    else {
      float v4 = 0.0;
    }
    float v7 = v4;
  }
  else
  {
    for (int i = 0; i < a3->size - 1; ++i)
    {
      if (a2 <= a3->_L[i + 1])
      {
        if ((float)(a3->_E[i + 1] - a3->_E[i]) != 0.0)
        {
          float v6 = (float)(a3->_L[i + 1] - a3->_L[i]) / (float)(a3->_E[i + 1] - a3->_E[i]);
          if (v6 == 0.0) {
            float v7 = fminf(a3->_E[i], 20000.0);
          }
          else {
            float v7 = fminf((float)((float)(a2 - a3->_L[i]) + (float)(a3->_E[i] * v6)) / v6, 20000.0);
          }
        }
        return fmaxf(v7, 0.0);
      }
      if (i == a3->size - 2) {
        return fmaxf(fminf(a3->_E[i + 1], 20000.0), 0.0);
      }
    }
  }
  return fmaxf(v7, 0.0);
}

float AAB::IlluminanceToLuminance(AAB *this, float a2, const CustomCurve *a3)
{
  float v6 = 0.0;
  if (*((int *)this + 40) <= 1)
  {
    if (*((_DWORD *)this + 40) == 1) {
      float v4 = *((float *)this + 20);
    }
    else {
      float v4 = 0.0;
    }
    float v6 = v4;
  }
  else
  {
    for (int i = 0; i < *((_DWORD *)this + 40) - 1; ++i)
    {
      if (a2 <= *((float *)this + i + 1))
      {
        if ((float)(*((float *)this + i + 1) - *((float *)this + i)) != 0.0) {
          float v6 = *((float *)this + i + 20)
        }
             + (float)((float)((float)(*((float *)this + i + 21) - *((float *)this + i + 20))
                             / (float)(*((float *)this + i + 1) - *((float *)this + i)))
                     * (float)(a2 - *((float *)this + i)));
        return fmaxf(fmaxf(v6, 0.0), *((float *)this + 20));
      }
      if (i == *((_DWORD *)this + 40) - 2)
      {
        float v6 = *((float *)this + i + 21);
        return fmaxf(fmaxf(v6, 0.0), *((float *)this + 20));
      }
    }
  }
  return fmaxf(fmaxf(v6, 0.0), *((float *)this + 20));
}

uint64_t AAB::UpdateCurve_Block3(uint64_t a1, uint64_t a2, float a3, float a4, float a5)
{
  unint64_t v10 = __PAIR64__(LODWORD(a4), LODWORD(a3));
  float v11 = a5;
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v7, a1 + 72);
  (*(void (**)(void, uint64_t, uint64_t, float, float, float))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), a1, v8, *(float *)&v10, *((float *)&v10 + 1), v11);
  *(CFAbsoluteTime *)(v8 + 88)  = CFAbsoluteTimeGetCurrent();
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v7);
}

void sub_1BA522190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object, uint64_t a14, uint64_t a15, char a16)
{
}

uint64_t std::unique_lock<std::mutex>::unique_lock[abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1;
}

{
  *(void *)a1  = a2;
  *(unsigned char *)(a1 + 8)  = 1;
  std::mutex::lock(*(std::mutex **)a1);
  return a1;
}

uint64_t std::unique_lock<std::mutex>::~unique_lock[abi:ne180100](uint64_t a1)
{
  return a1;
}

{
  if (*(unsigned char *)(a1 + 8)) {
    std::mutex::unlock(*(std::mutex **)a1);
  }
  return a1;
}

uint64_t AAB::UpdateCurve_Block3_WithCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float a5, float a6, float a7)
{
  unint64_t v14 = __PAIR64__(LODWORD(a6), LODWORD(a5));
  float v15 = a7;
  uint64_t v13 = a1;
  uint64_t v12 = a2;
  uint64_t v11 = a3;
  uint64_t v10 = a4;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v9, a1 + 72);
  (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64), a1, v12, v11, v10, *(float *)&v14, *((float *)&v14 + 1), v15);
  *(CFAbsoluteTime *)(v12 + 88)  = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v10 + 88)  = CFAbsoluteTimeGetCurrent();
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v9);
}

void sub_1BA5222F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, _Unwind_Exception *exception_object, uint64_t a16, uint64_t a17, char a18)
{
}

uint64_t AAB::UpdateCurve_Block3_WithCappedCurve_AlternativeCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7, float a8, float a9)
{
  unint64_t v18 = __PAIR64__(LODWORD(a8), LODWORD(a7));
  float v19 = a9;
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  uint64_t v12 = a6;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v11, a1 + 72);
  (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64), a1, v16, v15, v14, *(float *)&v18, *((float *)&v18 + 1), v19);
  (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, float, float, float))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64), a1, v13, v15, v12, *(float *)&v18, *((float *)&v18 + 1), v19);
  *(CFAbsoluteTime *)(v16 + 88)  = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v14 + 88)  = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v13 + 88)  = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v12 + 88)  = CFAbsoluteTimeGetCurrent();
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v11);
}

void sub_1BA52248C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, _Unwind_Exception *exception_object, uint64_t a18, uint64_t a19, char a20)
{
}

uint64_t AAB::GetCurveUpdates@<X0>(AAB *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v6 = a2;
  uint64_t v5 = this;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v4, (uint64_t)this + 72);
  (*(void (**)(void))(**((void **)this + 8) + 48))(*((void *)this + 8));
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v4);
}

void sub_1BA522528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object, char a14)
{
}

uint64_t AAB::SetCurveUpdates(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1;
  uint64_t v5 = a2;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v4, a1 + 72);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 56))(*(void *)(a1 + 64), v5);
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v4);
}

void sub_1BA5225C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object, char a14)
{
}

uint64_t AAB::TraditionalUpdateCurveStrategy::UpdateCurve(double a1, float a2, float a3, uint64_t a4, float *a5, uint64_t a6)
{
  (*(void (**)(float *, const char *, ...))(*(void *)a5 + 8))(a5, "%s: inputs: Esensor=%f Luser=%f %x", "UpdateCurve", a2, a3);
  float v16 = (float)(*(float *)(a6 + 28) - *(float *)(a6 + 24)) / (float)(*(float *)(a6 + 20) - *(float *)(a6 + 16));
  float v15 = *(float *)(a6 + 24) / v16;
  if (v15 <= 0.0) {
    float v15 = (float)(*(float *)(a6 + 16) + *(float *)(a6 + 20)) / 2.0;
  }
  if (v15 > 300.0) {
    float v15 = 300.0;
  }
  if (v15 > a5[6] / 1.2)
  {
    float v6 = a5[6] / 1.2;
    float v15 = v6;
  }
  if (v15 < 30.0) {
    float v15 = 30.0;
  }
  if (v15 < a5[5] * 1.2)
  {
    float v7 = a5[5] * 1.2;
    float v15 = v7;
  }
  a5[7]  = v15;
  a5[8]  = a2;
  a5[9]  = a3;
  if (a2 >= *(float *)(a6 + 8) || (float)(*(float *)(a6 + 24) + (float)(v16 * *(float *)(a6 + 8))) >= 200.0)
  {
    if (a2 <= v15)
    {
      a5[5]  = a2;
      float v9 = (float)(*(float *)(a6 + 28) - a3) / (float)(*(float *)(a6 + 20) - a5[5]);
      (**(void (***)(float *, const char *, ...))a5)(a5, "Esensor: %0.2f Luser: %0.4f Eth_dyn=%0.2f _Mmax=%0.4f _Mmin=%0.4f slope=%0.4f CCCC", a2, a3, v15, a5[2], a5[3], v9);
      float v10 = fmaxf(fminf(v9, a5[2]), a5[3]);
      (*(void (**)(float *, const char *, ...))(*(void *)a5 + 8))(a5, "%s: <= Eth_dyn=%f _Mmax=%f _Mmin=%f slope=%f", "UpdateCurve", v15, a5[2], a5[3], v10);
      *(float *)(a6 + 28)  = a3 + (float)(v10 * (float)(*(float *)(a6 + 20) - a5[5]));
      *(float *)(a6 + 24)  = a3 + (float)(v10 * (float)(*(float *)(a6 + 16) - a5[5]));
      if ((float)(*(float *)(a6 + 24) + (float)(v10 * *(float *)(a6 + 8))) >= 200.0)
      {
        *(_DWORD *)(a6 + 4)  = *(_DWORD *)(a6 + 24);
        *(float *)(a6 + 12)  = *(float *)(a6 + 24) + (float)(v10 * *(float *)(a6 + 8));
      }
      else
      {
        *(_DWORD *)(a6 + 8)  = *(_DWORD *)(a6 + 8);
        *(float *)(a6 + 12)  = *(float *)(a6 + 24) + (float)(v10 * *(float *)(a6 + 8));
        *(float *)(a6 + 4)  = *(float *)(a6 + 12)
                           - (float)(std::__math::fmax[abi:ne180100](fminf((float)(*(float *)(a6 + 12) - *(float *)(a6 + 4))/ (float)(*(float *)(a6 + 8) - *(float *)a6), a5[4]), v10)* *(float *)(a6 + 8));
      }
    }
    else
    {
      a5[6]  = a2;
      float v11 = fmaxf(fminf((float)(a3 - *(float *)(a6 + 24)) / (float)(a5[6] - *(float *)(a6 + 16)), a5[2]), a5[3]);
      (**(void (***)(float *, const char *, ...))a5)(a5, "Esensor: %0.2f Luser: %0.4f Eth_dyn=%0.2f _Mmax=%0.4f _Mmin=%0.4f slope=%0.4f", a2, a3, v15, a5[2], a5[3], v11);
      if (a5[6] < 200.0)
      {
        *(_DWORD *)(a6 + 20)  = 1128792064;
        *(float *)(a6 + 28)  = a3 + (float)(v11 * (float)(*(float *)(a6 + 20) - a5[6]));
      }
      else
      {
        *(float *)(a6 + 20)  = a5[6];
        *(float *)(a6 + 28)  = a3;
      }
      *(float *)(a6 + 24)  = *(float *)(a6 + 28) + (float)(v11 * (float)(*(float *)(a6 + 16) - *(float *)(a6 + 20)));
      if ((float)(*(float *)(a6 + 24) + (float)(v11 * *(float *)(a6 + 8))) >= 200.0)
      {
        *(_DWORD *)(a6 + 4)  = *(_DWORD *)(a6 + 24);
        *(float *)(a6 + 12)  = *(float *)(a6 + 24) + (float)(v11 * *(float *)(a6 + 8));
      }
      else
      {
        *(_DWORD *)(a6 + 8)  = *(_DWORD *)(a6 + 8);
        *(float *)(a6 + 12)  = *(float *)(a6 + 24) + (float)(v11 * *(float *)(a6 + 8));
        *(float *)(a6 + 4)  = *(float *)(a6 + 12)
                           - (float)(std::__math::fmax[abi:ne180100](fminf((float)(*(float *)(a6 + 12) - *(float *)(a6 + 4))/ (float)(*(float *)(a6 + 8) - *(float *)a6), a5[4]), v11)* *(float *)(a6 + 8));
      }
    }
  }
  else
  {
    float v14 = fmaxf(fminf((float)(*(float *)(a6 + 12) - a3) / (float)(*(float *)(a6 + 8) - a2), a5[4]), v16);
    *(float *)(a6 + 4)  = a3 - (float)(v14 * a2);
    *(float *)(a6 + 12)  = *(float *)(a6 + 4) + (float)(v14 * *(float *)(a6 + 8));
    a5[5]  = *(float *)(a6 + 8);
    float v12 = (float)(*(float *)(a6 + 28) - *(float *)(a6 + 12)) / (float)(*(float *)(a6 + 20) - a5[5]);
    (**(void (***)(float *, const char *, ...))a5)(a5, "Esensor: %0.2f Luser: %0.4f Eth_dyn=%f _Mmax=%0.4f _Mmin=%0.4f slope=%0.4f", a2, a3, v15, a5[2], a5[3], v12);
    float v13 = fmaxf(fminf(v12, a5[2]), a5[3]);
    *(float *)(a6 + 28)  = *(float *)(a6 + 12) + (float)(v13 * (float)(*(float *)(a6 + 20) - a5[5]));
    *(float *)(a6 + 24)  = *(float *)(a6 + 12) + (float)(v13 * (float)(*(float *)(a6 + 16) - a5[5]));
  }
  return (*(uint64_t (**)(float *, const char *, ...))(*(void *)a5 + 8))(a5, "%s: outputs: E1=%f L1=%f E2=%f L2=%f", "UpdateCurve", *(float *)(a6 + 16), *(float *)(a6 + 24), *(float *)(a6 + 20), *(float *)(a6 + 28));
}

float AAB::FitCurveToReferencePoints(float *a1, uint64_t a2, int a3)
{
  float result = 0.0;
  if (a3)
  {
    if (a3 == 1)
    {
      if (a1[11] < *(float *)(a2 + 8))
      {
        float result = a1[11];
        if (result < *(float *)(a2 + 8))
        {
          for (float i = a1[13] - (float)(a1[3] * (float)(a1[12] - *(float *)(a2 + 8)));
                i >= (float)(a1[13] - (float)(a1[2] * (float)(a1[12] - *(float *)(a2 + 8))));
                float i = i - 0.01)
          {
            float v15 = (float)(i - a1[10]) / (float)(*(float *)(a2 + 8) - a1[11]);
            if (v15 <= (float)((float)(a1[13] - i) / (float)(a1[12] - *(float *)(a2 + 8))) || v15 < a1[4]) {
              break;
            }
          }
          float v12 = (float)(a1[13] - i) / (float)(a1[12] - *(float *)(a2 + 8));
          *(float *)(a2 + 12)  = a1[13] - (float)(v12 * (float)(a1[12] - *(float *)(a2 + 8)));
          if (a1[12] < 301.0) {
            *(_DWORD *)(a2 + 20)  = 1133936640;
          }
          else {
            *(float *)(a2 + 20)  = a1[12];
          }
          *(float *)(a2 + 28)  = a1[13] + (float)(v12 * (float)(*(float *)(a2 + 20) - a1[12]));
          *(float *)(a2 + 24)  = *(float *)(a2 + 28) - (float)(v12 * *(float *)(a2 + 20));
          float result = *(float *)(a2 + 12)
                 - (float)(fminf(fmaxf((float)(*(float *)(a2 + 12) - a1[10]) / (float)(*(float *)(a2 + 8) - a1[11]), v12), a1[4])* (float)(*(float *)(a2 + 8) - *(float *)a2));
          *(float *)(a2 + 4)  = result;
        }
      }
      else
      {
        float v11 = fminf(fmaxf((float)(a1[13] - a1[10]) / (float)(a1[12] - a1[11]), a1[3]), a1[2]);
        if (a1[12] < 301.0) {
          *(_DWORD *)(a2 + 20)  = 1133936640;
        }
        else {
          *(float *)(a2 + 20)  = a1[12];
        }
        *(float *)(a2 + 28)  = a1[13] + (float)(v11 * (float)(*(float *)(a2 + 20) - a1[12]));
        *(float *)(a2 + 24)  = *(float *)(a2 + 28) - (float)(v11 * *(float *)(a2 + 20));
        *(float *)(a2 + 12)  = *(float *)(a2 + 28) - (float)(v11 * (float)(*(float *)(a2 + 20) - *(float *)(a2 + 8)));
        float result = *(float *)(a2 + 12)
               - (float)(fmaxf(fminf(a1[4], (float)(*(float *)(a2 + 12) - a1[15]) / (float)(*(float *)(a2 + 8) - *(float *)a2)), v11)* *(float *)(a2 + 8));
        *(float *)(a2 + 4)  = result;
      }
    }
  }
  else if (a1[11] == *(float *)(a2 + 8))
  {
    *(float *)(a2 + 12)  = a1[10];
    float v7 = fminf(fmaxf((float)(a1[13] - *(float *)(a2 + 12)) / (float)(a1[12] - *(float *)(a2 + 8)), a1[3]), a1[2]);
    *(float *)(a2 + 28)  = *(float *)(a2 + 12) + (float)(v7 * (float)(*(float *)(a2 + 20) - *(float *)(a2 + 8)));
    *(float *)(a2 + 24)  = *(float *)(a2 + 28) - (float)(v7 * *(float *)(a2 + 20));
    float result = a1[10]
           - (float)(fmaxf(fminf(a1[4], (float)(a1[10] - a1[15]) / (float)(*(float *)(a2 + 8) - *(float *)a2)), v7)
                   * a1[11]);
    *(float *)(a2 + 4)  = result;
  }
  else if (a1[11] >= *(float *)(a2 + 8))
  {
    float v10 = fminf(fmaxf((float)(a1[13] - a1[10]) / (float)(a1[12] - a1[11]), a1[3]), a1[2]);
    *(float *)(a2 + 28)  = a1[10] + (float)(v10 * (float)(*(float *)(a2 + 20) - a1[11]));
    *(float *)(a2 + 24)  = *(float *)(a2 + 28) - (float)(v10 * *(float *)(a2 + 20));
    *(float *)(a2 + 12)  = *(float *)(a2 + 28) - (float)(v10 * (float)(*(float *)(a2 + 20) - *(float *)(a2 + 8)));
    float result = *(float *)(a2 + 12)
           - (float)(fmaxf(fminf(a1[4], (float)(*(float *)(a2 + 12) - a1[15]) / (float)(*(float *)(a2 + 8) - *(float *)a2)), v10)* *(float *)(a2 + 8));
    *(float *)(a2 + 4)  = result;
  }
  else
  {
    float v13 = a1[4];
    for (float j = a1[10]; j < a1[14]; float j = j + 0.01)
    {
      float v13 = (float)(j - a1[10]) / (float)(*(float *)(a2 + 8) - a1[11]);
      if (v13 > a1[3])
      {
        float v8 = (float)(a1[13] - j) / (float)(a1[12] - *(float *)(a2 + 8));
        if (v13 >= a1[4])
        {
          float v13 = a1[4];
          break;
        }
        if (v8 <= a1[3]
          || v13 >= v8
          && v8 <= a1[2]
          && (float)(j - (float)(v13 * (float)(*(float *)(a2 + 8) - *(float *)a2))) <= a1[15]
          && *(float *)a2 != a1[11])
        {
          break;
        }
      }
    }
    float v14 = fminf(v13, a1[4]);
    *(float *)(a2 + 4)  = a1[10] - (float)(v14 * a1[11]);
    *(float *)(a2 + 12)  = a1[10] + (float)(v14 * (float)(*(float *)(a2 + 8) - a1[11]));
    float v9 = fminf(fmaxf((float)(a1[13] - *(float *)(a2 + 12)) / (float)(a1[12] - *(float *)(a2 + 8)), a1[3]), a1[2]);
    *(float *)(a2 + 28)  = *(float *)(a2 + 12) + (float)(v9 * (float)(*(float *)(a2 + 20) - *(float *)(a2 + 8)));
    float result = *(float *)(a2 + 28) - (float)(v9 * *(float *)(a2 + 20));
    *(float *)(a2 + 24)  = result;
  }
  return result;
}

uint64_t AAB::UpdateAge(uint64_t result, _DWORD *a2)
{
  if (a2[9] != result)
  {
    if (a2[10] != result) {
      a2[11]  = a2[10];
    }
    a2[10]  = a2[9];
  }
  a2[9]  = result;
  return result;
}

uint64_t AAB::Reset(AAB *this)
{
  float v4 = this;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v3, (uint64_t)this + 72);
  (*(void (**)(void))(**((void **)this + 8) + 16))(*((void *)this + 8));
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v3);
}

void sub_1BA523B10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object, char a13)
{
}

uint64_t AAB::SetUpdateStrategy(AAB *this, AAB::UpdateCurveStrategy *a2)
{
  float v7 = this;
  float v6 = a2;
  std::unique_lock<std::mutex>::unique_lock[abi:ne180100]((uint64_t)v5, (uint64_t)this + 72);
  if (v6)
  {
    if (*((void *)this + 8))
    {
      if (*((AAB::UpdateCurveStrategy **)this + 8) != v6)
      {
        uint64_t v3 = *((void *)this + 8);
        if (v3) {
          (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
        }
      }
    }
    *((void *)this + 8)  = v6;
  }
  return std::unique_lock<std::mutex>::~unique_lock[abi:ne180100]((uint64_t)v5);
}

float AAB::PreferenceUpdateCurveStrategy::UpdateCurveAndCappedCurve(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, double a6, float a7, float a8)
{
  unint64_t v15 = __PAIR64__(LODWORD(a7), LODWORD(a6));
  float v16 = a8;
  AAB::PreferenceUpdateCurveStrategy::UpdateCurve(a6, a7, a8, a1, a2, a3);
  float CapForE = AAB::findCapForE(a4, *(float *)&v15);
  if (v16 > CapForE) {
    float v16 = CapForE;
  }
  LODWORD(v8)  = v15;
  return AAB::PreferenceUpdateCurveStrategy::UpdateCurve(v8, *((float *)&v15 + 1), v16, a1, a2, a5);
}

float AAB::PreferenceUpdateCurveStrategy::UpdateCurve(double a1, float a2, float a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = a6 + 32;
  *(float *)(a6 + 100)  = -1.0;
  float v11 = *(float *)(a6 + 20) + (float)((float)(*(float *)(a5 + 56) - *(float *)(a6 + 28)) / *(float *)(a6 + 84));
  if (a2 > 300.0)
  {
    int v13 = 2;
    *(unsigned char *)(a6 + 80)  = 0;
  }
  else if (a2 > *(float *)(a6 + 8))
  {
    int v13 = 1;
    *(unsigned char *)(a6 + 80)  = 0;
  }
  else
  {
    int v13 = 0;
  }
  if (v13 != 1 && *(_DWORD *)(a6 + 64) != -1)
  {
    *(_DWORD *)(a6 + 32 + 4 * *(unsigned int *)(a6 + 64))  = *(_DWORD *)(a6 + 56);
    *(_DWORD *)(a6 + 44 + 4 * *(unsigned int *)(a6 + 64))  = *(_DWORD *)(a6 + 60);
  }
  *(_DWORD *)(a6 + 64)  = -1;
  AAB::UpdateAge(v13, (_DWORD *)v12);
  *(float *)(v12 + 4 * v13)  = a2;
  *(float *)(v12 + 12 + 4 * v13)  = a3;
  if (*(_DWORD *)(v12 + 36) || *(_DWORD *)(v12 + 40) != 2)
  {
    if (*(_DWORD *)(v12 + 36) != 2 || *(_DWORD *)(v12 + 40))
    {
      float v10 = *(float *)(v12 + 4) - *(float *)v12;
      float v9 = *(float *)(v12 + 8) - *(float *)(v12 + 4);
      if (*(_DWORD *)(v12 + 36) == 1)
      {
        if (v10 > v9)
        {
          *(_DWORD *)(a5 + 44)  = *(_DWORD *)v12;
          *(_DWORD *)(a5 + 40)  = *(_DWORD *)(v12 + 12);
          *(_DWORD *)(a5 + 48)  = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(a5 + 52)  = *(_DWORD *)(v12 + 16);
          int v14 = 1;
          AAB::FitCurveToReferencePoints((float *)a5, a6, 1);
        }
        else
        {
          *(_DWORD *)(a5 + 44)  = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(a5 + 40)  = *(_DWORD *)(v12 + 16);
          *(_DWORD *)(a5 + 48)  = *(_DWORD *)(v12 + 8);
          *(_DWORD *)(a5 + 52)  = *(_DWORD *)(v12 + 20);
          int v14 = 0;
          AAB::FitCurveToReferencePoints((float *)a5, a6, 0);
        }
      }
      else
      {
        if (*(_DWORD *)(v12 + 36))
        {
          *(_DWORD *)(a5 + 48)  = *(_DWORD *)(v12 + 8);
          *(_DWORD *)(a5 + 52)  = *(_DWORD *)(v12 + 20);
          int v14 = 1;
          if (v10 > v9)
          {
            *(_DWORD *)(a5 + 44)  = *(_DWORD *)v12;
            *(_DWORD *)(a5 + 40)  = *(_DWORD *)(v12 + 12);
          }
          else
          {
            *(_DWORD *)(a5 + 44)  = *(_DWORD *)(v12 + 4);
            *(_DWORD *)(a5 + 40)  = *(_DWORD *)(v12 + 16);
          }
        }
        else
        {
          *(_DWORD *)(a5 + 44)  = *(_DWORD *)v12;
          *(_DWORD *)(a5 + 40)  = *(_DWORD *)(v12 + 12);
          int v14 = 0;
          if (v10 > v9)
          {
            *(_DWORD *)(a5 + 48)  = *(_DWORD *)(v12 + 4);
            *(_DWORD *)(a5 + 52)  = *(_DWORD *)(v12 + 16);
          }
          else
          {
            if ((*(unsigned char *)(v12 + 48) & 1) == 0)
            {
              *(_DWORD *)(v12 + 8)  = *(_DWORD *)(a6 + 20);
              *(_DWORD *)(v12 + 20)  = *(_DWORD *)(a6 + 28);
              *(unsigned char *)(v12 + 48)  = 1;
            }
            *(_DWORD *)(a5 + 48)  = *(_DWORD *)(v12 + 8);
            *(_DWORD *)(a5 + 52)  = *(_DWORD *)(v12 + 20);
          }
        }
        AAB::FitCurveToReferencePoints((float *)a5, a6, v14);
      }
    }
    else
    {
      *(_DWORD *)(a5 + 44)  = *(_DWORD *)v12;
      *(_DWORD *)(a5 + 40)  = *(_DWORD *)(v12 + 12);
      *(_DWORD *)(a5 + 48)  = *(_DWORD *)(v12 + 8);
      *(_DWORD *)(a5 + 52)  = *(_DWORD *)(v12 + 20);
      int v14 = 1;
      AAB::FitCurveToReferencePoints((float *)a5, a6, 1);
    }
  }
  else
  {
    *(_DWORD *)(a5 + 44)  = *(_DWORD *)v12;
    *(_DWORD *)(a5 + 40)  = *(_DWORD *)(v12 + 12);
    *(_DWORD *)(a5 + 48)  = *(_DWORD *)(v12 + 8);
    *(_DWORD *)(a5 + 52)  = *(_DWORD *)(v12 + 20);
    int v14 = 0;
    AAB::FitCurveToReferencePoints((float *)a5, a6, 0);
  }
  if (*(_DWORD *)(v12 + 36) == 1)
  {
    if (v14)
    {
      float v8 = (float)(*(float *)(a6 + 28) - *(float *)(a6 + 12)) / (float)(*(float *)(a6 + 20) - *(float *)(a6 + 8));
      *(_DWORD *)(v12 + 32)  = 2;
      *(_DWORD *)(v12 + 24)  = *(_DWORD *)(v12 + 8);
      *(float *)(v12 + 28)  = *(float *)(a6 + 28) + (float)(v8 * (float)(*(float *)(v12 + 8) - *(float *)(a6 + 20)));
    }
    else
    {
      *(_DWORD *)(v12 + 24)  = *(_DWORD *)(a6 + 8);
      *(_DWORD *)(v12 + 28)  = *(_DWORD *)(a6 + 12);
      *(_DWORD *)(v12 + 32)  = 0;
    }
  }
  float v7 = *(float *)(a6 + 28) / *(float *)(a6 + 20);
  if ((float)(*(float *)(a6 + 20) + (float)((float)(*(float *)(a5 + 56) - *(float *)(a6 + 28)) / v7)) < v11) {
    *(float *)(a6 + 84)  = fmaxf((float)(*(float *)(a5 + 56) - *(float *)(a6 + 28)) / (float)(v11 - *(float *)(a6 + 20)), (float)(*(float *)(a6 + 28) - *(float *)(a6 + 12))/ (float)(*(float *)(a6 + 20) - *(float *)(a6 + 8)));
  }
  else {
    *(float *)(a6 + 84)  = v7;
  }
  *(float *)(a5 + 32)  = a2;
  float result = a3;
  *(float *)(a5 + 36)  = a3;
  return result;
}

float AAB::findCapForE(float *a1, float a2)
{
  float v6 = a1[4];
  if (a2 <= *a1) {
    return a1[4];
  }
  if (a2 >= a1[3]) {
    return a1[7];
  }
  for (int i = 1; i < 4; ++i)
  {
    if (a2 < a1[i])
    {
      float v4 = a1[i - 1];
      float v2 = a1[i + 3];
      return v2 + (float)((float)((float)(a2 - v4) / (float)(a1[i] - v4)) * (float)(a1[i + 4] - v2));
    }
  }
  return v6;
}

void AAB::curveToCustomCurve(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 160)  = 4;
  *(_DWORD *)a3  = *(_DWORD *)a2;
  *(_DWORD *)(a3 + 4)  = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 8)  = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a3 + 12)  = 1184645120;
  *(_DWORD *)(a3 + 80)  = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 84)  = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a3 + 88)  = *(_DWORD *)(a2 + 28);
  *(float *)(a3 + 92)  = AAB::IlluminanceToLuminance(a1, (float *)a2, 20000.0);
}

BOOL lineIntersection(float *a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  BOOL v14 = 0;
  if ((float)(a4 - a2) == 0.0)
  {
    return 0;
  }
  else
  {
    float v13 = (float)(a5 - a3) / (float)(a4 - a2);
    float v12 = (float)(a9 - a7) / (float)(a8 - a6);
    float v11 = a3 - (float)(v13 * a2);
    if ((float)(v13 - v12) == 0.0)
    {
      return 0;
    }
    else
    {
      float v10 = (float)((float)(a7 - (float)(v12 * a6)) - v11) / (float)(v13 - v12);
      *a1  = v10;
      a1[1]  = v11 + (float)(v13 * v10);
      if (a2 <= v10 && a6 <= v10 && a4 >= v10) {
        return a8 >= v10;
      }
      return v14;
    }
  }
}

float getY(float a1, float a2, float a3, float a4, float a5)
{
  return (float)(a2 - (float)((float)((float)(a4 - a2) / (float)(a3 - a1)) * a1))
       + (float)((float)((float)(a4 - a2) / (float)(a3 - a1)) * a5);
}

void AAB::findDarkerCurve(AAB *this, CustomCurve *a2, CustomCurve *a3, CustomCurve *a4)
{
  char v24 = this;
  float v23 = a2;
  uint64_t v22 = a3;
  int v21 = 0;
  int v20 = 0;
  int v19 = 0;
  if (COERCE_INT(*(float *)this * 10000.0) == COERCE_INT(a2->_E[0] * 10000.0))
  {
    v22->_E[0]  = *(float *)this;
    if (*((float *)this + 20) >= a2->_L[0]) {
      float v5 = a2->_L[0];
    }
    else {
      float v5 = *((float *)this + 20);
    }
    v22->_L[0]  = v5;
  }
  else if (*(float *)this >= a2->_E[0])
  {
    v22->_E[0]  = a2->_E[0];
    v22->_L[0]  = a2->_L[0];
  }
  else
  {
    v22->_E[0]  = *(float *)this;
    v22->_L[0]  = *((float *)this + 20);
  }
  ++v19;
  while (1)
  {
    BOOL v4 = 0;
    if (v21 + 1 < *((_DWORD *)this + 40)) {
      BOOL v4 = v20 + 1 < a2->size;
    }
    if (!v4) {
      break;
    }
    *(void *)unint64_t v18 = 0;
    float v16 = *((float *)this + v21);
    float v17 = *((float *)this + v21 + 20);
    float v14 = *((float *)this + v21 + 1);
    float v15 = *((float *)this + v21 + 21);
    float v12 = a2->_E[v20];
    float v13 = a2->_L[v20];
    float v10 = a2->_E[v20 + 1];
    float v11 = a2->_L[v20 + 1];
    if (lineIntersection(v18, v16, v17, v14, v15, v12, v13, v10, v11))
    {
      v22->_E[v19]  = v18[0];
      v22->_L[v19++]  = v18[1];
    }
    if (*((float *)this + v21 + 1) > a2->_E[v20 + 1])
    {
      float v8 = getY(v16, v17, v14, v15, a2->_E[v20 + 1]);
      if (v8 > a2->_L[v20 + 1])
      {
        v22->_E[v19]  = a2->_E[v20 + 1];
        v22->_L[v19++]  = a2->_L[v20 + 1];
      }
      ++v20;
    }
    else
    {
      float v9 = getY(v12, v13, v10, v11, *((float *)this + v21 + 1));
      if (v9 > *((float *)this + v21 + 21))
      {
        v22->_E[v19]  = *((float *)this + v21 + 1);
        v22->_L[v19++]  = *((float *)this + v21 + 21);
      }
      ++v21;
    }
  }
  if (*((_DWORD *)this + 40) - 1 > v21 && *((float *)this + ++v21 + 20) < a2->_L[v20])
  {
    v22->_E[v19]  = *((float *)this + v21);
    v22->_L[v19++]  = *((float *)this + v21 + 20);
  }
  if (a2->size - 1 > v20 && a2->_L[++v20] < *((float *)this + v21 + 20))
  {
    v22->_E[v19]  = a2->_E[v20];
    v22->_L[v19++]  = a2->_L[v20];
  }
  v22->size  = v19;
}

float AAB::customCurveToCurve@<S0>(const CustomCurve *a1@<X1>, float *a2@<X8>)
{
  memset(a2, 0, 0x68uLL);
  if (a1->size == 4)
  {
    *a2  = a1->_E[0];
    a2[2]  = a1->_E[1];
    a2[5]  = a1->_E[2];
    a2[1]  = a1->_L[0];
    a2[3]  = a1->_L[1];
    a2[7]  = a1->_L[2];
    a2[4]  = 0.0;
    a2[6]  = a2[3] - (float)((float)(a2[2] - a2[4]) * (float)((float)(a2[7] - a2[3]) / (float)(a2[5] - a2[2])));
    float result = (float)(a1->_L[3] - a1->_L[2]) / (float)(a1->_E[3] - a1->_E[2]);
    a2[21]  = result;
  }
  return result;
}

void AAB::TraditionalUpdateCurveStrategy::~TraditionalUpdateCurveStrategy(AAB::TraditionalUpdateCurveStrategy *this)
{
}

{
  AAB::TraditionalUpdateCurveStrategy::~TraditionalUpdateCurveStrategy(this);
  MEMORY[0x1BA9EC4A0](this, 0x81C40B8603338);
}

{
  AAB::UpdateCurveStrategy::~UpdateCurveStrategy(this);
}

uint64_t AAB::TraditionalUpdateCurveStrategy::curveType(AAB::TraditionalUpdateCurveStrategy *this)
{
  return 1;
}

uint64_t AAB::PreferenceUpdateCurveStrategy::curveType(AAB::PreferenceUpdateCurveStrategy *this)
{
  return 2;
}

void sub_1BA52678C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void sub_1BA5269C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t __os_log_helper_16_2_3_8_66_8_66_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 32;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_66_8_66_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_0_8_32_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 32;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_32_8_0(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_64_8_64(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 64;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 64;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

void load_libEDR()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  os_log_t oslog = MEMORY[0x1E4F14500];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_2_1_8_32((uint64_t)v1, (uint64_t)"load_libEDR");
    _os_log_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_INFO, "%s: ", v1, 0xCu);
  }
  if (load_libEDR_onceToken_libEDRLoad != -1) {
    dispatch_once(&load_libEDR_onceToken_libEDRLoad, &__block_literal_global_9);
  }
}

void __load_libEDR_block_invoke()
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  libEDRHandle  = (uint64_t)dlopen("/System/Library/PrivateFrameworks/libEDR.framework/libEDR", 1);
  if (libEDRHandle)
  {
    float v14 = dlsym((void *)libEDRHandle, "EDRServerStartService");
    if (v14)
    {
      edrServiceStartFunction  = v14;
    }
    else
    {
      os_log_t oslog = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        uint64_t v0 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v28, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerStartService", (uint64_t)v0);
        _os_log_error_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v28, 0x20u);
      }
    }
    float v15 = (uint64_t (*)(void, float, float, float, float))dlsym((void *)libEDRHandle, "EDRServerSetDisplayBrightnessForDisplay");
    if (v15)
    {
      edrServerSetDisplayBrightnessFunction  = v15;
    }
    else
    {
      uint64_t v12 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        int v1 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v27, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerSetDisplayBrightnessForDisplay", (uint64_t)v1);
        _os_log_error_impl(&dword_1BA438000, v12, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v27, 0x20u);
      }
    }
    float v16 = (uint64_t (*)(void))dlsym((void *)libEDRHandle, "EDRServerAddMainDisplay");
    if (v16)
    {
      edrServerAddMainDisplayFunction  = v16;
    }
    else
    {
      float v11 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        uint64_t v2 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v26, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerAddMainDisplay", (uint64_t)v2);
        _os_log_error_impl(&dword_1BA438000, v11, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v26, 0x20u);
      }
    }
    float v17 = dlsym((void *)libEDRHandle, "EDRServerAddDisplay");
    if (v17)
    {
      edrServerAddDisplayFunction  = v17;
    }
    else
    {
      float v10 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        uint64_t v3 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v25, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerAddDisplay", (uint64_t)v3);
        _os_log_error_impl(&dword_1BA438000, v10, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v25, 0x20u);
      }
    }
    unint64_t v18 = dlsym((void *)libEDRHandle, "EDRServerRemoveDisplay");
    if (v18)
    {
      edrServerRemoveDisplayFunction  = v18;
    }
    else
    {
      float v9 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        BOOL v4 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v24, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerRemoveDisplay", (uint64_t)v4);
        _os_log_error_impl(&dword_1BA438000, v9, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v24, 0x20u);
      }
    }
    int v19 = dlsym((void *)libEDRHandle, "EDRServerGetCurrentDisplayPropertiesForDisplay");
    if (v19)
    {
      edrServerGetCurrentDisplayPropertiesFunction  = (uint64_t (*)(void, void, void, void, void, void))v19;
    }
    else
    {
      float v8 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        float v5 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v23, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerGetCurrentDisplayPropertiesForDisplay", (uint64_t)v5);
        _os_log_error_impl(&dword_1BA438000, v8, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v23, 0x20u);
      }
    }
    int v20 = dlsym((void *)libEDRHandle, "EDRServerRegisterCallbackBlockOnQueue");
    if (v20)
    {
      edrServerRegisterCallbackBlockOnQueueFunction  = (uint64_t (*)(void, void))v20;
    }
    else
    {
      float v7 = MEMORY[0x1E4F14500];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        float v6 = dlerror();
        __os_log_helper_16_2_3_8_32_8_32_8_32((uint64_t)v22, (uint64_t)"load_libEDR_block_invoke", (uint64_t)"EDRServerRegisterCallbackBlockOnQueue", (uint64_t)v6);
        _os_log_error_impl(&dword_1BA438000, v7, OS_LOG_TYPE_ERROR, "%s: couldn't lookup symbol %s:\n%s", v22, 0x20u);
      }
    }
  }
  else
  {
    int v21 = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v29, (uint64_t)"load_libEDR_block_invoke");
      _os_log_error_impl(&dword_1BA438000, v21, OS_LOG_TYPE_ERROR, "%s: libEDR.framework not found!\n", v29, 0xCu);
    }
  }
}

BOOL CBEDRServerStartServer()
{
  if (CBEDRServerStartServer_onceToken_libEDRServiceStar != -1) {
    dispatch_once(&CBEDRServerStartServer_onceToken_libEDRServiceStar, &__block_literal_global_11);
  }
  return libEDRHandle != 0;
}

void __CBEDRServerStartServer_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (edrServiceStartFunction)
  {
    int v1 = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v3, (uint64_t)"CBEDRServerStartServer_block_invoke");
      _os_log_impl(&dword_1BA438000, v1, OS_LOG_TYPE_INFO, "%s: EDR service kick off", v3, 0xCu);
    }
    edrServiceStartFunction();
  }
  else
  {
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v2, (uint64_t)"CBEDRServerStartServer_block_invoke");
      _os_log_error_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_ERROR, "%s: missing edrServiceStartFunction", v2, 0xCu);
    }
  }
}

uint64_t __os_log_helper_16_2_6_8_32_4_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 0;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  return result;
}

void CBEDRServerAddMainDisplay(unsigned int a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (edrServerAddMainDisplayFunction)
  {
    uint64_t v2 = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v5, (uint64_t)"CBEDRServerAddMainDisplay", a1);
      _os_log_impl(&dword_1BA438000, v2, OS_LOG_TYPE_INFO, "%s: main display: %u", v5, 0x12u);
    }
    edrServerAddMainDisplayFunction(a1);
  }
  else
  {
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v4, (uint64_t)"CBEDRServerAddMainDisplay");
      _os_log_error_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_ERROR, "%s: missing edrServerSetMainDisplayFunction", v4, 0xCu);
    }
  }
}

void CBEDRServerAddDisplay(unsigned int a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (edrServerAddDisplayFunction)
  {
    uint64_t v2 = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v5, (uint64_t)"CBEDRServerAddDisplay", a1);
      _os_log_impl(&dword_1BA438000, v2, OS_LOG_TYPE_INFO, "%s: adding display: %u", v5, 0x12u);
    }
    edrServerAddDisplayFunction(a1);
  }
  else
  {
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v4, (uint64_t)"CBEDRServerAddDisplay");
      _os_log_error_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_ERROR, "%s: missing edrServerAddDisplayFunction", v4, 0xCu);
    }
  }
}

void CBEDRServerRemoveDisplay(unsigned int a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (edrServerRemoveDisplayFunction)
  {
    uint64_t v2 = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_2_8_32_4_0((uint64_t)v5, (uint64_t)"CBEDRServerRemoveDisplay", a1);
      _os_log_impl(&dword_1BA438000, v2, OS_LOG_TYPE_INFO, "%s: removing display: %u", v5, 0x12u);
    }
    edrServerRemoveDisplayFunction(a1);
  }
  else
  {
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v4, (uint64_t)"CBEDRServerRemoveDisplay");
      _os_log_error_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_ERROR, "%s: missing edrServerRemoveDisplayFunction", v4, 0xCu);
    }
  }
}

void CBEDRServerGetCurrentDisplayPropertiesForDisplay(unsigned int a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (edrServerGetCurrentDisplayPropertiesFunction)
  {
    edrServerGetCurrentDisplayPropertiesFunction(a1, a2, a3, a4, a5, a6);
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_7_8_32_4_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v15, (uint64_t)"CBEDRServerGetCurrentDisplayPropertiesForDisplay", a1, COERCE__INT64(*a2), COERCE__INT64(*a3), COERCE__INT64(*a4), COERCE__INT64(*a5), COERCE__INT64(*a6));
      _os_log_debug_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_DEBUG, "%s: display: %u | backlight: %f | EDR factor: %f | max luminance: %f | ambient illuminance: %f | brightness scaler: %f", v15, 0x44u);
    }
  }
  else
  {
    uint64_t v6 = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v14, (uint64_t)"CBEDRServerGetCurrentDisplayPropertiesForDisplay");
      _os_log_error_impl(&dword_1BA438000, v6, OS_LOG_TYPE_ERROR, "%s: missing edrServerGetCurrentDisplayPropertiesFunction", v14, 0xCu);
    }
  }
}

uint64_t __os_log_helper_16_2_7_8_32_4_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 7;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 0;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  *(unsigned char *)(result + 58)  = 0;
  *(unsigned char *)(result + 59)  = 8;
  *(void *)(result + 60)  = a8;
  return result;
}

void CBEDRServerRegisterCallbackBlockOnQueue(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (edrServerRegisterCallbackBlockOnQueueFunction)
  {
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v7, (uint64_t)"CBEDRServerRegisterCallbackBlockOnQueue", a2, a1);
      _os_log_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_INFO, "%s: register callback (%p) on a queue (%p)", v7, 0x20u);
    }
    edrServerRegisterCallbackBlockOnQueueFunction(a1, a2);
  }
  else
  {
    uint64_t v2 = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v6, (uint64_t)"CBEDRServerRegisterCallbackBlockOnQueue");
      _os_log_error_impl(&dword_1BA438000, v2, OS_LOG_TYPE_ERROR, "%s: missing edrServerRegisterCallbackBlockOnQueueFunction", v6, 0xCu);
    }
  }
}

unint64_t nextBufferIndex(uint64_t a1, uint64_t a2)
{
  return (a1 + a2) % 0x64uLL;
}

unint64_t previousBufferIndex(uint64_t a1)
{
  return (a1 + 99) % 0x64uLL;
}

BOOL aabParamsDiffer(const CBAABParams *a1, const CBAABParams *a2)
{
  BOOL v3 = 1;
  if (a1->e0a == a2->e0a)
  {
    BOOL v3 = 1;
    if (a1->e0b == a2->e0b)
    {
      BOOL v3 = 1;
      if (a1->e1 == a2->e1)
      {
        BOOL v3 = 1;
        if (a1->e2 == a2->e2)
        {
          BOOL v3 = 1;
          if (a1->l0a == a2->l0a)
          {
            BOOL v3 = 1;
            if (a1->l0b == a2->l0b)
            {
              BOOL v3 = 1;
              if (a1->l1 == a2->l1)
              {
                BOOL v3 = 1;
                if (a1->l2 == a2->l2) {
                  return a1->thirdSlope != a2->thirdSlope;
                }
              }
            }
          }
        }
      }
    }
  }
  return v3;
}

uint64_t localizeTimestamp(uint64_t a1)
{
  uint64_t v1 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F1CAF0], "localTimeZone"), "secondsFromGMT");
  return (uint64_t)((double)(a1 + v1) + *MEMORY[0x1E4F1CF78]);
}

uint64_t std::array<CBSliderCommitInfo,100ul>::operator[][abi:ne180100](uint64_t a1, uint64_t a2)
{
  return a1 + 232 * a2;
}

void TrackedState::TrackedState(TrackedState *this)
{
}

{
  this->darkThemeApplied  = 0;
  this->landscapeOrientation  = 0;
  this->autobrightnessEnabled  = 0;
  this->ecoModeEnabled  = 0;
}

uint64_t CBU_IsHarmonySupported()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  bzero(__s1, 0x400uLL);
  size_t v2 = 1024;
  if (sysctlbyname("kern.bootargs", __s1, &v2, 0, 0) || !strstr(__s1, "FORCE_HARMONY_SUPPORT"))
  {
    char v3 = 0;
  }
  else
  {
    os_log_t oslog = MEMORY[0x1E4F14500];
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_2_1_8_32((uint64_t)v4, (uint64_t)"CBU_IsHarmonySupported");
      _os_log_impl(&dword_1BA438000, oslog, OS_LOG_TYPE_INFO, "%s: boot-arg to enforce harmony support", v4, 0xCu);
    }
    char v3 = 1;
  }
  return v3 & 1;
}

uint64_t CBU_IsNightShiftSupported()
{
  return MGGetBoolAnswer() & 1;
}

BOOL CBU_IsSoftWakeSupported()
{
  return CBU_IsWatch();
}

BOOL CBU_IsWatch()
{
  return MGGetSInt32Answer() == 6;
}

uint64_t CBU_IsSliderCommitTelemetrySupported()
{
  return 1;
}

uint64_t CBU_SyncDisplayStateControlSupported()
{
  if (CBU_SyncDisplayStateControlSupported_SDSC_onceToken != -1) {
    dispatch_once(&CBU_SyncDisplayStateControlSupported_SDSC_onceToken, &__block_literal_global_10);
  }
  return CBU_SyncDisplayStateControlSupported_SDSCEnabled & 1;
}

uint64_t CBU_ForceUpdateFrequencyAndFrameSkip()
{
  if (CBU_ForceUpdateFrequencyAndFrameSkip_once != -1) {
    dispatch_once(&CBU_ForceUpdateFrequencyAndFrameSkip_once, &__block_literal_global_24);
  }
  return CBU_ForceUpdateFrequencyAndFrameSkip_force & 1;
}

uint64_t CBU_ForceFrameAfterBrightnessUpdate()
{
  if (CBU_ForceFrameAfterBrightnessUpdate_once != -1) {
    dispatch_once(&CBU_ForceFrameAfterBrightnessUpdate_once, &__block_literal_global_29);
  }
  return CBU_ForceFrameAfterBrightnessUpdate_force & 1;
}

uint64_t CBU_IsSyncBrightnessTransactionsSupported()
{
  return MGGetBoolAnswer() & 1;
}

uint64_t CBU_RampLumaBoostFactorInAOD()
{
  if (CBU_RampLumaBoostFactorInAOD_once != -1) {
    dispatch_once(&CBU_RampLumaBoostFactorInAOD_once, &__block_literal_global_77);
  }
  return CBU_RampLumaBoostFactorInAOD_result & 1;
}

uint64_t CBU_ShouldWaitForALS()
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  char v2 = 0;
  long long v15 = xmmword_1BA612880;
  int v16 = 414393924;
  long long v13 = xmmword_1BA612894;
  int v14 = 897736383;
  long long v11 = xmmword_1BA6128A8;
  int v12 = -996295886;
  long long v9 = xmmword_1BA6128BC;
  int v10 = -453987047;
  long long v7 = xmmword_1BA6128D0;
  int v8 = -337121064;
  long long v5 = xmmword_1BA6128E4;
  int v6 = 450980336;
  long long v3 = xmmword_1BA6128F8;
  int v4 = -1431778695;
  v1[8]  = v1;
  v1[0]  = &v13;
  v1[1]  = &v11;
  v1[2]  = &v9;
  v1[3]  = &v7;
  v1[4]  = &v5;
  v1[5]  = &v3;
  v1[6]  = 0;
  v1[7]  = 0;
  return MGIsDeviceOneOfType() & 1;
}

BOOL CBU_IsPad()
{
  return MGGetSInt32Answer() == 3;
}

uint64_t __os_log_helper_16_2_3_8_32_8_32_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 32;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  return result;
}

void CBU_GetNightShiftCCTRange(io_registry_entry_t a1, float *a2, float *a3, float *a4, float *a5)
{
  if (a2 && a3 && a4 && a5)
  {
    CFDataRef cf = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", @"blr-cct-min", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (cf)
    {
      CFTypeID TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(cf) && (unint64_t)CFDataGetLength(cf) >= 4) {
        *a2  = (float)*(unsigned int *)CFDataGetBytePtr(cf);
      }
      CFRelease(cf);
    }
    cfa  = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", @"blr-cct-max", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (cfa)
    {
      CFTypeID v7 = CFDataGetTypeID();
      if (v7 == CFGetTypeID(cfa) && (unint64_t)CFDataGetLength(cfa) >= 4) {
        *a4  = (float)*(unsigned int *)CFDataGetBytePtr(cfa);
      }
      CFRelease(cfa);
    }
    cfb  = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", @"blr-cct-default", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (cfb)
    {
      CFTypeID v6 = CFDataGetTypeID();
      if (v6 == CFGetTypeID(cfb) && (unint64_t)CFDataGetLength(cfb) >= 4) {
        *a3  = (float)*(unsigned int *)CFDataGetBytePtr(cfb);
      }
      CFRelease(cfb);
    }
    cfc  = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", @"blr-cct-warning", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (cfc)
    {
      CFTypeID v5 = CFDataGetTypeID();
      if (v5 == CFGetTypeID(cfc) && (unint64_t)CFDataGetLength(cfc) >= 4) {
        *a5  = (float)*(unsigned int *)CFDataGetBytePtr(cfc);
      }
      CFRelease(cfc);
    }
  }
}

uint64_t CBU_ShouldNotHandleExistingInternalDisplayAttachment()
{
  if (CBU_ShouldNotHandleExistingInternalDisplayAttachment_once != -1) {
    dispatch_once(&CBU_ShouldNotHandleExistingInternalDisplayAttachment_once, &__block_literal_global_111);
  }
  return CBU_ShouldNotHandleExistingInternalDisplayAttachment_result & 1;
}

uint64_t CBU_DeviceHasGrimaldi()
{
  return MGGetBoolAnswer() & 1;
}

uint64_t CBU_ImplicitUserInteractedWithUI()
{
  if (CBU_ImplicitUserInteractedWithUI_once != -1) {
    dispatch_once(&CBU_ImplicitUserInteractedWithUI_once, &__block_literal_global_120);
  }
  return CBU_ImplicitUserInteractedWithUI_result & 1;
}

unint64_t readDataFromIOService(io_registry_entry_t a1, const __CFString *a2, UInt8 *a3, CFIndex *a4)
{
  CFTypeRef cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (!cf) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFDataGetTypeID())
  {
    Length  = CFDataGetLength((CFDataRef)cf);
    if (Length >= *a4) {
      CFIndex v5 = *a4;
    }
    else {
      CFIndex v5 = Length;
    }
    *a4  = v5;
    v13.location  = 0;
    v13.length  = v5;
    CFDataGetBytes((CFDataRef)cf, v13, a3);
    unint64_t v8 = Length;
  }
  else
  {
    unint64_t v8 = 0;
  }
  CFRelease(cf);
  return v8;
}

BOOL readExactDataFromIOService(io_registry_entry_t a1, const __CFString *a2, UInt8 *a3, CFIndex a4)
{
  io_registry_entry_t v6 = a1;
  uint64_t v5[3] = (CFIndex)a2;
  void v5[2] = (CFIndex)a3;
  v5[1]  = a4;
  v5[0]  = a4;
  return a4 == readDataFromIOService(a1, a2, a3, v5);
}

void sub_1BA53AF18()
{
  _Unwind_Resume(v0);
}

__CFString *aabUpdateStrategyTypeToString(uint64_t a1)
{
  int v4 = 0;
  if (a1)
  {
    uint64_t v2 = a1;
    char v1 = 1;
  }
  else
  {
    uint64_t v2 = 0;
    char v1 = 0;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        int v4 = @"preference based";
        break;
      case 1:
        int v4 = @"BOLTS";
        break;
      case 2:
        int v4 = @"hybrid with pref based as main and BOLTS as alternative";
        break;
      case 3:
        int v4 = @"hybrid with BOLTS as main and pref based as alternative";
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v4;
}

{
  char v1;
  uint64_t v2;
  __CFString *v4;

  int v4 = 0;
  if (a1)
  {
    uint64_t v2 = a1;
    char v1 = 1;
  }
  else
  {
    uint64_t v2 = 0;
    char v1 = 0;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        int v4 = @"preference based";
        break;
      case 1:
        int v4 = @"BOLTS";
        break;
      case 2:
        int v4 = @"hybrid with pref based as main and BOLTS as alternative";
        break;
      case 3:
        int v4 = @"hybrid with BOLTS as main and pref based as alternative";
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v4;
}

id getMLModelClass_1()
{
  uint64_t v9 = 0;
  int v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLModelClass_softClass_1;
  uint64_t v13 = getMLModelClass_softClass_1;
  if (!getMLModelClass_softClass_1)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    CFIndex v5 = __getMLModelClass_block_invoke_1;
    io_registry_entry_t v6 = &unk_1E6219058;
    CFTypeID v7 = &v9;
    __getMLModelClass_block_invoke_1((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLArrayBatchProviderClass_1()
{
  uint64_t v9 = 0;
  int v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLArrayBatchProviderClass_softClass_1;
  uint64_t v13 = getMLArrayBatchProviderClass_softClass_1;
  if (!getMLArrayBatchProviderClass_softClass_1)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    CFIndex v5 = __getMLArrayBatchProviderClass_block_invoke_1;
    io_registry_entry_t v6 = &unk_1E6219058;
    CFTypeID v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke_1((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke_1(uint64_t a1)
{
  CoreMLLibrary_1();
  Class Class = objc_getClass("MLFeatureValue");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLFeatureValueClass_softClass_1  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary_1()
{
  uint64_t v1 = CoreMLLibraryCore_1();
  if (!v1) {
    abort_report_np();
  }
  return v1;
}

uint64_t CoreMLLibraryCore_1()
{
  if (!CoreMLLibraryCore_frameworkLibrary_1) {
    __CoreMLLibraryCore_block_invoke_1();
  }
  return CoreMLLibraryCore_frameworkLibrary_1;
}

uint64_t __CoreMLLibraryCore_block_invoke_1()
{
  uint64_t result = _sl_dlopen();
  CoreMLLibraryCore_frameworkLibrary_1  = result;
  return result;
}

uint64_t __getMLModelClass_block_invoke_1(uint64_t a1)
{
  CoreMLLibrary_1();
  Class Class = objc_getClass("MLModel");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLModelClass_softClass_1  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke_1(uint64_t a1)
{
  CoreMLLibrary_1();
  Class Class = objc_getClass("MLPredictionOptions");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLPredictionOptionsClass_softClass_1  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke_1(uint64_t a1)
{
  CoreMLLibrary_1();
  Class Class = objc_getClass("MLArrayBatchProvider");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLArrayBatchProviderClass_softClass_1  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t getMLModelConfigurationClass()
{
  uint64_t v9 = 0;
  int v10 = &v9;
  int v11 = 1375731712;
  int v12 = 48;
  uint64_t v13 = __Block_byref_object_copy__14;
  int v14 = __Block_byref_object_dispose__14;
  uint64_t v8 = getMLModelConfigurationClass_softClass;
  uint64_t v15 = getMLModelConfigurationClass_softClass;
  if (!getMLModelConfigurationClass_softClass)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    CFIndex v5 = __getMLModelConfigurationClass_block_invoke;
    io_registry_entry_t v6 = &unk_1E6219058;
    CFTypeID v7 = &v9;
    __getMLModelConfigurationClass_block_invoke((uint64_t)&v2);
  }
  uint64_t v1 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v1;
}

uint64_t __os_log_helper_16_0_11_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 11;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 0;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  *(unsigned char *)(result + 82)  = 0;
  *(unsigned char *)(result + 83)  = 8;
  *(void *)(result + 84)  = a10;
  *(unsigned char *)(result + 92)  = 0;
  *(unsigned char *)(result + 93)  = 8;
  *(void *)(result + 94)  = a11;
  *(unsigned char *)(result + 102)  = 0;
  *(unsigned char *)(result + 103)  = 8;
  *(void *)(result + 104)  = a12;
  return result;
}

uint64_t __getMLModelConfigurationClass_block_invoke(uint64_t a1)
{
  CoreMLLibrary_2();
  Class Class = objc_getClass("MLModelConfiguration");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    uint64_t result = abort_report_np();
  }
  getMLModelConfigurationClass_softClass Class = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t CoreMLLibrary_2()
{
  uint64_t v1 = CoreMLLibraryCore_2();
  if (!v1) {
    abort_report_np();
  }
  return v1;
}

uint64_t CoreMLLibraryCore_2()
{
  if (!CoreMLLibraryCore_frameworkLibrary_2) {
    __CoreMLLibraryCore_block_invoke_2();
  }
  return CoreMLLibraryCore_frameworkLibrary_2;
}

uint64_t __CoreMLLibraryCore_block_invoke_2()
{
  uint64_t result = _sl_dlopen();
  CoreMLLibraryCore_frameworkLibrary_2  = result;
  return result;
}

uint64_t __getMLMultiArrayClass_block_invoke(uint64_t a1)
{
  CoreMLLibrary_2();
  Class Class = objc_getClass("MLMultiArray");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    uint64_t result = abort_report_np();
  }
  getMLMultiArrayClass_softClass Class = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  return result;
}

BOOL isDisplayAvailable(CADisplay *a1)
{
  BOOL v2 = 0;
  if (a1)
  {
    BOOL v2 = 0;
    if (objc_msgSend((id)-[CADisplay currentMode](a1, "currentMode"), "width")) {
      return objc_msgSend((id)-[CADisplay currentMode](a1, "currentMode"), "height") != 0;
    }
  }
  return v2;
}

uint64_t __os_log_helper_16_2_4_8_66_8_66_8_66_8_66(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 66;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 66;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  return result;
}

uint64_t __os_log_helper_16_2_2_4_0_8_66(uint64_t result, int a2, uint64_t a3)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 66;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  return result;
}

void sub_1BA5446D8()
{
  _Unwind_Resume(v0);
}

void sub_1BA545724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v14 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __os_log_helper_16_2_3_8_66_4_0_8_0(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

void sub_1BA547654(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

uint64_t __os_log_helper_16_2_3_8_0_8_66_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  return result;
}

void handleShutdownNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  uint64_t v12 = a2;
  CFIndex v5 = *(NSObject **)(a2 + 24);
  uint64_t block = MEMORY[0x1E4F143A8];
  int v7 = -1073741824;
  int v8 = 0;
  uint64_t v9 = __handleShutdownNotification_block_invoke;
  int v10 = &unk_1E6218FE0;
  uint64_t v11 = a2;
  dispatch_async(v5, &block);
}

void handleAvailabilityNotification(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  uint64_t v12 = a2;
  if (a2)
  {
    CFIndex v5 = *(NSObject **)(v12 + 24);
    uint64_t block = MEMORY[0x1E4F143A8];
    int v7 = -1073741824;
    int v8 = 0;
    uint64_t v9 = __handleAvailabilityNotification_block_invoke;
    int v10 = &unk_1E6218FE0;
    uint64_t v11 = v12;
    dispatch_async(v5, &block);
  }
}

void deviceManagementArrivalCallback(void *a1, io_iterator_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v11 = a1;
  io_iterator_t v10 = a2;
  if (a1 && v10)
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    if (os_log_type_enabled(inited, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v12, (uint64_t)v11);
      _os_log_impl(&dword_1BA438000, inited, OS_LOG_TYPE_DEFAULT, "Device management arrived refcon=%p", v12, 0xCu);
    }
    while (1)
    {
      io_object_t v6 = IOIteratorNext(v10);
      if (!v6) {
        break;
      }
      if (v11) {
        [v11 handleDeviceManagementArrival:v6];
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      CFIndex v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      CFIndex v5 = init_default_corebrightness_log();
    }
    uint64_t v9 = v5;
    char v8 = 16;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v9;
      os_log_type_t type = v8;
      __os_log_helper_16_0_0(v7);
      _os_log_error_impl(&dword_1BA438000, log, type, "error: invalid input", v7, 2u);
    }
  }
}

uint64_t __os_log_helper_16_0_3_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_0_8_0_8_0_8_66(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 66;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_66_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

void __handleShutdownNotification_block_invoke(uint64_t a1)
{
  uint64_t v9 = a1;
  uint64_t v8 = a1;
  if (*(void *)(a1 + 32))
  {
    [*(id *)(a1 + 32) stopRamp];
    [*(id *)(a1 + 32) setUserActive:0];
    [*(id *)(a1 + 32) updateBacklightDeviceWithReason:4];
    int v7 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v7 = inited;
    os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(inited, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t log = v7;
      os_log_type_t type = v6;
      __os_log_helper_16_0_0(v5);
      _os_log_impl(&dword_1BA438000, log, type, "Got shutdown notification -> turned off keyboard backlight", v5, 2u);
    }
  }
}

void __handleAvailabilityNotification_block_invoke(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    if (GSEventIsHardwareKeyboardAttached())
    {
      id v3 = (id)[objc_alloc(NSNumber) initWithBool:1];
      [*(id *)(a1 + 32) KBAvailabilityUpdateHandler:v3];
    }
    else
    {
      [*(id *)(a1 + 32) stopRamp];
      id v2 = (id)[objc_alloc(NSNumber) initWithBool:0];
      [*(id *)(a1 + 32) KBAvailabilityUpdateHandler:v2];
    }
  }
}

uint64_t __os_log_helper_16_2_4_4_0_8_0_8_0_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 32;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  return result;
}

uint64_t __os_log_helper_16_2_17_4_0_8_0_8_0_8_32_8_0_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_0_8_32_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 17;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 32;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 0;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  *(unsigned char *)(result + 58)  = 32;
  *(unsigned char *)(result + 59)  = 8;
  *(void *)(result + 60)  = a8;
  *(unsigned char *)(result + 68)  = 0;
  *(unsigned char *)(result + 69)  = 8;
  *(void *)(result + 70)  = a9;
  *(unsigned char *)(result + 78)  = 32;
  *(unsigned char *)(result + 79)  = 8;
  *(void *)(result + 80)  = a10;
  *(unsigned char *)(result + 88)  = 0;
  *(unsigned char *)(result + 89)  = 8;
  *(void *)(result + 90)  = a11;
  *(unsigned char *)(result + 98)  = 32;
  *(unsigned char *)(result + 99)  = 8;
  *(void *)(result + 100)  = a12;
  *(unsigned char *)(result + 108)  = 0;
  *(unsigned char *)(result + 109)  = 8;
  *(void *)(result + 110)  = a13;
  *(unsigned char *)(result + 118)  = 32;
  *(unsigned char *)(result + 119)  = 8;
  *(void *)(result + 120)  = a14;
  *(unsigned char *)(result + 128)  = 0;
  *(unsigned char *)(result + 129)  = 8;
  *(void *)(result + 130)  = a15;
  *(unsigned char *)(result + 138)  = 0;
  *(unsigned char *)(result + 139)  = 8;
  *(void *)(result + 140)  = a16;
  *(unsigned char *)(result + 148)  = 32;
  *(unsigned char *)(result + 149)  = 8;
  *(void *)(result + 150)  = a17;
  *(unsigned char *)(result + 158)  = 0;
  *(unsigned char *)(result + 159)  = 8;
  *(void *)(result + 160)  = a18;
  return result;
}

uint64_t __os_log_helper_16_0_7_4_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 7;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 0;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  *(unsigned char *)(result + 58)  = 0;
  *(unsigned char *)(result + 59)  = 8;
  *(void *)(result + 60)  = a8;
  return result;
}

void sub_1BA560354()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_8_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 8;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 0;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  return result;
}

float std::__math::sqrt[abi:ne180100](float a1)
{
  return sqrtf(a1);
}

uint64_t __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 8;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 0;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  *(unsigned char *)(result + 58)  = 0;
  *(unsigned char *)(result + 59)  = 8;
  *(void *)(result + 60)  = a8;
  *(unsigned char *)(result + 68)  = 0;
  *(unsigned char *)(result + 69)  = 8;
  *(void *)(result + 70)  = a9;
  return result;
}

uint64_t __os_log_helper_16_2_16_4_0_8_0_8_32_8_0_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_32_8_0_8_0_8_32_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 16;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 32;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 32;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  *(unsigned char *)(result + 58)  = 0;
  *(unsigned char *)(result + 59)  = 8;
  *(void *)(result + 60)  = a8;
  *(unsigned char *)(result + 68)  = 32;
  *(unsigned char *)(result + 69)  = 8;
  *(void *)(result + 70)  = a9;
  *(unsigned char *)(result + 78)  = 0;
  *(unsigned char *)(result + 79)  = 8;
  *(void *)(result + 80)  = a10;
  *(unsigned char *)(result + 88)  = 32;
  *(unsigned char *)(result + 89)  = 8;
  *(void *)(result + 90)  = a11;
  *(unsigned char *)(result + 98)  = 0;
  *(unsigned char *)(result + 99)  = 8;
  *(void *)(result + 100)  = a12;
  *(unsigned char *)(result + 108)  = 32;
  *(unsigned char *)(result + 109)  = 8;
  *(void *)(result + 110)  = a13;
  *(unsigned char *)(result + 118)  = 0;
  *(unsigned char *)(result + 119)  = 8;
  *(void *)(result + 120)  = a14;
  *(unsigned char *)(result + 128)  = 0;
  *(unsigned char *)(result + 129)  = 8;
  *(void *)(result + 130)  = a15;
  *(unsigned char *)(result + 138)  = 32;
  *(unsigned char *)(result + 139)  = 8;
  *(void *)(result + 140)  = a16;
  *(unsigned char *)(result + 148)  = 0;
  *(unsigned char *)(result + 149)  = 8;
  *(void *)(result + 150)  = a17;
  return result;
}

uint64_t __os_log_helper_16_0_9_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 9;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 0;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  *(unsigned char *)(result + 58)  = 0;
  *(unsigned char *)(result + 59)  = 8;
  *(void *)(result + 60)  = a8;
  *(unsigned char *)(result + 68)  = 0;
  *(unsigned char *)(result + 69)  = 8;
  *(void *)(result + 70)  = a9;
  *(unsigned char *)(result + 78)  = 0;
  *(unsigned char *)(result + 79)  = 8;
  *(void *)(result + 80)  = a10;
  return result;
}

float std::__math::exp[abi:ne180100](float a1)
{
  return expf(a1);
}

float std::__math::cos[abi:ne180100](float a1)
{
  return cosf(a1);
}

float std::__math::sin[abi:ne180100](float a1)
{
  return sinf(a1);
}

uint64_t __os_log_helper_16_2_6_8_64_8_64_8_0_4_0_4_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 64;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 4;
  *(_DWORD *)(result + 34)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 4;
  *(_DWORD *)(result + 40)  = a6;
  *(unsigned char *)(result + 44)  = 32;
  *(unsigned char *)(result + 45)  = 8;
  *(void *)(result + 46)  = a7;
  return result;
}

uint64_t __os_log_helper_16_0_4_8_0_8_0_4_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  return result;
}

id getMLModelClass_2()
{
  uint64_t v9 = 0;
  io_iterator_t v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLModelClass_softClass_2;
  uint64_t v13 = getMLModelClass_softClass_2;
  if (!getMLModelClass_softClass_2)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    CFIndex v5 = __getMLModelClass_block_invoke_2;
    os_log_type_t v6 = &unk_1E6219058;
    int v7 = &v9;
    __getMLModelClass_block_invoke_2((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLArrayBatchProviderClass_2()
{
  uint64_t v9 = 0;
  io_iterator_t v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLArrayBatchProviderClass_softClass_2;
  uint64_t v13 = getMLArrayBatchProviderClass_softClass_2;
  if (!getMLArrayBatchProviderClass_softClass_2)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    CFIndex v5 = __getMLArrayBatchProviderClass_block_invoke_2;
    os_log_type_t v6 = &unk_1E6219058;
    int v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke_2((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke_2(uint64_t a1)
{
  CoreMLLibrary_3();
  Class Class = objc_getClass("MLFeatureValue");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLFeatureValueClass_softClass_2  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary_3()
{
  uint64_t v1 = CoreMLLibraryCore_3();
  if (!v1) {
    abort_report_np();
  }
  return v1;
}

uint64_t CoreMLLibraryCore_3()
{
  if (!CoreMLLibraryCore_frameworkLibrary_3) {
    __CoreMLLibraryCore_block_invoke_3();
  }
  return CoreMLLibraryCore_frameworkLibrary_3;
}

uint64_t __CoreMLLibraryCore_block_invoke_3()
{
  uint64_t result = _sl_dlopen();
  CoreMLLibraryCore_frameworkLibrary_3  = result;
  return result;
}

uint64_t __getMLModelClass_block_invoke_2(uint64_t a1)
{
  CoreMLLibrary_3();
  Class Class = objc_getClass("MLModel");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLModelClass_softClass_2  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke_2(uint64_t a1)
{
  CoreMLLibrary_3();
  Class Class = objc_getClass("MLPredictionOptions");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLPredictionOptionsClass_softClass_2  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke_2(uint64_t a1)
{
  CoreMLLibrary_3();
  Class Class = objc_getClass("MLArrayBatchProvider");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLArrayBatchProviderClass_softClass_2  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void displayArrivalCallback(void *a1, io_iterator_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v11 = a1;
  io_iterator_t v10 = a2;
  if (a1 && v10)
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    if (os_log_type_enabled(inited, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v12, (uint64_t)v11);
      _os_log_impl(&dword_1BA438000, inited, OS_LOG_TYPE_DEFAULT, "display arrived refcon=%p", v12, 0xCu);
    }
    while (1)
    {
      io_object_t v6 = IOIteratorNext(v10);
      if (!v6) {
        break;
      }
      [v11 handleDisplayArrival:v6];
    }
  }
  else
  {
    uint64_t v9 = 0;
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      CFIndex v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      CFIndex v5 = init_default_corebrightness_log();
    }
    uint64_t v9 = v5;
    char v8 = 16;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v9;
      os_log_type_t type = v8;
      __os_log_helper_16_0_0(v7);
      _os_log_error_impl(&dword_1BA438000, log, type, "error: invalid input", v7, 2u);
    }
  }
}

uint64_t __os_log_helper_16_2_3_4_0_8_0_8_66(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 66;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

void sub_1BA57FC84(uint64_t a1, int a2)
{
  *(void *)(v2 - 120)  = a1;
  *(_DWORD *)(v2 - 124)  = a2;
  _Block_object_dispose((const void *)(v2 - 64), 8);
  _Unwind_Resume(*(_Unwind_Exception **)(v2 - 120));
}

void sub_1BA58067C()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_2_2_8_66_8_32(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 66;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 32;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  return result;
}

uint64_t __os_log_helper_16_0_4_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 4;
  *(_DWORD *)(result + 34)  = a5;
  return result;
}

float _DisplayPerceptualLuminanceToLuminanceInternal(uint64_t a1, float a2)
{
  float v3 = *(float *)(a1 + 1312);
  return v3 * powf(v3 / *(float *)(a1 + 1320), a2 - 1.0);
}

float DisplayPerceptualLuminanceToLuminance(uint64_t a1, float a2)
{
  uint64_t v19 = a1;
  float v18 = a2;
  uint64_t v13 = 0;
  uint64_t v14 = (float *)&v13;
  int v15 = 0x20000000;
  int v16 = 32;
  int v17 = 0;
  uint64_t v2 = *(NSObject **)(a1 + 144);
  CFIndex v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  char v8 = __DisplayPerceptualLuminanceToLuminance_block_invoke;
  uint64_t v9 = &unk_1E621A430;
  io_iterator_t v10 = &v13;
  uint64_t v11 = v19;
  float v12 = a2;
  disp_dispatch_sync(v2, &v5);
  float v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA589A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __DisplayPerceptualLuminanceToLuminance_block_invoke(uint64_t a1)
{
  float v1 = _DisplayPerceptualLuminanceToLuminanceInternal(*(void *)(a1 + 40), *(float *)(a1 + 48));
  uint64_t result = a1;
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = v1;
  return result;
}

float DisplayReflectedLuminanceToPerceptualLuminance(uint64_t a1, float a2)
{
  uint64_t v19 = a1;
  float v18 = a2;
  uint64_t v13 = 0;
  uint64_t v14 = (float *)&v13;
  int v15 = 0x20000000;
  int v16 = 32;
  int v17 = 0;
  uint64_t v2 = *(NSObject **)(a1 + 144);
  CFIndex v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  char v8 = __DisplayReflectedLuminanceToPerceptualLuminance_block_invoke;
  uint64_t v9 = &unk_1E621A430;
  io_iterator_t v10 = &v13;
  uint64_t v11 = v19;
  float v12 = a2;
  disp_dispatch_sync(v2, &v5);
  float v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA589B64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __DisplayReflectedLuminanceToPerceptualLuminance_block_invoke(uint64_t a1)
{
  float v1 = _DisplayReflectedLuminanceToPerceptualLuminanceInternal(*(void *)(a1 + 40), *(float *)(a1 + 48));
  uint64_t result = a1;
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = v1;
  return result;
}

float _DisplayReflectedLuminanceToPerceptualLuminanceInternal(uint64_t a1, float a2)
{
  float v5 = fminf(fmaxf(a2, 0.01), *(float *)(a1 + 1312));
  float v2 = *(float *)(a1 + 1312) / 0.01;
  float v4 = logf(v2);
  return (float)(logf(v5 / *(float *)(a1 + 1312)) / v4) + 1.0;
}

float _DisplayPerceptualLuminanceToReflectedLuminanceInternal(uint64_t a1, float a2)
{
  float v4 = *(float *)(a1 + 1312);
  float v2 = v4 / 0.01;
  return v4 * powf(v2, a2 - 1.0);
}

float DisplayPerceptualLuminanceToReflectedLuminance(uint64_t a1, float a2)
{
  uint64_t v19 = a1;
  float v18 = a2;
  uint64_t v13 = 0;
  uint64_t v14 = (float *)&v13;
  int v15 = 0x20000000;
  int v16 = 32;
  int v17 = 0;
  float v2 = *(NSObject **)(a1 + 144);
  float v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  char v8 = __DisplayPerceptualLuminanceToReflectedLuminance_block_invoke;
  uint64_t v9 = &unk_1E621A430;
  io_iterator_t v10 = &v13;
  uint64_t v11 = v19;
  float v12 = a2;
  disp_dispatch_sync(v2, &v5);
  float v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA589DE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __DisplayPerceptualLuminanceToReflectedLuminance_block_invoke(uint64_t a1)
{
  float v1 = _DisplayPerceptualLuminanceToReflectedLuminanceInternal(*(void *)(a1 + 40), *(float *)(a1 + 48));
  uint64_t result = a1;
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = v1;
  return result;
}

uint64_t DisplayGetTypeID()
{
  if (!__kHIDDisplayTypeID) {
    pthread_once(&__displayTypeInit, (void (*)(void))__DisplayRegister);
  }
  return __kHIDDisplayTypeID;
}

uint64_t __DisplayRegister()
{
  uint64_t result = _CFRuntimeRegisterClass();
  __kHIDDisplayCFTypeID TypeID = result;
  return result;
}

uint64_t DisplaySetHarmonyEnabled(uint64_t result, char a2)
{
  *(unsigned char *)(result + 12515)  = a2 & 1;
  return result;
}

uint64_t DisplaySetBLREnabled(uint64_t result, char a2)
{
  *(unsigned char *)(result + 12512)  = a2 & 1;
  return result;
}

uint64_t __DisplayRequiresBDM_block_invoke(uint64_t a1)
{
  uint64_t v5 = a1;
  uint64_t v4 = a1;
  int v3 = 0;
  CFTypeRef v2 = IORegistryEntrySearchCFProperty(*(_DWORD *)(*(void *)(a1 + 32) + 80), "IOService", @"use-bright-dot-mitigation", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  uint64_t result = _DisplayGetUint32FromCFDataAndRelease(v2, &v3);
  if (result) {
    DisplayRequiresBDM_requiresBDM  = v3 != 0;
  }
  return result;
}

uint64_t _DisplayGetUint32FromCFDataAndRelease(const void *a1, _DWORD *a2)
{
  CFTypeRef v7 = a1;
  int v6 = a2;
  char v5 = 0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(v7);
    if (v3 == CFDataGetTypeID())
    {
      *(_DWORD *)buffer  = 0;
      if (CFDataGetLength((CFDataRef)v7) == 4)
      {
        uint64_t v9 = 0;
        uint64_t v8 = 4;
        uint64_t v10 = 0;
        uint64_t v11 = 4;
        v12.location  = 0;
        v12.length  = 4;
        CFDataGetBytes((CFDataRef)v7, v12, buffer);
        *int v6 = *(_DWORD *)buffer;
        char v5 = 1;
      }
    }
    CFRelease(v7);
  }
  return v5 & 1;
}

CFTypeRef DisplayCreate(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return DisplayCreateWithCapabilitiesAndID(a1, a2, a3, 0);
}

CFTypeRef DisplayCreateWithCapabilitiesAndID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFAllocatorRef v4 = (const __CFAllocator *)MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v379 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef allocator = v4;
  object  = v5;
  target  = v6;
  uint64_t v326 = v7;
  int v325 = v8;
  _logHandle  = (uint64_t)os_log_create("com.apple.CoreBrightness.Display", "default");
  CFTypeRef cf = 0;
  CFProperty  = 0;
  CFTypeRef v321 = 0;
  Private  = (CFTypeRef)__DisplayCreatePrivate();
  if (!Private) {
    return 0;
  }
  *((_DWORD *)Private + 69)  = 0;
  *((float *)Private + 70)  = -1.0;
  *((_DWORD *)Private + 55)  = 0;
  *((_DWORD *)Private + 56)  = 0;
  *((_DWORD *)Private + 57)  = 0;
  *((void *)Private + 2)  = 0;
  *((_DWORD *)Private + 10)  = 0;
  *((_DWORD *)Private + 3148)  = v325;
  *((_DWORD *)Private + 3149)  = 0;
  *((_DWORD *)Private + 3150)  = 0;
  *((unsigned char *)Private + 321)  = 0;
  *((unsigned char *)Private + 322)  = 0;
  *((unsigned char *)Private + 323)  = 0;
  *((void *)Private + 26)  = 0;
  *((_DWORD *)Private + 54)  = 1199570944;
  *((unsigned char *)Private + 12712)  = 0;
  mach_timebase_info info = 0;
  mach_timebase_info(&info);
  LODWORD(v10)  = info.denom;
  LODWORD(v9)  = info.numer;
  *((double *)Private + 7)  = (double)v9 / (double)v10 * 0.000000001;
  if (!object) {
    goto LABEL_495;
  }
  if (IOObjectRetain(object)) {
    goto LABEL_495;
  }
  *((_DWORD *)Private + 20)  = object;
  *((void *)Private + 15)  = 0;
  *((void *)Private + 16)  = 0;
  CFTypeRef v11 = CFRetain(@"CBUser-0");
  *((void *)Private + 1590)  = v11;
  CFDictionaryRef v318 = 0;
  number  = 0;
  CFDictionaryRef theDict = (CFDictionaryRef)IORegistryEntryCreateCFProperty(object, @"IODisplayParameters", allocator, 0);
  if (!theDict) {
    goto LABEL_495;
  }
  CFDictionaryRef v318 = (CFDictionaryRef)CFDictionaryGetValue(theDict, @"brightness");
  if (v318)
  {
    number  = (CFNumberRef)CFDictionaryGetValue(v318, @"value");
    if (number)
    {
      CFNumberGetValue(number, kCFNumberSInt32Type, (char *)Private + 1244);
      number  = (CFNumberRef)CFDictionaryGetValue(v318, @"min");
      if (number)
      {
        CFNumberGetValue(number, kCFNumberSInt32Type, (char *)Private + 1236);
        number  = (CFNumberRef)CFDictionaryGetValue(v318, @"max");
        if (number) {
          CFNumberGetValue(number, kCFNumberSInt32Type, (char *)Private + 1240);
        }
      }
    }
  }
  CFRelease(theDict);
  CFTypeRef cf = IORegistryEntryCreateCFProperty(object, @"new-backlight-architecture", allocator, 0);
  if (cf && cf == (CFTypeRef)*MEMORY[0x1E4F1CFD0])
  {
    *((_DWORD *)Private + 8)  = 1;
    os_log_t oslog = 0;
    if (_logHandle)
    {
      float v154 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v154 = inited;
    }
    os_log_t oslog = v154;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t log = oslog;
      os_log_type_t v152 = type;
      __os_log_helper_16_0_0(v314);
      _os_log_impl(&dword_1BA438000, log, v152, "New backlight architecture.", v314, 2u);
    }
  }
  else
  {
    pthread_once(&__displayThreadInit, (void (*)(void))__DisplayBrightnessThreadInit);
    *((_DWORD *)Private + 9)  = 1;
  }
  if (cf) {
    CFRelease(cf);
  }
  CFProperty  = IORegistryEntryCreateCFProperty(object, @"backlight-calibration-parameters", allocator, 0);
  if (CFProperty)
  {
    CFTypeID v150 = CFGetTypeID(CFProperty);
    if (v150 == CFDictionaryGetTypeID())
    {
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"current-for-max-backlight");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1288);
      *((float *)Private + 322)  = *((float *)Private + 322) / 65536.0;
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"current-for-mid-backlight");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1292);
      *((float *)Private + 323)  = *((float *)Private + 323) / 65536.0;
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"hardware-max-current-limit");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1296);
      *((float *)Private + 324)  = *((float *)Private + 324) / 65536.0;
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"lMaxProduct");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1300);
      *((float *)Private + 325)  = *((float *)Private + 325) / 65536.0;
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"lMidProduct");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1304);
      *((float *)Private + 326)  = *((float *)Private + 326) / 65536.0;
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"lMinProduct");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1308);
      *((float *)Private + 327)  = *((float *)Private + 327) / 65536.0;
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"lMaxPanel");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1312);
      *((float *)Private + 328)  = *((float *)Private + 328) / 65536.0;
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"lMidPanel");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1316);
      *((float *)Private + 329)  = *((float *)Private + 329) / 65536.0;
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"lMinPanel");
      CFNumberGetValue(number, kCFNumberFloatType, (char *)Private + 1320);
      *((float *)Private + 330)  = *((float *)Private + 330) / 65536.0;
      *((_DWORD *)Private + 331)  = *((_DWORD *)Private + 328);
      number  = (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)CFProperty, @"milliAmps2NitsScaleFactor");
      if (number)
      {
        float valuePtr = 0.0;
        float valuePtr = *((float *)Private + 328);
        CFNumberGetValue(number, kCFNumberFloatType, &valuePtr);
        if (valuePtr > 0.0) {
          *((float *)Private + 331)  = valuePtr / 65536.0;
        }
      }
      os_log_t v312 = 0;
      if (_logHandle)
      {
        CFTypeID v149 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v148 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v148 = init_default_corebrightness_log();
        }
        CFTypeID v149 = v148;
      }
      os_log_t v312 = v149;
      os_log_type_t v311 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v378, COERCE__INT64(*((float *)Private + 322)));
        _os_log_impl(&dword_1BA438000, v312, v311, "I_max=%f", v378, 0xCu);
      }
      os_log_t v310 = 0;
      if (_logHandle)
      {
        uint64_t v147 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v146 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v146 = init_default_corebrightness_log();
        }
        uint64_t v147 = v146;
      }
      os_log_t v310 = v147;
      os_log_type_t v309 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v377, COERCE__INT64(*((float *)Private + 323)));
        _os_log_impl(&dword_1BA438000, v310, v309, "I_mid=%f", v377, 0xCu);
      }
      os_log_t v308 = 0;
      if (_logHandle)
      {
        os_log_type_t v145 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v144 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v144 = init_default_corebrightness_log();
        }
        os_log_type_t v145 = v144;
      }
      os_log_t v308 = v145;
      os_log_type_t v307 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v376, COERCE__INT64(*((float *)Private + 324)));
        _os_log_impl(&dword_1BA438000, v308, v307, "Ihw_max=%f", v376, 0xCu);
      }
      os_log_t v306 = 0;
      if (_logHandle)
      {
        CFTypeID v143 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v142 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v142 = init_default_corebrightness_log();
        }
        CFTypeID v143 = v142;
      }
      os_log_t v306 = v143;
      os_log_type_t v305 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v375, COERCE__INT64(*((float *)Private + 325)));
        _os_log_impl(&dword_1BA438000, v306, v305, "Lmax_product=%f", v375, 0xCu);
      }
      os_log_t v304 = 0;
      if (_logHandle)
      {
        uint64_t v141 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v140 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v140 = init_default_corebrightness_log();
        }
        uint64_t v141 = v140;
      }
      os_log_t v304 = v141;
      os_log_type_t v303 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v374, COERCE__INT64(*((float *)Private + 326)));
        _os_log_impl(&dword_1BA438000, v304, v303, "Lmid_product=%f", v374, 0xCu);
      }
      os_log_t v302 = 0;
      if (_logHandle)
      {
        os_log_type_t v139 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v138 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v138 = init_default_corebrightness_log();
        }
        os_log_type_t v139 = v138;
      }
      os_log_t v302 = v139;
      os_log_type_t v301 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v373, COERCE__INT64(*((float *)Private + 327)));
        _os_log_impl(&dword_1BA438000, v302, v301, "Lmin_product=%f", v373, 0xCu);
      }
      os_log_t v300 = 0;
      if (_logHandle)
      {
        CFTypeID v137 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v136 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v136 = init_default_corebrightness_log();
        }
        CFTypeID v137 = v136;
      }
      os_log_t v300 = v137;
      os_log_type_t v299 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v372, COERCE__INT64(*((float *)Private + 328)));
        _os_log_impl(&dword_1BA438000, v300, v299, "Lmax_panel=%f", v372, 0xCu);
      }
      os_log_t v298 = 0;
      if (_logHandle)
      {
        uint64_t v135 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v134 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v134 = init_default_corebrightness_log();
        }
        uint64_t v135 = v134;
      }
      os_log_t v298 = v135;
      os_log_type_t v297 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v371, COERCE__INT64(*((float *)Private + 329)));
        _os_log_impl(&dword_1BA438000, v298, v297, "Lmid_panel=%f", v371, 0xCu);
      }
      os_log_t v296 = 0;
      if (_logHandle)
      {
        os_log_t v133 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v132 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v132 = init_default_corebrightness_log();
        }
        os_log_t v133 = v132;
      }
      os_log_t v296 = v133;
      os_log_type_t v295 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v370, COERCE__INT64(*((float *)Private + 330)));
        _os_log_impl(&dword_1BA438000, v296, v295, "Lmin_panel=%f", v370, 0xCu);
      }
      os_log_t v294 = 0;
      if (_logHandle)
      {
        CFTypeID v131 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v130 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v130 = init_default_corebrightness_log();
        }
        CFTypeID v131 = v130;
      }
      os_log_t v294 = v131;
      os_log_type_t v293 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v369, COERCE__INT64(*((float *)Private + 331)));
        _os_log_impl(&dword_1BA438000, v294, v293, "milliAmps2NitsScaleFactor=%f", v369, 0xCu);
      }
      if ([+[CBAODState sharedInstance] enableAODLiveON])
      {
        long long v367 = xmmword_1BA6131E4;
        int v368 = 713503427;
        long long v365 = xmmword_1BA6131F8;
        int v366 = -1632750650;
        if (MGIsDeviceOneOfType()) {
          *((float *)Private + 330)  = 2.0;
        }
      }
    }
    CFRelease(CFProperty);
  }
  else
  {
    *((float *)Private + 330)  = 5.0;
    *((float *)Private + 327)  = 5.0;
    *((_DWORD *)Private + 329)  = 1124859904;
    *((_DWORD *)Private + 326)  = 1124859904;
    *((_DWORD *)Private + 328)  = 1137180672;
    *((_DWORD *)Private + 325)  = 1137180672;
    float v12 = _DisplaySliderToLogicalBrightnessInternal((uint64_t)Private, 0.0);
    *((float *)Private + 330)  = v12;
    *((float *)Private + 327)  = v12;
    float v13 = _DisplaySliderToLogicalBrightnessInternal((uint64_t)Private, 0.5);
    *((float *)Private + 329)  = v13;
    *((float *)Private + 326)  = v13;
    float v14 = _DisplaySliderToLogicalBrightnessInternal((uint64_t)Private, 1.0);
    *((float *)Private + 328)  = v14;
    *((float *)Private + 325)  = v14;
    *((_DWORD *)Private + 331)  = *((_DWORD *)Private + 328);
  }
  *((_DWORD *)Private + 386)  = *((_DWORD *)Private + 328);
  *((_DWORD *)Private + 383)  = *((_DWORD *)Private + 330);
  *((unsigned char *)Private + 1548)  = 0;
  CFTypeRef v292 = 0;
  uint64_t v129 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  CFTypeRef v292 = IORegistryEntrySearchCFProperty(object, "IOService", @"digital-dimming-min-nits", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  unsigned int v291 = 0;
  unsigned int v291 = (float)(*((float *)Private + 383) * 65536.0);
  _DisplayGetUint32FromCFDataAndRelease(v292, &v291);
  *((float *)Private + 382)  = (float)v291 / 65536.0;
  CFTypeRef v292 = IORegistryEntrySearchCFProperty(object, "IOService", @"user-accessible-max-nits", *v129, 3u);
  unsigned int v290 = 0;
  unsigned int v290 = (float)(*((float *)Private + 386) * 65536.0);
  _DisplayGetUint32FromCFDataAndRelease(v292, &v290);
  *((float *)Private + 384)  = (float)v290 / 65536.0;
  CFTypeRef v292 = IORegistryEntrySearchCFProperty(object, "IOService", @"aot-accessible-min-nits", *v129, 3u);
  unsigned int v289 = 0;
  unsigned int v289 = (float)(*((float *)Private + 330) * 65536.0);
  _DisplayGetUint32FromCFDataAndRelease(v292, &v289);
  *((float *)Private + 385)  = (float)v289 / 65536.0;
  *((unsigned char *)Private + 1516)  = *((float *)Private + 383) > *((float *)Private + 382);
  *((unsigned char *)Private + 1517)  = *((float *)Private + 386) > *((float *)Private + 384);
  CFTypeRef v321 = IORegistryEntryCreateCFProperty(object, @"backlight-marketing-table", *v129, 0);
  if (v321)
  {
    CFTypeID v128 = CFGetTypeID(v321);
    if (v128 == CFDataGetTypeID())
    {
      count  = CFDataGetLength((CFDataRef)v321) / 4uLL;
      float v287 = (float *)malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
      BytePtr  = CFDataGetBytePtr((CFDataRef)v321);
      for (unsigned int i = 0; i < (uint64_t)count; ++i)
      {
        int v284 = 0;
        int v15 = (int *)BytePtr;
        BytePtr += 4;
        int v284 = *v15;
        v287[i]  = (float)v284 / 65536.0;
      }
      float v283 = 0.0;
      float v283 = *((float *)Private + 386);
      float v282 = 0.0;
      float v282 = *((float *)Private + 383);
      os_log_t v281 = 0;
      if (_logHandle)
      {
        os_log_t v127 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v126 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v126 = init_default_corebrightness_log();
        }
        os_log_t v127 = v126;
      }
      os_log_t v281 = v127;
      os_log_type_t v280 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v364, COERCE__INT64(*((float *)Private + 386)), COERCE__INT64(*((float *)Private + 383)), COERCE__INT64(*((float *)Private + 384)), COERCE__INT64(*((float *)Private + 382)), 0x3FF0000000000000, count);
        _os_log_debug_impl(&dword_1BA438000, v281, v280, "Digital dimming params: hardware max: %f, hardware min: %f, user accessible max: %f, dig.dimming min: %f, midpointfactor: %f, mark table entries count: %ld", v364, 0x3Eu);
      }
      float v279 = 1.0;
      if (*((unsigned char *)Private + 1516))
      {
        for (unint64_t j = 0; j < (uint64_t)count / 2; ++j)
        {
          float v277 = 0.0;
          float v277 = (float)(*((float *)Private + 382) / v282)
               + (float)((float)((float)j / (float)((uint64_t)count / 2 - 1))
                       * (float)(1.0 - (float)(*((float *)Private + 382) / v282)));
          v287[j]  = v287[j] * v277;
          v276  = 0;
          if (_logHandle)
          {
            CFTypeID v125 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v124 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v124 = init_default_corebrightness_log();
            }
            CFTypeID v125 = v124;
          }
          v276  = v125;
          os_log_type_t v275 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v363, j, COERCE__INT64(v287[j]), COERCE__INT64(v277));
            _os_log_debug_impl(&dword_1BA438000, v276, v275, "Rescaled marketing table %ld: %f (factor %f)", v363, 0x20u);
          }
        }
      }
      if (*((unsigned char *)Private + 1517))
      {
        for (size_t k = (uint64_t)count / 2; k < count; ++k)
        {
          float v273 = 0.0;
          float v273 = (float)((float)((float)(k - (uint64_t)count / 2) / (float)(uint64_t)(count - 1 - (uint64_t)count / 2))
                       * (float)((float)(*((float *)Private + 384) / v283) - 1.0))
               + 1.0;
          v287[k]  = v287[k] * v273;
          os_log_t v272 = 0;
          if (_logHandle)
          {
            uint64_t v123 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v122 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v122 = init_default_corebrightness_log();
            }
            uint64_t v123 = v122;
          }
          os_log_t v272 = v123;
          os_log_type_t v271 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v123, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v362, k, COERCE__INT64(v287[k]), COERCE__INT64(v273));
            _os_log_debug_impl(&dword_1BA438000, v272, v271, "Rescaled marketing table %ld: %f (factor %f)", v362, 0x20u);
          }
        }
      }
      *((void *)Private + 9)  = v287;
      *((_DWORD *)Private + 16)  = count;
    }
    CFRelease(v321);
  }
  else
  {
    if (*((_DWORD *)Private + 8)) {
      goto LABEL_495;
    }
    uint64_t v360 = 0x430C000040A00000;
    int v361 = 1137180672;
    int v270 = 3;
    int v16 = malloc_type_calloc(3uLL, 4uLL, 0x100004052888210uLL);
    *((void *)Private + 9)  = v16;
    *((_DWORD *)Private + 16)  = v270;
    __memcpy_chk();
  }
  os_log_t v269 = 0;
  if (_logHandle)
  {
    uint64_t v121 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v120 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v120 = init_default_corebrightness_log();
    }
    uint64_t v121 = v120;
  }
  os_log_t v269 = v121;
  os_log_type_t v268 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v359, COERCE__INT64(*((float *)Private + 330)), COERCE__INT64(*((float *)Private + 329)), COERCE__INT64(*((float *)Private + 328)));
    _os_log_debug_impl(&dword_1BA438000, v269, v268, "Original panel calibration data: %f %f %f", v359, 0x20u);
  }
  if (*((unsigned char *)Private + 1516))
  {
    int v17 = *((_DWORD *)Private + 382);
    *((_DWORD *)Private + 330)  = v17;
    *((_DWORD *)Private + 327)  = v17;
  }
  if (*((unsigned char *)Private + 1517))
  {
    int v18 = *((_DWORD *)Private + 384);
    *((_DWORD *)Private + 328)  = v18;
    *((_DWORD *)Private + 325)  = v18;
  }
  os_log_t v267 = 0;
  if (_logHandle)
  {
    CFTypeID v119 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v118 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v118 = init_default_corebrightness_log();
    }
    CFTypeID v119 = v118;
  }
  os_log_t v267 = v119;
  os_log_type_t v266 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v119, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v358, COERCE__INT64(*((float *)Private + 330)), COERCE__INT64(*((float *)Private + 329)), COERCE__INT64(*((float *)Private + 328)));
    _os_log_debug_impl(&dword_1BA438000, v267, v266, "Overridden panel calibration data: %f %f %f", v358, 0x20u);
  }
  *((_DWORD *)Private + 75)  = 0;
  CFTypeRef v265 = 0;
  CFTypeRef v265 = IORegistryEntrySearchCFProperty(object, "IOService", @"nits2mAmps0thOrderCoef", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (v265)
  {
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v265) && (unint64_t)CFDataGetLength((CFDataRef)v265) >= 4)
    {
      CFDataGetBytePtr((CFDataRef)v265);
      __memcpy_chk();
    }
  }
  if (v265) {
    CFRelease(v265);
  }
  *((_DWORD *)Private + 74)  = 1310720;
  CFTypeRef v265 = IORegistryEntrySearchCFProperty(object, "IOService", @"nits2mAmps1stOrderCoef", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (v265)
  {
    v116  = CFDataGetTypeID();
    if (v116 == CFGetTypeID(v265) && (unint64_t)CFDataGetLength((CFDataRef)v265) >= 4)
    {
      CFDataGetBytePtr((CFDataRef)v265);
      __memcpy_chk();
    }
  }
  if (v265) {
    CFRelease(v265);
  }
  *((_DWORD *)Private + 73)  = 0;
  CFTypeRef v265 = IORegistryEntrySearchCFProperty(object, "IOService", @"nits2mAmps2ndOrderCoef", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (v265)
  {
    CFTypeID v115 = CFDataGetTypeID();
    if (v115 == CFGetTypeID(v265) && (unint64_t)CFDataGetLength((CFDataRef)v265) >= 4)
    {
      CFDataGetBytePtr((CFDataRef)v265);
      __memcpy_chk();
    }
  }
  if (v265) {
    CFRelease(v265);
  }
  *((_DWORD *)Private + 76)  = 1072064102;
  *((unsigned char *)Private + 312)  = 0;
  *((float *)Private + 79)  = -1.0;
  *((_DWORD *)Private + 77)  = 0;
  CFTypeRef v265 = IORegistryEntrySearchCFProperty(object, "IOService", @"display-type-A", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (v265)
  {
    CFTypeID v114 = CFDataGetTypeID();
    if (v114 == CFGetTypeID(v265))
    {
      CFDataGetBytePtr((CFDataRef)v265);
      __memcpy_chk();
      os_log_t v264 = 0;
      if (_logHandle)
      {
        CFTypeID v113 = _logHandle;
      }
      else
      {
        uint64_t v112 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        CFTypeID v113 = v112;
      }
      os_log_t v264 = v113;
      os_log_type_t v263 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
      {
        CFTypeID v110 = v264;
        os_log_type_t v111 = v263;
        __os_log_helper_16_0_0(v262);
        _os_log_impl(&dword_1BA438000, v110, v111, "New backlight architecture.", v262, 2u);
      }
    }
  }
  if (v265) {
    CFRelease(v265);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((void *)Private + 24)  = Mutable;
  if (*((void *)Private + 24))
  {
    context  = (void *)MEMORY[0x1BA9ECAE0](Mutable, v20);
    value  = 0;
    v356[0]  = @"HardwareAccessibleMaxNits";
    v357[0]  = [NSNumber numberWithDouble:*((float *)Private + 386)];
    v356[1]  = @"UserAccessibleMaxNits";
    v357[1]  = [NSNumber numberWithDouble:*((float *)Private + 384)];
    v356[2]  = @"HardwareAccessibleMinNits";
    v357[2]  = [NSNumber numberWithDouble:*((float *)Private + 383)];
    uint64_t v356[3] = @"MinNitsAccessibleWithDigitalDimming";
    v357[3]  = [NSNumber numberWithDouble:*((float *)Private + 382)];
    v356[4]  = @"DigitalDimmingSupported";
    v357[4]  = [NSNumber numberWithBool:*((unsigned char *)Private + 1516) & 1];
    v356[5]  = @"ExtrabrightEDRSupported";
    v357[5]  = [NSNumber numberWithBool:*((unsigned char *)Private + 1517) & 1];
    value  = (void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v357 forKeys:v356 count:6];
    CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"VirtualBrightnessLimits", value);
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1320);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayPanelLuminanceMin", number);
      CFRelease(number);
    }
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1316);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayPanelLuminanceMid", number);
      CFRelease(number);
    }
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1312);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayPanelLuminanceMax", number);
      CFRelease(number);
    }
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1308);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayProductLuminanceMin", number);
      CFRelease(number);
    }
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1304);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayProductLuminanceMid", number);
      CFRelease(number);
    }
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1300);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayProductLuminanceMax", number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 21)  = 0;
    *((_DWORD *)Private + 22)  = 1;
    *((void *)Private + 12)  = 0;
    number  = CFNumberCreate(allocator, kCFNumberIntType, (char *)Private + 308);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayTypeA", number);
      CFRelease(number);
    }
    int v260 = 0;
    CFTypeRef v259 = 0;
    CFTypeRef v259 = IORegistryEntrySearchCFProperty(object, "IOService", @"default-curve-version", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v259)
    {
      CFTypeID v108 = CFDataGetTypeID();
      if (v108 == CFGetTypeID(v259))
      {
        int v260 = *(_DWORD *)CFDataGetBytePtr((CFDataRef)v259);
        number  = CFNumberCreate(allocator, kCFNumberIntType, &v260);
        if (number)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DefaultCurveVersion", number);
          CFRelease(number);
        }
      }
      CFRelease(v259);
    }
    int v258 = 0;
    CFTypeRef v257 = 0;
    CFTypeRef v257 = IORegistryEntrySearchCFProperty(object, "IOService", @"raise-high-curve", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v257)
    {
      CFTypeID v107 = CFDataGetTypeID();
      if (v107 == CFGetTypeID(v257))
      {
        int v258 = *(_DWORD *)CFDataGetBytePtr((CFDataRef)v257);
        number  = CFNumberCreate(allocator, kCFNumberIntType, &v258);
        if (number)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"RaiseHighCurve", number);
          CFRelease(number);
        }
      }
      CFRelease(v257);
    }
    int v256 = 0;
    if (!(load_int_from_edt(object, @"plt-logic-version", &v256) & 1)) {
      int v256 = 0;
    }
    CFTypeRef v254 = CFNumberCreate(allocator, kCFNumberIntType, &v256);
    if (v254)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"plt-logic-version", v254);
      CFRelease(v254);
    }
    *((float *)Private + 285)  = 1.0;
    *((unsigned char *)Private + 1048)  = 0;
    *((unsigned char *)Private + 1120)  = 0;
    char v253 = 0;
    GlobalScalarFromDevice  = _DisplayGetGlobalScalarFromDevice((uint64_t)Private, object);
    *((float *)Private + 285)  = GlobalScalarFromDevice;
    *((unsigned char *)Private + 972)  = 0;
    uint64_t v22 = [CBBacklightNode alloc];
    id v252 = [(CBBacklightNode *)v22 initWithService:object];
    RestrictionDictionary  = _DisplayCreateRestrictionDictionary(object, v252);
    if (RestrictionDictionary)
    {
      CFTypeRef v250 = CFDictionaryGetValue(RestrictionDictionary, @"multi_point");
      if (v250)
      {
        CFTypeID v106 = CFGetTypeID(v250);
        if (v106 == CFBooleanGetTypeID())
        {
          BOOL v23 = CFBooleanGetValue((CFBooleanRef)v250) != 0;
          *((unsigned char *)Private + 972)  = v23;
        }
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"BrightnessRestrictions", RestrictionDictionary);
      CFRelease(RestrictionDictionary);
      char v253 = 1;
    }

    if (*((float *)Private + 285) < 1.0 || (v253 & 1) != 0)
    {
      CFPreferencesSynchronize(@"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
      if (v253)
      {
        CFTypeRef v249 = 0;
        CFTypeRef v249 = CFPreferencesCopyValue(@"DynamicSliderEnable", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
        if (v249)
        {
          CFTypeID v105 = CFGetTypeID(v249);
          if (v105 == CFNumberGetTypeID())
          {
            int v248 = 1;
            CFNumberGetValue((CFNumberRef)v249, kCFNumberIntType, &v248);
            *((unsigned char *)Private + 1048)  = v248 == 0;
            *((unsigned char *)Private + 1120)  = v248 == 0;
            CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DynamicSliderEnable", v249);
          }
          CFRelease(v249);
        }
      }
      if (*((float *)Private + 285) < 1.0)
      {
        CFTypeRef v247 = 0;
        CFTypeRef v247 = CFPreferencesCopyValue(@"BrightnessGlobalScalar", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
        if (v247)
        {
          CFTypeID v104 = CFGetTypeID(v247);
          if (v104 == CFNumberGetTypeID())
          {
            int v246 = 1;
            CFNumberGetValue((CFNumberRef)v247, kCFNumberIntType, &v246);
            if (!v246)
            {
              *((float *)Private + 285)  = 1.0;
              CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"BrightnessGlobalScalar", @"disabled");
            }
          }
          CFRelease(v247);
        }
      }
    }
    int v245 = 0;
    CFTypeRef v244 = 0;
    CFTypeRef v244 = IORegistryEntrySearchCFProperty(object, "IOService", @"supports-edm", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    _DisplayGetUint32FromCFDataAndRelease(v244, &v245);
    CFTypeID v103 = (__CFDictionary *)*((void *)Private + 24);
    if (v245) {
      CFDictionarySetValue(v103, @"EDMSupported", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    else {
      CFDictionarySetValue(v103, @"EDMSupported", (const void *)*MEMORY[0x1E4F1CFC8]);
    }
    AABConstraintDictionary  = _DisplayCreateAABConstraintDictionary(object);
    if (AABConstraintDictionary)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"AABConstraints", AABConstraintDictionary);
      CFRelease(AABConstraintDictionary);
    }
    AABCapDictionary  = _DisplayCreateAABCapDictionary(object);
    if (AABCapDictionary)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"AABCurveCap", AABCapDictionary);
      CFRelease(AABCapDictionary);
    }
    *((unsigned char *)Private + 232)  = 0;
    *((_DWORD *)Private + 62)  = 0;
    *((float *)Private + 61)  = -1.0;
    *((_DWORD *)Private + 63)  = -1;
    *((_DWORD *)Private + 65)  = -1;
    *((_DWORD *)Private + 64)  = -1;
    unsigned int v241 = 0;
    CFTypeRef v240 = 0;
    CFTypeRef v240 = IORegistryEntrySearchCFProperty(object, "IOService", @"pre-strobe-dim-period", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(v240, &v241))
    {
      *((float *)Private + 61)  = (float)v241 / 1000.0;
      *((_DWORD *)Private + 62)  = 0;
    }
    CFTypeRef v240 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)Private + 244);
    if (v240)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"PreStrobeDimPeriod", v240);
      CFRelease(v240);
    }
    int v239 = 0;
    CFTypeRef v238 = 0;
    CFTypeRef v238 = IORegistryEntrySearchCFProperty(object, "IOService", @"pre-strobe-current", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(v238, &v239)) {
      *((_DWORD *)Private + 62)  = 1;
    }
    int v237 = 0;
    CFTypeRef v236 = 0;
    CFTypeRef v236 = IORegistryEntrySearchCFProperty(object, "IOService", @"pre-strobe-nit", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(v236, &v237))
    {
      *((_DWORD *)Private + 62)  = 1;
      int v24 = v237 << 16;
      *((_DWORD *)Private + 63)  = v237 << 16;
      *((_DWORD *)Private + 64)  = v24;
    }
    int v235 = 0;
    CFTypeRef v234 = 0;
    CFTypeRef v234 = IORegistryEntrySearchCFProperty(object, "IOService", @"pre-strobe-drop-als-samples", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    _DisplayGetUint32FromCFDataAndRelease(v234, &v235);
    CFTypeID v102 = (__CFDictionary *)*((void *)Private + 24);
    if (v235) {
      CFDictionarySetValue(v102, @"PreStrobeDropALSSamples", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    else {
      CFDictionarySetValue(v102, @"PreStrobeDropALSSamples", (const void *)*MEMORY[0x1E4F1CFC8]);
    }
    int v233 = 0;
    CFTypeRef v232 = 0;
    CFTypeRef v232 = IORegistryEntrySearchCFProperty(object, "IOService", @"sync-wake-ramp", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(v232, &v233)) {
      *((_DWORD *)Private + 21)  = v233 != 0;
    }
    int v231 = -1;
    CFDictionaryRef v230 = 0;
    CFDictionaryRef v230 = (CFDictionaryRef)IORegistryEntryCreateCFProperty(*((_DWORD *)Private + 20), @"IODisplayParameters", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (v230)
    {
      v229  = (CFDictionaryRef)CFDictionaryGetValue(v230, @"brightness");
      if (v229)
      {
        CFNumberRef v228 = (CFNumberRef)CFDictionaryGetValue(v229, @"value");
        if (v228)
        {
          CFNumberGetValue(v228, kCFNumberSInt32Type, &v231);
          *((_DWORD *)Private + 26)  = v231 != 0;
        }
      }
      os_log_t v227 = 0;
      if (_logHandle)
      {
        int v101 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v100 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v100 = init_default_corebrightness_log();
        }
        int v101 = v100;
      }
      os_log_t v227 = v101;
      os_log_type_t v226 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_66((uint64_t)v355, (uint64_t)v230);
        _os_log_impl(&dword_1BA438000, v227, v226, "display parameters  = %{public}@", v355, 0xCu);
      }
      CFRelease(v230);
    }
    double v25 = 1.0;
    if (!v231) {
      double v25 = 0.0;
    }
    float v26 = v25;
    *((float *)Private + 87)  = v26;
    os_log_t v225 = 0;
    if (_logHandle)
    {
      CFTypeID v99 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v98 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v98 = init_default_corebrightness_log();
      }
      CFTypeID v99 = v98;
    }
    os_log_t v225 = v99;
    os_log_type_t v224 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_2_4_0_8_0((uint64_t)v354, v231, COERCE__INT64(*((float *)Private + 87)));
      _os_log_impl(&dword_1BA438000, v225, v224, "brightness %d -> factor %f", v354, 0x12u);
    }
    *((_DWORD *)Private + 350)  = *((_DWORD *)Private + 87);
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 348);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayBrightnessFactor", number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 353)  = 0;
    *((float *)Private + 354)  = 1.0;
    *((_DWORD *)Private + 355)  = 0;
    *((float *)Private + 84)  = (float)(*((_DWORD *)Private + 311) - *((_DWORD *)Private + 309))
                             / (float)(*((_DWORD *)Private + 310) - *((_DWORD *)Private + 309));
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 336);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayBrightness", number);
      CFRelease(number);
    }
    if (cf)
    {
      float v27 = _DisplaySliderToLogicalBrightnessInternal((uint64_t)Private, *((float *)Private + 84));
      *((float *)Private + 313)  = v27;
      *((_DWORD *)Private + 314)  = *((_DWORD *)Private + 313);
      *((_DWORD *)Private + 372)  = *((_DWORD *)Private + 314);
      *((_DWORD *)Private + 373)  = *((_DWORD *)Private + 313);
      *((_DWORD *)Private + 315)  = *((_DWORD *)Private + 314);
      *((_DWORD *)Private + 318)  = *((_DWORD *)Private + 314);
      uint64_t v223 = 0;
      HIDWORD(v223)  = *((_DWORD *)Private + 315);
      LODWORD(v223)  = 1;
      __DisplayUpdateAAPStateInternal((uint64_t)Private, (uint64_t)&v223, 0);
      CFTypeRef v222 = 0;
      CFTypeRef v222 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloat32Type, (char *)Private + 1256);
      if (v222)
      {
        CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayNitsKey", v222);
        CFRelease(v222);
      }
    }
    *((_DWORD *)Private + 98)  = 0;
    int v28 = *((_DWORD *)Private + 330);
    *((_DWORD *)Private + 99)  = v28;
    *((_DWORD *)Private + 100)  = v28;
    *((float *)Private + 114)  = 1.0;
    int v29 = *((_DWORD *)Private + 328);
    *((_DWORD *)Private + 115)  = v29;
    *((_DWORD *)Private + 116)  = v29;
    *((float *)Private + 130)  = 1.0;
    int v30 = *((_DWORD *)Private + 328);
    *((_DWORD *)Private + 131)  = v30;
    *((_DWORD *)Private + 132)  = v30;
    *((void *)Private + 69)  = 0x407E000000000000;
    *((void *)Private + 68)  = 0x404E000000000000;
    *((CFAbsoluteTime *)Private + 67)  = CFAbsoluteTimeGetCurrent();
    *((void *)Private + 72)  = *((void *)Private + 67);
    *((void *)Private + 74)  = 0;
    *((unsigned char *)Private + 584)  = 1;
    *((double *)Private + 70)  = 30.0;
    *((double *)Private + 71)  = 0.5;
    *((_DWORD *)Private + 160)  = 1;
    *((float *)Private + 162)  = 1.0;
    *((void *)Private + 82)  = 0x3FE99999A0000000;
    *((float *)Private + 170)  = 1.0;
    *((float *)Private + 172)  = 1.0;
    *((float *)Private + 171)  = 1.0;
    *((_DWORD *)Private + 173)  = 0;
    *((float *)Private + 174)  = 1.0;
    *((_DWORD *)Private + 175)  = 0;
    *((_DWORD *)Private + 180)  = 1140457472;
    *((_DWORD *)Private + 181)  = 1140457472;
    *((_DWORD *)Private + 208)  = 1120403456;
    *((float *)Private + 264)  = 1.0;
    int v31 = *((_DWORD *)Private + 264);
    *((_DWORD *)Private + 272)  = v31;
    *((_DWORD *)Private + 270)  = v31;
    *((_DWORD *)Private + 271)  = v31;
    *((void *)Private + 133)  = 0;
    *((float *)Private + 246)  = 1.0;
    int v32 = *((_DWORD *)Private + 246);
    *((_DWORD *)Private + 254)  = v32;
    *((_DWORD *)Private + 252)  = v32;
    *((_DWORD *)Private + 253)  = v32;
    *((void *)Private + 124)  = 0;
    *((_DWORD *)Private + 245)  = *((_DWORD *)Private + 329);
    *((_DWORD *)Private + 244)  = *((_DWORD *)Private + 329);
    *((float *)Private + 86)  = 1.0;
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 344);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayBrightnessMax", number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 85)  = 0;
    if (*((_DWORD *)Private + 9)) {
      *((float *)Private + 85)  = (float)(*((_DWORD *)Private + 309) + 1) / (float)*((int *)Private + 310);
    }
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 340);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayBrightnessMin", number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 307)  = 1050253722;
    *((float *)Private + 296)  = 0.5;
    __DisplayUpdateAmbientProperties((uint64_t)Private, *((float *)Private + 84));
    *((_DWORD *)Private + 300)  = 1063675494;
    *((_DWORD *)Private + 298)  = 0;
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1200);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayBrightnessAutoWeightMax", number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 299)  = 1036831949;
    number  = CFNumberCreate(allocator, kCFNumberFloatType, (char *)Private + 1196);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayBrightnessAutoWeightMin", number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 3184)  = 10;
    *((_DWORD *)Private + 3183)  = 0;
    *((_DWORD *)Private + 3182)  = 0;
    __memset_chk();
    *((float *)Private + 3235)  = -1.0;
    char v220 = MGGetBoolAnswer() & 1;
    char v221 = v220;
    double v33 = 1.0;
    if (!v220) {
      double v33 = 0.0;
    }
    float v34 = v33;
    *((float *)Private + 301)  = v34;
    CFTypeID v97 = (__CFDictionary *)*((void *)Private + 24);
    if (v221) {
      CFDictionarySetValue(v97, @"DisplayBrightnessAuto", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    else {
      CFDictionarySetValue(v97, @"DisplayBrightnessAuto", (const void *)*MEMORY[0x1E4F1CFC8]);
    }
    *((_DWORD *)Private + 50)  = 6;
    number  = CFNumberCreate(allocator, kCFNumberIntType, (char *)Private + 200);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"LogLevel", number);
      CFRelease(number);
    }
    int v219 = 0;
    CFTypeRef v218 = 0;
    CFTypeID v96 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    CFTypeRef v218 = IORegistryEntrySearchCFProperty(object, "IOService", @"use-cabal", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    char v217 = _DisplayGetUint32FromCFDataAndRelease(v218, &v219) & 1;
    int v216 = 0;
    CFTypeRef v215 = 0;
    CFTypeRef v215 = IORegistryEntrySearchCFProperty(object, "IOService", @"use-new-AAP-ramp", *v96, 3u);
    char v214 = _DisplayGetUint32FromCFDataAndRelease(v215, &v216) & 1;
    if (v217 & 1) != 0 || (v214)
    {
      BOOL v95 = 1;
      if (!v216) {
        BOOL v95 = v219 != 0;
      }
      *((unsigned char *)Private + 12282)  = v95;
      BOOL v94 = 1;
      if (!v216) {
        BOOL v94 = v219 != 0;
      }
      *((unsigned char *)Private + 12248)  = v94;
      os_log_t v213 = 0;
      if (_logHandle)
      {
        float v93 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v92 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v92 = init_default_corebrightness_log();
        }
        float v93 = v92;
      }
      os_log_t v213 = v93;
      os_log_type_t v212 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v353, v219, v216);
        _os_log_impl(&dword_1BA438000, v213, v212, "Use Cabal  = %d, new AAP ramp  = %d", v353, 0xEu);
      }
      if (v219)
      {
        os_log_t v211 = 0;
        if (_logHandle)
        {
          CFTypeRef v91 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v90 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v90 = init_default_corebrightness_log();
          }
          CFTypeRef v91 = v90;
        }
        os_log_t v211 = v91;
        os_log_type_t v210 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v88 = v211;
          os_log_type_t v89 = v210;
          __os_log_helper_16_0_0(v209);
          _os_log_impl(&dword_1BA438000, v88, v89, "AAP factor calculation function  = DisplayUpdateAAPStateLookup", v209, 2u);
        }
        *((void *)Private + 1559)  = __DisplayUpdateAAPStateLookup;
      }
      else
      {
        os_log_t v208 = 0;
        if (_logHandle)
        {
          CFTypeID v87 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v86 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v86 = init_default_corebrightness_log();
          }
          CFTypeID v87 = v86;
        }
        os_log_t v208 = v87;
        os_log_type_t v207 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
        {
          CFTypeID v84 = v208;
          os_log_type_t v85 = v207;
          __os_log_helper_16_0_0(v206);
          _os_log_impl(&dword_1BA438000, v84, v85, "AAP factor calculation function  = DisplayUpdateAAPStateStandard", v206, 2u);
        }
        *((void *)Private + 1559)  = __DisplayUpdateAAPStateStandard;
      }
    }
    CFTypeRef v205 = IORegistryEntryCreateCFProperty(object, @"use-AAP", allocator, 0);
    if (v205)
    {
      BOOL v35 = GetCFBooleanValue((const __CFNumber *)v205) != 0;
      *((unsigned char *)Private + 12248)  = v35;
      os_log_t v204 = 0;
      if (_logHandle)
      {
        uint64_t v83 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v82 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v82 = init_default_corebrightness_log();
        }
        uint64_t v83 = v82;
      }
      os_log_t v204 = v83;
      os_log_type_t v203 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        if (*((unsigned char *)Private + 12248)) {
          os_log_t v36 = "";
        }
        else {
          os_log_t v36 = "don't ";
        }
        __os_log_helper_16_2_1_8_32((uint64_t)v352, (uint64_t)v36);
        _os_log_impl(&dword_1BA438000, v204, v203, "%suse AAP", v352, 0xCu);
      }
      CFRelease(v205);
    }
    if (*((unsigned char *)Private + 12248))
    {
      *((_DWORD *)Private + 3098)  = 0;
      *((_DWORD *)Private + 3115)  = 1053609165;
      *((_DWORD *)Private + 3114)  = 0;
      *((float *)Private + 3069)  = 2.0;
      *((float *)Private + 3068)  = 5.0;
      *((float *)Private + 3063)  = 2.0;
      *((_DWORD *)Private + 3065)  = 1161527296;
      *((_DWORD *)Private + 3066)  = 1175232512;
      *((_DWORD *)Private + 3064)  = 1140457472;
      *((_DWORD *)Private + 3072)  = -1;
      *((unsigned char *)Private + 12284)  = 0;
      *((unsigned char *)Private + 12285)  = 0;
      *((unsigned char *)Private + 12292)  = 0;
      *((float *)Private + 3117)  = -1.0;
      *((float *)Private + 3067)  = 10.0;
      *((_DWORD *)Private + 3075)  = 0;
      *((_DWORD *)Private + 3076)  = 0;
      *((_DWORD *)Private + 3107)  = 0;
      *((float *)Private + 3108)  = 1.0;
      *((_DWORD *)Private + 3109)  = 0;
      *((_DWORD *)Private + 392)  = 0;
      *((_DWORD *)Private + 393)  = 0;
      *((CFAbsoluteTime *)Private + 1551)  = CFAbsoluteTimeGetCurrent();
      *((float *)Private + 3117)  = -1.0;
      CFTypeRef v202 = 0;
      CFTypeRef v202 = IORegistryEntrySearchCFProperty(object, "IOService", @"use-lut", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
      unsigned int v201 = 0;
      _DisplayGetUint32FromCFDataAndRelease(v202, &v201);
      long long v350 = xmmword_1BA613218;
      int v351 = 460218192;
      v348  = xmmword_1BA61322C;
      int v349 = 2144905009;
      long long v346 = xmmword_1BA613240;
      int v347 = 127894440;
      long long v344 = xmmword_1BA613254;
      int v345 = 1070997468;
      if (MGIsDeviceOneOfType())
      {
        *((void *)Private + 1540)  = DBV_SDR_XDR;
        *((_DWORD *)Private + 3078)  = 68;
        *((void *)Private + 1542)  = LUX_SDR_XDR;
        *((_DWORD *)Private + 3082)  = 92;
        *((void *)Private + 1544)  = &LUT31_SDR_XDR;
        *((_DWORD *)Private + 3086)  = 92;
        *((_DWORD *)Private + 3087)  = 68;
        os_log_t v200 = 0;
        if (_logHandle)
        {
          CFTypeID v81 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v80 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v80 = init_default_corebrightness_log();
          }
          CFTypeID v81 = v80;
        }
        os_log_t v200 = v81;
        os_log_type_t v199 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex v78 = v200;
          os_log_type_t v79 = v199;
          __os_log_helper_16_0_0(v198);
          _os_log_impl(&dword_1BA438000, v78, v79, "select XDR PCC configuration", v198, 2u);
        }
      }
      else
      {
        *((void *)Private + 1540)  = *(&D_SDRs + v201);
        *((_DWORD *)Private + 3078)  = 68;
        *((void *)Private + 1542)  = *(&L_SDRs + v201);
        *((_DWORD *)Private + 3082)  = 92;
        *((void *)Private + 1544)  = *(&A_SDRs + v201);
        *((_DWORD *)Private + 3086)  = 92;
        *((_DWORD *)Private + 3087)  = 68;
        os_log_t v197 = 0;
        if (_logHandle)
        {
          uint64_t v77 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v76 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v76 = init_default_corebrightness_log();
          }
          uint64_t v77 = v76;
        }
        os_log_t v197 = v77;
        os_log_type_t v196 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v74 = v197;
          os_log_type_t v75 = v196;
          __os_log_helper_16_0_0(v195);
          _os_log_impl(&dword_1BA438000, v74, v75, "select non-XDR PCC configuration", v195, 2u);
        }
      }
      *((void *)Private + 1546)  = &HDR_LUT_PT;
      *((_DWORD *)Private + 3090)  = 100;
      *((void *)Private + 1548)  = &HDR_SCALE_DOWN;
      *((_DWORD *)Private + 3094)  = 100;
    }
    int v194 = 0;
    if (*((_DWORD *)Private + 8))
    {
      int v194 = 1;
      int v193 = 0;
      int v193 = (int)(float)(*((float *)Private + 329) * 65536.0);
      CFTypeRef v192 = CFNumberCreate(allocator, kCFNumberIntType, &v193);
      if (v192)
      {
        __DisplaySetBLDriverProperty((uint64_t)Private, @"DisplayBrightnessNitsNVRAM", v192);
        CFRelease(v192);
      }
    }
    number  = CFNumberCreate(allocator, kCFNumberIntType, &v194);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"DisplayBackLightArchitecture", number);
      CFRelease(number);
    }
    *((_DWORD *)Private + 3055)  = 0;
    *((float *)Private + 3056)  = 1.0;
    *((_DWORD *)Private + 3057)  = 0;
    *((float *)Private + 3053)  = 1.0;
    *((float *)Private + 3054)  = 1.0;
    *((float *)Private + 3052)  = 1.0;
    *((unsigned char *)Private + 12180)  = 0;
    uint64_t v72 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
    uint64_t v73 = (CFStringRef *)MEMORY[0x1E4F1D3E0];
    CFPreferencesSynchronize(@"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    CFTypeRef v191 = 0;
    CFTypeRef v191 = CFPreferencesCopyValue(@"CBCPMSRampHDR", @"com.apple.CoreBrightness", *v72, *v73);
    if (v191)
    {
      CFTypeID v71 = CFGetTypeID(v191);
      if (v71 == CFBooleanGetTypeID()) {
        *((unsigned char *)Private + 12180)  = v191 == (CFTypeRef)*MEMORY[0x1E4F1CFD0];
      }
    }
    if (v191) {
      CFRelease(v191);
    }
    *((unsigned char *)Private + 12180)  = 1;
    float_from_edt  = load_float_from_edt(object, @"cpms-hdr-reset-duration");
    *((float *)Private + 3046)  = float_from_edt;
    float v38 = load_float_from_edt(object, @"cpms-hdr-cap-multiplier");
    *((float *)Private + 3047)  = v38;
    memset(__b, 0, sizeof(__b));
    __sprintf_chk(__b, 0, 0x100uLL, "Display: %p", Private);
    if (target)
    {
      os_log_t v190 = 0;
      if (_logHandle)
      {
        CFTypeID v70 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v69 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v69 = init_default_corebrightness_log();
        }
        CFTypeID v70 = v69;
      }
      os_log_t v190 = v70;
      os_log_type_t v189 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
      {
        CFTypeID v67 = v190;
        os_log_type_t v68 = v189;
        __os_log_helper_16_0_0(v188);
        _os_log_impl(&dword_1BA438000, v67, v68, "Using root queue \n", v188, 2u);
      }
      *((unsigned char *)Private + 160)  = 1;
      dispatch_queue_t v39 = dispatch_queue_create_with_target_V2(__b, 0, target);
      *((void *)Private + 18)  = v39;
    }
    else
    {
      os_log_t v187 = 0;
      if (_logHandle)
      {
        uint64_t v66 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v65 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v65 = init_default_corebrightness_log();
        }
        uint64_t v66 = v65;
      }
      os_log_t v187 = v66;
      os_log_type_t v186 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
        os_log_type_t v63 = v187;
        os_log_type_t v64 = v186;
        __os_log_helper_16_0_0(v185);
        _os_log_impl(&dword_1BA438000, v63, v64, "Using default queue \n", v185, 2u);
      }
      *((unsigned char *)Private + 160)  = 0;
      dispatch_queue_t v40 = dispatch_queue_create(__b, 0);
      *((void *)Private + 18)  = v40;
    }
    __sprintf_chk(__b, 0, 0x100uLL, "DisplayAsync: %p", Private);
    dispatch_queue_t v41 = dispatch_queue_create(__b, 0);
    *((void *)Private + 21)  = v41;
    __sprintf_chk(__b, 0, 0x100uLL, "DisplayAsyncCPMS: %p", Private);
    dispatch_queue_t v42 = dispatch_queue_create(__b, 0);
    *((void *)Private + 19)  = v42;
    *((_DWORD *)Private + 3125)  = 0;
    *((float *)Private + 3124)  = -1.0;
    *((unsigned char *)Private + 12522)  = 1;
    *((unsigned char *)Private + 12514)  = 0;
    *((unsigned char *)Private + 12520)  = CBU_IsNightShiftSupported() & 1;
    CFTypeRef v184 = 0;
    CFTypeRef v184 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v184)
    {
      if (*((unsigned char *)Private + 12520)) {
        CFDictionaryAddValue((CFMutableDictionaryRef)v184, @"SupportsNightMode", (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      else {
        CFDictionaryAddValue((CFMutableDictionaryRef)v184, @"SupportsNightMode", (const void *)*MEMORY[0x1E4F1CFC8]);
      }
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"SupportedColorFX", v184);
      CFRelease(v184);
    }
    *((void *)Private + 1572)  = 0;
    *((_DWORD *)Private + 3146)  = 300;
    __DisplayInitializeReport((uint64_t)Private);
    number  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)Private + 12584);
    if (number)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"PowerLogReportInterval", number);
      CFRelease(number);
    }
    *((unsigned char *)Private + 12515)  = 0;
    *((unsigned char *)Private + 12512)  = 0;
    *((unsigned char *)Private + 12513)  = 0;
    CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"BlueReductionEnabled", (const void *)*MEMORY[0x1E4F1CFC8]);
    *((float *)Private + 3132)  = 1.0;
    if (*((unsigned char *)Private + 12514) & 1) != 0 || (*((unsigned char *)Private + 12520))
    {
      *((void *)Private + 1563)  = CFXCreate();
      if (*((void *)Private + 1563))
      {
        CFXInstallCallback(*((void *)Private + 1563), (uint64_t)ColorRampCallback_0, (uint64_t)Private);
        CFTypeRef v183 = 0;
        CFTypeRef v183 = IORegistryEntrySearchCFProperty(object, "IOService", @"default-whitepoint-type", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
        v182  = 0;
        if (_DisplayGetUint32FromCFDataAndRelease(v183, &v182)) {
          CFXSetWhitePointType(*((_DWORD **)Private + 1563), v182);
        }
        if (*((unsigned char *)Private + 12520))
        {
          char v181 = 0;
          char v181 = CFXInitializeBlueLightReduction(*((void *)Private + 1563)) & 1;
          if (v181)
          {
            float v180 = 0.0;
            float v179 = 0.0;
            float v178 = 0.0;
            float v177 = 0.0;
            CFXGetBlueLightReductionCCTRange(*((void *)Private + 1563), &v178, &v180, &v179);
            float v177 = v179;
            CBU_GetNightShiftCCTRange(object, &v180, &v179, &v178, &v177);
            CFTypeRef v176 = 0;
            CFTypeRef v176 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v177);
            if (v176)
            {
              CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"BlueLightReductionCCTWarningKey", v176);
              CFRelease(v176);
            }
            float v61 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
            CFTypeID v62 = (CFStringRef *)MEMORY[0x1E4F1D3E0];
            CFPreferencesSynchronize(@"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
            CFTypeRef v175 = 0;
            CFTypeRef v175 = CFPreferencesCopyValue(@"CBBlueLightReductionCCTRange", @"com.apple.CoreBrightness", *v61, *v62);
            if (v175)
            {
              CFTypeID v60 = CFArrayGetTypeID();
              if (v60 == CFGetTypeID(v175))
              {
                CFArrayRef theArray = (CFArrayRef)v175;
                if (CFArrayGetCount((CFArrayRef)v175) == 3)
                {
                  unint64_t v341 = 0xBF800000BF800000;
                  float v342 = -1.0;
                  memset(idx, 0, sizeof(idx));
                  while (idx[0] < 3)
                  {
                    *(void *)&idx[1]  = CFArrayGetValueAtIndex(theArray, idx[0]);
                    if (*(void *)&idx[1])
                    {
                      CFTypeID v59 = CFNumberGetTypeID();
                      if (v59 == CFGetTypeID(*(CFTypeRef *)&idx[1])) {
                        CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)&v341 + 4 * idx[0]);
                      }
                    }
                    ++idx[0];
                  }
                  if (*(float *)&v341 != -1.0 && *((float *)&v341 + 1) != -1.0 && v342 != -1.0)
                  {
                    float v179 = *((float *)&v341 + 1);
                    LODWORD(v180)  = v341;
                    float v178 = v342;
                  }
                }
              }
              CFRelease(v175);
            }
            CFXOverrideBlueLightReductionCCTRange(*((void *)Private + 1563), v178, v180, v179);
            values  = 0;
            CFTypeRef v339 = 0;
            CFTypeRef v340 = 0;
            float v58 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
            values  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v180);
            CFTypeRef v339 = CFNumberCreate(*v58, kCFNumberFloatType, &v179);
            CFTypeRef v340 = CFNumberCreate(*v58, kCFNumberFloatType, &v178);
            if (values)
            {
              if (v339)
              {
                if (v340)
                {
                  CFTypeRef v172 = 0;
                  CFTypeRef v172 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&values, 3, MEMORY[0x1E4F1D510]);
                  if (v172)
                  {
                    CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"BlueLightReductionCCTRange", v172);
                    CFRelease(v172);
                  }
                }
              }
            }
            if (values) {
              CFRelease(values);
            }
            if (v339) {
              CFRelease(v339);
            }
            if (v340) {
              CFRelease(v340);
            }
            CFTypeRef v171 = 0;
            CFTypeRef v171 = CFPreferencesCopyValue(@"CBBlueLightReductionCCTTargetRaw", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
            float v170 = 0.0;
            float v170 = CFXGetBlueLightReductionTargetCCT(*((void *)Private + 1563));
            if (v171)
            {
              CFTypeID v57 = CFGetTypeID(v171);
              if (v57 == CFNumberGetTypeID())
              {
                CFNumberGetValue((CFNumberRef)v171, kCFNumberFloatType, &v170);
                float v170 = fminf(fmaxf(v170, v180), v178);
                CFXSetBlueLightReductionTargetCCT(*((void *)Private + 1563), 0, v170, 0.0, 0.0);
              }
              CFRelease(v171);
            }
            keys  = @"BlueLightReductionCCTTargetValue";
            CFTypeRef v336 = 0;
            CFTypeRef v336 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v170);
            if (v336)
            {
              CFTypeRef v169 = 0;
              CFTypeRef v169 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, &v336, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
              CFRelease(v336);
              if (v169)
              {
                CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"BlueLightReductionCCTTargetKey", v169);
                CFRelease(v169);
              }
            }
          }
        }
      }
      if (CFPreferencesAppSynchronize((CFStringRef)*MEMORY[0x1E4F1D3D8]))
      {
        CFTypeRef v168 = 0;
        CFTypeRef v168 = CFPreferencesCopyAppValue(@"CBCarryLogEnabled", (CFStringRef)*MEMORY[0x1E4F1D3D8]);
        int v167 = 0;
        if (!v168) {
          CFTypeRef v168 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v167);
        }
        if (v168)
        {
          CFTypeID v56 = CFNumberGetTypeID();
          if (v56 == CFGetTypeID(v168))
          {
            CFNumberGetValue((CFNumberRef)v168, kCFNumberIntType, &v167);
            CFXEnableLog(*((void *)Private + 1563), v167 != 0);
            CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"CarryLogEnabled", v168);
          }
          CFRelease(v168);
        }
      }
    }
    *((_DWORD *)Private + 287)  = 0;
    *((unsigned char *)Private + 1144)  = 0;
    *((unsigned char *)Private + 960)  = 0;
    *((_DWORD *)Private + 241)  = 0;
    *((_DWORD *)Private + 242)  = 0;
    *((_DWORD *)Private + 3136)  = 0;
    *((void *)Private + 1567)  = 0;
    *((unsigned char *)Private + 12548)  = 0;
    *((_DWORD *)Private + 3138)  = 0;
    *((_DWORD *)Private + 3139)  = 0;
    *((_DWORD *)Private + 282)  = 0;
    *((_DWORD *)Private + 283)  = 0;
    *((_DWORD *)Private + 284)  = 0;
    *((_DWORD *)Private + 317)  = 0;
    *((unsigned char *)Private + 1284)  = 0;
    *((float *)Private + 388)  = 1.0;
    *((_DWORD *)Private + 389)  = 1;
    *((_DWORD *)Private + 390)  = 0;
    if (+[CBSoftWakeDisplayDelegate isSupported]) {
      char v55 = objc_alloc_init(CBSoftWakeDisplayDelegate);
    }
    else {
      char v55 = 0;
    }
    *((void *)Private + 41)  = v55;
    *((float *)Private + 288)  = 10.0;
    *((_DWORD *)Private + 289)  = *((_DWORD *)Private + 384);
    *((float *)Private + 290)  = 16.0;
    *((_DWORD *)Private + 291)  = *((_DWORD *)Private + 386);
    *((float *)Private + 293)  = 10.0;
    *((unsigned char *)Private + 1176)  = 1;
    CFTypeRef v166 = 0;
    CFTypeRef v166 = IORegistryEntrySearchCFProperty(object, "IOService", @"bright-dot-mitigation-nits1", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    int v165 = 0;
    if (_DisplayGetUint32FromCFDataAndRelease(v166, &v165)) {
      *((float *)Private + 289)  = (float)v165 / 65536.0;
    }
    *((_DWORD *)Private + 292)  = *((_DWORD *)Private + 289);
    CFTypeRef v164 = 0;
    CFTypeRef v164 = IORegistryEntrySearchCFProperty(object, "IOService", @"bright-dot-mitigation-nits2", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    int v163 = 0;
    if (_DisplayGetUint32FromCFDataAndRelease(v164, &v163)) {
      *((float *)Private + 291)  = (float)v163 / 65536.0;
    }
    CFTypeRef v54 = (void *)MEMORY[0x1BA9ECAE0]();
    if (*((void *)Private + 24))
    {
      id v162 = 0;
      id v162 = (id)*((void *)Private + 24);
      v334[0]  = @"brightDotsMitigationLux1";
      LODWORD(v43)  = *((_DWORD *)Private + 288);
      v335[0]  = [NSNumber numberWithFloat:v43];
      v334[1]  = @"brightDotsMitigationLux2";
      LODWORD(v44)  = *((_DWORD *)Private + 290);
      v335[1]  = [NSNumber numberWithFloat:v44];
      v334[2]  = @"brightDotsMitigationNits1";
      LODWORD(v45)  = *((_DWORD *)Private + 289);
      v335[2]  = [NSNumber numberWithFloat:v45];
      v334[3]  = @"brightDotsMitigationNits2";
      LODWORD(v46)  = *((_DWORD *)Private + 291);
      v335[3]  = [NSNumber numberWithFloat:v46];
      objc_msgSend(v162, "setObject:forKey:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v335, v334, 4), @"BrightDotsMitigationParameters");
    }
    CFTypeRef v161 = 0;
    CFTypeRef v161 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)Private + 1560);
    if (v161)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"BrightnessCLTMMode", v161);
      CFRelease(v161);
    }
    float v160 = 4.0;
    long long v333 = xmmword_1E621A478;
    CFTypeRef v331 = 0;
    CFTypeRef v332 = 0;
    int v53 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    CFTypeRef v331 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)Private + 1556);
    CFTypeRef v332 = CFNumberCreate(*v53, kCFNumberFloatType, &v160);
    CFAllocatorRef v47 = CFGetAllocator(Private);
    CFTypeRef v159 = CFDictionaryCreate(v47, (const void **)&v333, &v331, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v159)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)Private + 24), @"BrightnessCLTM", v159);
      CFRelease(v159);
    }
    if (v331) {
      CFRelease(v331);
    }
    if (v332) {
      CFRelease(v332);
    }
    BOOL v48 = _DisplayCheckEDRSupport((uint64_t)Private);
    *((_DWORD *)Private + 3149)  = v48;
    if (*((_DWORD *)Private + 3149) == 1)
    {
      CBEDRServerAddMainDisplay(*((_DWORD *)Private + 3148));
      SetLibEDRBrightness((uint64_t)Private, *((float *)Private + 314), *((float *)Private + 386), *((float *)Private + 298), *((float *)Private + 3132));
    }
    *((unsigned char *)Private + 1504)  = 0;
    *((_DWORD *)Private + 377)  = (int)*((float *)Private + 326);
    *((_DWORD *)Private + 378)  = (int)*((float *)Private + 386);
    int v158 = 0;
    CFTypeRef v157 = 0;
    CFTypeRef v157 = IORegistryEntrySearchCFProperty(object, "IOService", @"has-2dbl", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(v157, &v158)) {
      *((unsigned char *)Private + 323)  = v158 != 0;
    }
    int v156 = 0;
    CFTypeRef v155 = IORegistryEntrySearchCFProperty(object, "IOService", @"supports-aurora", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    Uint32FromCFDataAndRelease  = _DisplayGetUint32FromCFDataAndRelease(v155, &v156);
    int v52 = (void *)MEMORY[0x1BA9ECAE0](Uint32FromCFDataAndRelease);
    if (*((void *)Private + 24)) {
      objc_msgSend(*((id *)Private + 24), "setObject:forKey:", objc_msgSend(NSNumber, "numberWithInt:", v156 == 1), @"AuroraSupported");
    }
    *((float *)Private + 3236)  = 1.0;
    *((unsigned char *)Private + 13008)  = 0;
    *((void *)Private + 1619)  = 0;
    *((_DWORD *)Private + 3254)  = 1150681088;
    *((float *)Private + 3255)  = 4.0;
    *((float *)Private + 3256)  = 4.0;
    CFStringRef v50 = objc_alloc_init(CBDisplayRamps);
    *((void *)Private + 33)  = v50;
    return Private;
  }
LABEL_495:
  if (*((_DWORD *)Private + 20)) {
    IOObjectRelease(*((_DWORD *)Private + 20));
  }
  if (*((void *)Private + 9))
  {
    free(*((void **)Private + 9));
    *((void *)Private + 9)  = 0;
    *((_DWORD *)Private + 16)  = 0;
  }
  CFRelease(Private);
  return 0;
}

CFTypeRef DisplayCreateWithCapabilities(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  return DisplayCreateWithCapabilitiesAndID(a1, a2, a3, a4);
}

CFTypeRef DisplayCreateWithID(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return DisplayCreateWithCapabilitiesAndID(a1, a2, a3, 0);
}

uint64_t __DisplayCreatePrivate()
{
  DisplayGetTypeID();
  Instance  = _CFRuntimeCreateInstance();
  if (!Instance) {
    return 0;
  }
  __memset_chk();
  return Instance;
}

uint64_t __DisplayBrightnessThreadInit()
{
  kern_return_t inserted;
  pthread_t v5;
  pthread_attr_t __b;
  uint64_t v7;

  uint64_t v7 = *MEMORY[0x1E4F143B8];
  io_object_t v5 = 0;
  memset(&__b, 0, sizeof(__b));
  inserted  = 0;
  port_info_out  = 0;
  tassize_t k = 0;
  tassize_t k = *MEMORY[0x1E4F14960];
  port_info_outCnt  = 1;
  if (mach_port_allocate(task, 1u, (mach_port_name_t *)&__brightnessPort)) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1379, "KERN_SUCCESS == ret");
  }
  inserted  = mach_port_insert_right(task, __brightnessPort, __brightnessPort, 0x14u);
  if (inserted) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1382, "KERN_SUCCESS == ret");
  }
  inserted  = mach_port_get_attributes(task, __brightnessPort, 1, &port_info_out, &port_info_outCnt);
  if (inserted) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1385, "KERN_SUCCESS == ret");
  }
  port_info_out  = 1024;
  inserted  = MEMORY[0x1BA9EC9B0](task, __brightnessPort, 1, &port_info_out, port_info_outCnt);
  if (inserted) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1390, "KERN_SUCCESS == ret");
  }
  __brightnessDict  = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (pthread_attr_init(&__b)) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1398, "!pthread_attr_init(&attr)");
  }
  if (pthread_attr_setdetachstate(&__b, 2)) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1399, "!pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)");
  }
  if (pthread_create(&v5, &__b, (void *(__cdecl *)(void *))brightnessThread, 0)) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1400, "!pthread_create( &tid, &attr, brightnessThread, NULL)");
  }
  if (pthread_attr_destroy(&__b)) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1401, "!pthread_attr_destroy(&attr)");
  }
  uint64_t result = pthread_mutex_init(&__brightnessLock, 0);
  if (result) {
    __assert_rtn("__DisplayBrightnessThreadInit", "Display.m", 1402, "!pthread_mutex_init(&__brightnessLock, NULL)");
  }
  return result;
}

float _DisplaySliderToLogicalBrightnessInternal(uint64_t a1, float a2)
{
  float v4 = a2;
  if (a1 && *(void *)(a1 + 72))
  {
    float v3 = a2 * (float)(*(_DWORD *)(a1 + 64) - 1);
    if (v3 >= *(_DWORD *)(a1 + 64) - 1) {
      float v4 = *(float *)(*(void *)(a1 + 72) + 4 * (*(_DWORD *)(a1 + 64) - 1));
    }
    else {
      float v4 = __interpolate((float)v3, *(float *)(*(void *)(a1 + 72) + 4 * v3), (float)(v3 + 1), *(float *)(*(void *)(a1 + 72) + 4 * (v3 + 1)), v3);
    }
  }
  float v5 = v4;
  if (a1)
  {
    if (v4 < *(float *)(a1 + 1304))
    {
      if (**(float **)(a1 + 72) <= *(float *)(a1 + 1320)) {
        return __interpolate(*(float *)(a1 + 1308), *(float *)(a1 + 1320), *(float *)(a1 + 1304), *(float *)(a1 + 1316), v4);
      }
    }
    else
    {
      return __interpolate(*(float *)(a1 + 1304), *(float *)(a1 + 1316), *(float *)(a1 + 1300), *(float *)(a1 + 1312), v4);
    }
  }
  return v5;
}

float _DisplayGetGlobalScalarFromDevice(uint64_t a1, io_registry_entry_t a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a1;
  io_registry_entry_t v36 = a2;
  float valuePtr = 1.0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  float v34 = 1.0;
  if ((_DisplayGetGlobalScalarDisplayParams(a2, (float *)&v31, (float *)&v31 + 1) & 1) == 0)
  {
LABEL_73:
    if (v37)
    {
      if (*(void *)(v37 + 192))
      {
        keys  = @"Scalar";
        values  = 0;
        values  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
        if (values)
        {
          value  = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)&keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          if (value)
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v37 + 192), @"BrightnessGlobalScalar", value);
            CFRelease(value);
          }
          CFRelease(values);
        }
      }
    }
    return valuePtr;
  }
  *(_DWORD *)(v37 + 12176)  = v31;
  unsigned int v30 = 0;
  CFTypeRef v29 = 0;
  int v21 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  CFTypeRef v29 = IORegistryEntrySearchCFProperty(v36, "IOService", @"pab-scaler-index", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  _DisplayGetUint32FromCFDataAndRelease(v29, &v30);
  unsigned int v28 = 0;
  CFTypeRef v29 = IORegistryEntrySearchCFProperty(v36, "IOService", @"first-paneltype-pab-index", *v21, 3u);
  _DisplayGetUint32FromCFDataAndRelease(v29, &v28);
  os_log_t oslog = 0;
  if (_logHandle)
  {
    uint64_t v20 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v20 = inited;
  }
  os_log_t oslog = v20;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v47, v30);
    _os_log_debug_impl(&dword_1BA438000, oslog, type, "PAB scaler index (as returned by iBoot)  = %u", v47, 8u);
  }
  if (v30 < v28)
  {
    os_log_t v25 = 0;
    if (_logHandle)
    {
      int v18 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v17 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v17 = init_default_corebrightness_log();
      }
      int v18 = v17;
    }
    os_log_t v25 = v18;
    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      int v15 = v25;
      os_log_type_t v16 = v24;
      __os_log_helper_16_0_0(v23);
      _os_log_error_impl(&dword_1BA438000, v15, v16, "PAB scaler: incorrect first-paneltype-pab-index in EDT! Using a default scaler", v23, 2u);
    }
    goto LABEL_73;
  }
  v30 -= v28;
  if (_logHandle)
  {
    float v14 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v13 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v13 = init_default_corebrightness_log();
    }
    float v14 = v13;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v46, v30);
    _os_log_debug_impl(&dword_1BA438000, v14, OS_LOG_TYPE_DEBUG, "PAB scaler index (after making it 0-based)  = %u", v46, 8u);
  }
  if ((_DisplayGetScalerForKeyAndIndex(v36, @"gs-i-nominal", v30, (float *)&v32, 1000.0) & 1) == 0) {
    goto LABEL_73;
  }
  if (_logHandle)
  {
    float v12 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v11 = init_default_corebrightness_log();
    }
    float v12 = v11;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v45, COERCE__INT64(*(float *)&v32));
    _os_log_debug_impl(&dword_1BA438000, v12, OS_LOG_TYPE_DEBUG, "I_nominal  = %f", v45, 0xCu);
  }
  if ((_DisplayGetScalerForKeyAndIndex(v36, @"gs-i-threshold", v30, (float *)&v32 + 1, 1000.0) & 1) == 0) {
    goto LABEL_73;
  }
  if (_logHandle)
  {
    unint64_t v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v9 = init_default_corebrightness_log();
    }
    unint64_t v10 = v9;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v44, COERCE__INT64(*((float *)&v32 + 1)));
    _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "I_threshold  = %f", v44, 0xCu);
  }
  if ((_DisplayGetScalerForKeyAndIndex(v36, @"gs-b-min", v30, (float *)&v33, 1000.0) & 1) == 0) {
    goto LABEL_73;
  }
  if (_logHandle)
  {
    int v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v7 = init_default_corebrightness_log();
    }
    int v8 = v7;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v43, COERCE__INT64(*(float *)&v33));
    _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "B-min  = %f", v43, 0xCu);
  }
  if ((_DisplayGetScalerForKeyAndIndex(v36, @"gs-slope", v30, (float *)&v33 + 1, 1000.0) & 1) == 0) {
    goto LABEL_73;
  }
  if (_logHandle)
  {
    int v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v5 = init_default_corebrightness_log();
    }
    int v6 = v5;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v42, COERCE__INT64(*((float *)&v33 + 1)));
    _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "Slope  = %f", v42, 0xCu);
  }
  if (_logHandle)
  {
    float v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v3 = init_default_corebrightness_log();
    }
    float v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_5_4_0_8_0_8_0_8_0_8_0((uint64_t)v41, v30, COERCE__INT64(*(float *)&v32), COERCE__INT64(*((float *)&v32 + 1)), COERCE__INT64(*(float *)&v33), COERCE__INT64(*((float *)&v33 + 1)));
    _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "{ \"pab_scaler_index\": %u, \"I_nominal\": %.3f, \"I_threshold\": %.3f, \"B-min\": %.3f, \"Slope\": %.3f }", v41, 0x30u);
  }
  return _DisplayCalculateGlobalScalar(v37, (float *)&v31);
}

CFMutableDictionaryRef _DisplayCreateRestrictionDictionary(io_registry_entry_t a1, void *a2)
{
  io_registry_entry_t v7 = a1;
  id v6 = a2;
  uint64_t v5 = 0;
  CFTypeRef v4 = 0;
  CFTypeRef v4 = IORegistryEntrySearchCFProperty(a1, "IOService", @"multi-point-restriction", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  int v3 = 0;
  _DisplayGetUint32FromCFDataAndRelease(v4, &v3);
  if (v3) {
    return (CFMutableDictionaryRef)[v6 copyRestrictionDictionaryMultiPoint];
  }
  else {
    return _DisplayCreateRestrictionDictionarySinglePoint(v7);
  }
}

CFMutableDictionaryRef _DisplayCreateAABConstraintDictionary(io_registry_entry_t a1)
{
  io_registry_entry_t v13 = a1;
  float valuePtr = -1.0;
  float v11 = -1.0;
  float v10 = -1.0;
  float v9 = -1.0;
  float v8 = -1.0;
  capacity_4  = -1.0;
  capacity  = 2;
  CFMutableDictionaryRef theDict = 0;
  value  = 0;
  value  = (void *)IORegistryEntrySearchCFProperty(a1, "IOService", @"aab-constraint-emax", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  unsigned int v3 = 0;
  if (_DisplayGetUint32FromCFDataAndRelease(value, &v3))
  {
    float valuePtr = (float)v3;
    ++capacity;
  }
  value  = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", @"aab-constraint-lmax", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (_DisplayGetUint32FromCFDataAndRelease(value, &v3))
  {
    float v11 = (float)v3;
    ++capacity;
  }
  value  = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", @"aab-constraint-e2", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (_DisplayGetUint32FromCFDataAndRelease(value, &v3))
  {
    float v10 = (float)v3;
    ++capacity;
  }
  value  = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", @"aab-constraint-l2", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (_DisplayGetUint32FromCFDataAndRelease(value, &v3))
  {
    float v9 = (float)v3;
    ++capacity;
  }
  value  = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", @"aab-constraint-l0b", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (_DisplayGetUint32FromCFDataAndRelease(value, &v3))
  {
    float v8 = (float)v3;
    ++capacity;
  }
  value  = (void *)IORegistryEntrySearchCFProperty(v13, "IOService", @"aab-constraint-emax-threshold", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (_DisplayGetUint32FromCFDataAndRelease(value, &v3))
  {
    capacity_4  = (float)v3;
    ++capacity;
  }
  if (capacity > 0)
  {
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], capacity, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (theDict)
    {
      if (valuePtr > 0.0)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"EmaxAlgo", value);
          CFRelease(value);
        }
      }
      if (v11 > 0.0)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v11);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"LmaxAlgo", value);
          CFRelease(value);
        }
      }
      if (v10 > 0.0)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v10);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"E2", value);
          CFRelease(value);
        }
      }
      if (v9 > 0.0)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v9);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"L2", value);
          CFRelease(value);
        }
      }
      if (v8 > 0.0)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v8);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"L0b", value);
          CFRelease(value);
        }
        float v2 = 30.0;
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v2);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"E0b", value);
          CFRelease(value);
        }
      }
      if (capacity_4 > 0.0)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &capacity_4);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"EmaxThreshold", value);
          CFRelease(value);
        }
      }
    }
  }
  return theDict;
}

CFMutableDictionaryRef _DisplayCreateAABCapDictionary(io_registry_entry_t a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  io_registry_entry_t v26 = a1;
  int v25 = 0;
  int v24 = 0;
  CFMutableDictionaryRef v23 = 0;
  CFDataRef v22 = 0;
  CFTypeRef v4 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  CFDataRef v22 = (const __CFData *)IORegistryEntrySearchCFProperty(a1, "IOService", @"aab-cap-e", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  CFDataRef v21 = 0;
  CFDataRef v21 = (const __CFData *)IORegistryEntrySearchCFProperty(v26, "IOService", @"aab-cap-l", *v4, 3u);
  if (v22)
  {
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v22))
    {
      CFDataRef v20 = v22;
      if (CFDataGetLength(v22) == 8)
      {
        uint64_t v32 = 0;
        uint64_t v31 = 8;
        uint64_t v33 = 0;
        uint64_t v34 = 8;
        range.location  = 0;
        range.length  = 8;
        v38.location  = 0;
        v38.length  = 8;
        CFDataGetBytes(v20, v38, (UInt8 *)buffer);
        int v25 = 1;
      }
    }
    CFRelease(v22);
  }
  if (v21)
  {
    CFTypeID v2 = CFDataGetTypeID();
    if (v2 == CFGetTypeID(v21))
    {
      theData  = v21;
      if (CFDataGetLength(v21) == 8)
      {
        uint64_t v28 = 0;
        uint64_t v27 = 8;
        uint64_t v29 = 0;
        uint64_t v30 = 8;
        v17.location  = 0;
        v17.length  = 8;
        v39.location  = 0;
        v39.length  = 8;
        CFDataGetBytes(theData, v39, (UInt8 *)v35);
        int v24 = 1;
      }
    }
    CFRelease(v21);
  }
  if (v25 && v24)
  {
    CFMutableArrayRef theArray = 0;
    CFMutableArrayRef theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D510]);
    if (theArray)
    {
      for (int i = 0; i < 4; ++i)
      {
        float valuePtr = 0.0;
        float valuePtr = (float)(__int16)buffer[i];
        value  = 0;
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
        if (value)
        {
          CFArrayAppendValue(theArray, value);
          CFRelease(value);
        }
      }
    }
    CFMutableArrayRef Mutable = 0;
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      for (int j = 0; j < 4; ++j)
      {
        float v10 = 0.0;
        float v10 = (float)(__int16)v35[j];
        CFTypeRef cf = 0;
        CFTypeRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v10);
        if (cf)
        {
          CFArrayAppendValue(Mutable, cf);
          CFRelease(cf);
        }
      }
    }
    if (theArray)
    {
      if (CFArrayGetCount(theArray) == 4)
      {
        if (Mutable)
        {
          if (CFArrayGetCount(Mutable) == 4)
          {
            CFMutableDictionaryRef v23 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
            if (v23)
            {
              CFDictionaryAddValue(v23, @"E", theArray);
              CFDictionaryAddValue(v23, @"L", Mutable);
            }
          }
        }
      }
    }
    if (theArray) {
      CFRelease(theArray);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  if (v23)
  {
    CFTypeRef v8 = 0;
    CFTypeRef v8 = IORegistryEntrySearchCFProperty(v26, "IOService", @"aab-cap-reverttime", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    unsigned int v7 = 0;
    if (_DisplayGetUint32FromCFDataAndRelease(v8, &v7))
    {
      double v6 = (double)v7;
      CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &v6);
      if (v5)
      {
        CFDictionaryAddValue(v23, @"revertTime", v5);
        CFRelease(v5);
      }
    }
  }
  return v23;
}

void __DisplayUpdateAmbientProperties(uint64_t a1, float a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    unsigned int v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    unsigned int v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v15, COERCE__INT64(*(float *)(a1 + 1204)));
    _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "autobrightness=%f\n", v15, 0xCu);
  }
  if (*(float *)(a1 + 1204) == 0.0)
  {
    *(_DWORD *)(a1 + 1208)  = 0;
    *(float *)(a1 + 1212)  = a2;
  }
  else
  {
    float v9 = *(float *)(a1 + 1196);
    float v8 = *(float *)(a1 + 1200);
    if (a2 > 0.5)
    {
      float v11 = (float)(1.0 - v9) + (float)(v9 * a2);
      float v3 = -(0.5 * (float)((float)(v8 + 1.0) + (float)(-2.0 * v9)) - (v8 + 1.0 - v9) * a2);
      float v10 = v3;
    }
    else
    {
      float v2 = (float)((float)((float)(v8 - v9) + 1.0) * a2) + 0.5 - (float)(v8 / 2.0);
      float v11 = v2;
      float v10 = v9 * a2;
    }
    *(float *)(a1 + 1208)  = v11 - v10;
    *(float *)(a1 + 1212)  = v10;
  }
  if (_logHandle)
  {
    CFNumberRef v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v4 = init_default_corebrightness_log();
    }
    CFNumberRef v5 = v4;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v14, COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 1196)), COERCE__INT64(*(float *)(a1 + 1200)), COERCE__INT64(*(float *)(a1 + 1208)), COERCE__INT64(*(float *)(a1 + 1212)));
    _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "brightness=%f min=%f max=%f slope=%f intercept=%f\n", v14, 0x34u);
  }
}

float __DisplayUpdateAAPStateStandard(uint64_t a1, uint64_t a2)
{
  BOOL v4 = 0;
  if (*(_DWORD *)a2)
  {
    if (*(_DWORD *)a2 == 1)
    {
      if (*(unsigned char *)(a1 + 1232))
      {
        if (*(float *)(a1 + 12256) > *(float *)(a2 + 4))
        {
          if (*(unsigned char *)(a1 + 12280))
          {
            *(unsigned char *)(a1 + 12280)  = 0;
            __DisplaySetAAPFactorWithFade(a1, 0, 0, 0.0, *(float *)(a1 + 12252));
          }
        }
        else
        {
          *(unsigned char *)(a1 + 12280)  = 1;
          BOOL v4 = *(float *)(a1 + 12304) < *(float *)(a1 + 12256);
        }
      }
      float result = *(float *)(a2 + 4);
      *(float *)(a1 + 12304)  = result;
    }
    else if (*(_DWORD *)a2 == 2)
    {
      float result = (float)(vabds_f32(*(float *)(a2 + 4), *(float *)(a1 + 12300)) / *(float *)(a1 + 12300)) * 100.0;
      if (result > *(float *)(a1 + 12268))
      {
        float result = *(float *)(a2 + 4);
        *(float *)(a1 + 12300)  = result;
        BOOL v4 = (*(unsigned char *)(a1 + 12280) & 1) != 0;
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 12280)  = *(unsigned char *)(a2 + 4) & 1;
    if (*(unsigned char *)(a1 + 12280))
    {
      float result = *(float *)(a1 + 12304);
      BOOL v4 = result >= *(float *)(a1 + 12256);
    }
    else
    {
      float result = __DisplaySetAAPFactorWithFade(a1, 0, 0, 0.0, *(float *)(a1 + 12252));
    }
  }
  if (v4)
  {
    if (*(float *)(a1 + 12300) >= *(float *)(a1 + 12260))
    {
      if (*(float *)(a1 + 12300) < *(float *)(a1 + 12264)) {
        float v3 = (float)((float)(*(float *)(a1 + 12460) - *(float *)(a1 + 12456))
      }
                   * (float)(*(float *)(a1 + 12300) - *(float *)(a1 + 12260)))
           / (float)(*(float *)(a1 + 12264) - *(float *)(a1 + 12260));
      else {
        float v3 = *(float *)(a1 + 12460);
      }
    }
    else
    {
      float v3 = *(float *)(a1 + 12456);
    }
    if (*(float *)(a1 + 12392) >= v3) {
      return __DisplaySetAAPFactorWithFade(a1, 0, 0, v3, *(float *)(a1 + 12276));
    }
    else {
      return __DisplaySetAAPFactorWithFade(a1, 0, 0, v3, *(float *)(a1 + 12272));
    }
  }
  return result;
}

uint64_t GetCFBooleanValue(const __CFNumber *a1)
{
  CFNumberRef v5 = a1;
  int valuePtr = 0;
  if (a1)
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
    }
    else
    {
      CFTypeID v2 = CFBooleanGetTypeID();
      if (v2 == CFGetTypeID(v5)) {
        return CFEqual(v5, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      }
    }
  }
  return valuePtr;
}

{
  CFTypeID v2;
  CFTypeID TypeID;
  int valuePtr;
  CFNumberRef v5;

  CFNumberRef v5 = a1;
  int valuePtr = 0;
  if (a1)
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v5))
    {
      CFNumberGetValue(v5, kCFNumberIntType, &valuePtr);
    }
    else
    {
      CFTypeID v2 = CFBooleanGetTypeID();
      if (v2 == CFGetTypeID(v5)) {
        return CFEqual(v5, (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
      }
    }
  }
  return valuePtr;
}

void __DisplayInitializeReport(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 12520) & 1) != 0 || (*(unsigned char *)(a1 + 12514))
  {
    if (*(void *)(a1 + 12504)) {
      CFXClearReport(*(void *)(a1 + 12504));
    }
    __DisplayResetLogTimer(a1, 0);
  }
}

BOOL _DisplayCheckEDRSupport(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  started  = 0;
  if (CBU_IsWatch() || CBU_IsAccessory())
  {
    char v6 = 0;
  }
  else if ((*(unsigned char *)(a1 + 321) & 1) == 0 || *(_DWORD *)(a1 + 12592))
  {
    char v6 = 1;
  }
  else
  {
    char v6 = 0;
    if (_logHandle)
    {
      BOOL v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      BOOL v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v8, *(_DWORD *)(a1 + 12592));
      _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "Not supporting LibEDR, uses CBEDR instead: displayID: %u", v8, 8u);
    }
  }
  if ((v6 & 1) == 1) {
    started  = CBEDRServerStartServer();
  }
  char v2 = 0;
  if (started) {
    char v2 = v6;
  }
  return (v2 & 1) != 0;
}

uint64_t DisplayIsNightShiftEnabled(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v11 = 0;
  float v12 = &v11;
  int v13 = 0x20000000;
  int v14 = 32;
  int v15 = 0;
  float v1 = *(NSObject **)(a1 + 144);
  BOOL v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  unsigned int v7 = __DisplayIsNightShiftEnabled_block_invoke;
  float v8 = &unk_1E621A490;
  uint64_t v9 = &v11;
  uint64_t v10 = v16;
  disp_dispatch_sync(v1, &v4);
  unsigned int v3 = *((_DWORD *)v12 + 6);
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1BA592790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

uint64_t __DisplayIsNightShiftEnabled_block_invoke(uint64_t result)
{
  if (v1 | ((*(unsigned char *)(*(void *)(result + 40) + 12513) & 1) == 0)) {
    char v2 = 0;
  }
  else {
    char v2 = 1;
  }
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24)  = v2 & 1;
  return result;
}

uint64_t DisplayNotify(unsigned __int8 a1)
{
  unsigned __int8 v4 = a1;
  out_token  = 0;
  state64  = a1;
  notify_register_check("com.apple.iokit.hid.displayStatus", &out_token);
  notify_set_state(out_token, state64);
  return notify_post("com.apple.iokit.hid.displayStatus");
}

void DisplaySetState(uint64_t a1, int a2)
{
  uint64_t v11 = a1;
  int v10 = a2;
  char v2 = *(NSObject **)(a1 + 144);
  unsigned int v3 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  int v6 = __DisplaySetState_block_invoke;
  unsigned int v7 = &__block_descriptor_44_e5_v8__0l;
  uint64_t v8 = v11;
  int v9 = a2;
  disp_dispatch_sync(v2, &v3);
}

void __DisplaySetState_block_invoke(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a1;
  uint64_t v24 = a1;
  if (*(_DWORD *)(*(void *)(a1 + 32) + 44) != *(_DWORD *)(a1 + 40))
  {
    os_log_t v23 = 0;
    if (_logHandle)
    {
      int v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v6 = inited;
    }
    os_log_t v23 = v6;
    os_log_type_t v22 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_DWORD *)(a1 + 40)) {
        char v1 = "ON";
      }
      else {
        char v1 = "OFF";
      }
      __os_log_helper_16_2_1_8_32((uint64_t)v26, (uint64_t)v1);
      _os_log_impl(&dword_1BA438000, v23, v22, "Notify display state %s....\n", v26, 0xCu);
    }
    *(_DWORD *)(*(void *)(a1 + 32) + 44)  = *(_DWORD *)(a1 + 40);
    if (*(void *)(*(void *)(a1 + 32) + 144))
    {
      char v2 = *(NSObject **)(*(void *)(a1 + 32) + 144);
      uint64_t block = MEMORY[0x1E4F143A8];
      int v17 = -1073741824;
      int v18 = 0;
      uint64_t v19 = __DisplaySetState_block_invoke_377;
      CFDataRef v20 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v21 = *(void *)(a1 + 32);
      dispatch_async(v2, &block);
    }
    if (*(void *)(*(void *)(a1 + 32) + 192))
    {
      CFMutableDictionaryRef theDict = *(__CFDictionary **)(*(void *)(a1 + 32) + 192);
      if (*(_DWORD *)(*(void *)(a1 + 32) + 44)) {
        CFDictionarySetValue(theDict, @"DisplayOn", (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      else {
        CFDictionarySetValue(theDict, @"DisplayOn", (const void *)*MEMORY[0x1E4F1CFC8]);
      }
    }
    uint64_t v15 = 0;
    uint64_t v15 = *(int *)(a1 + 40);
    unsigned int v3 = *(NSObject **)(*(void *)(a1 + 32) + 168);
    uint64_t v8 = MEMORY[0x1E4F143A8];
    int v9 = -1073741824;
    int v10 = 0;
    uint64_t v11 = __DisplaySetState_block_invoke_2;
    uint64_t v12 = &__block_descriptor_48_e5_v8__0l;
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = v15;
    dispatch_async(v3, &v8);
  }
}

uint64_t __DisplaySetState_block_invoke_377(uint64_t result)
{
  if (*(void *)(*(void *)(result + 32) + 16))
  {
    char v1 = *(uint64_t (**)(uint64_t, __CFString *, void))(*(void *)(result + 32) + 16);
    uint64_t v2 = *(void *)(*(void *)(result + 32) + 24);
    if (*(_DWORD *)(*(void *)(result + 32) + 44)) {
      return v1(v2, @"DisplayOn", *MEMORY[0x1E4F1CFD0]);
    }
    else {
      return v1(v2, @"DisplayOn", *MEMORY[0x1E4F1CFC8]);
    }
  }
  return result;
}

uint64_t __DisplaySetState_block_invoke_2(uint64_t a1)
{
  return notify_post("com.apple.iokit.hid.displayStatus");
}

uint64_t DisplayOpen(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  os_log_type_t v68 = a1;
  uint64_t v67 = a2;
  uint64_t v66 = a3;
  unsigned __int8 v65 = 0;
  CFNumberRef v64 = 0;
  CFNumberRef v63 = 0;
  *((void *)a1 + 2)  = a2;
  *((void *)v68 + 3)  = v66;
  if (v68[12248])
  {
    CFAllocatorRef allocator = CFGetAllocator(v68);
    CFNumberRef v64 = CFNumberCreate(allocator, kCFNumberFloatType, v68 + 12460);
    CFAllocatorRef v16 = CFGetAllocator(v68);
    CFNumberRef v63 = CFNumberCreate(v16, kCFNumberFloatType, v68 + 12456);
  }
  unsigned __int8 v65 = 1;
  if (v64)
  {
    DisplaySetProperty((uint64_t)v68, @"DisplayAAPFactorMax", (uint64_t)v64);
    CFRelease(v64);
  }
  if (v63)
  {
    DisplaySetProperty((uint64_t)v68, @"DisplayAAPFactorMin", (uint64_t)v63);
    CFRelease(v63);
  }
  notify_register_check("com.apple.iokit.hid.displayStatus", (int *)v68 + 12);
  if (*((float *)v68 + 87) == 0.0)
  {
    *((_DWORD *)v68 + 11)  = 0;
  }
  else
  {
    *((_DWORD *)v68 + 11)  = 1;
    uint64_t v62 = 0;
    uint64_t v62 = *((int *)v68 + 11);
    notify_set_state(*((_DWORD *)v68 + 12), v62);
    notify_post("com.apple.iokit.hid.displayStatus");
  }
  if (*((void *)v68 + 24))
  {
    CFMutableDictionaryRef theDict = (__CFDictionary *)*((void *)v68 + 24);
    if (*((_DWORD *)v68 + 11)) {
      CFDictionarySetValue(theDict, @"DisplayOn", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    else {
      CFDictionarySetValue(theDict, @"DisplayOn", (const void *)*MEMORY[0x1E4F1CFC8]);
    }
  }
  *((_DWORD *)v68 + 312)  = -1;
  *((_DWORD *)v68 + 27)  = 0;
  ValueAtIndex  = 0;
  DisplayList  = (const __CFArray *)IOMobileFramebufferCreateDisplayList();
  if (DisplayList)
  {
    for (int i = 0; i < CFArrayGetCount(DisplayList); ++i)
    {
      ValueAtIndex  = CFArrayGetValueAtIndex(DisplayList, i);
      if (!ValueAtIndex[2]) {
        break;
      }
    }
    CFRelease(DisplayList);
    if (ValueAtIndex)
    {
      int v58 = 0;
      uint64_t v57 = IOMobileFramebufferOpenByName();
    }
  }
  *((_DWORD *)v68 + 34)  = 1;
  *((_DWORD *)v68 + 35)  = -1;
  *((float *)v68 + 94)  = -1.0;
  v68[380]  = 0;
  CFTypeRef v56 = 0;
  CFTypeRef v56 = IORegistryEntrySearchCFProperty(*((_DWORD *)v68 + 20), "IOService", @"ignore-IOMFB", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  BOOL v55 = 0;
  if (v56)
  {
    CFTypeID TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v56))
    {
      int v54 = 0;
      _DisplayGetUint32FromCFDataAndRelease(v56, &v54);
      BOOL v55 = v54 != 0;
    }
    else
    {
      CFRelease(v56);
    }
  }
  if (v55 || (v68[312] & 1) != 0) {
    *((_DWORD *)v68 + 34)  = 0;
  }
  if ((v68[312] & 1) == 0)
  {
    unsigned int v3 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
    dispatch_queue_t v4 = dispatch_queue_create(0, v3);
    *((void *)v68 + 15)  = v4;
  }
  v68[320]  = 0;
  if (CBU_IsWatch()) {
    v68[320]  = 1;
  }
  *((float *)v68 + 3098)  = -1.0;
  __DisplaySetAAPFactor(v68, *((float *)v68 + 3114));
  *((_DWORD *)v68 + 71)  = 0;
  v68[288]  = 0;
  v68[289]  = 0;
  CFProperty  = 0;
  CFProperty  = (const __CFNumber *)IORegistryEntryCreateCFProperty(*((_DWORD *)v68 + 20), @"nitsThresholdPLC", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  if (CFProperty)
  {
    CFTypeID v13 = CFNumberGetTypeID();
    if (v13 == CFGetTypeID(CFProperty))
    {
      CFNumberGetValue(CFProperty, kCFNumberIntType, v68 + 284);
      v68[288]  = 1;
    }
    CFRelease(CFProperty);
  }
  if (*((_DWORD *)v68 + 27))
  {
    CFTypeRef v52 = 0;
    CFTypeRef v52 = IORegistryEntrySearchCFProperty(*((_DWORD *)v68 + 27), "IOService", @"limit_max_physical_brightness", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    int v51 = 0;
    int v51 = (int)(float)(*((float *)v68 + 386) * 65536.0);
    if (_DisplayGetUint32FromCFNumberAndRelease(v52, &v51)) {
      *((float *)v68 + 386)  = (float)v51 / 65536.0;
    }
    os_log_t v50 = 0;
    if (_logHandle)
    {
      uint64_t v12 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v12 = inited;
    }
    os_log_t v50 = v12;
    os_log_type_t v49 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v70, COERCE__INT64(*((float *)v68 + 386)));
      _os_log_debug_impl(&dword_1BA438000, v50, v49, "New hardwareAccessibleMaxNits: %f", v70, 0xCu);
    }
  }
  char v47 = MGGetBoolAnswer() & 1;
  char v48 = v47;
  *((_DWORD *)v68 + 3179)  = v47 != 0;
  os_log_t v46 = 0;
  if (_logHandle)
  {
    int v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v9 = init_default_corebrightness_log();
    }
    int v10 = v9;
  }
  os_log_t v46 = v10;
  os_log_type_t v45 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if (v48) {
      int v5 = "OLED";
    }
    else {
      int v5 = "LCD";
    }
    __os_log_helper_16_2_1_8_32((uint64_t)v69, (uint64_t)v5);
    _os_log_impl(&dword_1BA438000, v46, v45, "Device has %s display.", v69, 0xCu);
  }
  if (*((_DWORD *)v68 + 3149) == 1)
  {
    v41[0]  = 0;
    v41[1]  = v41;
    int v42 = 0x20000000;
    int v43 = 32;
    int v44 = 0;
    v37[0]  = 0;
    v37[1]  = v37;
    int v38 = 0x20000000;
    int v39 = 32;
    int v40 = 0;
    v33[0]  = 0;
    v33[1]  = v33;
    int v34 = 0x20000000;
    int v35 = 32;
    int v36 = 0;
    v29[0]  = 0;
    v29[1]  = v29;
    int v30 = 0x20000000;
    int v31 = 32;
    int v32 = 0;
    uint64_t v6 = *((void *)v68 + 18);
    uint64_t v19 = MEMORY[0x1E4F143A8];
    int v20 = -1073741824;
    int v21 = 0;
    os_log_type_t v22 = __DisplayOpen_block_invoke;
    os_log_t v23 = &unk_1E621A4D8;
    uint64_t v28 = v68;
    uint64_t v24 = v41;
    uint64_t v25 = v37;
    io_registry_entry_t v26 = v33;
    uint64_t v27 = v29;
    CBEDRServerRegisterCallbackBlockOnQueue(v6, (uint64_t)&v19);
    v68[12181]  = 0;
    if (([MEMORY[0x1E4F56678] isCPMSSupported] & 1) == 1)
    {
      v68[12181]  = 1;
      if (DisplayHasDCP((uint64_t)v68))
      {
        *((void *)v68 + 1516)  = IOReportCopyChannelsInGroup();
        if (*((void *)v68 + 1516)) {
          *((void *)v68 + 1518)  = IOReportCreateSubscription();
        }
      }
      else
      {
        *((void *)v68 + 1516)  = 0;
        *((void *)v68 + 1517)  = 0;
        *((void *)v68 + 1518)  = 0;
        *((void *)v68 + 1519)  = 0;
        *((void *)v68 + 1520)  = 0;
        *((void *)v68 + 1521)  = 0;
        CFMutableDictionaryRef v18 = IOServiceMatching("IOMobileFramebuffer");
        *((void *)v68 + 1516)  = IOReportCopyChannelsWithID();
        if (*((void *)v68 + 1516)) {
          *((void *)v68 + 1518)  = IOReportCreateSubscription();
        }
        *((void *)v68 + 1519)  = IOReportCopyChannelsWithID();
        if (*((void *)v68 + 1519)) {
          *((void *)v68 + 1521)  = IOReportCreateSubscription();
        }
        *((void *)v68 + 1511)  = 0;
        *((void *)v68 + 1512)  = 0;
        *((void *)v68 + 1514)  = 0;
        *((_DWORD *)v68 + 3030)  = 0;
        if (v18) {
          CFRelease(v18);
        }
      }
    }
    _Block_object_dispose(v29, 8);
    _Block_object_dispose(v33, 8);
    _Block_object_dispose(v37, 8);
    _Block_object_dispose(v41, 8);
  }
  if (*((_DWORD *)v68 + 21))
  {
    IONotificationPortRef v8 = IONotificationPortCreate(*MEMORY[0x1E4F2EEF0]);
    *((void *)v68 + 22)  = v8;
    if (*((void *)v68 + 22))
    {
      if (*((void *)v68 + 18))
      {
        IONotificationPortSetDispatchQueue(*((IONotificationPortRef *)v68 + 22), *((dispatch_queue_t *)v68 + 18));
        IOServiceAddInterestNotification(*((IONotificationPortRef *)v68 + 22), *((_DWORD *)v68 + 20), "IOGeneralInterest", (IOServiceInterestCallback)BacklightGeneralInterestNotificationCallback, v68, (io_object_t *)v68 + 46);
      }
    }
  }
  _DisplayReduceBacklightCompensation((uint64_t)v68, 1.0);
  return v65;
}

void sub_1BA593CB0()
{
  _Unwind_Resume(v0);
}

void __DisplaySetAAPFactor(unsigned char *a1, float a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = (uint64_t)a1;
  float valuePtr = a2;
  if (a1[12248])
  {
    if (*(_DWORD *)(v15 + 108))
    {
      float valuePtr = fminf(fmaxf(valuePtr, *(float *)(v15 + 12456)), *(float *)(v15 + 12460));
      int v13 = (int)(float)(valuePtr * 1023.0);
      int v12 = 0;
      int v12 = (int)(float)(*(float *)(v15 + 12392) * 1023.0);
      if (v13 != v12 || *(float *)(v15 + 12468) >= 0.0)
      {
        os_log_t v11 = 0;
        if (_logHandle)
        {
          uint64_t v6 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t inited = init_default_corebrightness_log();
          }
          uint64_t v6 = inited;
        }
        os_log_t v11 = v6;
        os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          if (*(float *)(v15 + 12468) >= 0.0) {
            float v4 = *(float *)(v15 + 12468);
          }
          else {
            float v4 = valuePtr;
          }
          __os_log_helper_16_0_1_8_0((uint64_t)v16, COERCE__INT64(v4));
          _os_log_debug_impl(&dword_1BA438000, v11, v10, "AAP factor=%0.4f", v16, 0xCu);
        }
        *(float *)(v15 + 12392)  = valuePtr;
        CFNumberRef v9 = 0;
        CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
        if (v9)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v15 + 192), @"DisplayAAPFactor", v9);
          CFRelease(v9);
        }
        if (![+[CBAODState sharedInstance] isAODActive])
        {
          if (*(unsigned char *)(v15 + 321) & 1) != 0 && (CBU_PassContrastEnhancerStrengthThroughSyncDBV())
          {
            SendSyncDBVNotification(v15, 0, (float)*(int *)(v15 + 1248) / 65536.0);
          }
          else
          {
            int v8 = 0;
            if (*(float *)(v15 + 12468) >= 0.0) {
              float v3 = *(float *)(v15 + 12468);
            }
            else {
              float v3 = *(float *)(v15 + 12392);
            }
            int v8 = (int)(float)(v3 * 65536.0);
            CFAllocatorRef v2 = CFGetAllocator((CFTypeRef)v15);
            CFNumberRef property = CFNumberCreate(v2, kCFNumberSInt32Type, &v8);
            if (property)
            {
              IORegistryEntrySetCFProperty(*(_DWORD *)(v15 + 108), @"IOMFBContrastEnhancerStrength", property);
              CFRelease(property);
            }
          }
        }
      }
    }
  }
}

uint64_t _DisplayGetUint32FromCFNumberAndRelease(const void *a1, _DWORD *a2)
{
  CFTypeRef v7 = a1;
  uint64_t v6 = a2;
  char v5 = 0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(v7);
    if (v3 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      if (CFNumberGetByteSize((CFNumberRef)v7) == 4)
      {
        CFNumberGetValue((CFNumberRef)v7, kCFNumberSInt32Type, &valuePtr);
        *uint64_t v6 = valuePtr;
        char v5 = 1;
      }
    }
    CFRelease(v7);
  }
  return v5 & 1;
}

void __DisplayStartAPLCPMSTimer(dispatch_object_t *a1, float a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v21 = a1;
  float v20 = a2;
  if (([MEMORY[0x1E4F56678] isCPMSSupported] & 1) == 1)
  {
    if (v21[1514] && v20 < *((float *)v21 + 3030))
    {
      dispatch_release(v21[1514]);
      v21[1514]  = 0;
    }
    if (v21[1514])
    {
      if (_logHandle)
      {
        CFTypeID v3 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        CFTypeID v3 = inited;
      }
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_1_8_32((uint64_t)v22, (uint64_t)"void __DisplayStartAPLCPMSTimer(DisplayRef, float)");
        _os_log_debug_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEBUG, "%s: Reusing current HDR Callback Timer\n", v22, 0xCu);
      }
    }
    else
    {
      *((float *)v21 + 3030)  = v20;
      v21[1514]  = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v21[18]);
      if (v21[1514])
      {
        uint64_t v19 = 0;
        uint64_t v18 = 0;
        uint64_t v18 = (unint64_t)(float)(*((float *)v21 + 3030) * 1000000000.0);
        dispatch_source_set_timer(v21[1514], 0, v18, 0);
        if ((_BYTE)v21[20])
        {
          dispatch_set_context(v21[1514], v21);
          dispatch_source_set_event_handler_f(v21[1514], (dispatch_function_t)__DisplayCPMSHDRCallback);
        }
        else
        {
          dispatch_block_t v17 = 0;
          uint64_t block = MEMORY[0x1E4F143A8];
          int v12 = -1073741824;
          int v13 = 0;
          uint64_t v14 = ____DisplayStartAPLCPMSTimer_block_invoke;
          uint64_t v15 = &__block_descriptor_40_e5_v8__0l;
          CFAllocatorRef v16 = v21;
          dispatch_block_t v17 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_DEFAULT, 0, &block);
          if (v17)
          {
            dispatch_source_set_event_handler(v21[1514], v17);
            _Block_release(v17);
          }
        }
        dispatch_resume(v21[1514]);
      }
      else
      {
        os_log_t oslog = 0;
        if (_logHandle)
        {
          CFTypeRef v7 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v6 = init_default_corebrightness_log();
          }
          CFTypeRef v7 = v6;
        }
        os_log_t oslog = v7;
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          os_log_t log = oslog;
          os_log_type_t v5 = type;
          __os_log_helper_16_0_0(v8);
          _os_log_error_impl(&dword_1BA438000, log, v5, "Could not create HDR Callback Timer\n", v8, 2u);
        }
      }
    }
  }
}

uint64_t __DisplayProcessHDRStatusForCoreAnalytics(uint64_t a1)
{
  return +[CBAnalytics hdrSession:*(unsigned char *)(a1 + 12082) & 1];
}

void SetBLDriverNitsCapIfNotInLPM(uint64_t a1, int a2)
{
  if ((*(unsigned char *)(a1 + 1504) & 1) == 0 && (*(unsigned char *)(a1 + 232) & 1) == 0) {
    SetBLDriverNitsCap((const void *)a1, a2);
  }
  *(_DWORD *)(a1 + 1512)  = a2;
}

void BacklightGeneralInterestNotificationCallback(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a3 == -536870352)
    {
      *(_DWORD *)(a1 + 104)  = 1;
      if (_logHandle)
      {
        uint64_t v6 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v6 = inited;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_4_0((uint64_t)v8, -536870352);
        _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "Backlight ON: %x", v8, 8u);
      }
    }
    else if (a3 == -536870384)
    {
      *(_DWORD *)(a1 + 104)  = 0;
      if (_logHandle)
      {
        float v4 = _logHandle;
      }
      else
      {
        uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        float v4 = v3;
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_4_0((uint64_t)v7, -536870384);
        _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "Backlight OFF: %x", v7, 8u);
      }
    }
  }
}

void _DisplayReduceBacklightCompensation(uint64_t a1, float a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1;
  *(float *)&valuePtr[1]  = a2;
  valuePtr[0]  = (int)(float)(a2 * 65536.0);
  int v4 = 0x20000;
  values  = 0;
  CFNumberRef v9 = 0;
  CFAllocatorRef v2 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  values  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, valuePtr);
  CFNumberRef v9 = CFNumberCreate(*v2, kCFNumberIntType, &v4);
  *(_OWORD *)keys  = xmmword_1E621A720;
  if (values)
  {
    if (v9)
    {
      CFDictionaryRef cf = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (cf)
      {
        __DisplaySetBLDriverProperty(v6, @"CompensationTweak", cf);
        CFRelease(cf);
      }
    }
  }
  if (values) {
    CFRelease(values);
  }
  if (v9) {
    CFRelease(v9);
  }
}

void DisplayClose(uint64_t a1)
{
  if (*(void *)(a1 + 176))
  {
    IONotificationPortDestroy(*(IONotificationPortRef *)(a1 + 176));
    *(void *)(a1 + 176)  = 0;
  }
  if (*(_DWORD *)(a1 + 184))
  {
    IOObjectRelease(*(_DWORD *)(a1 + 184));
    *(_DWORD *)(a1 + 184)  = 0;
  }
}

void _DisplaySetLockState(uint64_t a1, int a2)
{
  uint64_t v11 = a1;
  int v10 = a2;
  CFAllocatorRef v2 = *(NSObject **)(a1 + 144);
  uint64_t v3 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  uint64_t v6 = ___DisplaySetLockState_block_invoke;
  CFTypeRef v7 = &__block_descriptor_44_e5_v8__0l;
  uint64_t v8 = v11;
  int v9 = a2;
  disp_dispatch_sync(v2, &v3);
}

uint64_t DisplayGetProperty(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  int v15 = 0x20000000;
  int v16 = 32;
  uint64_t v17 = 0;
  CFAllocatorRef v2 = *(NSObject **)(a1 + 144);
  int v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  uint64_t v8 = __DisplayGetProperty_block_invoke;
  int v9 = &unk_1E62194F0;
  int v10 = &v13;
  uint64_t v11 = v19;
  uint64_t v12 = a2;
  disp_dispatch_sync(v2, &v5);
  uint64_t v4 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA594C9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

const void *__DisplayGetProperty_block_invoke(uint64_t a1)
{
  float result = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 40) + 192), *(const void **)(a1 + 48));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = result;
  return result;
}

float DisplayInitializeFastEDR(uint64_t a1)
{
  *(void *)(a1 + 12608)  = 0;
  float result = 1.0;
  *(float *)(a1 + 12624)  = 1.0;
  *(float *)(a1 + 12632)  = 1.0;
  *(float *)(a1 + 12628)  = 1.0;
  *(void *)(a1 + 12640)  = 0;
  return result;
}

void __DisplayStartFade(unsigned char *a1, float a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a1;
  float v27 = a2;
  if (a1[321])
  {
    HIDWORD(v2)  = 0;
    float v26 = 1.0 / v27;
    if ((*((unsigned char *)v28 + 322) & 1) != 0 || (double v2 = *((double *)v28 + 1576), v2 > 0.0))
    {
      float v26 = 120.0;
      LODWORD(v2)  = 1123024896;
      [*((id *)v28 + 26) setPreferredFramesPerSecond:v2];
      if ([*((id *)v28 + 26) isPaused]) {
        [*((id *)v28 + 26) resume];
      }
      *((float *)v28 + 54)  = 1.0 / v26;
    }
    else if ([*((id *)v28 + 26) isPaused])
    {
      *(float *)&double v3 = v26;
      [*((id *)v28 + 26) setPreferredFramesPerSecond:v3];
      [*((id *)v28 + 26) resume];
      *((float *)v28 + 54)  = v27;
    }
    else if (v27 < *((float *)v28 + 54))
    {
      os_log_t v25 = 0;
      if (_logHandle)
      {
        uint64_t v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v12 = inited;
      }
      os_log_t v25 = v12;
      os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v30, COERCE__INT64(v27), COERCE__INT64(*((float *)v28 + 54)), COERCE__INT64(v26));
        _os_log_impl(&dword_1BA438000, v25, v24, "Requested interval: %fsec is lower than current: %fsec, update CADisplayLink to %fhz", v30, 0x20u);
      }
      *(float *)&double v4 = v26;
      [*((id *)v28 + 26) setPreferredFramesPerSecond:v4];
      *((float *)v28 + 54)  = v27;
    }
  }
  else
  {
    if (*((void *)v28 + 1560) && v27 < *((float *)v28 + 3122))
    {
      dispatch_release(*((dispatch_object_t *)v28 + 1560));
      *((void *)v28 + 1560)  = 0;
    }
    if (*((void *)v28 + 1560))
    {
      if (_logHandle)
      {
        int v6 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v5 = init_default_corebrightness_log();
        }
        int v6 = v5;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_1_8_32((uint64_t)v29, (uint64_t)"void __DisplayStartFade(DisplayRef, float)");
        _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "%s: Reusing current ramp timer\n", v29, 0xCu);
      }
    }
    else
    {
      *((float *)v28 + 3122)  = v27;
      *((void *)v28 + 1560)  = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *((dispatch_queue_t *)v28 + 18));
      if (*((void *)v28 + 1560))
      {
        uint64_t v23 = 0;
        uint64_t v23 = (unint64_t)(float)(*((float *)v28 + 3122) * 1000000000.0);
        dispatch_source_set_timer(*((dispatch_source_t *)v28 + 1560), 0, v23, 0);
        if (*((unsigned char *)v28 + 160))
        {
          dispatch_set_context(*((dispatch_object_t *)v28 + 1560), v28);
          dispatch_source_set_event_handler_f(*((dispatch_source_t *)v28 + 1560), (dispatch_function_t)__DisplayFadeCallback);
        }
        else
        {
          dispatch_block_t v22 = 0;
          uint64_t block = MEMORY[0x1E4F143A8];
          int v17 = -1073741824;
          int v18 = 0;
          uint64_t v19 = ____DisplayStartFade_block_invoke;
          float v20 = &__block_descriptor_40_e5_v8__0l;
          int v21 = v28;
          dispatch_block_t v22 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, QOS_CLASS_USER_INITIATED, 0, &block);
          if (v22)
          {
            dispatch_source_set_event_handler(*((dispatch_source_t *)v28 + 1560), v22);
            _Block_release(v22);
          }
        }
        dispatch_resume(*((dispatch_object_t *)v28 + 1560));
      }
      else
      {
        os_log_t oslog = 0;
        if (_logHandle)
        {
          int v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v9 = init_default_corebrightness_log();
          }
          int v10 = v9;
        }
        os_log_t oslog = v10;
        os_log_type_t v14 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          int v7 = oslog;
          os_log_type_t v8 = v14;
          __os_log_helper_16_0_0(v13);
          _os_log_error_impl(&dword_1BA438000, v7, v8, "Could not create ramp timer\n", v13, 2u);
        }
      }
    }
  }
}

float DisplayInitializeRTPLCEDRRamp(uint64_t a1)
{
  *(void *)(a1 + 12656)  = 0;
  float result = 1.0;
  *(float *)(a1 + 12672)  = 1.0;
  *(float *)(a1 + 12680)  = 1.0;
  *(float *)(a1 + 12676)  = 1.0;
  *(void *)(a1 + 12688)  = 0;
  *(unsigned char *)(a1 + 12704)  = 0;
  return result;
}

uint64_t DisplayStartRTPLCEDRCapRamp(uint64_t a1, char a2, float a3, float a4, float a5)
{
  uint64_t v21 = a1;
  float v20 = a3;
  float v19 = a4;
  float v18 = a5;
  char v17 = a2 & 1;
  uint64_t v5 = *(NSObject **)(a1 + 144);
  int v7 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v8 = -1073741824;
  int v9 = 0;
  int v10 = __DisplayStartRTPLCEDRCapRamp_block_invoke;
  uint64_t v11 = &__block_descriptor_53_e5_v8__0l;
  char v16 = a2 & 1;
  float v13 = a3;
  uint64_t v12 = v21;
  float v14 = a4;
  float v15 = a5;
  disp_dispatch_sync(v5, &v7);
  return 1;
}

void __DisplayStartRTPLCEDRCapRamp_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 52))
  {
    float v8 = *(float *)(a1 + 40);
  }
  else
  {
    if (*(unsigned char *)(*(void *)(a1 + 32) + 12704)) {
      float v4 = *(float *)(*(void *)(a1 + 32) + 12676);
    }
    else {
      float v4 = *(float *)(a1 + 40);
    }
    float v8 = v4;
  }
  double v7 = (float)(fabsf(log2f(*(float *)(a1 + 44) / v8)) * *(float *)(a1 + 48));
  if (v7 <= 0.0)
  {
    int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 1328) | 1;
    *(_DWORD *)(*(void *)(a1 + 32) + 12672)  = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(*(void *)(a1 + 32) + 12676)  = *(_DWORD *)(*(void *)(a1 + 32) + 12672);
    *(void *)(*(void *)(a1 + 32) + 12656)  = 0;
    __DisplaySetLogicalBrightnessInternal(*(const void **)(a1 + 32), v6 | 0x40, *(float *)(*(void *)(a1 + 32) + 1256));
  }
  else
  {
    *(double *)(*(void *)(a1 + 32) + 12656)  = v7;
    *(_DWORD *)(*(void *)(a1 + 32) + 12672)  = *(_DWORD *)(a1 + 44);
    *(float *)(*(void *)(a1 + 32) + 12680)  = v8;
    *(float *)(*(void *)(a1 + 32) + 12676)  = v8;
    *(CFAbsoluteTime *)(*(void *)(a1 + 32) + 12664)  = CFAbsoluteTimeGetCurrent();
    *(void *)(*(void *)(a1 + 32) + 12688)  = 0;
    if (_logHandle)
    {
      double v3 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      double v3 = inited;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      char v1 = "YES";
      if ((*(unsigned char *)(*(void *)(a1 + 32) + 12704) & 1) == 0) {
        char v1 = "NO";
      }
      __os_log_helper_16_2_8_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_32((uint64_t)v9, COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 12680)), COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 12672)), *(uint64_t *)&v7, COERCE__INT64(*(float *)(a1 + 40)), COERCE__INT64(v8), COERCE__INT64(*(float *)(a1 + 44)), COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 12676)), (uint64_t)v1);
      _os_log_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEFAULT, "HDR RTPLC CAP: \n\tFADE: %f --------> %f, duration: %f, \n\tstart:%f, \n\thStart:%f, \n\ttarget:%f, \n\tdisplay->rtplcEDRFade.fade.Hcurrent: %f\n\trtplcFadeIsRunning: %s", v9, 0x52u);
    }
    __DisplayStartFade(*(unsigned char **)(a1 + 32), 0.0083333);
  }
}

uint64_t __os_log_helper_16_2_8_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 8;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 32;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  return result;
}

double __DisplayRTPLCEDRUpdateFade(uint64_t a1, uint64_t a2, double a3)
{
  double v6 = (a3 - *(double *)(a2 + 8)) / *(double *)a2;
  if (v6 >= 1.0)
  {
    *(_DWORD *)(a2 + 20)  = *(_DWORD *)(a2 + 16);
    double result = 0.0;
    *(void *)a2  = 0;
    *(unsigned char *)(a1 + 12704)  = 0;
  }
  else
  {
    float v3 = -v6;
    float v5 = *(float *)(a2 + 24);
    *(float *)&double result = v5 * powf(fabsf(v5 / *(float *)(a2 + 16)), v3);
    *(_DWORD *)(a2 + 20)  = LODWORD(result);
  }
  return result;
}

float DisplayGetCurrentRTPLCHeadroomCap(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v11 = 0;
  uint64_t v12 = (float *)&v11;
  int v13 = 0x20000000;
  int v14 = 32;
  float v15 = 1.0;
  char v1 = *(NSObject **)(a1 + 144);
  float v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  double v7 = __DisplayGetCurrentRTPLCHeadroomCap_block_invoke;
  float v8 = &unk_1E621A490;
  int v9 = &v11;
  uint64_t v10 = v16;
  disp_dispatch_sync(v1, &v4);
  float v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1BA595B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

float __DisplayGetCurrentRTPLCHeadroomCap_block_invoke(uint64_t a1)
{
  float result = *(float *)(*(void *)(a1 + 40) + 12676);
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = result;
  return result;
}

double __DisplayFastEDRUpdateFade(double a1, uint64_t a2, uint64_t a3)
{
  double v6 = (a1 - *(double *)(a3 + 8)) / *(double *)a3;
  if (v6 >= 1.0)
  {
    *(_DWORD *)(a3 + 20)  = *(_DWORD *)(a3 + 16);
    double result = 0.0;
    *(void *)a3  = 0;
  }
  else
  {
    float v3 = -v6;
    float v5 = *(float *)(a3 + 24);
    *(float *)&double result = v5 * powf(fabsf(v5 / *(float *)(a3 + 16)), v3);
    *(_DWORD *)(a3 + 20)  = LODWORD(result);
  }
  return result;
}

void DisplayClockCapRamp(uint64_t a1)
{
  uint64_t v8 = a1;
  char v1 = *(NSObject **)(a1 + 144);
  double v2 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  float v5 = __DisplayClockCapRamp_block_invoke;
  double v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void __DisplayClockCapRamp_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 12712)  = 1;
  __DisplayStartFade(*(unsigned char **)(a1 + 32), 0.016667);
}

void DisplayStopCapRamp(uint64_t a1)
{
  uint64_t v8 = a1;
  char v1 = *(NSObject **)(a1 + 144);
  double v2 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  float v5 = __DisplayStopCapRamp_block_invoke;
  double v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

uint64_t __DisplayStopCapRamp_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 12712)  = 0;
  return result;
}

void DisplaySetDCPPowerAssertionForAOT(uint64_t a1, char a2)
{
  uint64_t v16 = a1;
  char v15 = a2 & 1;
  v11[0]  = 0;
  v11[1]  = v11;
  int v12 = 0x20000000;
  int v13 = 32;
  uint64_t v14 = 0;
  if ((a2 & 1) == 1) {
    uint64_t v3 = *MEMORY[0x1E4F1CFD0];
  }
  else {
    uint64_t v3 = *MEMORY[0x1E4F1CFC8];
  }
  uint64_t v14 = v3;
  double v2 = *(NSObject **)(v16 + 144);
  int v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  uint64_t v7 = __DisplaySetDCPPowerAssertionForAOT_block_invoke;
  uint64_t v8 = &unk_1E621A490;
  uint64_t v10 = v16;
  int v9 = v11;
  disp_dispatch_sync(v2, &v4);
  _Block_object_dispose(v11, 8);
}

void sub_1BA595EDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, int a12, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v13 - 48), 8);
  _Unwind_Resume(a1);
}

void __DisplaySetDCPPowerAssertionForAOT_block_invoke(uint64_t a1)
{
}

float DisplaySliderToLogicalBrightness(uint64_t a1, float a2)
{
  uint64_t v19 = a1;
  float v18 = a2;
  uint64_t v13 = 0;
  uint64_t v14 = (float *)&v13;
  int v15 = 0x20000000;
  int v16 = 32;
  int v17 = 0;
  double v2 = *(NSObject **)(a1 + 144);
  int v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  uint64_t v8 = __DisplaySliderToLogicalBrightness_block_invoke;
  int v9 = &unk_1E621A430;
  uint64_t v10 = &v13;
  uint64_t v11 = v19;
  float v12 = a2;
  disp_dispatch_sync(v2, &v5);
  float v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA596028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __DisplaySliderToLogicalBrightness_block_invoke(uint64_t a1)
{
  float v1 = _DisplaySliderToLogicalBrightnessInternal(*(void *)(a1 + 40), *(float *)(a1 + 48));
  uint64_t result = a1;
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = v1;
  return result;
}

float DisplayLogicalToSliderBrightness(uint64_t a1, float a2)
{
  uint64_t v19 = a1;
  float v18 = a2;
  uint64_t v13 = 0;
  uint64_t v14 = (float *)&v13;
  int v15 = 0x20000000;
  int v16 = 32;
  int v17 = 0;
  double v2 = *(NSObject **)(a1 + 144);
  int v5 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v6 = -1073741824;
  int v7 = 0;
  uint64_t v8 = __DisplayLogicalToSliderBrightness_block_invoke;
  int v9 = &unk_1E621A430;
  uint64_t v10 = &v13;
  uint64_t v11 = v19;
  float v12 = a2;
  disp_dispatch_sync(v2, &v5);
  float v4 = v14[6];
  _Block_object_dispose(&v13, 8);
  return v4;
}

void sub_1BA59617C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __DisplayLogicalToSliderBrightness_block_invoke(uint64_t a1)
{
  float v1 = _DisplayLogicalToSliderBrightnessInternal(*(void *)(a1 + 40), *(float *)(a1 + 48));
  uint64_t result = a1;
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = v1;
  return result;
}

void __ShortcutAllRamps(unsigned char *a1)
{
  uint64_t v8 = a1;
  int v7 = 0;
  if (_logHandle)
  {
    float v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    float v4 = inited;
  }
  int v7 = v4;
  os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    os_log_t log = v7;
    os_log_type_t type = v6;
    __os_log_helper_16_0_0(v5);
    _os_log_impl(&dword_1BA438000, log, type, "Display has been turned off, shortcutting all ramps", v5, 2u);
  }
  *((void *)v8 + 174)  = 0;
  *((void *)v8 + 52)  = 0;
  *((void *)v8 + 60)  = 0;
  *((void *)v8 + 75)  = 0;
  *((void *)v8 + 84)  = 0;
  *((void *)v8 + 125)  = 0;
  *((void *)v8 + 134)  = 0;
  *((void *)v8 + 1620)  = 0;
  *((void *)v8 + 168)  = 0;
  *((void *)v8 + 181)  = 0;
  *((void *)v8 + 1525)  = 0;
  *((void *)v8 + 1577)  = 0;
  *((void *)v8 + 1583)  = 0;
  *((void *)v8 + 198)  = 0;
  *((void *)v8 + 1551)  = 0;
  *((void *)v8 + 106)  = 0;
  __DisplayFadeCallback(v8);
}

void __DisplayFadeCallback(unsigned char *a1)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  int v54 = a1;
  int v53 = a1;
  if (a1)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    char v51 = 0;
    char v50 = 0;
    char v49 = 0;
    char v48 = 1;
    char v47 = 0;
    char v46 = 0;
    char v45 = 0;
    if (*((double *)v53 + 173) > 0.0)
    {
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)v53 + 173, 1, Current);
      _DisplaySetBrightnessFactor((uint64_t)v53, *((float *)v53 + 351));
      if (*((double *)v53 + 173) <= 0.0)
      {
        kdebug_trace();
        char v49 = 1;
      }
      else
      {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 51) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 408));
      if (!getClientOverrideState((uint64_t)v53, 1)
        || *((float *)v53 + 100) > *((float *)v53 + 242)
        || *((float *)v53 + 99) > *((float *)v53 + 242))
      {
        *((float *)v53 + 100)  = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 107));
      }
      os_log_t v44 = 0;
      if (_logHandle)
      {
        float v26 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        float v26 = inited;
      }
      os_log_t v44 = v26;
      os_log_type_t v43 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v57, COERCE__INT64(*((float *)v53 + 100)));
        _os_log_debug_impl(&dword_1BA438000, v44, v43, "display->brightness.restriction.min.Lcurrent=%f\n", v57, 0xCu);
      }
      if (*((double *)v53 + 51) <= 0.0) {
        char v50 = 1;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 59) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 472));
      *((float *)v53 + 116)  = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 123));
      if (*((double *)v53 + 59) <= 0.0) {
        char v50 = 1;
      }
      else {
        char v48 = 0;
      }
      if (_DisplayCLTMRev2Applicable((uint64_t)v53)
        && *((_DWORD *)v53 + 389) == 1
        && (v48 & 1) == 1
        && *((float *)v53 + 388) == 0.0)
      {
        *((_DWORD *)v53 + 116)  = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 74) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 592));
      *((float *)v53 + 132)  = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 153));
      if (*((double *)v53 + 74) <= 0.0) {
        char v50 = 1;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 98) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 784));
      *((float *)v53 + 195)  = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 201));
      if (*((double *)v53 + 98) <= 0.0) {
        char v50 = 1;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 83) > 0.0)
    {
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)v53 + 83, 0, Current);
      *((_DWORD *)v53 + 162)  = *((_DWORD *)v53 + 171);
      float v42 = 0.0;
      float v1 = 0.5 * (float)(*((float *)v53 + 162) - 0.8) / 0.199999988 + 0.5;
      float v42 = v1;
      _DisplayReduceBacklightCompensation((uint64_t)v53, v1);
      if (*((double *)v53 + 83) <= 0.0) {
        char v49 = 1;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 91) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 728));
      *((float *)v53 + 181)  = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 187));
      if (*((double *)v53 + 91) <= 0.0) {
        char v50 = 1;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 124) > 0.0)
    {
      __DisplayFadeUpdateRestrictionFactorFade(Current, (uint64_t)v53, (uint64_t)(v53 + 992));
      *((_DWORD *)v53 + 246)  = *((_DWORD *)v53 + 253);
      if (*((double *)v53 + 124) <= 0.0) {
        char v49 = 1;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 133) > 0.0)
    {
      __DisplayFadeUpdateRestrictionFactorFade(Current, (uint64_t)v53, (uint64_t)(v53 + 1064));
      *((_DWORD *)v53 + 264)  = *((_DWORD *)v53 + 271);
      if (*((double *)v53 + 133) <= 0.0) {
        char v49 = 1;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 1619) > 0.0)
    {
      __DisplayFadeUpdateAuroraFactorFade((uint64_t)v53, (uint64_t)(v53 + 12952), Current);
      *((_DWORD *)v53 + 3236)  = *((_DWORD *)v53 + 3243);
      if (*((double *)v53 + 1619) <= 0.0) {
        char v49 = 1;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 167) <= 0.0)
    {
      *((float *)v53 + 70)  = -1.0;
    }
    else
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 1336));
      if (*((float *)v53 + 87) == 0.0 && *((float *)v53 + 339) == 0.0) {
        *((_DWORD *)v53 + 314)  = 0;
      }
      else {
        *((float *)v53 + 314)  = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 339));
      }
      if (*((double *)v53 + 167) <= 0.0)
      {
        char v50 = 1;
        *((float *)v53 + 70)  = -1.0;
      }
      else
      {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((void *)v53 + 41)
      && ([*((id *)v53 + 41) isActive] & 1) != 0
      && *(double *)[*((id *)v53 + 41) fade] > 0.0)
    {
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)[*((id *)v53 + 41) fade], 0, Current);
      if (*(double *)[*((id *)v53 + 41) fade] > 0.0) {
        char v48 = 0;
      }
      char v51 = 1;
    }
    if (*((double *)v53 + 180) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 1440));
      if (*((float *)v53 + 87) == 0.0 && *((float *)v53 + 365) == 0.0) {
        *((_DWORD *)v53 + 372)  = 0;
      }
      else {
        *((float *)v53 + 372)  = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 365));
      }
      if (*((double *)v53 + 180) <= 0.0) {
        char v47 = 1;
      }
      else {
        char v48 = 0;
      }
    }
    if (*((void *)v53 + 1563))
    {
      if (v53[12521])
      {
        v53[12521]  = CFXUpdateColorFade(*((void *)v53 + 1563), Current) & 1;
        if (v53[12521]) {
          char v48 = 0;
        }
      }
    }
    if (*((double *)v53 + 1524) > 0.0)
    {
      double v2 = CFAbsoluteTimeGetCurrent();
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)v53 + 1524, 0, v2);
      if (*((double *)v53 + 1524) > 0.0) {
        char v48 = 0;
      }
      float v41 = 0.0;
      float v41 = *((float *)v53 + 3053) * fmaxf(*((float *)v53 + 416), *((float *)v53 + 386));
      *((float *)v53 + 3027)  = v41;
      float v40 = _DisplayComputeEDRNitsCap((uint64_t)v53);
      SetLibEDRBrightness((uint64_t)v53, *((float *)v53 + 375), v40, *((float *)v53 + 298), *((float *)v53 + 3132));
      *((_DWORD *)v53 + 64)  = (int)(float)(*((float *)v53 + 3027) * 65536.0);
      char v46 = 1;
    }
    if (*((double *)v53 + 1576) > 0.0)
    {
      __DisplayFastEDRUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 12608));
      if (*((double *)v53 + 1576) > 0.0) {
        char v48 = 0;
      }
      char v46 = 1;
    }
    if (*((double *)v53 + 1582) > 0.0)
    {
      __DisplayRTPLCEDRUpdateFade((uint64_t)v53, (uint64_t)(v53 + 12656), Current);
      if (*((double *)v53 + 1582) > 0.0)
      {
        char v48 = 0;
        v53[12704]  = 1;
      }
      char v46 = 1;
    }
    if (v53[12712])
    {
      char v51 = 1;
      char v48 = 0;
    }
    if ((v53[321] & 1) != 0
      && (CBU_PassContrastEnhancerStrengthThroughSyncDBV() & 1) != 0
      && (v53[12248] & 1) != 0
      && *((double *)v53 + 1550) > 0.0)
    {
      double v3 = CFAbsoluteTimeGetCurrent();
      __DisplayFadeUpdateFactorFade((uint64_t)v53, (double *)v53 + 1550, 0, v3);
      *((float *)v53 + 3098)  = clamp(*((float *)v53 + 3105), *((float *)v53 + 3114), *((float *)v53 + 3115));
      if (*((double *)v53 + 1550) > 0.0) {
        char v48 = 0;
      }
      char v45 = 1;
    }
    if (*((void *)v53 + 33) && ([*((id *)v53 + 33) isDisplayRampRunning] & 1) != 0)
    {
      if (![+[CBAODState sharedInstance] isAODActive])char v48 = 0; {
      char v45 = 1;
      }
      int v39 = 0;
      if (_logHandle)
      {
        os_log_type_t v24 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v23 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v23 = init_default_corebrightness_log();
        }
        os_log_type_t v24 = v23;
      }
      int v39 = v24;
      char v38 = 2;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v21 = v39;
        os_log_type_t v22 = v38;
        __os_log_helper_16_0_0(v37);
        _os_log_debug_impl(&dword_1BA438000, v21, v22, "External ramp forced SyncDBV update", v37, 2u);
      }
    }
    if (*((double *)v53 + 105) > 0.0)
    {
      __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 840));
      *((float *)v53 + 208)  = _DisplayPerceptualLuminanceToLuminanceInternal((uint64_t)v53, *((float *)v53 + 215));
      if (*((double *)v53 + 105) <= 0.0) {
        *((_DWORD *)v53 + 208)  = 1120403456;
      }
      else {
        char v48 = 0;
      }
      char v51 = 1;
    }
    os_log_t v36 = 0;
    if (_logHandle)
    {
      float v20 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v19 = init_default_corebrightness_log();
      }
      float v20 = v19;
    }
    os_log_t v36 = v20;
    os_log_type_t v35 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_4_0_4_0_4_0_4_0((uint64_t)v56, v51 & 1, v47 & 1, v46 & 1, v45 & 1);
      _os_log_debug_impl(&dword_1BA438000, v36, v35, "Display fade callback: updateBrightness  = %d, updateVirtual  = %d, updateEDRHeadroom  = %d, forceSyncDBVUpdate  = %d", v56, 0x1Au);
    }
    if (v51 & 1) != 0 || (v47 & 1) != 0 || (v46 & 1) != 0 || (v45)
    {
      if (*((_DWORD *)v53 + 9))
      {
        *((float *)v53 + 98)  = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v53, *((float *)v53 + 100));
        *((float *)v53 + 114)  = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v53, *((float *)v53 + 116));
        float v18 = (float *)v53;
        float v4 = __DisplayCalculateBrightnessFromFactorChange((uint64_t)v53, *((_DWORD *)v53 + 51));
        __DisplaySetLogicalBrightnessLegacy(v18, 6u, v4, 0.0);
      }
      else
      {
        int v34 = 0;
        int v34 = *((_DWORD *)v53 + 332) | 1;
        if (v50) {
          v34 |= 0x3000u;
        }
        if (v47) {
          v34 |= 0x2000u;
        }
        if (v49) {
          v34 |= 0x3008u;
        }
        if ((v51 & 1) == 0) {
          v34 |= 0x4000u;
        }
        if (v46) {
          v34 |= 0x40u;
        }
        if (v45) {
          v34 |= 0x100u;
        }
        __DisplaySetLogicalBrightnessInternal(v53, v34, *((float *)v53 + 314));
      }
    }
    if ((v53[321] & 1) == 0 || (CBU_PassContrastEnhancerStrengthThroughSyncDBV() & 1) == 0)
    {
      if (v53[12282])
      {
        if ((v53[12248] & 1) != 0 && *((double *)v53 + 1550) > 0.0)
        {
          int v17 = v53;
          double v5 = CFAbsoluteTimeGetCurrent();
          __DisplayFadeUpdateFactorFade((uint64_t)v17, (double *)v53 + 1550, 0, v5);
          if (*((double *)v53 + 1550) > 0.0) {
            char v48 = 0;
          }
          __DisplaySetAAPFactor(v53, *((float *)v53 + 3105));
        }
      }
      else if ((v53[12248] & 1) != 0 && *((double *)v53 + 197) > 0.0)
      {
        __DisplayFadeUpdateFade(Current, (uint64_t)v53, (uint64_t)(v53 + 1576));
        *((float *)v53 + 393)  = _DisplayPerceptualLuminanceToReflectedLuminanceInternal((uint64_t)v53, *((float *)v53 + 399));
        if (*((double *)v53 + 197) > 0.0) {
          char v48 = 0;
        }
        __DisplayUpdateAAPFactor((uint64_t)v53);
      }
    }
    if (v48)
    {
      if (v53[321])
      {
        [*((id *)v53 + 26) pause];
      }
      else
      {
        dispatch_release(*((dispatch_object_t *)v53 + 1560));
        *((void *)v53 + 1560)  = 0;
      }
      uint64_t v33 = 0;
      if (_logHandle)
      {
        int v16 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v15 = init_default_corebrightness_log();
        }
        int v16 = v15;
      }
      uint64_t v33 = v16;
      os_signpost_type_t v32 = OS_SIGNPOST_EVENT;
      unint64_t v31 = 0xEEEEB0B5B2B2EEEELL;
      if (os_signpost_enabled(v16))
      {
        uint64_t v12 = v33;
        os_signpost_type_t v13 = v32;
        os_signpost_id_t spid = v31;
        __os_log_helper_16_0_0(v30);
        _os_signpost_emit_with_name_impl(&dword_1BA438000, v12, v13, spid, "DisplayFadeEndRamp", (const char *)&unk_1BA61B929, v30, 2u);
      }
      if ((v53[12248] & 1) != 0 && *((float *)v53 + 87) == 0.0)
      {
        os_log_t oslog = 0;
        if (_logHandle)
        {
          uint64_t v11 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v10 = init_default_corebrightness_log();
          }
          uint64_t v11 = v10;
        }
        os_log_t oslog = v11;
        os_log_type_t v28 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v8 = oslog;
          os_log_type_t v9 = v28;
          __os_log_helper_16_0_0(v27);
          _os_log_debug_impl(&dword_1BA438000, v8, v9, "Resetting AAP cache", v27, 2u);
        }
        *((_DWORD *)v53 + 3098)  = 0;
        *((_DWORD *)v53 + 392)  = 0;
        *((_DWORD *)v53 + 393)  = 0;
      }
      if (*((float *)v53 + 87) == 0.0 && *((float *)v53 + 3124) >= 0.0)
      {
        __DisplaySetBrightness((uint64_t)v53, *((_DWORD *)v53 + 3125), *((float *)v53 + 3124));
        *((float *)v53 + 3124)  = -1.0;
      }
      if (_logHandle)
      {
        int v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v6 = init_default_corebrightness_log();
        }
        int v7 = v6;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_5_8_32_8_0_8_0_8_0_8_0((uint64_t)v55, (uint64_t)"Unknown", COERCE__INT64(*((float *)v53 + 315)), COERCE__INT64(*((float *)v53 + 314)), COERCE__INT64(*((float *)v53 + 99)), COERCE__INT64(*((float *)v53 + 115)));
        _os_log_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: End ramp: Ldevice  = %f, Lcurrent  = %f, Lmin  = %f, Lmax  = %f", v55, 0x34u);
      }
    }
  }
}

void DisplaySetCabalFactorOverride(uint64_t a1, float a2)
{
  uint64_t v11 = a1;
  float v10 = a2;
  double v2 = *(NSObject **)(a1 + 144);
  double v3 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  uint64_t v6 = __DisplaySetCabalFactorOverride_block_invoke;
  int v7 = &__block_descriptor_44_e5_v8__0l;
  float v9 = a2;
  uint64_t v8 = v11;
  disp_dispatch_sync(v2, &v3);
}

void __DisplaySetCabalFactorOverride_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  float v4 = *(float *)(a1 + 40);
  if (v4 >= 0.0) {
    float v4 = (float)(clamp(*(float *)(a1 + 40), 1.0, 16.0) - 1.0) / 15.0;
  }
  *(float *)(*(void *)(a1 + 32) + 12468)  = v4;
  if (_logHandle)
  {
    double v2 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    double v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_2_8_32_8_0((uint64_t)v5, (uint64_t)"CabalFactorOverride", COERCE__INT64(v4));
    _os_log_impl(&dword_1BA438000, v2, OS_LOG_TYPE_DEFAULT, "%s  = %f\n", v5, 0x16u);
  }
  if (v4 >= 0.0) {
    __DisplaySetAAPFactor(*(unsigned char **)(a1 + 32), v4);
  }
}

void _DisplaySetBrightnessWeakCapWithFade(unsigned char *a1, char a2, float a3, float a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  os_log_t v44 = a1;
  float v43 = a3;
  float v42 = a4;
  char v41 = a2 & 1;
  if (a1[380]) {
    float v42 = *((float *)v44 + 94);
  }
  os_log_t v40 = 0;
  if (_logHandle)
  {
    uint64_t v21 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v21 = inited;
  }
  os_log_t v40 = v21;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v49, COERCE__INT64(v43), COERCE__INT64(v42));
    _os_log_debug_impl(&dword_1BA438000, v40, type, "max: %f fadePeriod: %f", v49, 0x16u);
  }
  if (v41)
  {
    *((float *)v44 + 131)  = v43;
    *((float *)v44 + 130)  = _DisplayLogicalToSliderBrightnessInternal((uint64_t)v44, v43);
    if (*((float *)v44 + 87) < 1.0) {
      float v42 = 0.0;
    }
  }
  else
  {
    v44[12080]  = 1;
  }
  *((double *)v44 + 74)  = v42;
  if (v42 == 0.0)
  {
    *((float *)v44 + 132)  = v43;
    float v38 = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)v44, v43);
    *((float *)v44 + 153)  = v38;
    *((float *)v44 + 154)  = v38;
    *((float *)v44 + 152)  = v38;
    __DisplaySetLogicalBrightnessInternal(v44, 12298, *((float *)v44 + 314));
    v44[584]  = 1;
    os_log_t oslog = 0;
    if (_logHandle)
    {
      uint64_t v19 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v18 = init_default_corebrightness_log();
      }
      uint64_t v19 = v18;
    }
    os_log_t oslog = v19;
    os_log_type_t v36 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      int v16 = oslog;
      os_log_type_t v17 = v36;
      __os_log_helper_16_0_0(v35);
      _os_log_debug_impl(&dword_1BA438000, v16, v17, "Weak cap: user interacted\n", v35, 2u);
    }
    os_log_t v34 = 0;
    if (_logHandle)
    {
      uint64_t v15 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v14 = init_default_corebrightness_log();
      }
      uint64_t v15 = v14;
    }
    os_log_t v34 = v15;
    os_log_type_t v33 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v48, (uint64_t)"Weak Cap", COERCE__INT64(v43), COERCE__INT64(*((float *)v44 + 315)));
      _os_log_impl(&dword_1BA438000, v34, v33, "[BRT update: %s]: Weak cap: %f, nits  = %f", v48, 0x20u);
    }
  }
  else
  {
    *((void *)v44 + 78)  = 0;
    *((void *)v44 + 79)  = 0;
    *((CFAbsoluteTime *)v44 + 75)  = CFAbsoluteTimeGetCurrent();
    os_log_t v32 = 0;
    if (_logHandle)
    {
      os_signpost_type_t v13 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v12 = init_default_corebrightness_log();
      }
      os_signpost_type_t v13 = v12;
    }
    os_log_t v32 = v13;
    os_log_type_t v31 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v47, *((void *)v44 + 74), *((void *)v44 + 75), *((void *)v44 + 1560));
      _os_log_debug_impl(&dword_1BA438000, v32, v31, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v47, 0x20u);
    }
    float v30 = 0.0;
    float v30 = (float)(v43 - *((float *)v44 + 132)) / v42;
    UpdateFrequency  = __DisplayGetUpdateFrequency((uint64_t)v44, v30);
    os_log_t v28 = 0;
    if (_logHandle)
    {
      uint64_t v11 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v10 = init_default_corebrightness_log();
      }
      uint64_t v11 = v10;
    }
    os_log_t v28 = v11;
    os_log_type_t v27 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v46, (uint64_t)"Weak Cap", COERCE__INT64(*((float *)v44 + 132)), COERCE__INT64(v43), COERCE__INT64(v42), COERCE__INT64(v30), COERCE__INT64(UpdateFrequency));
      _os_log_impl(&dword_1BA438000, v28, v27, "[BRT update: %s]: weak cap begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v46, 0x3Eu);
    }
    *((float *)v44 + 153)  = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)v44, *((float *)v44 + 132));
    *((_DWORD *)v44 + 154)  = *((_DWORD *)v44 + 153);
    *((float *)v44 + 152)  = _DisplayLuminanceToPerceptualLuminanceInternal((uint64_t)v44, v43);
    os_log_t v26 = 0;
    if (_logHandle)
    {
      float v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v8 = init_default_corebrightness_log();
      }
      float v9 = v8;
    }
    os_log_t v26 = v9;
    os_log_type_t v25 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v45, COERCE__INT64(*((float *)v44 + 132)), COERCE__INT64(v43), COERCE__INT64(*((float *)v44 + 154)), COERCE__INT64(*((float *)v44 + 152)));
      _os_log_debug_impl(&dword_1BA438000, v26, v25, "display->brightness.restriction.weakCap.Lcurrent=%f L=%f display->brightness.restriction.max.fade.Pstart=%f display->brightness.restriction.max.fade.Ptarget=%f\n", v45, 0x2Au);
    }
    __DisplayStartFade(v44, 1.0 / UpdateFrequency);
    v44[584]  = 1;
    os_log_t v24 = 0;
    if (_logHandle)
    {
      int v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v6 = init_default_corebrightness_log();
      }
      int v7 = v6;
    }
    os_log_t v24 = v7;
    os_log_type_t v23 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      float v4 = v24;
      os_log_type_t v5 = v23;
      __os_log_helper_16_0_0(v22);
      _os_log_debug_impl(&dword_1BA438000, v4, v5, "Weak cap: user interacted\n", v22, 2u);
    }
  }
}

void __DisplaySetBrightnessWithFade(uint64_t a1, unsigned int a2, float a3, float a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  float v10 = a3;
  *(float *)(a1 + 336)  = a3;
  if (*(_DWORD *)(a1 + 36))
  {
    __DisplayUpdateAmbientProperties(a1, a3);
    float v7 = __DisplayCalculateBrightnessAtAmbient((float *)a1, *(float *)(a1 + 1184));
    if (_logHandle)
    {
      os_log_type_t v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      os_log_type_t v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v12, COERCE__INT64(v10));
      _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "User Brightness Level=%f\n", v12, 0xCu);
    }
    __DisplaySetLogicalBrightnessLegacy((float *)a1, 0, v7, 0.0);
  }
  else
  {
    if (a3 >= *(float *)(a1 + 340))
    {
      if (a3 > *(float *)(a1 + 344)) {
        float v10 = *(float *)(a1 + 344);
      }
    }
    else
    {
      float v10 = *(float *)(a1 + 340);
    }
    float v6 = _DisplaySliderToLogicalBrightnessInternal(a1, v10);
    _DisplaySetLogicalBrightnessWithFade(a1, a2, 0, 0, v6, a4);
  }
}

void __DisplayReportCommit(NSObject **a1, float a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a1;
  float valuePtr = a2;
  *(_OWORD *)keys  = xmmword_1E621A7A8;
  values  = 0;
  uint64_t v15 = 0;
  values  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
  uint64_t v15 = *MEMORY[0x1E4F1CFD0];
  if (values)
  {
    CFAllocatorRef v2 = CFGetAllocator(v13);
    CFDictionaryRef v11 = CFDictionaryCreate(v2, (const void **)keys, (const void **)&values, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (v11)
    {
      double v3 = v13[18];
      uint64_t block = MEMORY[0x1E4F143A8];
      int v5 = -1073741824;
      int v6 = 0;
      float v7 = ____DisplayReportCommit_block_invoke;
      uint64_t v8 = &__block_descriptor_48_e5_v8__0l;
      float v9 = v13;
      CFDictionaryRef v10 = v11;
      dispatch_async(v3, &block);
    }
  }
  if (values) {
    CFRelease(values);
  }
}

uint64_t __os_log_helper_16_2_5_8_32_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 4;
  *(_DWORD *)(result + 44)  = a6;
  return result;
}

void _DisplaySetLogicalBrightnessWithFade(uint64_t a1, unsigned int a2, void (*a3)(uint64_t), uint64_t a4, float a5, float a6)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *(float *)(a1 + 1252)  = a5;
  *(double *)(a1 + 1336)  = a6;
  if (_logHandle)
  {
    CFDictionaryRef v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    CFDictionaryRef v10 = inited;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v17, COERCE__INT64(a5), COERCE__INT64(a6));
    _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "L=%f fadePeriod=%f\n", v17, 0x16u);
  }
  if (a6 == 0.0 || a5 == 0.0)
  {
    BOOL v8 = 0;
    if (*(double *)(a1 + 1384) != 0.0)
    {
      BOOL v8 = 0;
      if (*(float *)(a1 + 1400) > 0.0) {
        BOOL v8 = *(float *)(a1 + 1400) < 1.0;
      }
    }
    BOOL v7 = 0;
    if (*(double *)(a1 + 1384) == 0.0)
    {
      BOOL v7 = 0;
      if (*(float *)(a1 + 348) > 0.0) {
        BOOL v7 = *(float *)(a1 + 348) < 1.0;
      }
    }
    if (v8 || v7) {
      *(float *)(a1 + 1256)  = a5;
    }
    else {
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, a2 | 0x1000, 0, 0, a5, 0.0);
    }
    if (a3) {
      a3(a4);
    }
  }
  else if (a2 & 0x10) != 0 && (_DisplayRampIsRunning(a1))
  {
    *(float *)(a1 + 1352)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1252));
  }
  else
  {
    float v6 = *(double *)(a1 + 1336);
    __DisplaySetLogicalBrightnessWithFadeInternal(a1, a2, a3, a4, *(float *)(a1 + 1252), v6);
  }
}

uint64_t __DisplayGetPowerAccumulator(uint64_t a1)
{
  uint64_t v9 = a1;
  uint64_t v4 = 0;
  int v5 = &v4;
  int v6 = 0x20000000;
  int v7 = 32;
  unint64_t v8 = 0x8000000000000000;
  if (*(void *)(a1 + 12144))
  {
    if (*(void *)(v9 + 12136))
    {
      Samples  = (const void *)IOReportCreateSamples();
      if (Samples)
      {
        IOReportIterate();
        CFRelease(Samples);
      }
    }
  }
  uint64_t v2 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v2;
}

uint64_t __DisplaySetProperty_block_invoke_456(void *a1)
{
  uint64_t result = __DisplayGetPowerAccumulatorDCP(a1[6], (void *)(*(void *)(a1[5] + 8) + 24));
  *(void *)(*(void *)(a1[4] + 8) + 24)  = result;
  return result;
}

uint64_t __DisplayGetPowerAccumulatorDCP(uint64_t a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a1;
  os_log_t v26 = a2;
  os_log_type_t v25 = 0;
  if (_logHandle)
  {
    CFDictionaryRef v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    CFDictionaryRef v10 = inited;
  }
  os_log_type_t v25 = v10;
  char v24 = 1;
  unint64_t v23 = 0xEEEEB0B5B2B2EEEELL;
  if (os_signpost_enabled(v10))
  {
    os_log_t log = v25;
    os_signpost_type_t type = v24;
    os_signpost_id_t spid = v23;
    __os_log_helper_16_0_0(v22);
    _os_signpost_emit_with_name_impl(&dword_1BA438000, log, type, spid, "DisplayGetPowerAccumulatorDCP", (const char *)&unk_1BA61B929, v22, 2u);
  }
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  int v19 = 0x20000000;
  int v20 = 32;
  unint64_t v21 = 0x8000000000000000;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  int v14 = 0x20000000;
  int v15 = 32;
  uint64_t v16 = 0;
  if (*(void *)(v27 + 12144))
  {
    if (*(void *)(v27 + 12136))
    {
      Samples  = (const void *)IOReportCreateSamples();
      if (Samples)
      {
        IOReportIterate();
        CFRelease(Samples);
      }
    }
  }
  if (v26) {
    *os_log_t v26 = v13[3];
  }
  if (_logHandle)
  {
    int v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v4 = init_default_corebrightness_log();
    }
    int v5 = v4;
  }
  if (os_signpost_enabled(v5))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v28, v18[3]);
    _os_signpost_emit_with_name_impl(&dword_1BA438000, v5, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DisplayGetPowerAccumulatorDCP", "power accumulator  = %llu", v28, 0xCu);
  }
  uint64_t v3 = v18[3];
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v17, 8);
  return v3;
}

void sub_1BA5996D0()
{
  _Unwind_Resume(v0);
}

void _DisplaySetBrightness(uint64_t a1, float a2)
{
}

void __DisplaySetBrightness(uint64_t a1, unsigned int a2, float a3)
{
}

void _DisplaySetAdaptiveDimmingLimitWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a1 + 888)  = Current;
  if (*(unsigned char *)(a1 + 380)) {
    a3  = *(float *)(a1 + 376);
  }
  *(_DWORD *)(a1 + 832)  = *(_DWORD *)(a1 + 1260);
  uint64_t v3 = 0;
  if (!*(_DWORD *)(a1 + 228)) {
    uint64_t v3 = _DisplayAdaptiveDimmingLeftCallback;
  }
  *(void *)(a1 + 872)  = v3;
  *(void *)(a1 + 880)  = a1;
  *(double *)(a1 + 840)  = a3;
  *(CFAbsoluteTime *)(a1 + 848)  = Current;
  if (_logHandle)
  {
    int v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v5 = inited;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v10, COERCE__INT64(*(float *)(a1 + 1260)), COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "AutoDim begin ramp : %0.2f -> %0.2f t: %f", v10, 0x20u);
  }
  *(float *)(a1 + 860)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1260));
  *(_DWORD *)(a1 + 864)  = *(_DWORD *)(a1 + 860);
  *(float *)(a1 + 856)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
  __DisplayStartFade((unsigned char *)a1, 0.016667);
}

float __DisplayCalculateBrightnessAtAmbient(float *a1, float a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  float v6 = a2;
  if (a2 >= 0.0)
  {
    if (a2 > 1.0) {
      float v6 = 1.0;
    }
  }
  else
  {
    float v6 = 0.0;
  }
  float v5 = a1[303] + (float)(a1[302] * v6);
  if (_logHandle)
  {
    uint64_t v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v8, COERCE__INT64(v6), COERCE__INT64(a1[302]), COERCE__INT64(a1[303]), COERCE__INT64(a1[84]), COERCE__INT64(v5));
    _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "ambient=%f slope=%f intercept=%f user=%f brightness=%f\n", v8, 0x34u);
  }
  if (v5 > a1[86]) {
    return a1[86];
  }
  if (v5 < a1[85]) {
    return a1[85];
  }
  return v5;
}

void __DisplaySetLogicalBrightnessLegacy(float *a1, mach_port_t a2, float a3, double a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  float v17 = a3;
  double v16 = a4;
  char v14 = 0;
  if (a3 >= a1[85])
  {
    if (a3 > a1[86]) {
      float v17 = a1[86];
    }
  }
  else
  {
    float v17 = a1[85];
  }
  if (v17 <= a1[114])
  {
    if (v17 < a1[98]) {
      float v17 = a1[98];
    }
  }
  else
  {
    float v17 = a1[114];
  }
  if (a4 == -1.0)
  {
    float v4 = fabs((float)(a1[88] - v17));
    float v13 = v4;
    double v16 = (float)(a1[306] + (float)(a1[305] * v4));
    if (_logHandle)
    {
      uint64_t v11 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v11 = inited;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v21, COERCE__INT64(a1[305]), COERCE__INT64(a1[306]), COERCE__INT64((float)(v13 * 64.0)), *(uint64_t *)&v16, COERCE__INT64(v16 / (float)(v13 * 64.0)));
      _os_log_debug_impl(&dword_1BA438000, v11, OS_LOG_TYPE_DEBUG, "slope=%f intercept=%f delta=%f fadePeriod=%f steptime=%f\n", v21, 0x34u);
    }
    if (v16 <= 0.0) {
      double v16 = -1.0;
    }
    char v14 = 1;
  }
  if (_logHandle)
  {
    uint64_t v9 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v8 = init_default_corebrightness_log();
    }
    uint64_t v9 = v8;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_4_0((uint64_t)v20, COERCE__INT64(v17), *(uint64_t *)&v16, (a2 & 1) != 0);
    _os_log_debug_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEBUG, "brightness=%f fadePeriod=%f block=%d\n", v20, 0x1Cu);
  }
  if (!v14 || a1[87] == 1.0)
  {
    a1[88]  = v17;
    __DisplaySetPhysicalBrightnessLegacy(a1, a2, v17, v16);
  }
  else
  {
    float v5 = (float)(a1[88] * a1[87]) + 0.01;
    float v12 = v5;
    if (v17 >= v5) {
      a1[89]  = v17;
    }
    else {
      a1[89]  = v5;
    }
    if (_logHandle)
    {
      int v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v6 = init_default_corebrightness_log();
      }
      int v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v19, COERCE__INT64(a1[88]), COERCE__INT64(a1[87]), COERCE__INT64(a1[89]), COERCE__INT64(v17), COERCE__INT64(v12));
      _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "logical=%f factor=%f pending=%f brightness=%f minPendingBrightness=%f\n", v19, 0x34u);
    }
  }
}

uint64_t setClientOverrideState(uint64_t result, char a2, char a3)
{
  *(unsigned char *)(result + 960)  = *(unsigned char *)(result + 960) & ~(1 << a2) | ((a3 & 1) << a2);
  return result;
}

uint64_t evaluateClientOverrides(uint64_t a1)
{
  ClientOverrideState  = getClientOverrideState(a1, 0);
  BOOL v2 = getClientOverrideState(a1, 1);
  if (ClientOverrideState)
  {
    if (*(float *)(a1 + 964) >= *(float *)(a1 + 400)) {
      return 0;
    }
    else {
      return 2;
    }
  }
  else if (v2)
  {
    return 1;
  }
  else
  {
    return 3;
  }
}

void _DisplaySetBrightnessMinPhysicalWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a3  = *(float *)(a1 + 376);
  }
  float v18 = fmaxf(a2, *(float *)(a1 + 1320));
  if (_logHandle)
  {
    char v14 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    char v14 = inited;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v27, COERCE__INT64(v18), COERCE__INT64(a3));
    _os_log_impl(&dword_1BA438000, v14, OS_LOG_TYPE_DEFAULT, "min: %f fadePeriod: %f", v27, 0x16u);
  }
  if (v18 != *(float *)(a1 + 396))
  {
    *(float *)(a1 + 396)  = v18;
    *(float *)(a1 + 392)  = _DisplayLogicalToSliderBrightnessInternal(a1, v18);
    *(double *)(a1 + 408)  = a3;
    if (a3 == 0.0)
    {
      *(float *)(a1 + 400)  = v18;
      if (*(_DWORD *)(a1 + 36))
      {
        _DisplaySetAmbient(a1, 0, *(float *)(a1 + 1184));
      }
      else
      {
        float v17 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, v18);
        *(float *)(a1 + 428)  = v17;
        *(float *)(a1 + 432)  = v17;
        *(float *)(a1 + 424)  = v17;
        __DisplaySetLogicalBrightnessInternal((const void *)a1, 12290, *(float *)(a1 + 1256));
        if (_logHandle)
        {
          float v12 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v11 = init_default_corebrightness_log();
          }
          float v12 = v11;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v26, (uint64_t)"Min cap", COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 1260)));
          _os_log_impl(&dword_1BA438000, v12, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: Min brightness: %f, nits  = %f", v26, 0x20u);
        }
      }
    }
    else
    {
      *(void *)(a1 + 440)  = 0;
      *(void *)(a1 + 448)  = 0;
      *(CFAbsoluteTime *)(a1 + 416)  = CFAbsoluteTimeGetCurrent();
      if (_logHandle)
      {
        CFDictionaryRef v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v9 = init_default_corebrightness_log();
        }
        CFDictionaryRef v10 = v9;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v25, *(void *)(a1 + 408), *(void *)(a1 + 416), *(void *)(a1 + 12480));
        _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v25, 0x20u);
      }
      float v16 = (float)(v18 - *(float *)(a1 + 400)) / a3;
      UpdateFrequency  = __DisplayGetUpdateFrequency(a1, v16);
      if (_logHandle)
      {
        uint64_t v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v7 = init_default_corebrightness_log();
        }
        uint64_t v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v24, COERCE__INT64(*(float *)(a1 + 400)), COERCE__INT64(v18), COERCE__INT64(a3), COERCE__INT64(v16), COERCE__INT64(UpdateFrequency));
        _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "MIN begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v24, 0x34u);
      }
      if (_logHandle)
      {
        uint64_t v6 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v5 = init_default_corebrightness_log();
        }
        uint64_t v6 = v5;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v23, (uint64_t)"Min cap", COERCE__INT64(*(float *)(a1 + 400)), COERCE__INT64(v18), COERCE__INT64(a3), COERCE__INT64(v16), COERCE__INT64(UpdateFrequency));
        _os_log_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: MIN begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v23, 0x3Eu);
      }
      *(float *)(a1 + 428)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 400));
      *(_DWORD *)(a1 + 432)  = *(_DWORD *)(a1 + 428);
      *(float *)(a1 + 424)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, v18);
      if (_logHandle)
      {
        float v4 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v3 = init_default_corebrightness_log();
        }
        float v4 = v3;
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v22, COERCE__INT64(*(float *)(a1 + 400)), COERCE__INT64(v18), COERCE__INT64(*(float *)(a1 + 432)), COERCE__INT64(*(float *)(a1 + 424)));
        _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "display->brightness.restriction.min.Lcurrent=%f L=%f display->brightness.restriction.min.fade.Pstart=%f display->brightness.restriction.min.fade.Ptarget=%f\n", v22, 0x2Au);
      }
      __DisplayStartFade((unsigned char *)a1, 1.0 / UpdateFrequency);
    }
  }
}

void _DisplaySetAmbient(uint64_t a1, char a2, float a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a3 >= 0.0 && a3 <= 1.0)
  {
    if (*(float *)(a1 + 348) == 1.0)
    {
      if (a2) {
        *(_DWORD *)(a1 + 1220)  = *(_DWORD *)(a1 + 1228);
      }
      else {
        *(float *)(a1 + 1220)  = 1.5;
      }
      *(_DWORD *)(a1 + 1224)  = 0;
    }
    *(float *)(a1 + 1184)  = a3;
    if (_logHandle)
    {
      uint64_t v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v6 = inited;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v11, COERCE__INT64(*(float *)(a1 + 1220)), COERCE__INT64(*(float *)(a1 + 1224)));
      _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "ALS: slope=%f intercept=%f \n", v11, 0x16u);
    }
    float v7 = __DisplayCalculateBrightnessAtAmbient((float *)a1, a3);
    if (_logHandle)
    {
      float v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v3 = init_default_corebrightness_log();
      }
      float v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v10, COERCE__INT64(v7));
      _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "Brightness For Ambient Level=%f\n", v10, 0xCu);
    }
    __DisplaySetLogicalBrightnessLegacy((float *)a1, 2u, v7, -1.0);
  }
}

void _DisplaySetBrightnessEcoModeFactorWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a3  = *(float *)(a1 + 376);
  }
  if (_logHandle)
  {
    uint64_t v11 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v11 = inited;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v18, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_debug_impl(&dword_1BA438000, v11, OS_LOG_TYPE_DEBUG, "factor: %f fadePeriod: %f", v18, 0x16u);
  }
  if (a2 != *(float *)(a1 + 648))
  {
    if (a3 == 0.0)
    {
      *(float *)(a1 + 648)  = a2;
      *(float *)(a1 + 684)  = a2;
      *(float *)(a1 + 688)  = a2;
      *(float *)(a1 + 680)  = a2;
      *(void *)(a1 + 664)  = 0;
      float v3 = 0.5 * (float)(*(float *)(a1 + 648) - 0.8) / 0.199999988 + 0.5;
      _DisplayReduceBacklightCompensation(a1, v3);
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, 12288, 0, 0, *(float *)(a1 + 1252), 0.0);
    }
    else
    {
      *(void *)(a1 + 704)  = 0;
      *(void *)(a1 + 712)  = 0;
      *(double *)(a1 + 664)  = a3;
      *(CFAbsoluteTime *)(a1 + 672)  = CFAbsoluteTimeGetCurrent();
      if (_logHandle)
      {
        uint64_t v9 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v8 = init_default_corebrightness_log();
        }
        uint64_t v9 = v8;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v17, *(void *)(a1 + 664), *(void *)(a1 + 672), *(void *)(a1 + 12480));
        _os_log_debug_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v17, 0x20u);
      }
      if (_logHandle)
      {
        float v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v6 = init_default_corebrightness_log();
        }
        float v7 = v6;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v16, COERCE__INT64(*(float *)(a1 + 648)), COERCE__INT64(a2), COERCE__INT64(a3), 0x404E000000000000);
        _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "EcoModeFactor begin ramp Factor: %0.2f -> Factor: %0.2f t: %f rate: %0.2fhz", v16, 0x2Au);
      }
      *(_DWORD *)(a1 + 684)  = *(_DWORD *)(a1 + 648);
      *(_DWORD *)(a1 + 688)  = *(_DWORD *)(a1 + 648);
      *(float *)(a1 + 680)  = a2;
      __DisplayStartFade((unsigned char *)a1, 0.016667);
    }
  }
  if (_logHandle)
  {
    uint64_t v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v4 = init_default_corebrightness_log();
    }
    uint64_t v5 = v4;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v15, (uint64_t)"Eco Mode", COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: factor  = %f, fadePeriod  = %f", v15, 0x20u);
  }
}

void _DisplaySetBrightnessEcoModeLimitWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a3  = *(float *)(a1 + 376);
  }
  *(_DWORD *)(a1 + 780)  = *(_DWORD *)(a1 + 1260);
  *(void *)(a1 + 816)  = 0;
  *(void *)(a1 + 824)  = 0;
  *(double *)(a1 + 784)  = a3;
  *(CFAbsoluteTime *)(a1 + 792)  = CFAbsoluteTimeGetCurrent();
  if (_logHandle)
  {
    uint64_t v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v11, COERCE__INT64(*(float *)(a1 + 1260)), COERCE__INT64(a2), COERCE__INT64(a3), 0x404E000000000000);
    _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "EcoModeLimit begin ramp : %0.2f -> %0.2f t: %f rate: %0.2fhz", v11, 0x2Au);
  }
  *(float *)(a1 + 804)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1260));
  *(_DWORD *)(a1 + 808)  = *(_DWORD *)(a1 + 804);
  *(float *)(a1 + 800)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
  __DisplayStartFade((unsigned char *)a1, 0.016667);
  if (_logHandle)
  {
    uint64_t v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v3 = init_default_corebrightness_log();
    }
    uint64_t v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v10, (uint64_t)"Eco Mode", COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: target  = %f, fadePeriod  = %f", v10, 0x20u);
  }
}

void _DisplaySetBrightnessDominoModeLimitWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 760)  = 0;
  *(void *)(a1 + 768)  = 0;
  *(double *)(a1 + 728)  = a3;
  *(CFAbsoluteTime *)(a1 + 736)  = CFAbsoluteTimeGetCurrent();
  if (_logHandle)
  {
    uint64_t v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v11, COERCE__INT64(*(float *)(a1 + 724)), COERCE__INT64(a2), COERCE__INT64(a3), 0x404E000000000000);
    _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "DominoModeLimit begin ramp : %0.2f -> %0.2f t: %f rate: %0.2fhz", v11, 0x2Au);
  }
  *(float *)(a1 + 748)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 724));
  *(_DWORD *)(a1 + 752)  = *(_DWORD *)(a1 + 748);
  *(float *)(a1 + 744)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
  __DisplayStartFade((unsigned char *)a1, 0.016667);
  if (_logHandle)
  {
    uint64_t v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v3 = init_default_corebrightness_log();
    }
    uint64_t v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v10, (uint64_t)"Domino Mode", COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: target  = %f, fadePeriod  = %f", v10, 0x20u);
  }
}

double __DisplayCancelFactorFade(uint64_t a1)
{
  uint64_t v9 = a1;
  if (_DisplayRampIsRunning(a1))
  {
    uint64_t v8 = 0;
    if (_logHandle)
    {
      uint64_t v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v5 = inited;
    }
    uint64_t v8 = v5;
    char v7 = 2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      os_log_t log = v8;
      os_log_type_t type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_debug_impl(&dword_1BA438000, log, type, "cancel factor ramp", v6, 2u);
    }
    *(_DWORD *)(v9 + 88)  = 0;
    if (*(void *)(v9 + 1424)) {
      (*(void (**)(void))(v9 + 1424))(*(void *)(v9 + 1376));
    }
    double result = 0.0;
    *(void *)(v9 + 1384)  = 0;
  }
  return result;
}

void _DisplayUpdateWeakCapOnFactorChange(uint64_t a1, float a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a1;
  float v25 = a2;
  if (*(float *)(a1 + 348) < 1.0 && v25 == 1.0)
  {
    if (*(float *)(v26 + 524) < *(float *)(v26 + 1312) && *(float *)(v26 + 528) > *(float *)(v26 + 524))
    {
      double Current = CFAbsoluteTimeGetCurrent();
      double v23 = 0.0;
      float v2 = Current - *(double *)(v26 + 536) - *(double *)(v26 + 544);
      double v23 = fmaxf(v2, 0.0);
      double v22 = 0.0;
      double v22 = *(double *)(v26 + 552) - *(double *)(v26 + 544);
      float v3 = v23;
      float v4 = v22;
      double v23 = fminf(v3, v4);
      float v5 = v23 / v22;
      float v21 = v5 * (float)(*(float *)(v26 + 528) - *(float *)(v26 + 524));
      *(float *)(v26 + 528)  = *(float *)(v26 + 528) - v21;
      *(void *)(v26 + 592)  = 0;
      float v20 = 0.0;
      float v20 = _DisplayLuminanceToPerceptualLuminanceInternal(v26, *(float *)(v26 + 528));
      *(float *)(v26 + 612)  = v20;
      *(float *)(v26 + 616)  = v20;
      *(float *)(v26 + 608)  = v20;
      os_log_t v19 = 0;
      if (_logHandle)
      {
        uint64_t v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v11 = inited;
      }
      os_log_t v19 = v11;
      os_log_type_t v18 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v27, COERCE__INT64(*(float *)(v26 + 528)));
        _os_log_debug_impl(&dword_1BA438000, v19, v18, "Display: Update weak cap to %f on factor change", v27, 0xCu);
      }
      *(double *)(v26 + 576)  = Current;
    }
  }
  else if (*(float *)(v26 + 348) == 1.0 && v25 < 1.0)
  {
    char v17 = 0;
    char v17 = *(unsigned char *)(v26 + 584) & 1;
    double v16 = CFAbsoluteTimeGetCurrent();
    if (v16 - *(double *)(v26 + 576) > *(double *)(v26 + 560)) {
      char v17 = 1;
    }
    if (v17)
    {
      *(double *)(v26 + 536)  = v16;
      *(unsigned char *)(v26 + 584)  = 0;
      os_log_t oslog = 0;
      if (_logHandle)
      {
        uint64_t v9 = _logHandle;
      }
      else
      {
        uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        uint64_t v9 = v8;
      }
      os_log_t oslog = v9;
      os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v6 = oslog;
        os_log_type_t v7 = v14;
        __os_log_helper_16_0_0(v13);
        _os_log_debug_impl(&dword_1BA438000, v6, v7, "Weak cap: Resetting timer\n", v13, 2u);
      }
    }
    if (*(float *)(v26 + 524) < *(float *)(v26 + 1312))
    {
      *(void *)(v26 + 592)  = 0;
      float v12 = _DisplayLuminanceToPerceptualLuminanceInternal(v26, *(float *)(v26 + 528));
      *(float *)(v26 + 612)  = v12;
      *(float *)(v26 + 616)  = v12;
      *(float *)(v26 + 608)  = v12;
    }
  }
}

void _DisplaySetBrightnessFactor(uint64_t a1, float a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v51 = a1;
  float v50 = a2;
  int v49 = a2 > 0.0;
  if (*(_DWORD *)(a1 + 44) != v49)
  {
    if (*(_DWORD *)(v51 + 44) || v49 != 1)
    {
      if (*(_DWORD *)(v51 + 44) == 1 && !v49)
      {
        if (*(void *)(v51 + 328)
          && ([*(id *)(v51 + 328) isActive] & 1) != 0
          && ![*(id *)(v51 + 328) action:0])
        {
          os_log_t v44 = (void *)[objc_alloc(NSNumber) initWithInt:0];
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v51 + 192), @"CBSoftWakeActive", v44);
        }
        double v43 = 0.0;
        double v43 = (double)mach_absolute_time() * *(double *)(v51 + 56);
        CFNumberRef v42 = 0;
        CFNumberRef v42 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &v43);
        if (v42)
        {
          if (*(void *)(v51 + 192)) {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v51 + 192), @"EventTimestampDisplayOff", v42);
          }
          os_log_t v41 = 0;
          if (_logHandle)
          {
            os_log_type_t v14 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t inited = init_default_corebrightness_log();
            }
            os_log_type_t v14 = inited;
          }
          os_log_t v41 = v14;
          os_log_type_t v40 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_0_1_8_0((uint64_t)v52, *(uint64_t *)&v43);
            _os_log_impl(&dword_1BA438000, v41, v40, "ts=%f Setting kCBEventTimestampDisplayOffKey", v52, 0xCu);
          }
          CFRelease(v42);
        }
        _DisplayResetAdaptiveDimming(v51);
      }
    }
    else
    {
      double v48 = 0.0;
      double v48 = (double)mach_absolute_time() * *(double *)(v51 + 56);
      CFNumberRef v47 = 0;
      CFNumberRef v47 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &v48);
      if (v47)
      {
        if (*(void *)(v51 + 192)) {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v51 + 192), @"EventTimestampDisplayOn", v47);
        }
        os_log_t v46 = 0;
        if (_logHandle)
        {
          double v16 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v15 = init_default_corebrightness_log();
          }
          double v16 = v15;
        }
        os_log_t v46 = v16;
        os_log_type_t v45 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v53, *(uint64_t *)&v48);
          _os_log_impl(&dword_1BA438000, v46, v45, "ts=%f Setting kCBEventTimestampDisplayOnKey", v53, 0xCu);
        }
        CFRelease(v47);
      }
      if ((DisplayHasDCP(v51) & 1) != 0 && *(_DWORD *)(v51 + 108))
      {
        __memset_chk();
        *(_DWORD *)(v51 + 12732)  = 0;
        *(_DWORD *)(v51 + 12728)  = 0;
        *(float *)(v51 + 12940)  = -1.0;
      }
    }
    *(_DWORD *)(v51 + 44)  = v49;
    if (*(void *)(v51 + 144))
    {
      float v2 = *(NSObject **)(v51 + 144);
      uint64_t block = MEMORY[0x1E4F143A8];
      int v35 = -1073741824;
      int v36 = 0;
      uint64_t v37 = ___DisplaySetBrightnessFactor_block_invoke;
      float v38 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v39 = v51;
      dispatch_async(v2, &block);
    }
    if (*(void *)(v51 + 192))
    {
      CFMutableDictionaryRef theDict = *(__CFDictionary **)(v51 + 192);
      if (*(_DWORD *)(v51 + 44)) {
        CFDictionarySetValue(theDict, @"DisplayOn", (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      else {
        CFDictionarySetValue(theDict, @"DisplayOn", (const void *)*MEMORY[0x1E4F1CFC8]);
      }
    }
    uint64_t v33 = v49;
    float v3 = *(NSObject **)(v51 + 168);
    uint64_t v26 = MEMORY[0x1E4F143A8];
    int v27 = -1073741824;
    int v28 = 0;
    uint64_t v29 = ___DisplaySetBrightnessFactor_block_invoke_2;
    float v30 = &__block_descriptor_48_e5_v8__0l;
    uint64_t v31 = v51;
    uint64_t v32 = v49;
    dispatch_async(v3, &v26);
  }
  if (*(float *)(v51 + 348) == 0.0 && v50 > 0.0) {
    __DisplayInitializeReport(v51);
  }
  *(float *)(v51 + 348)  = v50;
  if (*(float *)(v51 + 348) == 0.0)
  {
    if (*(unsigned char *)(v51 + 232))
    {
      os_log_t oslog = 0;
      if (_logHandle)
      {
        uint64_t v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v10 = init_default_corebrightness_log();
        }
        uint64_t v11 = v10;
      }
      os_log_t oslog = v11;
      os_log_type_t v24 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v8 = oslog;
        os_log_type_t v9 = v24;
        __os_log_helper_16_0_0(v23);
        _os_log_debug_impl(&dword_1BA438000, v8, v9, "Pre-strobe OFF (display off) \n", v23, 2u);
      }
      *(unsigned char *)(v51 + 232)  = 0;
    }
    if (!getClientOverrideState(v51, 1))
    {
      *(_DWORD *)(v51 + 392)  = 0;
      int v4 = *(_DWORD *)(v51 + 1320);
      *(_DWORD *)(v51 + 396)  = v4;
      *(_DWORD *)(v51 + 400)  = v4;
    }
    if (*(_DWORD *)(v51 + 32))
    {
      if (*(float *)(v51 + 1204) > 0.0)
      {
        *(_DWORD *)(v51 + 1252)  = *(_DWORD *)(v51 + 1320);
        *(_DWORD *)(v51 + 1492)  = *(_DWORD *)(v51 + 1320);
      }
    }
    *(unsigned char *)(v51 + 12522)  = 0;
    float v5 = *(NSObject **)(v51 + 144);
    uint64_t v17 = MEMORY[0x1E4F143A8];
    int v18 = -1073741824;
    int v19 = 0;
    float v20 = ___DisplaySetBrightnessFactor_block_invoke_748;
    float v21 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v22 = v51;
    dispatch_async(v5, &v17);
    int v6 = *(_DWORD *)(v51 + 1080);
    *(_DWORD *)(v51 + 1084)  = v6;
    *(_DWORD *)(v51 + 1056)  = v6;
    *(void *)(v51 + 1064)  = 0;
    int v7 = *(_DWORD *)(v51 + 1008);
    *(_DWORD *)(v51 + 1012)  = v7;
    *(_DWORD *)(v51 + 984)  = v7;
    *(void *)(v51 + 992)  = 0;
    __DisplayCommitReport(v51, 1);
  }
}

float __DisplayCalculateBrightnessFromFactorChange(uint64_t a1, int a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    int v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v8, COERCE__INT64(*(float *)(a1 + 348)), COERCE__INT64(*(float *)(a1 + 356)));
    _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "Brightness factor=%f pending=%f\n", v8, 0x16u);
  }
  if (*(float *)(a1 + 348) == 1.0 && *(float *)(a1 + 356) != 0.0) {
    *(_DWORD *)(a1 + 352)  = *(_DWORD *)(a1 + 356);
  }
  if (a2) {
    return *(float *)(a1 + 352);
  }
  else {
    return __DisplayCalculateBrightnessAtAmbient((float *)a1, *(float *)(a1 + 1184));
  }
}

double __DisplayCancelReflectedBrightnessFadeInternal(uint64_t a1)
{
  uint64_t v9 = a1;
  if (*(unsigned char *)(a1 + 12248) & 1) != 0 && (_DisplayRampIsRunning(v9))
  {
    uint64_t v8 = 0;
    if (_logHandle)
    {
      float v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v5 = inited;
    }
    uint64_t v8 = v5;
    char v7 = 2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      os_log_t log = v8;
      os_log_type_t type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_debug_impl(&dword_1BA438000, log, type, "cancel AAP ramp", v6, 2u);
    }
    if ((*(unsigned char *)(v9 + 12282) & 1) == 0) {
      __DisplayUpdateAAPFactor(v9);
    }
    if (*(void *)(v9 + 1608)) {
      (*(void (**)(void))(v9 + 1608))(*(void *)(v9 + 1616));
    }
    double result = 0.0;
    *(void *)(v9 + 1576)  = 0;
  }
  return result;
}

double __DisplayCancelAAPFade(unsigned char *a1)
{
  uint64_t v9 = a1;
  if (a1[12248] & 1) != 0 && (_DisplayRampIsRunning((uint64_t)v9))
  {
    uint64_t v8 = 0;
    if (_logHandle)
    {
      float v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v5 = inited;
    }
    uint64_t v8 = v5;
    char v7 = 2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      os_log_t log = v8;
      os_log_type_t type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_debug_impl(&dword_1BA438000, log, type, "cancel AAP ramp", v6, 2u);
    }
    __DisplaySetAAPFactor(v9, 0.0);
    if (*((void *)v9 + 1555)) {
      (*((void (**)(void))v9 + 1555))(*((void *)v9 + 1556));
    }
    double result = 0.0;
    *((void *)v9 + 1550)  = 0;
  }
  return result;
}

void __DisplaySetLogicalBrightnessWithFadeInternal(uint64_t a1, int a2, uint64_t a3, uint64_t a4, float a5, float a6)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a6  = *(float *)(a1 + 376);
  }
  if (a6 == 0.0)
  {
    float v12 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1256));
    *(void *)(a1 + 1336)  = 0;
    *(float *)(a1 + 1356)  = v12;
    *(float *)(a1 + 1360)  = v12;
    *(float *)(a1 + 1352)  = v12;
    __DisplaySetLogicalBrightnessInternal((const void *)a1, a2 | 0x1000, a5);
  }
  else
  {
    *(_DWORD *)(a1 + 1328)  = a2;
    *(void *)(a1 + 1368)  = a3;
    *(void *)(a1 + 1376)  = a4;
    *(CFAbsoluteTime *)(a1 + 1344)  = CFAbsoluteTimeGetCurrent();
    *(double *)(a1 + 1336)  = a6;
    if (_logHandle)
    {
      uint64_t v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v9 = inited;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v18, *(void *)(a1 + 1336), *(void *)(a1 + 1344), *(void *)(a1 + 12480));
      _os_log_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEFAULT, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v18, 0x20u);
    }
    float v11 = (float)(a5 - *(float *)(a1 + 1256)) / a6;
    UpdateFrequency  = __DisplayGetUpdateFrequency(a1, v11);
    *(float *)(a1 + 1356)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1256));
    *(_DWORD *)(a1 + 1360)  = *(_DWORD *)(a1 + 1356);
    *(float *)(a1 + 1352)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a5);
    if (_logHandle)
    {
      char v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v6 = init_default_corebrightness_log();
      }
      char v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v17, COERCE__INT64(*(float *)(a1 + 1256)), COERCE__INT64(a5), COERCE__INT64(*(float *)(a1 + 1360)), COERCE__INT64(*(float *)(a1 + 1352)), COERCE__INT64(a6), COERCE__INT64(v11), COERCE__INT64(UpdateFrequency));
      _os_log_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEFAULT, "begin ramping L: %0.2f -> L: %0.2f Brightness: %f -> %f t: %f rate: %0.2f nits/s %0.2fhz", v17, 0x48u);
    }
    if ((a2 & 0x80u) != 0) {
      UpdateFrequency  = 120.0;
    }
    __DisplayStartFade((unsigned char *)a1, 1.0 / UpdateFrequency);
  }
}

void _DisplaySetFactorWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a3  = *(float *)(a1 + 376);
  }
  if (_logHandle)
  {
    uint64_t v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v16, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEFAULT, "factor: %f fadePeriod: %f", v16, 0x16u);
  }
  if (a2 != *(float *)(a1 + 348) || *(double *)(a1 + 1384) > 0.0)
  {
    if ((*(unsigned char *)(a1 + 12282) & 1) == 0) {
      *(_DWORD *)(a1 + 12392)  = 0;
    }
    *(void *)(a1 + 96)  = 0;
    if (a3 == 0.0)
    {
      _DisplaySetBrightnessFactor(a1, a2);
      *(float *)(a1 + 1404)  = a2;
      *(float *)(a1 + 1408)  = a2;
      *(float *)(a1 + 1400)  = a2;
      *(void *)(a1 + 1384)  = 0;
      float v10 = *(float *)(a1 + 1252);
      *(_DWORD *)(a1 + 1488)  = *(_DWORD *)(a1 + 1492);
      int v9 = 4098;
      if (*(float *)(a1 + 348) == 1.0) {
        int v9 = 4106;
      }
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, v9 | 0x2000, 0, 0, v10, 0.0);
    }
    else
    {
      *(void *)(a1 + 1424)  = 0;
      *(void *)(a1 + 1432)  = 0;
      *(double *)(a1 + 1384)  = a3;
      *(CFAbsoluteTime *)(a1 + 1392)  = CFAbsoluteTimeGetCurrent();
      if (_logHandle)
      {
        uint64_t v6 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v5 = init_default_corebrightness_log();
        }
        uint64_t v6 = v5;
      }
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v15, *(void *)(a1 + 1384), *(void *)(a1 + 1392), *(void *)(a1 + 12480));
        _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v15, 0x20u);
      }
      if (_logHandle)
      {
        int v4 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v3 = init_default_corebrightness_log();
        }
        int v4 = v3;
      }
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v14, COERCE__INT64(*(float *)(a1 + 348)), COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(60.0));
        _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "FACTOR begin ramp Factor: %0.2f -> Factor: %0.2f t: %f rate: %0.2fhz", v14, 0x2Au);
      }
      *(_DWORD *)(a1 + 1404)  = *(_DWORD *)(a1 + 348);
      *(_DWORD *)(a1 + 1408)  = *(_DWORD *)(a1 + 348);
      *(float *)(a1 + 1400)  = a2;
      __DisplayStartFade((unsigned char *)a1, 1.0 / 60.0);
    }
  }
}

void __DisplaySendPLCUpdate(uint64_t a1, char a2)
{
  char v3 = a2 & 1;
  if (a2) {
    float v2 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    float v2 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  if ((a2 & 1) == 1)
  {
    if (*(void *)(a1 + 16)) {
      (*(void (**)(void, __CFString *, const void *))(a1 + 16))(*(void *)(a1 + 24), @"nitsExceedsPLCThreshold", v2);
    }
    if (*(_DWORD *)(a1 + 108)) {
      IORegistryEntrySetCFProperty(*(_DWORD *)(a1 + 108), @"enablePLCMode", v2);
    }
    __DisplaySetBLDriverProperty(a1, @"plc-update", v2);
  }
  else
  {
    __DisplaySetBLDriverProperty(a1, @"plc-update", v2);
    if (*(_DWORD *)(a1 + 108)) {
      IORegistryEntrySetCFProperty(*(_DWORD *)(a1 + 108), @"enablePLCMode", v2);
    }
    if (*(void *)(a1 + 16)) {
      (*(void (**)(void, __CFString *, const void *))(a1 + 16))(*(void *)(a1 + 24), @"nitsExceedsPLCThreshold", v2);
    }
  }
  *(unsigned char *)(a1 + 289)  = v3 & 1;
}

void SetBLDriverNitsValueIfNotInLPM(uint64_t a1, int a2)
{
  if ((*(unsigned char *)(a1 + 1504) & 1) == 0) {
    SetBLDriverNitsValue((float *)a1, a2);
  }
  *(_DWORD *)(a1 + 1508)  = a2;
}

void __DisplaySetProperty_block_invoke_592(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 16)) {
    (*(void (**)(void, __CFString *, void))(*(void *)(a1 + 32) + 16))(*(void *)(*(void *)(a1 + 32) + 24), @"BrightnessCLTMMode", *(void *)(a1 + 40));
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void _DisplaySetBrightnessMaxPhysicalZeroWithFade(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a5  = *(float *)(a1 + 376);
  }
  *(float *)(a1 + 460)  = a4;
  *(float *)(a1 + 456)  = _DisplayLogicalToSliderBrightnessInternal(a1, a4);
  *(double *)(a1 + 472)  = a5;
  *(void *)(a1 + 504)  = a2;
  *(void *)(a1 + 512)  = a3;
  *(CFAbsoluteTime *)(a1 + 480)  = CFAbsoluteTimeGetCurrent();
  if (_logHandle)
  {
    float v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    float v10 = inited;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v20, *(void *)(a1 + 472), *(void *)(a1 + 480), *(void *)(a1 + 12480));
    _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v20, 0x20u);
  }
  float v12 = (float)(a4 - *(float *)(a1 + 464)) / a5;
  UpdateFrequency  = __DisplayGetUpdateFrequency(a1, v12);
  if (_logHandle)
  {
    uint64_t v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v7 = init_default_corebrightness_log();
    }
    uint64_t v8 = v7;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v19, (uint64_t)"Max cap", COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(a4), COERCE__INT64(a5), COERCE__INT64(v12), COERCE__INT64(UpdateFrequency));
    _os_log_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: MAX begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v19, 0x3Eu);
  }
  *(float *)(a1 + 492)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 464));
  *(_DWORD *)(a1 + 496)  = *(_DWORD *)(a1 + 492);
  *(float *)(a1 + 488)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a4);
  if (_logHandle)
  {
    uint64_t v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v5 = init_default_corebrightness_log();
    }
    uint64_t v6 = v5;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v18, COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(*(float *)(a1 + 460)), COERCE__INT64(*(float *)(a1 + 496)), COERCE__INT64(*(float *)(a1 + 488)));
    _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "display->brightness.restriction.max.Lcurrent=%f L=%f display->brightness.restriction.max.fade.Pstart=%f display->brightness.restriction.max.fade.Ptarget=%f\n", v18, 0x2Au);
  }
  __DisplayStartFade((unsigned char *)a1, 1.0 / UpdateFrequency);
}

void _DisplayRampDoneCallback(uint64_t a1)
{
  if (a1)
  {
    if (_DisplayCLTMRev2Applicable(a1))
    {
      *(_DWORD *)(a1 + 464)  = 0;
      SetBLDriverNitsValueIfNotInLPM(a1, 0);
    }
  }
}

void _DisplaySetBrightnessMaxPhysicalWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a3  = *(float *)(a1 + 376);
  }
  if (_logHandle)
  {
    float v12 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    float v12 = inited;
  }
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v23, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_impl(&dword_1BA438000, v12, OS_LOG_TYPE_DEFAULT, "Thermal Brightness Cap: %f fadePeriod: %f", v23, 0x16u);
  }
  *(float *)(a1 + 460)  = a2;
  *(float *)(a1 + 456)  = _DisplayLogicalToSliderBrightnessInternal(a1, a2);
  *(double *)(a1 + 472)  = a3;
  if (a3 == 0.0)
  {
    *(float *)(a1 + 464)  = a2;
    if (*(_DWORD *)(a1 + 36))
    {
      _DisplaySetAmbient(a1, 0, *(float *)(a1 + 1184));
    }
    else
    {
      float v15 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
      *(float *)(a1 + 492)  = v15;
      *(float *)(a1 + 496)  = v15;
      *(float *)(a1 + 488)  = v15;
      __DisplaySetLogicalBrightnessInternal((const void *)a1, 12298, *(float *)(a1 + 1256));
      if (_logHandle)
      {
        float v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v9 = init_default_corebrightness_log();
        }
        float v10 = v9;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v22, (uint64_t)"Max cap", COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 1260)));
        _os_log_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: Thermal Brightness Cap: %f, nits  = %f", v22, 0x20u);
      }
    }
  }
  else
  {
    *(void *)(a1 + 504)  = 0;
    *(void *)(a1 + 512)  = 0;
    *(CFAbsoluteTime *)(a1 + 480)  = CFAbsoluteTimeGetCurrent();
    if (_logHandle)
    {
      uint64_t v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v7 = init_default_corebrightness_log();
      }
      uint64_t v8 = v7;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v21, *(void *)(a1 + 472), *(void *)(a1 + 480), *(void *)(a1 + 12480));
      _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v21, 0x20u);
    }
    float v14 = (float)(a2 - *(float *)(a1 + 464)) / a3;
    UpdateFrequency  = __DisplayGetUpdateFrequency(a1, v14);
    if (_logHandle)
    {
      uint64_t v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v5 = init_default_corebrightness_log();
      }
      uint64_t v6 = v5;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0((uint64_t)v20, (uint64_t)"Max cap", COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(v14), COERCE__INT64(UpdateFrequency));
      _os_log_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: MAX begin ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v20, 0x3Eu);
    }
    *(float *)(a1 + 492)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 464));
    *(_DWORD *)(a1 + 496)  = *(_DWORD *)(a1 + 492);
    *(float *)(a1 + 488)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
    if (_logHandle)
    {
      int v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v3 = init_default_corebrightness_log();
      }
      int v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v19, COERCE__INT64(*(float *)(a1 + 464)), COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 496)), COERCE__INT64(*(float *)(a1 + 488)));
      _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "display->brightness.restriction.max.Lcurrent=%f L=%f display->brightness.restriction.max.fade.Pstart=%f display->brightness.restriction.max.fade.Ptarget=%f\n", v19, 0x2Au);
    }
    __DisplayStartFade((unsigned char *)a1, 1.0 / UpdateFrequency);
  }
}

void SetPreStrobeState(unsigned char *a1, char a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = a1;
  char v18 = a2 & 1;
  if ((a1[232] & 1) != (a2 & 1))
  {
    int v17 = 0;
    if (v18)
    {
      *((_DWORD *)v19 + 59)  = *((_DWORD *)v19 + 35);
      int v17 = 44236800;
      if (*((int *)v19 + 64) > 0)
      {
        int v17 = *((_DWORD *)v19 + 64);
        if (*((int *)v19 + 63) > 0)
        {
          if (*((_DWORD *)v19 + 64) < *((_DWORD *)v19 + 63)) {
            int v17 = 44236800;
          }
          else {
            int v17 = *((_DWORD *)v19 + 63);
          }
        }
      }
    }
    else
    {
      int v17 = *((_DWORD *)v19 + 59);
    }
    v19[232]  = v18 & 1;
    if ((DisplayHasDCP((uint64_t)v19) & 1) != 0 && *((_DWORD *)v19 + 27))
    {
      int valuePtr = 0;
      int valuePtr = *((_DWORD *)v19 + 378);
      if ((v18 & 1) != 0 && v17 > valuePtr) {
        int valuePtr = v17;
      }
      CFAllocatorRef v2 = CFGetAllocator(v19);
      CFNumberRef v15 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      if (v15)
      {
        if ((v19[321] & 1) == 0) {
          IORegistryEntrySetCFProperty(*((_DWORD *)v19 + 27), @"BLNitsCap", v15);
        }
        *((float *)v19 + 60)  = (float)valuePtr / 65536.0;
        CFRelease(v15);
      }
      os_log_t v14 = 0;
      if (_logHandle)
      {
        uint64_t v5 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v5 = inited;
      }
      os_log_t v14 = v5;
      os_log_type_t v13 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v20, COERCE__INT64((float)valuePtr / 65536.0), COERCE__INT64((float)v17 / 65536.0));
        _os_log_debug_impl(&dword_1BA438000, v14, v13, "Pre-strobe: setting Cap=%f and Nits=%f \n", v20, 0x16u);
      }
    }
    if (v19[1516])
    {
      uint64_t v3 = *((void *)v19 + 18);
      uint64_t block = MEMORY[0x1E4F143A8];
      int v7 = -1073741824;
      int v8 = 0;
      uint64_t v9 = __SetPreStrobeState_block_invoke;
      float v10 = &__block_descriptor_41_e5_v8__0l;
      float v11 = v19;
      char v12 = v18 & 1;
      dispatch_async(v3, &block);
    }
    SetIOMFBBrightness(v19, v17, 1);
  }
}

float _DisplayGetGlobalScalarFromDictionary(uint64_t a1, io_registry_entry_t a2, const __CFDictionary *a3)
{
  uint64_t v19 = a1;
  io_registry_entry_t v18 = a2;
  CFDictionaryRef v17 = a3;
  float v16 = -1.0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  float v15 = 1.0;
  BOOL v11 = 1;
  if (!a1 || !v18 || !v17) {
    return _DisplayGetGlobalScalarFromDevice(v19, v18);
  }
  CFTypeRef cf = CFDictionaryGetValue(v17, @"enable");
  if (cf)
  {
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(cf))
    {
      int valuePtr = 1;
      CFNumberGetValue((CFNumberRef)cf, kCFNumberIntType, &valuePtr);
      BOOL v11 = valuePtr != 0;
    }
  }
  if (v11)
  {
    if ((_DisplayGetGlobalScalarDisplayParams(v18, (float *)&v12, (float *)&v12 + 1) & 1) == 0) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFTypeRef cf = CFDictionaryGetValue(v17, @"I_nominal");
    if (!cf) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFTypeID v7 = CFNumberGetTypeID();
    if (v7 != CFGetTypeID(cf)) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &v13);
    CFTypeRef cf = CFDictionaryGetValue(v17, @"I_threshold");
    if (!cf) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFTypeID v6 = CFNumberGetTypeID();
    if (v6 != CFGetTypeID(cf)) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)&v13 + 4);
    CFTypeRef cf = CFDictionaryGetValue(v17, @"B_min");
    if (!cf) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFTypeID v5 = CFNumberGetTypeID();
    if (v5 != CFGetTypeID(cf)) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &v14);
    CFTypeRef cf = CFDictionaryGetValue(v17, @"Slope");
    if (!cf) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFTypeID v4 = CFNumberGetTypeID();
    if (v4 != CFGetTypeID(cf)) {
      return _DisplayGetGlobalScalarFromDevice(v19, v18);
    }
    CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)&v14 + 4);
    return _DisplayCalculateGlobalScalar(v19, (float *)&v12);
  }
  else
  {
    float v16 = 1.0;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v19 + 192), @"BrightnessGlobalScalar", @"disabled");
    return v16;
  }
}

void SetBLDriverNitsCap(const void *a1, int a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  CFTypeRef v9 = a1;
  int valuePtr = a2;
  if (_logHandle)
  {
    CFTypeID v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    CFTypeID v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v11, COERCE__INT64((float)((float)valuePtr / 65536.0)));
    _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "SetBLDriverNitsCap to %f", v11, 0xCu);
  }
  if (valuePtr == *((_DWORD *)v9 + 284))
  {
    if (_logHandle)
    {
      CFTypeID v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v3 = init_default_corebrightness_log();
      }
      CFTypeID v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v10, COERCE__INT64((float)((float)valuePtr / 65536.0)));
      _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "SetBLDriverNitsCap: cap unchanged (%f), skipping", v10, 0xCu);
    }
  }
  else
  {
    CFAllocatorRef v2 = CFGetAllocator(v9);
    CFNumberRef cf = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    if (cf)
    {
      __DisplaySetBLDriverProperty((uint64_t)v9, @"brightness-nits-cap", cf);
      *((_DWORD *)v9 + 284)  = valuePtr;
      CFRelease(cf);
    }
  }
}

void SetBLDriverNitsValue(float *a1, int a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  int v49 = a1;
  int valuePtr = a2;
  os_log_t v47 = 0;
  if (_logHandle)
  {
    BOOL v11 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    BOOL v11 = inited;
  }
  os_log_t v47 = v11;
  os_log_type_t v46 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v50, COERCE__INT64((float)((float)valuePtr / 65536.0)));
    _os_log_debug_impl(&dword_1BA438000, v47, v46, "Setting BL nits value to %f", v50, 0xCu);
  }
  v49[381]  = (float)valuePtr / 65536.0;
  if ((_BYTE)v49[379])
  {
    if ((*((unsigned char *)v49 + 321) & 1) != 0 || (CBU_ForceFrameAfterBrightnessUpdate() & 1) == 0)
    {
      float v41 = (float)valuePtr / 65536.0;
      float v40 = 0.0;
      float v40 = v49[383];
      if (v41 >= v40 || valuePtr <= 0)
      {
        if (valuePtr > 0)
        {
          CFTypeID v5 = *((void *)v49 + 18);
          uint64_t v26 = MEMORY[0x1E4F143A8];
          int v27 = -1073741824;
          int v28 = 0;
          uint64_t v29 = __SetBLDriverNitsValue_block_invoke_2;
          float v30 = &__block_descriptor_40_e5_v8__0l;
          uint64_t v31 = v49;
          dispatch_async(v5, &v26);
        }
        CFAllocatorRef v6 = CFGetAllocator(v49);
        CFTypeRef cf = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
        if (cf)
        {
          __DisplaySetBLDriverProperty((uint64_t)v49, @"brightness-nits", cf);
          CFRelease(cf);
          SetIOMFBBrightness(v49, valuePtr, 0);
        }
        if (!valuePtr)
        {
          CFTypeID v7 = *((void *)v49 + 18);
          uint64_t v19 = MEMORY[0x1E4F143A8];
          int v20 = -1073741824;
          int v21 = 0;
          uint64_t v22 = __SetBLDriverNitsValue_block_invoke_3;
          double v23 = &__block_descriptor_40_e5_v8__0l;
          uint64_t v24 = v49;
          dispatch_async(v7, &v19);
        }
      }
      else
      {
        uint64_t v3 = *((void *)v49 + 18);
        uint64_t block = MEMORY[0x1E4F143A8];
        int v34 = -1073741824;
        int v35 = 0;
        int v36 = __SetBLDriverNitsValue_block_invoke;
        uint64_t v37 = &__block_descriptor_44_e5_v8__0l;
        float v38 = v49;
        float v39 = v41;
        dispatch_async(v3, &block);
        int valuePtr = (int)(float)(v40 * 65536.0);
        CFAllocatorRef v4 = CFGetAllocator(v49);
        CFNumberRef v32 = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
        if (v32)
        {
          __DisplaySetBLDriverProperty((uint64_t)v49, @"brightness-nits", v32);
          CFRelease(v32);
          SetIOMFBBrightness(v49, valuePtr, 0);
        }
      }
    }
    else
    {
      float v45 = (float)valuePtr / 65536.0;
      float v44 = 0.0;
      float v44 = v49[383];
      float v43 = 1.0;
      if (v45 < v44 && valuePtr > 0)
      {
        int valuePtr = (int)(float)(v44 * 65536.0);
        float v43 = v45 / v49[383];
      }
      CFAllocatorRef v2 = CFGetAllocator(v49);
      CFNumberRef v42 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      if (v42)
      {
        __DisplaySetBLDriverProperty((uint64_t)v49, @"brightness-nits", v42);
        CFRelease(v42);
        SetIOMFBBrightness(v49, valuePtr, 0);
      }
      SetWiggledDigitalDimmingScalar((uint64_t)v49, v43);
    }
  }
  else
  {
    CFAllocatorRef v8 = CFGetAllocator(v49);
    CFTypeRef v18 = CFNumberCreate(v8, kCFNumberSInt32Type, &valuePtr);
    if (v18)
    {
      __DisplaySetBLDriverProperty((uint64_t)v49, @"brightness-nits", v18);
      CFRelease(v18);
      SetIOMFBBrightness(v49, valuePtr, 0);
      if (*((unsigned char *)v49 + 321) & 1) == 0 && (CBU_ForceFrameAfterBrightnessUpdate())
      {
        CFTypeRef v9 = *((void *)v49 + 18);
        uint64_t v12 = MEMORY[0x1E4F143A8];
        int v13 = -1073741824;
        int v14 = 0;
        float v15 = __SetBLDriverNitsValue_block_invoke_4;
        float v16 = &__block_descriptor_40_e5_v8__0l;
        CFDictionaryRef v17 = v49;
        dispatch_async(v9, &v12);
      }
    }
  }
}

void DisplayEnableFullBrightnessRangeAccessOverride(uint64_t a1, char a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = a1;
  char v38 = a2 & 1;
  if (a2)
  {
    if ((*(unsigned char *)(v39 + 1548) & 1) == 0)
    {
      uint64_t v37 = 0;
      if (_logHandle)
      {
        uint64_t v19 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v19 = inited;
      }
      uint64_t v37 = v19;
      char v36 = 2;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        os_log_t log = v37;
        os_log_type_t type = v36;
        __os_log_helper_16_0_0(v35);
        _os_log_debug_impl(&dword_1BA438000, log, type, "DisplayEnableFullBrightnessRangeAccessOverride: Enable", v35, 2u);
      }
      int v2 = *(_DWORD *)(v39 + 1544);
      *(_DWORD *)(v39 + 1312)  = v2;
      *(_DWORD *)(v39 + 1300)  = v2;
      unsigned int v34 = 0;
      unsigned int v34 = *(_DWORD *)(v39 + 64);
      uint64_t v33 = 0;
      uint64_t v33 = *(void *)(v39 + 72);
      if (*(unsigned char *)(v39 + 1517))
      {
        for (unint64_t i = v34 / 2; i < v34; ++i)
        {
          float v31 = 0.0;
          float v31 = *(float *)(v39 + 1544);
          float v30 = 1.0;
          float v29 = 0.0;
          float v29 = (float)((float)((float)(i - v34 / 2) / (float)(v34 - 1 - v34 / 2))
                      * (float)((float)(*(float *)(v39 + 1536) / v31) - 1.0))
              + 1.0;
          if (v29 > 0.0) {
            *(float *)(v33 + 4 * i)  = *(float *)(v33 + 4 * i) / v29;
          }
          os_log_t v28 = 0;
          if (_logHandle)
          {
            float v15 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v14 = init_default_corebrightness_log();
            }
            float v15 = v14;
          }
          os_log_t v28 = v15;
          os_log_type_t v27 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v41, i, COERCE__INT64(*(float *)(v33 + 4 * i)), COERCE__INT64(v29));
            _os_log_debug_impl(&dword_1BA438000, v28, v27, "Rescaled marketing table %ld: %f (factor %f)", v41, 0x20u);
          }
        }
      }
      int v3 = *(_DWORD *)(v39 + 1312);
      *(_DWORD *)(v39 + 460)  = v3;
      *(_DWORD *)(v39 + 464)  = v3;
      int v4 = *(_DWORD *)(v39 + 1312);
      *(_DWORD *)(v39 + 460)  = v4;
      *(_DWORD *)(v39 + 528)  = v4;
      *(unsigned char *)(v39 + 1548)  = 1;
    }
  }
  else if (*(unsigned char *)(v39 + 1548))
  {
    uint64_t v26 = 0;
    if (_logHandle)
    {
      int v13 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v12 = init_default_corebrightness_log();
      }
      int v13 = v12;
    }
    uint64_t v26 = v13;
    char v25 = 2;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      float v10 = v26;
      os_log_type_t v11 = v25;
      __os_log_helper_16_0_0(v24);
      _os_log_debug_impl(&dword_1BA438000, v10, v11, "DisplayEnableFullBrightnessRangeAccessOverride: Disable", v24, 2u);
    }
    int v5 = *(_DWORD *)(v39 + 1536);
    *(_DWORD *)(v39 + 1312)  = v5;
    *(_DWORD *)(v39 + 1300)  = v5;
    unsigned int v23 = *(_DWORD *)(v39 + 64);
    uint64_t v22 = *(void *)(v39 + 72);
    if (*(unsigned char *)(v39 + 1517))
    {
      for (unint64_t j = v23 / 2; j < v23; ++j)
      {
        float v20 = (float)((float)((float)(j - v23 / 2) / (float)(v23 - 1 - v23 / 2))
                    * (float)((float)(*(float *)(v39 + 1536) / *(float *)(v39 + 1544)) - 1.0))
            + 1.0;
        *(float *)(v22 + 4 * j)  = *(float *)(v22 + 4 * j) * v20;
        if (_logHandle)
        {
          CFTypeRef v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v8 = init_default_corebrightness_log();
          }
          CFTypeRef v9 = v8;
        }
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v40, j, COERCE__INT64(*(float *)(v22 + 4 * j)), COERCE__INT64(v20));
          _os_log_debug_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEBUG, "Rescaled marketing table %ld: %f (factor %f)", v40, 0x20u);
        }
      }
    }
    int v6 = *(_DWORD *)(v39 + 1312);
    *(_DWORD *)(v39 + 460)  = v6;
    *(_DWORD *)(v39 + 464)  = v6;
    int v7 = *(_DWORD *)(v39 + 1312);
    *(_DWORD *)(v39 + 460)  = v7;
    *(_DWORD *)(v39 + 528)  = v7;
    *(unsigned char *)(v39 + 1548)  = 0;
  }
}

void _DisplaySetAuroraFactorWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a3  = *(float *)(a1 + 376);
  }
  char v7 = 0;
  if (_logHandle)
  {
    int v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v11, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "factor: %f fadePeriod: %f", v11, 0x16u);
  }
  if (*(unsigned char *)(a1 + 13008))
  {
    char v7 = 1;
    a3  = 0.0;
  }
  if (a3 == 0.0)
  {
    *(float *)(a1 + 12944)  = a2;
    *(float *)(a1 + 12972)  = a2;
    *(float *)(a1 + 12976)  = a2;
    *(float *)(a1 + 12968)  = a2;
    *(void *)(a1 + 12952)  = 0;
    if (*(void *)(a1 + 16))
    {
      context  = (void *)MEMORY[0x1BA9ECAE0]();
      *(float *)&double v3 = a2;
      (*(void (**)(void, __CFString *, uint64_t))(a1 + 16))(*(void *)(a1 + 24), @"AuroraFactor", [NSNumber numberWithFloat:v3]);
      (*(void (**)(void, __CFString *, void))(a1 + 16))(*(void *)(a1 + 24), @"AuroraRampInProgress", *MEMORY[0x1E4F1CFC8]);
    }
    if ((v7 & 1) == 0 && (_DisplayRampIsRunning(a1) & 1) == 0) {
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, 12288, 0, 0, *(float *)(a1 + 1252), 0.0);
    }
  }
  else
  {
    *(void *)(a1 + 12992)  = 0;
    *(void *)(a1 + 13000)  = 0;
    *(double *)(a1 + 12952)  = a3;
    *(CFAbsoluteTime *)(a1 + 12960)  = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)(a1 + 12972)  = *(_DWORD *)(a1 + 12944);
    *(_DWORD *)(a1 + 12976)  = *(_DWORD *)(a1 + 12944);
    *(float *)(a1 + 12968)  = a2;
    __DisplayStartFade((unsigned char *)a1, 0.016667);
  }
}

uint64_t _DisplayRampIsRunning(uint64_t a1)
{
  char v3 = 1;
  if (!*(void *)(a1 + 12480))
  {
    LOBYTE(v2)  = 0;
    if (*(unsigned char *)(a1 + 321)) {
      int v2 = [*(id *)(a1 + 208) isPaused] ^ 1;
    }
    char v3 = v2;
  }
  return v3 & 1;
}

float _DisplayGetAmbient(uint64_t a1)
{
  return *(float *)(a1 + 1184);
}

float _DisplayGetBrightness(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v11 = 0;
  uint64_t v12 = (float *)&v11;
  int v13 = 0x20000000;
  int v14 = 32;
  int v15 = 0;
  float v1 = *(NSObject **)(a1 + 144);
  int v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  char v7 = ___DisplayGetBrightness_block_invoke;
  uint64_t v8 = &unk_1E621A490;
  CFTypeRef v9 = &v11;
  uint64_t v10 = v16;
  disp_dispatch_sync(v1, &v4);
  float v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1BA5A04C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

float _DisplayResetAdaptiveDimming(uint64_t a1)
{
  uint64_t v9 = a1;
  uint64_t v8 = 0;
  if (_logHandle)
  {
    int v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v5 = inited;
  }
  uint64_t v8 = v5;
  char v7 = 2;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    os_log_t log = v8;
    os_log_type_t type = v7;
    __os_log_helper_16_0_0(v6);
    _os_log_debug_impl(&dword_1BA438000, log, type, "Display powering off; reset AutoDim state", v6, 2u);
  }
  *(_DWORD *)(v9 + 228)  = 0;
  float result = 100.0;
  *(_DWORD *)(v9 + 832)  = 1120403456;
  return result;
}

uint64_t __DisplayCommitReport(uint64_t result, char a2)
{
  uint64_t v15 = result;
  char v14 = a2;
  if (*(unsigned char *)(result + 12520) & 1) != 0 || (*(unsigned char *)(v15 + 12514))
  {
    if (v14) {
      float result = __DisplayResetLogTimer(v15, 1);
    }
    if (*(void *)(v15 + 12504))
    {
      bzero(v10, 0x200uLL);
      CFXGetReport(*(void *)(v15 + 12504), (uint64_t)v10);
      float v2 = v12 / v11;
      float valuePtr = v2;
      float v3 = v13 / v11;
      float v8 = v3;
      float valuePtr = fmaxf(fminf(v2, *(float *)(v15 + 1312)), *(float *)(v15 + 1320));
      float v8 = fmaxf(fminf(v3, *(float *)(v15 + 1312)), *(float *)(v15 + 1320));
      CFMutableDictionaryRef theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 10, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (theDict)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"AvgBacklightNits", value);
          CFRelease(value);
        }
        valuea  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v8);
        if (valuea)
        {
          CFDictionaryAddValue(theDict, @"AvgLogicalBrightnessNits", valuea);
          CFRelease(valuea);
        }
        if (*(void *)(v15 + 16)) {
          (*(void (**)(void, __CFString *, __CFDictionary *))(v15 + 16))(*(void *)(v15 + 24), @"PowerLogReport", theDict);
        }
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(v15 + 192), @"PowerLogReport", theDict);
        CFRelease(theDict);
      }
      return __DisplayReportToCA(v15, (uint64_t)v10, v4);
    }
  }
  return result;
}

float _DisplayGetBrightnessFactor(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v11 = 0;
  double v12 = (float *)&v11;
  int v13 = 0x20000000;
  int v14 = 32;
  int v15 = 0;
  float v1 = *(NSObject **)(a1 + 144);
  double v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  char v7 = ___DisplayGetBrightnessFactor_block_invoke;
  float v8 = &unk_1E621A490;
  uint64_t v9 = &v11;
  uint64_t v10 = v16;
  disp_dispatch_sync(v1, &v4);
  float v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1BA5A0B1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

void DisplaySetAuroraFactorWithFade(uint64_t a1, float a2, float a3)
{
  uint64_t v14 = a1;
  float v13 = a2;
  float v12 = a3;
  float v3 = *(NSObject **)(a1 + 144);
  double v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  char v7 = __DisplaySetAuroraFactorWithFade_block_invoke;
  float v8 = &__block_descriptor_48_e5_v8__0l;
  uint64_t v9 = v14;
  float v10 = a2;
  float v11 = a3;
  disp_dispatch_sync(v3, &v4);
}

void __DisplaySetAuroraFactorWithFade_block_invoke(uint64_t a1)
{
}

void _DisplaySetRestrictionFactorWithFade(uint64_t a1, char a2, float a3, float a4, float a5, float a6)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = __PAIR64__(LODWORD(a6), LODWORD(a5));
  char v10 = a2 & 1;
  if (*(unsigned char *)(a1 + 380)) {
    a4  = *(float *)(a1 + 376);
  }
  char v9 = 0;
  if (_logHandle)
  {
    char v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    char v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v15, COERCE__INT64(a3), COERCE__INT64(a4));
    _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "factor: %f fadePeriod: %f", v15, 0x16u);
  }
  *(void *)(a1 + 976)  = v14;
  if (v10) {
    uint64_t v8 = a1 + 984;
  }
  else {
    uint64_t v8 = a1 + 1056;
  }
  if (v10 & 1) != 0 && (*(unsigned char *)(a1 + 1048) & 1) != 0 || (v10 & 1) == 0 && (*(unsigned char *)(a1 + 1120))
  {
    char v9 = 1;
    a4  = 0.0;
  }
  if (a4 == 0.0)
  {
    *(float *)uint64_t v8 = a3;
    *(float *)(v8 + 28)  = a3;
    *(float *)(v8 + 32)  = a3;
    *(float *)(v8 + 24)  = a3;
    *(void *)(v8 + 8)  = 0;
    if ((v9 & 1) == 0) {
      __DisplaySetLogicalBrightnessWithFadeInternal(a1, 12288, 0, 0, *(float *)(a1 + 1252), 0.0);
    }
  }
  else
  {
    *(void *)(v8 + 48)  = 0;
    *(void *)(v8 + 56)  = 0;
    *(double *)(v8 + 8)  = a4;
    *(CFAbsoluteTime *)(v8 + 16)  = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)(v8 + 28)  = *(_DWORD *)v8;
    *(_DWORD *)(v8 + 32)  = *(_DWORD *)v8;
    *(float *)(v8 + 24)  = a3;
    __DisplayStartFade((unsigned char *)a1, 0.016667);
  }
}

void DisplaySetRestrictionFactorWithFade(uint64_t a1, char a2, float a3, float a4, float a5, float a6)
{
  unint64_t v21 = __PAIR64__(LODWORD(a6), LODWORD(a5));
  uint64_t v20 = a1;
  float v19 = a3;
  float v18 = a4;
  char v17 = a2 & 1;
  int v6 = *(NSObject **)(a1 + 144);
  char v7 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v8 = -1073741824;
  int v9 = 0;
  char v10 = __DisplaySetRestrictionFactorWithFade_block_invoke;
  float v11 = &__block_descriptor_57_e5_v8__0l;
  uint64_t v12 = v20;
  float v13 = a3;
  float v14 = a4;
  char v16 = a2 & 1;
  unint64_t v15 = __PAIR64__(LODWORD(a6), LODWORD(a5));
  disp_dispatch_sync(v6, &v7);
}

void __DisplaySetRestrictionFactorWithFade_block_invoke(uint64_t a1)
{
}

float DisplayGetRestrictionFactorForNits(uint64_t a1, char a2, float a3)
{
  uint64_t v21 = a1;
  float v20 = a3;
  char v19 = a2 & 1;
  uint64_t v14 = 0;
  unint64_t v15 = (float *)&v14;
  int v16 = 0x20000000;
  int v17 = 32;
  int v18 = 0;
  float v3 = *(NSObject **)(a1 + 144);
  int v6 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v7 = -1073741824;
  int v8 = 0;
  int v9 = __DisplayGetRestrictionFactorForNits_block_invoke;
  char v10 = &unk_1E621A5A8;
  float v11 = &v14;
  char v13 = a2 & 1;
  uint64_t v12 = v21;
  disp_dispatch_sync(v3, &v6);
  float v5 = v20 / v15[6];
  _Block_object_dispose(&v14, 8);
  return v5;
}

void sub_1BA5A1168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

float __DisplayGetRestrictionFactorForNits_block_invoke(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48)) {
    float v2 = *(float *)(*(void *)(a1 + 40) + 1320);
  }
  else {
    float v2 = *(float *)(*(void *)(a1 + 40) + 1312);
  }
  float result = v2;
  *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = v2;
  return result;
}

float _DisplayGetBrightnessMaxPhysical(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v11 = 0;
  uint64_t v12 = (float *)&v11;
  int v13 = 0x20000000;
  int v14 = 32;
  int v15 = 0;
  float v1 = *(NSObject **)(a1 + 144);
  double v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  int v7 = ___DisplayGetBrightnessMaxPhysical_block_invoke;
  int v8 = &unk_1E621A490;
  int v9 = &v11;
  uint64_t v10 = v16;
  disp_dispatch_sync(v1, &v4);
  float v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1BA5A12C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

float DisplayGetBrightnessMaxPhysical(uint64_t a1)
{
  return *(float *)(a1 + 464);
}

float DisplayGetWeakCap(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v11 = 0;
  uint64_t v12 = (float *)&v11;
  int v13 = 0x20000000;
  int v14 = 32;
  int v15 = 0;
  float v1 = *(NSObject **)(a1 + 144);
  double v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  int v7 = __DisplayGetWeakCap_block_invoke;
  int v8 = &unk_1E621A490;
  int v9 = &v11;
  uint64_t v10 = v16;
  disp_dispatch_sync(v1, &v4);
  float v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1BA5A1400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

void __DisplayGetWeakCap_block_invoke(uint64_t a1)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = *(_DWORD *)(*(void *)(a1 + 40) + 1312);
  if (*(float *)(*(void *)(a1 + 40) + 524) < *(float *)(*(void *)(a1 + 40) + 1312)) {
    *(float *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = _DisplayPerceptualLuminanceToLuminanceInternal(*(void *)(a1 + 40), *(float *)(*(void *)(a1 + 40) + 608));
  }
}

void DisplayUpdateWeakCapOnSignificantAmbientChange(uint64_t a1)
{
  uint64_t v8 = a1;
  float v1 = *(NSObject **)(a1 + 144);
  float v2 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  int v5 = __DisplayUpdateWeakCapOnSignificantAmbientChange_block_invoke;
  int v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void __DisplayUpdateWeakCapOnSignificantAmbientChange_block_invoke(uint64_t a1)
{
}

void _DisplayUpdateWeakCapOnSignificantAmbientChange(float *a1)
{
  uint64_t v8 = a1;
  if (a1[131] < a1[328] && v8[132] > v8[131])
  {
    uint64_t v7 = 0;
    if (_logHandle)
    {
      int v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v4 = inited;
    }
    uint64_t v7 = v4;
    char v6 = 2;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      os_log_t log = v7;
      os_log_type_t type = v6;
      __os_log_helper_16_0_0(v5);
      _os_log_debug_impl(&dword_1BA438000, log, type, "Display: Resetting weak cap on significant ambient change", v5, 2u);
    }
    _DisplaySetBrightnessWeakCapWithFade(v8, 0, v8[131], 10.0);
  }
}

float _DisplayGetBrightnessMinPhysical(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v11 = 0;
  uint64_t v12 = (float *)&v11;
  int v13 = 0x20000000;
  int v14 = 32;
  int v15 = 0;
  float v1 = *(NSObject **)(a1 + 144);
  int v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  uint64_t v7 = ___DisplayGetBrightnessMinPhysical_block_invoke;
  uint64_t v8 = &unk_1E621A490;
  uint64_t v10 = v16;
  int v9 = &v11;
  disp_dispatch_sync(v1, &v4);
  float v3 = v12[6];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1BA5A1794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

float __DisplayGetUpdateFrequency(uint64_t a1, float a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  float v10 = fminf(fmaxf(fabsf(a2), 1.0), 20.0);
  float v8 = (float)((float)(v10 - 1.0) / 20.0) * 95.0;
  unsigned int v7 = v8;
  if (v8 == 95.0) {
    float v9 = __DisplayNitsPerSecondToUpdateFrequency[v8];
  }
  else {
    float v9 = __interpolate((float)v7, __DisplayNitsPerSecondToUpdateFrequency[v7], (float)(v7 + 1), __DisplayNitsPerSecondToUpdateFrequency[v7 + 1], v8);
  }
  if (*(unsigned char *)(a1 + 321) & 1) == 0 && (CBU_ForceUpdateFrequencyAndFrameSkip())
  {
    if (v9 > 30.0) {
      float v9 = 60.0;
    }
    else {
      float v9 = 30.0;
    }
  }
  if (_logHandle)
  {
    int v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v6 = inited;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_4_0_4_0((uint64_t)v12, COERCE__INT64(v10), COERCE__INT64(v9), v7, 96);
    _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "rate: %0.2f nits/s %0.2fhz         [%u/%u]", v12, 0x22u);
  }
  if (*(float *)(a1 + 384) == 0.0) {
    float v4 = 1.0;
  }
  else {
    float v4 = *(float *)(a1 + 384);
  }
  if (*(float *)(a1 + 388) == 0.0) {
    float v3 = 80.0;
  }
  else {
    float v3 = *(float *)(a1 + 388);
  }
  return fminf(fmaxf(v9, v4), v3);
}

uint64_t __os_log_helper_16_2_6_8_32_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  return result;
}

void _DisplayScheduleAsync(uint64_t a1)
{
  uint64_t v8 = a1;
  float v1 = *(NSObject **)(a1 + 144);
  float v2 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  int v5 = ___DisplayScheduleAsync_block_invoke;
  int v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

void _DisplayUnscheduleAsync(uint64_t a1)
{
  uint64_t v8 = a1;
  float v1 = *(NSObject **)(a1 + 144);
  float v2 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  int v5 = ___DisplayUnscheduleAsync_block_invoke;
  int v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

float DisplayGetDeviceBrightness(uint64_t a1)
{
  return *(float *)(a1 + 1260);
}

float DisplayGetPhysicalBrightness(uint64_t a1)
{
  return *(float *)(a1 + 1264);
}

float DisplayGetLogicalBrightness(uint64_t a1)
{
  return *(float *)(a1 + 1256);
}

void DisplayAccessoryInitializeBrightnessOverrides(uint64_t a1)
{
  uint64_t v6 = a1;
  CFPreferencesAppSynchronize(@"com.apple.CoreBrightness");
  CFStringRef v5 = 0;
  CFStringRef v1 = @"DisplayTypeAOverride";
  if (!*(_DWORD *)(v6 + 308)) {
    CFStringRef v1 = @"DisplayTypeBOverride";
  }
  CFStringRef v5 = v1;
  CFTypeRef cf = CFPreferencesCopyAppValue(v1, @"com.apple.CoreBrightness");
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == CFNumberGetTypeID())
    {
      float valuePtr = -1.0;
      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &valuePtr);
      *(float *)(v6 + 316)  = valuePtr;
    }
    CFRelease(cf);
  }
}

void DisplaySetLogicalBrightness(uint64_t a1, int a2, float a3)
{
}

void DisplaySetLogicalBrightnessWithFade(uint64_t a1, int a2, uint64_t a3, uint64_t a4, float a5, float a6)
{
  uint64_t v23 = a1;
  float v22 = a5;
  int v21 = a2;
  float v20 = a6;
  uint64_t v19 = a3;
  uint64_t v18 = a4;
  uint64_t v6 = *(NSObject **)(a1 + 144);
  uint64_t v7 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v8 = -1073741824;
  int v9 = 0;
  float v10 = __DisplaySetLogicalBrightnessWithFade_block_invoke;
  uint64_t v11 = &__block_descriptor_68_e5_v8__0l;
  uint64_t v12 = v23;
  float v15 = a5;
  int v16 = a2;
  float v17 = a6;
  uint64_t v13 = a3;
  uint64_t v14 = a4;
  disp_dispatch_sync(v6, &v7);
}

void __DisplaySetLogicalBrightnessWithFade_block_invoke(uint64_t a1)
{
}

void DisplaySetVirtualBrightnessWithFade(uint64_t a1, int a2, uint64_t a3, uint64_t a4, float a5, float a6)
{
  uint64_t v34 = a1;
  float v33 = a5;
  int v32 = a2;
  float v31 = a6;
  uint64_t v30 = a3;
  uint64_t v29 = a4;
  if (*(_DWORD *)(a1 + 40))
  {
    uint64_t v6 = *(NSObject **)(v34 + 144);
    uint64_t v19 = (void (*)(void))MEMORY[0x1E4F143A8];
    int v20 = -1073741824;
    int v21 = 0;
    float v22 = __DisplaySetVirtualBrightnessWithFade_block_invoke;
    uint64_t v23 = &__block_descriptor_64_e5_v8__0l;
    uint64_t v24 = v34;
    float v27 = v33;
    float v28 = v31;
    uint64_t v25 = v30;
    uint64_t v26 = v29;
    disp_dispatch_sync(v6, &v19);
  }
  else
  {
    uint64_t v7 = *(NSObject **)(v34 + 144);
    int v8 = (void (*)(void))MEMORY[0x1E4F143A8];
    int v9 = -1073741824;
    int v10 = 0;
    uint64_t v11 = __DisplaySetVirtualBrightnessWithFade_block_invoke_2;
    uint64_t v12 = &__block_descriptor_68_e5_v8__0l;
    uint64_t v13 = v34;
    float v16 = v33;
    int v17 = v32;
    float v18 = v31;
    uint64_t v14 = v30;
    uint64_t v15 = v29;
    disp_dispatch_sync(v7, &v8);
  }
}

void __DisplaySetVirtualBrightnessWithFade_block_invoke(uint64_t a1)
{
}

void _DisplaySetVirtualBrightnessWithFade(uint64_t a1, unsigned int a2, void (*a3)(uint64_t), uint64_t a4, float a5, float a6)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a6  = *(float *)(a1 + 376);
  }
  *(float *)(a1 + 1492)  = a5;
  *(double *)(a1 + 1440)  = a6;
  if (_logHandle)
  {
    int v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v10 = inited;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v17, COERCE__INT64(a5), COERCE__INT64(a6));
    _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "L=%f fadePeriod=%f\n", v17, 0x16u);
  }
  if (a6 == 0.0 || a5 == 0.0)
  {
    BOOL v8 = 0;
    if (*(double *)(a1 + 1384) != 0.0)
    {
      BOOL v8 = 0;
      if (*(float *)(a1 + 1400) > 0.0) {
        BOOL v8 = *(float *)(a1 + 1400) < 1.0;
      }
    }
    BOOL v7 = 0;
    if (*(double *)(a1 + 1384) == 0.0)
    {
      BOOL v7 = 0;
      if (*(float *)(a1 + 348) > 0.0) {
        BOOL v7 = *(float *)(a1 + 348) < 1.0;
      }
    }
    if (v8 || v7) {
      *(float *)(a1 + 1488)  = a5;
    }
    else {
      __DisplaySetVirtualBrightnessWithFadeInternal(a1, a5, 0.0, a2 | 0x1000, 0, 0);
    }
    if (a3) {
      a3(a4);
    }
  }
  else if (a2 & 0x10) != 0 && (_DisplayRampIsRunning(a1))
  {
    *(float *)(a1 + 1456)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1492));
  }
  else
  {
    float v6 = *(double *)(a1 + 1440);
    __DisplaySetVirtualBrightnessWithFadeInternal(a1, *(float *)(a1 + 1492), v6, a2, (uint64_t)a3, a4);
  }
}

void __DisplaySetVirtualBrightnessWithFade_block_invoke_2(uint64_t a1)
{
}

uint64_t __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  return result;
}

void DisplayCancelBrightnessFade(uint64_t a1)
{
  uint64_t v8 = a1;
  CFStringRef v1 = *(NSObject **)(a1 + 144);
  CFTypeID v2 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  CFStringRef v5 = __DisplayCancelBrightnessFade_block_invoke;
  float v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

double __DisplayCancelBrightnessFade_block_invoke(uint64_t a1)
{
  uint64_t v11 = a1;
  uint64_t v10 = a1;
  if (_DisplayRampIsRunning(*(void *)(a1 + 32)))
  {
    int v9 = 0;
    if (_logHandle)
    {
      CFStringRef v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      CFStringRef v5 = inited;
    }
    int v9 = v5;
    char v8 = 2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      os_log_t log = v9;
      os_log_type_t type = v8;
      __os_log_helper_16_0_0(v7);
      _os_log_debug_impl(&dword_1BA438000, log, type, "cancel ramp", v7, 2u);
    }
    *(_DWORD *)(*(void *)(a1 + 32) + 1252)  = *(_DWORD *)(*(void *)(a1 + 32) + 1256);
    __DisplaySetLogicalBrightnessWithFadeInternal(*(void *)(a1 + 32), *(_DWORD *)(*(void *)(a1 + 32) + 1328) | 0x1000, 0, 0, *(float *)(*(void *)(a1 + 32) + 1256), 0.0);
    if (*(void *)(*(void *)(a1 + 32) + 1368)) {
      (*(void (**)(void))(*(void *)(a1 + 32) + 1368))(*(void *)(*(void *)(a1 + 32) + 1376));
    }
    double result = 0.0;
    *(void *)(*(void *)(a1 + 32) + 1336)  = 0;
  }
  return result;
}

void __DisplayUpdateAAPFactor(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 12248) & 1) != 0 && !*(_DWORD *)(a1 + 40))
  {
    float v5 = *(float *)(a1 + 1572);
    if (v5 <= 0.0) {
      float v4 = 200.0;
    }
    else {
      float v4 = *(float *)(a1 + 1256) / v5;
    }
    if ((float)(v4 * 0.005) > 1.0) {
      float v4 = 200.0;
    }
    float v3 = (float)(powf(v4 * 0.005, -0.45) - 1.0) / 5.0;
    if (_logHandle)
    {
      CFTypeID v2 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      CFTypeID v2 = inited;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v7, COERCE__INT64(*(float *)(a1 + 1256)), COERCE__INT64(v5), COERCE__INT64(v4), COERCE__INT64(v3));
      _os_log_impl(&dword_1BA438000, v2, OS_LOG_TYPE_DEFAULT, "Lcurrent=%0.4f Lr=%0.4f DR=%0.4f factor=%0.4f\n", v7, 0x2Au);
    }
    __DisplaySetAAPFactor((unsigned char *)a1, v3);
  }
}

void __DisplaySetReflectedBrightnessWithFade_block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(*(void *)(a1 + 32) + 12248))
  {
    *(double *)(*(void *)(a1 + 32) + 1576)  = *(float *)(a1 + 56);
    *(_DWORD *)(*(void *)(a1 + 32) + 1568)  = *(_DWORD *)(a1 + 60);
    if (_logHandle)
    {
      uint64_t v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v7 = inited;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v14, COERCE__INT64(*(float *)(a1 + 60)), COERCE__INT64(*(float *)(a1 + 56)));
      _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "reflected=%f fadePeriod=%f\n", v14, 0x16u);
    }
    if (*(double *)(*(void *)(a1 + 32) + 1576) == 0.0)
    {
      *(_DWORD *)(*(void *)(a1 + 32) + 1572)  = *(_DWORD *)(*(void *)(a1 + 32) + 1568);
      if (*(float *)(*(void *)(a1 + 32) + 1572) == 0.0) {
        float v11 = 0.0;
      }
      else {
        float v11 = _DisplayReflectedLuminanceToPerceptualLuminanceInternal(*(void *)(a1 + 32), *(float *)(*(void *)(a1 + 32) + 1572));
      }
      *(float *)(*(void *)(a1 + 32) + 1600)  = v11;
      *(float *)(*(void *)(a1 + 32) + 1592)  = v11;
      *(float *)(*(void *)(a1 + 32) + 1596)  = v11;
      if ((*(unsigned char *)(*(void *)(a1 + 32) + 12282) & 1) == 0) {
        __DisplayUpdateAAPFactor(*(void *)(a1 + 32));
      }
      if (*(void *)(a1 + 40)) {
        (*(void (**)(void))(a1 + 40))(*(void *)(a1 + 48));
      }
    }
    else if (*(float *)(*(void *)(a1 + 32) + 1572) != *(float *)(*(void *)(a1 + 32) + 1568))
    {
      *(void *)(*(void *)(a1 + 32) + 1608)  = *(void *)(a1 + 40);
      *(void *)(*(void *)(a1 + 32) + 1616)  = *(void *)(a1 + 48);
      *(CFAbsoluteTime *)(*(void *)(a1 + 32) + 1584)  = CFAbsoluteTimeGetCurrent();
      double v10 = *(float *)(*(void *)(a1 + 32) + 12488);
      if (v10 == 0.0) {
        double v10 = 0.100000001;
      }
      if (_logHandle)
      {
        float v5 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v4 = init_default_corebrightness_log();
        }
        float v5 = v4;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v13, COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 1572)), COERCE__INT64(*(float *)(*(void *)(a1 + 32) + 1568)), COERCE__INT64(*(float *)(a1 + 56)), COERCE__INT64(1.0 / v10));
        _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "begin ramp Lr: %0.2f -> Lr: %0.2f t: %f %0.2fhz", v13, 0x2Au);
      }
      if (_logHandle)
      {
        float v3 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v2 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v2 = init_default_corebrightness_log();
        }
        float v3 = v2;
      }
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v12, *(void *)(*(void *)(a1 + 32) + 1576), *(void *)(*(void *)(a1 + 32) + 1584), *(void *)(*(void *)(a1 + 32) + 12480), *(uint64_t *)&v10);
        _os_log_debug_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p interval=%f\n", v12, 0x2Au);
      }
      if (*(float *)(*(void *)(a1 + 32) + 1572) == 0.0) {
        float v9 = 0.0;
      }
      else {
        float v9 = _DisplayReflectedLuminanceToPerceptualLuminanceInternal(*(void *)(a1 + 32), *(float *)(*(void *)(a1 + 32) + 1572));
      }
      *(float *)(*(void *)(a1 + 32) + 1600)  = v9;
      *(float *)(*(void *)(a1 + 32) + 1596)  = v9;
      *(float *)(*(void *)(a1 + 32) + 1592)  = _DisplayReflectedLuminanceToPerceptualLuminanceInternal(*(void *)(a1 + 32), fmaxf(*(float *)(*(void *)(a1 + 32) + 1568), 0.01));
      float v1 = v10;
      __DisplayStartFade(*(unsigned char **)(a1 + 32), v1);
    }
  }
}

void DisplayCancelReflectedBrightnessFade(uint64_t a1)
{
  uint64_t v8 = a1;
  float v1 = *(NSObject **)(a1 + 144);
  uint64_t v2 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  float v5 = __DisplayCancelReflectedBrightnessFade_block_invoke;
  float v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = v8;
  disp_dispatch_sync(v1, &v2);
}

double __DisplayCancelReflectedBrightnessFade_block_invoke(uint64_t a1)
{
  return __DisplayCancelReflectedBrightnessFadeInternal(*(void *)(a1 + 32));
}

void __DisplayFadeUpdateFade(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  double v8 = a1 - *(double *)(a3 + 8);
  double v7 = v8 / *(double *)a3;
  if (v7 >= 1.0)
  {
    float v4 = fmin(1.0, *(float *)(a3 + 16));
    *(float *)(a3 + 20)  = v4;
    if (_logHandle)
    {
      float v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v6 = inited;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v11, *(uint64_t *)&a1, *(uint64_t *)&v8, *(void *)a3, *(uint64_t *)&v7, COERCE__INT64(*(float *)(a3 + 24)), COERCE__INT64(*(float *)(a3 + 16)));
      _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Pstart=%f fade->Ptarget=%f [finished]\n", v11, 0x3Eu);
    }
    if (*(void *)(a3 + 32)) {
      (*(void (**)(void))(a3 + 32))(*(void *)(a3 + 40));
    }
    *(void *)a3  = 0;
  }
  else
  {
    float v3 = fmin(1.0, *(float *)(a3 + 24) + (float)(*(float *)(a3 + 16) - *(float *)(a3 + 24)) * v7);
    *(float *)(a3 + 20)  = v3;
  }
}

float __DisplayFadeComputeCurrentFactor(float *a1, double a2)
{
  float v2 = a1[7] + a1[8] * a2 + a1[9] * a2 * a2;
  float v3 = fmin(1.0, (float)(a1[6] + (float)((float)(a1[4] - a1[6]) * v2)));
  return fmax(0.0, v3);
}

void __DisplayFadeUpdateFactorFade(uint64_t a1, double *a2, int a3, double a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = a1;
  double v28 = a4;
  float v27 = a2;
  int v26 = a3;
  double v25 = 0.0;
  double v25 = a4 - a2[1];
  double v24 = 0.0;
  double v24 = v25 / *a2;
  if (a3 && *(_DWORD *)(v29 + 84) && !*(_DWORD *)(v29 + 104) && *((float *)v27 + 4) > 0.0 && !*(_DWORD *)(v29 + 88))
  {
    if (*(double *)(v29 + 96) == 0.0) {
      *(double *)(v29 + 96)  = v28;
    }
    if (v28 - *(double *)(v29 + 96) < 1.0)
    {
      v27[1]  = v28;
      os_log_t oslog = 0;
      if (_logHandle)
      {
        int v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        int v17 = inited;
      }
      os_log_t oslog = v17;
      os_log_type_t type = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        os_log_t log = oslog;
        os_log_type_t v15 = type;
        __os_log_helper_16_0_0(v21);
        _os_log_debug_impl(&dword_1BA438000, log, v15, "Delaying Ramp Start\n", v21, 2u);
      }
      return;
    }
    os_log_t v20 = 0;
    if (_logHandle)
    {
      uint64_t v13 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v12 = init_default_corebrightness_log();
      }
      uint64_t v13 = v12;
    }
    os_log_t v20 = v13;
    os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      double v10 = v20;
      os_log_type_t v11 = v19;
      __os_log_helper_16_0_0(v18);
      _os_log_debug_impl(&dword_1BA438000, v10, v11, "Ramp delay hit timeout\n", v18, 2u);
    }
  }
  if (v24 >= 1.0)
  {
    float v5 = fmin(1.0, *((float *)v27 + 4));
    *((float *)v27 + 5)  = v5;
    if (v26) {
      *(_DWORD *)(v29 + 88)  = 0;
    }
    if (_logHandle)
    {
      double v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v6 = init_default_corebrightness_log();
      }
      double v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v30, *(uint64_t *)&v28, *(uint64_t *)&v25, *(void *)v27, *(uint64_t *)&v24, COERCE__INT64(*((float *)v27 + 6)), COERCE__INT64(*((float *)v27 + 4)));
      _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f [finished]\n", v30, 0x3Eu);
    }
    if (*((void *)v27 + 5)) {
      (*((void (**)(void))v27 + 5))(*((void *)v27 + 6));
    }
    *float v27 = 0.0;
  }
  else
  {
    float v4 = __DisplayFadeComputeCurrentFactor((float *)v27, v24);
    *((float *)v27 + 5)  = v4;
    if (_logHandle)
    {
      float v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v8 = init_default_corebrightness_log();
      }
      float v9 = v8;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v31, *(uint64_t *)&v28, *(uint64_t *)&v25, *(void *)v27, *(uint64_t *)&v24, COERCE__INT64(*((float *)v27 + 6)), COERCE__INT64(*((float *)v27 + 4)), COERCE__INT64(*((float *)v27 + 5)));
      _os_log_debug_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f Factor=%f\n", v31, 0x48u);
    }
  }
}

void __DisplayFadeUpdateRestrictionFactorFade(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  double v10 = a1 - *(double *)(a3 + 8);
  double v8 = v10 / *(double *)a3;
  if (*(float *)(a3 + 20) == *(float *)(a3 + 16)) {
    double v8 = 1.0;
  }
  if (v8 >= 1.0)
  {
    *(_DWORD *)(a3 + 20)  = *(_DWORD *)(a3 + 16);
    if (_logHandle)
    {
      float v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v13, *(uint64_t *)&a1, *(uint64_t *)&v10, *(void *)a3, *(uint64_t *)&v8, COERCE__INT64(*(float *)(a3 + 24)), COERCE__INT64(*(float *)(a3 + 16)));
      _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f [finished]\n", v13, 0x3Eu);
    }
    if (*(void *)(a3 + 40)) {
      (*(void (**)(void))(a3 + 40))(*(void *)(a3 + 48));
    }
    *(void *)a3  = 0;
  }
  else
  {
    if (*(float *)(a3 + 24) >= *(float *)(a3 + 16)) {
      double v9 = 1.0 - (1.0 - v8) * (1.0 - v8) * (1.0 - v8);
    }
    else {
      double v9 = v8 * v8 * v8;
    }
    float v3 = *(float *)(a3 + 24) + (float)(*(float *)(a3 + 16) - *(float *)(a3 + 24)) * v9;
    *(float *)(a3 + 20)  = v3;
    if (_logHandle)
    {
      double v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v6 = init_default_corebrightness_log();
      }
      double v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v14, *(uint64_t *)&a1, *(uint64_t *)&v10, *(void *)a3, *(uint64_t *)&v9, COERCE__INT64(*(float *)(a3 + 24)), COERCE__INT64(*(float *)(a3 + 16)), COERCE__INT64(*(float *)(a3 + 20)));
      _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f Factor=%f\n", v14, 0x48u);
    }
  }
}

void __DisplayFadeUpdateAuroraFactorFade(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  double v15 = a3 - *(double *)(a2 + 8);
  double v14 = v15 / *(double *)a2;
  if (*(float *)(a2 + 20) == *(float *)(a2 + 16)) {
    double v14 = 1.0;
  }
  if (v14 >= 1.0)
  {
    *(_DWORD *)(a2 + 20)  = *(_DWORD *)(a2 + 16);
    if (_logHandle)
    {
      double v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      double v8 = inited;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v19, *(uint64_t *)&a3, *(uint64_t *)&v15, *(void *)a2, *(uint64_t *)&v14, COERCE__INT64(*(float *)(a2 + 24)), COERCE__INT64(*(float *)(a2 + 16)));
      _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f [finished]\n", v19, 0x3Eu);
    }
    if (*(void *)(a2 + 40)) {
      (*(void (**)(void))(a2 + 40))(*(void *)(a2 + 48));
    }
    HIDWORD(v4)  = 0;
    *(void *)a2  = 0;
  }
  else
  {
    float v13 = 2.0;
    float v12 = *(float *)(a1 + 13020);
    if (*(float *)(a2 + 24) > *(float *)(a2 + 16))
    {
      float v13 = 1.0 / 2.0;
      float v12 = *(float *)(a1 + 13024);
    }
    float v3 = v14 * (float)(fabsf(log2f(*(float *)(a2 + 16) / *(float *)(a2 + 24))) * v12);
    float v11 = *(float *)(a2 + 24);
    *(float *)(a2 + 20)  = v11 * powf(v13, v3 / v12);
    if (_logHandle)
    {
      double v10 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v9 = init_default_corebrightness_log();
      }
      double v10 = v9;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_7_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v20, *(uint64_t *)&a3, *(uint64_t *)&v15, *(void *)a2, *(uint64_t *)&v14, COERCE__INT64(*(float *)(a2 + 24)), COERCE__INT64(*(float *)(a2 + 16)), COERCE__INT64(*(float *)(a2 + 20)));
      _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "now=%f delta=%f fade->period=%f portion=%f fade->Fstart=%f fade->Ftarget=%f Factor=%f\n", v20, 0x48u);
    }
  }
  if (*(void *)(a1 + 16))
  {
    LODWORD(v4)  = *(_DWORD *)(a2 + 20);
    (*(void (**)(void, __CFString *, uint64_t))(a1 + 16))(*(void *)(a1 + 24), @"AuroraFactor", [NSNumber numberWithFloat:v4]);
    float v5 = *(void (**)(uint64_t, __CFString *, void))(a1 + 16);
    uint64_t v6 = *(void *)(a1 + 24);
    if (*(double *)(a1 + 12952) <= 0.0) {
      v5(v6, @"AuroraRampInProgress", *MEMORY[0x1E4F1CFC8]);
    }
    else {
      v5(v6, @"AuroraRampInProgress", *MEMORY[0x1E4F1CFD0]);
    }
  }
}

uint64_t IOFixedMultiply(int a1, int a2)
{
  return (a1 * (uint64_t)a2) >> 16;
}

uint64_t IOFixedDivide(int a1, int a2)
{
  return ((uint64_t)a1 << 16) / a2;
}

float DisplayNits2milliAmps(uint64_t a1, int a2)
{
  int v5 = IOFixedDivide(a2, (int)(float)(*(float *)(a1 + 1324) * 65536.0));
  int v2 = IOFixedMultiply(v5, v5);
  int v4 = IOFixedMultiply(v2, *(_DWORD *)(a1 + 292));
  return (float)(int)(v4 + IOFixedMultiply(*(_DWORD *)(a1 + 296), v5) + *(_DWORD *)(a1 + 300)) / 65536.0;
}

float DisplayMilliAmpsToMilliWatts(uint64_t a1, float a2)
{
  return a2 * *(float *)(a1 + 304);
}

void DisplayCancelRestrictionFactorFade(uint64_t a1, int a2)
{
  uint64_t v11 = a1;
  int v10 = a2;
  int v2 = *(NSObject **)(a1 + 144);
  float v3 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  uint64_t v6 = __DisplayCancelRestrictionFactorFade_block_invoke;
  double v7 = &__block_descriptor_44_e5_v8__0l;
  uint64_t v8 = v11;
  int v9 = a2;
  disp_dispatch_sync(v2, &v3);
}

uint64_t __DisplayCancelRestrictionFactorFade_block_invoke(uint64_t a1)
{
  uint64_t v20 = a1;
  uint64_t v19 = a1;
  uint64_t result = _DisplayRampIsRunning(*(void *)(a1 + 32));
  if (result)
  {
    uint64_t v18 = 0;
    uint64_t v18 = (double *)(*(void *)(a1 + 32) + 1064);
    if (__DisplayFactorFade_IsRunning(v18)
      && (!*(_DWORD *)(a1 + 40) || __DisplayFactorFade_Direction((uint64_t)v18) == *(_DWORD *)(a1 + 40)))
    {
      int v17 = 0;
      if (_logHandle)
      {
        int v9 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        int v9 = inited;
      }
      int v17 = v9;
      char v16 = 2;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        os_log_t log = v17;
        os_log_type_t type = v16;
        __os_log_helper_16_0_0(v15);
        _os_log_debug_impl(&dword_1BA438000, log, type, "Cancelling right restiction factor ramp", v15, 2u);
      }
      *(_DWORD *)(*(void *)(a1 + 32) + 1056)  = *((_DWORD *)v18 + 5);
      __DisplayFactorFade_Cancel((uint64_t)v18);
    }
    double v14 = 0;
    double v14 = (double *)(*(void *)(a1 + 32) + 992);
    uint64_t result = __DisplayFactorFade_IsRunning(v14);
    if (result)
    {
      if (!*(_DWORD *)(a1 + 40)
        || (uint64_t result = __DisplayFactorFade_Direction((uint64_t)v14), result == *(_DWORD *)(a1 + 40)))
      {
        float v13 = 0;
        if (_logHandle)
        {
          int v5 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v4 = init_default_corebrightness_log();
          }
          int v5 = v4;
        }
        float v13 = v5;
        char v12 = 2;
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          int v2 = v13;
          os_log_type_t v3 = v12;
          __os_log_helper_16_0_0(v11);
          _os_log_debug_impl(&dword_1BA438000, v2, v3, "Cancelling left restriction factor ramp", v11, 2u);
        }
        *(_DWORD *)(*(void *)(a1 + 32) + 984)  = *((_DWORD *)v14 + 5);
        return __DisplayFactorFade_Cancel((uint64_t)v14);
      }
    }
  }
  return result;
}

BOOL __DisplayFactorFade_IsRunning(double *a1)
{
  return *a1 > 0.0;
}

uint64_t __DisplayFactorFade_Direction(uint64_t a1)
{
  if (__DisplayFactorFade_IsRunning((double *)a1))
  {
    if (*(float *)(a1 + 16) <= *(float *)(a1 + 24)) {
      return *(float *)(a1 + 16) < *(float *)(a1 + 24);
    }
    else {
      return 2;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __DisplayFactorFade_Cancel(uint64_t a1)
{
  if (__DisplayFactorFade_IsRunning((double *)a1))
  {
    *(_DWORD *)(a1 + 16)  = *(_DWORD *)(a1 + 20);
    *(void *)a1  = 0;
    if (*(void *)(a1 + 40)) {
      (*(void (**)(void))(a1 + 40))(*(void *)(a1 + 48));
    }
    char v3 = 1;
  }
  else
  {
    char v3 = 0;
  }
  return v3 & 1;
}

void DisplayCancelVirtualFade(uint64_t a1)
{
  uint64_t v8 = a1;
  float v1 = *(NSObject **)(a1 + 144);
  int v2 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  int v5 = __DisplayCancelVirtualFade_block_invoke;
  uint64_t v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = v8;
  disp_dispatch_sync(v1, &v2);
  DisplayCancelBrightnessFade(v8);
}

double __DisplayCancelVirtualFade_block_invoke(uint64_t a1)
{
  uint64_t v11 = a1;
  uint64_t v10 = a1;
  if (_DisplayRampIsRunning(*(void *)(a1 + 32)))
  {
    int v9 = 0;
    if (_logHandle)
    {
      int v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v5 = inited;
    }
    int v9 = v5;
    char v8 = 2;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      os_log_t log = v9;
      os_log_type_t type = v8;
      __os_log_helper_16_0_0(v7);
      _os_log_debug_impl(&dword_1BA438000, log, type, "cancel ramp", v7, 2u);
    }
    *(_DWORD *)(*(void *)(a1 + 32) + 1492)  = *(_DWORD *)(*(void *)(a1 + 32) + 1488);
    __DisplaySetVirtualBrightnessWithFadeInternal(*(void *)(a1 + 32), *(float *)(*(void *)(a1 + 32) + 1488), 0.0, 0, 0, 0);
    if (*(void *)(*(void *)(a1 + 32) + 1472)) {
      (*(void (**)(void))(*(void *)(a1 + 32) + 1472))(*(void *)(*(void *)(a1 + 32) + 1480));
    }
    double result = 0.0;
    *(void *)(*(void *)(a1 + 32) + 1440)  = 0;
  }
  return result;
}

void __DisplaySetVirtualBrightnessWithFadeInternal(uint64_t a1, float a2, float a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 380)) {
    a3  = *(float *)(a1 + 376);
  }
  if (a3 == 0.0)
  {
    float v14 = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1488));
    *(void *)(a1 + 1440)  = 0;
    *(float *)(a1 + 1460)  = v14;
    *(float *)(a1 + 1464)  = v14;
    *(float *)(a1 + 1456)  = v14;
    __DisplaySetLogicalBrightnessInternal((const void *)a1, 0x2000, *(float *)(a1 + 1256));
  }
  else
  {
    *(void *)(a1 + 1472)  = a5;
    *(void *)(a1 + 1480)  = a6;
    *(CFAbsoluteTime *)(a1 + 1448)  = CFAbsoluteTimeGetCurrent();
    *(double *)(a1 + 1440)  = a3;
    if (_logHandle)
    {
      uint64_t v11 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v11 = inited;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v20, *(void *)(a1 + 1440), *(void *)(a1 + 1448), *(void *)(a1 + 12480));
      _os_log_debug_impl(&dword_1BA438000, v11, OS_LOG_TYPE_DEBUG, "fadePeriod=%f startTime=%f display->fade.timer=%p\n", v20, 0x20u);
    }
    float v13 = (float)(a2 - *(float *)(a1 + 1488)) / a3;
    UpdateFrequency  = __DisplayGetUpdateFrequency(a1, v13);
    if (_logHandle)
    {
      int v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v8 = init_default_corebrightness_log();
      }
      int v9 = v8;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v19, COERCE__INT64(*(float *)(a1 + 1488)), COERCE__INT64(a2), COERCE__INT64(a3), COERCE__INT64(v13), COERCE__INT64(UpdateFrequency));
      _os_log_debug_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEBUG, "begin virtual ramp L: %0.2f -> L: %0.2f t: %f rate: %0.2f nits/s %0.2fhz", v19, 0x34u);
    }
    *(float *)(a1 + 1460)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, *(float *)(a1 + 1488));
    *(_DWORD *)(a1 + 1464)  = *(_DWORD *)(a1 + 1460);
    *(float *)(a1 + 1456)  = _DisplayLuminanceToPerceptualLuminanceInternal(a1, a2);
    if (_logHandle)
    {
      uint64_t v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v6 = init_default_corebrightness_log();
      }
      uint64_t v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v18, COERCE__INT64(*(float *)(a1 + 1488)), COERCE__INT64(a2), COERCE__INT64(*(float *)(a1 + 1464)), COERCE__INT64(*(float *)(a1 + 1456)));
      _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "display->brightness.Lvirtual=%f L=%f display->brightness.virtualFade.Pstart=%f display->brightness.virtualFade.Ptarget=%f\n", v18, 0x2Au);
    }
    __DisplayStartFade((unsigned char *)a1, 1.0 / UpdateFrequency);
  }
}

void __BLPropertyChangedCallback(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v14 = a1;
  CFTypeRef v13 = a2;
  uint64_t v12 = a3;
  if (a2)
  {
    if (CFEqual(v13, @"brightness-nits"))
    {
      int v3 = *(NSObject **)(v14 + 144);
      uint64_t v4 = MEMORY[0x1E4F143A8];
      int v5 = -1073741824;
      int v6 = 0;
      uint64_t v7 = ____BLPropertyChangedCallback_block_invoke;
      uint64_t v8 = &__block_descriptor_56_e5_v8__0l;
      uint64_t v9 = v14;
      CFTypeRef v10 = v13;
      uint64_t v11 = v12;
      dispatch_async(v3, &v4);
    }
  }
}

uint64_t __DisplayHasDCP_block_invoke(uint64_t a1)
{
  uint64_t v5 = a1;
  uint64_t v4 = a1;
  int v3 = 0;
  CFTypeRef v2 = IORegistryEntrySearchCFProperty(*(_DWORD *)(*(void *)(a1 + 32) + 80), "IOService", @"dcp-brightness-node", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  uint64_t result = _DisplayGetUint32FromCFDataAndRelease(v2, &v3);
  if (result) {
    DisplayHasDCP_hasDCP  = v3 != 0;
  }
  return result;
}

uint64_t DisplayGetCPMSAPLTable(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  int v13 = 0x20000000;
  int v14 = 32;
  uint64_t v15 = 0;
  float v1 = *(NSObject **)(a1 + 144);
  uint64_t v4 = (void (*)(void))MEMORY[0x1E4F143A8];
  int v5 = -1073741824;
  int v6 = 0;
  uint64_t v7 = __DisplayGetCPMSAPLTable_block_invoke;
  uint64_t v8 = &unk_1E621A490;
  uint64_t v9 = &v11;
  uint64_t v10 = v16;
  disp_dispatch_sync(v1, &v4);
  uint64_t v3 = v12[3];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_1BA5A552C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 40), 8);
  _Unwind_Resume(a1);
}

uint64_t __DisplayGetCPMSAPLTable_block_invoke(uint64_t a1)
{
  uint64_t result = __DisplayGetCPMSAPLTableInternal(*(void *)(a1 + 40));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = result;
  return result;
}

uint64_t __DisplayGetCPMSAPLTableInternal(uint64_t a1)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t v70 = a1;
  char v69 = 1;
  if (*(_DWORD *)(a1 + 108))
  {
    CFTypeRef v68 = 0;
    CFTypeRef v68 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v70 + 108), "IOService", @"power-lut-vbatt-cur-nominal", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    unsigned int v67 = 0;
    float v66 = 1.0;
    if ((_DisplayGetUint32FromCFDataAndRelease(v68, &v67) & 1) != 0
      && v67
      && *(float *)(v70 + 12176) != 0.0
      && (DisplayHasDCP(v70) & 1) != 0)
    {
      float v66 = *(float *)(v70 + 12176) / (float)((float)v67 / 1000.0);
      os_log_t v65 = 0;
      if (_logHandle)
      {
        os_log_t v32 = (os_log_t)_logHandle;
      }
      else
      {
        float v31 = (_COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log());
        os_log_t v32 = v31;
      }
      os_log_t v65 = v32;
      os_log_type_t v64 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        os_log_t log = v65;
        *(_DWORD *)os_log_type_t type = v64;
        buf  = v71;
        __os_log_helper_16_0_1_8_0((uint64_t)v71, COERCE__INT64(v66));
        _os_log_impl(&dword_1BA438000, v65, v64, "CPMS table scalar  = %f", v71, 0xCu);
      }
    }
    float v27 = &v63;
    int v63 = 0;
    size_t v62 = 0;
    float v61 = 0;
    BOOL v60 = 0;
    CFTypeRef v68 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v70 + 108), "IOService", @"power-lut-use-iofixed", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(v68, &v63)) {
      BOOL v60 = v63 != 0;
    }
    CFTypeRef v68 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v70 + 108), "IOService", @"power-lut-data-x", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(v68, &v63)) {
      *(_DWORD *)(v70 + 1660)  = v63;
    }
    else {
      char v69 = 0;
    }
    CFTypeRef v68 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v70 + 108), "IOService", @"power-lut-data-y", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(v68, &v63)) {
      *(_DWORD *)(v70 + 1656)  = v63;
    }
    else {
      char v69 = 0;
    }
    CFTypeRef v68 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v70 + 108), "IOService", @"power-lut-data-xindex", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v68)
    {
      float v61 = (int *)_DisplayCreateUint32ArrayFromCFData(v68, &v62);
      for (int i = 0; i < v62; ++i)
      {
        if (v60) {
          *(float *)(v70 + 1868 + 4 * i)  = (float)v61[i] / 65536.0;
        }
        else {
          *(float *)(v70 + 1868 + 4 * i)  = (float)v61[i];
        }
      }
      if (v61) {
        free(v61);
      }
      CFRelease(v68);
    }
    else
    {
      char v69 = 0;
    }
    CFTypeRef v68 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v70 + 108), "IOService", @"power-lut-data-yindex", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v68)
    {
      float v61 = (int *)_DisplayCreateUint32ArrayFromCFData(v68, &v62);
      if (v61)
      {
        for (int j = 0; j < v62; ++j)
          *(float *)(v70 + 1668 + 4 * j)  = (float)v61[j];
        free(v61);
      }
      else
      {
        char v69 = 0;
      }
      CFRelease(v68);
    }
    else
    {
      char v69 = 0;
    }
    CFTypeRef v68 = IORegistryEntrySearchCFProperty(*(_DWORD *)(v70 + 108), "IOService", @"power-lut-data-lut", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v68)
    {
      float v61 = (int *)_DisplayCreateUint32ArrayFromCFData(v68, &v62);
      if (v61)
      {
        for (unsigned int k = 0; k < *(_DWORD *)(v70 + 1656); ++k)
        {
          for (m  = 0; m < *(_DWORD *)(v70 + 1660); ++m)
          {
            *(float *)(v70 + 2068 + 200 * (int)k + 4 * (int)m)  = (float)v61[m
                                                                                            * *(_DWORD *)(v70 + 1656)
                                                                                            + k]
                                                                   * v66;
            if (v60) {
              *(float *)(v70 + 2068 + 200 * (int)k + 4 * (int)m)  = (float)(int)*(float *)(v70
            }
                                                                                            + 2068
                                                                                            + 200 * (int)k
                                                                                            + 4 * (int)m)
                                                                     / 65536.0;
          }
        }
        free(v61);
      }
      else
      {
        char v69 = 0;
      }
      CFRelease(v68);
    }
    else
    {
      char v69 = 0;
    }
  }
  else
  {
    char v69 = 0;
  }
  if ((v69 & 1) == 0)
  {
    for (n  = 0; n < 21; ++n)
    {
      for (iint i = 0; ii < 20; ++ii)
        *(_DWORD *)(v70 + 2068 + 200 * ii + 4 * n)  = CPMSPowerModel[20 * n + ii];
      *(float *)(v70 + 1868 + 4 * n)  = (float)NitIndexTable[n];
    }
    for (jint j = 0; jj < 20; ++jj)
      *(float *)(v70 + 1668 + 4 * jj)  = (float)APLIndexTable[jj];
    *(_DWORD *)(v70 + 1660)  = 21;
    *(_DWORD *)(v70 + 1656)  = 20;
  }
  id v52 = 0;
  unint64_t v25 = 0x1E4F1C000uLL;
  id v1 = objc_alloc(MEMORY[0x1E4F1CA48]);
  id v52 = (id)[v1 initWithCapacity:*(unsigned int *)(v70 + 1660)];
  id v51 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  id v50 = 0;
  id v2 = objc_alloc(MEMORY[0x1E4F1CA48]);
  id v50 = (id)[v2 initWithCapacity:*(unsigned int *)(v70 + 1656)];
  id v49 = 0;
  unint64_t v26 = 0x1E4F28000uLL;
  id v3 = objc_alloc(NSNumber);
  id v49 = (id)[v3 initWithUnsignedInt:*(unsigned int *)(v70 + 1660)];
  id v48 = 0;
  id v4 = objc_alloc(NSNumber);
  id v48 = (id)[v4 initWithUnsignedInt:*(unsigned int *)(v70 + 1656)];
  if (v52 && v51 && v50 && v49 && v48)
  {
    for (kunsigned int k = 0; kk < *(_DWORD *)(v70 + 1656); ++kk)
    {
      id v46 = 0;
      id v5 = objc_alloc(MEMORY[0x1E4F1CA48]);
      id v46 = (id)[v5 initWithCapacity:*(unsigned int *)(v70 + 1660)];
      for (mm  = 0; mm < *(_DWORD *)(v70 + 1660); ++mm)
      {
        id v44 = 0;
        id v6 = objc_alloc(NSNumber);
        id v44 = (id)[v6 initWithUnsignedInt:*(float *)(v70 + 2068 + 200 * (int)kk + 4 * (int)mm)];
        [v46 addObject:v44];
      }
      id v43 = 0;
      id v7 = [NSString alloc];
      id v43 = (id)objc_msgSend(v7, "initWithFormat:", @"%1.3f", *(float *)(v70 + 1668 + 4 * (int)kk));
      [v51 setValue:v46 forKey:v43];

      id v42 = 0;
      id v8 = objc_alloc(NSNumber);
      id v42 = (id)[v8 initWithUnsignedInt:*(float *)(v70 + 1668 + 4 * (int)kk)];
      [v50 addObject:v42];
    }
    for (nn  = 0; nn < *(_DWORD *)(v70 + 1660); ++nn)
    {
      id v40 = 0;
      id v9 = objc_alloc(NSNumber);
      id v40 = (id)[v9 initWithUnsignedInt:*(float *)(v70 + 1868 + 4 * (int)nn)];
      [v52 addObject:v40];
    }
    if (*(_DWORD *)(v70 + 1660)) {
      *(_DWORD *)(v70 + 1664)  = *(_DWORD *)(v70 + 1868 + 4 * (*(_DWORD *)(v70 + 1660) - 1));
    }
    uint64_t v39 = 0;
    id v10 = objc_alloc(MEMORY[0x1E4F1C9E8]);
    double v24 = &v12;
    uint64_t v39 = objc_msgSend(v10, "initWithObjectsAndKeys:", v52, @"Nits", v51, @"Watts", v49, @"TableSize", v50, @"APL", v48, @"APLSize", 0);
    if (v39)
    {
      char v69 = 1;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v70 + 192), @"CPMSAPLLUT", v39);
    }
    else
    {
      os_log_t oslog = 0;
      if (_logHandle)
      {
        os_log_t v23 = (os_log_t)_logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        os_log_t v23 = inited;
      }
      os_log_t oslog = v23;
      os_log_type_t v37 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        os_log_t v19 = oslog;
        *(_DWORD *)uint64_t v20 = v37;
        uint64_t v21 = (uint8_t *)v36;
        __os_log_helper_16_0_0(v36);
        _os_log_error_impl(&dword_1BA438000, v19, v20[0], "CPMS: problem loading budget dict", v21, 2u);
      }
    }
  }
  else
  {
    os_log_t v35 = 0;
    if (_logHandle)
    {
      os_log_t v18 = (os_log_t)_logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        int v17 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        int v17 = init_default_corebrightness_log();
      }
      os_log_t v18 = v17;
    }
    os_log_t v35 = v18;
    os_log_type_t v34 = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      os_log_t v14 = v35;
      *(_DWORD *)uint64_t v15 = v34;
      uint64_t v16 = v33;
      __os_log_helper_16_0_0(v33);
      _os_log_error_impl(&dword_1BA438000, v14, v15[0], "CPMS: problem loading table values", v33, 2u);
    }
  }
  if (v49) {

  }
  if (v48) {
  if (v50)
  }

  if (v52) {
  if (v51)
  }

  if (v69) {
    return v70 + 1656;
  }
  else {
    return 0;
  }
}

uint64_t __DisplayGetAPLColumn_block_invoke(uint64_t a1)
{
  uint64_t v5 = a1;
  uint64_t v4 = a1;
  int v3 = 0;
  CFTypeRef v2 = IORegistryEntrySearchCFProperty(*(_DWORD *)(*(void *)(a1 + 32) + 108), "IOService", @"cpms-apl-column", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  uint64_t result = _DisplayGetUint32FromCFDataAndRelease(v2, &v3);
  if (result) {
    DisplayGetAPLColumn_column  = v3;
  }
  return result;
}

uint64_t DisplayGetHDRAPLColumn(uint64_t a1)
{
  uint64_t v8 = a1;
  uint64_t v2 = MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  uint64_t v5 = __DisplayGetHDRAPLColumn_block_invoke;
  id v6 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v7 = a1;
  id v10 = &DisplayGetHDRAPLColumn_hdrToken;
  id v9 = &v2;
  if (DisplayGetHDRAPLColumn_hdrToken != -1) {
    dispatch_once(v10, v9);
  }
  return DisplayGetHDRAPLColumn_hdrColumn;
}

uint64_t __DisplayGetHDRAPLColumn_block_invoke(uint64_t a1)
{
  uint64_t v5 = a1;
  uint64_t v4 = a1;
  int v3 = 0;
  CFTypeRef v2 = IORegistryEntrySearchCFProperty(*(_DWORD *)(*(void *)(a1 + 32) + 108), "IOService", @"cpms-hdr-apl-column", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  uint64_t result = _DisplayGetUint32FromCFDataAndRelease(v2, &v3);
  if (result) {
    DisplayGetHDRAPLColumn_hdrColumn  = v3;
  }
  return result;
}

void DisplayUpdateCPMSBudget(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = a1;
  uint64_t v10 = a2;
  if (*(void *)(a1 + 144))
  {
    CFTypeRef v2 = *(NSObject **)(v11 + 144);
    int v3 = (void (*)(void))MEMORY[0x1E4F143A8];
    int v4 = -1073741824;
    int v5 = 0;
    id v6 = __DisplayUpdateCPMSBudget_block_invoke;
    uint64_t v7 = &__block_descriptor_48_e5_v8__0l;
    uint64_t v8 = v11;
    uint64_t v9 = v10;
    disp_dispatch_sync(v2, &v3);
  }
}

void __DisplayUpdateCPMSBudget_block_invoke(uint64_t a1)
{
}

void __DisplayUpdateCPMSBudgetInternal(float *a1, float *a2)
{
  os_log_type_t v37 = a1;
  char v36 = a2;
  float v35 = 0.0;
  if ((_BYTE)a1[3020]) {
    float v18 = v37[3018];
  }
  else {
    float v18 = fminf(v37[3018], v37[3019]);
  }
  float v35 = v18;
  unsigned int APLColumnOrDefault = DisplayGetAPLColumnOrDefault((uint64_t)v37, 0x64u);
  if (v36[1] != -1.0)
  {
    *((unsigned char *)v37 + 12080)  = 0;
    v37[3019]  = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)v37, APLColumnOrDefault, v36[1]);
    float v33 = 0.0;
    float v32 = 0.0;
    float v32 = v36[1];
    float v33 = v32 < v37[132] ? 7.0 : 2.5;
    _DisplaySetBrightnessWeakCapWithFade(v37, 1, v32, v33);
    if (*((void *)v37 + 2))
    {
      *(float *)&double v2 = v36[1];
      (*((void (**)(void, __CFString *, uint64_t))v37 + 2))(*((void *)v37 + 3), @"CPMS.UPO.Cap", [NSNumber numberWithFloat:v2]);
    }
  }
  if (*v36 != -1.0)
  {
    v37[3018]  = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)v37, APLColumnOrDefault, *v36);
    _DisplaySetBrightnessMaxPhysicalWithFade((uint64_t)v37, *v36, 0.0);
    if (*((void *)v37 + 2))
    {
      *(float *)&double v3 = *v36;
      (*((void (**)(void, __CFString *, uint64_t))v37 + 2))(*((void *)v37 + 3), @"CPMS.CLTM.Cap", [NSNumber numberWithFloat:v3]);
    }
  }
  HIDWORD(v4)  = 0;
  float v31 = 0.0;
  if ((_BYTE)v37[3020]) {
    float v17 = v37[3018];
  }
  else {
    float v17 = fminf(v37[3018], v37[3019]);
  }
  float v31 = v17;
  if (*((void *)v37 + 2))
  {
    BOOL v30 = 0;
    BOOL v16 = 0;
    if (v37[3018] < v37[3019]) {
      BOOL v16 = *v36 != -1.0;
    }
    BOOL v30 = v16;
    uint64_t v29 = 0;
    if (v16 && *(float *)&__DisplayUpdateCPMSBudgetInternal_prevCap > v31
      || (__DisplayUpdateCPMSBudgetInternal_prevMinWasCLTM & 1) != 0
      && *(float *)&__DisplayUpdateCPMSBudgetInternal_prevCap < v31)
    {
      uint64_t v15 = *MEMORY[0x1E4F1CFC8];
    }
    else
    {
      uint64_t v15 = *MEMORY[0x1E4F1CFD0];
    }
    uint64_t v29 = v15;
    __DisplayUpdateCPMSBudgetInternal_prevMinWasCLTM  = v30;
    __DisplayUpdateCPMSBudgetInternal_prevCap  = LODWORD(v31);
    (*((void (**)(void, __CFString *, uint64_t))v37 + 2))(*((void *)v37 + 3), @"CPMSCurrentCap", v15);
  }
  if (v36[2] != -1.0 && (*((unsigned char *)v37 + 1517) & 1) != 0)
  {
    HDRunsigned int APLColumn = DisplayGetHDRAPLColumn((uint64_t)v37);
    v37[3017]  = __DisplayPhysicalBrightnessToPowerInternal((uint64_t)v37, HDRAPLColumn, v36[2]);
    v37[3017]  = fmaxf(v37[3017], v31);
    float v27 = 0;
    if (_logHandle)
    {
      os_log_t v14 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      os_log_t v14 = inited;
    }
    float v27 = v14;
    char v26 = 1;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      os_log_t log = v27;
      os_log_type_t type = v26;
      __os_log_helper_16_0_0(v25);
      _os_log_impl(&dword_1BA438000, log, type, "CPMS:HDR cap changed: Resetting HDR Nit Cap", v25, 2u);
    }
    v37[3026]  = v36[2];
    *((_DWORD *)v37 + 64)  = (int)(float)(v37[3026] * 65536.0);
    if (v35 >= v31)
    {
      if ((_BYTE)v37[3045])
      {
        __DisplaySetHDRFactorWithFade((uint64_t)v37, 0, 0, v37[3026] / v37[416], 1.0);
      }
      else
      {
        v37[3027]  = v36[2];
        float v24 = _DisplayComputeEDRNitsCap((uint64_t)v37);
        SetLibEDRBrightness((uint64_t)v37, v37[375], v24, v37[298], v37[3132]);
        *((_DWORD *)v37 + 64)  = (int)(float)(v37[3027] * 65536.0);
      }
    }
  }
  if (*((unsigned char *)v37 + 1517))
  {
    if (v35 < v31)
    {
      float v22 = 0;
      if (_logHandle)
      {
        uint64_t v9 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v8 = init_default_corebrightness_log();
        }
        uint64_t v9 = v8;
      }
      float v22 = v9;
      char v21 = 1;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        id v6 = v22;
        os_log_type_t v7 = v21;
        __os_log_helper_16_0_0(v20);
        _os_log_impl(&dword_1BA438000, v6, v7, "CPMS:CLTM/UPO cap raised: Resetting HDR Nit Cap", v20, 2u);
      }
      if ((_BYTE)v37[3045])
      {
        int v38 = *((_DWORD *)v37 + 3046);
        __DisplaySetHDRFactorWithFade((uint64_t)v37, 0, 0, v37[3026] / v37[416], v37[3046]);
      }
      else
      {
        v37[3027]  = v37[3026];
        float v19 = _DisplayComputeEDRNitsCap((uint64_t)v37);
        SetLibEDRBrightness((uint64_t)v37, v37[375], v19, v37[298], v37[3132]);
        *((_DWORD *)v37 + 64)  = (int)(float)(v37[3027] * 65536.0);
      }
    }
  }
  else
  {
    float v23 = 0.0;
    float v23 = (float)(((_BYTE)v37[3045] & 1) == 1);
    uint64_t v10 = v37;
    float v5 = DisplayPowerToPhysicalBrightness((uint64_t)v37, APLColumnOrDefault, v31);
    __DisplaySetHDRFactorWithFade((uint64_t)v10, 0, 0, v5 / v37[416], v23);
  }
  if (v36[2] != -1.0)
  {
    if (*((void *)v37 + 2))
    {
      *(float *)&double v4 = v36[2];
      (*((void (**)(void, __CFString *, uint64_t))v37 + 2))(*((void *)v37 + 3), @"CPMS.HDR.Cap", [NSNumber numberWithFloat:v4]);
    }
  }
}

float DisplayPhysicalBrightnessToPower(uint64_t a1, unsigned int a2, float a3)
{
  return __DisplayPhysicalBrightnessToPowerInternal(a1, a2, a3);
}

float __DisplayPhysicalBrightnessToPowerInternal(uint64_t a1, unsigned int a2, float a3)
{
  if (!*(_DWORD *)(a1 + 1660)) {
    return 0.0;
  }
  int APLIndex = DisplayGetAPLIndex(a1, a2);
  int IndexFromValue = __DisplayGetIndexFromValue(0, *(_DWORD *)(a1 + 1660) - 1, a1 + 1868, a3);
  float PercentageFromIndex = __DisplayGetPercentageFromIndex(IndexFromValue, *(_DWORD *)(a1 + 1660) - 1, (float *)(a1 + 1868), a3);
  if (IndexFromValue == *(_DWORD *)(a1 + 1660) - 1) {
    return *(float *)(a1 + 2068 + 200 * APLIndex + 4 * IndexFromValue);
  }
  else {
    return *(float *)(a1 + 2068 + 200 * APLIndex + 4 * IndexFromValue)
  }
         + (float)(PercentageFromIndex
                 * (float)(*(float *)(a1 + 2068 + 200 * APLIndex + 4 * (IndexFromValue + 1))
                         - *(float *)(a1 + 2068 + 200 * APLIndex + 4 * IndexFromValue)));
}

void __DisplayRelease(uint64_t a1)
{
  uint64_t v9 = a1;
  uint64_t v8 = a1;
  if (([MEMORY[0x1E4F56678] isCPMSSupported] & 1) == 1)
  {
    if (*(void *)(v8 + 12128))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12128));
      *(void *)(v8 + 12128)  = 0;
    }
    if (*(void *)(v8 + 12136))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12136));
      *(void *)(v8 + 12136)  = 0;
    }
    if (*(void *)(v8 + 12144))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12144));
      *(void *)(v8 + 12144)  = 0;
    }
    if (*(void *)(v8 + 12152))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12152));
      *(void *)(v8 + 12152)  = 0;
    }
    if (*(void *)(v8 + 12160))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12160));
      *(void *)(v8 + 12160)  = 0;
    }
    if (*(void *)(v8 + 12168))
    {
      CFRelease(*(CFTypeRef *)(v8 + 12168));
      *(void *)(v8 + 12168)  = 0;
    }
    if (*(void *)(v8 + 12112))
    {
      dispatch_release(*(dispatch_object_t *)(v8 + 12112));
      *(void *)(v8 + 12112)  = 0;
    }
  }
  if (*(void *)(v8 + 72))
  {
    free(*(void **)(v8 + 72));
    *(void *)(v8 + 72)  = 0;
    *(_DWORD *)(v8 + 64)  = 0;
  }
  if (*(void *)(v8 + 144))
  {
    id v1 = *(NSObject **)(v8 + 144);
    double v2 = (void (*)(void))MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    float v5 = ____DisplayRelease_block_invoke;
    id v6 = &__block_descriptor_40_e5_v8__0l;
    uint64_t v7 = v8;
    disp_dispatch_sync(v1, &v2);
  }
  if (*(void *)(v8 + 120))
  {
    dispatch_release(*(dispatch_object_t *)(v8 + 120));
    *(void *)(v8 + 120)  = 0;
  }
  if (*(void *)(v8 + 144))
  {
    dispatch_release(*(dispatch_object_t *)(v8 + 144));
    *(void *)(v8 + 144)  = 0;
  }
  if (*(void *)(v8 + 168))
  {
    dispatch_release(*(dispatch_object_t *)(v8 + 168));
    *(void *)(v8 + 168)  = 0;
  }
  if (*(void *)(v8 + 152))
  {
    dispatch_release(*(dispatch_object_t *)(v8 + 152));
    *(void *)(v8 + 152)  = 0;
  }
  if (*(void *)(v8 + 12536)) {
    CFRelease(*(CFTypeRef *)(v8 + 12536));
  }
  if (*(void *)(v8 + 12720)) {
    CFRelease(*(CFTypeRef *)(v8 + 12720));
  }
  CBEDRServerRemoveDisplay(*(_DWORD *)(v8 + 12592));
  *(_DWORD *)(v8 + 12596)  = 0;
  if (*(void *)(v8 + 328))
  {

    *(void *)(v8 + 328)  = 0;
  }
  if (*(void *)(v8 + 264))
  {

    *(void *)(v8 + 264)  = 0;
  }
}

uint64_t brightnessThread(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a1;
  mach_error_t v12 = 0;
  memset(__b, 0, sizeof(__b));
  while (1)
  {
    __b[0].msgh_size  = 72;
    __b[0].msgh_local_port  = __brightnessPort;
    mach_error_t v12 = mach_msg_receive(__b);
    if (v12) {
      break;
    }
    memcpy(msg, __b, sizeof(msg));
    while (1)
    {
      BOOL v3 = 0;
      if ((__b[2].msgh_remote_port & 4) == 0)
      {
        BOOL v3 = 0;
        if (*(double *)&__b[1].msgh_voucher_port == 0.0) {
          BOOL v3 = mach_msg(msg, 258, 0, 0x48u, __brightnessPort, 0, 0) == 0;
        }
      }
      if (!v3) {
        break;
      }
      memcpy(__b, msg, sizeof(__b));
    }
    __DisplaySetPhysicalBrightnessLegacyOnThread(*(float **)&__b[1].msgh_bits, *(unint64_t *)&__b[2].msgh_bits, __b[2].msgh_remote_port, *(float *)&__b[1].msgh_remote_port, *(double *)&__b[1].msgh_voucher_port);
    if (*(double *)&__b[1].msgh_voucher_port != 0.0 && *(float *)&__b[1].msgh_remote_port != 0.0) {
      usleep((*(double *)&__b[1].msgh_voucher_port * 1000000.0));
    }
  }
  uint64_t v10 = 0;
  if (_logHandle)
  {
    uint64_t v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v7 = inited;
  }
  uint64_t v10 = v7;
  char v9 = 16;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    os_log_t log = v10;
    os_log_type_t type = v9;
    id v1 = mach_error_string(v12);
    __os_log_helper_16_2_1_8_34((uint64_t)v14, (uint64_t)v1);
    _os_log_error_impl(&dword_1BA438000, log, type, "brightnessThread: mach_msg_receive() failed: %{public}s\n", v14, 0xCu);
  }
  return v13;
}

uint64_t __os_log_helper_16_2_1_8_34(uint64_t result, uint64_t a2)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 1;
  *(unsigned char *)(result + 2)  = 34;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  return result;
}

void __DisplaySetPhysicalBrightnessLegacyOnThread(float *a1, unint64_t a2, int a3, float a4, double a5)
{
  kern_return_t v34;
  int v35;
  unint64_t v36;
  double v37;
  float v38;
  float *v39;
  uint8_t v40[32];
  uint8_t v41[48];
  uint8_t v42[32];
  CFNumberRef v43;
  CFNumberRef v44;
  CFNumberRef v45;
  uint64_t v46;

  id v46 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = a1;
  int v38 = a4;
  os_log_type_t v37 = a5;
  char v36 = a2;
  float v35 = a3;
  os_log_type_t v34 = 0;
  id v43 = 0;
  id v44 = 0;
  float v45 = 0;
  int valuePtr = 0;
  int v32 = 0;
  int v31 = 0;
  float v30 = a4;
  pthread_mutex_lock(&__brightnessLock);
  os_log_t v29 = 0;
  if (_logHandle)
  {
    char v21 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    char v21 = inited;
  }
  os_log_t v29 = v21;
  os_log_type_t v28 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v42, v36, __brightnessTS);
    _os_log_debug_impl(&dword_1BA438000, v29, v28, "timeStamp=%lld __brightnessTS=%lld\n", v42, 0x16u);
  }
  if (v36 > __brightnessTS)
  {
    __brightnessTS  = v36;
    float v30 = v30 * v39[87];
    if (v39[87] != 0.0)
    {
      if (v30 >= v39[85])
      {
        if (v30 > v39[86]) {
          float v30 = v39[86];
        }
      }
      else
      {
        float v30 = v39[85];
      }
    }
    int valuePtr = (int)(ceil((float)(v30 * (float)(*((_DWORD *)v39 + 310) - *((_DWORD *)v39 + 309))))
                   + (double)*((int *)v39 + 309));
    if (valuePtr != *((_DWORD *)v39 + 311))
    {
      CFAllocatorRef v5 = CFGetAllocator(v39);
      id v43 = CFNumberCreate(v5, kCFNumberSInt32Type, &valuePtr);
      if (v43)
      {
        int v31 = (int)(v37 * 65536.0);
        CFAllocatorRef v6 = CFGetAllocator(v39);
        id v44 = CFNumberCreate(v6, kCFNumberSInt32Type, &v31);
        if (v44)
        {
          CFDictionarySetValue((CFMutableDictionaryRef)__brightnessDict, (const void *)__brightnessKeys, v43);
          CFDictionarySetValue((CFMutableDictionaryRef)__brightnessDict, off_1E9F4DCB8[0], v44);
          if ((v35 & 2) != 0)
          {
            CFDictionaryRemoveValue((CFMutableDictionaryRef)__brightnessDict, off_1E9F4DCC0);
          }
          else
          {
            int v32 = (int)(ceil((float)(v39[84] * (float)(*((_DWORD *)v39 + 310) - *((_DWORD *)v39 + 309))))
                      + (double)*((int *)v39 + 309));
            CFAllocatorRef v7 = CFGetAllocator(v39);
            float v45 = CFNumberCreate(v7, kCFNumberSInt32Type, &v32);
            if (!v45) {
              goto LABEL_61;
            }
            CFDictionarySetValue((CFMutableDictionaryRef)__brightnessDict, off_1E9F4DCC0, v45);
          }
          os_log_type_t v34 = IORegistryEntrySetCFProperties(*((_DWORD *)v39 + 20), (CFTypeRef)__brightnessDict);
          if (!v34)
          {
            if (valuePtr || !*((_DWORD *)v39 + 311))
            {
              if (valuePtr && !*((_DWORD *)v39 + 311))
              {
                os_log_t oslog = 0;
                if (_logHandle)
                {
                  uint64_t v15 = _logHandle;
                }
                else
                {
                  uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                  uint64_t v15 = v14;
                }
                os_log_t oslog = v15;
                os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                {
                  mach_error_t v12 = oslog;
                  os_log_type_t v13 = v23;
                  __os_log_helper_16_0_0(v22);
                  _os_log_impl(&dword_1BA438000, v12, v13, "Brightness ON.\n", v22, 2u);
                }
              }
            }
            else
            {
              float v27 = 0;
              if (_logHandle)
              {
                float v19 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT) {
                  uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else {
                  uint64_t v18 = init_default_corebrightness_log();
                }
                float v19 = v18;
              }
              float v27 = v19;
              os_log_type_t v26 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v16 = v27;
                os_log_type_t v17 = v26;
                __os_log_helper_16_0_0(v25);
                _os_log_impl(&dword_1BA438000, v16, v17, "Brightness OFF.\n", v25, 2u);
              }
            }
            *((_DWORD *)v39 + 311)  = valuePtr;
            if (_logHandle)
            {
              uint64_t v11 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v10 = init_default_corebrightness_log();
              }
              uint64_t v11 = v10;
            }
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_4_0((uint64_t)v41, COERCE__INT64(v30), COERCE__INT64(v39[87]), valuePtr, *(uint64_t *)&v37, v31);
              _os_log_debug_impl(&dword_1BA438000, v11, OS_LOG_TYPE_DEBUG, "brightness=%f factor=%f deviceBrightness=%d fadePeriod=%f fixedFadePeriod=0x%08x\n", v41, 0x2Cu);
            }
            if (v39[86] < 1.0)
            {
              if (_logHandle)
              {
                char v9 = _logHandle;
              }
              else
              {
                uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                char v9 = v8;
              }
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_0_2_8_0_8_0((uint64_t)v40, COERCE__INT64(v30), COERCE__INT64(v39[86]));
                _os_log_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEFAULT, "Device brightness %f based on max brightness of %f\n", v40, 0x16u);
              }
            }
          }
        }
      }
    }
  }
LABEL_61:
  pthread_mutex_unlock(&__brightnessLock);
  if (v43) {
    CFRelease(v43);
  }
  if (v44) {
    CFRelease(v44);
  }
  if (v45) {
    CFRelease(v45);
  }
}

uint64_t __os_log_helper_16_0_5_8_0_8_0_4_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 4;
  *(_DWORD *)(result + 40)  = a6;
  return result;
}

uint64_t _DisplayGetGlobalScalarDisplayParams(io_registry_entry_t a1, float *a2, float *a3)
{
  io_registry_entry_t v10 = a1;
  char v9 = a2;
  uint64_t v8 = a3;
  char v7 = 0;
  if (a2)
  {
    if (v8)
    {
      CFTypeRef v6 = 0;
      CFTypeRef v6 = IORegistryEntrySearchCFProperty(v10, "IOService", @"luminance-ratio", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
      unsigned int v5 = 0;
      if (_DisplayGetUint32FromCFDataAndRelease(v6, &v5))
      {
        CFTypeRef v6 = IORegistryEntrySearchCFProperty(v10, "IOService", @"vbatt-current", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
        unsigned int v4 = 0;
        if ((_DisplayGetUint32FromCFDataAndRelease(v6, &v4) & 1) != 0 && v4 != -1 && v5 != -1)
        {
          unsigned int v5 = ((v5 & 0xFF00) << 8) + (v5 << 24) + ((v5 & 0xFF0000) >> 8) + ((v5 & 0xFF000000) >> 24);
          unsigned int v4 = ((v4 & 0xFF00) << 8) + (v4 << 24) + ((v4 & 0xFF0000) >> 8) + ((v4 & 0xFF000000) >> 24);
          *char v9 = (float)v4 / 16777000.0;
          *uint64_t v8 = (float)v5 / 16777000.0;
          char v7 = 1;
        }
      }
    }
  }
  return v7 & 1;
}

uint64_t _DisplayGetScalerForKeyAndIndex(io_registry_entry_t a1, const __CFString *a2, unsigned int a3, float *a4, float a5)
{
  io_registry_entry_t v14 = a1;
  CFStringRef v13 = a2;
  unsigned int v12 = a3;
  uint64_t v11 = a4;
  float v10 = a5;
  char v9 = 0;
  CFTypeRef cf = 0;
  CFTypeRef cf = IORegistryEntrySearchCFProperty(a1, "IOService", a2, (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  size_t v7 = 0;
  CFTypeRef v6 = 0;
  if (cf) {
    CFTypeRef v6 = _DisplayCreateUint32ArrayFromCFData(cf, &v7);
  }
  if (v6 && v7)
  {
    if (v7 <= v12) {
      float *v11 = (float)*(unsigned int *)v6 / v10;
    }
    else {
      float *v11 = (float)*(unsigned int *)&v6[4 * v12] / v10;
    }
    char v9 = 1;
  }
  if (v6) {
    free(v6);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v9 & 1;
}

float _DisplayCalculateGlobalScalar(uint64_t a1, float *a2)
{
  __dst[7]  = *(const void **)MEMORY[0x1E4F143B8];
  float v11 = 1.0;
  if (a1 && a2)
  {
    float v10 = *a2 / a2[2];
    if (v10 > a2[3])
    {
      float v2 = 1.0 - (float)(a2[5] * (float)(v10 - a2[3]));
      float numValues_4 = v2;
      if ((float)(v2 * a2[1]) < a2[4]) {
        float numValues_4 = a2[4] / a2[1];
      }
      a2[6]  = numValues_4;
      float v11 = numValues_4;
    }
    memcpy(__dst, &off_1E621A630, 0x38uLL);
    memset(__b, 0, sizeof(__b));
    unsigned int v4 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    __b[0]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, a2 + 2);
    __b[1]  = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 3);
    __b[2]  = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 4);
    __b[3]  = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 5);
    __b[4]  = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 6);
    __b[5]  = CFNumberCreate(*v4, kCFNumberFloatType, a2);
    __b[6]  = CFNumberCreate(*v4, kCFNumberFloatType, a2 + 1);
    char v8 = 1;
    for (int i = 0; i < 7; ++i)
    {
      if (!__b[i])
      {
        char v8 = 0;
        break;
      }
    }
    if (v8)
    {
      value  = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __dst, __b, 7, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      if (value)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 192), @"BrightnessGlobalScalar", value);
        CFRelease(value);
      }
    }
    for (int j = 0; j < 7; ++j)
    {
      if (__b[j]) {
        CFRelease(__b[j]);
      }
    }
  }
  return v11;
}

UInt8 *_DisplayCreateUint32ArrayFromCFData(const void *a1, size_t *a2)
{
  size_t v5 = 0;
  buffer  = 0;
  if (a1)
  {
    CFTypeID v3 = CFGetTypeID(a1);
    if (v3 == CFDataGetTypeID())
    {
      size_t v5 = CFDataGetLength((CFDataRef)a1) / 4uLL;
      buffer  = (UInt8 *)malloc_type_calloc(v5, 4uLL, 0x100004052888210uLL);
      if (buffer)
      {
        v8.location  = 0;
        v8.length  = 4 * v5;
        CFDataGetBytes((CFDataRef)a1, v8, buffer);
      }
      else
      {
        size_t v5 = 0;
      }
    }
  }
  *a2  = v5;
  return buffer;
}

CFMutableDictionaryRef _DisplayCreateRestrictionDictionarySinglePoint(io_registry_entry_t a1)
{
  io_registry_entry_t v18 = a1;
  float v17 = 0.0;
  float v16 = -1.0;
  float v15 = 0.0;
  float v14 = 0.0;
  float v13 = -1.0;
  float valuePtr = 0.0;
  float v11 = -1.0;
  float v10 = 0.0;
  float v9 = 0.0;
  capacity_4  = -1.0;
  capacity  = 0;
  CFMutableDictionaryRef theDict = 0;
  value  = 0;
  value  = (void *)IORegistryEntrySearchCFProperty(a1, "IOService", @"min-restriction-factor", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  unsigned int v4 = 0;
  if (_DisplayGetUint32FromCFDataAndRelease(value, &v4))
  {
    float v1 = (float)v4 / 1000.0;
    float v17 = v1;
    value  = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", @"min-restriction-enableth", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(value, &v4)) {
      float v15 = (float)v4;
    }
    else {
      float v17 = 0.0;
    }
    value  = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", @"min-restriction-disableth", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(value, &v4)) {
      float v14 = (float)v4;
    }
    else {
      float v17 = 0.0;
    }
    if (v17 > 0.0) {
      capacity += 3;
    }
    value  = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", @"min-restriction-disableth2", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(value, &v4)) {
      float v13 = (float)v4;
    }
  }
  value  = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", @"max-restriction-factor", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
  if (_DisplayGetUint32FromCFDataAndRelease(value, &v4))
  {
    float v2 = (float)v4 / 1000.0;
    float valuePtr = v2;
    value  = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", @"max-restriction-enableth", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(value, &v4)) {
      float v10 = (float)v4;
    }
    else {
      float valuePtr = 0.0;
    }
    value  = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", @"max-restriction-disableth", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(value, &v4)) {
      float v9 = (float)v4;
    }
    else {
      float valuePtr = 0.0;
    }
    if (valuePtr > 0.0) {
      capacity += 3;
    }
    value  = (void *)IORegistryEntrySearchCFProperty(v18, "IOService", @"max-restriction-disableth2", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (_DisplayGetUint32FromCFDataAndRelease(value, &v4)) {
      capacity_4  = (float)v4;
    }
  }
  if (capacity > 0)
  {
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], capacity, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (theDict)
    {
      if (valuePtr > 0.0)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"max_Factor", value);
          CFRelease(value);
        }
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v10);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"max_enableTh", value);
          CFRelease(value);
        }
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v9);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"max_disableTh", value);
          CFRelease(value);
        }
        if (v11 > 0.0)
        {
          value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v11);
          if (value)
          {
            CFDictionaryAddValue(theDict, @"max_Factor_AABOff", value);
            CFRelease(value);
          }
        }
        if (capacity_4 > 0.0)
        {
          value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &capacity_4);
          if (value)
          {
            CFDictionaryAddValue(theDict, @"max_disableTh_highbound", value);
            CFRelease(value);
          }
        }
      }
      if (v17 > 0.0)
      {
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v17);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"min_Factor", value);
          CFRelease(value);
        }
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v15);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"min_enableTh", value);
          CFRelease(value);
        }
        value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v14);
        if (value)
        {
          CFDictionaryAddValue(theDict, @"min_disableTh", value);
          CFRelease(value);
        }
        if (v16 > 0.0)
        {
          value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v16);
          if (value)
          {
            CFDictionaryAddValue(theDict, @"min_Factor_AABOff", value);
            CFRelease(value);
          }
        }
        if (v13 > 0.0)
        {
          value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v13);
          if (value)
          {
            CFDictionaryAddValue(theDict, @"min_disableTh_lowbound", value);
            CFRelease(value);
          }
        }
      }
    }
  }
  return theDict;
}

void __DisplayResetLogTimer(uint64_t a1, char a2)
{
  if (a2)
  {
    if (*(void *)(a1 + 12576))
    {
      dispatch_release(*(dispatch_object_t *)(a1 + 12576));
      *(void *)(a1 + 12576)  = 0;
    }
  }
  else if (!*(void *)(a1 + 12576))
  {
    *(void *)(a1 + 12576)  = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(a1 + 144));
    if (*(void *)(a1 + 12576))
    {
      dispatch_set_context(*(dispatch_object_t *)(a1 + 12576), (void *)a1);
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 12576), 0, 1000000000 * *(int *)(a1 + 12584), 0);
      dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 12576), (dispatch_function_t)__DisplayLogTimerCallback);
      dispatch_resume(*(dispatch_object_t *)(a1 + 12576));
      *(unsigned char *)(a1 + 12568)  = 1;
    }
  }
}

uint64_t __DisplayLogTimerCallback(uint64_t result)
{
  if (result)
  {
    if (*(unsigned char *)(result + 12568)) {
      *(unsigned char *)(result + 12568)  = 0;
    }
    else {
      return __DisplayCommitReport(result, 0);
    }
  }
  return result;
}

void __SetPreStrobeState_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(a1 + 32) + 16))
  {
    float v8 = *(float *)(*(void *)(a1 + 32) + 1520);
    if (*(unsigned char *)(a1 + 40)) {
      float v8 = 1.0;
    }
    id v1 = objc_alloc(NSNumber);
    *(float *)&double v2 = v8;
    size_t v7 = (void *)[v1 initWithFloat:v2];
    CFTypeRef v6 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v7, @"Scaler", 0);

    (*(void (**)(void, __CFString *, void *))(*(void *)(a1 + 32) + 16))(*(void *)(*(void *)(a1 + 32) + 24), @"UpdateDigitalDimmingBrightnessScaler", v6);
    if (_logHandle)
    {
      unsigned int v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      unsigned int v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v9, COERCE__INT64(v8));
      _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "Pre-strobe: setting Scalar=%f\n", v9, 0xCu);
    }
  }
}

void SetIOMFBBrightness(unsigned char *a1, int a2, char a3)
{
  uint64_t v25 = (uint64_t)a1;
  int valuePtr = a2;
  char v23 = a3 & 1;
  if (a1[321])
  {
    if (*(unsigned char *)(v25 + 232) & 1) == 0 || (v23)
    {
      if (*(void *)(v25 + 120))
      {
        CFTypeID v3 = *(NSObject **)(v25 + 120);
        uint64_t block = MEMORY[0x1E4F143A8];
        int v16 = -1073741824;
        int v17 = 0;
        io_registry_entry_t v18 = __SetIOMFBBrightness_block_invoke;
        float v19 = &__block_descriptor_45_e5_v8__0l;
        uint64_t v20 = v25;
        int v21 = valuePtr;
        char v22 = v23 & 1;
        dispatch_async(v3, &block);
      }
      else
      {
        SendSyncDBVNotification(v25, v23 & 1, (float)valuePtr / 65536.0);
      }
      *(_DWORD *)(v25 + 140)  = valuePtr;
    }
    else
    {
      *(_DWORD *)(v25 + 236)  = valuePtr;
    }
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator((CFTypeRef)v25);
    CFTypeRef cf = CFNumberCreate(v4, kCFNumberSInt32Type, &valuePtr);
    if (!cf) {
      return;
    }
    if (*(_DWORD *)(v25 + 108))
    {
      if (*(_DWORD *)(v25 + 136))
      {
        int v13 = valuePtr;
        if (*(_DWORD *)(v25 + 140) != valuePtr)
        {
          if ((*(unsigned char *)(v25 + 232) & 1) != 0 && (v23 & 1) == 0)
          {
            *(_DWORD *)(v25 + 236)  = v13;
            CFRelease(cf);
            return;
          }
          if (*(void *)(v25 + 120))
          {
            CFRetain(cf);
            size_t v5 = *(NSObject **)(v25 + 120);
            uint64_t v6 = MEMORY[0x1E4F143A8];
            int v7 = -1073741824;
            int v8 = 0;
            float v9 = __SetIOMFBBrightness_block_invoke_2;
            uint64_t v10 = &__block_descriptor_48_e5_v8__0l;
            uint64_t v11 = v25;
            CFTypeRef v12 = cf;
            dispatch_async(v5, &v6);
          }
          else
          {
            IORegistryEntrySetCFProperty(*(_DWORD *)(v25 + 108), @"IOMFBBrightnessLevel", cf);
          }
          *(_DWORD *)(v25 + 140)  = v13;
        }
      }
    }
    CFRelease(cf);
  }
}

void __SetIOMFBBrightness_block_invoke(uint64_t a1)
{
}

void __SetIOMFBBrightness_block_invoke_2(uint64_t a1)
{
}

void SetWiggledDigitalDimmingScalar(uint64_t a1, float a2)
{
  uint64_t v11 = a1;
  float v10 = a2;
  if (a2 == 1.0) {
    SetWiggledDigitalDimmingScalar_direction  = -1;
  }
  double v2 = *(NSObject **)(v11 + 144);
  uint64_t block = MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  uint64_t v6 = __SetWiggledDigitalDimmingScalar_block_invoke;
  int v7 = &__block_descriptor_44_e5_v8__0l;
  uint64_t v8 = v11;
  float v9 = v10;
  dispatch_async(v2, &block);
}

void __SetBLDriverNitsValue_block_invoke(uint64_t a1)
{
  uint64_t v3 = a1;
  uint64_t v8 = a1;
  uint64_t v7 = a1;
  if (*(void *)(*(void *)(a1 + 32) + 16))
  {
    float v6 = 0.0;
    float v6 = *(float *)(v3 + 40) / *(float *)(*(void *)(v3 + 32) + 1532);
    if (*(float *)(*(void *)(v3 + 32) + 1520) != v6)
    {
      id v1 = objc_alloc(NSNumber);
      *(float *)&double v2 = v6;
      id v5 = (id)[v1 initWithFloat:v2];
      id v4 = 0;
      id v4 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v5, @"Scaler", 0);

      (*(void (**)(void, __CFString *, id))(*(void *)(v3 + 32) + 16))(*(void *)(*(void *)(v3 + 32) + 24), @"UpdateDigitalDimmingBrightnessScaler", v4);
      *(float *)(*(void *)(v3 + 32) + 1520)  = v6;
    }
  }
}

float __SetBLDriverNitsValue_block_invoke_2(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 16))
  {
    float result = *(float *)(*(void *)(a1 + 32) + 1520);
    if (result != 1.0)
    {
      id v2 = objc_alloc(NSNumber);
      LODWORD(v3)  = 1.0;
      float v6 = (void *)[v2 initWithFloat:v3];
      id v5 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v6, @"Scaler", 0);

      (*(void (**)(void, __CFString *, id))(*(void *)(a1 + 32) + 16))(*(void *)(*(void *)(a1 + 32) + 24), @"UpdateDigitalDimmingBrightnessScaler", v5);
      float result = 1.0;
      *(float *)(*(void *)(a1 + 32) + 1520)  = 1.0;
    }
  }
  return result;
}

float __SetBLDriverNitsValue_block_invoke_3(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 16))
  {
    float result = *(float *)(*(void *)(a1 + 32) + 1520);
    if (result != 1.0)
    {
      id v2 = objc_alloc(NSNumber);
      LODWORD(v3)  = 1.0;
      float v6 = (void *)[v2 initWithFloat:v3];
      id v5 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v6, @"Scaler", 0);

      (*(void (**)(void, __CFString *, id))(*(void *)(a1 + 32) + 16))(*(void *)(*(void *)(a1 + 32) + 24), @"UpdateDigitalDimmingBrightnessScaler", v5);
      float result = 1.0;
      *(float *)(*(void *)(a1 + 32) + 1520)  = 1.0;
    }
  }
  return result;
}

void __SetBLDriverNitsValue_block_invoke_4(uint64_t a1)
{
  uint64_t v4 = a1;
  uint64_t v9 = a1;
  uint64_t v8 = a1;
  if (*(void *)(*(void *)(a1 + 32) + 16))
  {
    float v7 = 0.0;
    float v1 = 1.0;
    if (*(float *)(*(void *)(v4 + 32) + 1520) != 1.0) {
      float v1 = 1.0;
    }
    float v7 = v1;
    id v2 = objc_alloc(NSNumber);
    *(float *)&double v3 = v7;
    id v6 = (id)[v2 initWithFloat:v3];
    id v5 = 0;
    id v5 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v6, @"Scaler", 0);
    (*(void (**)(void, __CFString *, id))(*(void *)(v4 + 32) + 16))(*(void *)(*(void *)(v4 + 32) + 24), @"UpdateDigitalDimmingBrightnessScaler", v5);
    *(float *)(*(void *)(v4 + 32) + 1520)  = v7;
  }
}

void __SetWiggledDigitalDimmingScalar_block_invoke(uint64_t a1)
{
  uint64_t v3 = a1;
  uint64_t v8 = a1;
  uint64_t v7 = a1;
  if (*(void *)(*(void *)(a1 + 32) + 16))
  {
    float v6 = 0.0;
    float v6 = *(float *)(v3 + 40);
    if (v6 == *(float *)(*(void *)(v3 + 32) + 1520))
    {
      float v6 = v6 + (float)(0.000001 * (float)SetWiggledDigitalDimmingScalar_direction);
      SetWiggledDigitalDimmingScalar_direction  = -SetWiggledDigitalDimmingScalar_direction;
    }
    id v1 = objc_alloc(NSNumber);
    *(float *)&double v2 = v6;
    id v5 = (id)[v1 initWithFloat:v2];
    id v4 = 0;
    id v4 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v5, @"Scaler", 0);
    (*(void (**)(void, __CFString *, id))(*(void *)(v3 + 32) + 16))(*(void *)(*(void *)(v3 + 32) + 24), @"UpdateDigitalDimmingBrightnessScaler", v4);
    *(float *)(*(void *)(v3 + 32) + 1520)  = v6;
  }
}

void __DisplaySetPhysicalBrightnessLegacy(float *a1, mach_port_t a2, float a3, double a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  int v21 = a1;
  float v20 = a3;
  double v19 = a4;
  mach_port_t v18 = a2;
  uint64_t v17 = mach_absolute_time();
  os_log_t v16 = 0;
  if (_logHandle)
  {
    CFTypeRef v12 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    CFTypeRef v12 = inited;
  }
  os_log_t v16 = v12;
  os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v25, COERCE__INT64(v20), *(uint64_t *)&v19);
    _os_log_debug_impl(&dword_1BA438000, v16, v15, "brightness=%f fadePeriod=%lf\n", v25, 0x16u);
  }
  if (v18)
  {
    if (_logHandle)
    {
      float v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v5 = init_default_corebrightness_log();
      }
      float v6 = v5;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v22, v17);
      _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "Calling __DisplaySetPhysicalBrightnessLegacyOnThread directly at ts=%lld\n", v22, 0xCu);
    }
    __DisplaySetPhysicalBrightnessLegacyOnThread(v21, v17, v18, v20, v19);
  }
  else
  {
    mach_error_t v14 = 0;
    memset(__b, 0, sizeof(__b));
    __b[0].msgh_bits  = 19;
    __b[0].msgh_size  = 64;
    __b[0].msgh_remote_port  = __brightnessPort;
    __b[0].msgh_local_port  = 0;
    __b[0].msgh_id  = 1112688980;
    *(void *)&__b[1].msgh_bits  = v21;
    *(float *)&__b[1].msgh_remote_port  = v20;
    *(double *)&__b[1].msgh_voucher_port  = v19;
    *(void *)&__b[2].msgh_bits  = v17;
    __b[2].msgh_remote_port  = v18;
    if (_logHandle)
    {
      float v10 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v9 = init_default_corebrightness_log();
      }
      float v10 = v9;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v24, v17);
      _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "Queueing brightness at ts=%lld\n", v24, 0xCu);
    }
    mach_error_t v14 = mach_msg_send(__b);
    if (v14)
    {
      if (_logHandle)
      {
        uint64_t v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v7 = init_default_corebrightness_log();
        }
        uint64_t v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        id v4 = mach_error_string(v14);
        __os_log_helper_16_2_1_8_34((uint64_t)v23, (uint64_t)v4);
        _os_log_error_impl(&dword_1BA438000, v8, OS_LOG_TYPE_ERROR, "mach_msg_send() failed: %{public}s\n", v23, 0xCu);
      }
    }
  }
}

uint64_t __DisplayReportToCA(uint64_t a1, uint64_t a2, double a3)
{
  LODWORD(a3)  = *(_DWORD *)(a1 + 1288);
  return +[CBAnalytics displayMaxCurrent:](CBAnalytics, "displayMaxCurrent:", a3, a2, a1);
}

uint64_t _DisplayAdaptiveDimmingLeftCallback(uint64_t a1)
{
  if (!a1) {
    __assert_rtn("_DisplayAdaptiveDimmingLeftCallback", "Display.m", 10126, "callbackData");
  }
  return +[CBAnalytics autoDimLeave:CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 888)];
}

void __DisplayCPMSHDRCallback(uint64_t a1)
{
  if (a1)
  {
    if (DisplayHasDCP(a1))
    {
      __DisplayCPMSHDRCallbackDCPStage1((NSObject **)a1);
    }
    else
    {
      double Current = CFAbsoluteTimeGetCurrent();
      double v4 = Current - *(double *)(a1 + 12088);
      PowerAccumulator  = __DisplayGetPowerAccumulator(a1);
      float v1 = (float)(unint64_t)(PowerAccumulator - *(void *)(a1 + 12096)) / (1000.0 * v4);
      InstantPower  = v1;
      if (v1 == 0.0)
      {
        InstantPower  = (float)(unint64_t)__DisplayGetInstantPower(a1);
      }
      else
      {
        *(void *)(a1 + 12096)  = PowerAccumulator;
        *(double *)(a1 + 12088)  = Current;
      }
      if (*(unsigned char *)(a1 + 12081)) {
        __DisplayEvaluateCPMSHDRPowerConstraint(a1, InstantPower);
      }
      *(unsigned char *)(a1 + 12081)  = 1;
    }
  }
}

uint64_t __DisplayGetInstantPower(uint64_t a1)
{
  uint64_t v9 = a1;
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  int v6 = 0x20000000;
  int v7 = 32;
  unint64_t v8 = 0x8000000000000000;
  if (*(void *)(a1 + 12168))
  {
    if (*(void *)(v9 + 12160))
    {
      Samples  = (const void *)IOReportCreateSamples();
      if (Samples)
      {
        IOReportIterate();
        CFRelease(Samples);
      }
    }
  }
  uint64_t v2 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v2;
}

void __DisplayEvaluateCPMSHDRPowerConstraint(uint64_t a1, float a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  float CPMSPowerConstraint = __DisplayGetCPMSPowerConstraint(a1);
  HDRunsigned int APLColumn = DisplayGetHDRAPLColumn(a1);
  float v4 = __DisplayPhysicalBrightnessToPowerInternal(a1, HDRAPLColumn, *(float *)(a1 + 1544));
  if ((*(unsigned char *)(a1 + 12082) & 1) == 0 && CPMSPowerConstraint < v4) {
    *(unsigned char *)(a1 + 12082)  = 1;
  }
  if (_logHandle)
  {
    uint64_t v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v3 = inited;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v9, COERCE__INT64(a2), COERCE__INT64(CPMSPowerConstraint), COERCE__INT64(v4));
    _os_log_debug_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEBUG, "CPMS: Current Power Output:%f Budget Constraint:%f/%f", v9, 0x20u);
  }
  if (a2 > CPMSPowerConstraint) {
    __DisplayUpdateHDRCap(a1);
  }
}

void __DisplayCPMSHDRCallbackDCPStage1(NSObject **a1)
{
  char v23 = a1;
  v19[0]  = 0;
  v19[1]  = v19;
  int v20 = 0x20000000;
  int v21 = 32;
  uint64_t v22 = 0;
  v15[0]  = 0;
  v15[1]  = v15;
  int v16 = 0x20000000;
  int v17 = 32;
  uint64_t v18 = 0;
  v11[0]  = 0;
  v11[1]  = v11;
  int v12 = 0x20000000;
  int v13 = 32;
  CFAbsoluteTime Current = 0.0;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFRetain(v23);
  float v1 = v23[19];
  uint64_t block = MEMORY[0x1E4F143A8];
  int v3 = -1073741824;
  int v4 = 0;
  uint64_t v5 = ____DisplayCPMSHDRCallbackDCPStage1_block_invoke;
  int v6 = &unk_1E621A6D8;
  int v7 = v15;
  uint64_t v10 = v23;
  unint64_t v8 = v19;
  uint64_t v9 = v11;
  dispatch_async(v1, &block);
  _Block_object_dispose(v11, 8);
  _Block_object_dispose(v15, 8);
  _Block_object_dispose(v19, 8);
}

void sub_1BA5AB024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,int a26,_Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v27 - 88), 8);
  _Block_object_dispose((const void *)(v27 - 56), 8);
  _Unwind_Resume(a1);
}

void __DisplayUpdateHDRCap(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  float CPMSPowerConstraint = __DisplayGetCPMSPowerConstraint(a1);
  unsigned int APLColumnOrDefault = DisplayGetAPLColumnOrDefault(a1, 0x64u);
  float v5 = DisplayPowerToPhysicalBrightness(a1, APLColumnOrDefault, CPMSPowerConstraint);
  float v4 = fmaxf(*(float *)(a1 + 12108) * *(float *)(a1 + 12188), v5);
  if (*(float *)(a1 + 12108) > v5)
  {
    if (_logHandle)
    {
      int v3 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v3 = inited;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_2_8_0_8_0((uint64_t)v9, COERCE__INT64(*(float *)(a1 + 12108)), COERCE__INT64(v4));
      _os_log_impl(&dword_1BA438000, v3, OS_LOG_TYPE_INFO, "CPMS: Current HDR Power consumption is too high. Lowering from %f to %f", v9, 0x16u);
    }
    if (*(unsigned char *)(a1 + 12180))
    {
      __DisplaySetHDRFactorWithFade(a1, 0, 0, v4 / *(float *)(a1 + 1664), 1.0);
    }
    else
    {
      *(float *)(a1 + 12108)  = v4;
      float v1 = _DisplayComputeEDRNitsCap(a1);
      SetLibEDRBrightness(a1, *(float *)(a1 + 1500), v1, *(float *)(a1 + 1192), *(float *)(a1 + 12528));
    }
  }
}

float __DisplaySetHDRFactorWithFade(uint64_t a1, void (*a2)(uint64_t), uint64_t a3, float a4, float a5)
{
  if (*(unsigned char *)(a1 + 380)) {
    a5  = *(float *)(a1 + 376);
  }
  *(double *)(a1 + 12192)  = a5;
  if (*(double *)(a1 + 12192) == 0.0)
  {
    *(float *)(a1 + 12216)  = a4;
    *(float *)(a1 + 12208)  = a4;
    *(float *)(a1 + 12212)  = a4;
    *(float *)(a1 + 12108)  = a4 * fmaxf(*(float *)(a1 + 1664), *(float *)(a1 + 1536));
    float v9 = _DisplayComputeEDRNitsCap(a1);
    SetLibEDRBrightness(a1, *(float *)(a1 + 1500), v9, *(float *)(a1 + 1192), *(float *)(a1 + 12528));
    if (a2) {
      a2(a3);
    }
    float result = *(float *)(a1 + 12108) * 65536.0;
    *(_DWORD *)(a1 + 256)  = (int)result;
  }
  else
  {
    float v8 = *(float *)(a1 + 12108) / fmaxf(*(float *)(a1 + 1664), *(float *)(a1 + 1544));
    if (!float_equal(v8, a4))
    {
      *(void *)(a1 + 12232)  = a2;
      *(void *)(a1 + 12240)  = a3;
      *(CFAbsoluteTime *)(a1 + 12200)  = CFAbsoluteTimeGetCurrent();
      double v7 = *(float *)(a1 + 12488);
      if (v7 == 0.0) {
        double v7 = 0.100000001;
      }
      *(float *)(a1 + 12212)  = v8;
      *(float *)(a1 + 12216)  = v8;
      *(float *)(a1 + 12208)  = a4;
      float v6 = v7;
      __DisplayStartFade((unsigned char *)a1, v6);
    }
  }
  return result;
}

void __DisplayCPMSHDRCallbackDCPStage2(uint64_t a1, uint64_t a2, unint64_t a3, double a4)
{
  float v4 = (float)(unint64_t)(a2 - *(void *)(a1 + 12096)) / (1000.0 * (a4 - *(double *)(a1 + 12088)));
  float v5 = v4;
  if (v4 == 0.0)
  {
    float v5 = (float)a3;
  }
  else
  {
    *(void *)(a1 + 12096)  = a2;
    *(double *)(a1 + 12088)  = a4;
  }
  if (*(unsigned char *)(a1 + 12081)) {
    __DisplayEvaluateCPMSHDRPowerConstraint(a1, v5);
  }
  *(unsigned char *)(a1 + 12081)  = 1;
}

uint64_t __os_log_helper_16_0_4_8_0_8_0_4_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 4;
  *(_DWORD *)(result + 30)  = a5;
  return result;
}

id getMLModelClass_3()
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLModelClass_softClass_3;
  uint64_t v13 = getMLModelClass_softClass_3;
  if (!getMLModelClass_softClass_3)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    float v5 = __getMLModelClass_block_invoke_3;
    float v6 = &unk_1E6219058;
    double v7 = &v9;
    __getMLModelClass_block_invoke_3((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

id getMLArrayBatchProviderClass_3()
{
  uint64_t v9 = 0;
  uint64_t v10 = &v9;
  int v11 = 1342177280;
  int v12 = 32;
  uint64_t v8 = getMLArrayBatchProviderClass_softClass_3;
  uint64_t v13 = getMLArrayBatchProviderClass_softClass_3;
  if (!getMLArrayBatchProviderClass_softClass_3)
  {
    uint64_t v2 = MEMORY[0x1E4F143A8];
    int v3 = -1073741824;
    int v4 = 0;
    float v5 = __getMLArrayBatchProviderClass_block_invoke_3;
    float v6 = &unk_1E6219058;
    double v7 = &v9;
    __getMLArrayBatchProviderClass_block_invoke_3((uint64_t)&v2);
  }
  id v1 = (id)v10[3];
  _Block_object_dispose(&v9, 8);

  return v1;
}

uint64_t __getMLFeatureValueClass_block_invoke_3(uint64_t a1)
{
  CoreMLLibrary_4();
  Class Class = objc_getClass("MLFeatureValue");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLFeatureValueClass_softClass_3  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t CoreMLLibrary_4()
{
  uint64_t v1 = CoreMLLibraryCore_4();
  if (!v1) {
    abort_report_np();
  }
  return v1;
}

uint64_t CoreMLLibraryCore_4()
{
  if (!CoreMLLibraryCore_frameworkLibrary_4) {
    __CoreMLLibraryCore_block_invoke_4();
  }
  return CoreMLLibraryCore_frameworkLibrary_4;
}

uint64_t __CoreMLLibraryCore_block_invoke_4()
{
  uint64_t result = _sl_dlopen();
  CoreMLLibraryCore_frameworkLibrary_4  = result;
  return result;
}

uint64_t __getMLModelClass_block_invoke_3(uint64_t a1)
{
  CoreMLLibrary_4();
  Class Class = objc_getClass("MLModel");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLModelClass_softClass_3  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLPredictionOptionsClass_block_invoke_3(uint64_t a1)
{
  CoreMLLibrary_4();
  Class Class = objc_getClass("MLPredictionOptions");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLPredictionOptionsClass_softClass_3  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __getMLArrayBatchProviderClass_block_invoke_3(uint64_t a1)
{
  CoreMLLibrary_4();
  Class Class = objc_getClass("MLArrayBatchProvider");
  uint64_t result = a1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)  = Class;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    uint64_t result = abort_report_np();
  }
  getMLArrayBatchProviderClass_softClass_3  = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void AABC::SetDeviceInSleeve(NSObject **this, char a2)
{
  int v11 = (AABC *)this;
  char v10 = a2 & 1;
  uint64_t v2 = this[509];
  uint64_t block = MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  float v6 = ___ZN4AABC17SetDeviceInSleeveEb_block_invoke;
  double v7 = &__block_descriptor_41_e5_v8__0l;
  uint64_t v8 = v11;
  char v9 = a2 & 1;
  dispatch_sync(v2, &block);
}

void AABCFactoryFunction(AABC *a1, const __CFAllocator *a2)
{
  if (AABCFactoryFunction::pred != -1) {
    dispatch_once(&AABCFactoryFunction::pred, &__block_literal_global_14);
  }
  AABC::alloc(a1, a2);
}

os_log_t __AABCFactoryFunction_block_invoke()
{
  os_log_t result = os_log_create("com.apple.CoreBrightness.AABC", "default");
  _logHandle  = (uint64_t)result;
  return result;
}

void AABC::alloc(AABC *this, const __CFAllocator *a2)
{
}

AABC *AABC::alloc(AABC *this, const __CFAllocator *a2, AAB::UpdateCurveStrategy *a3)
{
  int v12 = this;
  int v11 = a2;
  char v10 = (AABC *)CFAllocatorAllocate(this, 4184, 0);
  if (v10)
  {
    double v7 = v10;
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CFB0];
    p_byte7  = &byte7;
    char v9 = CFUUIDGetConstantUUIDWithBytes(v3, 0x96u, 0x5Fu, 0xC3u, 0xCBu, 0x16u, 0xB8u, 0x48u, 0x2Fu, 0xA6u, 0xC6u, 0x48u, 0x63u, 7u, 0x52u, 0x16u, 0xE9u);
    AABC::AABC(v7, v9, v11);
    return v7;
  }
  else
  {
    float v6 = v11;
    if (v11) {
      (*(void (**)(AAB::UpdateCurveStrategy *))(*(void *)v6 + 8))(v6);
    }
  }
  return v10;
}

void AABC::AABC(AABC *this, const __CFUUID *a2, AAB::UpdateCurveStrategy *a3)
{
}

{
  CBSoftWakeAABCDelegate *v3;
  uint64_t inited;
  NSObject *v5;
  uint8_t v7[8];
  uint64_t v8;

  uint64_t v8 = *MEMORY[0x1E4F143B8];
  AAB::AAB(this, a3);
  *(void *)this  = &unk_1F13F12D0;
  *((unsigned char *)this + 136)  = 0;
  *((unsigned char *)this + 144)  = 0;
  *((void *)this + 19)  = 0;
  *((unsigned char *)this + 160)  = 0;
  *((unsigned char *)this + 161)  = 0;
  AABC::ALSFilter::ALSFilter((AABC *)((char *)this + 168));
  AABC::ALSFilter::ALSFilter((AABC *)((char *)this + 216));
  *((unsigned char *)this + 264)  = 0;
  *((void *)this + 35)  = 0;
  *((_DWORD *)this + 72)  = 0;
  *((void *)this + 37)  = 0;
  std::bitset<3ul>::bitset[abi:ne180100]((void *)this + 38, 0);
  *((float *)this + 78)  = -1.0;
  *((unsigned char *)this + 316)  = 0;
  *((_DWORD *)this + 81)  = 17;
  *((_DWORD *)this + 92)  = 0;
  *((_DWORD *)this + 93)  = 0;
  *((_DWORD *)this + 94)  = 1;
  *((unsigned char *)this + 400)  = 0;
  *((unsigned char *)this + 401)  = 0;
  *((void *)this + 51)  = 0;
  *((void *)this + 53)  = 0;
  *((void *)this + 54)  = 0;
  *((unsigned char *)this + 440)  = 0;
  *((unsigned char *)this + 441)  = 0;
  *((unsigned char *)this + 442)  = 0;
  *((unsigned char *)this + 443)  = 0;
  *((unsigned char *)this + 444)  = 0;
  *((unsigned char *)this + 445)  = 0;
  *((_DWORD *)this + 112)  = 0;
  *((unsigned char *)this + 452)  = 0;
  *((void *)this + 58)  = 0;
  *((void *)this + 59)  = 0;
  *((void *)this + 60)  = 0;
  *((_DWORD *)this + 122)  = 0;
  *((_DWORD *)this + 123)  = 0;
  *((_DWORD *)this + 124)  = 0;
  *((unsigned char *)this + 504)  = 0;
  *((unsigned char *)this + 505)  = 0;
  *((unsigned char *)this + 506)  = 0;
  *((_DWORD *)this + 127)  = 0;
  *((_DWORD *)this + 128)  = 1;
  *((_DWORD *)this + 129)  = 1;
  *((_DWORD *)this + 130)  = 0;
  *((_DWORD *)this + 131)  = 0;
  *((_DWORD *)this + 132)  = 0;
  *((float *)this + 133)  = 0.5;
  *((_DWORD *)this + 134)  = 1138819072;
  *((float *)this + 135)  = -1.0;
  *((float *)this + 136)  = -1.0;
  *((float *)this + 137)  = -1.0;
  *((_DWORD *)this + 138)  = 1138819072;
  *((_DWORD *)this + 141)  = 0;
  *((_DWORD *)this + 142)  = 1;
  *((_DWORD *)this + 147)  = 255;
  *((void *)this + 74)  = 0;
  *((_DWORD *)this + 150)  = 0;
  *((_DWORD *)this + 151)  = 0;
  *((_DWORD *)this + 152)  = 0;
  *((_DWORD *)this + 154)  = 0;
  *((_DWORD *)this + 155)  = 0;
  *((_DWORD *)this + 156)  = 0;
  *((unsigned char *)this + 628)  = 0;
  memset((char *)this + 632, 0, 0x28uLL);
  *((_DWORD *)this + 168)  = 0;
  *((_DWORD *)this + 169)  = 0;
  *((void *)this + 85)  = 0;
  *((void *)this + 86)  = 0;
  *((void *)this + 87)  = 1045220557;
  *((_DWORD *)this + 176)  = 0;
  *((float *)this + 177)  = 5.0;
  *((_DWORD *)this + 178)  = 1124859904;
  *((_DWORD *)this + 179)  = 1140457472;
  *((float *)this + 180)  = 5.0;
  *((_DWORD *)this + 181)  = 1124859904;
  *((_DWORD *)this + 182)  = 1140457472;
  *((_DWORD *)this + 183)  = 5;
  *((unsigned char *)this + 1552)  = 0;
  *((_DWORD *)this + 719)  = 0;
  *((_DWORD *)this + 720)  = 0;
  *((_DWORD *)this + 721)  = 0;
  *((unsigned char *)this + 2888)  = 0;
  *((unsigned char *)this + 3320)  = 0;
  *((unsigned char *)this + 3401)  = 0;
  *((_DWORD *)this + 851)  = 1;
  *((unsigned char *)this + 3416)  = 0;
  *((unsigned char *)this + 3417)  = 0;
  *((unsigned char *)this + 3418)  = 1;
  *((_DWORD *)this + 855)  = 0;
  *((_OWORD *)this + 214)  = AABC::_defaultSettings;
  *((_OWORD *)this + 215)  = xmmword_1BA613310;
  *((_DWORD *)this + 864)  = 3;
  *((unsigned char *)this + 3460)  = 0;
  *((void *)this + 489)  = 0;
  *((unsigned char *)this + 3937)  = 1;
  *((float *)this + 985)  = 3.0;
  *((_DWORD *)this + 986)  = 0;
  *((_DWORD *)this + 987)  = 0;
  *((_DWORD *)this + 988)  = 0;
  *((_DWORD *)this + 989)  = 0;
  *((_DWORD *)this + 990)  = 0;
  *((_DWORD *)this + 991)  = 0;
  *((_DWORD *)this + 992)  = 0;
  *((void *)this + 497)  = 0;
  *((_DWORD *)this + 996)  = 0;
  *((_DWORD *)this + 997)  = 1045220557;
  *((_DWORD *)this + 998)  = 1045220557;
  *((_DWORD *)this + 999)  = 981668463;
  *((_DWORD *)this + 1000)  = 1036831949;
  *((_DWORD *)this + 1001)  = 1036831949;
  *((_DWORD *)this + 1002)  = 0;
  *((void *)this + 502)  = 0;
  *((_DWORD *)this + 1006)  = 0;
  *((_DWORD *)this + 1008)  = 0;
  *((void *)this + 505)  = 1;
  *((_DWORD *)this + 1012)  = 0;
  *((void *)this + 509)  = 0;
  *((unsigned char *)this + 4160)  = 0;
  *((void *)this + 521)  = 0;
  *((unsigned char *)this + 4176)  = 0;
  _logHandle  = (uint64_t)os_log_create("com.apple.CoreBrightness.AABC", "default");
  if (_logHandle)
  {
    int v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v5 = inited;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v7, 4);
    _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "[%x]: ", v7, 8u);
  }
  memset((char *)this + 632, 0, 0x28uLL);
  *((_DWORD *)this + 158)  = 0;
  *((_DWORD *)this + 167)  = 0;
  *((_DWORD *)this + 166)  = *((_DWORD *)this + 167);
  *((_DWORD *)this + 162)  = 0;
  *((_DWORD *)this + 163)  = 0;
  *((_DWORD *)this + 164)  = 0;
  *((_DWORD *)this + 165)  = 0;
  *((unsigned char *)this + 3368)  = 0;
  *((void *)this + 422)  = 0;
  *((void *)this + 424)  = 0x4072C00000000000;
  *((void *)this + 423)  = 0;
  *((_DWORD *)this + 843)  = 3;
  *((unsigned char *)this + 4084)  = 0;
  *((_DWORD *)this + 1022)  = 0;
  *((_DWORD *)this + 1020)  = 0;
  *((unsigned char *)this + 4092)  = 0;
  memset((char *)this + 3704, 0, 0xD0uLL);
  *((_DWORD *)this + 926)  = -1;
  *((void *)this + 488)  = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:1];
  *((void *)this + 490)  = objc_alloc_init(AABCHistograms);
  *((void *)this + 491)  = objc_alloc_init(ALSOcclusionStats);
  if (+[CBSoftWakeAABCDelegate isSupported]) {
    CFAllocatorRef v3 = objc_alloc_init(CBSoftWakeAABCDelegate);
  }
  else {
    CFAllocatorRef v3 = 0;
  }
  *((void *)this + 507)  = v3;
  AABC::UpdateState((uint64_t)this, 0);
}

void AABC::operator delete(void *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    uint64_t v2 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v4, (uint64_t)a1);
    _os_log_impl(&dword_1BA438000, v2, OS_LOG_TYPE_INFO, "%p", v4, 0xCu);
  }
  (*(void (**)(void *))(*(void *)a1 + 32))(a1);
  CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1);
}

void sub_1BA5B1798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void AAB::AAB(AAB *this, AAB::UpdateCurveStrategy *a2)
{
  *(void *)this  = &unk_1F13F12A0;
  *((_DWORD *)this + 2)  = 1070315492;
  *((_DWORD *)this + 3)  = 1031954742;
  *((_DWORD *)this + 4)  = 1070315492;
  *((_DWORD *)this + 5)  = 0;
  *((_DWORD *)this + 6)  = 1157234688;
  *((_DWORD *)this + 7)  = 1133903872;
  *((float *)this + 8)  = -1.0;
  *((float *)this + 9)  = -1.0;
  *((void *)this + 8)  = a2;
  std::mutex::mutex[abi:ne180100]((void *)this + 9);
}

AABC::ALSFilter *AABC::ALSFilter::ALSFilter(AABC::ALSFilter *this)
{
  return this;
}

{
  AABC::ALSFilter *result;

  std::vector<float>::vector[abi:ne180100](this);
  os_log_t result = this;
  *((_WORD *)this + 12)  = 0;
  *((_WORD *)this + 20)  = 0;
  return result;
}

void *std::bitset<3ul>::bitset[abi:ne180100](void *a1, char a2)
{
  return a1;
}

{
  std::__bitset<1ul,3ul>::__bitset(a1, a2);
  return a1;
}

void AABC::UpdateState(uint64_t a1, int a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = a1;
  int v28 = a2;
  if (*(_DWORD *)(a1 + 368) != a2)
  {
    os_log_t v27 = 0;
    if (_logHandle)
    {
      int v16 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v16 = inited;
    }
    os_log_t v27 = v16;
    os_log_type_t v26 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_2_3_4_0_8_32_8_32((uint64_t)v31, 1, (uint64_t)(&kAABStateStr)[*(unsigned int *)(a1 + 368)], (uint64_t)(&kAABStateStr)[v28]);
      _os_log_debug_impl(&dword_1BA438000, v27, v26, "[%x]: _state=%s -> state=%s", v31, 0x1Cu);
    }
    *(_DWORD *)(a1 + 368)  = v28;
    int v25 = 0;
    char v24 = 0;
    unsigned int v2 = *(_DWORD *)(a1 + 368);
    if (v2)
    {
      uint64_t v4 = v2;
      char v3 = 1;
    }
    else
    {
      uint64_t v4 = *(unsigned int *)(a1 + 368);
      char v3 = 0;
    }
    if ((v3 & 1) == 0)
    {
      switch(v4)
      {
        case 0:
          char v23 = 0;
          if (_logHandle)
          {
            mach_error_t v14 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v13 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v13 = init_default_corebrightness_log();
            }
            mach_error_t v14 = v13;
          }
          char v23 = v14;
          char v22 = 1;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
          {
            int v11 = v23;
            os_log_type_t v12 = v22;
            __os_log_helper_16_0_0(v21);
            _os_log_impl(&dword_1BA438000, v11, v12, "Cancel ramp, auto-brightness off", v21, 2u);
          }
          AABC::CancelRamp((AABC *)a1);
          v25 |= 0x11u;
          *(_DWORD *)(a1 + 632)  = 0;
          *(_DWORD *)(a1 + 668)  = 0;
          char v24 = 1;
          break;
        case 1:
          int v20 = 0;
          if (_logHandle)
          {
            char v10 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v9 = init_default_corebrightness_log();
            }
            char v10 = v9;
          }
          int v20 = v10;
          char v19 = 1;
          if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
          {
            double v7 = v20;
            os_log_type_t v8 = v19;
            __os_log_helper_16_0_0(v18);
            _os_log_impl(&dword_1BA438000, v7, v8, "Cancel ramp, manual brightness (slider moving)", v18, 2u);
          }
          AABC::CancelRamp((AABC *)a1);
          v25 |= 0x11u;
          if (*(void *)(a1 + 464)) {
            *(_DWORD *)(a1 + 632)  = *(_DWORD *)(*(void *)(a1 + 464) + 48);
          }
          *(_DWORD *)(a1 + 668)  = 3;
          break;
        case 2:
          if (*(void *)(a1 + 464))
          {
            *(_DWORD *)(a1 + 4004)  = *(_DWORD *)(a1 + 3996);
            PerceptualLuminanceThresholding::SetPthresholdBrighten(*(void *)(a1 + 4016), *(float *)(a1 + 4004));
            *(_DWORD *)(a1 + 3992)  = 1045220557;
            PerceptualLuminanceThresholding::SetPthresholdDim(*(void *)(a1 + 4016), *(float *)(a1 + 3992));
            v25 |= 0x11u;
            if (*(_DWORD *)(a1 + 600))
            {
              *(_DWORD *)(a1 + 632)  = *(_DWORD *)(*(void *)(a1 + 464) + 44);
              *(_DWORD *)(a1 + 668)  = 2;
            }
            else
            {
              *(_DWORD *)(a1 + 632)  = *(_DWORD *)(*(void *)(a1 + 464) + 40);
              *(_DWORD *)(a1 + 668)  = 1;
            }
          }
          break;
        case 3:
          if (*(void *)(a1 + 464))
          {
            *(_DWORD *)(a1 + 4004)  = *(_DWORD *)(a1 + 4000);
            PerceptualLuminanceThresholding::SetPthresholdBrighten(*(void *)(a1 + 4016), *(float *)(a1 + 4004));
            if (*(_DWORD *)(a1 + 3436) == 4 || *(_DWORD *)(a1 + 3436) == 5) {
              *(_DWORD *)(a1 + 3992)  = 1045220557;
            }
            else {
              *(_DWORD *)(a1 + 3992)  = *(_DWORD *)(a1 + 3988);
            }
            PerceptualLuminanceThresholding::SetPthresholdDim(*(void *)(a1 + 4016), *(float *)(a1 + 3992));
            if (*(float *)(a1 + 416) <= 0.0)
            {
              *(float *)(a1 + 416)  = 1.0;
              *(_DWORD *)(a1 + 368)  = 0;
              *(_DWORD *)(a1 + 676)  = 1;
            }
            else
            {
              v25 |= 0x11u;
            }
            *(_DWORD *)(a1 + 632)  = *(_DWORD *)(*(void *)(a1 + 464) + 48);
            *(_DWORD *)(a1 + 668)  = 3;
          }
          break;
        case 4:
          v25 |= 0x11u;
          if (*(void *)(a1 + 464)) {
            *(_DWORD *)(a1 + 632)  = *(_DWORD *)(*(void *)(a1 + 464) + 48);
          }
          *(_DWORD *)(a1 + 668)  = 3;
          break;
        default:
          JUMPOUT(0);
      }
    }
    if ((v24 & 1) == 0 && *(_DWORD *)(a1 + 640) && *(float *)(a1 + 632) < 0.05) {
      *(_DWORD *)(a1 + 632)  = 1045220557;
    }
    if (v25) {
      AABC::UpdateALSState((CFDictionaryRef *)a1, v25);
    }
    if (_logHandle)
    {
      float v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v5 = init_default_corebrightness_log();
      }
      float v6 = v5;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_4_0_8_0_8_0_8_0((uint64_t)v30, 2, COERCE__INT64(*(float *)(a1 + 632)), COERCE__INT64(*(float *)(a1 + 4004)), COERCE__INT64(*(float *)(a1 + 3992)));
      _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "[%x]: _als.interval=%f _Pthreshold_brighten=%f _Pthreshold_dim=%f", v30, 0x26u);
    }
  }
}

void AABC::ALSFilter::~ALSFilter(AABC::ALSFilter *this)
{
}

{
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)this);
}

void AAB::~AAB(AAB *this)
{
  *(void *)this  = &unk_1F13F12A0;
  if (*((void *)this + 8))
  {
    uint64_t v1 = *((void *)this + 8);
    if (v1) {
      (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
    }
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 72));
}

void AABC::~AABC(id *this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  *this  = &unk_1F13F12D0;
  if (_logHandle)
  {
    unsigned int v2 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    unsigned int v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v4, 4);
    _os_log_debug_impl(&dword_1BA438000, v2, OS_LOG_TYPE_DEBUG, "[%x]: ", v4, 8u);
  }

  if (this[507])
  {

    this[507]  = 0;
  }
  [this[19] stop];

  if (this[521]) {
  AABC::ALSFilter::~ALSFilter((AABC::ALSFilter *)(this + 27));
  }
  AABC::ALSFilter::~ALSFilter((AABC::ALSFilter *)(this + 21));
  AAB::~AAB((AAB *)this);
}

{
  AABC::~AABC(this);
}

{
  AABC::~AABC(this);
  AABC::operator delete(this);
}

void sub_1BA5B2A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void AABC::HandleKeyboardEvent(AABC *this, __IOHIDServiceClient *a2, __IOHIDEvent *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t IntegerValue = IOHIDEventGetIntegerValue();
  uint64_t v22 = IOHIDEventGetIntegerValue();
  uint64_t v21 = IOHIDEventGetIntegerValue();
  char v20 = 0;
  if (_logHandle)
  {
    uint64_t v18 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v18 = inited;
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_4_0_8_0_8_0_8_0((uint64_t)v31, 2, IntegerValue, v22, v21);
    _os_log_debug_impl(&dword_1BA438000, v18, OS_LOG_TYPE_DEBUG, "[%x]: downEvent=%lx usagePage=%lx usage=%lx", v31, 0x26u);
  }
  if (v22 == 12)
  {
    switch(v21)
    {
      case 48:
        if (_logHandle)
        {
          int v16 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v15 = init_default_corebrightness_log();
          }
          int v16 = v15;
        }
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v30, IntegerValue);
          _os_log_debug_impl(&dword_1BA438000, v16, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_Consumer usage=kHIDUsage_Csmr_Power", v30, 0xCu);
        }
        if (IntegerValue) {
          char v20 = 1;
        }
        break;
      case 64:
        if (_logHandle)
        {
          os_log_type_t v12 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v11 = init_default_corebrightness_log();
          }
          os_log_type_t v12 = v11;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v28, IntegerValue);
          _os_log_debug_impl(&dword_1BA438000, v12, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_Consumer usage=kHIDUsage_Csmr_Menu", v28, 0xCu);
        }
        if (IntegerValue) {
          char v20 = 1;
        }
        break;
      case 547:
        if (_logHandle)
        {
          mach_error_t v14 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v13 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v13 = init_default_corebrightness_log();
          }
          mach_error_t v14 = v13;
        }
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v29, IntegerValue);
          _os_log_debug_impl(&dword_1BA438000, v14, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_Consumer usage=kHIDUsage_Csmr_ACHome", v29, 0xCu);
        }
        if (IntegerValue) {
          char v20 = 1;
        }
        break;
    }
  }
  else if (v22 == 65289)
  {
    if (v21 == 1)
    {
      if (_logHandle)
      {
        char v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v9 = init_default_corebrightness_log();
        }
        char v10 = v9;
      }
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v27, IntegerValue);
        _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_AppleVendorSmartCover usage=kHIDUsage_AppleVendorSmartCover_Open", v27, 0xCu);
      }
      if (IntegerValue) {
        *((_DWORD *)this + 1012)  = 2;
      }
      else {
        *((_DWORD *)this + 1012)  = 1;
      }
    }
    else if (v21 == 2)
    {
      if (_logHandle)
      {
        os_log_type_t v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v7 = init_default_corebrightness_log();
        }
        os_log_type_t v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v26, IntegerValue);
        _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "downEvent=%lx usagePage=kHIDPage_AppleVendorSmartCover usage=kHIDUsage_AppleVendorSmartCover_Flap1", v26, 0xCu);
      }
      if (*((_DWORD *)this + 1012) != 1)
      {
        if (IntegerValue)
        {
          *((_DWORD *)this + 1012)  = 3;
        }
        else
        {
          *((_DWORD *)this + 1012)  = 2;
          char v20 = 1;
        }
      }
    }
    if (_logHandle)
    {
      float v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v5 = init_default_corebrightness_log();
      }
      float v6 = v5;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v25, *((_DWORD *)this + 1012));
      _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "usagePage=kHIDPage_AppleVendorSmartCover SmartCoverState=%d", v25, 8u);
    }
  }
  if (*((_DWORD *)this + 128) && (v20 & 1) != 0 && !*((_DWORD *)this + 122))
  {
    if (*((void *)this + 58)) {
      *((_DWORD *)this + 158)  = *(_DWORD *)(*((void *)this + 58) + 40);
    }
    if (*((_DWORD *)this + 160) && *((float *)this + 158) < 0.05) {
      *((_DWORD *)this + 158)  = 1045220557;
    }
    if (_logHandle)
    {
      uint64_t v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v3 = init_default_corebrightness_log();
      }
      uint64_t v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v24, COERCE__INT64(*((float *)this + 158)));
      _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "Keyboard/Cover event -> turn on ALS sensor with interval %f.", v24, 0xCu);
    }
    *((_DWORD *)this + 167)  = 1;
    AABC::UpdateALSState((CFDictionaryRef *)this, 17);
  }
}

uint64_t __os_log_helper_16_0_4_4_0_8_0_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)os_log_t result = 0;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  return result;
}

void AABC::UpdateALSState(CFDictionaryRef *this, int a2)
{
  float v6 = this;
  int v5 = a2;
  memset(__b, 0, sizeof(__b));
  __b[0]  = this;
  memcpy(&__b[1], this + 79, 0x28uLL);
  LODWORD(__b[6])  = v5;
  CFDictionaryRef theDict = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], this[53]);
  if (theDict)
  {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)AABC::UpdateALSStateFunction, __b);
    CFRelease(theDict);
  }
}

void AABC::ArmFirstALSSampleTimer(AABC *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  __b[5]  = this;
  if (!*((_DWORD *)this + 150))
  {
    memset(__b, 0, 0x28uLL);
    __b[1]  = this;
    if (_logHandle)
    {
      int v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      int v5 = inited;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(double *)&uint64_t v1 = CFAbsoluteTimeGetCurrent();
      __os_log_helper_16_0_1_8_0((uint64_t)v8, v1);
      _os_log_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEFAULT, "ts=%f Arming first sample timeout", v8, 0xCu);
    }
    *((void *)this + 74)  = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *((dispatch_queue_t *)this + 509));
    if (*((void *)this + 74))
    {
      dispatch_set_context(*((dispatch_object_t *)this + 74), this);
      source  = *((void *)this + 74);
      dispatch_time_t v2 = dispatch_time(0, (uint64_t)(float)(*((float *)this + 852) * 1000000000.0));
      dispatch_source_set_timer(source, v2, 0xFFFFFFFFFFFFFFFFLL, 0);
      dispatch_source_set_event_handler_f(*((dispatch_source_t *)this + 74), (dispatch_function_t)AABC::FirstALSSampleTimeout);
      dispatch_resume(*((dispatch_object_t *)this + 74));
    }
  }
}

void AABC::FirstALSSampleTimeout(AABC *this, void *a2)
{
}

void AABC::FirstALSSampleTimeout(AABC *this)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  v16[1]  = (uint64_t)this;
  if (*((void *)this + 48))
  {
    v16[0]  = 0;
    *(double *)int v16 = (double)mach_absolute_time() * *(double *)&AABC::_sMachTimebaseFactor;
    CFNumberRef v15 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, v16);
    if (v15)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"EventTimestampFirstALSSampleTimeout", v15);
      if (_logHandle)
      {
        os_log_type_t v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        os_log_type_t v12 = inited;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v21, v16[0]);
        _os_log_impl(&dword_1BA438000, v12, OS_LOG_TYPE_DEFAULT, "ts=%f FirstALSSampleTimeout fired", v21, 0xCu);
      }
      CFRelease(v15);
    }
  }
  if (_logHandle)
  {
    char v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v9 = init_default_corebrightness_log();
    }
    char v10 = v9;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v20, 4);
    _os_log_debug_impl(&dword_1BA438000, v10, OS_LOG_TYPE_DEBUG, "[%x]: ", v20, 8u);
  }
  *((unsigned char *)this + 442)  = 1;
  if (*((unsigned char *)this + 443)) {
    *((unsigned char *)this + 441)  = 1;
  }
  if (_logHandle)
  {
    os_log_type_t v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v7 = init_default_corebrightness_log();
    }
    os_log_type_t v8 = v7;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 441)) {
      uint64_t v1 = "YES";
    }
    else {
      uint64_t v1 = "NO";
    }
    __os_log_helper_16_2_2_8_32_8_0((uint64_t)v19, (uint64_t)v1, COERCE__INT64(*((float *)this + 852)));
    _os_log_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEFAULT, "TIMEOUT!! - Potentially busted ALS? %s!!! (timeout=%f)\n", v19, 0x16u);
  }
  if (*((void *)this + 74))
  {
    if (!*((_DWORD *)this + 150))
    {
      if (*((_DWORD *)this + 169))
      {
        if (*((void *)this + 58)) {
          *((_DWORD *)this + 158)  = *(_DWORD *)(*((void *)this + 58) + 44);
        }
        if (*((_DWORD *)this + 160) && *((float *)this + 158) < 0.05) {
          *((_DWORD *)this + 158)  = 1045220557;
        }
        *((_DWORD *)this + 167)  = 2;
        AABC::UpdateALSState((CFDictionaryRef *)this, 17);
      }
      if (*((_DWORD *)this + 128) && (*((unsigned char *)this + 443) & 1) == 0)
      {
        *((_DWORD *)this + 136)  = 1138819072;
        *((_DWORD *)this + 137)  = 1138819072;
        *((_DWORD *)this + 139)  = 1138819072;
        *((_DWORD *)this + 138)  = 1138819072;
        AABC::_UpdateSemanticAmbientLightLevel((uint64_t)this, 0);
        ++*((_DWORD *)this + 150);
        float v14 = fminf(fmaxf(AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139)), *((float *)this + 180)), *((float *)this + 182));
        if (_logHandle)
        {
          float v6 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v5 = init_default_corebrightness_log();
          }
          float v6 = v5;
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          *(double *)&uint64_t v2 = CFAbsoluteTimeGetCurrent();
          __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v18, v2, COERCE__INT64(*((float *)this + 136)), COERCE__INT64(v14));
          _os_log_impl(&dword_1BA438000, v6, OS_LOG_TYPE_INFO, "ts=%f Timeout waiting for first ALS sample _Esensor_trusted=%0.4f L=%0.4f. Switching to fast mode\n", v18, 0x20u);
        }
        AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 0, 2, 0, v14);
      }
    }
    dispatch_release(*((dispatch_object_t *)this + 74));
    *((void *)this + 74)  = 0;
  }
  else
  {
    if (_logHandle)
    {
      uint64_t v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v3 = init_default_corebrightness_log();
      }
      uint64_t v4 = v3;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v17, 1);
      _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "[%x]: timer invalid", v17, 8u);
    }
  }
}

uint64_t AABC::open(AABC *this, io_registry_entry_t a2, int a3, void (*a4)(void *, const __CFString *, const void *), void *a5)
{
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  os_log_t v133 = this;
  io_registry_entry_t v132 = a2;
  int v131 = a3;
  uint64_t v130 = a4;
  uint64_t v129 = a5;
  os_log_t v128 = 0;
  if (_logHandle)
  {
    int v53 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v53 = inited;
  }
  os_log_t v128 = v53;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v171, 4);
    _os_log_debug_impl(&dword_1BA438000, v128, type, "[%x]: ", v171, 8u);
  }
  int v126 = MGGetSInt32Answer();
  *((_DWORD *)this + 80)  = v126;
  *((void *)this + 48)  = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *((_DWORD *)this + 140)  = 0;
  *((unsigned char *)this + 1152)  = 0;
  *((float *)this + 289)  = -1.0;
  *((float *)this + 290)  = -1.0;
  *((float *)this + 291)  = -1.0;
  *((float *)this + 292)  = -1.0;
  *((float *)this + 293)  = -1.0;
  *((float *)this + 294)  = -1.0;
  *((float *)this + 295)  = -1.0;
  if (v132)
  {
    if (CBU_IsR2RSupported())
    {
      *((unsigned char *)this + 1152)  = 1;
    }
    else
    {
      int v125 = 0;
      char v124 = load_int_from_edt(v132, @"crgb", &v125) & 1;
      if (v124 && v125) {
        *((unsigned char *)this + 1152)  = 1;
      }
    }
    CFTypeRef v123 = 0;
    CFTypeRef v123 = IORegistryEntrySearchCFProperty(v132, "IOService", @"ALSBrightenPdeltaSlow", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v123)
    {
      CFTypeID v51 = CFGetTypeID(v123);
      if (v51 == CFDataGetTypeID())
      {
        buffer  = 0;
        CFDataRef v121 = (CFDataRef)v123;
        if (CFDataGetLength((CFDataRef)v123) == 4)
        {
          uint64_t v153 = 0;
          uint64_t v152 = 4;
          uint64_t v154 = 0;
          uint64_t v155 = 4;
          uint64_t v119 = 0;
          uint64_t v120 = 4;
          v173.location  = 0;
          v173.length  = 4;
          CFDataGetBytes(v121, v173, (UInt8 *)&buffer);
          *((float *)this + 1000)  = (float)buffer / 65536.0;
          os_log_t v118 = 0;
          if (_logHandle)
          {
            id v50 = _logHandle;
          }
          else
          {
            uint64_t v49 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            id v50 = v49;
          }
          os_log_t v118 = v50;
          os_log_type_t v117 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v170, 1, COERCE__INT64(*((float *)this + 1000)));
            _os_log_debug_impl(&dword_1BA438000, v118, v117, "[%x]: _Pthreshold_brighten_slow overriden to %f in ioreg", v170, 0x12u);
          }
        }
      }
      CFRelease(v123);
    }
    CFTypeRef v123 = 0;
    CFTypeRef v123 = IORegistryEntrySearchCFProperty(v132, "IOService", @"ALSBrightenPdeltaFast", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v123)
    {
      CFTypeID v48 = CFGetTypeID(v123);
      if (v48 == CFDataGetTypeID())
      {
        v116  = 0;
        CFDataRef v115 = (CFDataRef)v123;
        if (CFDataGetLength((CFDataRef)v123) == 4)
        {
          uint64_t v149 = 0;
          uint64_t v148 = 4;
          uint64_t v150 = 0;
          uint64_t v151 = 4;
          uint64_t v113 = 0;
          uint64_t v114 = 4;
          v174.location  = 0;
          v174.length  = 4;
          CFDataGetBytes(v115, v174, (UInt8 *)&v116);
          *((float *)this + 999)  = (float)v116 / 65536.0;
          os_log_t v112 = 0;
          if (_logHandle)
          {
            os_log_t v47 = _logHandle;
          }
          else
          {
            uint64_t v46 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            os_log_t v47 = v46;
          }
          os_log_t v112 = v47;
          os_log_type_t v111 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v169, 1, COERCE__INT64(*((float *)this + 999)));
            _os_log_debug_impl(&dword_1BA438000, v112, v111, "[%x]: _Pthreshold_brighten_fast overriden to %f in ioreg", v169, 0x12u);
          }
        }
      }
      CFRelease(v123);
    }
    CFTypeRef v123 = 0;
    CFTypeRef v123 = IORegistryEntrySearchCFProperty(v132, "IOService", @"ALSDimPdeltaSlow", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v123)
    {
      CFTypeID v45 = CFGetTypeID(v123);
      if (v45 == CFDataGetTypeID())
      {
        int v110 = 0;
        CFDataRef v109 = (CFDataRef)v123;
        if (CFDataGetLength((CFDataRef)v123) == 4)
        {
          uint64_t v145 = 0;
          uint64_t v144 = 4;
          uint64_t v146 = 0;
          uint64_t v147 = 4;
          uint64_t v107 = 0;
          uint64_t v108 = 4;
          v175.location  = 0;
          v175.length  = 4;
          CFDataGetBytes(v109, v175, (UInt8 *)&v110);
          *((float *)this + 997)  = (float)v110 / 65536.0;
          os_log_t v106 = 0;
          if (_logHandle)
          {
            id v44 = _logHandle;
          }
          else
          {
            uint64_t v43 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            id v44 = v43;
          }
          os_log_t v106 = v44;
          os_log_type_t v105 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v168, 1, COERCE__INT64(*((float *)this + 997)));
            _os_log_debug_impl(&dword_1BA438000, v106, v105, "[%x]: _Pthreshold_dim_slow overriden to %f in ioreg", v168, 0x12u);
          }
        }
      }
      CFRelease(v123);
    }
    CFTypeRef v123 = 0;
    CFTypeRef v123 = IORegistryEntrySearchCFProperty(v132, "IOService", @"ALSRampLuxThreshold", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v123)
    {
      CFTypeID v42 = CFGetTypeID(v123);
      if (v42 == CFDataGetTypeID())
      {
        unsigned int v104 = 0;
        CFDataRef v103 = (CFDataRef)v123;
        if (CFDataGetLength((CFDataRef)v123) == 4)
        {
          uint64_t v141 = 0;
          uint64_t v140 = 4;
          uint64_t v142 = 0;
          uint64_t v143 = 4;
          uint64_t v101 = 0;
          uint64_t v102 = 4;
          v176.location  = 0;
          v176.length  = 4;
          CFDataGetBytes(v103, v176, (UInt8 *)&v104);
          *((float *)this + 1002)  = (float)v104;
          os_log_t v100 = 0;
          if (_logHandle)
          {
            float v41 = _logHandle;
          }
          else
          {
            uint64_t v40 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
            float v41 = v40;
          }
          os_log_t v100 = v41;
          os_log_type_t v99 = OS_LOG_TYPE_DEBUG;
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_2_4_0_8_0((uint64_t)v167, 1, COERCE__INT64(*((float *)this + 1002)));
            _os_log_debug_impl(&dword_1BA438000, v100, v99, "[%x]: _AbsoluteLuxThreshold overriden to %f in ioreg", v167, 0x12u);
          }
        }
      }
      CFRelease(v123);
    }
    CFTypeRef v123 = 0;
    BOOL v98 = 1;
    CFTypeRef v123 = IORegistryEntrySearchCFProperty(v132, "IOService", @"AABNoDimming", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v123)
    {
      CFTypeID TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(v123) && CFDataGetLength((CFDataRef)v123) > 0)
      {
        BOOL v98 = *CFDataGetBytePtr((CFDataRef)v123) == 0;
        os_log_t v97 = 0;
        if (_logHandle)
        {
          int v38 = _logHandle;
        }
        else
        {
          uint64_t v37 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          int v38 = v37;
        }
        os_log_t v97 = v38;
        os_log_type_t v96 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
        {
          __os_log_helper_16_0_1_4_0((uint64_t)v166, v98);
          _os_log_impl(&dword_1BA438000, v97, v96, "Full dimming overridden to %d in ioreg", v166, 8u);
        }
      }
      CFRelease(v123);
    }
    CFTypeRef v123 = 0;
    int v95 = 3;
    CFTypeRef v123 = IORegistryEntrySearchCFProperty(v132, "IOService", @"AABDimPolicy", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v123)
    {
      CFTypeID v36 = CFDataGetTypeID();
      if (v36 == CFGetTypeID(v123) && CFDataGetLength((CFDataRef)v123) > 0)
      {
        int v95 = *CFDataGetBytePtr((CFDataRef)v123);
        os_log_t v94 = 0;
        if (_logHandle)
        {
          float v35 = _logHandle;
        }
        else
        {
          uint64_t v34 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          float v35 = v34;
        }
        os_log_t v94 = v35;
        os_log_type_t v93 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v165, 4, v98);
          _os_log_debug_impl(&dword_1BA438000, v94, v93, "[%x]: Dim policy overridden to %d", v165, 0xEu);
        }
      }
      CFRelease(v123);
    }
    CFTypeRef v123 = 0;
    *((unsigned char *)this + 136)  = 0;
    CFTypeRef v123 = IORegistryEntrySearchCFProperty(v132, "IOService", @"is-accessory", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v123)
    {
      CFTypeID v33 = CFDataGetTypeID();
      if (v33 == CFGetTypeID(v123) && CFDataGetLength((CFDataRef)v123) > 0)
      {
        *((unsigned char *)this + 136)  = *CFDataGetBytePtr((CFDataRef)v123) != 0;
        os_log_t v92 = 0;
        if (_logHandle)
        {
          uint64_t v32 = _logHandle;
        }
        else
        {
          uint64_t v31 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          uint64_t v32 = v31;
        }
        os_log_t v92 = v32;
        os_log_type_t v91 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v164, 16, *((unsigned char *)this + 136) & 1);
          _os_log_debug_impl(&dword_1BA438000, v92, v91, "[%x]: isAccessory ? %d\n", v164, 0xEu);
        }
      }
      CFRelease(v123);
    }
    CFTypeRef v123 = 0;
    *((_DWORD *)this + 858)  = 1;
    if (v98)
    {
      os_log_t v90 = 0;
      if (_logHandle)
      {
        float v30 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v29 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v29 = init_default_corebrightness_log();
        }
        float v30 = v29;
      }
      os_log_t v90 = v30;
      os_log_type_t v89 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v163, 4, v95);
        _os_log_debug_impl(&dword_1BA438000, v90, v89, "[%x]: Turning on dimming with policy %d", v163, 0xEu);
      }
      if (v95 < 8) {
        *((_DWORD *)this + 858)  = v95;
      }
    }
    else
    {
      *((_DWORD *)this + 858)  = 0;
    }
    *((_DWORD *)this + 859)  = *((_DWORD *)this + 858);
    CFTypeRef v123 = IORegistryEntrySearchCFProperty(v132, "IOService", @"min-curve-version", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 3u);
    if (v123)
    {
      CFTypeID v28 = CFGetTypeID(v123);
      if (v28 == CFDataGetTypeID())
      {
        int v88 = 0;
        CFDataRef v87 = (CFDataRef)v123;
        if (CFDataGetLength((CFDataRef)v123) == 4)
        {
          uint64_t v137 = 0;
          uint64_t v136 = 4;
          uint64_t v138 = 0;
          uint64_t v139 = 4;
          uint64_t v85 = 0;
          uint64_t v86 = 4;
          v177.location  = 0;
          v177.length  = 4;
          CFDataGetBytes(v87, v177, (UInt8 *)&v88);
          if (v88 > 5)
          {
            *((_DWORD *)this + 183)  = v88;
            os_log_t v84 = 0;
            if (_logHandle)
            {
              os_log_t v27 = _logHandle;
            }
            else
            {
              uint64_t v26 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              os_log_t v27 = v26;
            }
            os_log_t v84 = v27;
            os_log_type_t v83 = OS_LOG_TYPE_DEBUG;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_1_4_0((uint64_t)v162, *((_DWORD *)this + 183));
              _os_log_debug_impl(&dword_1BA438000, v84, v83, "Min curve version set to %d", v162, 8u);
            }
          }
        }
      }
      CFRelease(v123);
    }
    CFTypeRef v123 = 0;
    int v82 = 0;
    if ((load_int_from_edt(v132, @"supports-float-lux", &v82) & 1) == 0) {
      int v82 = 0;
    }
    *((unsigned char *)this + 3936)  = v82 != 0;
    os_log_t v81 = 0;
    if (_logHandle)
    {
      int v25 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v24 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v24 = init_default_corebrightness_log();
      }
      int v25 = v24;
    }
    os_log_t v81 = v25;
    os_log_type_t v80 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v161, *((unsigned char *)this + 3936) & 1);
      _os_log_debug_impl(&dword_1BA438000, v81, v80, "supports-float-lux=%d", v161, 8u);
    }
  }
  *((_DWORD *)this + 93)  = v131;
  *((void *)this + 42)  = -1;
  int v79 = MGGetSInt32Answer();
  *((void *)this + 42)  = v79;
  if (*((uint64_t *)this + 42) <= 0)
  {
    int v72 = MGGetSInt32Answer();
    *((void *)this + 42)  = v72;
    os_log_t oslog = 0;
    if (_logHandle)
    {
      char v19 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v18 = init_default_corebrightness_log();
      }
      char v19 = v18;
    }
    os_log_t oslog = v19;
    os_log_type_t v70 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v158, *((void *)this + 42));
      _os_log_debug_impl(&dword_1BA438000, oslog, v70, "Cover color: 0x%llX\n", v158, 0xCu);
    }
    if (*((void *)this + 42) != -1)
    {
      int v68 = MGGetSInt32Answer();
      int v69 = v68;
      os_log_t v67 = 0;
      if (_logHandle)
      {
        int v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v16 = init_default_corebrightness_log();
        }
        int v17 = v16;
      }
      os_log_t v67 = v17;
      os_log_type_t v66 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_1_4_0((uint64_t)v157, v69);
        _os_log_debug_impl(&dword_1BA438000, v67, v66, "Enclosure color: 0x%X\n", v157, 8u);
      }
      if (v69 != -1) {
        *((void *)this + 42) |= (uint64_t)v69 << 32;
      }
    }
  }
  else
  {
    os_log_t v78 = 0;
    if (_logHandle)
    {
      char v23 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v22 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v22 = init_default_corebrightness_log();
      }
      char v23 = v22;
    }
    os_log_t v78 = v23;
    os_log_type_t v77 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v160, *((void *)this + 42));
      _os_log_debug_impl(&dword_1BA438000, v78, v77, "Cover color (new): 0x%llX\n", v160, 0xCu);
    }
    int v75 = MGGetSInt32Answer();
    int v76 = v75;
    os_log_t v74 = 0;
    if (_logHandle)
    {
      uint64_t v21 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v20 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v20 = init_default_corebrightness_log();
      }
      uint64_t v21 = v20;
    }
    os_log_t v74 = v21;
    os_log_type_t v73 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v159, v76);
      _os_log_debug_impl(&dword_1BA438000, v74, v73, "Enclosure color (new): 0x%X\n", v159, 8u);
    }
    if (v76 != -1) {
      *((void *)this + 42) |= (uint64_t)v76 << 32;
    }
  }
  uint64_t v5 = +[CBAnalyticsScheduler sharedInstance];
  uint64_t v60 = MEMORY[0x1E4F143A8];
  int v61 = -1073741824;
  int v62 = 0;
  int v63 = ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke;
  os_log_type_t v64 = &__block_descriptor_40_e5_v8__0l;
  os_log_t v65 = this;
  *((void *)this + 489)  = -[CBAnalyticsScheduler registerHandler:](v5, "registerHandler:");
  *((_DWORD *)this + 125)  = 0;
  if (*((_DWORD *)this + 94))
  {
    uint64_t v135 = &AABC::open(unsigned int,int,void (*)(void *,__CFString const*,void const*),void *)::pred;
    dispatch_block_t v134 = &__block_literal_global_172;
    if (AABC::open(unsigned int,int,void (*)(void *,__CFString const*,void const*),void *)::pred != -1) {
      dispatch_once(v135, v134);
    }
    CFNumberRef v15 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    keyCallBacks  = (CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    *((void *)this + 53)  = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], 0);
    valueCallBacks  = (CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    *((void *)this + 54)  = CFDictionaryCreateMutable(*v15, 0, keyCallBacks, MEMORY[0x1E4F1D540]);
    *((void *)this + 44)  = v130;
    *((void *)this + 45)  = v129;
    value  = 0;
    *((void *)this + 49)  = CFDictionaryCreateMutable(*v15, 0, keyCallBacks, valueCallBacks);
    value  = CFNumberCreate(*v15, kCFNumberFloatType, (char *)this + 3452);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSMaxDimDuration", value);
      CFRelease(value);
    }
    value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3448);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSMaxBrightenDuration", value);
      CFRelease(value);
    }
    value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 3444);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSSpikeFilterDuration", value);
      CFRelease(value);
    }
    value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)this + 3432);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSDimPolicy", value);
      CFRelease(value);
    }
    CFDictionaryRef theDict = (__CFDictionary *)*((void *)this + 49);
    if (*((_DWORD *)this + 860)) {
      CFDictionarySetValue(theDict, @"ALSLockScreenAutoBrightness", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    else {
      CFDictionarySetValue(theDict, @"ALSLockScreenAutoBrightness", (const void *)*MEMORY[0x1E4F1CFC8]);
    }
    int valuePtr = 1;
    value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSAlgorithm", value);
      CFRelease(value);
    }
    int v57 = 1036831949;
    value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v57);
    if (value)
    {
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"ALSIntPeriod", value);
      CFRelease(value);
    }
    CFNumberRef cf = (const __CFNumber *)IORegistryEntryCreateCFProperty(v132, @"AutoRateControl", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    if (cf)
    {
      *((_DWORD *)this + 162)  = GetCFBooleanValue(cf);
      CFRelease(cf);
    }
    uint64_t v11 = (__CFDictionary *)*((void *)this + 48);
    if (*((_DWORD *)this + 162)) {
      CFDictionarySetValue(v11, @"BoostPriority", (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    else {
      CFDictionarySetValue(v11, @"BoostPriority", (const void *)*MEMORY[0x1E4F1CFC8]);
    }
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"AAPEnabled", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFDictionaryRef OutlierRemovalDictionary = AABC::createOutlierRemovalDictionary((uint64_t)this, (unsigned char *)this + 3368);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"OutlierRemoval", OutlierRemovalDictionary);
    CFRelease(OutlierRemovalDictionary);
    *((float *)this + 852)  = 0.25;
    if (*((unsigned char *)this + 136))
    {
      *((float *)this + 853)  = 2.0;
    }
    else
    {
      float v6 = 4.0;
      if (!*((_DWORD *)this + 162)) {
        float v6 = 30.0;
      }
      *((float *)this + 853)  = v6;
    }
    *((unsigned char *)this + 3472)  = 0;
    *((unsigned char *)this + 3473)  = 0;
    *((_DWORD *)this + 869)  = 0;
    *((_DWORD *)this + 870)  = 0;
    *((_DWORD *)this + 871)  = 0;
    *((float *)this + 872)  = 1.0;
    *((float *)this + 873)  = 1.0;
    *((unsigned char *)this + 3588)  = 0;
    *((unsigned char *)this + 3589)  = 0;
    *((_DWORD *)this + 898)  = 0;
    *((_DWORD *)this + 899)  = 0;
    *((_DWORD *)this + 900)  = 0;
    *((_DWORD *)this + 901)  = 1061997773;
    *((float *)this + 902)  = 1.0;
  }
  AABC::ParseCustomAABCurvesFromEDT(this, v132);
  if (_logHandle)
  {
    char v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v9 = init_default_corebrightness_log();
    }
    char v10 = v9;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    if (*((_DWORD *)this + 94)) {
      uint64_t v7 = "true";
    }
    else {
      uint64_t v7 = "false";
    }
    __os_log_helper_16_2_1_8_32((uint64_t)v156, (uint64_t)v7);
    _os_log_impl(&dword_1BA438000, v10, OS_LOG_TYPE_INFO, "ambient adaptive brightness plugin _plugInEnabled=%s", v156, 0xCu);
  }
  return v132;
}

void ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v9 = a1;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 4072);
  uint64_t block = MEMORY[0x1E4F143A8];
  int v4 = -1073741824;
  int v5 = 0;
  float v6 = ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke_2;
  uint64_t v7 = &__block_descriptor_40_e5_v8__0l;
  uint64_t v8 = v1;
  dispatch_async(v2, &block);
}

uint64_t ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke_2(uint64_t a1)
{
  uint64_t v6 = a1;
  uint64_t v5 = a1;
  uint64_t v2 = *(void *)(a1 + 32);
  +[CBAnalytics alsSelectionSwaps:*(unsigned int *)(v2 + 3896)];
  *(_DWORD *)(v2 + 3896)  = 0;
  memcpy(__dst, (const void *)(v2 + 3704), sizeof(__dst));
  memset((void *)(v2 + 3808), 0, 0x48uLL);
  memset((void *)(v2 + 3712), 0, 0x60uLL);
  +[CBAnalytics alsSelectionTimes:&__dst[104] count:9];
  +[CBAnalytics alsSelectionDeltas:&__dst[8] count:12];
  +[CBAnalytics deviceColor:*(void *)(v2 + 336)];
  +[CBAnalytics cuveLevel:*(unsigned int *)(v2 + 3404)];
  BOOL v3 = 0;
  if (*(_DWORD *)(v2 + 512)) {
    BOOL v3 = *(_DWORD *)(v2 + 520) == 0;
  }
  +[CBAnalytics autoBrightnessEnabled:v3 byUser:0];
  [*(id *)(v2 + 3920) submit];
  return [*(id *)(v2 + 3928) submit];
}

double ___ZN4AABC4openEjiPFvPvPK10__CFStringPKvES0__block_invoke_3(uint64_t a1)
{
  uint64_t v6 = a1;
  uint64_t v5 = a1;
  mach_timebase_info(&info);
  LODWORD(v1)  = info.numer;
  LODWORD(v2)  = info.denom;
  double result = (double)v1 / (double)v2 * 0.000000001;
  AABC::_sMachTimebaseFactor  = *(void *)&result;
  return result;
}

CFDictionaryRef AABC::createOutlierRemovalDictionary(uint64_t a1, unsigned char *a2)
{
  __dst[5]  = *(const void **)MEMORY[0x1E4F143B8];
  memcpy(__dst, off_1E621A9B8, 0x28uLL);
  memset(__b, 0, sizeof(__b));
  if (*a2) {
    int v4 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    int v4 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  __b[0]  = v4;
  BOOL v3 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  __b[1]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, a2 + 4);
  __b[2]  = CFNumberCreate(*v3, kCFNumberDoubleType, a2 + 8);
  __b[3]  = CFNumberCreate(*v3, kCFNumberDoubleType, a2 + 24);
  __b[4]  = CFNumberCreate(*v3, kCFNumberDoubleType, a2 + 16);
  CFDictionaryRef v5 = CFDictionaryCreate(*v3, __dst, __b, 5, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(__b[4]);
  CFRelease(__b[3]);
  CFRelease(__b[2]);
  CFRelease(__b[1]);
  return v5;
}

void AABC::ParseCustomAABCurvesFromEDT(AABC *this, io_registry_entry_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = this;
  io_registry_entry_t v9 = a2;
  uint64_t v8 = 0;
  unint64_t v7 = 0;
  int v6 = 0;
  if (load_int_from_edt(a2, @"support-custom-curve", &v6))
  {
    if (v6)
    {
      unint64_t v7 = load_float_array_from_edt(v9, @"low-curve-lux-points", &v8);
      if (v8)
      {
        if (v7 == 4)
        {
          memcpy((char *)this + 1556, v8, 0x10uLL);
          free(v8);
          uint64_t v8 = 0;
          unint64_t v7 = load_float_array_from_edt(v9, @"low-curve-nits-points", &v8);
          if (v8)
          {
            if (v7 == 4)
            {
              memcpy((char *)this + 1636, v8, 0x10uLL);
              free(v8);
              uint64_t v8 = 0;
              *((_DWORD *)this + 429)  = 4;
              unint64_t v7 = load_float_array_from_edt(v9, @"med-curve-lux-points", &v8);
              if (v8)
              {
                if (v7 == 4)
                {
                  memcpy((char *)this + 1720, v8, 0x10uLL);
                  free(v8);
                  uint64_t v8 = 0;
                  unint64_t v7 = load_float_array_from_edt(v9, @"med-curve-nits-points", &v8);
                  if (v8)
                  {
                    if (v7 == 4)
                    {
                      memcpy((char *)this + 1800, v8, 0x10uLL);
                      free(v8);
                      uint64_t v8 = 0;
                      *((_DWORD *)this + 470)  = 4;
                      unint64_t v7 = load_float_array_from_edt(v9, @"high-curve-lux-points", &v8);
                      if (v8)
                      {
                        if (v7 == 4)
                        {
                          memcpy((char *)this + 1884, v8, 0x10uLL);
                          free(v8);
                          uint64_t v8 = 0;
                          unint64_t v7 = load_float_array_from_edt(v9, @"high-curve-nits-points", &v8);
                          if (v8 && v7 == 4)
                          {
                            memcpy((char *)this + 1964, v8, 0x10uLL);
                            free(v8);
                            uint64_t v8 = 0;
                            *((_DWORD *)this + 511)  = 4;
                            *((unsigned char *)this + 1552)  = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (_logHandle)
  {
    int v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)this + 1552)) {
      unint64_t v2 = "success";
    }
    else {
      unint64_t v2 = "failure";
    }
    __os_log_helper_16_2_1_8_32((uint64_t)v11, (uint64_t)v2);
    _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "Parsing AAB Curve from EDT: %s", v11, 0xCu);
  }
  if (v8) {
    free(v8);
  }
}

void AABC::close(AABC *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    BOOL v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    BOOL v3 = inited;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v5, 4);
    _os_log_debug_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEBUG, "[%x]: ", v5, 8u);
  }
  AABC::CancelFirstSampleTimeout((dispatch_object_t *)this);
  [+[CBAnalyticsScheduler sharedInstance] removeHandler:*((void *)this + 489)];
  if (*((void *)this + 48))
  {
    CFRelease(*((CFTypeRef *)this + 48));
    *((void *)this + 48)  = 0;
  }
  if (*((void *)this + 497))
  {
    uint64_t v1 = *((void *)this + 497);
    if (v1) {
      MEMORY[0x1BA9EC4A0](v1, 0x1000C4052888210);
    }
    *((void *)this + 497)  = 0;
  }
  if (*((void *)this + 53))
  {
    CFRelease(*((CFTypeRef *)this + 53));
    *((void *)this + 53)  = 0;
  }
  if (*((void *)this + 54))
  {
    CFRelease(*((CFTypeRef *)this + 54));
    *((void *)this + 54)  = 0;
  }
}

void AABC::registerDisplay(AABC *this, __Display *a2)
{
  uint64_t v196 = *MEMORY[0x1E4F143B8];
  float v170 = this;
  CFTypeRef v169 = a2;
  os_log_t v168 = 0;
  if (_logHandle)
  {
    os_log_type_t v77 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    os_log_type_t v77 = inited;
  }
  os_log_t v168 = v77;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v195, 4);
    _os_log_debug_impl(&dword_1BA438000, v168, type, "[%x]: ", v195, 8u);
  }
  if (v169 && !*((void *)this + 51))
  {
    *((void *)this + 51)  = v169;
    Property  = 0;
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DisplayProductLuminanceMax");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 716);
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"plt-logic-version");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberIntType, (char *)this + 4024);
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DisplayProductLuminanceMid");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 712);
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DisplayProductLuminanceMin");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 708);
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DisplayPanelLuminanceMax");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 728);
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DisplayPanelLuminanceMid");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 724);
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DisplayPanelLuminanceMin");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 720);
    }
    CFBooleanRef v165 = 0;
    CFBooleanRef v165 = (CFBooleanRef)DisplayGetProperty(*((void *)this + 51), @"PreStrobeDropALSSamples");
    if (v165) {
      *((unsigned char *)this + 505)  = CFBooleanGetValue(v165) != 0;
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DisplayTypeA");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberIntType, (char *)this + 2876);
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DefaultCurveVersion");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberIntType, (char *)this + 2880);
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"RaiseHighCurve");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberIntType, (char *)this + 2884);
    }
    BOOL v164 = 0;
    CFBooleanRef v163 = 0;
    CFBooleanRef v163 = (CFBooleanRef)DisplayGetProperty(*((void *)this + 51), @"EDMSupported");
    if (v163)
    {
      BOOL v75 = 0;
      if (CFBooleanGetValue(v163)) {
        BOOL v75 = +[CBExtendedDisplayMitigation isSupported];
      }
      BOOL v164 = v75;
    }
    if (v164) {
      os_log_t v74 = objc_alloc_init(CBExtendedDisplayMitigation);
    }
    else {
      os_log_t v74 = 0;
    }
    *((void *)this + 508)  = v74;
    os_log_t v162 = 0;
    if (_logHandle)
    {
      os_log_type_t v73 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v72 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v72 = init_default_corebrightness_log();
      }
      os_log_type_t v73 = v72;
    }
    os_log_t v162 = v73;
    os_log_type_t v161 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v194, v164);
      _os_log_debug_impl(&dword_1BA438000, v162, v161, "Extended display mitigation supported: %d", v194, 8u);
    }
    CFDictionaryRef v160 = 0;
    CFDictionaryRef v160 = (CFDictionaryRef)DisplayGetProperty(*((void *)this + 51), @"AABConstraints");
    if (v160)
    {
      Property  = (CFNumberRef)CFDictionaryGetValue(v160, @"EmaxAlgo");
      if (Property) {
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1156);
      }
      Property  = (CFNumberRef)CFDictionaryGetValue(v160, @"LmaxAlgo");
      if (Property) {
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1160);
      }
      Property  = (CFNumberRef)CFDictionaryGetValue(v160, @"E2");
      if (Property) {
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1172);
      }
      Property  = (CFNumberRef)CFDictionaryGetValue(v160, @"L2");
      if (Property) {
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1176);
      }
      Property  = (CFNumberRef)CFDictionaryGetValue(v160, @"E0b");
      if (Property) {
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1164);
      }
      Property  = (CFNumberRef)CFDictionaryGetValue(v160, @"L0b");
      if (Property) {
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1168);
      }
      Property  = (CFNumberRef)CFDictionaryGetValue(v160, @"EmaxThreshold");
      if (Property) {
        CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 1180);
      }
    }
    Property  = (CFNumberRef)DisplayGetProperty(*((void *)this + 51), @"DisplayBrightnessFactor");
    if (Property) {
      CFNumberGetValue(Property, kCFNumberFloatType, (char *)this + 416);
    }
    os_log_t v159 = 0;
    if (_logHandle)
    {
      uint64_t v71 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v70 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v70 = init_default_corebrightness_log();
      }
      uint64_t v71 = v70;
    }
    os_log_t v159 = v71;
    os_log_type_t v158 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v71, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v193, COERCE__INT64(*((float *)this + 104)));
      _os_log_impl(&dword_1BA438000, v159, v158, "Initial factor %f", v193, 0xCu);
    }
    *((float *)this + 4)  = (float)(100.0 - *((float *)this + 177)) / 30.0;
    float LogicalBrightness = DisplayGetLogicalBrightness(*((void *)this + 51));
    *((float *)this + 155)  = LogicalBrightness;
    *((float *)this + 154)  = LogicalBrightness;
    *((float *)this + 855)  = DisplayGetLogicalBrightness(*((void *)this + 51));
    *((float *)this + 1007)  = (float)((float)(*((float *)this + 179) - *((float *)this + 177)) / *((float *)this + 3))
                            / 2.0;
    if (*((float *)this + 295) <= 0.0)
    {
      if (*((float *)this + 289) > 0.0) {
        *((_DWORD *)this + 1007)  = *((_DWORD *)this + 289);
      }
    }
    else
    {
      *((_DWORD *)this + 1007)  = *((_DWORD *)this + 295);
    }
    if (*((float *)this + 292) > 0.0) {
      *((float *)this + 4)  = (float)(*((float *)this + 292) - *((float *)this + 177)) / 30.0;
    }
    os_log_t v157 = 0;
    if (_logHandle)
    {
      int v68 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v67 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v67 = init_default_corebrightness_log();
      }
      int v68 = v67;
    }
    os_log_t v157 = v68;
    os_log_type_t v156 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v68, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v192, COERCE__INT64(*((float *)this + 1007)));
      _os_log_impl(&dword_1BA438000, v157, v156, "_Emax_logical: %0.4f", v192, 0xCu);
    }
    CFDictionaryRef v155 = 0;
    BOOL v154 = 0;
    *((_DWORD *)this + 900)  = *((_DWORD *)this + 1007);
    *((_DWORD *)this + 866)  = *((_DWORD *)this + 181);
    *((_DWORD *)this + 867)  = *((_DWORD *)this + 181);
    *((_DWORD *)this + 299)  = 0;
    *((_DWORD *)this + 298)  = 0;
    *((_DWORD *)this + 297)  = 0;
    *((_DWORD *)this + 296)  = 0;
    int v2 = *((_DWORD *)this + 182);
    *((_DWORD *)this + 303)  = v2;
    *((_DWORD *)this + 302)  = v2;
    *((_DWORD *)this + 301)  = v2;
    *((_DWORD *)this + 300)  = v2;
    *((void *)this + 152)  = 0x40AC200000000000;
    *(void *)((char *)v153 + 1)  = 0;
    CFPreferencesSynchronize(@"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    v153[0]  = CFPreferencesGetAppBooleanValue(@"BrightnessRestrictionsFromPreferences", @"com.apple.CoreBrightness", 0) != 0;
    *((unsigned char *)this + 452)  = CFPreferencesGetAppBooleanValue(@"StoreDemoMode", @"/var/mobile/Library/Preferences/com.apple.demo-settings", 0) != 0;
    uint64_t v66 = *((void *)this + 51);
    if (*((unsigned char *)this + 452)) {
      DisplaySetProperty(v66, @"CBStoreDemoModeIsPresent", *MEMORY[0x1E4F1CFD0]);
    }
    else {
      DisplaySetProperty(v66, @"CBStoreDemoModeIsPresent", *MEMORY[0x1E4F1CFC8]);
    }
    if (*((unsigned char *)this + 452) & 1) != 0 || (v153[0])
    {
      *(void *)((char *)v153 + 1)  = CFPreferencesCopyValue(@"BrightnessRestrictions", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
      if (*(void *)((char *)v153 + 1)
        && (CFTypeID v65 = CFGetTypeID(*(CFTypeRef *)((char *)v153 + 1)), v65 == CFDictionaryGetTypeID()))
      {
        CFDictionaryRef v155 = *(CFDictionaryRef *)((char *)v153 + 1);
        BOOL v154 = 1;
        os_log_t v152 = 0;
        if (_logHandle)
        {
          os_log_type_t v64 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v63 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v63 = init_default_corebrightness_log();
          }
          os_log_type_t v64 = v63;
        }
        os_log_t v152 = v64;
        os_log_type_t v151 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          if (*((unsigned char *)this + 452)) {
            BOOL v3 = "YES";
          }
          else {
            BOOL v3 = "NO";
          }
          __os_log_helper_16_2_1_8_32((uint64_t)v191, (uint64_t)v3);
          _os_log_impl(&dword_1BA438000, v152, v151, "BrightnessRestrictions were loaded from CFPreferences (StoreDemoMode  = %s)", v191, 0xCu);
        }
      }
      else
      {
        os_log_t v150 = 0;
        if (_logHandle)
        {
          int v62 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v61 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v61 = init_default_corebrightness_log();
          }
          int v62 = v61;
        }
        os_log_t v150 = v62;
        os_log_type_t v149 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          if (*((unsigned char *)this + 452)) {
            int v4 = "YES";
          }
          else {
            int v4 = "NO";
          }
          __os_log_helper_16_2_1_8_32((uint64_t)v190, (uint64_t)v4);
          _os_log_error_impl(&dword_1BA438000, v150, v149, "Failed to load BrightnessRestrictions from CFPreferences (StoreDemoMode  = %s)", v190, 0xCu);
        }
      }
    }
    id v148 = 0;
    id v148 = (id)CFPreferencesCopyValue(@"DisplayOffTimeToRevertAABCurve", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      [v148 floatValue];
      *((double *)this + 152)  = v5;
      os_log_t v147 = 0;
      if (_logHandle)
      {
        uint64_t v60 = _logHandle;
      }
      else
      {
        uint64_t v59 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        uint64_t v60 = v59;
      }
      os_log_t v147 = v60;
      os_log_type_t v146 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        [v148 floatValue];
        __os_log_helper_16_0_1_8_0((uint64_t)v189, COERCE__INT64(v6));
        _os_log_impl(&dword_1BA438000, v147, v146, "Display off time to revert AAB curve were overriden to %f seconds.", v189, 0xCu);
      }
    }

    if (!v155)
    {
      CFDictionaryRef v155 = (CFDictionaryRef)DisplayGetProperty(*((void *)this + 51), @"BrightnessRestrictions");
      if (v155)
      {
        CFTypeRef v145 = CFDictionaryGetValue(v155, @"multi_point");
        if (v145)
        {
          CFTypeID v58 = CFGetTypeID(v145);
          if (v58 == CFNumberGetTypeID()) {
            BOOL v154 = CFBooleanGetValue((CFBooleanRef)v145) != 0;
          }
        }
      }
    }
    if (v154)
    {
      char v144 = 0;
      char v143 = 0;
      char v142 = 0;
      char v141 = 0;
      if (v155)
      {
        int v140 = 0;
        int v139 = 6;
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"min_thresholds");
        if (*(void *)&idx[1])
        {
          CFTypeID v57 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v57 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&idx[1]) == v139)
          {
            for (idx[0]  = 0; idx[0] < v139; ++idx[0])
            {
              *(void *)&v137[1]  = CFArrayGetValueAtIndex(*(CFArrayRef *)&idx[1], idx[0]);
              if (*(void *)&v137[1])
              {
                CFTypeID TypeID = CFNumberGetTypeID();
                if (TypeID == CFGetTypeID(*(CFTypeRef *)&v137[1]))
                {
                  CFNumberGetValue(*(CFNumberRef *)&v137[1], kCFNumberFloatType, (char *)this + 4 * idx[0] + 3492);
                  ++v140;
                }
              }
            }
            if (v140 == v139) {
              char v142 = 1;
            }
          }
        }
        int v140 = 0;
        int v139 = 6;
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"min_factors");
        if (*(void *)&idx[1])
        {
          CFTypeID v55 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v55 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&idx[1]) == v139)
          {
            for (v137[0]  = 0; v137[0] < v139; ++v137[0])
            {
              *(void *)&v136[1]  = CFArrayGetValueAtIndex(*(CFArrayRef *)&idx[1], v137[0]);
              if (*(void *)&v136[1])
              {
                CFTypeID v54 = CFNumberGetTypeID();
                if (v54 == CFGetTypeID(*(CFTypeRef *)&v136[1]))
                {
                  CFNumberGetValue(*(CFNumberRef *)&v136[1], kCFNumberFloatType, (char *)this + 4 * v137[0] + 3516);
                  ++v140;
                }
              }
            }
            if (v140 == v139) {
              char v141 = 1;
            }
          }
        }
        if (v142 & 1) != 0 && (v141) {
          char v144 = 1;
        }
        char v142 = 0;
        char v141 = 0;
        int v140 = 0;
        int v139 = 6;
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"max_thresholds");
        if (*(void *)&idx[1])
        {
          CFTypeID v53 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v53 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&idx[1]) == v139)
          {
            for (v136[0]  = 0; v136[0] < v139; ++v136[0])
            {
              *(void *)&v135[1]  = CFArrayGetValueAtIndex(*(CFArrayRef *)&idx[1], v136[0]);
              if (*(void *)&v135[1])
              {
                CFTypeID v52 = CFNumberGetTypeID();
                if (v52 == CFGetTypeID(*(CFTypeRef *)&v135[1]))
                {
                  CFNumberGetValue(*(CFNumberRef *)&v135[1], kCFNumberFloatType, (char *)this + 4 * v136[0] + 3608);
                  ++v140;
                }
              }
            }
            if (v140 == v139) {
              char v142 = 1;
            }
          }
        }
        int v140 = 0;
        int v139 = 6;
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"max_factors");
        if (*(void *)&idx[1])
        {
          CFTypeID v51 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v51 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&idx[1]) == v139)
          {
            for (v135[0]  = 0; v135[0] < v139; ++v135[0])
            {
              ValueAtIndex  = (const __CFNumber *)CFArrayGetValueAtIndex(*(CFArrayRef *)&idx[1], v135[0]);
              if (ValueAtIndex)
              {
                CFTypeID v50 = CFNumberGetTypeID();
                if (v50 == CFGetTypeID(ValueAtIndex))
                {
                  CFNumberGetValue(ValueAtIndex, kCFNumberFloatType, (char *)this + 4 * v135[0] + 3632);
                  ++v140;
                }
              }
            }
            if (v140 == v139) {
              char v141 = 1;
            }
          }
        }
        if (v142 & 1) != 0 && (v141) {
          char v143 = 1;
        }
        if (v144)
        {
          *((unsigned char *)this + 3472)  = 1;
          *((unsigned char *)this + 3473)  = 1;
          *((_DWORD *)this + 869)  = 2143289344;
          *((_DWORD *)this + 870)  = 2143289344;
          *((float *)this + 871)  = 2.5;
          *((float *)this + 872)  = 5.0;
          memcpy((char *)this + 3540, (char *)this + 3492, 0x30uLL);
          float v133 = 1.0;
          int v132 = 6;
          if (*((unsigned char *)this + 452)) {
            float v133 = *((float *)this + 891);
          }
          for (int i = 0; i < v132; ++i)
            *((float *)this + i + 891)  = v133;
        }
        else
        {
          *((unsigned char *)this + 3472)  = 0;
        }
        if (v143)
        {
          *((unsigned char *)this + 3588)  = 1;
          *((unsigned char *)this + 3589)  = 1;
          *((_DWORD *)this + 898)  = 2143289344;
          *((_DWORD *)this + 899)  = 2143289344;
          *((float *)this + 900)  = 2.5;
          *((float *)this + 901)  = 5.0;
          memcpy((char *)this + 3656, (char *)this + 3608, 0x30uLL);
          float valuePtr = 1.0;
          int v129 = 6;
          *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"max_factor_aab_off");
          if (*((unsigned char *)this + 452))
          {
            float valuePtr = *((float *)this + v129 + 919);
          }
          else if (*(void *)&idx[1])
          {
            CFTypeID v49 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
            if (v49 == CFNumberGetTypeID())
            {
              CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, &valuePtr);
              os_log_t v128 = 0;
              if (_logHandle)
              {
                CFTypeID v48 = _logHandle;
              }
              else
              {
                uint64_t v47 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
                CFTypeID v48 = v47;
              }
              os_log_t v128 = v48;
              os_log_type_t v127 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_0_1_8_0((uint64_t)v188, COERCE__INT64(valuePtr));
                _os_log_impl(&dword_1BA438000, v128, v127, "MAX - FACTOR AAB OFF %f", v188, 0xCu);
              }
            }
          }
          for (int j = 0; j < v129; ++j)
            *((float *)this + j + 920)  = valuePtr;
        }
        else
        {
          *((unsigned char *)this + 3588)  = 0;
        }
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"max_rise_time_fast_threshold");
        if (*(void *)&idx[1])
        {
          CFTypeID v46 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v46 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3592);
            os_log_t v125 = 0;
            if (_logHandle)
            {
              CFTypeID v45 = _logHandle;
            }
            else
            {
              uint64_t v44 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              CFTypeID v45 = v44;
            }
            os_log_t v125 = v45;
            os_log_type_t v124 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v187, COERCE__INT64(*((float *)this + 898)));
              _os_log_impl(&dword_1BA438000, v125, v124, "MAX - RISE TIME FAST THRESHOLD %f", v187, 0xCu);
            }
          }
        }
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"max_rise_time_fast");
        if (*(void *)&idx[1])
        {
          CFTypeID v43 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v43 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3596);
            os_log_t v123 = 0;
            if (_logHandle)
            {
              CFTypeID v42 = _logHandle;
            }
            else
            {
              uint64_t v41 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              CFTypeID v42 = v41;
            }
            os_log_t v123 = v42;
            os_log_type_t v122 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v186, COERCE__INT64(*((float *)this + 899)));
              _os_log_impl(&dword_1BA438000, v123, v122, "MAX - RISE TIME FAST %f s", v186, 0xCu);
            }
          }
        }
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"max_rise_time");
        if (*(void *)&idx[1])
        {
          CFTypeID v40 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v40 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3600);
            os_log_t v121 = 0;
            if (_logHandle)
            {
              uint64_t v39 = _logHandle;
            }
            else
            {
              uint64_t v38 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              uint64_t v39 = v38;
            }
            os_log_t v121 = v39;
            os_log_type_t v120 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v185, COERCE__INT64(*((float *)this + 900)));
              _os_log_impl(&dword_1BA438000, v121, v120, "MAX - RISE TIME %f s", v185, 0xCu);
            }
          }
        }
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"max_fall_time");
        if (*(void *)&idx[1])
        {
          CFTypeID v37 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v37 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3604);
            os_log_t v119 = 0;
            if (_logHandle)
            {
              CFTypeID v36 = _logHandle;
            }
            else
            {
              uint64_t v35 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              CFTypeID v36 = v35;
            }
            os_log_t v119 = v36;
            os_log_type_t v118 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v184, COERCE__INT64(*((float *)this + 901)));
              _os_log_impl(&dword_1BA438000, v119, v118, "MAX - FALL TIME %f s", v184, 0xCu);
            }
          }
        }
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"min_rise_time");
        if (*(void *)&idx[1])
        {
          CFTypeID v34 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v34 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3484);
            os_log_t v117 = 0;
            if (_logHandle)
            {
              CFTypeID v33 = _logHandle;
            }
            else
            {
              uint64_t v32 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              CFTypeID v33 = v32;
            }
            os_log_t v117 = v33;
            v116  = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v183, COERCE__INT64(*((float *)this + 871)));
              _os_log_impl(&dword_1BA438000, v117, v116, "MIN - RISE TIME %f s", v183, 0xCu);
            }
          }
        }
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"min_fall_time");
        if (*(void *)&idx[1])
        {
          CFTypeID v31 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v31 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3488);
            os_log_t v115 = 0;
            if (_logHandle)
            {
              float v30 = _logHandle;
            }
            else
            {
              uint64_t v29 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              float v30 = v29;
            }
            os_log_t v115 = v30;
            os_log_type_t v114 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v182, COERCE__INT64(*((float *)this + 872)));
              _os_log_impl(&dword_1BA438000, v115, v114, "MIN - FALL TIME %f s", v182, 0xCu);
            }
          }
        }
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"pivoting_L");
        if (*(void *)&idx[1])
        {
          CFTypeID v28 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v28 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3464);
            os_log_t v113 = 0;
            if (_logHandle)
            {
              os_log_t v27 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v26 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v26 = init_default_corebrightness_log();
              }
              os_log_t v27 = v26;
            }
            os_log_t v113 = v27;
            os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v181, COERCE__INT64(*((float *)this + 866)));
              _os_log_impl(&dword_1BA438000, v113, v112, "Pivoting at L  = %f", v181, 0xCu);
            }
            *((_DWORD *)this + 867)  = *((_DWORD *)this + 866);
          }
        }
        *(void *)&idx[1]  = CFDictionaryGetValue(v155, @"pivoting_L_max");
        if (*(void *)&idx[1])
        {
          CFTypeID v25 = CFGetTypeID(*(CFTypeRef *)&idx[1]);
          if (v25 == CFNumberGetTypeID())
          {
            CFNumberGetValue(*(CFNumberRef *)&idx[1], kCFNumberFloatType, (char *)this + 3468);
            os_log_t v111 = 0;
            if (_logHandle)
            {
              uint64_t v24 = _logHandle;
            }
            else
            {
              uint64_t v23 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              uint64_t v24 = v23;
            }
            os_log_t v111 = v24;
            os_log_type_t v110 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v180, COERCE__INT64(*((float *)this + 867)));
              _os_log_impl(&dword_1BA438000, v111, v110, "Max pivoting at L  = %f", v180, 0xCu);
            }
          }
        }
      }
    }
    else if (v155)
    {
      CFNumberRef v109 = (CFNumberRef)CFDictionaryGetValue(v155, @"min_Factor");
      if (v109)
      {
        int v108 = 0;
        CFNumberGetValue(v109, kCFNumberFloatType, &v108);
        *((_DWORD *)this + 872)  = v108;
        CFNumberRef v107 = (CFNumberRef)CFDictionaryGetValue(v155, @"min_enableTh");
        if (v107) {
          CFNumberGetValue(v107, kCFNumberFloatType, (char *)this + 3476);
        }
        CFNumberRef v106 = (CFNumberRef)CFDictionaryGetValue(v155, @"min_disableTh");
        if (v106) {
          CFNumberGetValue(v106, kCFNumberFloatType, (char *)this + 3480);
        }
        if (v107 && v106) {
          *((unsigned char *)this + 3472)  = 1;
        }
        CFNumberRef v105 = (CFNumberRef)CFDictionaryGetValue(v155, @"min_Factor_AABOff");
        if (v105) {
          CFNumberGetValue(v105, kCFNumberFloatType, (char *)this + 3492);
        }
        CFNumberRef v106 = (CFNumberRef)CFDictionaryGetValue(v155, @"min_disableTh_lowbound");
        if (v106) {
          CFNumberGetValue(v106, kCFNumberFloatType, (char *)this + 3484);
        }
        else {
          *((float *)this + 871)  = *((float *)this + 870) - 200.0;
        }
      }
      CFNumberRef v109 = (CFNumberRef)CFDictionaryGetValue(v155, @"max_Factor");
      if (v109)
      {
        int v104 = 0;
        CFNumberGetValue(v109, kCFNumberFloatType, &v104);
        *((_DWORD *)this + 901)  = v104;
        CFNumberRef v103 = (CFNumberRef)CFDictionaryGetValue(v155, @"max_enableTh");
        if (v103) {
          CFNumberGetValue(v103, kCFNumberFloatType, (char *)this + 3592);
        }
        CFNumberRef v102 = (CFNumberRef)CFDictionaryGetValue(v155, @"max_disableTh");
        if (v102) {
          CFNumberGetValue(v102, kCFNumberFloatType, (char *)this + 3596);
        }
        if (v103 && v102) {
          *((unsigned char *)this + 3588)  = 1;
        }
        CFNumberRef v101 = (CFNumberRef)CFDictionaryGetValue(v155, @"max_Factor_AABOff");
        if (v101) {
          CFNumberGetValue(v101, kCFNumberFloatType, (char *)this + 3608);
        }
        CFNumberRef v102 = (CFNumberRef)CFDictionaryGetValue(v155, @"max_disableTh_highbound");
        if (v102) {
          CFNumberGetValue(v102, kCFNumberFloatType, (char *)this + 3600);
        }
      }
    }
    if (*((unsigned char *)this + 136))
    {
      if (*((_DWORD *)this + 720) == 1)
      {
        *((_DWORD *)this + 864)  = 2;
        *((float *)this + 35)  = 2.0;
        long long v178 = xmmword_1BA613320;
        int v179 = -584398440;
        if (MGIsDeviceOfType()) {
          *((float *)this + 35)  = 15.0;
        }
      }
      if (_os_feature_enabled_impl()) {
        AABC::setupAABCurvesFromPlist(this);
      }
      else {
        AABC::setupAABCurves(this);
      }
      uint64_t v100 = 0;
      if (*((unsigned char *)this + 136)) {
        uint64_t v22 = *MEMORY[0x1E4F1CFD0];
      }
      else {
        uint64_t v22 = *MEMORY[0x1E4F1CFC8];
      }
      uint64_t v100 = v22;
      DisplaySetProperty(*((void *)this + 51), @"ProductTypeAccessory", v22);
      DisplayAccessoryInitializeBrightnessOverrides(*((void *)this + 51));
    }
    if (*(void *)((char *)v153 + 1)) {
      CFRelease(*(CFTypeRef *)((char *)v153 + 1));
    }
    CFDictionaryRef v99 = 0;
    *(void *)((char *)v153 + 1)  = CFPreferencesCopyValue(@"AABCurveCap", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    if (*(void *)((char *)v153 + 1)
      && (CFTypeID v21 = CFGetTypeID(*(CFTypeRef *)((char *)v153 + 1)), v21 == CFDictionaryGetTypeID()))
    {
      CFDictionaryRef v99 = *(CFDictionaryRef *)((char *)v153 + 1);
    }
    else
    {
      CFDictionaryRef v99 = (CFDictionaryRef)DisplayGetProperty(*((void *)this + 51), @"AABCurveCap");
    }
    char v98 = 0;
    char v97 = 0;
    os_log_t v96 = 0;
    if (_logHandle)
    {
      uint64_t v20 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v19 = init_default_corebrightness_log();
      }
      uint64_t v20 = v19;
    }
    os_log_t v96 = v20;
    os_log_type_t v95 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v177, (uint64_t)v99);
      _os_log_impl(&dword_1BA438000, v96, v95, "AAB Curve Cap  = %p\n", v177, 0xCu);
    }
    if (v99)
    {
      int v94 = 0;
      int v93 = 4;
      *(void *)&v92[1]  = CFDictionaryGetValue(v99, @"E");
      if (*(void *)&v92[1])
      {
        CFTypeID v18 = CFGetTypeID(*(CFTypeRef *)&v92[1]);
        if (v18 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&v92[1]) == v93)
        {
          for (v92[0]  = 0; v92[0] < v93; ++v92[0])
          {
            *(void *)&v91[1]  = CFArrayGetValueAtIndex(*(CFArrayRef *)&v92[1], v92[0]);
            if (*(void *)&v91[1])
            {
              CFTypeID v17 = CFNumberGetTypeID();
              if (v17 == CFGetTypeID(*(CFTypeRef *)&v91[1]))
              {
                CFNumberGetValue(*(CFNumberRef *)&v91[1], kCFNumberFloatType, (char *)this + 4 * v92[0] + 1184);
                ++v94;
              }
            }
          }
          if (v94 == v93) {
            char v98 = 1;
          }
        }
      }
      int v94 = 0;
      *(void *)&v92[1]  = CFDictionaryGetValue(v99, @"L");
      if (*(void *)&v92[1])
      {
        CFTypeID v16 = CFGetTypeID(*(CFTypeRef *)&v92[1]);
        if (v16 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)&v92[1]) == v93)
        {
          for (v91[0]  = 0; v91[0] < v93; ++v91[0])
          {
            CFTypeRef cf = CFArrayGetValueAtIndex(*(CFArrayRef *)&v92[1], v91[0]);
            if (cf)
            {
              CFTypeID v15 = CFNumberGetTypeID();
              if (v15 == CFGetTypeID(cf))
              {
                CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, (char *)this + 4 * v91[0] + 1200);
                ++v94;
                if (*((float *)this + v91[0] + 300) < 0.0) {
                  *((_DWORD *)this + v91[0] + 300)  = *((_DWORD *)this + 182);
                }
                if (*((float *)this + v91[0] + 300) < *((float *)this + 180)) {
                  *((_DWORD *)this + v91[0] + 300)  = *((_DWORD *)this + 180);
                }
              }
            }
          }
          if (v94 == v93) {
            char v97 = 1;
          }
        }
      }
      CFTypeRef v89 = CFDictionaryGetValue(v99, @"revertTime");
      if (v89)
      {
        CFTypeID v14 = CFNumberGetTypeID();
        if (v14 == CFGetTypeID(v89)) {
          CFNumberGetValue((CFNumberRef)v89, kCFNumberDoubleType, (char *)this + 1216);
        }
      }
    }
    if (v98 & 1) != 0 && (v97)
    {
      os_log_t oslog = 0;
      if (_logHandle)
      {
        uint64_t v13 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v12 = init_default_corebrightness_log();
        }
        uint64_t v13 = v12;
      }
      os_log_t oslog = v13;
      os_log_type_t v87 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_8_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v176, COERCE__INT64(*((float *)this + 296)), COERCE__INT64(*((float *)this + 300)), COERCE__INT64(*((float *)this + 297)), COERCE__INT64(*((float *)this + 301)), COERCE__INT64(*((float *)this + 298)), COERCE__INT64(*((float *)this + 302)), COERCE__INT64(*((float *)this + 299)), COERCE__INT64(*((float *)this + 303)));
        _os_log_impl(&dword_1BA438000, oslog, v87, "AAB Curve Cap found: (%f, %f) - (%f, %f) - (%f, %f) - (%f, %f)", v176, 0x52u);
      }
      *((unsigned char *)this + 3401)  = 1;
    }
    if (*(void *)((char *)v153 + 1)) {
      CFRelease(*(CFTypeRef *)((char *)v153 + 1));
    }
    if ((*((unsigned char *)this + 400) & 1) == 0)
    {
      AABC::CreateDefaultCurves(this);
      *((CFAbsoluteTime *)this + 414)  = CFAbsoluteTimeGetCurrent();
      os_log_t v86 = 0;
      if (_logHandle)
      {
        uint64_t v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v10 = init_default_corebrightness_log();
        }
        uint64_t v11 = v10;
      }
      os_log_t v86 = v11;
      os_log_type_t v85 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v175, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)));
        _os_log_impl(&dword_1BA438000, v86, v85, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f", v175, 0x2Au);
      }
      os_log_t v84 = 0;
      if (_logHandle)
      {
        io_registry_entry_t v9 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v8 = init_default_corebrightness_log();
        }
        io_registry_entry_t v9 = v8;
      }
      os_log_t v84 = v9;
      os_log_type_t v83 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v174, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
        _os_log_impl(&dword_1BA438000, v84, v83, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v174, 0x2Au);
      }
      *((unsigned char *)this + 400)  = 1;
      memset(values, 0, sizeof(values));
      for (int k = 0; k < 3; ++k)
      {
        int v81 = 1;
        memcpy(__dst, off_1E621A868, sizeof(__dst));
        memset(__b, 0, sizeof(__b));
        __b[0]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v81);
        __b[1]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 104 * k + 752);
        __b[2]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 104 * k + 760);
        __b[3]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 104 * k + 756);
        __b[4]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 104 * k + 764);
        __b[5]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 104 * k + 736);
        __b[6]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 104 * k + 740);
        __b[7]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 104 * k + 744);
        __b[8]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)this + 104 * k + 748);
        CFDictionaryRef v7 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __dst, __b, 9, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        values[k]  = v7;
        CFRelease(__b[8]);
        CFRelease(__b[7]);
        CFRelease(__b[6]);
        CFRelease(__b[5]);
        CFRelease(__b[4]);
        CFRelease(__b[3]);
        CFRelease(__b[2]);
        CFRelease(__b[1]);
        CFRelease(__b[0]);
      }
      value  = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 3, MEMORY[0x1E4F1D510]);
      for (m  = 0; m < 3; ++m)
        CFRelease(values[m]);
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"ALSDefaultCurves", value);
    }
    *((_DWORD *)this + 86)  = 1017370378;
    *((_DWORD *)this + 87)  = 0;
    AABC::setupDefaultsForAoT(this);
    if (*((_DWORD *)this + 1006) == 1) {
      operator new();
    }
    operator new();
  }
}

void sub_1BA5BB084()
{
  _Unwind_Resume(v0);
}

void AABC::setupAABCurvesFromPlist(AABC *this)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  int v81 = this;
  CFDictionaryRef theDict = 0;
  CFDictionaryRef v79 = 0;
  filePath  = 0;
  error  = 0;
  resourceData  = 0;
  errorCode  = 0;
  url  = 0;
  char v73 = 0;
  double Current = CFAbsoluteTimeGetCurrent();
  CFDictionaryRef v79 = (CFDictionaryRef)CFPreferencesCopyValue(@"CurveOverride", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
  if (v79)
  {
    os_log_t oslog = 0;
    if (_logHandle)
    {
      uint64_t v39 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v39 = inited;
    }
    os_log_t oslog = v39;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t log = oslog;
      os_log_type_t v37 = type;
      __os_log_helper_16_0_0(v69);
      _os_log_impl(&dword_1BA438000, log, v37, "using curve data from user defaults", v69, 2u);
    }
LABEL_87:
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v79, @"A");
    char v73 = AABC::populateCurveValuesFromDictionary(this, Value, (CustomCurve *)((char *)this + 1224), 20) & 1;
    if (v73)
    {
      CFDictionaryRef v2 = (const __CFDictionary *)CFDictionaryGetValue(v79, @"B");
      char v73 = AABC::populateCurveValuesFromDictionary(this, v2, (CustomCurve *)((char *)this + 1388), 20) & 1;
      if (v73)
      {
        os_log_t v45 = 0;
        if (_logHandle)
        {
          uint64_t v11 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v10 = init_default_corebrightness_log();
          }
          uint64_t v11 = v10;
        }
        os_log_t v45 = v11;
        os_log_type_t v44 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          CFAbsoluteTime v3 = CFAbsoluteTimeGetCurrent();
          __os_log_helper_16_0_1_8_0((uint64_t)v82, COERCE__INT64(v3 - Current));
          _os_log_impl(&dword_1BA438000, v45, v44, "loading curves took %0.4fs", v82, 0xCu);
        }
        if (CFPreferencesGetAppBooleanValue(@"WriteCurveUserDefault", @"com.apple.CoreBrightness", 0))
        {
          AABC::writeCurveToUserDefaults(this, (CustomCurve *)((char *)this + 1224), @"CustomCurveA", v4);
          AABC::writeCurveToUserDefaults(this, (CustomCurve *)((char *)this + 1388), @"CustomCurveB", v5);
        }
      }
      else
      {
        os_log_t v48 = 0;
        if (_logHandle)
        {
          CFTypeID v15 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v14 = init_default_corebrightness_log();
          }
          CFTypeID v15 = v14;
        }
        os_log_t v48 = v15;
        os_log_type_t v47 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          uint64_t v12 = v48;
          os_log_type_t v13 = v47;
          __os_log_helper_16_0_0(v46);
          _os_log_error_impl(&dword_1BA438000, v12, v13, "error reading curve B from plist", v46, 2u);
        }
      }
    }
    else
    {
      os_log_t v51 = 0;
      if (_logHandle)
      {
        uint64_t v19 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v18 = init_default_corebrightness_log();
        }
        uint64_t v19 = v18;
      }
      os_log_t v51 = v19;
      os_log_type_t v50 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        CFTypeID v16 = v51;
        os_log_type_t v17 = v50;
        __os_log_helper_16_0_0(v49);
        _os_log_error_impl(&dword_1BA438000, v16, v17, "error reading curve A from plist", v49, 2u);
      }
    }
    goto LABEL_117;
  }
  int v68 = (void *)MGCopyAnswer();
  key  = @"1";
  long long v95 = xmmword_1BA613334;
  int v96 = 1425254930;
  if (MGIsDeviceOfType())
  {
    key  = @"1";
  }
  else
  {
    long long v93 = xmmword_1BA613348;
    int v94 = 1899561076;
    if (MGIsDeviceOfType())
    {
      key  = @"1";
    }
    else
    {
      long long v91 = xmmword_1BA61335C;
      int v92 = -584398440;
      if (MGIsDeviceOfType())
      {
        key  = @"2";
      }
      else
      {
        long long v89 = xmmword_1BA613370;
        int v90 = -879476163;
        if (MGIsDeviceOfType())
        {
          key  = @"3";
        }
        else
        {
          os_log_t v66 = 0;
          if (_logHandle)
          {
            uint64_t v35 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v34 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v34 = init_default_corebrightness_log();
            }
            uint64_t v35 = v34;
          }
          os_log_t v66 = v35;
          os_log_type_t v65 = OS_LOG_TYPE_ERROR;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            uint64_t v32 = v66;
            os_log_type_t v33 = v65;
            __os_log_helper_16_0_0(v64);
            _os_log_error_impl(&dword_1BA438000, v32, v33, "unknown model", v64, 2u);
          }
        }
      }
    }
  }
  os_log_t v63 = 0;
  if (_logHandle)
  {
    CFTypeID v31 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v30 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v30 = init_default_corebrightness_log();
    }
    CFTypeID v31 = v30;
  }
  os_log_t v63 = v31;
  os_log_type_t v62 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_2_2_8_64_8_64((uint64_t)v88, (uint64_t)key, (uint64_t)v68);
    _os_log_impl(&dword_1BA438000, v63, v62, "loading curve from plist for model %@ and enclosure color %@", v88, 0x16u);
  }
  filePath  = CFStringCreateWithCString(0, "/System/Library/PrivateFrameworks/CoreBrightness.framework/DefaultCurves.plist", 0x8000100u);
  url  = CFURLCreateWithFileSystemPath(0, filePath, kCFURLPOSIXPathStyle, 0);
  CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)*MEMORY[0x1E4F1CF80], url, &resourceData, 0, 0, &errorCode);
  if (errorCode)
  {
    os_log_t v61 = 0;
    if (_logHandle)
    {
      uint64_t v29 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v28 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v28 = init_default_corebrightness_log();
      }
      uint64_t v29 = v28;
    }
    os_log_t v61 = v29;
    os_log_type_t v60 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_1_8_64((uint64_t)v87, (uint64_t)filePath);
      _os_log_impl(&dword_1BA438000, v61, v60, "unable to open %@", v87, 0xCu);
    }
  }
  else
  {
    CFDictionaryRef theDict = (CFDictionaryRef)CFPropertyListCreateWithData(0, resourceData, 0, 0, &error);
    if (theDict)
    {
      CFDictionaryRef v79 = (CFDictionaryRef)CFDictionaryGetValue(theDict, key);
      if (v79)
      {
        if (!CFDictionaryGetCountOfKey(v79, v68))
        {
          os_log_t v55 = 0;
          if (_logHandle)
          {
            uint64_t v23 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v22 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v22 = init_default_corebrightness_log();
            }
            uint64_t v23 = v22;
          }
          os_log_t v55 = v23;
          os_log_type_t v54 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_2_1_8_64((uint64_t)v84, (uint64_t)v68);
            _os_log_impl(&dword_1BA438000, v55, v54, "no entry found for color %@, using white instead", v84, 0xCu);
          }
          int v68 = @"2";
        }
        CFDictionaryRef v79 = (CFDictionaryRef)CFDictionaryGetValue(v79, v68);
        if (v79) {
          goto LABEL_87;
        }
        os_log_t v53 = 0;
        if (_logHandle)
        {
          CFTypeID v21 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v20 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v20 = init_default_corebrightness_log();
          }
          CFTypeID v21 = v20;
        }
        os_log_t v53 = v21;
        os_log_type_t v52 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_1_8_64((uint64_t)v83, (uint64_t)v68);
          _os_log_impl(&dword_1BA438000, v53, v52, "no entry found for color %@", v83, 0xCu);
        }
      }
      else
      {
        os_log_t v57 = 0;
        if (_logHandle)
        {
          CFTypeID v25 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v24 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v24 = init_default_corebrightness_log();
          }
          CFTypeID v25 = v24;
        }
        os_log_t v57 = v25;
        os_log_type_t v56 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_1_8_64((uint64_t)v85, (uint64_t)key);
          _os_log_impl(&dword_1BA438000, v57, v56, "no entry found for accessory with index %@", v85, 0xCu);
        }
      }
    }
    else
    {
      os_log_t v59 = 0;
      if (_logHandle)
      {
        os_log_t v27 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v26 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v26 = init_default_corebrightness_log();
        }
        os_log_t v27 = v26;
      }
      os_log_t v59 = v27;
      os_log_type_t v58 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v86, (uint64_t)error);
        _os_log_impl(&dword_1BA438000, v59, v58, "error reading plist: %@", v86, 0xCu);
      }
      if (error) {
        CFRelease(error);
      }
    }
  }
LABEL_117:
  if ((v73 & 1) == 0)
  {
    os_log_t v43 = 0;
    if (_logHandle)
    {
      io_registry_entry_t v9 = _logHandle;
    }
    else
    {
      uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      io_registry_entry_t v9 = v8;
    }
    os_log_t v43 = v9;
    os_log_type_t v42 = OS_LOG_TYPE_ERROR;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      float v6 = v43;
      os_log_type_t v7 = v42;
      __os_log_helper_16_0_0(v41);
      _os_log_error_impl(&dword_1BA438000, v6, v7, "error reading default curve", v41, 2u);
    }
  }
  if (resourceData) {
    CFRelease(resourceData);
  }
  if (url) {
    CFRelease(url);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (filePath) {
    CFRelease(filePath);
  }
}

void AABC::setupAABCurves(AABC *this)
{
  os_log_type_t v114 = v169;
  keys[3]  = *(void **)MEMORY[0x1E4F143B8];
  os_log_type_t v158 = this;
  os_log_t v115 = this;
  int v156 = MGGetSInt32Answer();
  int v157 = v156;
  if (v156 != 1 && v157 != 2) {
    int v157 = 1;
  }
  BOOL v155 = 0;
  CFTypeRef v154 = 0;
  uint64_t v1 = CFPreferencesCopyValue(@"CustomCurveVersion", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
  CFTypeRef v154 = v1;
  if (v1)
  {
    CFTypeID v113 = CFGetTypeID(v154);
    if (v113 == CFNumberGetTypeID())
    {
      float v153 = 0.0;
      CFTypeRef v152 = v154;
      CFNumberGetValue((CFNumberRef)v154, kCFNumberFloatType, &v153);
      BOOL v155 = v153 == 1.1;
    }
    CFRelease(v154);
  }
  char v151 = 1;
  if (*((_DWORD *)v115 + 720) != 1 && v155)
  {
    uint64_t v1 = CFPreferencesCopyValue(@"CustomCurveA", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    CFTypeRef v154 = v1;
    if (v1)
    {
      CFTypeID v112 = CFGetTypeID(v154);
      if (v112 == CFDictionaryGetTypeID())
      {
        CFDictionaryRef v150 = (const __CFDictionary *)v154;
        unsigned __int8 Count = 0;
        unsigned __int8 v147 = 0;
        CFTypeRef Value = CFDictionaryGetValue((CFDictionaryRef)v154, @"Ea");
        if (Value)
        {
          CFTypeID v111 = CFGetTypeID(Value);
          if (v111 == CFArrayGetTypeID())
          {
            unsigned __int8 Count = CFArrayGetCount((CFArrayRef)Value);
            if (Count <= 0x14u) {
              int v110 = Count;
            }
            else {
              int v110 = 20;
            }
            unsigned __int8 Count = v110;
            for (int i = 0; i < Count; ++i)
            {
              ValueAtIndex  = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)Value, i);
              if (ValueAtIndex)
              {
                CFTypeID TypeID = CFNumberGetTypeID();
                if (TypeID == CFGetTypeID(ValueAtIndex)) {
                  CFNumberGetValue(ValueAtIndex, kCFNumberFloatType, (char *)v115 + 4 * i + 1224);
                }
              }
            }
          }
        }
        CFTypeRef Value = CFDictionaryGetValue(v150, @"La");
        if (Value)
        {
          CFTypeID v108 = CFGetTypeID(Value);
          if (v108 == CFArrayGetTypeID())
          {
            unsigned __int8 v147 = CFArrayGetCount((CFArrayRef)Value);
            if (v147 <= 0x14u) {
              int v107 = v147;
            }
            else {
              int v107 = 20;
            }
            unsigned __int8 v147 = v107;
            for (int j = 0; j < v147; ++j)
            {
              CFNumberRef v143 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)Value, j);
              if (v143)
              {
                CFTypeID v106 = CFNumberGetTypeID();
                if (v106 == CFGetTypeID(v143)) {
                  CFNumberGetValue(v143, kCFNumberFloatType, (char *)v115 + 4 * j + 1304);
                }
              }
            }
          }
        }
        if (Count <= (int)v147) {
          int v105 = Count;
        }
        else {
          int v105 = v147;
        }
        *((_DWORD *)v115 + 346)  = v105;
        CFRelease(v150);
        char v151 = 0;
      }
      else
      {
        CFRelease(v154);
      }
    }
  }
  if (v151)
  {
    uint64_t v5 = v115;
    *((_OWORD *)v114 + 34)  = xmmword_1E621AB50;
    if (*((_DWORD *)v5 + 720) == 1)
    {
      float v142 = 0.0;
      float v141 = 0.0;
      float v6 = *((float *)v115 + 177) + 0.735 * (float)(*((float *)v115 + 179) - *((float *)v115 + 177));
      float v141 = v6;
      if (v157 == 1)
      {
        float v7 = *((float *)v115 + 177) + 0.0028 * (float)(*((float *)v115 + 179) - *((float *)v115 + 177));
        float v142 = v7;
        CFNumberRef v102 = __dst;
        uint64_t v104 = 60;
        memcpy(__dst, &unk_1BA613384, sizeof(__dst));
        CFNumberRef v103 = v178;
        memcpy(v178, &unk_1BA6133C0, sizeof(v178));
        memcpy((char *)v115 + 1224, __dst, 0x3CuLL);
        uint64_t v1 = memcpy((char *)v115 + 1304, v178, 0x3CuLL);
        *((_DWORD *)v115 + 346)  = 15;
      }
      else if (v157 == 2)
      {
        float v8 = *((float *)v115 + 177) + 0.0018 * (float)(*((float *)v115 + 179) - *((float *)v115 + 177));
        float v142 = v8;
        CFDictionaryRef v99 = v177;
        uint64_t v101 = 60;
        memcpy(v177, &unk_1BA6133FC, sizeof(v177));
        uint64_t v100 = v176;
        memcpy(v176, &unk_1BA613438, sizeof(v176));
        memcpy((char *)v115 + 1224, v177, 0x3CuLL);
        uint64_t v1 = memcpy((char *)v115 + 1304, v176, 0x3CuLL);
        *((_DWORD *)v115 + 346)  = 15;
      }
      for (int k = 0; k < *((_DWORD *)v115 + 346); ++k)
      {
        io_registry_entry_t v9 = v115;
        *((float *)v115 + k + 326)  = fminf(v141, *((float *)v115 + k + 326));
        *((float *)v9 + k + 326)  = fmaxf(v142, *((float *)v9 + k + 326));
      }
    }
    else if (v157 == 1)
    {
      int v96 = v175;
      uint64_t v98 = 68;
      memcpy(v175, &unk_1BA613474, sizeof(v175));
      uint64_t v97 = v174;
      memcpy(v174, &unk_1BA6134B8, sizeof(v174));
      memcpy((char *)v115 + 1224, v175, 0x44uLL);
      uint64_t v1 = memcpy((char *)v115 + 1304, v174, 0x44uLL);
      *((_DWORD *)v115 + 346)  = 17;
    }
    else if (v157 == 2)
    {
      long long v93 = v173;
      uint64_t v95 = 68;
      memcpy(v173, &unk_1BA6134FC, sizeof(v173));
      int v94 = v172;
      memcpy(v172, &unk_1BA613540, sizeof(v172));
      memcpy((char *)v115 + 1224, v173, 0x44uLL);
      uint64_t v1 = memcpy((char *)v115 + 1304, v172, 0x44uLL);
      *((_DWORD *)v115 + 346)  = 17;
    }
    uint64_t v10 = *((unsigned int *)v115 + 346);
    int v139 = &v45;
    unint64_t v87 = (8 * v10 + 15) & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1F4188790](v1, v2, v3, v4);
    int v88 = (const void **)((char *)&v45 - v87);
    uint64_t v138 = v11;
    uint64_t v89 = 512;
    if ((unint64_t)(8 * v11) <= 0x200) {
      size_t v12 = 8 * v11;
    }
    else {
      size_t v12 = 512;
    }
    bzero((char *)&v45 - v87, v12);
    uint64_t v91 = *((unsigned int *)v115 + 346);
    unint64_t v90 = (8 * v91 + 15) & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1F4188790](v13, v14, v15, v16);
    int v92 = (const void **)((char *)&v45 - v90);
    uint64_t v137 = v91;
    if ((unint64_t)(8 * v91) <= 0x200) {
      size_t v18 = 8 * v91;
    }
    else {
      size_t v18 = v17;
    }
    bzero((char *)&v45 - v90, v18);
    for (m  = 0; m < *((_DWORD *)v115 + 346); ++m)
    {
      CFNumberRef v19 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)v115 + 4 * m + 1224);
      v88[m]  = v19;
    }
    for (n  = 0; n < *((_DWORD *)v115 + 346); ++n)
    {
      CFNumberRef v20 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)v115 + 4 * n + 1304);
      v92[n]  = v20;
    }
    os_log_type_t v83 = (const void **)&v170;
    CFArrayRef v170 = 0;
    CFArrayRef v171 = 0;
    int v82 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex v22 = *((int *)v115 + 346);
    int v81 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    CFArrayRef v170 = CFArrayCreate(v21, v88, v22, MEMORY[0x1E4F1D510]);
    CFArrayRef v171 = CFArrayCreate(*v82, v92, *((int *)v115 + 346), v81);
    CFDictionaryRef v134 = 0;
    CFDictionaryRef v134 = CFDictionaryCreate(*v82, (const void **)keys, v83, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    os_log_t v84 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
    CFStringRef v23 = (const __CFString *)*MEMORY[0x1E4F1D3F0];
    os_log_type_t v85 = (CFStringRef *)MEMORY[0x1E4F1D3E0];
    CFStringRef v24 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
    CFStringRef v86 = @"com.apple.CoreBrightness";
    CFPreferencesSetValue(@"CustomCurveA", v134, @"com.apple.CoreBrightness", v23, v24);
    CFPreferencesSynchronize(v86, *v84, *v85);
    for (iint i = 0; ii < *((_DWORD *)v115 + 346); ++ii)
    {
      CFRelease(v88[ii]);
      CFRelease(v92[ii]);
    }
    CFRelease(v134);
  }
  char v151 = 1;
  if (*((_DWORD *)v115 + 720) != 1 && v155)
  {
    uint64_t v1 = CFPreferencesCopyValue(@"CustomCurveB", @"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
    CFTypeRef v154 = v1;
    if (v1)
    {
      CFTypeID v80 = CFGetTypeID(v154);
      if (v80 == CFDictionaryGetTypeID())
      {
        CFDictionaryRef v132 = (const __CFDictionary *)v154;
        CFTypeRef v131 = 0;
        unsigned __int8 v130 = 0;
        unsigned __int8 v129 = 0;
        CFTypeRef v131 = CFDictionaryGetValue((CFDictionaryRef)v154, @"Eb");
        if (v131)
        {
          CFTypeID v79 = CFGetTypeID(v131);
          if (v79 == CFArrayGetTypeID())
          {
            unsigned __int8 v130 = CFArrayGetCount((CFArrayRef)v131);
            if (v130 <= 0x14u) {
              int v78 = v130;
            }
            else {
              int v78 = 20;
            }
            unsigned __int8 v130 = v78;
            for (jint j = 0; jj < v130; ++jj)
            {
              CFTypeRef v127 = 0;
              CFTypeRef v127 = CFArrayGetValueAtIndex((CFArrayRef)v131, jj);
              if (v127)
              {
                CFTypeID v77 = CFNumberGetTypeID();
                CFTypeID v25 = CFGetTypeID(v127);
                if (v77 == v25) {
                  CFNumberGetValue((CFNumberRef)v127, kCFNumberFloatType, (char *)v115 + 4 * jj + 1388);
                }
              }
            }
          }
        }
        CFTypeRef v131 = CFDictionaryGetValue(v132, @"Lb");
        if (v131)
        {
          CFTypeID v76 = CFGetTypeID(v131);
          if (v76 == CFArrayGetTypeID())
          {
            unsigned __int8 v129 = CFArrayGetCount((CFArrayRef)v131);
            if (v129 <= 0x14u) {
              int v75 = v129;
            }
            else {
              int v75 = 20;
            }
            unsigned __int8 v129 = v75;
            for (kint k = 0; kk < v129; ++kk)
            {
              CFTypeRef v125 = 0;
              CFTypeRef v125 = CFArrayGetValueAtIndex((CFArrayRef)v131, kk);
              if (v125)
              {
                CFTypeID v74 = CFNumberGetTypeID();
                CFTypeID v26 = CFGetTypeID(v125);
                if (v74 == v26) {
                  CFNumberGetValue((CFNumberRef)v125, kCFNumberFloatType, (char *)v115 + 4 * kk + 1468);
                }
              }
            }
          }
        }
        if (v130 <= (int)v129) {
          int v73 = v130;
        }
        else {
          int v73 = v129;
        }
        *((_DWORD *)v115 + 387)  = v73;
        CFRelease(v132);
        char v151 = 0;
      }
      else
      {
        CFRelease(v154);
      }
    }
  }
  if (v151)
  {
    os_log_t v27 = v115;
    *(_OWORD *)os_log_type_t v114 = xmmword_1E621AB60;
    if (*((_DWORD *)v27 + 720) == 1)
    {
      if (v157 == 1)
      {
        uint64_t v70 = v168;
        size_t v72 = 48;
        memcpy(v168, &unk_1BA613584, sizeof(v168));
        uint64_t v71 = v167;
        memcpy(v167, &unk_1BA6135B4, sizeof(v167));
        memcpy((char *)v115 + 1388, v168, 0x30uLL);
        uint64_t v1 = memcpy((char *)v115 + 1468, v71, v72);
        *((_DWORD *)v115 + 387)  = 12;
      }
      else if (v157 == 2)
      {
        uint64_t v67 = v166;
        size_t v69 = 48;
        memcpy(v166, &unk_1BA6135E4, sizeof(v166));
        int v68 = v165;
        memcpy(v165, &unk_1BA613614, sizeof(v165));
        memcpy((char *)v115 + 1388, v166, 0x30uLL);
        uint64_t v1 = memcpy((char *)v115 + 1468, v68, v69);
        *((_DWORD *)v115 + 387)  = 12;
      }
    }
    else if (v157 == 1)
    {
      os_log_type_t v64 = v164;
      size_t v66 = 48;
      memcpy(v164, &unk_1BA613644, sizeof(v164));
      os_log_type_t v65 = v163;
      memcpy(v163, &unk_1BA613674, sizeof(v163));
      memcpy((char *)v115 + 1388, v164, 0x30uLL);
      uint64_t v1 = memcpy((char *)v115 + 1468, v65, v66);
      *((_DWORD *)v115 + 387)  = 12;
    }
    else if (v157 == 2)
    {
      os_log_t v61 = v162;
      size_t v63 = 44;
      memcpy(v162, &unk_1BA6136A4, sizeof(v162));
      os_log_type_t v62 = v161;
      memcpy(v161, &unk_1BA6136D0, sizeof(v161));
      memcpy((char *)v115 + 1388, v162, 0x2CuLL);
      uint64_t v1 = memcpy((char *)v115 + 1468, v62, v63);
      *((_DWORD *)v115 + 387)  = 11;
    }
    uint64_t v28 = *((unsigned int *)v115 + 387);
    os_log_type_t v124 = &v45;
    unint64_t v55 = (8 * v28 + 15) & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1F4188790](v1, v2, v3, v4);
    os_log_type_t v56 = (const void **)((char *)&v45 - v55);
    uint64_t v123 = v29;
    uint64_t v57 = 512;
    if ((unint64_t)(8 * v29) <= 0x200) {
      size_t v30 = 8 * v29;
    }
    else {
      size_t v30 = 512;
    }
    bzero((char *)&v45 - v55, v30);
    uint64_t v59 = *((unsigned int *)v115 + 387);
    unint64_t v58 = (8 * v59 + 15) & 0xFFFFFFFFFFFFFFF0;
    MEMORY[0x1F4188790](v31, v32, v33, v34);
    os_log_type_t v60 = (const void **)((char *)&v45 - v58);
    uint64_t v122 = v59;
    if ((unint64_t)(8 * v59) <= 0x200) {
      size_t v36 = 8 * v59;
    }
    else {
      size_t v36 = v35;
    }
    bzero((char *)&v45 - v58, v36);
    for (mm  = 0; mm < *((_DWORD *)v115 + 387); ++mm)
    {
      CFNumberRef v37 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)v115 + 4 * mm + 1388);
      v56[mm]  = v37;
    }
    for (nn  = 0; nn < *((_DWORD *)v115 + 387); ++nn)
    {
      CFNumberRef v38 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, (char *)v115 + 4 * nn + 1468);
      v60[nn]  = v38;
    }
    os_log_t v51 = (const void **)&v159;
    CFArrayRef v159 = 0;
    CFArrayRef v160 = 0;
    os_log_type_t v50 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    CFAllocatorRef v39 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFIndex v40 = *((int *)v115 + 387);
    CFTypeID v49 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    CFArrayRef v159 = CFArrayCreate(v39, v56, v40, MEMORY[0x1E4F1D510]);
    CFArrayRef v160 = CFArrayCreate(*v50, v60, *((int *)v115 + 387), v49);
    CFDictionaryRef v119 = 0;
    CFDictionaryRef v119 = CFDictionaryCreate(*v50, v169, v51, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    os_log_type_t v52 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
    CFStringRef v41 = (const __CFString *)*MEMORY[0x1E4F1D3F0];
    os_log_t v53 = (CFStringRef *)MEMORY[0x1E4F1D3E0];
    CFStringRef v42 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
    CFStringRef v54 = @"com.apple.CoreBrightness";
    CFPreferencesSetValue(@"CustomCurveB", v119, @"com.apple.CoreBrightness", v41, v42);
    CFPreferencesSynchronize(v54, *v52, *v53);
    for (i1  = 0; i1 < *((_DWORD *)v115 + 387); ++i1)
    {
      CFRelease(v56[i1]);
      CFRelease(v60[i1]);
    }
    CFRelease(v119);
  }
  if (!v155)
  {
    int v117 = 1066192077;
    v116  = 0;
    v116  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &v117);
    CFTypeID v46 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
    CFStringRef v43 = (const __CFString *)*MEMORY[0x1E4F1D3F0];
    os_log_type_t v47 = (CFStringRef *)MEMORY[0x1E4F1D3E0];
    CFStringRef v44 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
    CFStringRef v48 = @"com.apple.CoreBrightness";
    CFPreferencesSetValue(@"CustomCurveVersion", v116, @"com.apple.CoreBrightness", v43, v44);
    CFPreferencesSynchronize(v48, *v46, *v47);
    CFRelease(v116);
  }
}

void *AABC::CreateDefaultCurves(AABC *this)
{
  CFStringRef v23 = this;
  if (*((unsigned char *)this + 1552))
  {
    CFIndex v22 = 0;
    if (_logHandle)
    {
      io_registry_entry_t v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      io_registry_entry_t v9 = inited;
    }
    CFIndex v22 = v9;
    os_log_type_t v21 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t log = v22;
      os_log_type_t type = v21;
      __os_log_helper_16_0_0(v20);
      _os_log_impl(&dword_1BA438000, log, type, "Creating AAB Curves from the customCurves.", v20, 2u);
    }
    for (int i = 0; i < 3; ++i)
    {
      AAB::customCurveToCurve((const CustomCurve *)((char *)this + 164 * i + 1556), v18);
      memcpy((char *)this + 104 * i + 736, v18, 0x68uLL);
    }
  }
  else
  {
    size_t v17 = 0;
    if (_logHandle)
    {
      uint64_t v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v4 = init_default_corebrightness_log();
      }
      uint64_t v5 = v4;
    }
    size_t v17 = v5;
    os_log_type_t v16 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v2 = v17;
      os_log_type_t v3 = v16;
      __os_log_helper_16_0_0(v15);
      _os_log_impl(&dword_1BA438000, v2, v3, "No AAB curve present in EDT. Creating Default curves.", v15, 2u);
    }
    float v14 = 0.0;
    float v14 = *((float *)this + 178);
    if (*((_DWORD *)this + 80) == 6) {
      float v14 = 149.54;
    }
    for (int j = 0; j < 3; ++j)
    {
      float v12 = 0.0;
      float v12 = *((float *)this + 177);
      if (*((_DWORD *)this + 721) && j == 2) {
        float v12 = 5.0;
      }
      AAB::DefaultCurve((uint64_t)this, j, *((unsigned char *)this + 1152) & 1, (float *)this + 289, (uint64_t)this + 1164, (float *)this + 293, (uint64_t)v11, v12, v14, *((float *)this + 182));
      memcpy((char *)this + 104 * j + 736, v11, 0x68uLL);
    }
  }
  memcpy((char *)this + 1048, (char *)this + 104 * *((unsigned int *)this + 851) + 736, 0x68uLL);
  *((_DWORD *)this + 286)  = (*(uint64_t (**)(void))(**((void **)this + 8) + 104))(*((void *)this + 8));
  memcpy((char *)this + 2896, (char *)this + 1048, 0x68uLL);
  memcpy((char *)this + 3000, (char *)this + 1048, 0x68uLL);
  *((_DWORD *)this + 774)  = (*(uint64_t (**)(void))(**((void **)this + 8) + 112))(*((void *)this + 8));
  memcpy((char *)this + 3104, (char *)this + 3000, 0x68uLL);
  (*(void (**)(void, char *))(**((void **)this + 8) + 80))(*((void *)this + 8), (char *)this + 2896);
  (*(void (**)(void, char *))(**((void **)this + 8) + 88))(*((void *)this + 8), (char *)this + 3104);
  double result = memcpy((char *)this + 3208, (char *)this + 1048, 0x68uLL);
  *((_DWORD *)this + 832)  = 0;
  *((void *)this + 417)  = 0;
  *((void *)this + 418)  = 0;
  *((void *)this + 419)  = 0;
  *((_DWORD *)this + 840)  = 0;
  return result;
}

void AABC::setupDefaultsForAoT(AABC *this)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  CFStringRef v23 = this;
  long long v42 = xmmword_1BA6136FC;
  int v43 = 1184645120;
  LODWORD(v40)  = *((_DWORD *)this + 177);
  *(void *)((char *)&v40 + 4)  = COERCE_UNSIGNED_INT(30.0) | 0x42C4000000000000;
  HIDWORD(v40)  = 1140457472;
  int v41 = 1140457472;
  *((_OWORD *)this + 128)  = xmmword_1BA6136FC;
  *((_DWORD *)this + 516)  = v43;
  *((_OWORD *)this + 133)  = v40;
  *((_DWORD *)this + 536)  = v41;
  *((_DWORD *)this + 552)  = 5;
  long long v38 = xmmword_1BA613710;
  int v39 = 1184645120;
  LODWORD(v36)  = *((_DWORD *)this + 177);
  *(void *)((char *)&v36 + 4)  = COERCE_UNSIGNED_INT(30.0) | 0x42C4000000000000;
  HIDWORD(v36)  = 1140457472;
  int v37 = 1140457472;
  *(_OWORD *)((char *)this + 2212)  = xmmword_1BA613710;
  *((_DWORD *)this + 557)  = v39;
  *(_OWORD *)((char *)this + 2292)  = v36;
  *((_DWORD *)this + 577)  = v37;
  *((_DWORD *)this + 593)  = 5;
  long long v34 = xmmword_1BA613724;
  int v35 = 1184645120;
  LODWORD(v32)  = *((_DWORD *)this + 177);
  *(void *)((char *)&v32 + 4)  = COERCE_UNSIGNED_INT(30.0) | 0x42C4000000000000;
  HIDWORD(v32)  = 1140457472;
  int v33 = 1140457472;
  *(_OWORD *)((char *)this + 2376)  = xmmword_1BA613724;
  *((_DWORD *)this + 598)  = v35;
  *(_OWORD *)((char *)this + 2456)  = v32;
  *((_DWORD *)this + 618)  = v33;
  *((_DWORD *)this + 634)  = 5;
  memcpy((char *)this + 2540, (char *)this + 164 * *((unsigned int *)this + 851) + 2048, 0xA4uLL);
  memset(__b, 0, sizeof(__b));
  uint64_t v1 = memcpy((char *)this + 2704, __b, 0xA4uLL);
  *((_DWORD *)this + 717)  = 0;
  context  = (void *)MEMORY[0x1BA9ECAE0](v1);
  id v21 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v20 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (int i = 0; i < *((_DWORD *)this + 552); ++i)
  {
    LODWORD(v2)  = *((_DWORD *)this + i + 512);
    objc_msgSend(v21, "addObject:", objc_msgSend(NSNumber, "numberWithFloat:", v2));
    LODWORD(v3)  = *((_DWORD *)this + i + 532);
    objc_msgSend(v20, "addObject:", objc_msgSend(NSNumber, "numberWithFloat:", v3));
  }
  v30[0]  = @"lux";
  v31[0]  = v21;
  v30[1]  = @"nits";
  v31[1]  = v20;
  uint64_t v18 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v31 forKeys:v30 count:2];

  id v17 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v16 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (int j = 0; j < *((_DWORD *)this + 593); ++j)
  {
    LODWORD(v4)  = *((_DWORD *)this + j + 553);
    objc_msgSend(v17, "addObject:", objc_msgSend(NSNumber, "numberWithFloat:", v4));
    LODWORD(v5)  = *((_DWORD *)this + j + 573);
    objc_msgSend(v16, "addObject:", objc_msgSend(NSNumber, "numberWithFloat:", v5));
  }
  v28[0]  = @"lux";
  v29[0]  = v17;
  v28[1]  = @"nits";
  v29[1]  = v16;
  uint64_t v14 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v29 forKeys:v28 count:2];

  id v13 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v12 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (int k = 0; k < *((_DWORD *)this + 634); ++k)
  {
    LODWORD(v6)  = *((_DWORD *)this + k + 594);
    objc_msgSend(v13, "addObject:", objc_msgSend(NSNumber, "numberWithFloat:", v6));
    LODWORD(v7)  = *((_DWORD *)this + k + 614);
    objc_msgSend(v12, "addObject:", objc_msgSend(NSNumber, "numberWithFloat:", v7));
  }
  v26[0]  = @"lux";
  v27[0]  = v13;
  v26[1]  = @"nits";
  v27[1]  = v12;
  uint64_t v10 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v27 forKeys:v26 count:2];

  v24[0]  = @"CurveLevelLow";
  v25[0]  = v18;
  v24[1]  = @"CurveLevelMed";
  v25[1]  = v14;
  void v24[2] = @"CurveLevelHigh";
  v25[2]  = v10;
  CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"AOTCurve", (const void *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v25 forKeys:v24 count:3]);
}

uint64_t PerceptualLuminanceThresholding::SetBrightenDuration(uint64_t this, float a2)
{
  *(float *)(this + 32)  = a2;
  return this;
}

uint64_t PerceptualLuminanceThresholding::SetMaxDimDuration(uint64_t this, float a2)
{
  *(float *)(this + 36)  = a2;
  return this;
}

void AABC::unregisterDisplay(AABC *this, __Display *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    double v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    double v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v6, 4);
    _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "[%x]: ", v6, 8u);
  }
  *((void *)this + 51)  = 0;
  uint64_t v2 = *((void *)this + 502);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  *((void *)this + 502)  = 0;
}

CBDigitizerFilter *AABC::newDigitizerFilterForALS(AABC *this, const AABC::ALS *a2)
{
  double v4 = [[CBDigitizerFilter alloc] initWithALSNode:*((void *)a2 + 4) andLogCategory:"lux"];
  [(CBFilter *)v4 scheduleWithDispatchQueue:*((void *)this + 509)];
  return v4;
}

AABC::ALS *AABC::ALS::ALS(AABC::ALS *this)
{
  return this;
}

uint64_t AABC::lazyLoadIntegrationTimes(AABC *this, __IOHIDServiceClient *a2, AABC::ALS *a3)
{
  CFStringRef v23 = this;
  IOHIDServiceClientRef v22 = a2;
  id v21 = (float *)a3;
  char v20 = 0;
  CFNumberRef v19 = (const __CFNumber *)IOHIDServiceClientCopyProperty(a2, @"Calibrated");
  if (v19)
  {
    CFTypeID v11 = CFGetTypeID(v19);
    if (v11 == CFBooleanGetTypeID())
    {
      if (GetCFBooleanValue(v19))
      {
        uint64_t v18 = 0;
        if (_logHandle)
        {
          uint64_t v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t inited = init_default_corebrightness_log();
          }
          uint64_t v10 = inited;
        }
        uint64_t v18 = v10;
        char v17 = 1;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          os_log_t log = v18;
          os_log_type_t type = v17;
          __os_log_helper_16_0_0(v16);
          _os_log_impl(&dword_1BA438000, log, type, "Driver has been calibrated -> setting integration times.", v16, 2u);
        }
        CFTypeRef v13 = IOHIDServiceClientCopyProperty(v22, @"ALSSuperFastIntegrationTime");
        if (v13)
        {
          CFTypeID v6 = CFGetTypeID(v13);
          if (v6 == CFNumberGetTypeID())
          {
            CFNumberGetValue((CFNumberRef)v13, kCFNumberFloatType, v21 + 10);
            v21[10]  = v21[10] / 1000000.0;
          }
        }
        if (v13) {
          CFRelease(v13);
        }
        CFTypeRef v14 = IOHIDServiceClientCopyProperty(v22, @"ALSFastIntegrationTime");
        if (v14)
        {
          CFTypeID v5 = CFGetTypeID(v14);
          if (v5 == CFNumberGetTypeID())
          {
            CFNumberGetValue((CFNumberRef)v14, kCFNumberFloatType, v21 + 11);
            v21[11]  = v21[11] / 1000000.0;
          }
        }
        if (v14) {
          CFRelease(v14);
        }
        CFTypeRef v15 = IOHIDServiceClientCopyProperty(v22, @"ALSSlowIntegrationTime");
        if (v15)
        {
          CFTypeID v4 = CFGetTypeID(v15);
          if (v4 == CFNumberGetTypeID())
          {
            CFNumberGetValue((CFNumberRef)v15, kCFNumberFloatType, v21 + 12);
            v21[12]  = v21[12] / 1000000.0;
          }
        }
        if (v15) {
          CFRelease(v15);
        }
        *((unsigned char *)this + 445)  = 0;
        char v20 = 1;
      }
    }
  }
  if (v19) {
    CFRelease(v19);
  }
  return v20 & 1;
}

void AABC::setFilterDuration(uint64_t a1, uint64_t a2, __int16 a3)
{
  *(_WORD *)(a2 + 24)  = a3;
}

uint64_t __os_log_helper_16_2_3_4_0_8_64_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)double result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 64;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 32;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

void AABC::ALS::~ALS(AABC::ALS *this)
{
}

{
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)this + 16);
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)this + 11);
}

CBAPEndpoint *AABC::registerEndpoint(id *this, CBAPEndpoint *a2)
{
  CFTypeID v6 = (AABC *)this;
  CFTypeID v5 = a2;
  double result = a2;
  this[521]  = result;
  if (*((_DWORD *)this + 80) == 6)
  {
    AABC::sendCrossTalkConfigToDCP((IOHIDServiceClientRef *)this);
    double result = (CBAPEndpoint *)AABC::sendAOTCurvesToDCP((AABC *)this);
  }
  if (*((_DWORD *)this + 80) == 1)
  {
    char v4 = 0;
    return (CBAPEndpoint *)[this[521] sendCommand:232 inputBuffer:&v4 inputBufferSize:1];
  }
  return result;
}

void AABC::sendCrossTalkConfigToDCP(IOHIDServiceClientRef *this)
{
  valuePtr[1]  = (uint64_t)this;
  os_log_t v27 = this;
  valuePtr[0]  = 0;
  int v52 = 0;
  char v53 = 0;
  number  = 0;
  number  = (CFNumberRef)IOHIDServiceClientGetRegistryID(this[41]);
  if (number) {
    CFNumberGetValue(number, kCFNumberSInt64Type, valuePtr);
  }
  if (valuePtr[0])
  {
    context  = (void *)MEMORY[0x1BA9ECAE0]();
    id v50 = 0;
    options  = 0;
    entry  = 0;
    mainPort  = *MEMORY[0x1E4F2EEF0];
    CFDictionaryRef v1 = IORegistryEntryIDMatching(valuePtr[0]);
    entry  = IOServiceGetMatchingService(mainPort, v1);
    id v50 = (id)IORegistryEntryCreateCFProperty(entry, @"ALSSCalDBV", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    id v26 = v50;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v55[1]  = [v50 unsignedIntValue];
      LOBYTE(v52)  = 1;
    }
    id v50 = (id)IORegistryEntryCreateCFProperty(entry, @"ALSSNumRects", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    id v22 = v50;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      v55[0]  = [v50 unsignedIntValue];
      BYTE1(v52)  = 1;
    }
    id v50 = (id)IORegistryEntryCreateCFProperty(entry, @"ALSSRGBCoefficients", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    id v21 = v50;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      CFStringRef v48 = v57;
      uint64_t v42 = MEMORY[0x1E4F143A8];
      int v43 = -1073741824;
      int v44 = 0;
      uint64_t v45 = ___ZN4AABC24sendCrossTalkConfigToDCPEv_block_invoke;
      CFTypeID v46 = &__block_descriptor_40_e15_v32__0_8Q16_B24l;
      os_log_type_t v47 = v57;
      objc_msgSend(v50, "enumerateObjectsUsingBlock:");
      BYTE2(v52)  = 1;
    }
    int v41 = @"ALSSRect";
    id v40 = 0;
    CFNumberRef v19 = &v8;
    id v40 = (id)objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:", @"0", @"1", @"2", @"3", @"4", @"5", @"6", @"7", @"8", @"9", @"10", @"11", @"12", @"13", @"14", @"15", 0);
    id v50 = (id)IORegistryEntryCreateCFProperty(entry, @"ALSSRectConfig", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    id v20 = v50;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      for (unsigned int i = 0; i < v55[0]; ++i)
      {
        id v38 = 0;
        id v17 = v50;
        id v16 = v41;
        uint64_t v2 = [v40 objectAtIndexedSubscript:(int)i];
        uint64_t v3 = [(__CFString *)v16 stringByAppendingString:v2];
        id v38 = (id)[v17 objectForKey:v3];
        id v18 = v38;
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          int v4 = objc_msgSend((id)objc_msgSend(v38, "objectAtIndexedSubscript:", 0), "unsignedIntValue");
          CFTypeRef v15 = v55;
          *(_DWORD *)&v57[16 * i + 12]  = v4;
          int v5 = objc_msgSend((id)objc_msgSend(v38, "objectAtIndexedSubscript:", 1), "unsignedIntValue");
          v15[4 * i + 22]  = v5;
          int v6 = objc_msgSend((id)objc_msgSend(v38, "objectAtIndexedSubscript:", 2), "unsignedIntValue");
          v15[4 * i + 23]  = v6;
          int v7 = objc_msgSend((id)objc_msgSend(v38, "objectAtIndexedSubscript:", 3), "unsignedIntValue");
          v15[4 * i + 24]  = v7;
          HIBYTE(v52)  = 1;
        }
        else
        {
          HIBYTE(v52)  = 0;
        }
      }
    }
    id v50 = (id)IORegistryEntryCreateCFProperty(entry, @"ALSSWindowCoefficients", (CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    id v14 = v50;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      int v37 = v56;
      uint64_t v31 = MEMORY[0x1E4F143A8];
      int v32 = -1073741824;
      int v33 = 0;
      long long v34 = ___ZN4AABC24sendCrossTalkConfigToDCPEv_block_invoke_2;
      int v35 = &__block_descriptor_40_e15_v32__0_8Q16_B24l;
      long long v36 = v56;
      objc_msgSend(v50, "enumerateObjectsUsingBlock:");
      char v53 = 1;
    }
    if (std::all_of[abi:ne180100]<BOOL *,AABC::sendCrossTalkConfigToDCP(void)::$_0>(&v52, v54))
    {
      [(__IOHIDServiceClient *)v27[521] sendCommand:232 inputBuffer:v55 inputBufferSize:340];
    }
    else
    {
      os_log_t oslog = 0;
      if (_logHandle)
      {
        os_log_t v13 = (os_log_t)_logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        os_log_t v13 = inited;
      }
      os_log_t oslog = v13;
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        os_log_t log = oslog;
        *(_DWORD *)uint64_t v10 = type;
        buf  = (uint8_t *)v28;
        __os_log_helper_16_0_0(v28);
        _os_log_error_impl(&dword_1BA438000, log, v10[0], "No valid calibration for crosstalk, lux might be incorrect!", buf, 2u);
      }
    }
  }
}

uint64_t AABC::sendAOTCurvesToDCP(AABC *this)
{
  v4[21]  = *MEMORY[0x1E4F143B8];
  for (int i = 0; i < 3; ++i)
  {
    for (int j = 0; j < *((_DWORD *)this + 41 * i + 552); ++j)
    {
      *((_DWORD *)&v4[7 * i] + j)  = (int)(*((float *)this + 41 * i + j + 512) * 65536.0);
      *((_DWORD *)&v4[7 * i + 3] + j)  = (int)(*((float *)this + 41 * i + j + 532) * 65536.0);
    }
    v4[7 * i + 6]  = *((int *)this + 41 * i + 552);
  }
  return [*((id *)this + 521) sendCommand:228 inputBuffer:v4 inputBufferSize:168];
}

void AABC::scheduleWithDispatchQueue(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a1;
  uint64_t v25 = a2;
  os_log_t v24 = 0;
  if (_logHandle)
  {
    uint64_t v10 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v10 = inited;
  }
  os_log_t v24 = v10;
  os_log_type_t v23 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v28, 4);
    _os_log_debug_impl(&dword_1BA438000, v24, v23, "[%x]: ", v28, 8u);
  }
  if (*(_DWORD *)(a1 + 376))
  {
    os_log_t v22 = 0;
    if (_logHandle)
    {
      uint64_t v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v7 = init_default_corebrightness_log();
      }
      uint64_t v8 = v7;
    }
    os_log_t v22 = v8;
    os_log_type_t v21 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v27, *(_DWORD *)(a1 + 3436));
      _os_log_debug_impl(&dword_1BA438000, v22, v21, "_settings._internal._dimPolicy=%x", v27, 8u);
    }
    *(void *)(a1 + 4072)  = v25;
    if (!*(_DWORD *)(a1 + 648))
    {
      id v20 = 0;
      if (_logHandle)
      {
        int v6 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v5 = init_default_corebrightness_log();
        }
        int v6 = v5;
      }
      id v20 = v6;
      char v19 = 2;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v3 = v20;
        os_log_type_t v4 = v19;
        __os_log_helper_16_0_0(v18);
        _os_log_debug_impl(&dword_1BA438000, v3, v4, "lockstate notification enabled \n", v18, 2u);
      }
      uint64_t v2 = *(NSObject **)(a1 + 4072);
      uint64_t handler = MEMORY[0x1E4F143A8];
      int v13 = -1073741824;
      int v14 = 0;
      CFTypeRef v15 = ___ZN4AABC25scheduleWithDispatchQueueEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
      id v16 = &__block_descriptor_40_e8_v12__0i8l;
      uint64_t v17 = a1;
      notify_register_dispatch("com.apple.springboard.lockstate", (int *)(a1 + 4032), v2, &handler);
    }
    AABC::InitializeCPMSModule((AABC *)a1);
    *(void *)(a1 + 152)  = [[AccessoryDetection alloc] initWithAABC:a1];
    [*(id *)(a1 + 152) start];
  }
}

void ___ZN4AABC25scheduleWithDispatchQueueEPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(AABC **)(a1 + 32);
  notify_get_state(*((_DWORD *)v3 + 1008), (uint64_t *)v3 + 505);
  if (_logHandle)
  {
    uint64_t v2 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v2 = inited;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_4_0_8_0((uint64_t)v4, 2, *((void *)v3 + 505));
    _os_log_debug_impl(&dword_1BA438000, v2, OS_LOG_TYPE_DEBUG, "[%x]: _lockState=%llx", v4, 0x12u);
  }
  if (!*((void *)v3 + 505))
  {
    if (*((_DWORD *)v3 + 175))
    {
      AABC::CancelFastRampMode((CFAbsoluteTime *)v3);
      *((_DWORD *)v3 + 175)  = 0;
    }
    *((_DWORD *)v3 + 996)  = 0;
  }
}

void AABC::CancelFastRampMode(CFAbsoluteTime *this)
{
  io_registry_entry_t v9 = this;
  if (*((_DWORD *)this + 169))
  {
    uint64_t v8 = 0;
    if (_logHandle)
    {
      os_log_type_t v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      os_log_type_t v4 = inited;
    }
    uint64_t v8 = v4;
    char v7 = 1;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      os_log_t log = v8;
      os_log_type_t type = v7;
      __os_log_helper_16_0_0(v6);
      _os_log_impl(&dword_1BA438000, log, type, "end fast ramp mode", v6, 2u);
    }
    this[86]  = CFAbsoluteTimeGetCurrent();
    *((_DWORD *)this + 169)  = 0;
    if (*((_DWORD *)this + 92) == 2) {
      AABC::UpdateState((uint64_t)this, 3);
    }
  }
}

void AABC::InitializeCPMSModule(AABC *this)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  os_log_type_t v64 = this;
  *((void *)this + 516)  = 0;
  *((void *)this + 515)  = 0;
  int v62 = MGGetSInt32Answer();
  int v63 = v62;
  if ((v62 == 6 || v63 == 1 || v63 == 3) && ([MEMORY[0x1E4F56678] isCPMSSupported] & 1) == 1)
  {
    CPMSAPLTable  = 0;
    CPMSAPLTable  = (_DWORD *)DisplayGetCPMSAPLTable(*((void *)this + 51));
    if (CPMSAPLTable)
    {
      int v60 = 1125842944;
      unsigned int APLColumnOrDefault = 0;
      unsigned int APLColumnOrDefault = DisplayGetAPLColumnOrDefault(*((void *)this + 51), 0x64u);
      float v58 = 0.0;
      float v58 = DisplayPhysicalBrightnessToPower(*((void *)this + 51), APLColumnOrDefault, 155.0);
      int APLIndex = 0;
      int APLIndex = DisplayGetAPLIndex(*((void *)this + 51), APLColumnOrDefault);
      HDRunsigned int APLColumn = 0;
      HDRunsigned int APLColumn = DisplayGetHDRAPLColumn(*((void *)this + 51));
      float v55 = 0.0;
      float v55 = DisplayPhysicalBrightnessToPower(*((void *)this + 51), HDRAPLColumn, 155.0);
      int v54 = 0;
      int v54 = DisplayGetAPLIndex(*((void *)this + 51), HDRAPLColumn);
      os_log_t v53 = 0;
      if (_logHandle)
      {
        uint64_t v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v17 = inited;
      }
      os_log_t v53 = v17;
      os_log_type_t type = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_3_4_0_8_0_4_0((uint64_t)v70, APLColumnOrDefault, COERCE__INT64(v58), APLIndex);
        _os_log_impl(&dword_1BA438000, v53, type, "CPMS InitializeCPMSModule, cltm/upo apl: %d, budgetMin: %f, apl_inndex: %d", v70, 0x18u);
      }
      os_log_t oslog = 0;
      if (_logHandle)
      {
        CFTypeRef v15 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v14 = init_default_corebrightness_log();
        }
        CFTypeRef v15 = v14;
      }
      os_log_t oslog = v15;
      os_log_type_t v50 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_3_4_0_8_0_4_0((uint64_t)v69, HDRAPLColumn, COERCE__INT64(v55), v54);
        _os_log_impl(&dword_1BA438000, oslog, v50, "CPMS InitializeCPMSModule, hdrapl: %d, hdrbudgetMin: %f, hdr_apl_inndex: %d", v69, 0x18u);
      }
      id v12 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
      int v13 = (CFStringRef *)MEMORY[0x1E4F1D3E0];
      CFPreferencesSynchronize(@"com.apple.CoreBrightness", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
      CFTypeRef cf = 0;
      CFTypeRef cf = CFPreferencesCopyValue(@"CBCPMSPowerConstraints", @"com.apple.CoreBrightness", *v12, *v13);
      if (cf && (CFTypeID v11 = CFGetTypeID(cf), v11 == CFDictionaryGetTypeID()))
      {
        CFDictionaryRef theDict = (CFDictionaryRef)CFDictionaryGetValue((CFDictionaryRef)cf, @"CLTMRestriction");
        if (theDict)
        {
          number  = (CFNumberRef)CFDictionaryGetValue(theDict, @"Min");
          if (number) {
            CFNumberGetValue(number, kCFNumberIntType, (char *)this + 4152);
          }
          number  = (CFNumberRef)CFDictionaryGetValue(theDict, @"Max");
          if (number) {
            CFNumberGetValue(number, kCFNumberIntType, (char *)this + 4156);
          }
        }
        else
        {
          *((_DWORD *)this + 1038)  = (int)v58;
          *((_DWORD *)this + 1039)  = (int)*(float *)&CPMSAPLTable[50 * APLIndex + 103 + CPMSAPLTable[1] - 1];
        }
        CFDictionaryRef theDict = (CFDictionaryRef)CFDictionaryGetValue((CFDictionaryRef)cf, @"UPORestriction");
        if (theDict)
        {
          CFNumberRef Value = (CFNumberRef)CFDictionaryGetValue(theDict, @"Min");
          if (Value) {
            CFNumberGetValue(Value, kCFNumberIntType, (char *)this + 4136);
          }
          CFNumberRef Value = (CFNumberRef)CFDictionaryGetValue(theDict, @"Max");
          if (Value) {
            CFNumberGetValue(Value, kCFNumberIntType, (char *)this + 4140);
          }
        }
        else
        {
          *((_DWORD *)this + 1034)  = (int)v58;
          *((_DWORD *)this + 1035)  = (int)*(float *)&CPMSAPLTable[50 * APLIndex + 103 + CPMSAPLTable[1] - 1];
        }
        CFDictionaryRef theDict = (CFDictionaryRef)CFDictionaryGetValue((CFDictionaryRef)cf, @"HDRRestriction");
        if (theDict)
        {
          CFNumberRef v45 = (CFNumberRef)CFDictionaryGetValue(theDict, @"Min");
          if (v45) {
            CFNumberGetValue(v45, kCFNumberIntType, (char *)this + 4144);
          }
          CFNumberRef v45 = (CFNumberRef)CFDictionaryGetValue(theDict, @"Max");
          if (v45) {
            CFNumberGetValue(v45, kCFNumberIntType, (char *)this + 4148);
          }
        }
        else
        {
          *((_DWORD *)this + 1036)  = (int)v55;
          *((_DWORD *)this + 1037)  = (int)*(float *)&CPMSAPLTable[50 * v54 + 103 + *CPMSAPLTable - 1];
        }
      }
      else
      {
        *((_DWORD *)this + 1034)  = (int)v58;
        *((_DWORD *)this + 1035)  = (int)*(float *)&CPMSAPLTable[50 * APLIndex + 103 + CPMSAPLTable[1] - 1];
        *((_DWORD *)this + 1038)  = (int)v58;
        *((_DWORD *)this + 1039)  = (int)*(float *)&CPMSAPLTable[50 * APLIndex + 103 + CPMSAPLTable[1] - 1];
        *((_DWORD *)this + 1036)  = (int)v55;
        *((_DWORD *)this + 1037)  = (int)*(float *)&CPMSAPLTable[50 * v54 + 103 + CPMSAPLTable[1] - 1];
      }
      if (cf) {
        CFRelease(cf);
      }
      *((float *)this + 1025)  = -1.0;
      *((float *)this + 1026)  = -1.0;
      *((float *)this + 1024)  = -1.0;
      *((float *)this + 1029)  = 5.0;
      *((float *)this + 1027)  = 5.0;
      *((float *)this + 1028)  = 5.0;
      os_log_t v44 = 0;
      if (_logHandle)
      {
        uint64_t v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v9 = init_default_corebrightness_log();
        }
        uint64_t v10 = v9;
      }
      os_log_t v44 = v10;
      os_log_type_t v43 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        char v7 = v44;
        os_log_type_t v8 = v43;
        __os_log_helper_16_0_0(v42);
        _os_log_impl(&dword_1BA438000, v7, v8, "Registering CPMS Client", v42, 2u);
      }
      os_log_t v41 = 0;
      if (_logHandle)
      {
        int v6 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v5 = init_default_corebrightness_log();
        }
        int v6 = v5;
      }
      os_log_t v41 = v6;
      os_log_type_t v40 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_6_4_0_4_0_4_0_4_0_4_0_4_0((uint64_t)v68, *((_DWORD *)this + 1034), *((_DWORD *)this + 1035), *((_DWORD *)this + 1038), *((_DWORD *)this + 1039), *((_DWORD *)this + 1036), *((_DWORD *)this + 1037));
        _os_log_impl(&dword_1BA438000, v41, v40, "CPMS budgets[min/max]: UPO %d/%d, CLTM %d/%d, HDR %d/%d", v68, 0x26u);
      }
      *((void *)this + 516)  = [MEMORY[0x1E4F56678] sharedCPMSAgent];
      *((void *)this + 515)  = objc_alloc_init(MEMORY[0x1E4F56688]);
      if (*((void *)this + 515))
      {
        [*((id *)this + 515) setClientId:7];
        id v39 = 0;
        id v39 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1036)];
        id v38 = 0;
        id v38 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1037)];
        id v37 = 0;
        id v37 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1034)];
        id v36 = 0;
        id v36 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1035)];
        id v35 = 0;
        id v35 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1038)];
        id v34 = 0;
        id v34 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1039)];
        id v33 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C978]), "initWithObjects:", v39, v38, 0);
        id v32 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C978]), "initWithObjects:", v37, v36, 0);
        id v31 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C978]), "initWithObjects:", v35, v34, 0);
        id v30 = 0;
        id v1 = objc_alloc(MEMORY[0x1E4F1C9E8]);
        id v30 = (id)objc_msgSend(v1, "initWithObjectsAndKeys:", v33, *MEMORY[0x1E4F566B8], v32, *MEMORY[0x1E4F56698], v31, *MEMORY[0x1E4F566A8], 0);
        [*((id *)this + 515) setPowerLevels:v30];
        [*((id *)this + 515) setIsContinuous:1];
        [*((id *)this + 515) setPowerBudgetUpdateMinimumPeriod:1000];
        uint64_t v24 = MEMORY[0x1E4F143A8];
        int v25 = -1073741824;
        int v26 = 0;
        os_log_t v27 = ___ZN4AABC20InitializeCPMSModuleEv_block_invoke;
        uint64_t v28 = &__block_descriptor_40_e22_v16__0__NSDictionary_8l;
        uint64_t v29 = this;
        objc_msgSend(*((id *)this + 515), "setNotificationCallback:");
        [*((id *)this + 515) setGetCurrentPower:&__block_literal_global_1007];
        char v23 = 0;
        char v23 = [*((id *)this + 516) registerClientWithDescription:*((void *)this + 515) error:0] & 1;
        if (v23 == 1)
        {
          os_log_t v22 = 0;
          if (_logHandle)
          {
            os_log_type_t v4 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v3 = init_default_corebrightness_log();
            }
            os_log_type_t v4 = v3;
          }
          os_log_t v22 = v4;
          os_log_type_t v21 = OS_LOG_TYPE_INFO;
          if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
          {
            __os_log_helper_16_2_1_8_66((uint64_t)v67, [*((id *)this + 515) description]);
            _os_log_impl(&dword_1BA438000, v22, v21, "Successfully Registered CPMS Client\n%{public}@\n", v67, 0xCu);
          }
          id v20 = 0;
          uint64_t v2 = (void *)*((void *)this + 516);
          v65[0]  = *MEMORY[0x1E4F566B8];
          v66[0]  = v38;
          v65[1]  = *MEMORY[0x1E4F56698];
          v66[1]  = v36;
          v65[2]  = *MEMORY[0x1E4F566A8];
          v66[2]  = v34;
          id v20 = (id)objc_msgSend(v2, "copyPowerBudgetForRequest:forClient:error:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v66, v65, 3), objc_msgSend(*((id *)this + 515), "clientId"), 0);
          if (v20)
          {
            objc_msgSend(*((id *)this + 516), "acknowledgePowerBudget:forClientId:error:", v20, objc_msgSend(*((id *)this + 515), "clientId"), 0);
          }
          v19[0]  = fmaxf(*(float *)&CPMSAPLTable[CPMSAPLTable[1] - 1 + 53], *((float *)this + 182));
          v19[1]  = v19[0];
          v19[2]  = v19[0];
          DisplayUpdateCPMSBudget(*((void *)this + 51), (uint64_t)v19);
        }
      }
    }
  }
}

void AABC::unscheduleFromDispatchQueue(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 376))
  {
    if (*(_DWORD *)(a1 + 4032)) {
      notify_cancel(*(_DWORD *)(a1 + 4032));
    }
    if (_logHandle)
    {
      uint64_t v2 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v2 = inited;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v3, 4);
      _os_log_debug_impl(&dword_1BA438000, v2, OS_LOG_TYPE_DEBUG, "[%x]: ", v3, 8u);
    }
  }
}

CFDictionaryRef AABC::createCurvePrefsDictionary(uint64_t a1, void *a2)
{
  __dst[11]  = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t v19 = a1;
  float valuePtr = a2;
  memcpy(__dst, &off_1E621A8F0, 0x58uLL);
  CFNumberRef v21 = 0;
  CFNumberRef v22 = 0;
  CFNumberRef v23 = 0;
  uint64_t v4 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  CFNumberRef v21 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, valuePtr);
  CFNumberRef v22 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 4);
  CFNumberRef v23 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 8);
  CFTypeRef v17 = 0;
  callBacks  = (CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFTypeRef v17 = CFArrayCreate(*v4, (const void **)&v21, 3, MEMORY[0x1E4F1D510]);
  CFRelease(v21);
  CFRelease(v22);
  CFRelease(v23);
  CFNumberRef v21 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 12);
  CFNumberRef v22 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 16);
  CFNumberRef v23 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 20);
  CFTypeRef v16 = 0;
  CFTypeRef v16 = CFArrayCreate(*v4, (const void **)&v21, 3, callBacks);
  CFRelease(v21);
  CFRelease(v22);
  CFRelease(v23);
  CFTypeRef v15 = 0;
  CFTypeRef v15 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 24);
  CFTypeRef v14 = 0;
  CFTypeRef v14 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 28);
  CFTypeRef v13 = 0;
  CFTypeRef v13 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 32);
  CFNumberRef v21 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 36);
  CFNumberRef v22 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 40);
  CFNumberRef v23 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 44);
  CFTypeRef v12 = 0;
  CFTypeRef v12 = CFArrayCreate(*v4, (const void **)&v21, 3, callBacks);
  CFRelease(v21);
  CFRelease(v22);
  CFRelease(v23);
  BOOL v11 = 0;
  BOOL v11 = (*((unsigned char *)valuePtr + 48) & 1) != 0;
  CFNumberRef v10 = CFNumberCreate(*v4, kCFNumberIntType, &v11);
  CFNumberRef v9 = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 52);
  CFNumberRef v8 = CFNumberCreate(*v4, kCFNumberDoubleType, (char *)valuePtr + 56);
  CFNumberRef v7 = CFNumberCreate(*v4, kCFNumberIntType, (char *)valuePtr + 64);
  CFNumberRef cf = CFNumberCreate(*v4, kCFNumberFloatType, (char *)valuePtr + 68);
  __b[0]  = v17;
  __b[1]  = v16;
  __b[2]  = v15;
  __b[3]  = v14;
  __b[4]  = v13;
  __b[5]  = v12;
  __b[6]  = v10;
  __b[7]  = v9;
  __b[8]  = v8;
  _DWORD __b[9] = v7;
  __b[10]  = cf;
  CFDictionaryRef v5 = CFDictionaryCreate(*v4, __dst, __b, 11, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(cf);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(v9);
  CFRelease(v10);
  CFRelease(v12);
  CFRelease(v13);
  CFRelease(v14);
  CFRelease(v15);
  CFRelease(v16);
  CFRelease(v17);
  return v5;
}

const void *AABC::readCurvePrefsFromDictionary(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v29 = a1;
  CFDictionaryRef v28 = a2;
  uint64_t v27 = a3;
  CFTypeRef Value = CFDictionaryGetValue(a2, @"Eprefs");
  if (Value)
  {
    CFTypeID v18 = CFGetTypeID(Value);
    if (v18 == CFArrayGetTypeID())
    {
      ValueAtIndex  = 0;
      for (int i = 0; i < 3; ++i)
      {
        ValueAtIndex  = CFArrayGetValueAtIndex((CFArrayRef)Value, i);
        if (ValueAtIndex)
        {
          CFTypeID v17 = CFGetTypeID(ValueAtIndex);
          if (v17 == CFNumberGetTypeID()) {
            CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberFloatType, (void *)(v27 + 4 * i));
          }
        }
      }
    }
  }
  CFTypeRef Value = CFDictionaryGetValue(v28, @"Lprefs");
  if (Value)
  {
    CFTypeID v16 = CFGetTypeID(Value);
    if (v16 == CFArrayGetTypeID())
    {
      CFTypeRef v23 = 0;
      for (int j = 0; j < 3; ++j)
      {
        CFTypeRef v23 = CFArrayGetValueAtIndex((CFArrayRef)Value, j);
        if (v23)
        {
          CFTypeID v15 = CFGetTypeID(v23);
          if (v15 == CFNumberGetTypeID()) {
            CFNumberGetValue((CFNumberRef)v23, kCFNumberFloatType, (void *)(v27 + 12 + 4 * j));
          }
        }
      }
    }
  }
  CFTypeRef Value = CFDictionaryGetValue(v28, @"Eoverride");
  if (Value)
  {
    CFTypeID v14 = CFGetTypeID(Value);
    if (v14 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, (void *)(v27 + 24));
    }
  }
  CFTypeRef Value = CFDictionaryGetValue(v28, @"Loverride");
  if (Value)
  {
    CFTypeID v13 = CFGetTypeID(Value);
    if (v13 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, (void *)(v27 + 28));
    }
  }
  CFTypeRef Value = CFDictionaryGetValue(v28, @"overridePref");
  if (Value)
  {
    CFTypeID v12 = CFGetTypeID(Value);
    if (v12 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, (void *)(v27 + 32));
    }
  }
  CFTypeRef Value = CFDictionaryGetValue(v28, @"age");
  if (Value)
  {
    CFTypeID v11 = CFGetTypeID(Value);
    if (v11 == CFArrayGetTypeID())
    {
      CFTypeRef v21 = 0;
      for (int k = 0; k < 3; ++k)
      {
        CFTypeRef v21 = CFArrayGetValueAtIndex((CFArrayRef)Value, k);
        if (v21)
        {
          CFTypeID v10 = CFGetTypeID(v21);
          if (v10 == CFNumberGetTypeID()) {
            CFNumberGetValue((CFNumberRef)v21, kCFNumberIntType, (void *)(v27 + 36 + 4 * k));
          }
        }
      }
    }
  }
  CFTypeRef Value = CFDictionaryGetValue(v28, @"justOverriddenBrightValue");
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &valuePtr);
      *(unsigned char *)(v27 + 48)  = valuePtr != 0;
    }
  }
  CFTypeRef Value = 0;
  CFTypeRef Value = CFDictionaryGetValue(v28, @"thirdSlope");
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, (void *)(v27 + 52));
    }
  }
  CFTypeRef Value = 0;
  CFTypeRef Value = CFDictionaryGetValue(v28, @"timestamp");
  if (Value)
  {
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)Value, kCFNumberDoubleType, (void *)(v27 + 56));
    }
  }
  *(_DWORD *)(v27 + 64)  = 0;
  CFTypeRef Value = 0;
  CFTypeRef Value = CFDictionaryGetValue(v28, @"curveType");
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, (void *)(v27 + 64));
    }
  }
  *(float *)(v27 + 68)  = -1.0;
  CFTypeRef Value = 0;
  double result = CFDictionaryGetValue(v28, @"EmaxCap");
  CFTypeRef Value = result;
  if (result)
  {
    CFTypeID v5 = CFGetTypeID(Value);
    CFTypeID TypeID = CFNumberGetTypeID();
    double result = (const void *)v5;
    if (v5 == TypeID) {
      return (const void *)CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, (void *)(v27 + 68));
    }
  }
  return result;
}

CFDictionaryRef AABC::createCurveDictionary(uint64_t a1, void *a2)
{
  __dst[11]  = *(const void **)MEMORY[0x1E4F143B8];
  uint64_t v8 = a1;
  CFTypeID v7 = a2;
  int v6 = 0;
  int v6 = *(_DWORD *)(a1 + 732);
  memcpy(__dst, &off_1E621A948, 0x58uLL);
  memset(__b, 0, sizeof(__b));
  uint64_t v4 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  __b[0]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v6);
  __b[1]  = CFNumberCreate(*v4, kCFNumberFloatType, (const void *)(a1 + 532));
  __b[2]  = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 16);
  __b[3]  = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 24);
  __b[4]  = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 20);
  __b[5]  = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 28);
  __b[6]  = CFNumberCreate(*v4, kCFNumberFloatType, v7);
  __b[7]  = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 4);
  __b[8]  = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 8);
  _DWORD __b[9] = CFNumberCreate(*v4, kCFNumberFloatType, (char *)v7 + 12);
  __b[10]  = AABC::createCurvePrefsDictionary(a1, (char *)v7 + 32);
  CFDictionaryRef v5 = CFDictionaryCreate(*v4, __dst, __b, 11, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(__b[10]);
  CFRelease(__b[9]);
  CFRelease(__b[8]);
  CFRelease(__b[7]);
  CFRelease(__b[6]);
  CFRelease(__b[5]);
  CFRelease(__b[4]);
  CFRelease(__b[3]);
  CFRelease(__b[2]);
  CFRelease(__b[1]);
  CFRelease(__b[0]);
  return v5;
}

CFDictionaryRef AABC::createCurveDescriptorDictionary(uint64_t a1, _DWORD *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)keys  = xmmword_1E621A9A0;
  CFTypeID v15 = @"badCurves";
  memset(values, 0, sizeof(values));
  for (int i = 0; i < 3; ++i)
    values[i]  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &a2[2 * i + 2]);
  CFArrayRef v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)values, 3, MEMORY[0x1E4F1D510]);
  for (int j = 0; j < 3; ++j)
    CFRelease(values[j]);
  uint64_t v11 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v10 = v7;
  if (a2[8]) {
    uint64_t v4 = *MEMORY[0x1E4F1CFD0];
  }
  else {
    uint64_t v4 = *MEMORY[0x1E4F1CFC8];
  }
  uint64_t v11 = v4;
  uint64_t v3 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  CFTypeRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, a2);
  CFDictionaryRef v5 = CFDictionaryCreate(*v3, (const void **)keys, &v10, 3, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFRelease(cf);
  CFRelease(v10);
  return v5;
}

const __CFNumber *AABC::readOutlierRemovalFromDictionary(uint64_t a1, const __CFDictionary *a2, BOOL *a3)
{
  CFTypeRef Value = CFDictionaryGetValue(a2, @"enabled");
  if (Value)
  {
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFBooleanGetTypeID()) {
      *a3  = CFBooleanGetValue((CFBooleanRef)Value) != 0;
    }
  }
  uint64_t v11 = CFDictionaryGetValue(a2, @"badCurvesToStick");
  if (v11)
  {
    CFTypeID v8 = CFGetTypeID(v11);
    if (v8 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)v11, kCFNumberIntType, a3 + 4);
    }
  }
  CFTypeID v12 = CFDictionaryGetValue(a2, @"revertTime");
  if (v12)
  {
    CFTypeID v7 = CFGetTypeID(v12);
    if (v7 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)v12, kCFNumberDoubleType, a3 + 8);
    }
  }
  CFTypeID v13 = CFDictionaryGetValue(a2, @"resetTime");
  if (v13)
  {
    CFTypeID v6 = CFGetTypeID(v13);
    if (v6 == CFNumberGetTypeID()) {
      CFNumberGetValue((CFNumberRef)v13, kCFNumberDoubleType, a3 + 24);
    }
  }
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(a2, @"displayOffTime");
  CFNumberRef v14 = result;
  if (result)
  {
    CFTypeID v5 = CFGetTypeID(result);
    CFTypeID TypeID = CFNumberGetTypeID();
    CFNumberRef result = (const __CFNumber *)v5;
    if (v5 == TypeID) {
      return (const __CFNumber *)CFNumberGetValue(v14, kCFNumberDoubleType, a3 + 16);
    }
  }
  return result;
}

const __CFNumber *AABC::readCurveDescriptorFromDictionary(uint64_t a1, const __CFDictionary *a2, _DWORD *a3)
{
  CFTypeRef Value = CFDictionaryGetValue(a2, @"timestamps");
  if (Value)
  {
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 == CFArrayGetTypeID())
    {
      unsigned int Count = CFArrayGetCount((CFArrayRef)Value);
      for (idx  = 0; idx < Count && idx < 3; ++idx)
      {
        CFTypeRef cf = CFArrayGetValueAtIndex((CFArrayRef)Value, idx);
        if (cf)
        {
          CFTypeID v7 = CFGetTypeID(cf);
          if (v7 == CFNumberGetTypeID()) {
            CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &a3[2 * idx + 2]);
          }
        }
      }
    }
  }
  CFTypeID v13 = CFDictionaryGetValue(a2, @"reverted");
  if (v13)
  {
    CFTypeID v6 = CFGetTypeID(v13);
    if (v6 == CFBooleanGetTypeID()) {
      a3[8]  = CFBooleanGetValue((CFBooleanRef)v13);
    }
  }
  CFNumberRef result = (const __CFNumber *)CFDictionaryGetValue(a2, @"badCurves");
  CFNumberRef v14 = result;
  if (result)
  {
    CFTypeID v5 = CFGetTypeID(result);
    CFTypeID TypeID = CFNumberGetTypeID();
    CFNumberRef result = (const __CFNumber *)v5;
    if (v5 == TypeID) {
      return (const __CFNumber *)CFNumberGetValue(v14, kCFNumberIntType, a3);
    }
  }
  return result;
}

void AABC::readCurveFromDictionary(uint64_t a1, const __CFDictionary *a2, float *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v34 = a1;
  CFDictionaryRef v33 = a2;
  id v32 = a3;
  int valuePtr = -1;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(a2, @"version");
  if (Value)
  {
    CFTypeID v19 = CFGetTypeID(Value);
    if (v19 == CFNumberGetTypeID()) {
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    }
  }
  if (valuePtr < *(_DWORD *)(a1 + 732) || valuePtr > 6)
  {
    if (_logHandle)
    {
      uint64_t v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      __os_log_helper_16_0_1_4_0((uint64_t)v35, valuePtr);
      _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_INFO, "unsupported curve version %d", v35, 8u);
    }
  }
  else
  {
    int v29 = 0;
    int v29 = *(_DWORD *)(a1 + 532);
    int v28 = 0;
    int v28 = *((_DWORD *)v32 + 4);
    int v27 = 0;
    int v27 = *((_DWORD *)v32 + 6);
    int v26 = 0;
    int v26 = *((_DWORD *)v32 + 5);
    int v25 = 0;
    int v25 = *((_DWORD *)v32 + 7);
    float v24 = 0.0;
    float v24 = *v32;
    int v23 = 0;
    int v23 = *((_DWORD *)v32 + 1);
    int v22 = 0;
    int v22 = *((_DWORD *)v32 + 2);
    int v21 = 0;
    int v21 = *((_DWORD *)v32 + 3);
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"S");
    if (Value)
    {
      CFTypeID v18 = CFGetTypeID(Value);
      if (v18 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v29);
      }
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"E1");
    if (Value)
    {
      CFTypeID v17 = CFGetTypeID(Value);
      if (v17 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v28);
      }
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"L1");
    if (Value)
    {
      CFTypeID v16 = CFGetTypeID(Value);
      if (v16 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v27);
      }
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"E2");
    if (Value)
    {
      CFTypeID v15 = CFGetTypeID(Value);
      if (v15 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v26);
      }
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"L2");
    if (Value)
    {
      CFTypeID v14 = CFGetTypeID(Value);
      if (v14 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v25);
      }
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"E0a");
    if (Value)
    {
      CFTypeID v13 = CFGetTypeID(Value);
      if (v13 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v24);
      }
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"L0a");
    if (Value)
    {
      CFTypeID v12 = CFGetTypeID(Value);
      if (v12 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v23);
      }
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"E0b");
    if (Value)
    {
      CFTypeID v11 = CFGetTypeID(Value);
      if (v11 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v22);
      }
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"L0b");
    if (Value)
    {
      CFTypeID v10 = CFGetTypeID(Value);
      if (v10 == CFNumberGetTypeID()) {
        CFNumberGetValue(Value, kCFNumberFloatType, &v21);
      }
    }
    *(_DWORD *)(a1 + 532)  = v29;
    *((_DWORD *)v32 + 4)  = v28;
    *((_DWORD *)v32 + 6)  = v27;
    *((_DWORD *)v32 + 5)  = v26;
    *((_DWORD *)v32 + 7)  = v25;
    *id v32 = v24;
    *((_DWORD *)v32 + 1)  = v23;
    *((_DWORD *)v32 + 2)  = v22;
    *((_DWORD *)v32 + 3)  = v21;
    if (_logHandle)
    {
      CFTypeID v9 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v8 = init_default_corebrightness_log();
      }
      CFTypeID v9 = v8;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v37, COERCE__INT64(v32[4]), COERCE__INT64(v32[6]), COERCE__INT64(v32[5]), COERCE__INT64(v32[7]));
      _os_log_debug_impl(&dword_1BA438000, v9, OS_LOG_TYPE_DEBUG, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f", v37, 0x2Au);
    }
    if (_logHandle)
    {
      CFTypeID v7 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v6 = init_default_corebrightness_log();
      }
      CFTypeID v7 = v6;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v36, COERCE__INT64(*v32), COERCE__INT64(v32[1]), COERCE__INT64(v32[2]), COERCE__INT64(v32[3]));
      _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v36, 0x2Au);
    }
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v33, @"Prefs");
    if (Value)
    {
      CFTypeID v5 = CFGetTypeID(Value);
      if (v5 == CFDictionaryGetTypeID()) {
        AABC::readCurvePrefsFromDictionary(a1, Value, (uint64_t)(v32 + 8));
      }
    }
  }
}

BOOL AABC::isCurveGood(uint64_t a1, uint64_t a2)
{
  return *(float *)(a2 + 4) < *(float *)(a1 + 724) && *(float *)(a2 + 12) < (float)(*(float *)(a1 + 728) / 2.0);
}

uint64_t AABC::writeOutlierRemovalPreferences(uint64_t this, int a2)
{
  if (*(unsigned char *)(this + 3368))
  {
    CFPreferencesAppSynchronize((CFStringRef)*MEMORY[0x1E4F1D3D8]);
    if (a2) {
      value  = (CFPropertyListRef)*MEMORY[0x1E4F1CFD0];
    }
    else {
      value  = (CFPropertyListRef)*MEMORY[0x1E4F1CFC8];
    }
    uint64_t v2 = (CFStringRef *)MEMORY[0x1E4F1D3D8];
    CFPreferencesSetAppValue(@"CBCurveSticks", value, (CFStringRef)*MEMORY[0x1E4F1D3D8]);
    return CFPreferencesAppSynchronize(*v2);
  }
  return this;
}

uint64_t __os_log_helper_16_2_3_4_0_8_64_8_64(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)CFNumberRef result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 64;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 64;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

void AABC::_setInternalProperty(__CFString *this, __CFString *a2, AABC *a3, AABC *a4)
{
}

void AABC::setInternalProperty(AABC *this, __CFString *a2, void *a3)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  int v68 = this;
  key  = a2;
  value  = a3;
  os_log_t oslog = 0;
  if (_logHandle)
  {
    uint64_t v34 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v34 = inited;
  }
  os_log_t oslog = v34;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v78, 2, (uint64_t)key, (uint64_t)value);
    _os_log_debug_impl(&dword_1BA438000, oslog, type, "[%x]: key=%@ property=%@", v78, 0x1Cu);
  }
  if (*((_DWORD *)this + 94))
  {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), key, value);
    if (CFEqual(key, @"ALSSpikeFilterDuration"))
    {
      CFTypeID v32 = CFGetTypeID(value);
      if (v32 == CFNumberGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, (char *)this + 3444);
        os_log_t v63 = 0;
        if (_logHandle)
        {
          id v31 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v30 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v30 = init_default_corebrightness_log();
          }
          id v31 = v30;
        }
        os_log_t v63 = v31;
        os_log_type_t v62 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v77, 2, COERCE__INT64(*((float *)this + 861)));
          _os_log_debug_impl(&dword_1BA438000, v63, v62, "[%x]: updated spike filter history %fs", v77, 0x12u);
        }
        CFDictionaryApplyFunction(*((CFDictionaryRef *)this + 53), (CFDictionaryApplierFunction)AABC::ClearHistoryFunction, this);
      }
    }
    else if (CFEqual(key, @"ALSMaxBrightenDuration"))
    {
      os_log_t v61 = 0;
      if (_logHandle)
      {
        int v29 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v28 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v28 = init_default_corebrightness_log();
        }
        int v29 = v28;
      }
      os_log_t v61 = v29;
      os_log_type_t v60 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v76, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1BA438000, v61, v60, "[%x]: ALSMaxBrightenDuration key=%@ property=%@", v76, 0x1Cu);
      }
      CFTypeID v27 = CFGetTypeID(value);
      if (v27 == CFNumberGetTypeID())
      {
        os_log_t v59 = 0;
        if (_logHandle)
        {
          int v26 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v25 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v25 = init_default_corebrightness_log();
          }
          int v26 = v25;
        }
        os_log_t v59 = v26;
        os_log_type_t v58 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v75, 2, (uint64_t)key, (uint64_t)value);
          _os_log_debug_impl(&dword_1BA438000, v59, v58, "[%x]: ALSMaxBrightenDuration2 key=%@ property=%@", v75, 0x1Cu);
        }
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, (char *)this + 3448);
        PerceptualLuminanceThresholding::SetBrightenDuration(*((void *)this + 502), *((float *)this + 862));
        PerceptualLuminanceThresholding::UpdateTimeConstantTable(*((PerceptualLuminanceThresholding **)this + 502), *((_DWORD *)this + 142));
      }
    }
    else if (CFEqual(key, @"ALSMaxDimDuration"))
    {
      os_log_t v57 = 0;
      if (_logHandle)
      {
        float v24 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v23 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v23 = init_default_corebrightness_log();
        }
        float v24 = v23;
      }
      os_log_t v57 = v24;
      os_log_type_t v56 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v74, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1BA438000, v57, v56, "[%x]: ALSMaxDimDuration key=%@ property=%@", v74, 0x1Cu);
      }
      CFTypeID v22 = CFGetTypeID(value);
      if (v22 == CFNumberGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, (char *)this + 3452);
        PerceptualLuminanceThresholding::SetMaxDimDuration(*((void *)this + 502), *((float *)this + 863));
        PerceptualLuminanceThresholding::UpdateTimeConstantTable(*((PerceptualLuminanceThresholding **)this + 502), *((_DWORD *)this + 142));
      }
    }
    else if (CFEqual(key, @"ALSBrightenPdeltaSlow"))
    {
      os_log_t v55 = 0;
      if (_logHandle)
      {
        int v21 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v20 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v20 = init_default_corebrightness_log();
        }
        int v21 = v20;
      }
      os_log_t v55 = v21;
      os_log_type_t v54 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v73, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1BA438000, v55, v54, "[%x]: ALSBrightenPdeltaSlow key=%@ property=%@", v73, 0x1Cu);
      }
      CFTypeID v19 = CFGetTypeID(value);
      if (v19 == CFNumberGetTypeID())
      {
        float valuePtr = 0.0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &valuePtr))
        {
          *((float *)this + 1000)  = valuePtr;
          *((float *)this + 1001)  = valuePtr;
          PerceptualLuminanceThresholding::SetPthresholdBrighten(*((void *)this + 502), valuePtr);
        }
      }
    }
    else if (CFEqual(key, @"PLT_X") || CFEqual(key, @"PLT_Y") || CFEqual(key, @"PLT_Z"))
    {
      CFTypeID v18 = CFGetTypeID(value);
      if (v18 == CFNumberGetTypeID())
      {
        float v52 = 0.0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v52)) {
          (***((void (****)(void, void *, float))this + 502))(*((void *)this + 502), key, v52);
        }
      }
    }
    else if (CFEqual(key, @"ALSBrightenPdeltaFast"))
    {
      os_log_t v51 = 0;
      if (_logHandle)
      {
        CFTypeID v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v16 = init_default_corebrightness_log();
        }
        CFTypeID v17 = v16;
      }
      os_log_t v51 = v17;
      os_log_type_t v50 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v72, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1BA438000, v51, v50, "[%x]: ALSBrightenPdeltaFast key=%@ property=%@", v72, 0x1Cu);
      }
      CFTypeID v15 = CFGetTypeID(value);
      if (v15 == CFNumberGetTypeID())
      {
        int v49 = 0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v49)) {
          *((_DWORD *)this + 999)  = v49;
        }
      }
    }
    else if (CFEqual(key, @"ALSDimPdeltaSlow"))
    {
      os_log_t v48 = 0;
      if (_logHandle)
      {
        CFTypeID v14 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v13 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v13 = init_default_corebrightness_log();
        }
        CFTypeID v14 = v13;
      }
      os_log_t v48 = v14;
      os_log_type_t v47 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v71, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1BA438000, v48, v47, "[%x]: ALSDimPdeltaSlow key=%@ property=%@", v71, 0x1Cu);
      }
      CFTypeID v12 = CFGetTypeID(value);
      if (v12 == CFNumberGetTypeID())
      {
        float v46 = 0.0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v46))
        {
          *((float *)this + 997)  = v46;
          *((float *)this + 998)  = v46;
          PerceptualLuminanceThresholding::SetPthresholdDim(*((void *)this + 502), v46);
        }
      }
    }
    else if (CFEqual(key, @"ALSRampLuxThreshold"))
    {
      os_log_t v45 = 0;
      if (_logHandle)
      {
        CFTypeID v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v10 = init_default_corebrightness_log();
        }
        CFTypeID v11 = v10;
      }
      os_log_t v45 = v11;
      os_log_type_t v44 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_2_3_4_0_8_64_8_64((uint64_t)v70, 2, (uint64_t)key, (uint64_t)value);
        _os_log_debug_impl(&dword_1BA438000, v45, v44, "[%x]: ALSRampLuxThreshold key=%@ property=%@", v70, 0x1Cu);
      }
      CFTypeID v9 = CFGetTypeID(value);
      if (v9 == CFNumberGetTypeID())
      {
        int v43 = 0;
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v43)) {
          *((_DWORD *)this + 1002)  = v43;
        }
      }
    }
    else if (CFEqual(key, @"ALSDimPolicy"))
    {
      CFTypeID v8 = CFGetTypeID(value);
      if (v8 == CFNumberGetTypeID())
      {
        int v42 = 0;
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &v42);
        *((_DWORD *)this + 858)  = v42;
        AABC::SetALSDimPolicy((uint64_t)this, *((_DWORD *)this + 858));
        CFTypeRef cf = 0;
        CFTypeRef cf = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (char *)this + 3432);
        if (cf)
        {
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 49), @"ALSDimPolicy", cf);
          CFRelease(cf);
        }
      }
    }
    else if (CFEqual(key, @"ALSLockScreenAutoBrightness"))
    {
      *((_DWORD *)this + 860)  = GetCFBooleanValue((const __CFNumber *)value);
      os_log_t v40 = 0;
      if (_logHandle)
      {
        CFTypeID v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v6 = init_default_corebrightness_log();
        }
        CFTypeID v7 = v6;
      }
      os_log_t v40 = v7;
      os_log_type_t v39 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v69, 2, *((_DWORD *)this + 860));
        _os_log_debug_impl(&dword_1BA438000, v40, v39, "[%x]: _settings._internal._lockScreenAutoBrightness=%x", v69, 0xEu);
      }
    }
    else if (CFEqual(key, @"AutoBrightnessProxEnabled"))
    {
      *((unsigned char *)this + 3937)  = GetCFBooleanValue((const __CFNumber *)value) != 0;
    }
    else if (CFEqual(key, @"AutoBrightnessProxDelay"))
    {
      CFTypeID v5 = CFGetTypeID(value);
      if (v5 == CFNumberGetTypeID())
      {
        int v38 = 0;
        int v38 = (int)*((float *)this + 985);
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberFloatType, &v38)) {
          *((float *)this + 985)  = (float)v38;
        }
      }
    }
    else if (CFEqual(key, @"AutoBrightnessLogMask"))
    {
      CFTypeID v4 = CFGetTypeID(value);
      if (v4 == CFNumberGetTypeID())
      {
        int v37 = 0;
        int v37 = *((_DWORD *)this + 81);
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v37)) {
          *((_DWORD *)this + 81)  = v37 | 1;
        }
      }
    }
    else if (CFEqual(key, @"AutoBrightnessLuxFilter"))
    {
      CFTypeID v3 = CFGetTypeID(value);
      if (v3 == CFNumberGetTypeID())
      {
        unsigned int v36 = 0;
        unsigned int v36 = *((_DWORD *)this + 864);
        if (CFNumberGetValue((CFNumberRef)value, kCFNumberIntType, &v36))
        {
          if (v36 < 4) {
            *((_DWORD *)this + 864)  = v36;
          }
        }
      }
    }
    else if (CFEqual(key, @"AutoBrightnessResetAllLuxFilters"))
    {
      if (*((unsigned char *)this + 264)) {
        AABC::resetMovingAverage(this);
      }
      if (*((unsigned char *)this + 161)) {
        AABC::resetFilter((uint64_t)this, (uint64_t *)this + 27);
      }
      AABC::resetMedianFilter((CFDictionaryRef *)this);
    }
  }
}

void AABC::ClearHistoryFunction(AABC *this, __IOHIDServiceClient *a2, AABC::ALS *a3, AABC *a4)
{
  if (*((_DWORD *)a3 + 162))
  {
    if (*((float *)a3 + 163) > 0.0 && *((_DWORD *)a3 + 167) == 3
      || *((float *)a3 + 164) > 0.0 && *((_DWORD *)a3 + 167) == 2
      || *((float *)a3 + 165) > 0.0 && *((_DWORD *)a3 + 167) == 1)
    {
      *((_DWORD *)a2 + 20)  = (float)(*((float *)a3 + 861) / *((float *)a3 + 158));
    }
    else
    {
      *((_DWORD *)a2 + 20)  = 0;
    }
  }
  else
  {
    *((_DWORD *)a2 + 20)  = (float)(*((float *)a3 + 861) / *((float *)a3 + 158));
  }
  *((_DWORD *)a2 + 18)  = 0;
  *((_DWORD *)a2 + 19)  = 0;
  std::vector<float>::resize((uint64_t *)a2 + 11, *((unsigned int *)a2 + 20));
}

void std::vector<float>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v3 = std::vector<float>::size[abi:ne180100](a1);
  if (v3 >= a2)
  {
    if (v3 > a2) {
      std::vector<float>::__destruct_at_end[abi:ne180100](a1, *a1 + 4 * a2);
    }
  }
  else
  {
    std::vector<float>::__append(a1, a2 - v3);
  }
}

uint64_t AABC::SetALSDimPolicy(uint64_t a1, int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 3436)  = a2;
  if (_logHandle)
  {
    CFTypeID v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    CFTypeID v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v9, *(_DWORD *)(a1 + 3436));
    _os_log_impl(&dword_1BA438000, v7, OS_LOG_TYPE_INFO, "_settings._internal._dimPolicy=%x", v9, 8u);
  }
  unsigned int v2 = *(_DWORD *)(a1 + 3436);
  if (v2)
  {
    uint64_t v4 = v2;
    char v3 = 1;
  }
  else
  {
    uint64_t v4 = *(unsigned int *)(a1 + 3436);
    char v3 = 0;
  }
  if ((v3 & 1) == 0)
  {
    switch(v4)
    {
      case 0:
      case 4:
      case 5:
        goto LABEL_17;
      case 1:
      case 6:
      case 7:
        *(_DWORD *)(a1 + 3952)  = 0;
        *(_DWORD *)(a1 + 3956)  = 0;
        *(_DWORD *)(a1 + 3964)  = 0;
        goto LABEL_17;
      case 2:
        *(_DWORD *)(a1 + 3952)  = 0;
        *(_DWORD *)(a1 + 3956)  = 0;
        *(_DWORD *)(a1 + 3964)  = 0;
        goto LABEL_17;
      case 3:
        break;
      default:
        JUMPOUT(0);
    }
  }
  *(_DWORD *)(a1 + 3436)  = 3;
LABEL_17:
  if (*(_DWORD *)(a1 + 3436) == 4 || *(_DWORD *)(a1 + 3436) == 5) {
    *(_DWORD *)(a1 + 3992)  = 1045220557;
  }
  else {
    *(_DWORD *)(a1 + 3992)  = *(_DWORD *)(a1 + 3988);
  }
  return PerceptualLuminanceThresholding::SetPthresholdDim(*(void *)(a1 + 4016), *(float *)(a1 + 3992));
}

uint64_t PerceptualLuminanceThresholding::SetPthresholdBrighten(uint64_t this, float a2)
{
  *(float *)(this + 28)  = a2;
  return this;
}

double AABC::resetMovingAverage(AABC *this)
{
  *((void *)this + 35)  = 0;
  double result = 0.0;
  *((_DWORD *)this + 72)  = 0;
  return result;
}

void AABC::resetFilter(uint64_t a1, uint64_t *a2)
{
  uint64_t v10 = a1;
  CFTypeID v9 = a2;
  CFTypeID v8 = 0;
  if (_logHandle)
  {
    CFTypeID v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    CFTypeID v5 = inited;
  }
  CFTypeID v8 = v5;
  os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    os_log_t log = v8;
    os_log_type_t type = v7;
    __os_log_helper_16_0_0(v6);
    _os_log_impl(&dword_1BA438000, log, type, "RESETTING filter", v6, 2u);
  }
  std::vector<float>::clear[abi:ne180100](v9);
  *((_WORD *)v9 + 20)  = 0;
}

void AABC::resetMedianFilter(CFDictionaryRef *this)
{
}

void AABC::UpdateSensorOverride(AABC *this, __IOHIDServiceClient *a2, AABC::ALS *a3, const void *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFTypeID v18 = this;
  CFTypeID v17 = a2;
  CFNumberRef v16 = a3;
  int v15 = 0;
  float valuePtr = -1.0;
  CFTypeID v11 = CFGetTypeID(a3);
  if (v11 == CFNumberGetTypeID())
  {
    CFNumberGetValue(v16, kCFNumberFloatType, &valuePtr);
  }
  else
  {
    CFTypeID v10 = CFGetTypeID(v16);
    if (v10 == CFDictionaryGetTypeID())
    {
      CFDictionaryRef Value = CFDictionaryGetValue(v16, @"AABSensorOverrideOrientation");
      CFTypeID v12 = CFDictionaryGetValue(v16, @"AABSensorOverrideValue");
      if (Value)
      {
        if (v12)
        {
          CFTypeID v9 = CFGetTypeID(Value);
          if (v9 == CFNumberGetTypeID())
          {
            CFTypeID v8 = CFGetTypeID(v12);
            if (v8 == CFNumberGetTypeID())
            {
              CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &v15);
              CFNumberGetValue((CFNumberRef)v12, kCFNumberFloat32Type, &valuePtr);
            }
          }
        }
      }
    }
  }
  if (!v15 || *((_DWORD *)v17 + 1) == v15)
  {
    if (valuePtr < 0.0)
    {
      *((unsigned char *)v17 + 68)  = 0;
      if (_logHandle)
      {
        CFTypeID v5 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        CFTypeID v5 = inited;
      }
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_1_4_0((uint64_t)v19, v15);
        _os_log_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEFAULT, "Disable sensor override for ALS with orientation %d", v19, 8u);
      }
    }
    else
    {
      *((float *)v17 + 16)  = valuePtr;
      *((unsigned char *)v17 + 68)  = 1;
      if (_logHandle)
      {
        os_log_type_t v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v6 = init_default_corebrightness_log();
        }
        os_log_type_t v7 = v6;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_2_4_0_8_0((uint64_t)v20, v15, COERCE__INT64(valuePtr));
        _os_log_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEFAULT, "ALS with orientation %d has been overridden to %f Lux.", v20, 0x12u);
      }
    }
  }
}

void AABC::CancelRamp(AABC *this)
{
  if (*((_DWORD *)this + 128) && *((_DWORD *)this + 127) && (*((unsigned char *)this + 628) & 1) != 0) {
    DisplayCancelVirtualFade(*((void *)this + 51));
  }
}

void AABC::handleAODStateUpdateProperty(uint64_t a1, int a2, float a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a1;
  int v35 = a2;
  float v34 = a3;
  float BrightnessMinPhysical = 0.0;
  float BrightnessMinPhysical = _DisplayGetBrightnessMinPhysical(*(void *)(a1 + 408));
  AABC::NotifyCPMSWhenDisplayChangeState((AABC *)a1, v35 == 0);
  if (v35 == 1)
  {
    *(_DWORD *)(a1 + 2868)  = 2;
    if (*(_DWORD *)(a1 + 676)) {
      AABC::CancelFastRampMode((CFAbsoluteTime *)a1);
    }
    if (*(void *)(a1 + 4056) && ([*(id *)(a1 + 4056) isActive] & 1) != 0)
    {
      [*(id *)(a1 + 4056) action:0];
      DisplaySetProperty(*(void *)(a1 + 408), @"CBSoftWakeActive", (uint64_t)&unk_1F14181A0);
    }
    AABC::CancelFirstSampleTimeout((dispatch_object_t *)a1);
    *(float *)(a1 + 620)  = DisplayGetLogicalBrightness(*(void *)(a1 + 408));
    float v32 = 0.0;
    float v32 = AABC::LuminanceToIlluminance(a1, (float *)(a1 + 1048), *(float *)(a1 + 620));
    float v31 = AABC::IlluminanceToLuminance((AABC *)a1, v32, (CustomCurve *)(a1 + 2540));
    if (v31 >= *(float *)(a1 + 620))
    {
      if (*(float *)(a1 + 624) < v32)
      {
        float v31 = AABC::IlluminanceToLuminance((AABC *)a1, *(float *)(a1 + 624), (CustomCurve *)(a1 + 2540));
        os_log_t v30 = 0;
        if (_logHandle)
        {
          CFNumberRef v16 = _logHandle;
        }
        else
        {
          uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          CFNumberRef v16 = v15;
        }
        os_log_t v30 = v16;
        os_log_type_t v29 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v40, COERCE__INT64(*(float *)(a1 + 624)), COERCE__INT64(v31));
          _os_log_impl(&dword_1BA438000, v30, v29, "Target AOT Brightness >= Current brightness ; Using _Eprevious(: %f) instead: %f",
            v40,
            0x16u);
        }
      }
      if (v31 > *(float *)(a1 + 620))
      {
        float v31 = *(float *)(a1 + 620);
        os_log_t v28 = 0;
        if (_logHandle)
        {
          CFTypeID v14 = _logHandle;
        }
        else
        {
          uint64_t v13 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          CFTypeID v14 = v13;
        }
        os_log_t v28 = v14;
        os_log_type_t v27 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v39, COERCE__INT64(v31));
          _os_log_impl(&dword_1BA438000, v28, v27, "Target AOT Brightness >= Current brightness ; Capping to Current Brightness: %f",
            v39,
            0xCu);
        }
      }
    }
    *(_DWORD *)(a1 + 2872)  = *(_DWORD *)(a1 + 620);
    if (*(_DWORD *)(a1 + 520))
    {
      if (*(unsigned char *)(a1 + 452)) {
        float v31 = 200.0;
      }
      DisplaySetLogicalBrightnessWithFade(*(void *)(a1 + 408), 12296, (uint64_t)AABC::_RampDoneCallback, a1, v31, v34);
    }
    else
    {
      AABC::SetBrightness((AABC *)a1, v31, v34, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
    }
  }
  else if (!v35)
  {
    float v26 = 0.0;
    float v25 = 0.0;
    float v24 = 0.0;
    CFTypeRef v23 = 0;
    id v21 = (id)[objc_alloc(NSNumber) initWithInt:0];
    CFTypeID v22 = (objc_object *)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v21, @"AOTState", 0);
    AABC::setAlwaysOnProperty((id *)a1, &cfstr_Aotstate.isa, v22);
    IOHIDServiceClientSetProperty(*(IOHIDServiceClientRef *)(a1 + 328), @"AOTState", v22);

    int v20 = 0;
    int v20 = *(_DWORD *)(a1 + 2868);
    *(_DWORD *)(a1 + 2868)  = 3;
    if (*(_DWORD *)(a1 + 520))
    {
      float v25 = *(float *)(a1 + 2872);
      DisplaySetLogicalBrightnessWithFade(*(void *)(a1 + 408), 12296, (uint64_t)AABC::_RampDoneCallback, a1, v25, v34);
    }
    else
    {
      char v19 = 1;
      [*(id *)(a1 + 4168) sendCommand:230 inputBuffer:&v19 inputBufferSize:1];
      CFTypeRef v23 = (CFTypeRef)IOHIDServiceClientCopyEvent();
      if (v23)
      {
        if (*(unsigned char *)(a1 + 3936))
        {
          IOHIDEventGetDoubleValue();
          *(float *)&double v3 = v3;
          float IntegerValue = *(float *)&v3;
        }
        else
        {
          float IntegerValue = (float)IOHIDEventGetIntegerValue();
        }
        float v24 = IntegerValue;
        CFRelease(v23);
      }
      *(float *)(a1 + 624)  = v24;
      float v4 = AABC::IlluminanceToLuminance(a1, (float *)(a1 + 1048), v24);
      float v25 = fmaxf(BrightnessMinPhysical, v4);
      float BrightnessMaxPhysical = _DisplayGetBrightnessMaxPhysical(*(void *)(a1 + 408));
      float v25 = fminf(BrightnessMaxPhysical, v25);
      if (v20 == 1)
      {
        CFTypeID v18 = (void *)[*(id *)(a1 + 4168) copyProperty:@"CurrentBrightness"];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          float v26 = (float)(int)[v18 intValue] / 65536.0;
          if (_logHandle)
          {
            CFTypeID v11 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t inited = init_default_corebrightness_log();
            }
            CFTypeID v11 = inited;
          }
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            __os_log_helper_16_0_1_8_0((uint64_t)v38, COERCE__INT64(v26));
            _os_log_debug_impl(&dword_1BA438000, v11, OS_LOG_TYPE_DEBUG, "Exiting AOT, CurrentAoTNits: %f", v38, 0xCu);
          }
        }
        else
        {
          if (_logHandle)
          {
            CFTypeID v9 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v8 = init_default_corebrightness_log();
            }
            CFTypeID v9 = v8;
          }
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            uint64_t v6 = objc_msgSend((id)objc_msgSend((id)objc_opt_class(), "description"), "UTF8String");
            __os_log_helper_16_2_1_8_32((uint64_t)v37, v6);
            _os_log_error_impl(&dword_1BA438000, v9, OS_LOG_TYPE_ERROR, "Returned property is not an NSNumber!, class: %s", v37, 0xCu);
          }
        }

        float v7 = v26;
        *(float *)(a1 + 616)  = v26;
        *(float *)(a1 + 620)  = v7;
        AABC::SetBrightness((AABC *)a1, v26, 0.0, 12296, 0, 0);
      }
      *(float *)(a1 + 616)  = v25;
      AABC::SetBrightness((AABC *)a1, v25, v34, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
    }
  }
  DisplaySetState(*(void *)(a1 + 408), v35 == 0);
}

uint64_t ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v36 = a1;
  uint64_t v35 = a2;
  float v34 = a3;
  uint64_t v33 = a4;
  uint64_t v32 = a1;
  uint64_t v5 = *(void *)(a1 + 48);
  id v31 = a3;
  id v30 = (id)[a3 valueForKey:@"lux"];
  id v29 = (id)[v31 valueForKey:@"nits"];
  unsigned __int8 v28 = [v30 count];
  *(_DWORD *)(v5 + 2048 + 164 * *(int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) + 160)  = v28;
  uint64_t v27 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:v28];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] arrayWithCapacity:v28];
  uint64_t v17 = MEMORY[0x1E4F143A8];
  int v18 = -1073741824;
  int v19 = 0;
  int v20 = ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_2;
  id v21 = &unk_1E621AAD8;
  uint64_t v24 = v5;
  unsigned __int8 v25 = v28;
  uint64_t v23 = *(void *)(a1 + 40);
  uint64_t v22 = v27;
  objc_msgSend(v30, "enumerateObjectsUsingBlock:");
  uint64_t v8 = MEMORY[0x1E4F143A8];
  int v9 = -1073741824;
  int v10 = 0;
  CFTypeID v11 = ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_3;
  CFTypeID v12 = &unk_1E621AAD8;
  uint64_t v15 = v5;
  unsigned __int8 v16 = v28;
  uint64_t v14 = *(void *)(a1 + 40);
  uint64_t v13 = v26;
  objc_msgSend(v29, "enumerateObjectsUsingBlock:");
  float v7 = (void *)[MEMORY[0x1E4F1CA60] dictionaryWithCapacity:2];
  [v7 setObject:v27 forKey:@"Lux"];
  [v7 setObject:v26 forKey:@"Nits"];
  [*(id *)(a1 + 32) setObject:v7 forKey:v35];
  uint64_t result = a1;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_2(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a1;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a1;
  id v21 = a2;
  uint64_t v20 = a3;
  uint64_t v19 = a4;
  uint64_t v18 = a1;
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v4 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v17 = &v10;
  uint64_t v13 = (char *)&v10 - ((4 * v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = v4;
  float v15 = 0.0;
  [a2 floatValue];
  uint64_t v5 = v12;
  uint64_t v6 = v13;
  float v15 = v7;
  *(float *)(v11 + 2048 + 164 * *(int *)(*(void *)(*(void *)(v12 + 40) + 8) + 24) + 4 * v20)  = v7;
  *(_DWORD *)&v6[4 * v20]  = (int)(float)(v15 * 65536.0);
  id v14 = *(id *)(v5 + 32);
  uint64_t v8 = [NSNumber numberWithInteger:*(int *)&v6[4 * v20]];
  return [v14 addObject:v8];
}

uint64_t ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_3(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a1;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = a1;
  id v21 = a2;
  uint64_t v20 = a3;
  uint64_t v19 = a4;
  uint64_t v18 = a1;
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v4 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v17 = &v10;
  uint64_t v13 = (char *)&v10 - ((4 * v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v16 = v4;
  float v15 = 0.0;
  [a2 floatValue];
  uint64_t v5 = v12;
  uint64_t v6 = v13;
  float v15 = v7;
  *(float *)(v11 + 2048 + 164 * *(int *)(*(void *)(*(void *)(v12 + 40) + 8) + 24) + 80 + 4 * v20)  = v7;
  *(_DWORD *)&v6[4 * v20]  = (int)(float)(v15 * 65536.0);
  id v14 = *(id *)(v5 + 32);
  uint64_t v8 = [NSNumber numberWithInteger:*(int *)&v6[4 * v20]];
  return [v14 addObject:v8];
}

uint64_t __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 4;
  *(_DWORD *)(result + 44)  = a6;
  return result;
}

void *AABC::AlignCurveTypeWithStrategy(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a1;
  uint64_t v12 = a2;
  uint64_t v11 = a3;
  char v10 = 0;
  uint64_t result = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 104))(*(void *)(a1 + 64));
  if (result == 3 && v11[24] == 3
    || (uint64_t result = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 104))(*(void *)(a1 + 64)),
        result == 2)
    && v11[24] == 2
    || (uint64_t result = (void *)(*(uint64_t (**)(void))(**(void **)(a1 + 64) + 104))(*(void *)(a1 + 64)),
        result == 3)
    && !v12[24])
  {
    char v10 = 1;
  }
  if (v10)
  {
    os_log_t v9 = 0;
    if (_logHandle)
    {
      uint64_t v5 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v5 = inited;
    }
    os_log_t v9 = v5;
    os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_2_4_0_4_0((uint64_t)v14, v12[24], v11[24]);
      _os_log_impl(&dword_1BA438000, v9, v8, "Switch curve with alternative curve in order to align curves with update curve strategies. Curve  = %d, Alternative curve  = %d.", v14, 0xEu);
    }
    memcpy(__dst, v11, sizeof(__dst));
    memcpy(v11, v12, 0x68uLL);
    return memcpy(v12, __dst, 0x68uLL);
  }
  return result;
}

uint64_t AABC::getCurveUpdatesFromArray@<X0>(AABC *this@<X0>, objc_object *a2@<X1>, void *a3@<X8>)
{
  uint64_t v15 = a3;
  id v14 = this;
  id v13 = a2;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  int v7 = 301989888;
  int v8 = 72;
  os_log_t v9 = __Block_byref_object_copy__17;
  char v10 = __Block_byref_object_dispose__17;
  uint64_t v11 = 0;
  std::list<AAB::CurveUpdate>::list[abi:ne180100](v12);
  if (v13)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      objc_msgSend(v13, "enumerateObjectsUsingBlock:");
    }
  }
  std::list<AAB::CurveUpdate>::list(a3, (uint64_t)(v6 + 6));
  _Block_object_dispose(&v5, 8);
  return std::list<AAB::CurveUpdate>::~list((uint64_t)v12);
}

void AABC::revertToGoodCurve(uint64_t a1, unsigned int a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a1;
  unsigned int v24 = a2;
  memcpy((void *)(a1 + 1048), (const void *)(a1 + 2896), 0x68uLL);
  if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 64))(*(void *)(a1 + 64), a1 + 2896) & 1) == 0)
  {
    os_log_t oslog = 0;
    if (_logHandle)
    {
      uint64_t v16 = _logHandle;
    }
    else
    {
      uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      uint64_t v16 = v15;
    }
    os_log_t oslog = v16;
    os_log_type_t type = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      os_log_t log = oslog;
      os_log_type_t v14 = type;
      __os_log_helper_16_0_0(v21);
      _os_log_impl(&dword_1BA438000, log, v14, "Baseline curve strategy does not have the capped curve available -> use default.", v21, 2u);
    }
  }
  memcpy((void *)(a1 + 1048), (const void *)(a1 + 2896), 0x68uLL);
  if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 64) + 72))(*(void *)(a1 + 64), a1 + 3104) & 1) == 0)
  {
    os_log_t v20 = 0;
    if (_logHandle)
    {
      uint64_t v12 = _logHandle;
    }
    else
    {
      uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      uint64_t v12 = v11;
    }
    os_log_t v20 = v12;
    os_log_type_t v19 = OS_LOG_TYPE_INFO;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      os_log_t v9 = v20;
      os_log_type_t v10 = v19;
      __os_log_helper_16_0_0(v18);
      _os_log_impl(&dword_1BA438000, v9, v10, "Alternative curve strategy does not have the alternative capped curve available -> use default.", v18, 2u);
    }
  }
  memcpy((void *)(a1 + 3000), (const void *)(a1 + 3104), 0x68uLL);
  if (_logHandle)
  {
    int v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_4_0((uint64_t)v28, COERCE__INT64(*(float *)(a1 + 3104)), COERCE__INT64(*(float *)(a1 + 3112)), COERCE__INT64(*(float *)(a1 + 3120)), COERCE__INT64(*(float *)(a1 + 3124)), COERCE__INT64(*(float *)(a1 + 3108)), COERCE__INT64(*(float *)(a1 + 3116)), COERCE__INT64(*(float *)(a1 + 3128)), COERCE__INT64(*(float *)(a1 + 3132)), COERCE__INT64(*(float *)(a1 + 3188)), *(_DWORD *)(a1 + 3200));
    _os_log_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEFAULT, "revert alternative curve to alternative good curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f, type %d", v28, 0x62u);
  }
  if (_logHandle)
  {
    uint64_t v6 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v5 = init_default_corebrightness_log();
    }
    uint64_t v6 = v5;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_4_0((uint64_t)v27, COERCE__INT64(*(float *)(a1 + 2896)), COERCE__INT64(*(float *)(a1 + 2904)), COERCE__INT64(*(float *)(a1 + 2912)), COERCE__INT64(*(float *)(a1 + 2916)), COERCE__INT64(*(float *)(a1 + 2900)), COERCE__INT64(*(float *)(a1 + 2908)), COERCE__INT64(*(float *)(a1 + 2920)), COERCE__INT64(*(float *)(a1 + 2924)), COERCE__INT64(*(float *)(a1 + 2980)), *(_DWORD *)(a1 + 2992));
    _os_log_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEFAULT, "revert curve to good curve: E0a %f, E0b %f, E1 %f, E2 %f, L0a %f, L0b %f, L1 %f, L2 %f, thirdSlope %f, type %d", v27, 0x62u);
  }
  if (_logHandle)
  {
    uint64_t v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v3 = init_default_corebrightness_log();
    }
    uint64_t v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int updated = AABCurveUpdateReasonToString(v24);
    __os_log_helper_16_2_1_8_66((uint64_t)v26, (uint64_t)updated);
    _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "[Revert curve] %{public}@", v26, 0xCu);
  }
  AABC::setAABCurveUpdateReason(a1, v24);
}

void AABC::readOutlierRemovalPreferences(AABC *this)
{
  if (*((unsigned char *)this + 3368))
  {
    unsigned int v2 = (CFStringRef *)MEMORY[0x1E4F1D3D8];
    CFPreferencesAppSynchronize((CFStringRef)*MEMORY[0x1E4F1D3D8]);
    CFTypeRef cf = CFPreferencesCopyAppValue(@"CBCurveSticks", *v2);
    if (cf)
    {
      CFTypeID v1 = CFGetTypeID(cf);
      if (v1 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue((CFBooleanRef)cf)) {
          *((_DWORD *)this + 832)  = *((_DWORD *)this + 843);
        }
      }
      CFRelease(cf);
    }
  }
}

uint64_t ___ZN4AABC20setPropertyForClientEPK10__CFStringPKvS4__block_invoke_709(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (*(void *)(a3 + 24)) {
      return [*(id *)(a3 + 24) setProperty:*(void *)(result + 32) forKey:*(void *)(result + 40)];
    }
  }
  return result;
}

void AABC::UpdateAutoBrightnessEnabledStatus(AABC *this, const __CFNumber *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = this;
  CFNumberRef v10 = a2;
  int CFBooleanValue = GetCFBooleanValue(a2);
  os_log_t v8 = 0;
  if (_logHandle)
  {
    uint64_t v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v3 = inited;
  }
  os_log_t v8 = v3;
  os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v12, CFBooleanValue);
    _os_log_impl(&dword_1BA438000, v8, v7, "autoBrightnessEnabled=%x", v12, 8u);
  }
  *((_DWORD *)this + 130)  = CFBooleanValue == 0;
  BOOL v6 = CFBooleanValue != 0;
  int v5 = 0;
  DisplayUpdateAAPState(*((void *)this + 51), (uint64_t)&v5, 1, 1);
  if (CFBooleanValue) {
    *((_DWORD *)this + 128)  = 0;
  }
  AABC::SetAutoBrightnessState(this, CFBooleanValue);
  if (*((_DWORD *)this + 130)) {
    AABC::_UpdateNitsRestrictions(this, *((float *)this + 136), -1.0, 1);
  }
  if (*((void *)this + 44))
  {
    if (CFBooleanValue) {
      (*((void (**)(void, __CFString *, void))this + 44))(*((void *)this + 45), @"DisplayBrightnessAuto", *MEMORY[0x1E4F1CFD0]);
    }
    else {
      (*((void (**)(void, __CFString *, void))this + 44))(*((void *)this + 45), @"DisplayBrightnessAuto", *MEMORY[0x1E4F1CFC8]);
    }
  }
}

void AABC::SetDisplayOrientation(uint64_t a1, int a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 704)  = a2;
  if (_logHandle)
  {
    uint64_t v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v3 = inited;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_3_4_0_8_32_4_0((uint64_t)v5, 4, (uint64_t)(&kOrientationString)[a2], a2);
    _os_log_debug_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEBUG, "[%x]: orientation=%s (%x)", v5, 0x18u);
  }
}

void AABC::SetUserBrightness(AABC *this, float a2, int a3)
{
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  CFNumberRef v103 = this;
  float v102 = a2;
  int v101 = a3;
  os_log_t oslog = 0;
  if (_logHandle)
  {
    int v43 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    int v43 = inited;
  }
  os_log_t oslog = v43;
  os_log_type_t type = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v118, 4);
    _os_log_debug_impl(&dword_1BA438000, oslog, type, "[%x]: ", v118, 8u);
  }
  if (*((unsigned char *)this + 3320)) {
    AABC::CancelFastRampMode((CFAbsoluteTime *)this);
  }
  *((float *)this + 133)  = v102;
  os_log_t v98 = 0;
  if (_logHandle)
  {
    uint64_t v41 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v40 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v40 = init_default_corebrightness_log();
    }
    uint64_t v41 = v40;
  }
  os_log_t v98 = v41;
  os_log_type_t v97 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_4_0_8_0((uint64_t)v117, 2, COERCE__INT64(*((float *)this + 133)));
    _os_log_debug_impl(&dword_1BA438000, v98, v97, "[%x]: _S=%f", v117, 0x12u);
  }
  if (!*((_DWORD *)this + 130))
  {
    float v96 = 0.0;
    float v96 = *((float *)this + 155);
    if (*((void *)this + 51)) {
      float v96 = DisplaySliderToLogicalBrightness(*((void *)this + 51), *((float *)this + 133));
    }
    float v3 = v96;
    *((float *)this + 155)  = v96;
    *((float *)this + 154)  = v3;
    if (*((float *)this + 123) == 1.0)
    {
      memcpy(__dst, (char *)this + 1048, sizeof(__dst));
      if (v101)
      {
        memset(__b, 0, sizeof(__b));
        backtrace(__b, 20);
        memset(v115, 0, sizeof(v115));
        __str  = v115;
        for (int i = 0; i < 20 && __b[i]; ++i)
          snprintf(__str, 0x100uLL, "%p ", __b[i]);
        os_log_t v92 = 0;
        if (_logHandle)
        {
          os_log_type_t v39 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v38 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v38 = init_default_corebrightness_log();
          }
          os_log_type_t v39 = v38;
        }
        os_log_t v92 = v39;
        os_log_type_t v91 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          if (v101) {
            uint64_t v4 = "commit";
          }
          else {
            uint64_t v4 = ".";
          }
          __os_log_helper_16_2_4_8_0_8_0_8_0_8_32((uint64_t)v114, COERCE__INT64(*((float *)this + 133)), COERCE__INT64(*((float *)this + 136)), COERCE__INT64(v96), (uint64_t)v4);
          _os_log_impl(&dword_1BA438000, v92, v91, "_S: %0.4f Esensor: %0.4f Luser: %0.4f %s", v114, 0x2Au);
        }
        os_log_t v90 = 0;
        if (_logHandle)
        {
          int v37 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v36 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v36 = init_default_corebrightness_log();
          }
          int v37 = v36;
        }
        os_log_t v90 = v37;
        os_log_type_t v89 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_2_1_8_32((uint64_t)v113, (uint64_t)v115);
          _os_log_debug_impl(&dword_1BA438000, v90, v89, "backtrace=%s", v113, 0xCu);
        }
        if (*((_DWORD *)this + 92) == 4)
        {
          AABC::UpdateState((uint64_t)this, 3);
          if ((*((unsigned char *)this + 3368) & 1) != 0
            && *((_DWORD *)this + 832)
            && *((_DWORD *)this + 832) < *((_DWORD *)this + 843)
            && *((_DWORD *)this + 840))
          {
            double Current = CFAbsoluteTimeGetCurrent();
            unsigned int v87 = 0;
            for (unsigned int j = 0; j < *((_DWORD *)this + 832); ++j)
            {
              if (Current > *((double *)this + (int)j + 417) + *((double *)this + 424)) {
                ++v87;
              }
            }
            if (v87)
            {
              unsigned int v85 = 3 - v87;
              memmove((char *)this + 3336, (char *)this + 8 * v87 + 3336, 8 * (3 - v87));
              bzero((char *)this + 64 * (unint64_t)(3 - v87) + 3336, 8 * v87);
              *((_DWORD *)this + 832) -= v87;
              if (!*((_DWORD *)this + 832))
              {
                AABC::revertToGoodCurve((uint64_t)this, 4u);
                *((_DWORD *)this + 840)  = 0;
              }
            }
          }
          *((_DWORD *)this + 988)  = 0;
          *((_DWORD *)this + 989)  = 0;
          *((_DWORD *)this + 151)  = 0;
          *((_DWORD *)this + 991)  = *((_DWORD *)this + 992);
          *((_DWORD *)this + 141)  = 0;
          AABC::_UpdateEsensorTrusted(this, *((float *)this + 134));
          *((_DWORD *)this + 152)  = *((_DWORD *)this + 136);
          if (*((unsigned char *)this + 4084)) {
            *((_DWORD *)this + 1022)  = *((_DWORD *)this + 136);
          }
          if (*((unsigned char *)this + 3401))
          {
            if (*((void *)this + 48))
            {
              float v84 = 0.0;
              float v84 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
              float valuePtr = v96 - v84;
              float v82 = 0.0;
              float v82 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 750, *((float *)this + 136), *((float *)this + 139));
              float v81 = v96 - v82;
              os_log_t v80 = 0;
              if (_logHandle)
              {
                uint64_t v35 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT) {
                  uint64_t v34 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else {
                  uint64_t v34 = init_default_corebrightness_log();
                }
                uint64_t v35 = v34;
              }
              os_log_t v80 = v35;
              os_log_type_t v79 = OS_LOG_TYPE_DEFAULT;
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v112, COERCE__INT64(*((float *)this + 136)), COERCE__INT64(*((float *)this + 139)), COERCE__INT64(v84), COERCE__INT64(v96), COERCE__INT64(valuePtr), COERCE__INT64(*((float *)this + 136)), COERCE__INT64(*((float *)this + 139)), COERCE__INT64(v82), COERCE__INT64(v96), COERCE__INT64(v81));
                _os_log_impl(&dword_1BA438000, v80, v79, "Nits update: %f (capped %f) Lux => %f Nits -> %f Nits ( %f)\nAlternative Nits update: %f (capped %f) Lux => %f Nits -> %f Nits ( %f)", v112, 0x66u);
              }
              value  = 0;
              uint64_t v33 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
              value  = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberFloatType, &valuePtr);
              CFTypeRef cf = 0;
              CFTypeRef cf = CFNumberCreate(*v33, kCFNumberFloatType, &v81);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"AABCurveUpdateNitsDelta", value);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 48), @"AABCurveUpdateNitsDeltaAlternative", cf);
              CFRelease(value);
              CFRelease(cf);
            }
            LODWORD(v75)  = *((_DWORD *)this + 136);
            HIDWORD(v75)  = *((_DWORD *)this + 139);
            float v76 = v96;
            uint64_t v73 = v75;
            float v74 = v96;
            AAB::UpdateCurve_Block3_WithCappedCurve_AlternativeCurve((uint64_t)this, (uint64_t)__dst, (uint64_t)this + 1184, (uint64_t)this + 2896, (uint64_t)this + 3000, (uint64_t)this + 3104, *(float *)&v75, *((float *)&v75 + 1), v96);
            os_log_t v72 = 0;
            if (_logHandle)
            {
              uint64_t v32 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v31 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v31 = init_default_corebrightness_log();
              }
              uint64_t v32 = v31;
            }
            os_log_t v72 = v32;
            os_log_type_t v71 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v111, *((_DWORD *)this + 774), COERCE__INT64(*((float *)this + 750)), COERCE__INT64(*((float *)this + 751)), COERCE__INT64(*((float *)this + 752)), COERCE__INT64(*((float *)this + 753)), COERCE__INT64(*((float *)this + 755)), COERCE__INT64(*((float *)this + 757)), COERCE__INT64(*((float *)this + 771)));
              _os_log_impl(&dword_1BA438000, v72, v71, "ALTERNATIVE CURVE [os_log_type_t type = %d] - (%f, %f) - (%f, %f) - (%f, %f) - (%f)\n", v111, 0x4Eu);
            }
            os_log_t v70 = 0;
            if (_logHandle)
            {
              id v30 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v29 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v29 = init_default_corebrightness_log();
              }
              id v30 = v29;
            }
            os_log_t v70 = v30;
            os_log_type_t v69 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v110, *((_DWORD *)this + 800), COERCE__INT64(*((float *)this + 776)), COERCE__INT64(*((float *)this + 777)), COERCE__INT64(*((float *)this + 778)), COERCE__INT64(*((float *)this + 779)), COERCE__INT64(*((float *)this + 781)), COERCE__INT64(*((float *)this + 783)), COERCE__INT64(*((float *)this + 797)));
              _os_log_impl(&dword_1BA438000, v70, v69, "ALTERNATIVE GOOD CURVE [os_log_type_t type = %d] - (%f, %f) - (%f, %f) - (%f, %f) - (%f)\n", v110, 0x4Eu);
            }
            os_log_t v68 = 0;
            if (_logHandle)
            {
              unsigned __int8 v28 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v27 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v27 = init_default_corebrightness_log();
              }
              unsigned __int8 v28 = v27;
            }
            os_log_t v68 = v28;
            os_log_type_t v67 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v109, SLODWORD(__dst[24]), COERCE__INT64(__dst[0]), COERCE__INT64(__dst[1]), COERCE__INT64(__dst[2]), COERCE__INT64(__dst[3]), COERCE__INT64(__dst[5]), COERCE__INT64(__dst[7]), COERCE__INT64(__dst[21]));
              _os_log_impl(&dword_1BA438000, v68, v67, "CURVE [os_log_type_t type = %d] - (%f, %f) - (%f, %f) - (%f, %f) - (%f)\n", v109, 0x4Eu);
            }
            os_log_t v66 = 0;
            if (_logHandle)
            {
              uint64_t v26 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v25 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v25 = init_default_corebrightness_log();
              }
              uint64_t v26 = v25;
            }
            os_log_t v66 = v26;
            os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_8_4_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v108, *((_DWORD *)this + 748), COERCE__INT64(*((float *)this + 724)), COERCE__INT64(*((float *)this + 725)), COERCE__INT64(*((float *)this + 726)), COERCE__INT64(*((float *)this + 727)), COERCE__INT64(*((float *)this + 729)), COERCE__INT64(*((float *)this + 731)), COERCE__INT64(*((float *)this + 745)));
              _os_log_impl(&dword_1BA438000, v66, v65, "GOOD CURVE [os_log_type_t type = %d] - (%f, %f) - (%f, %f) - (%f, %f) - (%f)\n", v108, 0x4Eu);
            }
            os_log_t v64 = 0;
            if (_logHandle)
            {
              unsigned int v24 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v23 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v23 = init_default_corebrightness_log();
              }
              unsigned int v24 = v23;
            }
            os_log_t v64 = v24;
            os_log_type_t v63 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v107, COERCE__INT64(*((float *)this + 270)), COERCE__INT64(*((float *)this + 273)), COERCE__INT64(*((float *)this + 271)), COERCE__INT64(*((float *)this + 274)), COERCE__INT64(*((float *)this + 272)), COERCE__INT64(*((float *)this + 275)));
              _os_log_impl(&dword_1BA438000, v64, v63, "CURVE Prefs: (%f, %f), (%f, %f), (%f, %f)\n", v107, 0x3Eu);
            }
            os_log_t v62 = 0;
            if (_logHandle)
            {
              uint64_t v22 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v21 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v21 = init_default_corebrightness_log();
              }
              uint64_t v22 = v21;
            }
            os_log_t v62 = v22;
            os_log_type_t v61 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v106, COERCE__INT64(*((float *)this + 732)), COERCE__INT64(*((float *)this + 735)), COERCE__INT64(*((float *)this + 733)), COERCE__INT64(*((float *)this + 736)), COERCE__INT64(*((float *)this + 734)), COERCE__INT64(*((float *)this + 737)));
              _os_log_impl(&dword_1BA438000, v62, v61, "GOOD CURVE Prefs: (%f, %f), (%f, %f), (%f, %f)\n", v106, 0x3Eu);
            }
          }
          else
          {
            LODWORD(v59)  = *((_DWORD *)this + 136);
            HIDWORD(v59)  = *((_DWORD *)this + 139);
            float v60 = v96;
            uint64_t v57 = v59;
            float v58 = v96;
            AAB::UpdateCurve_Block3((uint64_t)this, (uint64_t)__dst, *(float *)&v59, *((float *)&v59 + 1), v96);
          }
          float v20 = v96;
          float v5 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
          *(float *)&double v6 = v20;
          +[CBAnalytics autoBrightnessUserChange:lowPower:](CBAnalytics, "autoBrightnessUserChange:lowPower:", v20 > v5, *((unsigned char *)this + 3416) & 1, v6);
          memcpy((char *)this + 1048, __dst, 0x68uLL);
          os_log_t v56 = 0;
          if (_logHandle)
          {
            os_log_type_t v19 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v18 = init_default_corebrightness_log();
            }
            os_log_type_t v19 = v18;
          }
          os_log_t v56 = v19;
          os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            if (*((float *)this + 136) <= *((float *)this + 7)) {
              uint64_t v17 = "E1 & L1";
            }
            else {
              uint64_t v17 = "E2 & L2";
            }
            __os_log_helper_16_2_5_8_0_8_0_8_0_8_0_8_32((uint64_t)v105, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)), (uint64_t)v17);
            _os_log_impl(&dword_1BA438000, v56, v55, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f  [updated %s]", v105, 0x34u);
          }
          os_log_t v54 = 0;
          if (_logHandle)
          {
            uint64_t v16 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v15 = init_default_corebrightness_log();
            }
            uint64_t v16 = v15;
          }
          os_log_t v54 = v16;
          os_log_type_t v53 = OS_LOG_TYPE_DEFAULT;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v104, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
            _os_log_impl(&dword_1BA438000, v54, v53, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v104, 0x2Au);
          }
          if (*((unsigned char *)this + 3368))
          {
            *((unsigned char *)this + 3400)  = 0;
            char v52 = 0;
            if (AABC::isCurveGood((uint64_t)this, (uint64_t)this + 1048))
            {
              memcpy((char *)this + 2896, (char *)this + 1048, 0x68uLL);
              os_log_t v51 = 0;
              if (_logHandle)
              {
                os_log_type_t v14 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT) {
                  uint64_t v13 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else {
                  uint64_t v13 = init_default_corebrightness_log();
                }
                os_log_type_t v14 = v13;
              }
              os_log_t v51 = v14;
              os_log_type_t v50 = OS_LOG_TYPE_DEBUG;
              if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v11 = v51;
                os_log_type_t v12 = v50;
                __os_log_helper_16_0_0(v49);
                _os_log_debug_impl(&dword_1BA438000, v11, v12, "Session curve is good", v49, 2u);
              }
              if ((v52 & 1) != 0
                || !*((_DWORD *)this + 832)
                || *((_DWORD *)this + 832) == *((_DWORD *)this + 843)
                || !*((_DWORD *)this + 840))
              {
                *((_DWORD *)this + 832)  = 0;
                *((_DWORD *)this + 840)  = 0;
                *((void *)this + 417)  = 0;
                *((void *)this + 418)  = 0;
                *((void *)this + 419)  = 0;
              }
            }
            else
            {
              double v48 = CFAbsoluteTimeGetCurrent();
              if (*((_DWORD *)this + 832))
              {
                if (*((_DWORD *)this + 832) < *((_DWORD *)this + 843)
                  && v48 > *((double *)this + 417) + *((double *)this + 422)
                  && *((_DWORD *)this + 840))
                {
                  *((double *)this + (*((_DWORD *)this + 832))++ + 417)  = v48;
                  *((_DWORD *)this + 840)  = 0;
                }
              }
              else
              {
                *((double *)this + *((unsigned int *)this + 832) + 417)  = v48;
                *((_DWORD *)this + 832)  = 1;
                *((_DWORD *)this + 840)  = 0;
              }
            }
          }
        }
      }
      else if (*((_DWORD *)this + 92) == 3)
      {
        os_log_t v47 = 0;
        if (_logHandle)
        {
          CFNumberRef v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v9 = init_default_corebrightness_log();
          }
          CFNumberRef v10 = v9;
        }
        os_log_t v47 = v10;
        os_log_type_t v46 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v7 = v47;
          os_log_type_t v8 = v46;
          __os_log_helper_16_0_0(v45);
          _os_log_debug_impl(&dword_1BA438000, v7, v8, "Cancel ramp, turning on auto-brightness", v45, 2u);
        }
        AABC::CancelRamp(this);
        AABC::UpdateState((uint64_t)this, 4);
      }
    }
  }
}

void AABC::setAABCurveUpdateReason(uint64_t a1, unsigned int a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a1;
  unsigned int valuePtr = a2;
  if (*(void *)(a1 + 384))
  {
    CFNumberRef v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 384), @"AABCurveUpdateReason", v6);
    if (_logHandle)
    {
      uint64_t v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int updated = AABCurveUpdateReasonToString(valuePtr);
      __os_log_helper_16_2_1_8_66((uint64_t)v9, (uint64_t)updated);
      _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "[aabParamsUpdateReason] %{public}@", v9, 0xCu);
    }
    CFRelease(v6);
  }
}

void AABC::SetAutoBrightnessStatus(AABC *this, int a2, float a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v35 = this;
  int v34 = a2;
  float v33 = a3;
  os_log_t v32 = 0;
  if (_logHandle)
  {
    uint64_t v17 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v17 = inited;
  }
  os_log_t v32 = v17;
  os_log_type_t v31 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v40, 4);
    _os_log_debug_impl(&dword_1BA438000, v32, v31, "[%x]: ", v40, 8u);
  }
  v34 |= *((_DWORD *)this + 860) | 1;
  os_log_t v30 = 0;
  if (_logHandle)
  {
    uint64_t v15 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v14 = init_default_corebrightness_log();
    }
    uint64_t v15 = v14;
  }
  os_log_t v30 = v15;
  os_log_type_t v29 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_2_3_4_0_8_32_8_0((uint64_t)v39, 2, (uint64_t)"true", COERCE__INT64(v33));
    _os_log_debug_impl(&dword_1BA438000, v30, v29, "[%x]: active=%s duration=%f", v39, 0x1Cu);
  }
  if (*((_DWORD *)this + 127) == v34)
  {
    if (*((_DWORD *)this + 128) && *((_DWORD *)this + 127) && v33 > 0.0)
    {
      AABC::UpdateState((uint64_t)this, 2);
      AABC::BeginFastRampMode((CFAbsoluteTime *)this, v33, 0.2);
    }
  }
  else
  {
    os_log_t v28 = 0;
    if (_logHandle)
    {
      uint64_t v13 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v12 = init_default_corebrightness_log();
      }
      uint64_t v13 = v12;
    }
    os_log_t v28 = v13;
    os_log_type_t v27 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if (*((_DWORD *)this + 128)) {
        float v3 = "true";
      }
      else {
        float v3 = "false";
      }
      __os_log_helper_16_2_3_8_32_8_32_8_0((uint64_t)v38, (uint64_t)v3, (uint64_t)"true", COERCE__INT64(*((float *)this + 136)));
      _os_log_impl(&dword_1BA438000, v28, v27, "_autoBrightnessEnabled=%s active=%s _Esensor_trusted=%f", v38, 0x20u);
    }
    if (*((_DWORD *)this + 128))
    {
      if (v33 <= 0.0)
      {
        if (*((_DWORD *)this + 860))
        {
          AABC::UpdateState((uint64_t)this, 3);
        }
        else
        {
          *((_DWORD *)this + 175)  = 1;
          AABC::UpdateState((uint64_t)this, 2);
          AABC::BeginFastRampMode((CFAbsoluteTime *)this, *((float *)this + 853), 0.2);
        }
      }
      else
      {
        AABC::UpdateState((uint64_t)this, 2);
        AABC::BeginFastRampMode((CFAbsoluteTime *)this, v33, 0.2);
      }
      os_log_t v26 = 0;
      if (_logHandle)
      {
        uint64_t v11 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v10 = init_default_corebrightness_log();
        }
        uint64_t v11 = v10;
      }
      os_log_t v26 = v11;
      os_log_type_t v25 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_4_0_4_0((uint64_t)v37, 2, *((_DWORD *)this + 150));
        _os_log_debug_impl(&dword_1BA438000, v26, v25, "[%x]: _Esamples=%x", v37, 0xEu);
      }
      if (*((_DWORD *)this + 150))
      {
        float v24 = 0.0;
        float v24 = fminf(fmaxf(AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139)), *((float *)this + 180)), *((float *)this + 182));
        os_log_t v23 = 0;
        if (_logHandle)
        {
          uint64_t v9 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v8 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v8 = init_default_corebrightness_log();
          }
          uint64_t v9 = v8;
        }
        os_log_t v23 = v9;
        os_log_type_t v22 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_8_0((uint64_t)v36, 2, COERCE__INT64(v24));
          _os_log_debug_impl(&dword_1BA438000, v23, v22, "[%x]: L=%f", v36, 0x12u);
        }
        AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 1, 2, 0, v24);
        *((_DWORD *)this + 151)  = 0;
      }
    }
    else
    {
      uint64_t v21 = 0;
      if (_logHandle)
      {
        os_log_type_t v7 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v6 = init_default_corebrightness_log();
        }
        os_log_type_t v7 = v6;
      }
      uint64_t v21 = v7;
      char v20 = 1;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = v21;
        os_log_type_t v5 = v20;
        __os_log_helper_16_0_0(v19);
        _os_log_impl(&dword_1BA438000, v4, v5, "Cancel ramp, manual brightness", v19, 2u);
      }
      AABC::CancelRamp(this);
      AABC::UpdateState((uint64_t)this, 1);
    }
    *((_DWORD *)this + 127)  = v34;
  }
}

void AABC::SetDisplayFactor(AABC *this, float a2, char a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  char v6 = a3 & 1;
  if (_logHandle)
  {
    uint64_t v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v4 = inited;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_4_0((uint64_t)v8, COERCE__INT64(a2), v6 & 1);
    _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "Factor=%0.4f reasonActivateALS=%d", v8, 0x12u);
  }
  if (v6)
  {
    if (*((float *)this + 124) <= 0.0) {
      AABC::SetDisplayFactor(this, a2);
    }
    *((unsigned char *)this + 504)  = v6 & 1;
  }
  else
  {
    *((float *)this + 124)  = a2;
    if ((*((unsigned char *)this + 504) & 1) != 0 && a2 > 0.0)
    {
      AABC::SetDisplayFactor(this, 0.0);
      AABC::SetDisplayFactor(this, a2);
    }
    else
    {
      AABC::SetDisplayFactor(this, a2);
    }
    *((unsigned char *)this + 504)  = 0;
  }
}

void AABC::NotifyCPMSWhenDisplayChangeState(AABC *this, char a2)
{
  v10[3]  = *MEMORY[0x1E4F143B8];
  char v8 = a2 & 1;
  if (([MEMORY[0x1E4F56678] isCPMSSupported] & 1) == 1)
  {
    if (v8)
    {
      os_log_type_t v7 = (void *)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1037)];
      id v6 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1039)];
      id v5 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 1035)];
    }
    else
    {
      os_log_type_t v7 = objc_msgSend(objc_alloc(NSNumber), "initWithInt:");
      id v6 = (id)[objc_alloc(NSNumber) initWithInt:0];
      id v5 = (id)[objc_alloc(NSNumber) initWithInt:0];
    }
    if (*((void *)this + 516) && *((void *)this + 515))
    {
      unsigned int v2 = (void *)*((void *)this + 516);
      v9[0]  = *MEMORY[0x1E4F566B8];
      v10[0]  = v7;
      v9[1]  = *MEMORY[0x1E4F56698];
      v10[1]  = v5;
      void v9[2] = *MEMORY[0x1E4F566A8];
      uint64_t v10[2] = v6;
      id v4 = (id)objc_msgSend(v2, "copyPowerBudgetForRequest:forClient:error:", objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", v10, v9, 3), objc_msgSend(*((id *)this + 515), "clientId"), 0);
      if (v4)
      {
        if (v8) {
          AABC::ProcessCPMSBudget((uint64_t)this, v4);
        }
      }
    }
  }
}

void AABC::SetBrightness(AABC *this, float a2, float a3, int a4, void (*a5)(void *), uint64_t a6)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    os_log_type_t v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    os_log_type_t v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v14, 1, COERCE__INT64(a2), COERCE__INT64(a3));
    _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "[%x]: L=%f duration=%f", v14, 0x1Cu);
  }
  if (*((_DWORD *)this + 128))
  {
    if (*((_DWORD *)this + 127)) {
      DisplaySetVirtualBrightnessWithFade(*((void *)this + 51), a4, (uint64_t)a5, a6, a2, a3);
    }
  }
}

void AABC::_RampDoneCallback(AABC *this, AABC *a2)
{
}

void *AABC::_UpdateEcoModeState(void *this, char a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  char v6 = a2 & 1;
  id v5 = this;
  if ((a2 & 1) != (*((unsigned char *)this + 3416) & 1))
  {
    if (_logHandle)
    {
      id v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      id v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if (v6) {
        unsigned int v2 = "ON";
      }
      else {
        unsigned int v2 = "OFF";
      }
      __os_log_helper_16_2_1_8_32((uint64_t)v7, (uint64_t)v2);
      _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "%s \n", v7, 0xCu);
    }
    *((unsigned char *)v5 + 3416)  = v6 & 1;
    if (*((unsigned char *)v5 + 3416)) {
      return PerceptualLuminanceThresholding::SetAggressivity(*((PerceptualLuminanceThresholding **)v5 + 502), 2u);
    }
    else {
      return PerceptualLuminanceThresholding::SetAggressivity(*((PerceptualLuminanceThresholding **)v5 + 502), 1u);
    }
  }
  return this;
}

uint64_t std::bitset<3ul>::operator[][abi:ne180100](uint64_t a1, char a2)
{
  return std::__bitset<1ul,3ul>::__make_ref[abi:ne180100](a1, a2);
}

uint64_t std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100](uint64_t result, char a2)
{
  if (a2) {
    **(void **)result |= *(void *)(result + 8);
  }
  else {
    **(void **)result &= ~*(void *)(result + 8);
  }
  return result;
}

void AABC::evaluateAABRearConditions(id *this)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  os_log_t v23 = this;
  if ([this[37] isRearALSSupported])
  {
    char v22 = 0;
    char v22 = [this[37] started] & 1;
    char v21 = 0;
    char v12 = 0;
    if (std::bitset<3ul>::none[abi:ne180100](this + 38)) {
      char v12 = v22 ^ 1;
    }
    char v21 = v12 & 1;
    char v20 = 0;
    char v11 = 0;
    if (std::bitset<3ul>::any[abi:ne180100](this + 38)) {
      char v11 = v22;
    }
    char v20 = v11;
    os_log_type_t v19 = @"none";
    if (v21)
    {
      [this[37] startSampling];
      os_log_type_t v19 = @"starting";
    }
    else if (v20)
    {
      [this[37] stopSampling];
      os_log_type_t v19 = @"stopping";
    }
    uint64_t v18 = 0;
    if (_logHandle)
    {
      uint64_t v10 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v10 = inited;
    }
    uint64_t v18 = v10;
    os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      os_log_t log = v18;
      os_log_type_t type = v17;
      v16[0]  = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)(this + 38), 0);
      v16[1]  = v1;
      BOOL v5 = std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator BOOL[abi:ne180100]((uint64_t)v16);
      v15[0]  = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)(this + 38), 1);
      v15[1]  = v2;
      BOOL v6 = std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator BOOL[abi:ne180100]((uint64_t)v15);
      v14[0]  = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)(this + 38), 2);
      v14[1]  = v3;
      BOOL v4 = std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator BOOL[abi:ne180100]((uint64_t)v14);
      __os_log_helper_16_2_5_4_0_4_0_4_0_4_0_8_64((uint64_t)v24, v5, v6, v4, v22 & 1, (uint64_t)v19);
      _os_log_impl(&dword_1BA438000, log, type, "Grimaldi; { \"aod_forbidden\": %d, \"factor_forbidden\": %d, \"property_forbidden\": %d, \"isStarted\": %d, \"st"
        "ate_change\": \"%@\" }",
        v24,
        0x24u);
    }
  }
}

uint64_t AABC::populateCurveValuesFromDictionary(AABC *this, const __CFDictionary *a2, CustomCurve *a3, int a4)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  float v60 = this;
  CFDictionaryRef v59 = a2;
  float v58 = a3;
  int v57 = a4;
  CFArrayRef v55 = 0;
  ValueAtIndex  = 0;
  CFTypeRef v53 = 0;
  FloatFromDictionary  = 0.0;
  float v51 = 0.0;
  int Count = 0;
  char v49 = 0;
  CFArrayFromDictionary  = (CFArrayRef)GetCFArrayFromDictionary(a2, @"E");
  if (CFArrayFromDictionary)
  {
    CFArrayRef v55 = (CFArrayRef)GetCFArrayFromDictionary(v59, @"L");
    if (v55)
    {
      int Count = CFArrayGetCount(CFArrayFromDictionary);
      if (CFArrayGetCount(v55) == Count)
      {
        if (Count)
        {
          if (Count <= v57)
          {
            for (idx  = 0; idx < Count; ++idx)
            {
              ValueAtIndex  = CFArrayGetValueAtIndex(v55, idx);
              CFTypeRef v53 = CFArrayGetValueAtIndex(CFArrayFromDictionary, idx);
              if (!ValueAtIndex
                || !v53
                || (CFTypeID v14 = CFGetTypeID(ValueAtIndex), v14 != CFNumberGetTypeID())
                || (CFTypeID v13 = CFGetTypeID(v53), v13 != CFNumberGetTypeID()))
              {
                if (_logHandle)
                {
                  uint64_t v10 = _logHandle;
                }
                else
                {
                  if (_COREBRIGHTNESS_LOG_DEFAULT) {
                    uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
                  }
                  else {
                    uint64_t inited = init_default_corebrightness_log();
                  }
                  uint64_t v10 = inited;
                }
                if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
                {
                  __os_log_helper_16_0_1_4_0((uint64_t)v63, idx);
                  _os_log_error_impl(&dword_1BA438000, v10, OS_LOG_TYPE_ERROR, "invalid curve data at index %d", v63, 8u);
                }
                return v49 & 1;
              }
              CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberFloatType, &v58->_L[idx]);
              CFNumberGetValue((CFNumberRef)v53, kCFNumberFloatType, &v58->_E[idx]);
              if (_logHandle)
              {
                char v12 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT) {
                  uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else {
                  uint64_t v11 = init_default_corebrightness_log();
                }
                char v12 = v11;
              }
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v64, idx, COERCE__INT64(v58->_E[idx]), COERCE__INT64(v58->_L[idx]));
                _os_log_impl(&dword_1BA438000, v12, OS_LOG_TYPE_DEFAULT, "[%d] nits(%f)  = %f", v64, 0x1Cu);
              }
            }
            v58->size  = Count;
            if (_logHandle)
            {
              uint64_t v8 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v7 = init_default_corebrightness_log();
              }
              uint64_t v8 = v7;
            }
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_1_4_0((uint64_t)v62, v58->size);
              _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "curve size: %d", v62, 8u);
            }
            FloatFromDictionary  = GetFloatFromDictionary(v59, @"m1");
            if (FloatFromDictionary > 0.0) {
              FloatFromDictionary  = *((float *)this + 177)
            }
                                  + (float)(FloatFromDictionary
                                          * (float)(*((float *)this + 179) - *((float *)this + 177)));
            float v51 = GetFloatFromDictionary(v59, @"m2");
            if (v51 > 0.0) {
              float v51 = *((float *)this + 177) + (float)(v51 * (float)(*((float *)this + 179) - *((float *)this + 177)));
            }
            if (_logHandle)
            {
              BOOL v6 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v5 = init_default_corebrightness_log();
              }
              BOOL v6 = v5;
            }
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
            {
              __os_log_helper_16_0_2_8_0_8_0((uint64_t)v61, COERCE__INT64(v51), COERCE__INT64(FloatFromDictionary));
              _os_log_debug_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEBUG, "minThreshold: %f maxThreshold: %f", v61, 0x16u);
            }
            if (FloatFromDictionary > 0.0)
            {
              for (int i = 0; i < v58->size; ++i)
                v58->_L[i]  = fminf(FloatFromDictionary, v58->_L[i]);
            }
            if (v51 > 0.0)
            {
              for (int j = 0; j < v58->size; ++j)
                v58->_L[j]  = fmaxf(v51, v58->_L[j]);
            }
            char v49 = 1;
          }
          else
          {
            if (_logHandle)
            {
              uint64_t v16 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v15 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v15 = init_default_corebrightness_log();
              }
              uint64_t v16 = v15;
            }
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              __os_log_helper_16_0_2_4_0_4_0((uint64_t)v65, v57, Count);
              _os_log_error_impl(&dword_1BA438000, v16, OS_LOG_TYPE_ERROR, "lux and nits array too large for display type (max: %d, actual: %d)", v65, 0xEu);
            }
          }
        }
        else
        {
          os_log_t v39 = 0;
          if (_logHandle)
          {
            char v20 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v19 = init_default_corebrightness_log();
            }
            char v20 = v19;
          }
          os_log_t v39 = v20;
          os_log_type_t v38 = OS_LOG_TYPE_ERROR;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            os_log_type_t v17 = v39;
            os_log_type_t v18 = v38;
            __os_log_helper_16_0_0(v37);
            _os_log_error_impl(&dword_1BA438000, v17, v18, "lux and nits arrays are empty", v37, 2u);
          }
        }
      }
      else
      {
        os_log_t oslog = 0;
        if (_logHandle)
        {
          float v24 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v23 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v23 = init_default_corebrightness_log();
          }
          float v24 = v23;
        }
        os_log_t oslog = v24;
        os_log_type_t v41 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          char v21 = oslog;
          os_log_type_t v22 = v41;
          __os_log_helper_16_0_0(v40);
          _os_log_error_impl(&dword_1BA438000, v21, v22, "lux and nits arrays differ in size", v40, 2u);
        }
      }
    }
    else
    {
      os_log_t v45 = 0;
      if (_logHandle)
      {
        os_log_t v28 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v27 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v27 = init_default_corebrightness_log();
        }
        os_log_t v28 = v27;
      }
      os_log_t v45 = v28;
      char v44 = 16;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = v45;
        os_log_type_t v26 = v44;
        __os_log_helper_16_0_0(v43);
        _os_log_error_impl(&dword_1BA438000, v25, v26, "invalid or missing L (nits) array", v43, 2u);
      }
    }
  }
  else
  {
    double v48 = 0;
    if (_logHandle)
    {
      os_log_t v32 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v31 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v31 = init_default_corebrightness_log();
      }
      os_log_t v32 = v31;
    }
    double v48 = v32;
    char v47 = 16;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v48;
      os_log_type_t type = v47;
      __os_log_helper_16_0_0(v46);
      _os_log_error_impl(&dword_1BA438000, log, type, "invalid or missing E (lux) array", v46, 2u);
    }
  }
  return v49 & 1;
}

CFTypeRef GetCFArrayFromDictionary(const __CFDictionary *a1, const __CFString *a2)
{
  CFDictionaryRef v15 = a1;
  CFTypeID v14 = a2;
  uint64_t v13 = 0;
  if (a1 && (CFTypeID v8 = CFGetTypeID(v15), v8 == CFDictionaryGetTypeID()))
  {
    CFTypeRef Value = CFDictionaryGetValue(v15, v14);
    if (Value)
    {
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFArrayGetTypeID()) {
        return Value;
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
    if (_logHandle)
    {
      BOOL v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      BOOL v6 = inited;
    }
    uint64_t v11 = v6;
    char v10 = 16;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v11;
      os_log_type_t type = v10;
      __os_log_helper_16_0_0(v9);
      _os_log_error_impl(&dword_1BA438000, log, type, "GetCFArrayFromDictionary: ref is NULL or not a dictionary", v9, 2u);
    }
  }
  return (CFTypeRef)v13;
}

float GetFloatFromDictionary(const __CFDictionary *a1, const __CFString *a2)
{
  CFDictionaryRef v15 = a1;
  CFTypeID v14 = a2;
  float valuePtr = 0.0;
  if (a1 && (CFTypeID v8 = CFGetTypeID(v15), v8 == CFDictionaryGetTypeID()))
  {
    CFTypeRef Value = CFDictionaryGetValue(v15, v14);
    if (Value)
    {
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFNumberGetTypeID()) {
        CFNumberGetValue((CFNumberRef)Value, kCFNumberFloatType, &valuePtr);
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
    if (_logHandle)
    {
      BOOL v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      BOOL v6 = inited;
    }
    uint64_t v11 = v6;
    char v10 = 16;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      os_log_t log = v11;
      os_log_type_t type = v10;
      __os_log_helper_16_0_0(v9);
      _os_log_error_impl(&dword_1BA438000, log, type, "GetCFNumberValueAsFloat: ref is NULL or not a dictionary", v9, 2u);
    }
  }
  return valuePtr;
}

void AABC::writeCurveToUserDefaults(AABC *this, CustomCurve *a2, const __CFString *a3, uint64_t a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  char v44 = this;
  int v43 = a2;
  CFStringRef v42 = a3;
  size  = 0;
  size  = a2->size;
  uint64_t v40 = v20;
  unint64_t v29 = (8 * size + 15) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x1F4188790](this, a2, a3, a4);
  os_log_t v30 = (const void **)&v20[-v29];
  uint64_t v39 = v4;
  uint64_t v31 = 512;
  if ((unint64_t)(8 * v4) <= 0x200) {
    size_t v5 = 8 * v4;
  }
  else {
    size_t v5 = 512;
  }
  bzero(&v20[-v29], v5);
  uint64_t v33 = size;
  unint64_t v32 = (8 * size + 15) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x1F4188790](v6, v7, v8, v9);
  int v34 = (const void **)&v20[-v32];
  uint64_t v38 = v33;
  if ((unint64_t)(8 * v33) <= 0x200) {
    size_t v11 = 8 * v33;
  }
  else {
    size_t v11 = v10;
  }
  bzero(&v20[-v32], v11);
  for (int i = 0; i < size; ++i)
  {
    uint64_t v27 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v28 = 12;
    CFNumberRef v13 = CFNumberCreate(v12, kCFNumberFloatType, &v43->_E[i]);
    CFTypeID v14 = v27;
    CFNumberType v15 = v28;
    v30[i]  = v13;
    CFNumberRef v16 = CFNumberCreate(*v14, v15, &v43->_L[i]);
    v34[i]  = v16;
  }
  uint64_t v23 = (const void **)&v46;
  CFArrayRef v46 = 0;
  CFArrayRef v47 = 0;
  os_log_type_t v22 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  char v21 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef v46 = CFArrayCreate(v17, v30, size, MEMORY[0x1E4F1D510]);
  CFArrayRef v47 = CFArrayCreate(*v22, v34, size, v21);
  *(_OWORD *)keys  = xmmword_1E621AB40;
  CFDictionaryRef v36 = 0;
  CFDictionaryRef v36 = CFDictionaryCreate(*v22, (const void **)keys, v23, 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  float v24 = (CFStringRef *)MEMORY[0x1E4F1D3F0];
  CFStringRef v18 = (const __CFString *)*MEMORY[0x1E4F1D3F0];
  uint64_t v25 = (CFStringRef *)MEMORY[0x1E4F1D3E0];
  CFStringRef v19 = (const __CFString *)*MEMORY[0x1E4F1D3E0];
  CFStringRef v26 = @"com.apple.CoreBrightness";
  CFPreferencesSetValue(v42, v36, @"com.apple.CoreBrightness", v18, v19);
  CFPreferencesSynchronize(v26, *v24, *v25);
  for (int j = 0; j < size; ++j)
  {
    CFRelease(v30[j]);
    CFRelease(v34[j]);
  }
  CFRelease(v46);
  CFRelease(v47);
  CFRelease(v36);
}

void ___ZN4AABC24getCurveUpdatesFromArrayEP11objc_object_block_invoke(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a1;
  id v26 = a2;
  uint64_t v25 = a3;
  float v24 = a4;
  uint64_t v23 = a1;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    float v22 = 0.0;
    float v21 = 0.0;
    uint64_t v20 = -1;
    [v26 objectForKeyedSubscript:@"Lux"];
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && ([v26 objectForKeyedSubscript:@"Nits"],
          objc_opt_class(),
          (objc_opt_isKindOfClass() & 1) != 0)
      && ([v26 objectForKeyedSubscript:@"Timestamp"],
          objc_opt_class(),
          (objc_opt_isKindOfClass() & 1) != 0))
    {
      objc_msgSend((id)objc_msgSend(v26, "objectForKeyedSubscript:", @"Lux"), "floatValue");
      float v22 = v4;
      objc_msgSend((id)objc_msgSend(v26, "objectForKeyedSubscript:", @"Nits"), "floatValue");
      float v21 = v5;
      uint64_t v20 = objc_msgSend((id)objc_msgSend(v26, "objectForKeyedSubscript:", @"Timestamp"), "longLongValue");
      os_log_t oslog = 0;
      if (_logHandle)
      {
        uint64_t v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v8 = inited;
      }
      os_log_t oslog = v8;
      os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v28, COERCE__INT64(v22), COERCE__INT64(v21), v20);
        _os_log_debug_impl(&dword_1BA438000, oslog, v15, "Adding curve update from ALS user preferences: %f %f %lld", v28, 0x20u);
      }
      uint64_t v6 = (void *)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
      v14.n128_u64[0]  = __PAIR64__(LODWORD(v21), LODWORD(v22));
      v14.n128_u64[1]  = v20;
      std::list<AAB::CurveUpdate>::push_back(v6, &v14);
    }
    else
    {
      CFStringRef v19 = 0;
      if (_logHandle)
      {
        CFAllocatorRef v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v11 = init_default_corebrightness_log();
        }
        CFAllocatorRef v12 = v11;
      }
      CFStringRef v19 = v12;
      char v18 = 16;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        os_log_t log = v19;
        os_log_type_t type = v18;
        __os_log_helper_16_0_0(v17);
        _os_log_error_impl(&dword_1BA438000, log, type, "Wrongly formatted BOLTS buffer", v17, 2u);
      }
      *float v24 = 1;
    }
  }
}

void ___ZN4AABC17SetDeviceInSleeveEb_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  if (_COREBRIGHTNESS_LOG_DEFAULT) {
    uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
  }
  else {
    uint64_t inited = init_default_corebrightness_log();
  }
  if (os_log_type_enabled(inited, OS_LOG_TYPE_ERROR))
  {
    if (*(unsigned char *)(a1 + 40)) {
      uint64_t v1 = "yes";
    }
    else {
      uint64_t v1 = "no";
    }
    __os_log_helper_16_2_1_8_32((uint64_t)v5, (uint64_t)v1);
    _os_log_error_impl(&dword_1BA438000, inited, OS_LOG_TYPE_ERROR, "deviceInSleeve=%s", v5, 0xCu);
  }
  *(unsigned char *)(v4 + 160)  = *(unsigned char *)(a1 + 40) & 1;
  if (*(unsigned char *)(v4 + 160)) {
    AABC::setFilterDuration(v4, v4 + 168, 4);
  }
  else {
    AABC::resetFilter(v4, (uint64_t *)(v4 + 168));
  }
}

void std::vector<float>::clear[abi:ne180100](uint64_t *a1)
{
}

uint64_t AABC::initAABRear(AABC *this, AABRear *a2)
{
  *((void *)this + 37)  = a2;
  return 1;
}

BOOL std::bitset<3ul>::none[abi:ne180100](void *a1)
{
  return !std::bitset<3ul>::any[abi:ne180100](a1);
}

BOOL std::bitset<3ul>::any[abi:ne180100](void *a1)
{
  return std::__bitset<1ul,3ul>::any[abi:ne180100](a1);
}

BOOL std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator BOOL[abi:ne180100](uint64_t a1)
{
  return (**(void **)a1 & *(void *)(a1 + 8)) != 0;
}

uint64_t __os_log_helper_16_2_5_4_0_4_0_4_0_4_0_8_64(uint64_t result, int a2, int a3, int a4, int a5, uint64_t a6)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 4;
  *(_DWORD *)(result + 10)  = a3;
  *(unsigned char *)(result + 14)  = 0;
  *(unsigned char *)(result + 15)  = 4;
  *(_DWORD *)(result + 16)  = a4;
  *(unsigned char *)(result + 20)  = 0;
  *(unsigned char *)(result + 21)  = 4;
  *(_DWORD *)(result + 22)  = a5;
  *(unsigned char *)(result + 26)  = 64;
  *(unsigned char *)(result + 27)  = 8;
  *(void *)(result + 28)  = a6;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_0_8_0_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 32;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  return result;
}

uint64_t __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 10;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 0;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  *(unsigned char *)(result + 82)  = 0;
  *(unsigned char *)(result + 83)  = 8;
  *(void *)(result + 84)  = a10;
  *(unsigned char *)(result + 92)  = 0;
  *(unsigned char *)(result + 93)  = 8;
  *(void *)(result + 94)  = a11;
  return result;
}

uint64_t __os_log_helper_16_2_5_8_0_8_0_8_0_8_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 32;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  return result;
}

uint64_t __os_log_helper_16_2_3_4_0_8_32_4_0(uint64_t result, int a2, uint64_t a3, int a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 32;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 4;
  *(_DWORD *)(result + 20)  = a4;
  return result;
}

void AABC::SetDisplayFactor(AABC *this, float a2)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  os_log_t v62 = this;
  float v61 = a2;
  os_log_t v60 = 0;
  if (_logHandle)
  {
    id v26 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    id v26 = inited;
  }
  os_log_t v60 = v26;
  os_log_type_t type = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v69, COERCE__INT64(v61));
    _os_log_impl(&dword_1BA438000, v60, type, "Factor=%0.4f", v69, 0xCu);
  }
  if (v61 != *((float *)this + 123))
  {
    float v58 = 0.0;
    float v58 = *((float *)this + 123);
    *((float *)this + 123)  = v61;
    *((_DWORD *)this + 122)  = *((float *)this + 123) > 0.0;
    if (v58 == 0.0 && *((float *)this + 123) > 0.0)
    {
      *((_DWORD *)this + 141)  = 0;
      *((_DWORD *)this + 152)  = 0;
      *((_DWORD *)this + 153)  = 0;
      if (*((void *)this + 521) && (*((_DWORD *)this + 80) == 6 || *((_DWORD *)this + 80) == 1))
      {
        char v57 = 0;
        [*((id *)this + 521) sendCommand:233 inputBuffer:&v57 inputBufferSize:1];
      }
      if ((*((unsigned char *)this + 3368) & 1) != 0
        && *((_DWORD *)this + 832)
        && *((_DWORD *)this + 832) < *((_DWORD *)this + 843))
      {
        if (*((_DWORD *)this + 840))
        {
          AABC::revertToGoodCurve((uint64_t)this, 4u);
          *((_DWORD *)this + 840)  = 1;
        }
        else
        {
          CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
          if (Current > *((double *)this + (*((_DWORD *)this + 832) - 1) + 417) + *((double *)this + 422)
            && Current > *((double *)this + 414) + *((double *)this + 423))
          {
            AABC::revertToGoodCurve((uint64_t)this, 4u);
            *((_DWORD *)this + 840)  = 1;
          }
        }
      }
      if (*((unsigned char *)this + 3401))
      {
        CFAbsoluteTime v55 = CFAbsoluteTimeGetCurrent();
        if (v55 - *((double *)this + 414) >= *((double *)this + 152)) {
          AABC::revertToGoodCurve((uint64_t)this, 1u);
        }
      }
      os_log_t v54 = 0;
      if (_logHandle)
      {
        float v24 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v23 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v23 = init_default_corebrightness_log();
        }
        float v24 = v23;
      }
      os_log_t v54 = v24;
      os_log_type_t v53 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v68, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)));
        _os_log_debug_impl(&dword_1BA438000, v54, v53, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f", v68, 0x2Au);
      }
      os_log_t v52 = 0;
      if (_logHandle)
      {
        float v22 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v21 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v21 = init_default_corebrightness_log();
        }
        float v22 = v21;
      }
      os_log_t v52 = v22;
      os_log_type_t v51 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v67, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
        _os_log_debug_impl(&dword_1BA438000, v52, v51, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v67, 0x2Au);
      }
      os_log_t v50 = 0;
      if (_logHandle)
      {
        uint64_t v20 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v19 = init_default_corebrightness_log();
        }
        uint64_t v20 = v19;
      }
      os_log_t v50 = v20;
      os_log_type_t v49 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        char v18 = 0;
        if (*((void *)this + 60)) {
          char v18 = *((unsigned char *)this + 3937);
        }
        if (v18) {
          uint64_t v2 = "yes";
        }
        else {
          uint64_t v2 = "no";
        }
        __os_log_helper_16_2_2_8_32_8_32((uint64_t)v66, (uint64_t)v2, (uint64_t)(&kDimPolicyStr)[*((unsigned int *)this + 859)]);
        _os_log_debug_impl(&dword_1BA438000, v50, v49, "prox mitigation: %s dimPolicy: %s", v66, 0x16u);
      }
      *((_DWORD *)this + 996)  = 0;
      if (*((_DWORD *)this + 860)) {
        AABC::SetAutoBrightnessStatus(this, 1, *((float *)this + 853));
      }
      AABC::UpdateState((uint64_t)this, 2);
      AABC::BeginFastRampMode((CFAbsoluteTime *)this, *((float *)this + 853), 0.2);
      if (*((_DWORD *)this + 150))
      {
        float v48 = 0.0;
        float v48 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
        if (*((unsigned char *)this + 3417))
        {
          float v47 = 0.0;
          float v47 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 802, *((float *)this + 136), *((float *)this + 139));
          float v48 = fminf(v48, v47);
          if ((*((unsigned char *)this + 3418) & 1) == 0) {
            float v48 = fminf(*((float *)this + 855), v47);
          }
        }
        float v48 = fminf(fmaxf(v48, *((float *)this + 180)), *((float *)this + 182));
        AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 0, 2, 0, v48);
      }
      else
      {
        if ((*((unsigned char *)this + 144) & 1) != 0 && *((void *)this + 57) && *(void *)(*((void *)this + 57) + 32))
        {
          id v46 = 0;
          LODWORD(v3)  = 0.5;
          id v46 = (id)[*(id *)(*((void *)this + 57) + 32) copyALSEventWithinTimeout:v3];
          if (v46)
          {
            os_log_t v45 = 0;
            if (_logHandle)
            {
              CFAllocatorRef v17 = _logHandle;
            }
            else
            {
              if (_COREBRIGHTNESS_LOG_DEFAULT) {
                uint64_t v16 = _COREBRIGHTNESS_LOG_DEFAULT;
              }
              else {
                uint64_t v16 = init_default_corebrightness_log();
              }
              CFAllocatorRef v17 = v16;
            }
            os_log_t v45 = v17;
            os_log_type_t v44 = OS_LOG_TYPE_DEFAULT;
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              __os_log_helper_16_2_1_8_66((uint64_t)v65, (uint64_t)v46);
              _os_log_impl(&dword_1BA438000, v45, v44, "Use copied event: %{public}@", v65, 0xCu);
            }
            AABC::HandleALSEvent(this, *((__IOHIDServiceClient **)this + 41), (__IOHIDEvent *)[v46 event]);
          }
          if (!*((_DWORD *)this + 150) && (*((unsigned char *)this + 444) & 1) != 0)
          {
            os_log_t oslog = 0;
            if (_logHandle)
            {
              os_log_type_t v15 = _logHandle;
            }
            else
            {
              uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
              os_log_type_t v15 = v14;
            }
            os_log_t oslog = v15;
            os_log_type_t v42 = OS_LOG_TYPE_ERROR;
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              __os_log_helper_16_0_1_8_0((uint64_t)v64, COERCE__INT64(*((float *)this + 852)));
              _os_log_error_impl(&dword_1BA438000, oslog, v42, "Copy event failed => arm first ALS sample TIMEOUT routine (timeout=%f)", v64, 0xCu);
            }
          }
        }
        if (!*((_DWORD *)this + 150)) {
          AABC::ArmFirstALSSampleTimer(this);
        }
      }
      v41[0]  = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)this + 304, 1);
      v41[1]  = v4;
      std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v41, 0);
      AABC::evaluateAABRearConditions((id *)this);
    }
    else if (*((float *)this + 123) == 1.0)
    {
      *((_DWORD *)this + 141)  = 0;
      *((_DWORD *)this + 151)  = 0;
      *((_DWORD *)this + 152)  = 0;
      *((_DWORD *)this + 153)  = 0;
      float v40 = 0.0;
      float v40 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
      if (*((unsigned char *)this + 3417))
      {
        float v39 = 0.0;
        float v39 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 802, *((float *)this + 136), *((float *)this + 139));
        float v40 = fminf(v40, v39);
        if ((*((unsigned char *)this + 3418) & 1) == 0) {
          float v40 = fminf(*((float *)this + 855), v39);
        }
      }
      float v40 = fminf(fmaxf(v40, *((float *)this + 180)), *((float *)this + 182));
      os_log_t v38 = 0;
      if (_logHandle)
      {
        CFNumberRef v13 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v12 = init_default_corebrightness_log();
        }
        CFNumberRef v13 = v12;
      }
      os_log_t v38 = v13;
      os_log_type_t v37 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_4_0_8_0((uint64_t)v63, 2, COERCE__INT64(v40));
        _os_log_debug_impl(&dword_1BA438000, v38, v37, "[%x]: L=%f", v63, 0x12u);
      }
      if (*((_DWORD *)this + 128) && *((_DWORD *)this + 127)) {
        AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 0, 2, 0, v40);
      }
    }
    else if (*((float *)this + 123) == 0.0)
    {
      v36[0]  = std::bitset<3ul>::operator[][abi:ne180100]((uint64_t)this + 304, 1);
      v36[1]  = v5;
      std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v36, 1);
      AABC::evaluateAABRearConditions((id *)this);
      AABC::CancelFirstSampleTimeout((dispatch_object_t *)this);
      if (*((_DWORD *)this + 80) == 6 && *((_DWORD *)this + 717) == 1 && *((void *)this + 41))
      {
        id v35 = (id)[objc_alloc(NSNumber) initWithInt:0];
        CFTypeRef property = (CFTypeRef)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v35, @"AOTState", 0);
        AABC::setAlwaysOnProperty((id *)this, &cfstr_Aotstate.isa, (objc_object *)property);
        IOHIDServiceClientSetProperty(*((IOHIDServiceClientRef *)this + 41), @"AOTState", property);
      }
      AABC::UpdateState((uint64_t)this, 0);
      uint64_t v33 = mach_absolute_time();
      if (*((int *)this + 926) >= 0)
      {
        unint64_t v32 = 0;
        unint64_t v32 = v33 - *((void *)this + 485);
        uint64_t v6 = (double *)((char *)this + 8 * *((int *)this + 926) + 3808);
        *uint64_t v6 = *v6 + (double)v32 * *(double *)&AABC::_sMachTimebaseFactor;
      }
      *((_DWORD *)this + 926)  = -1;
      [*((id *)this + 488) removeAllObjects];
      float v7 = (double)v33 * *(double *)&AABC::_sMachTimebaseFactor;
      *((float *)this + 168)  = v7;
      *((_DWORD *)this + 87)  = 0;
      if (*((unsigned char *)this + 3401) & 1) != 0 && (*((unsigned char *)this + 3320))
      {
        *((CFAbsoluteTime *)this + 414)  = CFAbsoluteTimeGetCurrent();
        os_log_t v31 = 0;
        if (_logHandle)
        {
          uint64_t v11 = _logHandle;
        }
        else
        {
          uint64_t v10 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          uint64_t v11 = v10;
        }
        os_log_t v31 = v11;
        os_log_type_t v30 = OS_LOG_TYPE_INFO;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          uint64_t v8 = v31;
          os_log_type_t v9 = v30;
          __os_log_helper_16_0_0(v29);
          _os_log_impl(&dword_1BA438000, v8, v9, "User interacted in the session. Resetting counter for AAB cap\n", v29, 2u);
        }
      }
      if (*((unsigned char *)this + 3368)) {
        *((CFAbsoluteTime *)this + 414)  = CFAbsoluteTimeGetCurrent();
      }
      if (*((void *)this + 54))
      {
        CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)this + 54));
        *((unsigned char *)this + 440)  = 0;
        *((unsigned char *)this + 442)  = 0;
        *((unsigned char *)this + 443)  = 0;
      }
      if (*((unsigned char *)this + 3320)) {
        *((unsigned char *)this + 3320)  = 0;
      }
      if (*((void *)this + 507) && ([*((id *)this + 507) isActive] & 1) != 0) {
        [*((id *)this + 507) action:0];
      }
      AABC::_UpdateNitsRestrictions(this, -1.0, 0.2, 1);
      if (*((void *)this + 521) && (*((_DWORD *)this + 80) == 6 || *((_DWORD *)this + 80) == 1))
      {
        char v28 = 0;
        [*((id *)this + 521) sendCommand:234 inputBuffer:&v28 inputBufferSize:1];
        DisplaySetDCPPowerAssertionForAOT(*((void *)this + 51), 0);
        *((unsigned char *)this + 4176)  = 0;
      }
      if (*((unsigned char *)this + 160)) {
        AABC::resetFilter((uint64_t)this, (uint64_t *)this + 21);
      }
      if (*((unsigned char *)this + 264)) {
        AABC::resetMovingAverage(this);
      }
      if (*((unsigned char *)this + 161)) {
        AABC::resetFilter((uint64_t)this, (uint64_t *)this + 27);
      }
    }
  }
}

float AABC::BeginFastRampMode(CFAbsoluteTime *this, float a2, float a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    uint64_t v5 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v5 = inited;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_1_8_0((uint64_t)v9, COERCE__INT64(a2));
    _os_log_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEFAULT, "begin fast ramp mode for %.1fs", v9, 0xCu);
  }
  this[85]  = CFAbsoluteTimeGetCurrent();
  this[86]  = this[85] + a2;
  *((_DWORD *)this + 169)  = 1;
  float result = a3;
  *((float *)this + 174)  = a3;
  return result;
}

uint64_t AABC::setAlwaysOnProperty(id *this, NSString *a2, objc_object *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v17 = this;
  id v16 = a2;
  id v15 = a3;
  if ([(NSString *)a2 isEqualToString:@"CurrentBrightness"])
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      if (this[521])
      {
        int v14 = [v15 intValue];
        os_log_t v13 = 0;
        if (_logHandle)
        {
          uint64_t v8 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t inited = init_default_corebrightness_log();
          }
          uint64_t v8 = inited;
        }
        os_log_t v13 = v8;
        os_log_type_t v12 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_4_0((uint64_t)v19, COERCE__INT64((double)v14 / 65536.0), v14);
          _os_log_impl(&dword_1BA438000, v13, v12, "Setting CurrentBrightness to %f, %d (IOFixed)", v19, 0x12u);
        }
        [this[521] sendCommand:225 inputBuffer:&v14 inputBufferSize:4];
      }
    }
  }
  uint64_t result = [v16 isEqualToString:@"AOTState"];
  if (result)
  {
    objc_opt_class();
    uint64_t result = objc_opt_isKindOfClass();
    if (result)
    {
      if (this[521])
      {
        int v11 = 0;
        uint64_t v10 = (void *)[v15 valueForKey:@"AOTState"];
        objc_opt_class();
        uint64_t result = objc_opt_isKindOfClass();
        if (result)
        {
          int v11 = [v10 intValue];
          if (_logHandle)
          {
            uint64_t v6 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v5 = init_default_corebrightness_log();
            }
            uint64_t v6 = v5;
          }
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            os_log_t v4 = v6;
            __os_log_helper_16_0_1_4_0((uint64_t)v18, v11);
            _os_log_impl(&dword_1BA438000, v6, OS_LOG_TYPE_DEFAULT, "Sending AOTState to DCP, aotState: %d", v18, 8u);
          }
          return objc_msgSend(this[521], "sendCommand:inputBuffer:inputBufferSize:", 227, &v11, 4, v4);
        }
      }
    }
  }
  return result;
}

void AABC::SetALSInterval(AABC *this, float a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    double v3 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    double v3 = inited;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_2_4_0_8_0((uint64_t)v6, 16, COERCE__INT64(a2));
    _os_log_debug_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEBUG, "[%x]: interval=%f", v6, 0x12u);
  }
  *((float *)this + 158)  = a2;
  AABC::UpdateALSState((CFDictionaryRef *)this, 1);
}

uint64_t AABC::AutobrightnessOn_UpdateCurve(AABC *this)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  float LogicalBrightness = DisplayGetLogicalBrightness(*((void *)this + 51));
  *((float *)this + 155)  = LogicalBrightness;
  *((float *)this + 154)  = LogicalBrightness;
  AABC::_UpdateEsensorTrusted(this, *((float *)this + 134));
  AAB::UpdateCurve_Block3((uint64_t)this, (uint64_t)this + 1048, *((float *)this + 136), *((float *)this + 139), *((float *)this + 155));
  if (_logHandle)
  {
    uint64_t v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    if (*((float *)this + 136) <= *((float *)this + 7)) {
      uint64_t v5 = "L1 & L2";
    }
    else {
      uint64_t v5 = "E2 & L2";
    }
    __os_log_helper_16_2_5_8_0_8_0_8_0_8_0_8_32((uint64_t)v11, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)), (uint64_t)v5);
    _os_log_debug_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEBUG, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f  [updated %s]", v11, 0x34u);
  }
  if (_logHandle)
  {
    os_log_t v4 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t v3 = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t v3 = init_default_corebrightness_log();
    }
    os_log_t v4 = v3;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v10, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
    _os_log_debug_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEBUG, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v10, 0x2Au);
  }
  float v9 = fminf(fmaxf(AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139)), *((float *)this + 180)), *((float *)this + 182));
  *((float *)this + 151)  = v9;
  return AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 0, 2, 0, v9);
}

void AABC::SetAutoBrightnessState(AABC *this, int a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  int v34 = this;
  int v33 = a2;
  os_log_t v32 = 0;
  if (_logHandle)
  {
    CFAllocatorRef v17 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    CFAllocatorRef v17 = inited;
  }
  os_log_t v32 = v17;
  os_log_type_t v31 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    __os_log_helper_16_0_1_4_0((uint64_t)v38, 4);
    _os_log_debug_impl(&dword_1BA438000, v32, v31, "[%x]: ", v38, 8u);
  }
  if (*((_DWORD *)this + 128) != v33)
  {
    if (*((void *)this + 521) && *((_DWORD *)this + 80) == 6)
    {
      BOOL v30 = v33 != 0;
      [*((id *)this + 521) sendCommand:240 inputBuffer:&v30 inputBufferSize:1];
    }
    os_log_t v29 = 0;
    if (_logHandle)
    {
      id v15 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v14 = init_default_corebrightness_log();
      }
      id v15 = v14;
    }
    os_log_t v29 = v15;
    os_log_type_t v28 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      if (v33) {
        uint64_t v2 = "true";
      }
      else {
        uint64_t v2 = "false";
      }
      if (*((_DWORD *)this + 127)) {
        uint64_t v3 = "true";
      }
      else {
        uint64_t v3 = "false";
      }
      __os_log_helper_16_2_2_8_32_8_32((uint64_t)v37, (uint64_t)v2, (uint64_t)v3);
      _os_log_impl(&dword_1BA438000, v29, v28, "autoBrightnessEnabled=%s _autoBrightnessActive=%s", v37, 0x16u);
    }
    if (v33 && *((_DWORD *)this + 127))
    {
      AABC::setAABCurveUpdateReason((uint64_t)this, 3u);
      float LogicalBrightness = DisplayGetLogicalBrightness(*((void *)this + 51));
      *((float *)this + 155)  = LogicalBrightness;
      *((float *)this + 154)  = LogicalBrightness;
      AABC::_UpdateEsensorTrusted(this, *((float *)this + 134));
      os_log_t v27 = 0;
      if (_logHandle)
      {
        os_log_t v13 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v12 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v12 = init_default_corebrightness_log();
        }
        os_log_t v13 = v12;
      }
      os_log_t v27 = v13;
      os_log_type_t v26 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        if (*((float *)this + 136) <= *((float *)this + 7)) {
          int v11 = "L1 & L2";
        }
        else {
          int v11 = "E2 & L2";
        }
        __os_log_helper_16_2_5_8_0_8_0_8_0_8_0_8_32((uint64_t)v36, COERCE__INT64(*((float *)this + 266)), COERCE__INT64(*((float *)this + 268)), COERCE__INT64(*((float *)this + 267)), COERCE__INT64(*((float *)this + 269)), (uint64_t)v11);
        _os_log_debug_impl(&dword_1BA438000, v27, v26, "curve E1: %0.2f L1: %0.4f E2: %0.2f L2: %0.4f  [updated %s]", v36, 0x34u);
      }
      os_log_t v25 = 0;
      if (_logHandle)
      {
        uint64_t v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v9 = init_default_corebrightness_log();
        }
        uint64_t v10 = v9;
      }
      os_log_t v25 = v10;
      os_log_type_t v24 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v35, COERCE__INT64(*((float *)this + 262)), COERCE__INT64(*((float *)this + 263)), COERCE__INT64(*((float *)this + 264)), COERCE__INT64(*((float *)this + 265)));
        _os_log_debug_impl(&dword_1BA438000, v25, v24, "dark curve E0a: %0.2f L0a: %0.4f E0b: %0.2f L0b: %0.4f", v35, 0x2Au);
      }
      AABC::UpdateState((uint64_t)this, 3);
      float v23 = 0.0;
      float v23 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 262, *((float *)this + 136), *((float *)this + 139));
      if (*((unsigned char *)this + 3417))
      {
        float v22 = 0.0;
        float v22 = AABC::IlluminanceToLuminance((uint64_t)this, (float *)this + 802, *((float *)this + 136), *((float *)this + 139));
        if ((*((unsigned char *)this + 3418) & 1) == 0) {
          float v23 = fminf(*((float *)this + 855), v22);
        }
      }
      float v23 = fminf(fmaxf(v23, *((float *)this + 180)), *((float *)this + 182));
      *((float *)this + 151)  = v23;
      *((_DWORD *)this + 128)  = v33;
      AABC::UpdateDisplayBrightness_Block6((uint64_t)this, 1, 2, 1, v23);
    }
    else
    {
      os_log_t oslog = 0;
      if (_logHandle)
      {
        uint64_t v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v7 = init_default_corebrightness_log();
        }
        uint64_t v8 = v7;
      }
      os_log_t oslog = v8;
      os_log_type_t v20 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v5 = oslog;
        os_log_type_t v6 = v20;
        __os_log_helper_16_0_0(v19);
        _os_log_debug_impl(&dword_1BA438000, v5, v6, "Cancel ramp, disabling auto-brightness", v19, 2u);
      }
      AABC::CancelRamp(this);
    }
    *((_DWORD *)this + 128)  = v33;
    +[CBAnalytics autoBrightnessEnabled:*((_DWORD *)this + 128) != 0 byUser:1];
    *((_DWORD *)this + 128)  = 1;
  }
}

uint64_t __os_log_helper_16_2_3_4_0_8_32_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 32;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_32_8_32_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 32;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  return result;
}

float AABC::IlluminanceToLuminanceAggregated_AOD(uint64_t a1, AAB *a2, float *a3, float a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  float v10 = AAB::IlluminanceToLuminance(a1, a3, a4);
  float v9 = AAB::IlluminanceToLuminance(a2, a4, v4);
  float v8 = fminf(v10, v9);
  if (_logHandle)
  {
    uint64_t v7 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v7 = inited;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v13, COERCE__INT64(a4), COERCE__INT64(v10), COERCE__INT64(v9), COERCE__INT64(v8));
    _os_log_impl(&dword_1BA438000, v7, OS_LOG_TYPE_DEFAULT, "IlluminanceToLuminanceAggregated_AOD: E  = %f | normal L  = %f | AOD L  = %f >>> L %f", v13, 0x2Au);
  }
  return v8;
}

float AABC::IlluminanceToLuminance(AABC *this, float a2, CustomCurve *a3)
{
  if (AABC::isAODCurveActive((uint64_t)this, [+[CBAODState sharedInstance] AODState]))
  {
    return AABC::IlluminanceToLuminanceAggregated_AOD((uint64_t)this, (AABC *)((char *)this + 2540), (float *)this + 262, a2);
  }
  else
  {
    return AAB::IlluminanceToLuminance((AAB *)a3, a2, v3);
  }
}

float AABC::LuminanceToIlluminance(AABC *this, float a2, CustomCurve *a3)
{
  return fmaxf(0.0, AAB::LuminanceToIlluminance(this, a2, a3));
}

uint64_t __os_log_helper_16_0_10_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 10;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 0;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  *(unsigned char *)(result + 82)  = 0;
  *(unsigned char *)(result + 83)  = 8;
  *(void *)(result + 84)  = a10;
  *(unsigned char *)(result + 92)  = 0;
  *(unsigned char *)(result + 93)  = 4;
  *(_DWORD *)(result + 94)  = a11;
  return result;
}

__CFString *AABCurveUpdateReasonToString(unsigned int a1)
{
  os_log_t v4 = 0;
  if (a1)
  {
    uint64_t v2 = a1;
    char v1 = 1;
  }
  else
  {
    uint64_t v2 = 0;
    char v1 = 0;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        os_log_t v4 = @"user adjustment";
        break;
      case 1:
        os_log_t v4 = @"AAB capping";
        break;
      case 2:
        os_log_t v4 = @"reset after in-App adjustment";
        break;
      case 3:
        os_log_t v4 = @"AAB reset";
        break;
      case 4:
        os_log_t v4 = @"Outlier removal";
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v4;
}

uint64_t AABC::IsProxEmulationTriggered(AABC *this, int *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  os_log_type_t v26 = this;
  os_log_t v25 = a2;
  unsigned int v24 = 0;
  float v23 = 0.5;
  if (*((float *)this + 152) <= 250.0)
  {
    if (*((float *)this + 152) > 100.0) {
      float v23 = 0.4;
    }
  }
  else
  {
    float v23 = 0.2;
  }
  *os_log_t v25 = 0;
  if (*((float *)this + 136) >= (float)(v23 * *((float *)this + 152)) || *((float *)this + 136) >= 200.0)
  {
    os_log_t v18 = 0;
    if (_logHandle)
    {
      float v8 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v8 = inited;
    }
    os_log_t v18 = v8;
    os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v27, COERCE__INT64(*((float *)this + 136)));
      _os_log_debug_impl(&dword_1BA438000, v18, v17, "Unrestricting prox emulation. E_sensor  = %f", v27, 0xCu);
    }
    if (*((_DWORD *)this + 141) == 1) {
      *((float *)this + 154)  = DisplayGetVirtualBrightness(*((float **)this + 51));
    }
    *((_DWORD *)this + 141)  = 0;
    *((_DWORD *)this + 153)  = *((_DWORD *)this + 136);
  }
  else if (*((_DWORD *)this + 141) {
         && (*((_DWORD *)this + 141) != 2
  }
          || *((float *)this + 136) > (float)(*((float *)this + 153) / 2.0)
          || *((float *)this + 136) > (float)(*((float *)this + 153) - 5.0)))
  {
    if (*((_DWORD *)this + 141) == 1
      && *((float *)this + 136) > (float)(*((float *)this + 153) * 2.0)
      && *((float *)this + 136) > (float)(*((float *)this + 153) + 20.0))
    {
      os_log_t v20 = 0;
      if (_logHandle)
      {
        float v10 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v9 = init_default_corebrightness_log();
        }
        float v10 = v9;
      }
      os_log_t v20 = v10;
      os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v28, COERCE__INT64(*((float *)this + 152)), COERCE__INT64(*((float *)this + 153)), COERCE__INT64(*((float *)this + 136)));
        _os_log_debug_impl(&dword_1BA438000, v20, v19, "ALS possibly covered. E_maximum  = %f, E_low  = %f, E_sensor  = %f", v28, 0x20u);
      }
      *((float *)this + 154)  = DisplayGetVirtualBrightness(*((float **)this + 51));
      *((_DWORD *)this + 141)  = 2;
      *((_DWORD *)this + 153)  = *((_DWORD *)this + 136);
    }
  }
  else
  {
    os_log_t v22 = 0;
    if (_logHandle)
    {
      uint64_t v12 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v11 = init_default_corebrightness_log();
      }
      uint64_t v12 = v11;
    }
    os_log_t v22 = v12;
    os_log_type_t v21 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_8_0_8_0_8_0((uint64_t)v29, COERCE__INT64(*((float *)this + 152)), COERCE__INT64(*((float *)this + 153)), COERCE__INT64(*((float *)this + 136)));
      _os_log_debug_impl(&dword_1BA438000, v22, v21, "ALS covered. Triggering prox emulation. E_maximum  = %f, E_low  = %f, E_sensor  = %f", v29, 0x20u);
    }
    *((_DWORD *)this + 141)  = 1;
  }
  if (*((_DWORD *)this + 141) == 1)
  {
    os_log_t oslog = 0;
    if (_logHandle)
    {
      os_log_type_t v6 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v5 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v5 = init_default_corebrightness_log();
      }
      os_log_type_t v6 = v5;
    }
    os_log_t oslog = v6;
    os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = oslog;
      os_log_type_t v4 = v15;
      __os_log_helper_16_0_0(v14);
      _os_log_debug_impl(&dword_1BA438000, v3, v4, "Restricting because of ALS covered", v14, 2u);
    }
    *os_log_t v25 = 1;
    unsigned int v24 = 1;
    *((float *)this + 153)  = fminf(*((float *)this + 153), *((float *)this + 136));
  }
  return v24;
}

void AABC::_UpdateNitsRestrictionsSinglePoint(AABC *this, float a2, float a3, char a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  float v28 = a3;
  char v27 = a4 & 1;
  float v26 = a2;
  float v25 = a2;
  if (a3 < 0.0) {
    float v28 = 2.5;
  }
  if (a2 < 0.0)
  {
    float v25 = 0.0;
    float v26 = 0.0;
  }
  if (*((unsigned char *)this + 3472))
  {
    if (*((_DWORD *)this + 130)) {
      float v24 = *((float *)this + 873);
    }
    else {
      float v24 = *((float *)this + 872);
    }
    if (v25 < *((float *)this + 870))
    {
      if (v25 >= *((float *)this + 871))
      {
        float v4 = (v24 - 1.0)
           * (float)((float)(v25 - *((float *)this + 870)) + (float)(*((float *)this + 870) - *((float *)this + 871)))
           / (float)(*((float *)this + 870) - *((float *)this + 871))
           + 1.0;
        float v23 = v4;
      }
      else
      {
        float v23 = 1.0;
      }
    }
    else
    {
      float v23 = v24;
    }
    float RestrictionFactorTarget = DisplayGetRestrictionFactorTarget(*((void *)this + 51), 1);
    BOOL v16 = 0;
    if (v25 > *((float *)this + 869)) {
      BOOL v16 = RestrictionFactorTarget < v24;
    }
    char isTrustedOccluded = 0;
    if (v23 < RestrictionFactorTarget) {
      char isTrustedOccluded = AABC::isTrustedOccluded((id **)this);
    }
    if ((v27 & 1) != 0 || (v23 < RestrictionFactorTarget || v16) && (isTrustedOccluded & 1) == 0)
    {
      if (_logHandle)
      {
        uint64_t v14 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        uint64_t v14 = inited;
      }
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v30, COERCE__INT64(v23), COERCE__INT64(v25));
        _os_log_debug_impl(&dword_1BA438000, v14, OS_LOG_TYPE_DEBUG, "Set minimum restriction %f for E=%f\n", v30, 0x16u);
      }
      if (v16) {
        DisplaySetRestrictionFactorWithFade(*((void *)this + 51), 1, v23, v28, COERCE_FLOAT(*((void *)this + 433)), COERCE_FLOAT(HIDWORD(*((void *)this + 433))));
      }
      else {
        DisplaySetRestrictionFactorWithFade(*((void *)this + 51), 1, v23, v28 * 2.0, COERCE_FLOAT(*((void *)this + 433)), COERCE_FLOAT(HIDWORD(*((void *)this + 433))));
      }
    }
  }
  if (*((unsigned char *)this + 3588))
  {
    float v20 = *((float *)this + 898);
    if (*((_DWORD *)this + 130)) {
      float v21 = *((float *)this + 902);
    }
    else {
      float v21 = *((float *)this + 901);
    }
    if ([*((id *)this + 508) isActive])
    {
      uint64_t v12 = *((void *)this + 51);
      [*((id *)this + 508) getCap];
      float v21 = fminf(v21, DisplayGetRestrictionFactorForNits(v12, 0, v5));
      float v20 = *((float *)this + 899);
    }
    if (v26 <= *((float *)this + 899)) {
      double v11 = v21;
    }
    else {
      double v11 = v21
    }
          + (1.0 - v21)
          * (float)(v26 - *((float *)this + 899))
          / (float)(*((float *)this + 900) - *((float *)this + 899));
    float v6 = v11;
    float v19 = v6;
    if (v6 > 1.0) {
      float v19 = 1.0;
    }
    float v18 = DisplayGetRestrictionFactorTarget(*((void *)this + 51), 0);
    BOOL v10 = 0;
    if (v26 < v20) {
      BOOL v10 = v18 > v21;
    }
    char v9 = 0;
    if (v19 <= v18) {
      char v9 = AABC::isTrustedOccluded((id **)this);
    }
    if ((v27 & 1) != 0 || v19 > v18 || v10 && (v9 & 1) == 0)
    {
      if (_logHandle)
      {
        float v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v7 = init_default_corebrightness_log();
        }
        float v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v29, COERCE__INT64(v19), COERCE__INT64(v26));
        _os_log_debug_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEBUG, "Set maximum restriction %f for E=%f\n", v29, 0x16u);
      }
      if (v10) {
        DisplaySetRestrictionFactorWithFade(*((void *)this + 51), 0, v19, v28 * 2.0, COERCE_FLOAT(*((void *)this + 433)), COERCE_FLOAT(HIDWORD(*((void *)this + 433))));
      }
      else {
        DisplaySetRestrictionFactorWithFade(*((void *)this + 51), 0, v19, v28, COERCE_FLOAT(*((void *)this + 433)), COERCE_FLOAT(HIDWORD(*((void *)this + 433))));
      }
    }
  }
}

uint64_t AABC::GetNitsBin(AABC *this, float a2)
{
  if (a2 >= 10.0)
  {
    if (a2 >= 75.0)
    {
      if (a2 >= 100.0)
      {
        if (a2 >= 125.0)
        {
          if (a2 >= 150.0)
          {
            if (a2 >= 250.0)
            {
              if (a2 >= 350.0)
              {
                if (a2 >= 450.0)
                {
                  if (a2 >= 550.0) {
                    return 9;
                  }
                  else {
                    return 8;
                  }
                }
                else
                {
                  return 7;
                }
              }
              else
              {
                return 6;
              }
            }
            else
            {
              return 5;
            }
          }
          else
          {
            return 4;
          }
        }
        else
        {
          return 3;
        }
      }
      else
      {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __os_log_helper_16_2_3_4_0_8_0_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 32;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_8_4_0_8_0_8_32_8_32_4_0_8_32_4_0_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 8;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 32;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 32;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 4;
  *(_DWORD *)(result + 40)  = a6;
  *(unsigned char *)(result + 44)  = 32;
  *(unsigned char *)(result + 45)  = 8;
  *(void *)(result + 46)  = a7;
  *(unsigned char *)(result + 54)  = 0;
  *(unsigned char *)(result + 55)  = 4;
  *(_DWORD *)(result + 56)  = a8;
  *(unsigned char *)(result + 60)  = 32;
  *(unsigned char *)(result + 61)  = 8;
  *(void *)(result + 62)  = a9;
  return result;
}

uint64_t __os_log_helper_16_0_7_4_0_4_0_8_0_8_0_8_0_8_0_8_0(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 7;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 4;
  *(_DWORD *)(result + 10)  = a3;
  *(unsigned char *)(result + 14)  = 0;
  *(unsigned char *)(result + 15)  = 8;
  *(void *)(result + 16)  = a4;
  *(unsigned char *)(result + 24)  = 0;
  *(unsigned char *)(result + 25)  = 8;
  *(void *)(result + 26)  = a5;
  *(unsigned char *)(result + 34)  = 0;
  *(unsigned char *)(result + 35)  = 8;
  *(void *)(result + 36)  = a6;
  *(unsigned char *)(result + 44)  = 0;
  *(unsigned char *)(result + 45)  = 8;
  *(void *)(result + 46)  = a7;
  *(unsigned char *)(result + 54)  = 0;
  *(unsigned char *)(result + 55)  = 8;
  *(void *)(result + 56)  = a8;
  return result;
}

uint64_t __os_log_helper_16_2_2_4_0_8_32(uint64_t result, int a2, uint64_t a3)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 32;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  return result;
}

void AABC::RampDoneCallback(AABC *this)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  double v11 = this;
  *((unsigned char *)this + 628)  = 0;
  *((float *)this + 155)  = DisplayGetVirtualBrightness(*((float **)this + 51));
  v10[1]  = *((_DWORD *)this + 155);
  v10[0]  = 1;
  DisplayUpdateAAPState(*((void *)this + 51), (uint64_t)v10, 1, 0);
  AABC::UpdateALSState((CFDictionaryRef *)this, 8);
  if (*((_DWORD *)this + 128) && *((_DWORD *)this + 127))
  {
    float DeviceBrightness = DisplayGetDeviceBrightness(*((void *)this + 51));
    if (_logHandle)
    {
      float v4 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      float v4 = inited;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_2_3_8_32_8_0_8_0((uint64_t)v13, (uint64_t)"ALS", COERCE__INT64(DeviceBrightness), COERCE__INT64(*((float *)this + 155)));
      _os_log_impl(&dword_1BA438000, v4, OS_LOG_TYPE_DEFAULT, "[BRT update: %s]: End Ramp: L_device  = %0.4f L_current  = %0.4f", v13, 0x20u);
    }
  }
  else
  {
    if (_logHandle)
    {
      uint64_t v2 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v1 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v1 = init_default_corebrightness_log();
      }
      uint64_t v2 = v1;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v12, COERCE__INT64(*((float *)this + 155)));
      _os_log_debug_impl(&dword_1BA438000, v2, OS_LOG_TYPE_DEBUG, "End Ramp: _L_current  = %0.4f", v12, 0xCu);
    }
  }
  if (*((_DWORD *)this + 717) == 2)
  {
    *((_DWORD *)this + 717)  = 1;
    float v8 = (objc_object *)[objc_alloc(NSNumber) initWithInt:(int)(float)(*((float *)this + 155) * 65536.0)];
    AABC::setAlwaysOnProperty((id *)this, &cfstr_Currentbrightn.isa, v8);
    id v7 = (id)[objc_alloc(NSNumber) initWithInt:*((unsigned int *)this + 717)];
    CFTypeRef property = (objc_object *)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v7, @"AOTState", 0);
    AABC::setAlwaysOnProperty((id *)this, &cfstr_Aotstate.isa, property);
    IOHIDServiceClientSetProperty(*((IOHIDServiceClientRef *)this + 41), @"AOTState", property);
  }
  else if (*((_DWORD *)this + 717) == 3)
  {
    AABC::UpdateState((uint64_t)this, 2);
    AABC::BeginFastRampMode((CFAbsoluteTime *)this, *((float *)this + 853), 0.2);
    *((_DWORD *)this + 717)  = 0;
  }
}

uint64_t __os_log_helper_16_2_6_4_0_8_0_8_32_8_32_8_0_4_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 32;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 32;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 0;
  *(unsigned char *)(result + 49)  = 4;
  *(_DWORD *)(result + 50)  = a7;
  return result;
}

uint64_t __os_log_helper_16_2_6_4_0_4_0_8_32_8_0_8_0_8_0(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 4;
  *(_DWORD *)(result + 10)  = a3;
  *(unsigned char *)(result + 14)  = 32;
  *(unsigned char *)(result + 15)  = 8;
  *(void *)(result + 16)  = a4;
  *(unsigned char *)(result + 24)  = 0;
  *(unsigned char *)(result + 25)  = 8;
  *(void *)(result + 26)  = a5;
  *(unsigned char *)(result + 34)  = 0;
  *(unsigned char *)(result + 35)  = 8;
  *(void *)(result + 36)  = a6;
  *(unsigned char *)(result + 44)  = 0;
  *(unsigned char *)(result + 45)  = 8;
  *(void *)(result + 46)  = a7;
  return result;
}

uint64_t __os_log_helper_16_2_6_4_0_8_0_8_0_8_0_8_0_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 8;
  *(void *)(result + 40)  = a6;
  *(unsigned char *)(result + 48)  = 32;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  return result;
}

uint64_t __os_log_helper_16_2_4_4_0_8_32_8_0_8_0(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 32;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  return result;
}

uint64_t __os_log_helper_16_2_3_4_0_8_32_8_32(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 32;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 32;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

void AABC::UpdateALSStateFunction(__IOHIDServiceClient *a1, AABC::ALS *a2, uint64_t *a3)
{
  if (*(_DWORD *)(*a3 + 648)) {
    AABC::UpdateALSStateFunctionInternalAutoRate(*a3, a1, (uint64_t)a2, (int *)a3);
  }
  else {
    AABC::UpdateALSStateFunctionInternalNoAutoRate(*a3, a1, a2, (float *)a3);
  }
}

void AABC::UpdateALSStateFunctionInternalAutoRate(uint64_t a1, __IOHIDServiceClient *a2, uint64_t a3, int *a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v33 = a1;
  IOHIDServiceClientRef v32 = a2;
  uint64_t v31 = a3;
  uint64_t v30 = a4;
  if (a4 && *(void *)v30 && *(_DWORD *)(*(void *)v30 + 372))
  {
    os_log_t v29 = 0;
    if (_logHandle)
    {
      uint64_t v14 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v14 = inited;
    }
    os_log_t v29 = v14;
    os_log_type_t v28 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_4_0_4_0_4_0((uint64_t)v38, 16, v30[12], *(_DWORD *)(a1 + 488));
      _os_log_debug_impl(&dword_1BA438000, v29, v28, "[%x]: function=%x _displayState=%d", v38, 0x14u);
    }
    CFNumberRef v27 = 0;
    if ((v30[12] & 1) != 0 && *(_DWORD *)(a1 + 644) != 1)
    {
      *(_DWORD *)(a1 + 644)  = 1;
      CFNumberRef v26 = 0;
      CFNumberRef v26 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(a1 + 644));
      if (v26)
      {
        IOHIDServiceClientSetProperty(v32, @"IOHIDALSContinuousMode", v26);
        CFRelease(v26);
      }
    }
    if ((v30[12] & 4) != 0)
    {
      CFNumberRef v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, v30 + 4);
      if (v27)
      {
        os_log_t v25 = 0;
        if (_logHandle)
        {
          uint64_t v12 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v11 = init_default_corebrightness_log();
          }
          uint64_t v12 = v11;
        }
        os_log_t v25 = v12;
        os_log_type_t v24 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v37, 16, v30[4]);
          _os_log_debug_impl(&dword_1BA438000, v25, v24, "[%x]: setting \"IOHIDALSTestMode\" %d", v37, 0xEu);
        }
        IOHIDServiceClientSetProperty(v32, @"IOHIDALSTestMode", v27);
        CFRelease(v27);
      }
    }
    if ((v30[12] & 0x10) != 0)
    {
      int valuePtr = 0;
      int valuePtr = *(_DWORD *)(a1 + 668);
      CFNumberRef v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
      if (v27)
      {
        IOHIDServiceClientSetProperty(v32, @"ALSIntegrationMode", v27);
        CFRelease(v27);
      }
      if (*(_DWORD *)(a1 + 668) != *(_DWORD *)(a1 + 664))
      {
        *(_DWORD *)(a1 + 664)  = *(_DWORD *)(a1 + 668);
        float v22 = 0.0;
        float v21 = 0.0;
        switch(*(_DWORD *)(a1 + 668))
        {
          case 3:
            float v22 = *(float *)(a1 + 652);
            float v21 = *(float *)(v31 + 48);
            break;
          case 2:
            float v22 = *(float *)(a1 + 656);
            float v21 = *(float *)(v31 + 44);
            break;
          case 1:
            float v22 = *(float *)(a1 + 660);
            float v21 = *(float *)(v31 + 40);
            break;
          default:
            if (*(_DWORD *)(a1 + 668))
            {
              os_log_t v20 = 0;
              if (_logHandle)
              {
                BOOL v10 = _logHandle;
              }
              else
              {
                if (_COREBRIGHTNESS_LOG_DEFAULT) {
                  uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
                }
                else {
                  uint64_t v9 = init_default_corebrightness_log();
                }
                BOOL v10 = v9;
              }
              os_log_t v20 = v10;
              os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
              if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
              {
                __os_log_helper_16_0_1_4_0((uint64_t)v36, 1);
                _os_log_debug_impl(&dword_1BA438000, v20, v19, "[%x]: INVALID Integration mode. Behaviour undefined!", v36, 8u);
              }
              *(_DWORD *)(v31 + 80)  = 0;
              *(_DWORD *)(a1 + 3960)  = 1;
            }
            else
            {
              *(_DWORD *)(a1 + 600)  = 0;
              *(float *)(a1 + 544)  = -1.0;
              *(float *)(a1 + 548)  = -1.0;
              *(float *)(a1 + 540)  = -1.0;
              *(_DWORD *)(a1 + 556)  = 0;
              *(float *)(a1 + 552)  = -1.0;
              AABC::_UpdateSemanticAmbientLightLevel(a1, 0);
              *(_DWORD *)(v31 + 156)  = 0;
              *(_DWORD *)(a1 + 624)  = 0;
            }
            break;
        }
        if (v22 <= 0.0)
        {
          *(_DWORD *)(v31 + 80)  = 0;
          *(_DWORD *)(a1 + 3960)  = v21 > 0.0;
          *(float *)(a1 + 632)  = v21;
          *(_DWORD *)(a1 + 3968)  = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 3960)  = (float)(7.0 / v22);
          *(_DWORD *)(v31 + 80)  = (float)(*(float *)(a1 + 3444) / v22);
          *(float *)(a1 + 632)  = v22;
          *(_DWORD *)(a1 + 3968)  = (int)(4.0 / v22);
        }
        if (*(void *)(a1 + 3976))
        {
          uint64_t v8 = *(void *)(a1 + 3976);
          if (v8) {
            MEMORY[0x1BA9EC4A0](v8, 0x1000C4052888210);
          }
          *(void *)(a1 + 3976)  = 0;
        }
        *(_DWORD *)(a1 + 3952)  = 0;
        *(_DWORD *)(a1 + 3956)  = 0;
        if (*(_DWORD *)(a1 + 3960))
        {
          is_mul_ok(*(unsigned int *)(a1 + 3960), 4uLL);
          operator new[]();
        }
        std::vector<float>::resize((uint64_t *)(v31 + 88), 0);
        *(_DWORD *)(v31 + 72)  = 0;
        *(_DWORD *)(v31 + 76)  = 0;
        std::vector<float>::resize((uint64_t *)(v31 + 88), *(unsigned int *)(v31 + 80));
        *(_DWORD *)(a1 + 3964)  = *(_DWORD *)(a1 + 3968);
        os_log_t v18 = 0;
        if (_logHandle)
        {
          id v7 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v6 = init_default_corebrightness_log();
          }
          id v7 = v6;
        }
        os_log_t v18 = v7;
        os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_5_4_0_4_0_4_0_4_0_4_0((uint64_t)v35, 16, *(_DWORD *)(v31 + 4), *(_DWORD *)(a1 + 668), *(_DWORD *)(a1 + 3960), *(_DWORD *)(v31 + 80));
          _os_log_debug_impl(&dword_1BA438000, v18, v17, "[%x]: als->orientation=%d - _als.integrationMode=%d, _Lhistory_max=%u als->_Ehistory_max=%u", v35, 0x20u);
        }
      }
    }
    if ((v30[12] & 8) != 0)
    {
      int v16 = 0;
      int v16 = (int)(float)(*(float *)(a1 + 620) * 65536.0);
      CFNumberRef v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v16);
      if (v27)
      {
        if (_logHandle)
        {
          float v5 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v4 = init_default_corebrightness_log();
          }
          float v5 = v4;
        }
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v34, 16, v30[3]);
          _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "[%x]: setting kIOHIDBacklightLevel %d", v34, 0xEu);
        }
        IOHIDServiceClientSetProperty(v32, @"IOHIDBacklightLevel", v27);
        CFRelease(v27);
      }
    }
  }
  else if (v30 && *(void *)v30 && !*(_DWORD *)(*(void *)v30 + 372) && !*(_DWORD *)(a1 + 668))
  {
    *(_DWORD *)(a1 + 3960)  = 0;
    *(_DWORD *)(a1 + 600)  = 0;
    *(float *)(a1 + 544)  = -1.0;
    *(float *)(a1 + 548)  = -1.0;
    *(float *)(a1 + 540)  = -1.0;
    *(_DWORD *)(a1 + 556)  = 0;
    *(float *)(a1 + 552)  = -1.0;
    *(_DWORD *)(a1 + 624)  = 0;
    *(_DWORD *)(a1 + 3968)  = 0;
  }
}

void AABC::UpdateALSStateFunctionInternalNoAutoRate(uint64_t a1, __IOHIDServiceClient *a2, AABC::ALS *a3, float *a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v35 = a1;
  int v34 = a2;
  uint64_t v33 = a3;
  IOHIDServiceClientRef v32 = a4;
  if (a4 && *(void *)v32 && *(_DWORD *)(*(void *)v32 + 372))
  {
    os_log_t v31 = 0;
    if (_logHandle)
    {
      uint64_t v14 = _logHandle;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t inited = init_default_corebrightness_log();
      }
      uint64_t v14 = inited;
    }
    os_log_t v31 = v14;
    os_log_type_t v30 = OS_LOG_TYPE_DEBUG;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      __os_log_helper_16_0_3_4_0_4_0_4_0((uint64_t)v40, 16, *((_DWORD *)v32 + 12), *(_DWORD *)(a1 + 488));
      _os_log_debug_impl(&dword_1BA438000, v31, v30, "[%x]: function=%x _displayState=%d", v40, 0x14u);
    }
    if (*(unsigned char *)(a1 + 445)) {
      AABC::lazyLoadIntegrationTimes((AABC *)a1, v34, v33);
    }
    CFNumberRef v29 = 0;
    if (v32[12])
    {
      if (*(_DWORD *)(a1 + 644) != 1)
      {
        *(_DWORD *)(a1 + 644)  = 1;
        CFNumberRef v28 = 0;
        CFNumberRef v28 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, (const void *)(a1 + 644));
        if (v28)
        {
          IOHIDServiceClientSetProperty(v34, @"IOHIDALSContinuousMode", v28);
          CFRelease(v28);
        }
      }
      if (v32[2] != *((float *)v33 + 38))
      {
        *((float *)v33 + 38)  = v32[2];
        CFNumberRef v27 = "";
        int v26 = 0;
        if (*((float *)v33 + 38) == *((float *)v33 + 10))
        {
          CFNumberRef v27 = "(super-fast mode)";
        }
        else if (*((float *)v33 + 38) == *((float *)v33 + 11))
        {
          CFNumberRef v27 = "(fast mode)";
          int v26 = 2;
        }
        else if (*((float *)v33 + 38) == *((float *)v33 + 12))
        {
          CFNumberRef v27 = "(slow mode)";
        }
        os_log_t v25 = 0;
        if (_logHandle)
        {
          uint64_t v12 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v11 = init_default_corebrightness_log();
          }
          uint64_t v12 = v11;
        }
        os_log_t v25 = v12;
        os_log_type_t v24 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_2_2_8_0_8_34((uint64_t)v39, COERCE__INT64(*((float *)v33 + 38)), (uint64_t)v27);
          _os_log_impl(&dword_1BA438000, v25, v24, "setting report interval: %fs %{public}s", v39, 0x16u);
        }
        unsigned int valuePtr = 0;
        unsigned int valuePtr = (float)(*((float *)v33 + 38) * 1000000.0);
        CFNumberRef v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
        if (v29)
        {
          IOHIDServiceClientSetProperty(v34, @"ReportInterval", v29);
          CFRelease(v29);
        }
        if (*((float *)v33 + 38) <= 0.0)
        {
          *(_DWORD *)(a1 + 3960)  = 0;
          *((_DWORD *)v33 + 20)  = 0;
          *(_DWORD *)(a1 + 600)  = 0;
          *(float *)(a1 + 544)  = -1.0;
          *(float *)(a1 + 548)  = -1.0;
          *(float *)(a1 + 540)  = -1.0;
          *(_DWORD *)(a1 + 556)  = 0;
          *(float *)(a1 + 552)  = -1.0;
          AABC::_UpdateSemanticAmbientLightLevel(a1, 0);
          *((_DWORD *)v33 + 39)  = 0;
          *(_DWORD *)(a1 + 624)  = 0;
          *(_DWORD *)(a1 + 3968)  = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 3960)  = (float)(7.0 / *(float *)(a1 + 632));
          if (v26 <= 0) {
            *((_DWORD *)v33 + 20)  = (float)(*(float *)(a1 + 3444) / *(float *)(a1 + 632));
          }
          else {
            *((_DWORD *)v33 + 20)  = v26;
          }
          *(_DWORD *)(a1 + 3968)  = (int)(4.0 / *(float *)(a1 + 632));
        }
        os_log_t v22 = 0;
        if (_logHandle)
        {
          BOOL v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v9 = init_default_corebrightness_log();
          }
          BOOL v10 = v9;
        }
        os_log_t v22 = v10;
        os_log_type_t v21 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_4_4_0_8_0_4_0_4_0((uint64_t)v38, 16, COERCE__INT64(*((float *)v33 + 38)), *(_DWORD *)(a1 + 3960), *((_DWORD *)v33 + 20));
          _os_log_debug_impl(&dword_1BA438000, v22, v21, "[%x]: als->_alsCurrentInterval=%f, _Lhistory_max=%u als->_Ehistory_max=%u", v38, 0x1Eu);
        }
        if (*(void *)(a1 + 3976))
        {
          uint64_t v8 = *(void *)(a1 + 3976);
          if (v8) {
            MEMORY[0x1BA9EC4A0](v8, 0x1000C4052888210);
          }
          *(void *)(a1 + 3976)  = 0;
        }
        std::vector<float>::resize((uint64_t *)v33 + 11, 0);
        *((_DWORD *)v33 + 18)  = 0;
        *((_DWORD *)v33 + 19)  = 0;
        std::vector<float>::resize((uint64_t *)v33 + 11, *((unsigned int *)v33 + 20));
        *(_DWORD *)(a1 + 3952)  = 0;
        *(_DWORD *)(a1 + 3956)  = 0;
        if (*(_DWORD *)(a1 + 3960))
        {
          is_mul_ok(*(unsigned int *)(a1 + 3960), 4uLL);
          operator new[]();
        }
        *(_DWORD *)(a1 + 3964)  = *(_DWORD *)(a1 + 3968);
      }
    }
    if ((v32[12] & 4) != 0)
    {
      CFNumberRef v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, v32 + 4);
      if (v29)
      {
        os_log_t oslog = 0;
        if (_logHandle)
        {
          id v7 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v6 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v6 = init_default_corebrightness_log();
          }
          id v7 = v6;
        }
        os_log_t oslog = v7;
        os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v37, 16, *((_DWORD *)v32 + 4));
          _os_log_debug_impl(&dword_1BA438000, oslog, v19, "[%x]: setting \"IOHIDALSTestMode\" %d", v37, 0xEu);
        }
        IOHIDServiceClientSetProperty(v34, @"IOHIDALSTestMode", v29);
        CFRelease(v29);
      }
      if (*((_DWORD *)v32 + 4))
      {
        if (*(float *)(*(void *)v32 + 492) > 0.0 && *((float *)v33 + 38) < 0.05)
        {
          *((_DWORD *)v33 + 38)  = 1045220557;
          unsigned int v18 = 0;
          unsigned int v18 = (float)(*((float *)v33 + 38) * 1000000.0);
          CFNumberRef v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v18);
          if (v29)
          {
            IOHIDServiceClientSetProperty(v34, @"ReportInterval", v29);
            CFRelease(v29);
          }
        }
      }
    }
    if ((v32[12] & 0x10) != 0)
    {
      int v17 = 0;
      int v17 = *(_DWORD *)(a1 + 668);
      CFNumberRef v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &v17);
      if (v29)
      {
        IOHIDServiceClientSetProperty(v34, @"ALSIntegrationMode", v29);
        CFRelease(v29);
      }
    }
    if ((v32[12] & 8) != 0)
    {
      int v16 = 0;
      int v16 = (int)(float)(*(float *)(a1 + 620) * 65536.0);
      CFNumberRef v29 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberIntType, &v16);
      if (v29)
      {
        if (_logHandle)
        {
          float v5 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v4 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v4 = init_default_corebrightness_log();
          }
          float v5 = v4;
        }
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          __os_log_helper_16_0_2_4_0_4_0((uint64_t)v36, 16, *((_DWORD *)v32 + 3));
          _os_log_debug_impl(&dword_1BA438000, v5, OS_LOG_TYPE_DEBUG, "[%x]: setting kIOHIDBacklightLevel %d", v36, 0xEu);
        }
        IOHIDServiceClientSetProperty(v34, @"IOHIDBacklightLevel", v29);
        CFRelease(v29);
      }
    }
  }
  else if (v32 && *(void *)v32 && !*(_DWORD *)(*(void *)v32 + 372) && v32[2] <= 0.0)
  {
    *(_DWORD *)(a1 + 3960)  = 0;
    *(_DWORD *)(a1 + 600)  = 0;
    *(float *)(a1 + 544)  = -1.0;
    *(float *)(a1 + 548)  = -1.0;
    *(float *)(a1 + 540)  = -1.0;
    *(_DWORD *)(a1 + 556)  = 0;
    *(float *)(a1 + 552)  = -1.0;
    *(_DWORD *)(a1 + 624)  = 0;
    *(_DWORD *)(a1 + 3968)  = 0;
  }
}

uint64_t __os_log_helper_16_0_5_4_0_4_0_4_0_4_0_4_0(uint64_t result, int a2, int a3, int a4, int a5, int a6)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 4;
  *(_DWORD *)(result + 10)  = a3;
  *(unsigned char *)(result + 14)  = 0;
  *(unsigned char *)(result + 15)  = 4;
  *(_DWORD *)(result + 16)  = a4;
  *(unsigned char *)(result + 20)  = 0;
  *(unsigned char *)(result + 21)  = 4;
  *(_DWORD *)(result + 22)  = a5;
  *(unsigned char *)(result + 26)  = 0;
  *(unsigned char *)(result + 27)  = 4;
  *(_DWORD *)(result + 28)  = a6;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_0_8_34(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)uint64_t result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 34;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  return result;
}

uint64_t __os_log_helper_16_0_4_4_0_8_0_4_0_4_0(uint64_t result, int a2, uint64_t a3, int a4, int a5)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 4;
  *(_DWORD *)(result + 20)  = a4;
  *(unsigned char *)(result + 24)  = 0;
  *(unsigned char *)(result + 25)  = 4;
  *(_DWORD *)(result + 26)  = a5;
  return result;
}

void *AABC::SetUpdateStrategy(AABC *this, AAB::UpdateCurveStrategy *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (_logHandle)
  {
    uint64_t v8 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    uint64_t v8 = inited;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = (*(uint64_t (**)(void))(**((void **)this + 8) + 104))(*((void *)this + 8));
    int v5 = (*(uint64_t (**)(AAB::UpdateCurveStrategy *))(*(void *)a2 + 104))(a2);
    int v6 = (*(uint64_t (**)(void))(**((void **)this + 8) + 112))(*((void *)this + 8));
    int v2 = (*(uint64_t (**)(AAB::UpdateCurveStrategy *))(*(void *)a2 + 112))(a2);
    __os_log_helper_16_0_4_4_0_4_0_4_0_4_0((uint64_t)v11, v4, v5, v6, v2);
    _os_log_impl(&dword_1BA438000, v8, OS_LOG_TYPE_DEFAULT, "Change curve update strategies! Curve type: %d => %d, Alternative curve type: %d => %d", v11, 0x1Au);
  }
  AAB::SetUpdateStrategy(this, a2);
  AABC::AlignCurveTypeWithStrategy((uint64_t)this, (_DWORD *)this + 262, (_DWORD *)this + 750);
  return AABC::AlignCurveTypeWithStrategy((uint64_t)this, (_DWORD *)this + 724, (_DWORD *)this + 776);
}

uint64_t AABC::ProcessCPMSBudget(uint64_t a1, void *a2)
{
  uint64_t v16 = a1;
  id v15 = a2;
  CPMSAPLTable  = 0;
  CPMSAPLTable  = DisplayGetCPMSAPLTable(*(void *)(a1 + 408));
  id v2 = v15;
  uint64_t v3 = *(NSObject **)(a1 + 4072);
  uint64_t block = MEMORY[0x1E4F143A8];
  int v7 = -1073741824;
  int v8 = 0;
  uint64_t v9 = ___ZN4AABC17ProcessCPMSBudgetEP12NSDictionaryIP8NSStringP8NSNumberE_block_invoke;
  BOOL v10 = &unk_1E6219100;
  uint64_t v12 = a1;
  id v11 = v15;
  uint64_t v13 = CPMSAPLTable;
  dispatch_async(v3, &block);
  return objc_msgSend(*(id *)(a1 + 4128), "acknowledgePowerBudget:forClientId:error:", v15, objc_msgSend(*(id *)(a1 + 4120), "clientId"), 0);
}

uint64_t __os_log_helper_16_0_3_4_0_8_0_4_0(uint64_t result, int a2, uint64_t a3, int a4)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 4;
  *(_DWORD *)(result + 20)  = a4;
  return result;
}

uint64_t __os_log_helper_16_0_6_4_0_4_0_4_0_4_0_4_0_4_0(uint64_t result, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(unsigned char *)uint64_t result = 0;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 4;
  *(_DWORD *)(result + 10)  = a3;
  *(unsigned char *)(result + 14)  = 0;
  *(unsigned char *)(result + 15)  = 4;
  *(_DWORD *)(result + 16)  = a4;
  *(unsigned char *)(result + 20)  = 0;
  *(unsigned char *)(result + 21)  = 4;
  *(_DWORD *)(result + 22)  = a5;
  *(unsigned char *)(result + 26)  = 0;
  *(unsigned char *)(result + 27)  = 4;
  *(_DWORD *)(result + 28)  = a6;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 4;
  *(_DWORD *)(result + 34)  = a7;
  return result;
}

uint64_t ___ZN4AABC20InitializeCPMSModuleEv_block_invoke(uint64_t a1, void *a2)
{
  return AABC::ProcessCPMSBudget(*(void *)(a1 + 32), a2);
}

uint64_t ___ZN4AABC20InitializeCPMSModuleEv_block_invoke_2()
{
  v4[1]  = *MEMORY[0x1E4F143B8];
  id v2 = (id)[objc_alloc(NSNumber) initWithInt:1];
  uint64_t v3 = *MEMORY[0x1E4F566B8];
  v4[0]  = v2;
  uint64_t v1 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v4 forKeys:&v3 count:1];

  return v1;
}

void ___ZN4AABC17ProcessCPMSBudgetEP12NSDictionaryIP8NSStringP8NSNumberE_block_invoke(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v44 = a1;
  uint64_t v43 = a1;
  os_log_type_t v24 = *(AABC **)(a1 + 40);
  float v41 = -1.0;
  float v40 = -1.0;
  float v42 = -1.0;
  id v39 = 0;
  if ([*(id *)(a1 + 32) valueForKey:*MEMORY[0x1E4F566B8]])
  {
    HDRunsigned int APLColumn = 0;
    HDRunsigned int APLColumn = DisplayGetHDRAPLColumn(*((void *)v24 + 51));
    id v39 = (id)[*(id *)(a1 + 32) valueForKey:*MEMORY[0x1E4F566B8]];
    float v37 = 0.0;
    uint64_t v22 = *((void *)v24 + 51);
    [v39 floatValue];
    float v37 = DisplayPowerToPhysicalBrightness(v22, HDRAPLColumn, v1);
    char v36 = 0;
    BOOL v21 = *((float *)v24 + 1026) == -1.0
       || (float)((float)(vabds_f32(v37, *((float *)v24 + 1026)) / *((float *)v24 + 1026)) * 100.0) > *((float *)v24 + 1029);
    char v36 = v21;
    if (v37 > *(float *)(*(void *)(a1 + 48)
                        + 212
                        + 4 * (*(_DWORD *)(*(void *)(a1 + 48) + 4) - 1))
             * 0.95)
      char v36 = 1;
    if ((v36 & 1) != 0
      || v37 == *(float *)(*(void *)(a1 + 48)
                         + 212
                         + 4 * (*(_DWORD *)(*(void *)(a1 + 48) + 4) - 1)))
    {
      float v42 = v37;
      *((float *)v24 + 1026)  = v37;
      os_log_t v35 = 0;
      if (_logHandle)
      {
        os_log_t v20 = _logHandle;
      }
      else
      {
        uint64_t v19 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
        os_log_t v20 = v19;
      }
      os_log_t v35 = v20;
      os_log_type_t v34 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        [v39 floatValue];
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v47, COERCE__INT64(v2), COERCE__INT64(v42));
        _os_log_impl(&dword_1BA438000, v35, v34, "Received an updated CPMS Budget for HDR:%f watts converted to %f nits", v47, 0x16u);
      }
    }
  }
  if ([*(id *)(a1 + 32) valueForKey:*MEMORY[0x1E4F56698]])
  {
    unsigned int APLColumnOrDefault = 0;
    unsigned int APLColumnOrDefault = DisplayGetAPLColumnOrDefault(*((void *)v24 + 51), 0x64u);
    AABC::CancelRamp(v24);
    id v39 = (id)[*(id *)(a1 + 32) valueForKey:*MEMORY[0x1E4F56698]];
    float v32 = 0.0;
    uint64_t v18 = *((void *)v24 + 51);
    [v39 floatValue];
    float v32 = DisplayPowerToPhysicalBrightness(v18, APLColumnOrDefault, v3);
    char v31 = 0;
    BOOL v17 = *((float *)v24 + 1024) == -1.0
       || (float)((float)(vabds_f32(v32, *((float *)v24 + 1024)) / *((float *)v24 + 1024)) * 100.0) > *((float *)v24 + 1027);
    char v31 = v17;
    if (v32 > *(float *)(*(void *)(a1 + 48)
                        + 212
                        + 4 * (*(_DWORD *)(*(void *)(a1 + 48) + 4) - 1))
             * 0.95)
      char v31 = 1;
    if ((v31 & 1) != 0
      || v32 == *(float *)(*(void *)(a1 + 48)
                         + 212
                         + 4 * (*(_DWORD *)(*(void *)(a1 + 48) + 4) - 1)))
    {
      float v41 = v32;
      *((float *)v24 + 1024)  = v32;
      if (v41 >= *((float *)v24 + 182))
      {
        *((_DWORD *)v24 + 1020)  = *((_DWORD *)v24 + 182);
        *((unsigned char *)v24 + 4084)  = 0;
      }
      else
      {
        *((float *)v24 + 1020)  = v41;
        *((unsigned char *)v24 + 4084)  = 1;
        *((_DWORD *)v24 + 1022)  = *((_DWORD *)v24 + 136);
        os_log_type_t v30 = 0;
        if (_logHandle)
        {
          uint64_t v16 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t inited = init_default_corebrightness_log();
          }
          uint64_t v16 = inited;
        }
        os_log_type_t v30 = v16;
        char v29 = 1;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          uint64_t v13 = v30;
          os_log_type_t v14 = v29;
          __os_log_helper_16_0_0(v28);
          _os_log_impl(&dword_1BA438000, v13, v14, "Enabling weak cap\n", v28, 2u);
        }
      }
      *((unsigned char *)v24 + 4092)  = 1;
      if (_logHandle)
      {
        uint64_t v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v11 = init_default_corebrightness_log();
        }
        uint64_t v12 = v11;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        [v39 floatValue];
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v46, COERCE__INT64(v4), COERCE__INT64(v41));
        _os_log_impl(&dword_1BA438000, v12, OS_LOG_TYPE_INFO, "Received an updated CPMS Budget for UPO:%f watts converted to %f nits", v46, 0x16u);
      }
    }
  }
  if ([*(id *)(a1 + 32) valueForKey:*MEMORY[0x1E4F566C8]])
  {
    unsigned int v27 = DisplayGetAPLColumnOrDefault(*((void *)v24 + 51), 0x64u);
    id v39 = (id)[*(id *)(a1 + 32) valueForKey:*MEMORY[0x1E4F566C8]];
    uint64_t v10 = *((void *)v24 + 51);
    [v39 floatValue];
    float v26 = DisplayPowerToPhysicalBrightness(v10, v27, v5);
    BOOL v9 = *((float *)v24 + 1025) == -1.0
      || (float)((float)(vabds_f32(v26, *((float *)v24 + 1025)) / *((float *)v24 + 1025)) * 100.0) > *((float *)v24 + 1028);
    char v25 = v9;
    if (v26 > *(float *)(*(void *)(a1 + 48)
                        + 212
                        + 4 * (*(_DWORD *)(*(void *)(a1 + 48) + 4) - 1))
             * 0.95)
      char v25 = 1;
    if ((v25 & 1) != 0
      || v26 == *(float *)(*(void *)(a1 + 48)
                         + 212
                         + 4 * (*(_DWORD *)(*(void *)(a1 + 48) + 4) - 1)))
    {
      float v40 = v26;
      *((float *)v24 + 1025)  = v26;
      if (_logHandle)
      {
        int v8 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v7 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v7 = init_default_corebrightness_log();
        }
        int v8 = v7;
      }
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        [v39 floatValue];
        __os_log_helper_16_0_2_8_0_8_0((uint64_t)v45, COERCE__INT64(v6), COERCE__INT64(v40));
        _os_log_impl(&dword_1BA438000, v8, OS_LOG_TYPE_INFO, "Received an updated CPMS Budget for CLTM:%f watts converted to %f nits", v45, 0x16u);
      }
    }
  }
  DisplayUpdateCPMSBudget(*((void *)v24 + 51), (uint64_t)&v40);
}

void AABC::handleAODStateUpdate(uint64_t a1, uint64_t a2, void *a3, float a4)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v58 = a1;
  uint64_t v57 = a2;
  float v56 = a4;
  id v55 = a3;
  os_log_t v54 = 0;
  if (_logHandle)
  {
    os_log_type_t v24 = _logHandle;
  }
  else
  {
    if (_COREBRIGHTNESS_LOG_DEFAULT) {
      uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
    }
    else {
      uint64_t inited = init_default_corebrightness_log();
    }
    os_log_type_t v24 = inited;
  }
  os_log_t v54 = v24;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    __os_log_helper_16_0_2_8_0_8_0((uint64_t)v65, v57, COERCE__INT64(v56));
    _os_log_impl(&dword_1BA438000, v54, type, "[AOD state] Update: %lu, transition time %f", v65, 0x16u);
  }
  switch(v57)
  {
    case 2:
      *(_DWORD *)(a1 + 3948)  = 0;
      if (*(_DWORD *)(a1 + 676)) {
        AABC::CancelFastRampMode((CFAbsoluteTime *)a1);
      }
      AABC::CancelRamp((AABC *)a1);
      v52[0]  = std::bitset<3ul>::operator[][abi:ne180100](a1 + 304, 0);
      v52[1]  = v4;
      std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v52, 1);
      AABC::evaluateAABRearConditions((id *)a1);
      if (*(_DWORD *)(a1 + 4024) == 1)
      {
        if (!*(void *)(a1 + 4016)) {
          __assert_rtn("handleAODStateUpdate", "AABC.mm", 10688, "_plt_logic");
        }
        uint64_t v22 = *(void *)(a1 + 4016);
        if (v22) {
          (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
        }
        operator new();
      }
      break;
    case 3:
      *(float *)(a1 + 620)  = DisplayGetLogicalBrightness(*(void *)(a1 + 408));
      PhysicalBrightness  = 0.0;
      PhysicalBrightness  = DisplayGetPhysicalBrightness(*(void *)(a1 + 408));
      float v50 = 0.0;
      float v50 = AABC::IlluminanceToLuminance((AABC *)a1, *(float *)(a1 + 556), (CustomCurve *)(a1 + 2540));
      float v49 = PhysicalBrightness;
      if (v55)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v48 = (id)[v55 objectForKey:@"NitsPhysical"];
          if (v48)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              [v48 floatValue];
              float v49 = v5;
            }
          }
        }
      }
      if (v50 < v49)
      {
        [+[CBAODState sharedInstance] AODTransitionTargetAlgoOptimised_dimmingThreshold];
        float v47 = v6;
        float v46 = 0.0;
        float v46 = DisplayLuminanceToPerceptualLuminance(*(void *)(a1 + 408), v49);
        float v45 = 0.0;
        float v45 = DisplayLuminanceToPerceptualLuminance(*(void *)(a1 + 408), v50);
        if (vabds_f32(v46, v45) > v47)
        {
          float v44 = fmaxf(v46 - v47, 0.0);
          float v43 = 0.0;
          float v43 = DisplayPerceptualLuminanceToLuminance(*(void *)(a1 + 408), v44);
          os_log_t oslog = 0;
          if (_logHandle)
          {
            BOOL v21 = _logHandle;
          }
          else
          {
            if (_COREBRIGHTNESS_LOG_DEFAULT) {
              uint64_t v20 = _COREBRIGHTNESS_LOG_DEFAULT;
            }
            else {
              uint64_t v20 = init_default_corebrightness_log();
            }
            BOOL v21 = v20;
          }
          os_log_t oslog = v21;
          os_log_type_t v41 = OS_LOG_TYPE_INFO;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
          {
            __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_8_0_8_0((uint64_t)v64, COERCE__INT64(v46), COERCE__INT64(v45), COERCE__INT64(v50), COERCE__INT64(v47), COERCE__INT64(v44), COERCE__INT64(v43));
            _os_log_impl(&dword_1BA438000, oslog, v41, "[AOD state][Entering] cP=%f | tP=%f | tNits=%f | thrP=%f | adj_tP=%f | adj_nits=%f", v64, 0x3Eu);
          }
          float v50 = v43;
        }
      }
      float v50 = clamp(v50, *(float *)(a1 + 720), PhysicalBrightness);
      *(float *)(a1 + 624)  = AABC::LuminanceToIlluminance((AABC *)a1, v50, (CustomCurve *)(a1 + 2540));
      *(_DWORD *)(a1 + 2872)  = *(_DWORD *)(a1 + 620);
      *(float *)(a1 + 620)  = v50;
      os_log_t v40 = 0;
      if (_logHandle)
      {
        uint64_t v19 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v18 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v18 = init_default_corebrightness_log();
        }
        uint64_t v19 = v18;
      }
      os_log_t v40 = v19;
      os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_5_8_0_8_0_8_0_8_0_8_0((uint64_t)v63, COERCE__INT64(v50), COERCE__INT64(*(float *)(a1 + 556)), COERCE__INT64(v49), COERCE__INT64(*(float *)(a1 + 544)), COERCE__INT64(*(float *)(a1 + 556)));
        _os_log_impl(&dword_1BA438000, v40, v39, "[AOD state][Entering] Target AOD Nits %f for lux %f (Physical Nits  = %f, Trusted Lux  = %f, Capped Trusted Lux  = %f)", v63, 0x34u);
      }
      os_log_t v38 = 0;
      if (_logHandle)
      {
        BOOL v17 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v16 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v16 = init_default_corebrightness_log();
        }
        BOOL v17 = v16;
      }
      os_log_t v38 = v17;
      os_log_type_t v37 = OS_LOG_TYPE_INFO;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_INFO))
      {
        __os_log_helper_16_0_3_4_0_4_0_4_0((uint64_t)v62, *(_DWORD *)(a1 + 512), *(_DWORD *)(a1 + 508), *(_DWORD *)(a1 + 520));
        _os_log_impl(&dword_1BA438000, v38, v37, "[AOD state][Entering] AB enabled  = %d, active  = %d, do not update curve  = %d", v62, 0x14u);
      }
      if (*(_DWORD *)(a1 + 520)) {
        DisplaySetLogicalBrightnessWithFade(*(void *)(a1 + 408), 12296, (uint64_t)AABC::_RampDoneCallback, a1, v50, v56);
      }
      else {
        AABC::SetBrightness((AABC *)a1, v50, v56, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
      }
      AABC::logAODCurveToPowerLog((AABC *)a1);
      break;
    case 1:
      if (!*(_DWORD *)(a1 + 520))
      {
        float v36 = 0.0;
        float v36 = AABC::IlluminanceToLuminance((AABC *)a1, *(float *)(a1 + 556), (CustomCurve *)(a1 + 2540));
        *(float *)(a1 + 2872)  = DisplayGetLogicalBrightness(*(void *)(a1 + 408));
        *(float *)(a1 + 620)  = v36;
        os_log_t v35 = 0;
        if (_logHandle)
        {
          id v15 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v14 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v14 = init_default_corebrightness_log();
          }
          id v15 = v14;
        }
        os_log_t v35 = v15;
        os_log_type_t v34 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v61, COERCE__INT64(v36), COERCE__INT64(*(float *)(a1 + 556)));
          _os_log_impl(&dword_1BA438000, v35, v34, "[AOD state][On] Perform update - target AOD Nits %f for trusted lux %f", v61, 0x16u);
        }
        AABC::SetBrightness((AABC *)a1, v36, v56, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
        *(float *)(a1 + 616)  = v36;
        *(_DWORD *)(a1 + 624)  = *(_DWORD *)(a1 + 556);
      }
      *(unsigned char *)(a1 + 3320)  = 0;
      break;
    case 4:
      float v33 = 0.0;
      if (*(_DWORD *)(a1 + 4024) == 1)
      {
        if (!*(void *)(a1 + 4016)) {
          __assert_rtn("handleAODStateUpdate", "AABC.mm", 10789, "_plt_logic");
        }
        uint64_t v13 = *(void *)(a1 + 4016);
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
        }
        operator new();
      }
      *(float *)(a1 + 620)  = DisplayGetLogicalBrightness(*(void *)(a1 + 408));
      if (v55)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v32 = (id)[v55 objectForKey:@"NitsPhysical"];
          if (v32)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              [v32 floatValue];
              *(_DWORD *)(a1 + 620)  = v7;
            }
          }
        }
      }
      float v33 = AABC::IlluminanceToLuminance(a1, (float *)(a1 + 1048), *(float *)(a1 + 544), *(float *)(a1 + 556));
      float v33 = clamp(v33, *(float *)(a1 + 620), *(float *)(a1 + 728));
      os_log_t v31 = 0;
      if (_logHandle)
      {
        uint64_t v12 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v11 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v11 = init_default_corebrightness_log();
        }
        uint64_t v12 = v11;
      }
      os_log_t v31 = v12;
      os_log_type_t v30 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_4_8_0_8_0_8_0_8_0((uint64_t)v60, COERCE__INT64(v33), COERCE__INT64(*(float *)(a1 + 556)), COERCE__INT64(*(float *)(a1 + 544)), COERCE__INT64(*(float *)(a1 + 556)));
        _os_log_impl(&dword_1BA438000, v31, v30, "[AOD state][Exiting] Normal mode Nits  = %f for lux %f (Trusted Lux  = %f, Capped Trusted Lux  = %f)", v60, 0x2Au);
      }
      *(float *)(a1 + 616)  = v33;
      AABC::SetBrightness((AABC *)a1, v33, v56, 10, (void (*)(void *))AABC::_RampDoneCallback, a1);
      break;
    case 0:
      if (!*(_DWORD *)(a1 + 520))
      {
        float v29 = 0.0;
        float v29 = AABC::IlluminanceToLuminance(a1, (float *)(a1 + 1048), *(float *)(a1 + 544), *(float *)(a1 + 556));
        os_log_t v28 = 0;
        if (_logHandle)
        {
          uint64_t v10 = _logHandle;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v9 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v9 = init_default_corebrightness_log();
          }
          uint64_t v10 = v9;
        }
        os_log_t v28 = v10;
        os_log_type_t v27 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v59, COERCE__INT64(v29));
          _os_log_impl(&dword_1BA438000, v28, v27, "[AOD state][Off]  Display brightness should be on %f", v59, 0xCu);
        }
        AABC::UpdateState(a1, 2);
        if ((*(unsigned char *)(a1 + 3320) & 1) == 1) {
          AABC::BeginFastRampMode((CFAbsoluteTime *)a1, 4.0, 0.2);
        }
        else {
          AABC::BeginFastRampMode((CFAbsoluteTime *)a1, 30.0, 0.2);
        }
      }
      v26[0]  = std::bitset<3ul>::operator[][abi:ne180100](a1 + 304, 0);
      v26[1]  = v8;
      std::__bit_reference<std::__bitset<1ul,3ul>,true>::operator=[abi:ne180100]((uint64_t)v26, 0);
      AABC::evaluateAABRearConditions((id *)a1);
      break;
  }
  if (*(float *)(a1 + 492) <= 0.0) {
    DisplaySetState(*(void *)(a1 + 408), 0);
  }
  else {
    DisplaySetState(*(void *)(a1 + 408), v57 == 0);
  }
}

void sub_1BA5D319C()
{
  _Unwind_Resume(v0);
}

void AABC::logAODCurveToPowerLog(AABC *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v15 = this;
  memset(__b, 0, sizeof(__b));
  AAB::curveToCustomCurve((uint64_t)this, (uint64_t)this + 1048, (uint64_t)__b);
  memset(&v13, 0, sizeof(v13));
  memcpy(__dst, __b, sizeof(__dst));
  memcpy(&v11, (char *)this + 2540, sizeof(v11));
  AAB::findDarkerCurve((AAB *)__dst, &v11, &v13, v1);
  char v10 = 0;
  if (v13.size == *((_DWORD *)this + 716))
  {
    for (int i = 0; i < v13.size; ++i)
    {
      if (COERCE_INT(v13._E[i] * 1000.0) != COERCE_INT(*((float *)this + i + 676) * 1000.0)
        || COERCE_INT(v13._L[i] * 1000.0) != COERCE_INT(*((float *)this + i + 696) * 1000.0))
      {
        char v10 = 1;
        break;
      }
    }
  }
  else
  {
    char v10 = 1;
  }
  if ((v10 & 1) != 0 && *((void *)this + 44))
  {
    id v8 = 0;
    memcpy(&v7, &v13, sizeof(v7));
    id v8 = (id)dictionaryForCustomCurve(&v7);
    id v6 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v8, @"CurveLevelHigh", 0);
    (*((void (**)(void, __CFString *, id))this + 44))(*((void *)this + 45), @"AODCurveUpdate", v6);
    for (int j = 0; j < v13.size; ++j)
    {
      if (_logHandle)
      {
        float v3 = _logHandle;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        float v3 = inited;
      }
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_0_3_4_0_8_0_8_0((uint64_t)v16, j, COERCE__INT64(v13._E[j]), COERCE__INT64(v13._L[j]));
        _os_log_impl(&dword_1BA438000, v3, OS_LOG_TYPE_DEFAULT, "AOD Darker Curve[%d]  = (%f;%f)", v16, 0x1Cu);
      }
    }
    memcpy((char *)this + 2704, &v13, 0xA4uLL);
  }
}

uint64_t dictionaryForCustomCurve(CustomCurve *a1)
{
  CustomCurve v7 = a1;
  id v15 = a1;
  unint64_t v8 = 0x1E4F1C000uLL;
  id v14 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v13 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (int i = 0; i < v7->size; ++i)
  {
    id v11 = 0;
    unint64_t v6 = 0x1E4F28000uLL;
    id v1 = objc_alloc(NSNumber);
    *(float *)&double v2 = v7->_E[i];
    id v11 = (id)[v1 initWithFloat:v2];
    id v10 = 0;
    id v3 = objc_alloc(NSNumber);
    *(float *)&double v4 = v7->_L[i];
    id v10 = (id)[v3 initWithFloat:v4];
    [v14 addObject:v11];
    [v13 addObject:v10];
  }
  uint64_t v9 = 0;
  uint64_t v9 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9E8]), "initWithObjectsAndKeys:", v14, @"lux", v13, @"nits", 0);

  return v9;
}

uint64_t ___ZN4AABC24sendCrossTalkConfigToDCPEv_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if (result)
  {
    uint64_t result = [a2 unsignedIntValue];
    *(_DWORD *)(*(void *)(a1 + 32) + 4 * a3)  = result;
  }
  return result;
}

uint64_t ___ZN4AABC24sendCrossTalkConfigToDCPEv_block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result = [a2 unsignedIntValue];
  *(_DWORD *)(*(void *)(a1 + 32) + 4 * a3)  = result;
  return result;
}

uint64_t std::all_of[abi:ne180100]<BOOL *,AABC::sendCrossTalkConfigToDCP(void)::$_0>(unsigned char *a1, unsigned char *a2)
{
  while (a1 != a2)
  {
    if ((AABC::sendCrossTalkConfigToDCP(void)::$_0::operator()((uint64_t)&v5, *a1 & 1) & 1) == 0)
    {
      char v6 = 0;
      return v6 & 1;
    }
    ++a1;
  }
  char v6 = 1;
  return v6 & 1;
}

void *std::mutex::mutex[abi:ne180100](void *a1)
{
  return a1;
}

{
  *a1  = 850045863;
  memset(a1 + 1, 0, 0x38uLL);
  return a1;
}

void *std::__bitset<1ul,3ul>::__bitset(void *result, char a2)
{
  *uint64_t result = a2 & 7;
  return result;
}

float AABC::ALS::ALS(AABC::ALS *this)
{
  *(_DWORD *)this  = 0;
  *((_DWORD *)this + 1)  = 0;
  *((_DWORD *)this + 2)  = 0;
  *((void *)this + 2)  = 0;
  *((void *)this + 3)  = 0;
  *((void *)this + 4)  = 0;
  *((_DWORD *)this + 10)  = 1028443341;
  *((_DWORD *)this + 11)  = 1036831949;
  *((_DWORD *)this + 12)  = 1053609165;
  *((_DWORD *)this + 13)  = 0;
  *((_DWORD *)this + 14)  = 1184645120;
  *((_DWORD *)this + 15)  = 1138819072;
  *((_DWORD *)this + 16)  = 1133903872;
  *((unsigned char *)this + 68)  = 0;
  *((_DWORD *)this + 18)  = 0;
  *((_DWORD *)this + 19)  = 0;
  *((_DWORD *)this + 20)  = 0;
  std::vector<float>::vector((void *)this + 11, 0);
  *((_DWORD *)this + 28)  = 0;
  *((_DWORD *)this + 29)  = 0;
  *((_DWORD *)this + 30)  = 0;
  *((float *)this + 31)  = -1.0;
  std::vector<float>::vector((void *)this + 16, 0);
  float result = 450.0;
  *((_DWORD *)this + 39)  = 1138819072;
  return result;
}

void sub_1BA5D3AE0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(void *)(v10 - 16)  = a1;
  *(_DWORD *)(v10 - 20)  = a2;
  std::vector<float>::~vector[abi:ne180100]((uint64_t *)(a10 + 88));
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 16));
}

void *std::vector<float>::vector(void *a1, unint64_t a2)
{
  return a1;
}

{
  uint64_t v4;
  unsigned char v5[23];
  uint64_t v6;
  unint64_t v7;
  void *v8;
  void *v9;

  unint64_t v8 = a1;
  CustomCurve v7 = a2;
  uint64_t v9 = a1;
  *a1  = 0;
  a1[1]  = 0;
  char v6 = 0;
  std::__compressed_pair<float *>::__compressed_pair[abi:ne180100]<decltype(nullptr),std::__default_init_tag>(a1 + 2);
  std::vector<float>::__destroy_vector::__destroy_vector[abi:ne180100](&v4, (uint64_t)a1);
  std::__make_exception_guard[abi:ne180100]<std::vector<float>::__destroy_vector>(v4, (uint64_t)v5);
  if (v7)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, v7);
    std::vector<float>::__construct_at_end((uint64_t)a1, v7);
  }
  std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::__complete[abi:ne180100]((uint64_t)v5);
  std::__exception_guard_exceptions<std::vector<float>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v5);
  return v9;
}

void *std::vector<float>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  std::vector<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](&v8, a1, a2);
  uint64_t v7 = v10;
  for (i = v9; i != v7; uint64_t v9 = i)
  {
    std::vector<float>::__alloc[abi:ne180100]();
    uint64_t v5 = v2;
    std::__to_address[abi:ne180100]<float>();
    _ZNSt3__116allocator_traitsINS_9allocatorIfEEE9constructB8ne180100IfJEvEEvRS2_PT_DpOT0_(v5, v3);
    i += 4;
  }
  return std::vector<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](&v8);
}

double _ZNSt3__116allocator_traitsINS_9allocatorIfEEE9constructB8ne180100IfJEvEEvRS2_PT_DpOT0_(uint64_t a1, _DWORD *a2)
{
  return std::allocator<float>::construct[abi:ne180100]<float>(a1, a2);
}

double std::allocator<float>::construct[abi:ne180100]<float>(uint64_t a1, _DWORD *a2)
{
  double result = 0.0;
  *a2  = 0;
  return result;
}

void **std::vector<float>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v12 = a1;
  unint64_t v11 = a2;
  std::vector<float>::__end_cap[abi:ne180100]();
  if ((*v2 - a1[1]) / 4 >= v11) {
    return (void **)std::vector<float>::__construct_at_end((uint64_t)a1, v11);
  }
  std::vector<float>::__alloc[abi:ne180100]();
  uint64_t v10 = v4;
  uint64_t v5 = std::vector<float>::size[abi:ne180100](a1);
  unint64_t v7 = std::vector<float>::__recommend[abi:ne180100](a1, v5 + v11);
  uint64_t v6 = std::vector<float>::size[abi:ne180100](a1);
  std::__split_buffer<float>::__split_buffer(v9, v7, v6, v10);
  std::__split_buffer<float>::__construct_at_end((uint64_t)v9, v11);
  std::vector<float>::__swap_out_circular_buffer(a1, v9);
  return std::__split_buffer<float>::~__split_buffer(v9);
}

void std::vector<float>::__destruct_at_end[abi:ne180100](void *a1, uint64_t a2)
{
}

uint64_t std::__split_buffer<float>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v6[4] = a1;
  uint64_t v6[3] = a2;
  std::__split_buffer<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](v6, (void *)(a1 + 16), a2);
  while (v6[0] != v6[1])
  {
    uint64_t v4 = std::__split_buffer<float>::__alloc[abi:ne180100](a1);
    std::__to_address[abi:ne180100]<float>();
    _ZNSt3__116allocator_traitsINS_9allocatorIfEEE9constructB8ne180100IfJEvEEvRS2_PT_DpOT0_(v4, v2);
    v6[0] += 4;
  }
  return std::__split_buffer<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100]((uint64_t)v6);
}

void *std::__split_buffer<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *a1, void *a2, uint64_t a3)
{
  return a1;
}

uint64_t std::__split_buffer<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](uint64_t a1)
{
  return a1;
}

void *std::__split_buffer<float>::_ConstructTransaction::_ConstructTransaction[abi:ne180100](void *result, void *a2, uint64_t a3)
{
  *double result = *a2;
  result[1]  = *a2 + 4 * a3;
  result[2]  = a2;
  return result;
}

uint64_t std::__split_buffer<float>::_ConstructTransaction::~_ConstructTransaction[abi:ne180100](uint64_t result)
{
  **(void **)(result + 16)  = *(void *)result;
  return result;
}

uint64_t std::__bitset<1ul,3ul>::__make_ref[abi:ne180100](uint64_t a1, char a2)
{
  std::__bit_reference<std::__bitset<1ul,3ul>,true>::__bit_reference[abi:ne180100](&v3, a1, 1 << a2);
  return v3;
}

void *std::__bit_reference<std::__bitset<1ul,3ul>,true>::__bit_reference[abi:ne180100](void *a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

void *std::__bit_reference<std::__bitset<1ul,3ul>,true>::__bit_reference[abi:ne180100](void *result, uint64_t a2, uint64_t a3)
{
  *double result = a2;
  result[1]  = a3;
  return result;
}

BOOL std::__bitset<1ul,3ul>::any[abi:ne180100](void *a1)
{
  return (*a1 & 7) != 0;
}

uint64_t AABC::sendCrossTalkConfigToDCP(void)::$_0::operator()(uint64_t a1, char a2)
{
  return a2 & 1;
}

uint64_t __os_log_helper_16_2_3_4_0_8_0_8_64(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)double result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 8;
  *(void *)(result + 10)  = a3;
  *(unsigned char *)(result + 18)  = 64;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

uint64_t __os_log_helper_16_2_8_8_0_8_0_8_0_8_0_8_0_4_0_4_0_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9)
{
  *(unsigned char *)double result = 2;
  *(unsigned char *)(result + 1)  = 8;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 0;
  *(unsigned char *)(result + 53)  = 4;
  *(_DWORD *)(result + 54)  = a7;
  *(unsigned char *)(result + 58)  = 0;
  *(unsigned char *)(result + 59)  = 4;
  *(_DWORD *)(result + 60)  = a8;
  *(unsigned char *)(result + 64)  = 32;
  *(unsigned char *)(result + 65)  = 8;
  *(void *)(result + 66)  = a9;
  return result;
}

uint64_t __os_log_helper_16_2_4_4_0_4_0_8_32_8_32(uint64_t result, int a2, int a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)double result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 4;
  *(_DWORD *)(result + 4)  = a2;
  *(unsigned char *)(result + 8)  = 0;
  *(unsigned char *)(result + 9)  = 4;
  *(_DWORD *)(result + 10)  = a3;
  *(unsigned char *)(result + 14)  = 32;
  *(unsigned char *)(result + 15)  = 8;
  *(void *)(result + 16)  = a4;
  *(unsigned char *)(result + 24)  = 32;
  *(unsigned char *)(result + 25)  = 8;
  *(void *)(result + 26)  = a5;
  return result;
}

double std::__math::fmin[abi:ne180100]<float,unsigned int,0>(int a1, float a2, double a3)
{
  LODWORD(a3)  = a1;
  return std::__math::fmin[abi:ne180100]<int>(a2, (double)*(unint64_t *)&a3);
}

double std::__math::fmax[abi:ne180100]<int,int,0>(int a1, int a2)
{
  return std::__math::fmax[abi:ne180100]<int>((double)a1, (double)a2);
}

__CFString *aabUpdateStrategyTypeToString_0(uint64_t a1)
{
  uint64_t v4 = 0;
  if (a1)
  {
    uint64_t v2 = a1;
    char v1 = 1;
  }
  else
  {
    uint64_t v2 = 0;
    char v1 = 0;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        uint64_t v4 = @"preference based";
        break;
      case 1:
        uint64_t v4 = @"BOLTS";
        break;
      case 2:
        uint64_t v4 = @"hybrid with pref based as main and BOLTS as alternative";
        break;
      case 3:
        uint64_t v4 = @"hybrid with BOLTS as main and pref based as alternative";
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v4;
}

float timeLengthAtFromPointToPoint(float a1, float a2, float a3, float a4, float a5)
{
  return (float)(a3 * (float)(1.0 - (float)((float)(a1 - a2) / (float)(a4 - a2))))
       + (float)(a5 * (float)((float)(a1 - a2) / (float)(a4 - a2)));
}

uint64_t __os_log_helper_16_0_6_8_0_8_0_8_0_8_0_4_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  *(unsigned char *)double result = 0;
  *(unsigned char *)(result + 1)  = 6;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 4;
  *(_DWORD *)(result + 44)  = a6;
  *(unsigned char *)(result + 48)  = 0;
  *(unsigned char *)(result + 49)  = 8;
  *(void *)(result + 50)  = a7;
  return result;
}

void sub_1BA5DA6CC()
{
  _Unwind_Resume(v0);
}

void CBAuroraParams::CBAuroraParams(CBAuroraParams *this)
{
}

{
  *(void *)this  = os_log_create("com.apple.CoreBrightness.Aurora", "params");
  *((_DWORD *)this + 2)  = 1174175744;
  *((_DWORD *)this + 3)  = 1174175744;
  *((_DWORD *)this + 4)  = 1174175744;
  *((_DWORD *)this + 5)  = 1173110784;
  *((_DWORD *)this + 6)  = 1173110784;
  *((_DWORD *)this + 7)  = 1173110784;
  *((_DWORD *)this + 8)  = 1183109120;
  *((_DWORD *)this + 9)  = 1183109120;
  *((_DWORD *)this + 10)  = 1183109120;
  *((_DWORD *)this + 11)  = 1158148096;
  *((_DWORD *)this + 12)  = 1149534208;
  *((float *)this + 13)  = 1.0;
  *((unsigned char *)this + 56)  = 0;
  *((float *)this + 15)  = 4.0;
  *((float *)this + 16)  = 4.0;
  *((float *)this + 17)  = 0.75;
  *((_DWORD *)this + 18)  = 1043878380;
  *((_DWORD *)this + 19)  = 1051931443;
  *((_DWORD *)this + 20)  = 1045220557;
  *((_DWORD *)this + 21)  = 1053609165;
  *((_DWORD *)this + 22)  = 1150681088;
  *((_DWORD *)this + 23)  = 1066863165;
  *((_DWORD *)this + 24)  = 1123024896;
  *((unsigned char *)this + 100)  = 0;
  *((unsigned char *)this + 101)  = 0;
  *((unsigned char *)this + 102)  = 0;
}

void CBAuroraParams::loadFromCapabilities(CBAuroraParams *this, NSDictionary *a2)
{
  uint64_t v178 = *MEMORY[0x1E4F143B8];
  int v156 = this;
  id v155 = a2;
  id v154 = [(NSDictionary *)a2 objectForKeyedSubscript:@"Aurora"];
  [v154 objectForKeyedSubscript:@"AuroraEnterLux"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v153 = (id)[v154 objectForKeyedSubscript:@"AuroraEnterLux"];
    if ([v153 count] == 3)
    {
      uint64_t v147 = MEMORY[0x1E4F143A8];
      int v148 = -1073741824;
      int v149 = 0;
      CFDictionaryRef v150 = ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke;
      char v151 = &__block_descriptor_40_e25_v32__0__NSNumber_8Q16_B24l;
      CFTypeRef v152 = this;
      objc_msgSend(v153, "enumerateObjectsUsingBlock:");
      os_log_t v146 = 0;
      if (*(void *)this)
      {
        int v88 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t inited = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t inited = init_default_corebrightness_log();
        }
        int v88 = inited;
      }
      os_log_t v146 = v88;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v177, (uint64_t)v153);
        _os_log_impl(&dword_1BA438000, v146, type, "Aurora Initialization | Enter lux overriden from capabilities: %@", v177, 0xCu);
      }
    }
    else
    {
      char v144 = 0;
      if (*(void *)this)
      {
        CFStringRef v86 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v85 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v85 = init_default_corebrightness_log();
        }
        CFStringRef v86 = v85;
      }
      char v144 = v86;
      os_log_type_t v143 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v83 = v144;
        os_log_type_t v84 = v143;
        __os_log_helper_16_0_0(v142);
        _os_log_error_impl(&dword_1BA438000, v83, v84, "Aurora Initialization | Enter lux array length from capablities doesn't match number of curve levels", v142, 2u);
      }
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraExitLux"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v141 = (id)[v154 objectForKeyedSubscript:@"AuroraExitLux"];
    if ([v141 count] == 3)
    {
      uint64_t v135 = MEMORY[0x1E4F143A8];
      int v136 = -1073741824;
      int v137 = 0;
      uint64_t v138 = ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke_311;
      int v139 = &__block_descriptor_40_e25_v32__0__NSNumber_8Q16_B24l;
      int v140 = this;
      objc_msgSend(v141, "enumerateObjectsUsingBlock:");
      os_log_t v134 = 0;
      if (*(void *)this)
      {
        float v82 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v81 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v81 = init_default_corebrightness_log();
        }
        float v82 = v81;
      }
      os_log_t v134 = v82;
      os_log_type_t v133 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v176, (uint64_t)v141);
        _os_log_impl(&dword_1BA438000, v134, v133, "Aurora Initialization | Exit lux overriden from capabilities: %@", v176, 0xCu);
      }
    }
    else
    {
      CFDictionaryRef v132 = 0;
      if (*(void *)this)
      {
        os_log_t v80 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v79 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v79 = init_default_corebrightness_log();
        }
        os_log_t v80 = v79;
      }
      CFDictionaryRef v132 = v80;
      os_log_type_t v131 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
      {
        CFTypeID v77 = v132;
        os_log_type_t v78 = v131;
        __os_log_helper_16_0_0(v130);
        _os_log_error_impl(&dword_1BA438000, v77, v78, "Aurora Initialization | Exit lux array length from capablities doesn't match number of curve levels", v130, 2u);
      }
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraSaturationLux"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v129 = (id)[v154 objectForKeyedSubscript:@"AuroraSaturationLux"];
    if ([v129 count] == 3)
    {
      uint64_t v123 = MEMORY[0x1E4F143A8];
      int v124 = -1073741824;
      int v125 = 0;
      int v126 = ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke_315;
      CFTypeRef v127 = &__block_descriptor_40_e25_v32__0__NSNumber_8Q16_B24l;
      os_log_t v128 = this;
      objc_msgSend(v129, "enumerateObjectsUsingBlock:");
      os_log_t v122 = 0;
      if (*(void *)this)
      {
        float v76 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v75 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v75 = init_default_corebrightness_log();
        }
        float v76 = v75;
      }
      os_log_t v122 = v76;
      os_log_type_t v121 = OS_LOG_TYPE_DEFAULT;
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
      {
        __os_log_helper_16_2_1_8_64((uint64_t)v175, (uint64_t)v129);
        _os_log_impl(&dword_1BA438000, v122, v121, "Aurora Initialization | Saturation lux overriden from capabilities: %@", v175, 0xCu);
      }
    }
    else
    {
      os_log_type_t v120 = 0;
      if (*(void *)this)
      {
        float v74 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v73 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v73 = init_default_corebrightness_log();
        }
        float v74 = v73;
      }
      os_log_type_t v120 = v74;
      os_log_type_t v119 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v71 = v120;
        os_log_type_t v72 = v119;
        __os_log_helper_16_0_0(v118);
        _os_log_error_impl(&dword_1BA438000, v71, v72, "Aurora Initialization | Saturation lux array length from capablities doesn't match number of curve levels", v118, 2u);
      }
    }
  }
  [v155 objectForKeyedSubscript:@"MaxNits"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v155, "objectForKeyedSubscript:", @"MaxNits"), "floatValue");
    *((_DWORD *)this + 12)  = v2;
    os_log_t v117 = 0;
    if (*(void *)this)
    {
      uint64_t v70 = *(NSObject **)this;
    }
    else
    {
      uint64_t v69 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      uint64_t v70 = v69;
    }
    os_log_t v117 = v70;
    v116  = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v174, COERCE__INT64(*((float *)this + 12)));
      _os_log_impl(&dword_1BA438000, v117, v116, "Aurora Initialization | Nits maximum user accessible overriden from capabilities: %f", v174, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraMaxNits"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraMaxNits"), "floatValue");
    *((_DWORD *)this + 11)  = v3;
    os_log_t v115 = 0;
    if (*(void *)this)
    {
      os_log_t v68 = *(NSObject **)this;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v67 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v67 = init_default_corebrightness_log();
      }
      os_log_t v68 = v67;
    }
    os_log_t v115 = v68;
    os_log_type_t v114 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v173, COERCE__INT64(*((float *)this + 11)));
      _os_log_impl(&dword_1BA438000, v115, v114, "Aurora Initialization | Nits maximum overriden from capabilities: %f", v173, 0xCu);
    }
  }
  else
  {
    [v155 objectForKeyedSubscript:@"MaxNitsPanel"];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      float v66 = *((float *)this + 11);
      objc_msgSend((id)objc_msgSend(v155, "objectForKeyedSubscript:", @"MaxNitsPanel"), "floatValue");
      float v4 = *(float *)&v5;
      *(float *)&double v5 = v66;
      if (v66 != v4)
      {
        objc_msgSend((id)objc_msgSend(v155, "objectForKeyedSubscript:", @"MaxNitsPanel", v5), "floatValue");
        *((_DWORD *)this + 11)  = v6;
        os_log_t v113 = 0;
        if (*(void *)this)
        {
          os_log_type_t v65 = *(NSObject **)this;
        }
        else
        {
          uint64_t v64 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
          os_log_type_t v65 = v64;
        }
        os_log_t v113 = v65;
        os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_1_8_0((uint64_t)v172, COERCE__INT64(*((float *)this + 11)));
          _os_log_impl(&dword_1BA438000, v113, v112, "Aurora Initialization | Nits maximum overriden from capabilities: %f", v172, 0xCu);
        }
      }
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraAverageAPCESamplingRate"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraAverageAPCESamplingRate"), "floatValue");
    *((_DWORD *)this + 13)  = v7;
    os_log_t v111 = 0;
    if (*(void *)this)
    {
      os_log_type_t v63 = *(NSObject **)this;
    }
    else
    {
      uint64_t v62 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      os_log_type_t v63 = v62;
    }
    os_log_t v111 = v63;
    os_log_type_t v110 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v171, COERCE__INT64(*((float *)this + 13)));
      _os_log_impl(&dword_1BA438000, v111, v110, "Aurora Initialization | Average APCE sampling rate overriden from capabilities: %f", v171, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraIgnorePeakAPCE"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraIgnorePeakAPCE"), "floatValue");
    *((unsigned char *)this + 56)  = v8 != 0.0;
    os_log_t v109 = 0;
    if (*(void *)this)
    {
      float v61 = *(NSObject **)this;
    }
    else
    {
      uint64_t v60 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      float v61 = v60;
    }
    os_log_t v109 = v61;
    os_log_type_t v108 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      if (*((unsigned char *)this + 56)) {
        uint64_t v9 = "YES";
      }
      else {
        uint64_t v9 = "NO";
      }
      __os_log_helper_16_2_1_8_32((uint64_t)v170, (uint64_t)v9);
      _os_log_impl(&dword_1BA438000, v109, v108, "Aurora Initialization | Ignore peak APCE overriden from capabilities: %s", v170, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraRampUpSpeed"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraRampUpSpeed"), "floatValue");
    *((_DWORD *)this + 15)  = v10;
    os_log_t v107 = 0;
    if (*(void *)this)
    {
      CFDictionaryRef v59 = *(NSObject **)this;
    }
    else
    {
      uint64_t v58 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      CFDictionaryRef v59 = v58;
    }
    os_log_t v107 = v59;
    os_log_type_t v106 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v169, COERCE__INT64(*((float *)this + 15)));
      _os_log_impl(&dword_1BA438000, v107, v106, "Aurora Initialization | Ramp up time overriden from capabilities: %f", v169, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraRampDownSpeed"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraRampDownSpeed"), "floatValue");
    *((_DWORD *)this + 16)  = v11;
    os_log_t v105 = 0;
    if (*(void *)this)
    {
      uint64_t v57 = *(NSObject **)this;
    }
    else
    {
      uint64_t v56 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      uint64_t v57 = v56;
    }
    os_log_t v105 = v57;
    os_log_type_t v104 = OS_LOG_TYPE_DEFAULT;
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v168, COERCE__INT64(*((float *)this + 16)));
      _os_log_impl(&dword_1BA438000, v105, v104, "Aurora Initialization | Ramp down time overriden from capabilities: %f", v168, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraRampUpTapAPCEPoints"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v103 = (id)[v154 objectForKeyedSubscript:@"AuroraRampUpTapAPCEPoints"];
    if ([v103 count] == 2)
    {
      [v103 objectAtIndexedSubscript:0];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0
        && ([v103 objectAtIndexedSubscript:1], objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        objc_msgSend((id)objc_msgSend(v103, "objectAtIndexedSubscript:", 0), "floatValue");
        *((_DWORD *)this + 18)  = v12;
        objc_msgSend((id)objc_msgSend(v103, "objectAtIndexedSubscript:", 1), "floatValue");
        *((_DWORD *)this + 19)  = v13;
        os_log_t v102 = 0;
        if (*(void *)this)
        {
          id v55 = *(NSObject **)this;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v54 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v54 = init_default_corebrightness_log();
          }
          id v55 = v54;
        }
        os_log_t v102 = v55;
        os_log_type_t v101 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v167, COERCE__INT64(*((float *)this + 18)), COERCE__INT64(*((float *)this + 19)));
          _os_log_impl(&dword_1BA438000, v102, v101, "Aurora Initialization | Ramp up tap APCE points overriden from capabilities - min: %f, max:%f", v167, 0x16u);
        }
      }
      else
      {
        uint64_t v100 = 0;
        if (*(void *)this)
        {
          os_log_type_t v53 = *(NSObject **)this;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v52 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v52 = init_default_corebrightness_log();
          }
          os_log_type_t v53 = v52;
        }
        uint64_t v100 = v53;
        os_log_type_t v99 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        {
          float v50 = v100;
          os_log_type_t v51 = v99;
          __os_log_helper_16_0_0(v98);
          _os_log_error_impl(&dword_1BA438000, v50, v51, "Aurora Initialization | Ramp up tap APCE points has unexpected types", v98, 2u);
        }
      }
    }
    else
    {
      os_log_t v97 = 0;
      if (*(void *)this)
      {
        float v49 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v48 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v48 = init_default_corebrightness_log();
        }
        float v49 = v48;
      }
      os_log_t v97 = v49;
      os_log_type_t v96 = OS_LOG_TYPE_ERROR;
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v166, [v103 count]);
        _os_log_error_impl(&dword_1BA438000, v97, v96, "Aurora Initialization | Ramp up tap APCE points has unexpected number of values(%lu), expected 2", v166, 0xCu);
      }
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraRampDownTapAPCEPoints"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v95 = (id)[v154 objectForKeyedSubscript:@"AuroraRampDownTapAPCEPoints"];
    if ([v95 count] == 2)
    {
      [v95 objectAtIndexedSubscript:0];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0
        && ([v95 objectAtIndexedSubscript:1], objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        objc_msgSend((id)objc_msgSend(v95, "objectAtIndexedSubscript:", 0), "floatValue");
        *((_DWORD *)this + 20)  = v14;
        objc_msgSend((id)objc_msgSend(v95, "objectAtIndexedSubscript:", 1), "floatValue");
        *((_DWORD *)this + 21)  = v15;
        os_log_t v94 = 0;
        if (*(void *)this)
        {
          float v47 = *(NSObject **)this;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v46 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v46 = init_default_corebrightness_log();
          }
          float v47 = v46;
        }
        os_log_t v94 = v47;
        os_log_type_t v93 = OS_LOG_TYPE_DEFAULT;
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          __os_log_helper_16_0_2_8_0_8_0((uint64_t)v165, COERCE__INT64(*((float *)this + 20)), COERCE__INT64(*((float *)this + 21)));
          _os_log_impl(&dword_1BA438000, v94, v93, "Aurora Initialization | Ramp down tap APCE points overriden from capabilities - min: %f, max:%f", v165, 0x16u);
        }
      }
      else
      {
        os_log_t v92 = 0;
        if (*(void *)this)
        {
          float v45 = *(NSObject **)this;
        }
        else
        {
          if (_COREBRIGHTNESS_LOG_DEFAULT) {
            uint64_t v44 = _COREBRIGHTNESS_LOG_DEFAULT;
          }
          else {
            uint64_t v44 = init_default_corebrightness_log();
          }
          float v45 = v44;
        }
        os_log_t v92 = v45;
        os_log_type_t v91 = OS_LOG_TYPE_ERROR;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          float v42 = v92;
          os_log_type_t v43 = v91;
          __os_log_helper_16_0_0(v90);
          _os_log_error_impl(&dword_1BA438000, v42, v43, "Aurora Initialization | Ramp down tap APCE points has unexpected types", v90, 2u);
        }
      }
    }
    else
    {
      if (*(void *)this)
      {
        os_log_type_t v41 = *(NSObject **)this;
      }
      else
      {
        if (_COREBRIGHTNESS_LOG_DEFAULT) {
          uint64_t v40 = _COREBRIGHTNESS_LOG_DEFAULT;
        }
        else {
          uint64_t v40 = init_default_corebrightness_log();
        }
        os_log_type_t v41 = v40;
      }
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        __os_log_helper_16_0_1_8_0((uint64_t)v164, [v95 count]);
        _os_log_error_impl(&dword_1BA438000, v41, OS_LOG_TYPE_ERROR, "Aurora Initialization | Ramp down tap APCE points has unexpected number of values(%lu), expected 2", v164, 0xCu);
      }
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraCPMSThreshold"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraCPMSThreshold"), "floatValue");
    *((_DWORD *)this + 22)  = v16;
    if (*(void *)this)
    {
      os_log_type_t v39 = *(NSObject **)this;
    }
    else
    {
      uint64_t v38 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      os_log_type_t v39 = v38;
    }
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v163, COERCE__INT64(*((float *)this + 22)));
      _os_log_impl(&dword_1BA438000, v39, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | CPMS activation threshold overriden from capabilities: %f", v163, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraCPMSEnterMultiplier"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraCPMSEnterMultiplier"), "floatValue");
    *((_DWORD *)this + 23)  = v17;
    if (*(void *)this)
    {
      os_log_type_t v37 = *(NSObject **)this;
    }
    else
    {
      uint64_t v36 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      os_log_type_t v37 = v36;
    }
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v162, COERCE__INT64(*((float *)this + 23)));
      _os_log_impl(&dword_1BA438000, v37, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | CPMS enter delta overriden from capabilities: %f", v162, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraSessionLimit"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraSessionLimit"), "floatValue");
    *((_DWORD *)this + 24)  = v18;
    if (*(void *)this)
    {
      os_log_t v35 = *(NSObject **)this;
    }
    else
    {
      uint64_t v34 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      os_log_t v35 = v34;
    }
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v161, COERCE__INT64(*((float *)this + 24)));
      _os_log_impl(&dword_1BA438000, v35, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Session limit overriden from capabilities: %f", v161, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraIgnoreSessionLimit"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraIgnoreSessionLimit"), "floatValue");
    *((unsigned char *)this + 100)  = v19 != 0.0;
    if (*(void *)this)
    {
      float v33 = *(NSObject **)this;
    }
    else
    {
      uint64_t v32 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      float v33 = v32;
    }
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      if (*((unsigned char *)this + 100)) {
        uint64_t v20 = "YES";
      }
      else {
        uint64_t v20 = "NO";
      }
      __os_log_helper_16_2_1_8_32((uint64_t)v160, (uint64_t)v20);
      _os_log_impl(&dword_1BA438000, v33, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Ignore session limit overriden from capabilities: %s", v160, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraIgnoreAPCE"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraIgnoreAPCE"), "floatValue");
    *((unsigned char *)this + 101)  = v21 != 0.0;
    if (*(void *)this)
    {
      os_log_t v31 = *(NSObject **)this;
    }
    else
    {
      uint64_t v30 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      os_log_t v31 = v30;
    }
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      if (*((unsigned char *)this + 101)) {
        uint64_t v22 = "YES";
      }
      else {
        uint64_t v22 = "NO";
      }
      __os_log_helper_16_2_1_8_32((uint64_t)v159, (uint64_t)v22);
      _os_log_impl(&dword_1BA438000, v31, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Ignore APCE overriden from capabilities: %s", v159, 0xCu);
    }
  }
  [v154 objectForKeyedSubscript:@"AuroraAllowEDR"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v154, "objectForKeyedSubscript:", @"AuroraAllowEDR"), "floatValue");
    *((unsigned char *)this + 102)  = v23 != 0.0;
    if (*(void *)this)
    {
      float v29 = *(NSObject **)this;
    }
    else
    {
      uint64_t v28 = _COREBRIGHTNESS_LOG_DEFAULT ? _COREBRIGHTNESS_LOG_DEFAULT : init_default_corebrightness_log();
      float v29 = v28;
    }
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      if (*((unsigned char *)this + 102)) {
        os_log_type_t v24 = "YES";
      }
      else {
        os_log_type_t v24 = "NO";
      }
      __os_log_helper_16_2_1_8_32((uint64_t)v158, (uint64_t)v24);
      _os_log_impl(&dword_1BA438000, v29, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Allow EDR overriden from capabilities: %s", v158, 0xCu);
    }
  }
  [v155 objectForKeyedSubscript:@"EDRAuroraSecondsPerStop"];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_msgSend((id)objc_msgSend(v155, "objectForKeyedSubscript:", @"EDRAuroraSecondsPerStop"), "floatValue");
    *((_DWORD *)this + 17)  = v25;
    if (*(void *)this)
    {
      os_log_type_t v27 = *(NSObject **)this;
    }
    else
    {
      if (_COREBRIGHTNESS_LOG_DEFAULT) {
        uint64_t v26 = _COREBRIGHTNESS_LOG_DEFAULT;
      }
      else {
        uint64_t v26 = init_default_corebrightness_log();
      }
      os_log_type_t v27 = v26;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      __os_log_helper_16_0_1_8_0((uint64_t)v157, COERCE__INT64(*((float *)this + 17)));
      _os_log_impl(&dword_1BA438000, v27, OS_LOG_TYPE_DEFAULT, "Aurora Initialization | Time for EDR ramps overriden from capabilities: %f", v157, 0xCu);
    }
  }
}

uint64_t __os_log_helper_16_2_11_8_32_8_32_8_32_8_32_8_32_8_32_8_32_8_32_8_32_8_32_8_32(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  *(unsigned char *)double result = 2;
  *(unsigned char *)(result + 1)  = 11;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 32;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 32;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 32;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 32;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  *(unsigned char *)(result + 52)  = 32;
  *(unsigned char *)(result + 53)  = 8;
  *(void *)(result + 54)  = a7;
  *(unsigned char *)(result + 62)  = 32;
  *(unsigned char *)(result + 63)  = 8;
  *(void *)(result + 64)  = a8;
  *(unsigned char *)(result + 72)  = 32;
  *(unsigned char *)(result + 73)  = 8;
  *(void *)(result + 74)  = a9;
  *(unsigned char *)(result + 82)  = 32;
  *(unsigned char *)(result + 83)  = 8;
  *(void *)(result + 84)  = a10;
  *(unsigned char *)(result + 92)  = 32;
  *(unsigned char *)(result + 93)  = 8;
  *(void *)(result + 94)  = a11;
  *(unsigned char *)(result + 102)  = 32;
  *(unsigned char *)(result + 103)  = 8;
  *(void *)(result + 104)  = a12;
  return result;
}

uint64_t __os_log_helper_16_2_5_8_32_8_32_8_0_8_0_8_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(unsigned char *)double result = 2;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 32;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 32;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 8;
  *(void *)(result + 24)  = a4;
  *(unsigned char *)(result + 32)  = 0;
  *(unsigned char *)(result + 33)  = 8;
  *(void *)(result + 34)  = a5;
  *(unsigned char *)(result + 42)  = 0;
  *(unsigned char *)(result + 43)  = 8;
  *(void *)(result + 44)  = a6;
  return result;
}

float abs[abi:ne180100](float a1)
{
  return fabsf(a1);
}

uint64_t __os_log_helper_16_2_20_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_32_8_32_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  uint64_t result = a11;
  *(unsigned char *)a1  = 2;
  *(unsigned char *)(a1 + 1)  = 20;
  *(unsigned char *)(a1 + 2)  = 0;
  *(unsigned char *)(a1 + 3)  = 8;
  *(void *)(a1 + 4)  = a2;
  *(unsigned char *)(a1 + 12)  = 0;
  *(unsigned char *)(a1 + 13)  = 8;
  *(void *)(a1 + 14)  = a3;
  *(unsigned char *)(a1 + 22)  = 0;
  *(unsigned char *)(a1 + 23)  = 8;
  *(void *)(a1 + 24)  = a4;
  *(unsigned char *)(a1 + 32)  = 0;
  *(unsigned char *)(a1 + 33)  = 8;
  *(void *)(a1 + 34)  = a5;
  *(unsigned char *)(a1 + 42)  = 0;
  *(unsigned char *)(a1 + 43)  = 8;
  *(void *)(a1 + 44)  = a6;
  *(unsigned char *)(a1 + 52)  = 0;
  *(unsigned char *)(a1 + 53)  = 8;
  *(void *)(a1 + 54)  = a7;
  *(unsigned char *)(a1 + 62)  = 0;
  *(unsigned char *)(a1 + 63)  = 8;
  *(void *)(a1 + 64)  = a8;
  *(unsigned char *)(a1 + 72)  = 32;
  *(unsigned char *)(a1 + 73)  = 8;
  *(void *)(a1 + 74)  = a9;
  *(unsigned char *)(a1 + 82)  = 32;
  *(unsigned char *)(a1 + 83)  = 8;
  *(void *)(a1 + 84)  = a10;
  *(unsigned char *)(a1 + 92)  = 0;
  *(unsigned char *)(a1 + 93)  = 8;
  *(void *)(a1 + 94)  = a11;
  *(unsigned char *)(a1 + 102)  = 0;
  *(unsigned char *)(a1 + 103)  = 8;
  *(void *)(a1 + 104)  = a12;
  *(unsigned char *)(a1 + 112)  = 0;
  *(unsigned char *)(a1 + 113)  = 8;
  *(void *)(a1 + 114)  = a13;
  *(unsigned char *)(a1 + 122)  = 0;
  *(unsigned char *)(a1 + 123)  = 8;
  *(void *)(a1 + 124)  = a14;
  *(unsigned char *)(a1 + 132)  = 0;
  *(unsigned char *)(a1 + 133)  = 8;
  *(void *)(a1 + 134)  = a15;
  *(unsigned char *)(a1 + 142)  = 0;
  *(unsigned char *)(a1 + 143)  = 8;
  *(void *)(a1 + 144)  = a16;
  *(unsigned char *)(a1 + 152)  = 0;
  *(unsigned char *)(a1 + 153)  = 8;
  *(void *)(a1 + 154)  = a17;
  *(unsigned char *)(a1 + 162)  = 0;
  *(unsigned char *)(a1 + 163)  = 8;
  *(void *)(a1 + 164)  = a18;
  *(unsigned char *)(a1 + 172)  = 0;
  *(unsigned char *)(a1 + 173)  = 8;
  *(void *)(a1 + 174)  = a19;
  *(unsigned char *)(a1 + 182)  = 0;
  *(unsigned char *)(a1 + 183)  = 8;
  *(void *)(a1 + 184)  = a20;
  *(unsigned char *)(a1 + 192)  = 0;
  *(unsigned char *)(a1 + 193)  = 8;
  *(void *)(a1 + 194)  = a21;
  return result;
}

float ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  [a2 floatValue];
  float v7 = v3;
  float v4 = (float *)std::array<float,3ul>::operator[][abi:ne180100](v6 + 8, a3);
  float result = v7;
  *float v4 = v7;
  return result;
}

float ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke_311(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  [a2 floatValue];
  float v7 = v3;
  float v4 = (float *)std::array<float,3ul>::operator[][abi:ne180100](v6 + 20, a3);
  float result = v7;
  *float v4 = v7;
  return result;
}

float ___ZN14CBAuroraParams20loadFromCapabilitiesEP12NSDictionary_block_invoke_315(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  [a2 floatValue];
  float v7 = v3;
  float v4 = (float *)std::array<float,3ul>::operator[][abi:ne180100](v6 + 32, a3);
  float result = v7;
  *float v4 = v7;
  return result;
}

uint64_t __os_log_helper_16_2_4_8_0_4_0_4_0_8_66(uint64_t result, uint64_t a2, int a3, int a4, uint64_t a5)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 4;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 4;
  *(_DWORD *)(result + 20)  = a4;
  *(unsigned char *)(result + 24)  = 66;
  *(unsigned char *)(result + 25)  = 8;
  *(void *)(result + 26)  = a5;
  return result;
}

uint64_t __os_log_helper_16_2_3_8_0_4_0_8_66(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 3;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 66;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  return result;
}

void sub_1BA5EAA7C(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  *(void *)(v10 - 24)  = a1;
  *(_DWORD *)(v10 - 28)  = a2;
  objc_sync_exit(obj);
  _Unwind_Resume(*(_Unwind_Exception **)(v10 - 24));
}

void sub_1BA5EEF6C()
{
  _Unwind_Resume(v0);
}

uint64_t __os_log_helper_16_0_5_8_0_4_0_8_0_8_0_4_0(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1)  = 5;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 4;
  *(_DWORD *)(result + 14)  = a3;
  *(unsigned char *)(result + 18)  = 0;
  *(unsigned char *)(result + 19)  = 8;
  *(void *)(result + 20)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 4;
  *(_DWORD *)(result + 40)  = a6;
  return result;
}

void sub_1BA5F0500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_1BA5F0698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, _Unwind_Exception *exception_object)
{
  _Block_object_dispose((const void *)(v12 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __os_log_helper_16_0_7_8_0_8_0_4_0_8_0_4_0_4_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, int a8)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1)  = 7;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 4;
  *(_DWORD *)(result + 40)  = a6;
  *(unsigned char *)(result + 44)  = 0;
  *(unsigned char *)(result + 45)  = 4;
  *(_DWORD *)(result + 46)  = a7;
  *(unsigned char *)(result + 50)  = 0;
  *(unsigned char *)(result + 51)  = 4;
  *(_DWORD *)(result + 52)  = a8;
  return result;
}

uint64_t __os_log_helper_16_0_9_8_0_8_0_4_0_8_0_4_0_4_0_4_0_4_0_4_0(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, int a8, int a9, int a10)
{
  *(unsigned char *)float result = 0;
  *(unsigned char *)(result + 1)  = 9;
  *(unsigned char *)(result + 2)  = 0;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 0;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  *(unsigned char *)(result + 22)  = 0;
  *(unsigned char *)(result + 23)  = 4;
  *(_DWORD *)(result + 24)  = a4;
  *(unsigned char *)(result + 28)  = 0;
  *(unsigned char *)(result + 29)  = 8;
  *(void *)(result + 30)  = a5;
  *(unsigned char *)(result + 38)  = 0;
  *(unsigned char *)(result + 39)  = 4;
  *(_DWORD *)(result + 40)  = a6;
  *(unsigned char *)(result + 44)  = 0;
  *(unsigned char *)(result + 45)  = 4;
  *(_DWORD *)(result + 46)  = a7;
  *(unsigned char *)(result + 50)  = 0;
  *(unsigned char *)(result + 51)  = 4;
  *(_DWORD *)(result + 52)  = a8;
  *(unsigned char *)(result + 56)  = 0;
  *(unsigned char *)(result + 57)  = 4;
  *(_DWORD *)(result + 58)  = a9;
  *(unsigned char *)(result + 62)  = 0;
  *(unsigned char *)(result + 63)  = 4;
  *(_DWORD *)(result + 64)  = a10;
  return result;
}

uint64_t __os_log_helper_16_2_2_8_64_8_66(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)float result = 2;
  *(unsigned char *)(result + 1)  = 2;
  *(unsigned char *)(result + 2)  = 64;
  *(unsigned char *)(result + 3)  = 8;
  *(void *)(result + 4)  = a2;
  *(unsigned char *)(result + 12)  = 66;
  *(unsigned char *)(result + 13)  = 8;
  *(void *)(result + 14)  = a3;
  return result;
}

BOOL CBPreferencesHandlerStorePreferenceForUser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[CBPreferencesHandler storePreferenceForUser:a1 withKey:a2 andValue:a3];
}

BOOL CBPreferencesHandlerStorePreferenceForAllUsers(uint64_t a1, uint64_t a2)
{
  return +[CBPreferencesHandler storePreferenceForAllUsersForKey:andValue:](CBPreferencesHandler, "storePreferenceForAllUsersForKey:andValue:", a1, a2, a2, a1);
}

BOOL CBPreferencesHandlerStorePreferenceForAllUsersMultiple(uint64_t a1)
{
  return +[CBPreferencesHandler storePreferenceForAllUsersMultiple:a1];
}

id CBPreferencesHandlerCopyPreferenceForUser(uint64_t a1, uint64_t a2)
{
  return +[CBPreferencesHandler copyPreferenceForUser:forKey:](CBPreferencesHandler, "copyPreferenceForUser:forKey:", a1, a2, a2, a1);
}

id CBPreferencesHandlerCopyPreferenceForAllUsers(uint64_t a1)
{
  return +[CBPreferencesHandler copyPreferenceForAllUsersForKey:a1];
}

id CBPreferencesHandlerCopyPreferenceForAllUsersMultiple(uint64_t a1)
{
  return +[CBPreferencesHandler copyPreferenceForAllUsersMultiple:a1];
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1F41138B8]();
}

uint64_t ApplePhotonDetectorServicesClose()
{
  return MEMORY[0x1F410AA88]();
}

uint64_t ApplePhotonDetectorServicesGetCoex()
{
  return MEMORY[0x1F410AA90]();
}

uint64_t ApplePhotonDetectorServicesGetGlobalCorrectionFactor()
{
  return MEMORY[0x1F410AA98]();
}

uint64_t ApplePhotonDetectorServicesGetLuxAsync()
{
  return MEMORY[0x1F410AAA8]();
}

uint64_t ApplePhotonDetectorServicesOpen()
{
  return MEMORY[0x1F410AAB0]();
}

uint64_t BiomeLibrary()
{
  return MEMORY[0x1F410C8D0]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return (void *)MEMORY[0x1F40D70E8](allocator, size, hint);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

Boolean CFCalendarAddComponents(CFCalendarRef calendar, CFAbsoluteTime *at, CFOptionFlags options, const char *componentDesc, ...)
{
  return MEMORY[0x1F40D7670](calendar, at, options, componentDesc);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x1F40D7678](calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  return (CFCalendarRef)MEMORY[0x1F40D7680]();
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)MEMORY[0x1F40D7690](allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  uint64_t v3 = va_arg(va, void);
  return MEMORY[0x1F40D7698](calendar, v3, at);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

CFIndex CFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D79C8](theDict, key);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1F40D7A18](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7B60](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D08]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return MEMORY[0x1F40D7DF8](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E30](number);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1F40D7E90](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

CFDictionaryRef CFPreferencesCopyMultiple(CFArrayRef keysToFetch, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7EC0](keysToFetch, applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7ED0](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE0](key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

void CFPreferencesSetMultiple(CFDictionaryRef keysToSet, CFArrayRef keysToRemove, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1F40D7F10](applicationID, userName, hostName);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopRun(void)
{
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1F40D85E0]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1F40D86F8]();
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  return MEMORY[0x1F40D8828](alloc, url, resourceData, properties, desiredProperties, errorCode);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x1F40D89D0](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  return MEMORY[0x1F40D8A20](userNotification);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x1F40D8A28](allocator, flags, error, dictionary, timeout);
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  return MEMORY[0x1F40D8A68](userNotification, responseFlags, timeout);
}

uint64_t GSEventIsHardwareKeyboardAttached()
{
  return MEMORY[0x1F411C8F8]();
}

CFDataRef IOCFSerialize(CFTypeRef object, CFOptionFlags options)
{
  return (CFDataRef)MEMORY[0x1F40E8688](object, options);
}

CFTypeRef IOCFUnserializeBinary(const char *buffer, size_t bufferSize, CFAllocatorRef allocator, CFOptionFlags options, CFStringRef *errorString)
{
  return (CFTypeRef)MEMORY[0x1F40E8690](buffer, bufferSize, allocator, options, errorString);
}

IOReturn IOHIDDeviceClose(IOHIDDeviceRef device, IOOptionBits options)
{
  return MEMORY[0x1F40E8798](device, *(void *)&options);
}

CFArrayRef IOHIDDeviceCopyMatchingElements(IOHIDDeviceRef device, CFDictionaryRef matching, IOOptionBits options)
{
  return (CFArrayRef)MEMORY[0x1F40E87A8](device, matching, *(void *)&options);
}

IOHIDDeviceRef IOHIDDeviceCreate(CFAllocatorRef allocator, io_service_t service)
{
  return (IOHIDDeviceRef)MEMORY[0x1F40E87B0](allocator, *(void *)&service);
}

IOReturn IOHIDDeviceOpen(IOHIDDeviceRef device, IOOptionBits options)
{
  return MEMORY[0x1F40E87E8](device, *(void *)&options);
}

CFIndex IOHIDElementGetPhysicalMax(IOHIDElementRef element)
{
  return MEMORY[0x1F40E8888](element);
}

CFIndex IOHIDElementGetPhysicalMin(IOHIDElementRef element)
{
  return MEMORY[0x1F40E8890](element);
}

IOHIDElementType IOHIDElementGetType(IOHIDElementRef element)
{
  return MEMORY[0x1F40E88A8](element);
}

CFTypeID IOHIDElementGetTypeID(void)
{
  return MEMORY[0x1F40E88B0]();
}

uint32_t IOHIDElementGetUnitExponent(IOHIDElementRef element)
{
  return MEMORY[0x1F40E88C0](element);
}

uint32_t IOHIDElementGetUsage(IOHIDElementRef element)
{
  return MEMORY[0x1F40E88C8](element);
}

uint32_t IOHIDElementGetUsagePage(IOHIDElementRef element)
{
  return MEMORY[0x1F40E88D0](element);
}

uint64_t IOHIDEventCreateAmbientLightSensorEvent()
{
  return MEMORY[0x1F40E88F8]();
}

uint64_t IOHIDEventCreateVendorDefinedEvent()
{
  return MEMORY[0x1F40E89A0]();
}

uint64_t IOHIDEventGetChildren()
{
  return MEMORY[0x1F40E89C8]();
}

uint64_t IOHIDEventGetDataValue()
{
  return MEMORY[0x1F40E89D0]();
}

uint64_t IOHIDEventGetDoubleValue()
{
  return MEMORY[0x1F40E89D8]();
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x1F40E89F8]();
}

uint64_t IOHIDEventGetIntegerValue()
{
  return MEMORY[0x1F40E8A00]();
}

uint64_t IOHIDEventGetTimeStamp()
{
  return MEMORY[0x1F40E8A28]();
}

uint64_t IOHIDEventGetType()
{
  return MEMORY[0x1F40E8A38]();
}

uint64_t IOHIDEventSetDoubleValue()
{
  return MEMORY[0x1F40E8A68]();
}

uint64_t IOHIDEventSetIntegerValue()
{
  return MEMORY[0x1F40E8A80]();
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  return (CFArrayRef)MEMORY[0x1F40E8AB8](client);
}

uint64_t IOHIDEventSystemClientCreate()
{
  return MEMORY[0x1F40E8AC0]();
}

uint64_t IOHIDEventSystemClientCreateWithType()
{
  return MEMORY[0x1F40E8AC8]();
}

uint64_t IOHIDEventSystemClientRegisterDeviceMatchingBlock()
{
  return MEMORY[0x1F40E8AD8]();
}

uint64_t IOHIDEventSystemClientRegisterEventBlock()
{
  return MEMORY[0x1F40E8AE8]();
}

uint64_t IOHIDEventSystemClientScheduleWithDispatchQueue()
{
  return MEMORY[0x1F40E8B18]();
}

uint64_t IOHIDEventSystemClientSetMatching()
{
  return MEMORY[0x1F40E8B38]();
}

uint64_t IOHIDEventSystemClientSetMatchingMultiple()
{
  return MEMORY[0x1F40E8B40]();
}

uint64_t IOHIDEventSystemClientUnregisterDeviceMatchingBlock()
{
  return MEMORY[0x1F40E8B50]();
}

uint64_t IOHIDEventSystemClientUnregisterEventBlock()
{
  return MEMORY[0x1F40E8B60]();
}

uint64_t IOHIDEventSystemClientUnscheduleFromDispatchQueue()
{
  return MEMORY[0x1F40E8B88]();
}

BOOLean_t IOHIDServiceClientConformsTo(IOHIDServiceClientRef service, uint32_t usagePage, uint32_t usage)
{
  return MEMORY[0x1F40E8D00](service, *(void *)&usagePage, *(void *)&usage);
}

uint64_t IOHIDServiceClientCopyEvent()
{
  return MEMORY[0x1F40E8D08]();
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40E8D20](service, key);
}

CFTypeRef IOHIDServiceClientGetRegistryID(IOHIDServiceClientRef service)
{
  return (CFTypeRef)MEMORY[0x1F40E8D40](service);
}

uint64_t IOHIDServiceClientRegisterRemovalBlock()
{
  return MEMORY[0x1F40E8D50]();
}

Boolean IOHIDServiceClientSetProperty(IOHIDServiceClientRef service, CFStringRef key, CFTypeRef property)
{
  return MEMORY[0x1F40E8D60](service, key, property);
}

void IOHIDTransactionAddElement(IOHIDTransactionRef transaction, IOHIDElementRef element)
{
}

IOReturn IOHIDTransactionCommit(IOHIDTransactionRef transaction)
{
  return MEMORY[0x1F40E8DD8](transaction);
}

IOHIDTransactionRef IOHIDTransactionCreate(CFAllocatorRef allocator, IOHIDDeviceRef device, IOHIDTransactionDirectionType direction, IOOptionBits options)
{
  return (IOHIDTransactionRef)MEMORY[0x1F40E8DE8](allocator, device, *(void *)&direction, *(void *)&options);
}

IOHIDValueRef IOHIDTransactionGetValue(IOHIDTransactionRef transaction, IOHIDElementRef element, IOOptionBits options)
{
  return (IOHIDValueRef)MEMORY[0x1F40E8DF8](transaction, element, *(void *)&options);
}

void IOHIDTransactionSetValue(IOHIDTransactionRef transaction, IOHIDElementRef element, IOHIDValueRef value, IOOptionBits options)
{
}

IOHIDValueRef IOHIDValueCreateWithIntegerValue(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, CFIndex value)
{
  return (IOHIDValueRef)MEMORY[0x1F40E8E80](allocator, element, timeStamp, value);
}

double_t IOHIDValueGetScaledValue(IOHIDValueRef value, IOHIDValueScaleType type)
{
  MEMORY[0x1F40E8EA8](value, *(void *)&type);
  return result;
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x1F40E8ED8](*(void *)&iterator);
}

uint64_t IOMobileFramebufferCreateDisplayList()
{
  return MEMORY[0x1F41249D0]();
}

uint64_t IOMobileFramebufferGetBlock()
{
  return MEMORY[0x1F4124A20]();
}

uint64_t IOMobileFramebufferGetMainDisplay()
{
  return MEMORY[0x1F4124A88]();
}

uint64_t IOMobileFramebufferGetServiceObject()
{
  return MEMORY[0x1F4124AB0]();
}

uint64_t IOMobileFramebufferOpenByName()
{
  return MEMORY[0x1F4124AE0]();
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x1F40E8F08](*(void *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return MEMORY[0x1F40E8F38](*(void *)&object, className);
}

CFStringRef IOObjectCopyClass(io_object_t object)
{
  return (CFStringRef)MEMORY[0x1F40E8F40](*(void *)&object);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1F40E8F60](*(void *)&object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return MEMORY[0x1F40E8F68](*(void *)&object);
}

uint64_t IOPMCopyUserActivityLevelDescription()
{
  return MEMORY[0x1F40E9020]();
}

uint64_t IOPMScheduleUserActiveChangedNotification()
{
  return MEMORY[0x1F40E9068]();
}

uint64_t IOPMScheduleUserActivityLevelNotificationWithTimeout()
{
  return MEMORY[0x1F40E9078]();
}

uint64_t IOPMSetUserActivityIdleTimeout()
{
  return MEMORY[0x1F40E9098]();
}

uint64_t IOPMUnregisterNotification()
{
  return MEMORY[0x1F40E90B0]();
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1F40E9168](*(void *)&entry, key, allocator, *(void *)&options);
}

kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t *entryID)
{
  return MEMORY[0x1F40E91F8](*(void *)&entry, entryID);
}

CFMutableDictionaryRef IORegistryEntryIDMatching(uint64_t entryID)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40E9200](entryID);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1F40E9208](*(void *)&entry, plane, key, allocator, *(void *)&options);
}

kern_return_t IORegistryEntrySetCFProperties(io_registry_entry_t entry, CFTypeRef properties)
{
  return MEMORY[0x1F40E9218](*(void *)&entry, properties);
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  return MEMORY[0x1F40E9220](*(void *)&entry, propertyName, property);
}

uint64_t IOReportChannelGetChannelName()
{
  return MEMORY[0x1F417A738]();
}

uint64_t IOReportCopyChannelsInGroup()
{
  return MEMORY[0x1F417A780]();
}

uint64_t IOReportCopyChannelsWithID()
{
  return MEMORY[0x1F417A788]();
}

uint64_t IOReportCreateSamples()
{
  return MEMORY[0x1F417A798]();
}

uint64_t IOReportCreateSubscription()
{
  return MEMORY[0x1F417A7A8]();
}

uint64_t IOReportIterate()
{
  return MEMORY[0x1F417A7D0]();
}

uint64_t IOReportSimpleGetIntegerValue()
{
  return MEMORY[0x1F417A7F8]();
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x1F40E9230](notifyPort, *(void *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x1F40E9238](notifyPort, notificationType, matching, callback, refCon, notification);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x1F40E9250](*(void *)&mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x1F40E9258](*(void *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40E9268](name);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1F417CDE0]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1F417CE00]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1F417CE28]();
}

uint64_t MGIsDeviceOfType()
{
  return MEMORY[0x1F417CE40]();
}

uint64_t MGIsDeviceOneOfType()
{
  return MEMORY[0x1F417CE48]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1F40E7010](aClassName);
}

void NSLog(NSString *format, ...)
{
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1F40E7280](aClass);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

uint64_t _IOHIDElementSetValue()
{
  return MEMORY[0x1F40E92A0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

uint64_t std::__sort<std::__less<float,float> &,float *>()
{
  return MEMORY[0x1F417EC40]();
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1F40C9B60](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1F40C9C38]();
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return MEMORY[0x1F40C9CA0](a1, *(void *)&a2, a3, a4);
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1F40C9CD8]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

float atan2f(float a1, float a2)
{
  MEMORY[0x1F40CA468](a1, a2);
  return result;
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1F40CA4F8](a1, *(void *)&a2);
}

void bzero(void *a1, size_t a2)
{
}

float cosf(float a1)
{
  MEMORY[0x1F40CB8B0](a1);
  return result;
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C8](flags, *(void *)&qos_class, *(void *)&relative_priority, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBD0](label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x1F40CBD58](label);
}

uint64_t dispatch_workloop_set_scheduler_priority()
{
  return MEMORY[0x1F40CBD88]();
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

float expf(float a1)
{
  MEMORY[0x1F40CBFF8](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

void free(void *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1F40CC700]();
}

long double log10(long double __x)
{
  MEMORY[0x1F40CC880](__x);
  return result;
}

float log2f(float a1)
{
  MEMORY[0x1F40CC8B0](a1);
  return result;
}

float logf(float a1)
{
  MEMORY[0x1F40CC8C0](a1);
  return result;
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x1F40CC930]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1F40CC940](*(void *)&error_value);
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1F40CC970](msg, *(void *)&option, *(void *)&send_size, *(void *)&rcv_size, *(void *)&rcv_name, *(void *)&timeout, *(void *)&notify);
}

mach_msg_return_t mach_msg_receive(mach_msg_header_t *a1)
{
  return MEMORY[0x1F40CC988](a1);
}

mach_msg_return_t mach_msg_send(mach_msg_header_t *a1)
{
  return MEMORY[0x1F40CC990](a1);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x1F40CC9A0](*(void *)&task, *(void *)&right, name);
}

kern_return_t mach_port_get_attributes(ipc_space_read_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return MEMORY[0x1F40CC9E0](*(void *)&task, *(void *)&name, *(void *)&flavor, port_info_out, port_info_outCnt);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x1F40CCA08](*(void *)&task, *(void *)&name, *(void *)&poly, *(void *)&polyPoly);
}

kern_return_t mach_port_set_attributes(ipc_space_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info, mach_msg_type_number_t port_infoCnt)
{
  return MEMORY[0x1F40CCA30](*(void *)&task, *(void *)&name, *(void *)&flavor, port_info, *(void *)&port_infoCnt);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1F40CCDD0](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1F40CD040](*(void *)&token, state64);
}

BOOL notify_is_valid_token(int val)
{
  return MEMORY[0x1F40CD048](*(void *)&val);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1F40CD050](name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x1F40CD058](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return MEMORY[0x1F40CD088](*(void *)&token, state64);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_throw(id exception)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C8](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1F4181A28](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1F4181A30](obj);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1F40CD558](log);
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x1F40CD818](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x1F40CD828](a1, a2);
  return result;
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD918](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1F40CD930](a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1F40CD940](a1, *(void *)&a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1F40CD9B8](a1, a2, a3, a4);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1F40CDA80](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1F40CDAC8](a1, a2);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

float sinf(float a1)
{
  MEMORY[0x1F40CE060](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE258](__s1, __s2);
}

float strtof(const char *a1, char **a2)
{
  MEMORY[0x1F40CE270](a1, a2);
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1F40CE2A0](__str, __endptr, *(void *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1F40CE3C0](a1, *(void *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1F40CE3D0](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1F40CE608](*(void *)&a1);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
}

void xpc_activity_unregister(const char *identifier)
{
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEE20](keys, values, count);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_release(xpc_object_t object)
{
}