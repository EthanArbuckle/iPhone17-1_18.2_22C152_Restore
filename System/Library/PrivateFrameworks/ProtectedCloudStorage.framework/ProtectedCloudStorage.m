__CFString *PCSServiceItemGetCKKSViewByName(void *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = PCSServiceItemGetByName(a1);
  if (!v1) {
    return 0;
  }
  v2 = *(void *)(v1 + 48);
  if (v2 && CFStringHasPrefix(*(CFStringRef *)(v1 + 48), @"PCS-")) {
    return @"ProtectedCloudStorage";
  }
  return (__CFString *)v2;
}

uint64_t PCSServiceItemTypeIsManatee(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result)
  {
    uint64_t v2 = result;
    return !CFEqual(*(CFTypeRef *)(result + 16), @"Raw") && *(unsigned char *)(v2 + 74) != 0;
  }
  return result;
}

uint64_t PCSServiceItemGetByName(void *key)
{
  if (!key) {
    return 0;
  }
  if (PCSServiceItemsInit_once != -1) {
    dispatch_once(&PCSServiceItemsInit_once, &__block_literal_global_91);
  }
  uint64_t v5 = 0;
  v6 = &v5;
  uint64_t v7 = 0x2020000000;
  Value = 0;
  Value = CFDictionaryGetValue((CFDictionaryRef)PCSServiceItemsInit_localServiceItems, key);
  uint64_t v2 = v6[3];
  if (!v2)
  {
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 3221225472;
    v4[2] = __PCSServiceItemGetByName_block_invoke;
    v4[3] = &unk_1E5E6ECD8;
    v4[4] = &v5;
    v4[5] = key;
    PCSServiceItemsIterate(v4);
    uint64_t v2 = v6[3];
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1ACF99884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __PCSServiceItemsInit_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  PCSServiceItemsInit_localServiceItems = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFURLRef v1 = CFURLCreateWithFileSystemPath(v0, @"/System/Library/Preferences/ProtectedCloudStorage/Identities", kCFURLPOSIXPathStyle, 1u);
  uint64_t v9 = 0;
  CFURLRef url = 0;
  uint64_t v2 = (const void *)MEMORY[0x1AD11C260](v0, v1, 2, 0);
  do
  {
    while (1)
    {
      uint64_t v3 = MEMORY[0x1AD11C270](v2, &url, 0);
      if (v3 != 1) {
        break;
      }
      CFStringRef v4 = CFURLCopyPathExtension(url);
      if (CFEqual(v4, @"plist"))
      {
        uint64_t v5 = CFReadStreamCreateWithFile(v0, url);
        if (v5)
        {
          v6 = v5;
          if (CFReadStreamOpen(v5))
          {
            CFDictionaryRef v7 = (const __CFDictionary *)CFPropertyListCreateWithStream(v0, v6, 0, 0, (CFPropertyListFormat *)&v9, 0);
            if (v7)
            {
              CFDictionaryRef v8 = v7;
              __PCSServiceItemsInit_block_invoke_2((int)v7, v7);
              CFRelease(v8);
            }
          }
          CFRelease(v6);
        }
      }
      if (v4) {
        CFRelease(v4);
      }
    }
  }
  while (v3 != 2);
  if (v2) {
    CFRelease(v2);
  }
  if (v1) {
    CFRelease(v1);
  }
}

void __PCSServiceItemsInit_block_invoke_2(int a1, CFDictionaryRef theDict)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"ServiceName");
  CFStringRef cf = (const __CFString *)CFDictionaryGetValue(theDict, @"OldName");
  CFNumberRef v4 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"ServiceNumber");
  CFStringRef v5 = (const __CFString *)CFDictionaryGetValue(theDict, @"ViewHint");
  CFStringRef v6 = (const __CFString *)CFDictionaryGetValue(theDict, @"KCItemClass");
  CFStringRef v7 = (const __CFString *)CFDictionaryGetValue(theDict, @"KeyDescription");
  CFDictionaryRef v8 = CFDictionaryGetValue(theDict, @"Classic7");
  uint64_t v9 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (v8) {
    BOOL v58 = CFEqual(v8, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
  }
  else {
    BOOL v58 = 0;
  }
  v10 = CFDictionaryGetValue(theDict, @"RollIdentity");
  if (v10) {
    BOOL v62 = CFEqual(v10, *v9) != 0;
  }
  else {
    BOOL v62 = 0;
  }
  v11 = CFDictionaryGetValue(theDict, @"Manatee");
  if (v11) {
    BOOL v61 = CFEqual(v11, *v9) != 0;
  }
  else {
    BOOL v61 = 0;
  }
  v12 = CFDictionaryGetValue(theDict, @"Authorship");
  if (v12) {
    BOOL v57 = CFEqual(v12, *v9) != 0;
  }
  else {
    BOOL v57 = 0;
  }
  v13 = CFDictionaryGetValue(theDict, @"Escrow");
  if (v13) {
    BOOL v60 = CFEqual(v13, *v9) != 0;
  }
  else {
    BOOL v60 = 0;
  }
  v14 = CFDictionaryGetValue(theDict, @"AllowKeyExport");
  if (v14) {
    BOOL v15 = CFEqual(v14, *v9) != 0;
  }
  else {
    BOOL v15 = 0;
  }
  v16 = CFDictionaryGetValue(theDict, @"AnonymousSharing");
  if (v16) {
    BOOL v17 = CFEqual(v16, *v9) != 0;
  }
  else {
    BOOL v17 = 0;
  }
  v18 = CFDictionaryGetValue(theDict, @"ManateeSharing");
  CFStringRef v63 = v7;
  if (v18) {
    BOOL v19 = CFEqual(v18, *v9) != 0;
  }
  else {
    BOOL v19 = 0;
  }
  CFNumberRef number = (const __CFNumber *)CFDictionaryGetValue(theDict, @"RollInterval");
  CFStringRef v20 = (const __CFString *)CFDictionaryGetValue(theDict, @"AccessGroup");
  CFAllocatorRef v21 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  PCSServiceItemGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v23 = Instance;
  if (!Instance) {
    goto LABEL_80;
  }
  CFStringRef v56 = v20;
  *(_OWORD *)(Instance + 32) = 0u;
  *(void *)(Instance + 16) = 0;
  *(_WORD *)(Instance + 72) = 256;
  *(_OWORD *)(Instance + 48) = 0u;
  *(void *)(Instance + 24) = 0x3B538000000000;
  *(void *)(Instance + 64) = 0;
  *(void *)(Instance + 88) = 0;
  *(void *)(Instance + 74) = 0;
  *(_WORD *)(Instance + 82) = 0;
  if (Value)
  {
    CFNumberRef v55 = v4;
    BOOL v24 = v17;
    CFStringRef v25 = v5;
    CFStringRef v26 = v6;
    CFTypeID v27 = CFGetTypeID(Value);
    if (v27 == CFStringGetTypeID()) {
      CFStringRef Copy = CFStringCreateCopy(v21, Value);
    }
    else {
      CFStringRef Copy = 0;
    }
    CFStringRef v6 = v26;
    CFStringRef v5 = v25;
    BOOL v17 = v24;
    CFNumberRef v4 = v55;
  }
  else
  {
    CFStringRef Copy = 0;
  }
  *(void *)(v23 + 16) = Copy;
  if (v4)
  {
    BOOL v29 = v15;
    CFStringRef v30 = v6;
    LODWORD(valuePtr) = 0;
    CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr);
    *(_DWORD *)(v23 + 24) = valuePtr;
    CFTypeID v31 = CFGetTypeID(v4);
    if (v31 == CFNumberGetTypeID())
    {
      uint64_t v65 = 0;
      CFNumberGetValue(v4, kCFNumberCFIndexType, &v65);
      uint64_t valuePtr = v65;
      CFNumberRef v32 = CFNumberCreate(v21, kCFNumberCFIndexType, &valuePtr);
    }
    else
    {
      CFNumberRef v32 = 0;
    }
    CFStringRef v6 = v30;
    BOOL v15 = v29;
  }
  else
  {
    CFNumberRef v32 = 0;
    *(_DWORD *)(v23 + 24) = 0;
  }
  *(void *)(v23 + 32) = v32;
  if (cf && (CFTypeID v33 = CFGetTypeID(cf), v33 == CFStringGetTypeID())) {
    CFStringRef v34 = CFStringCreateCopy(v21, cf);
  }
  else {
    CFStringRef v34 = 0;
  }
  *(void *)(v23 + 40) = v34;
  if (v5 && (CFStringRef v35 = v5, v36 = CFGetTypeID(v5), v36 == CFStringGetTypeID())) {
    CFStringRef v37 = CFStringCreateCopy(v21, v35);
  }
  else {
    CFStringRef v37 = 0;
  }
  *(void *)(v23 + 48) = v37;
  if (!v6 || (CFTypeID v38 = CFGetTypeID(v6), v38 != CFStringGetTypeID()) || (v39 = CFStringCreateCopy(v21, v6)) == 0)
  {
    CFStringRef v41 = (const __CFString *)*MEMORY[0x1E4F3B570];
    goto LABEL_53;
  }
  CFStringRef v40 = v39;
  CFStringRef v41 = (const __CFString *)*MEMORY[0x1E4F3B570];
  if (!CFEqual(v39, (CFTypeRef)*MEMORY[0x1E4F3B570]) && !CFEqual(v40, (CFTypeRef)*MEMORY[0x1E4F3B5B0]))
  {
    CFRelease(v40);
LABEL_53:
    CFStringRef v40 = CFStringCreateCopy(v21, v41);
  }
  *(void *)(v23 + 56) = v40;
  *(unsigned char *)(v23 + 72) = v58;
  *(unsigned char *)(v23 + 77) = v60;
  *(unsigned char *)(v23 + 78) = v15;
  *(unsigned char *)(v23 + 79) = v17;
  if (number)
  {
    LODWORD(valuePtr) = 0;
    CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
    int v42 = valuePtr;
  }
  else
  {
    int v42 = 0;
  }
  if (v62) {
    int v43 = 3888000;
  }
  else {
    int v43 = -99;
  }
  BOOL v44 = v42 <= 0;
  char v45 = v42 > 0 || v62;
  *(unsigned char *)(v23 + 73) = v45;
  int v46 = 60 * v42;
  if (v44) {
    int v46 = v43;
  }
  *(_DWORD *)(v23 + 28) = v46;
  *(unsigned char *)(v23 + 74) = v61;
  *(unsigned char *)(v23 + 75) = v19;
  *(unsigned char *)(v23 + 76) = v61 || v57;
  if (v63 && (CFTypeID v47 = CFGetTypeID(v63), v47 == CFStringGetTypeID())) {
    CFStringRef v48 = CFStringCreateCopy(v21, v63);
  }
  else {
    CFStringRef v48 = 0;
  }
  *(void *)(v23 + 64) = v48;
  if (v61) {
    int v49 = 4;
  }
  else {
    int v49 = 0;
  }
  if (v19) {
    v49 |= 8u;
  }
  *(_DWORD *)(v23 + 80) = v49;
  if (v56 && (CFTypeID v50 = CFGetTypeID(v56), v50 == CFStringGetTypeID())) {
    CFStringRef v51 = CFStringCreateCopy(v21, v56);
  }
  else {
    CFStringRef v51 = 0;
  }
  *(void *)(v23 + 88) = v51;
LABEL_80:
  v52 = *(const void **)(v23 + 16);
  if (v52)
  {
    if (CFEqual(v52, @"Raw") && *(void *)(v23 + 32))
    {
      CFStringRef v53 = *(const __CFString **)(v23 + 16);
      goto LABEL_87;
    }
    CFStringRef v53 = *(const __CFString **)(v23 + 16);
    if (v53 && *(void *)(v23 + 32) && *(void *)(v23 + 48))
    {
LABEL_87:
      CFStringRef v54 = CFStringCreateCopy(v21, v53);
      CFDictionaryAddValue((CFMutableDictionaryRef)PCSServiceItemsInit_localServiceItems, v54, (const void *)v23);
      CFRelease((CFTypeRef)v23);
      uint64_t v23 = (uint64_t)v54;
      if (!v54) {
        return;
      }
    }
  }
  CFRelease((CFTypeRef)v23);
}

uint64_t PCSServiceItemGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __PCSServiceItemGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &PCSServiceItemGetTypeID_sPCSServiceItemGetTypeIDSingleton;
  if (PCSServiceItemGetTypeID_sPCSServiceItemGetTypeIDOnce != -1) {
    dispatch_once(&PCSServiceItemGetTypeID_sPCSServiceItemGetTypeIDOnce, block);
  }
  return PCSServiceItemGetTypeID_sPCSServiceItemGetTypeIDSingleton;
}

uint64_t __PCSServiceItemGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t PCSPEMReaderGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __PCSPEMReaderGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp;
  block[4] = &PCSPEMReaderGetTypeID_sPCSPEMReaderGetTypeIDSingleton;
  if (PCSPEMReaderGetTypeID_sPCSPEMReaderGetTypeIDOnce != -1) {
    dispatch_once(&PCSPEMReaderGetTypeID_sPCSPEMReaderGetTypeIDOnce, block);
  }
  return PCSPEMReaderGetTypeID_sPCSPEMReaderGetTypeIDSingleton;
}

uint64_t __PCSPEMReaderGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void PCSPEMReaderDestroy(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[5];
  if (v3)
  {
    a1[5] = 0;
    CFRelease(v3);
  }
  CFNumberRef v4 = (const void *)a1[6];
  if (v4)
  {
    a1[6] = 0;
    CFRelease(v4);
  }
  CFStringRef v5 = (const void *)a1[7];
  if (v5)
  {
    a1[7] = 0;
    CFRelease(v5);
  }
  CFStringRef v6 = (const void *)a1[10];
  if (v6)
  {
    a1[10] = 0;
    CFRelease(v6);
  }
  CFStringRef v7 = (const void *)a1[2];
  if (v7)
  {
    a1[2] = 0;
    CFRelease(v7);
  }
  CFDictionaryRef v8 = (const void *)a1[8];
  if (v8)
  {
    a1[8] = 0;
    CFRelease(v8);
  }
}

BOOL PCSPEMReaderCompare(const void *a1, const void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != PCSPEMReaderGetTypeID()) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  return v5 == PCSPEMReaderGetTypeID() && a1 == a2;
}

CFStringRef PCSPEMReaderCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, @"<PCSPEMReader@%p>", a1);
}

void *PCSPEMReaderCreate(const void *a1)
{
  PCSPEMReaderGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[2] = CFRetain(a1);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  Instance[3] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], 0);
  CFTypeID v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  Instance[6] = CFDictionaryCreateMutable(0, 0, v3, MEMORY[0x1E4F1D540]);
  Instance[7] = CFDictionaryCreateMutable(0, 0, v3, v4);
  Instance[5] = 0;
  Instance[8] = CFDataCreateMutable(0, 0);
  Instance[9] = CFDataCreateMutable(0, 0);
  Instance[10] = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  Instance[12] = PEMStateBefore;
  return Instance;
}

uint64_t PEMStateBefore(uint64_t a1)
{
  if (PEMStateBefore_onceToken != -1) {
    dispatch_once(&PEMStateBefore_onceToken, &__block_literal_global);
  }
  CFDataRef Line = (const __CFData *)getLine(a1);
  if (Line)
  {
    CFDataRef v3 = Line;
    CFDataRef v4 = (const __CFData *)PEMMarkerBegin;
    v11.length = CFDataGetLength(Line);
    v11.CFIndex location = 0;
    if (CFDataFind(v3, v4, v11, 2uLL).location != -1)
    {
      CFDataRef v5 = (const __CFData *)PEMMarkerBeginEnd;
      v12.length = CFDataGetLength(v3);
      v12.CFIndex location = 11;
      CFIndex location = CFDataFind(v3, v5, v12, 0).location;
      if ((unint64_t)(location + 1) <= 1)
      {
        CFRelease(v3);
        uint64_t result = 0;
        *(void *)(a1 + 96) = PEMStateError;
        return result;
      }
      CFIndex v8 = location;
      uint64_t v9 = *(const void **)(a1 + 40);
      if (v9)
      {
        *(void *)(a1 + 40) = 0;
        CFRelease(v9);
      }
      BytePtr = CFDataGetBytePtr(v3);
      *(void *)(a1 + 40) = CFStringCreateWithBytes(0, BytePtr + 11, v8 - 11, 0x8000100u, 0);
      *(void *)(a1 + 96) = PEMStateSearchHeaders;
    }
    CFRelease(v3);
    return 1;
  }
  else
  {
    uint64_t result = 0;
    if (*(unsigned char *)(a1 + 89)) {
      *(unsigned char *)(a1 + 88) = 1;
    }
  }
  return result;
}

void PCSPEMReaderAddParser(uint64_t a1, const void *a2, const void *a3)
{
}

void PCSPEMReaderSetParameter(uint64_t a1, const void *a2, const void *a3)
{
}

const void *PCSPEMReaderGetParameter(uint64_t a1, const void *a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
}

uint64_t PCSPEMReaderRun(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  while (1)
  {
    if (*(unsigned char *)(a1 + 89)) {
      goto LABEL_7;
    }
    CFIndex v2 = CFReadStreamRead(*(CFReadStreamRef *)(a1 + 16), v4, 1000);
    if (v2 < 0) {
      return 0;
    }
    if (v2) {
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 64), v4, v2);
    }
    else {
      *(unsigned char *)(a1 + 89) = 1;
    }
LABEL_7:
    while (((*(uint64_t (**)(uint64_t))(a1 + 96))(a1) & 1) != 0)
      ;
    if (*(unsigned char *)(a1 + 88)) {
      return 1;
    }
  }
}

uint64_t PCSPEMReaderGetResult(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

CFDataRef __PEMStateBefore_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  PEMMarkerBegin = (uint64_t)CFDataCreateWithBytesNoCopy(0, (const UInt8 *)"-----BEGIN ", 11, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  PEMMarkerBeginEnd = (uint64_t)CFDataCreateWithBytesNoCopy(0, (const UInt8 *)"-----", 5, v0);
  PEMMarkerEnd = (uint64_t)CFDataCreateWithBytesNoCopy(0, (const UInt8 *)"-----END ", 9, v0);
  PEMMarkerHeader = (uint64_t)CFDataCreateWithBytesNoCopy(0, (const UInt8 *)": ", 2, v0);
  CFDataRef result = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)"\n", 1, v0);
  PEMMarkerNewline = (uint64_t)result;
  return result;
}

CFIndex getLine(uint64_t a1)
{
  CFIndex result = *(void *)(a1 + 32);
  if (result)
  {
    *(void *)(a1 + 32) = 0;
    return result;
  }
  if (!*(unsigned char *)(a1 + 89) || (CFIndex result = CFDataGetLength(*(CFDataRef *)(a1 + 64))) != 0)
  {
    CFDataRef v3 = *(const __CFData **)(a1 + 64);
    CFDataRef v4 = (const __CFData *)PEMMarkerNewline;
    v13.length = CFDataGetLength(v3);
    v13.CFIndex location = 0;
    CFIndex location = CFDataFind(v3, v4, v13, 0).location;
    if (location == -1)
    {
      if (!*(unsigned char *)(a1 + 89)) {
        return 0;
      }
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 64));
      uint64_t v7 = 0;
    }
    else
    {
      CFIndex Length = location;
      uint64_t v7 = 1;
    }
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 64));
    if (Length)
    {
      int v9 = BytePtr[Length - 1];
      BOOL v10 = v9 == 13;
      if (v9 == 13) {
        --Length;
      }
    }
    else
    {
      BOOL v10 = 0;
    }
    CFDataRef v11 = CFDataCreate(0, BytePtr, Length);
    v12.length = v10 + v7 + Length;
    v12.CFIndex location = 0;
    CFDataDeleteBytes(*(CFMutableDataRef *)(a1 + 64), v12);
    return (CFIndex)v11;
  }
  return result;
}

void PEMStateError()
{
}

BOOL PEMStateSearchHeaders(uint64_t a1)
{
  CFDataRef Line = (const __CFData *)getLine(a1);
  CFDataRef v3 = Line;
  if (Line)
  {
    CFDataRef v4 = (const __CFData *)PEMMarkerHeader;
    v11.length = CFDataGetLength(Line);
    v11.CFIndex location = 0;
    CFRange v5 = CFDataFind(v3, v4, v11, 0);
    if (v5.location == -1)
    {
      *(void *)(a1 + 96) = PEMStateInData;
      *(void *)(a1 + 32) = v3;
    }
    else
    {
      BytePtr = CFDataGetBytePtr(v3);
      CFStringRef v7 = CFStringCreateWithBytes(0, BytePtr, v5.location, 0x8000100u, 0);
      CFIndex Length = CFDataGetLength(v3);
      CFStringRef v9 = CFStringCreateWithBytes(0, &BytePtr[v5.location + v5.length], Length - (v5.location + v5.length), 0x8000100u, 0);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), v7, v9);
      CFRelease(v7);
      CFRelease(v9);
      CFRelease(v3);
    }
  }
  return v3 != 0;
}

CFIndex PEMStateInData(uint64_t a1)
{
  CFIndex result = getLine(a1);
  if (!result) {
    return result;
  }
  CFDataRef v3 = (const __CFData *)result;
  CFDataRef v4 = (const __CFData *)PEMMarkerEnd;
  v26.length = CFDataGetLength((CFDataRef)result);
  v26.CFIndex location = 0;
  if (CFDataFind(v3, v4, v26, 2uLL).location != -1)
  {
    *(void *)(a1 + 96) = PEMStateDone;
    CFDataRef v5 = v3;
    goto LABEL_4;
  }
  CFIndex Length = CFDataGetLength(v3);
  if ((Length & 3) != 0)
  {
    CFDataRef v7 = v3;
LABEL_7:
    CFRelease(v7);
    return 0;
  }
  uint64_t v8 = Length;
  CFIndex v9 = 3 * (Length / 4);
  Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v9);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (v8 < 1) {
    goto LABEL_30;
  }
  CFRange v12 = MutableBytePtr;
  CFIndex v13 = 0;
  uint64_t v14 = 0;
  do
  {
    while (1)
    {
      v25.CFIndex location = v13;
      v25.length = 4;
      CFDataGetBytes(v3, v25, buffer);
      uint64_t v15 = 0;
      int v16 = 0;
      int v17 = 0;
      do
      {
        v17 <<= 6;
        uint64_t v18 = buffer[v15];
        if (v18 == 61)
        {
          ++v16;
        }
        else
        {
          if (v16 >= 1) {
            goto LABEL_34;
          }
          v17 += tokenDecode_base64_chars_inverted[v18];
        }
        ++v15;
      }
      while (v15 != 4);
      if (v16 >= 3) {
LABEL_34:
      }
        abort();
      unsigned int v19 = v17 | (v16 << 24);
      if (v19 == -1) {
        PEMStateInData_cold_1(Mutable);
      }
      uint64_t v20 = HIBYTE(v19);
      if (v20)
      {
        if (v13 + 4 != v8)
        {
          printf("%d %d %d\n", HIBYTE(v19), v14, v8);
          abort();
        }
      }
      UInt8 *v12 = BYTE2(v17);
      if (v19 >> 25)
      {
        ++v14;
        CFIndex v13 = 4 * v14;
        ++v12;
        goto LABEL_28;
      }
      v12[1] = BYTE1(v17);
      if (v20) {
        break;
      }
      v12[2] = v17;
      v12 += 3;
      ++v14;
      CFIndex v13 = 4 * v14;
      if (4 * v14 >= v8) {
        goto LABEL_30;
      }
    }
    v12 += 2;
    ++v14;
    CFIndex v13 = 4 * v14;
LABEL_28:
    ;
  }
  while (v13 < v8);
  CFDataSetLength(Mutable, v9 - v20);
LABEL_30:
  CFRelease(v3);
  if (!Mutable) {
    return 0;
  }
  if (!CFDataGetLength(Mutable))
  {
    CFDataRef v7 = Mutable;
    goto LABEL_7;
  }
  CFAllocatorRef v21 = *(__CFData **)(a1 + 72);
  BytePtr = CFDataGetBytePtr(Mutable);
  CFIndex v23 = CFDataGetLength(Mutable);
  CFDataAppendBytes(v21, BytePtr, v23);
  CFDataRef v5 = Mutable;
LABEL_4:
  CFRelease(v5);
  return 1;
}

uint64_t PEMStateDone(uint64_t a1)
{
  CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), *(const void **)(a1 + 40));
  if (Value || (CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"ANY")) != 0)
  {
    CFDataRef v3 = (const void *)((uint64_t (*)(uint64_t, void, void, void))Value)(a1, *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 72));
    if (v3)
    {
      CFDataRef v4 = v3;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), v3);
      CFRelease(v4);
    }
  }
  CFDataRef v5 = *(const void **)(a1 + 40);
  if (v5)
  {
    *(void *)(a1 + 40) = 0;
    CFRelease(v5);
  }
  CFStringRef v6 = *(const void **)(a1 + 48);
  if (v6)
  {
    *(void *)(a1 + 48) = 0;
    CFRelease(v6);
  }
  *(void *)(a1 + 48) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDataRef v7 = *(const void **)(a1 + 72);
  if (v7)
  {
    *(void *)(a1 + 72) = 0;
    CFRelease(v7);
  }
  *(void *)(a1 + 72) = CFDataCreateMutable(0, 0);
  *(void *)(a1 + 96) = PEMStateBefore;
  return 1;
}

uint64_t PCSIdentityRollIdentity(uint64_t a1, void *cf1, const void **a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (CFEqual(cf1, kPCSServiceMaster))
  {
    CFStringRef v6 = _PCSIdentitySetCopyCurrentIdentityInternal(a1, kPCSServiceMaster, a3);
    if (v6)
    {
      CFDataRef v7 = v6;
      CFTypeRef Master = PCSIdentityCreateMaster((uint64_t)v6, a3);
      if (Master)
      {
        CFIndex v9 = Master;
        if ((PCSIdentitySetAddIdentity(a1, (uint64_t)Master) & 1) == 0)
        {
LABEL_32:
          uint64_t v10 = 0;
          goto LABEL_7;
        }
        goto LABEL_5;
      }
      goto LABEL_36;
    }
    return 0;
  }
  if (!CFEqual(cf1, kPCSServiceEscrow) && !CFEqual(cf1, kPCSServiceFDE))
  {
    CFIndex v13 = _PCSIdentitySetCopyCurrentIdentityInternal(a1, kPCSServiceMaster, a3);
    if (v13)
    {
      CFDataRef v7 = v13;
      int IsManatee = PCSServiceItemTypeIsManatee(cf1);
      uint64_t v15 = pcsLogObjForScope("keyRoll");
      BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
      if (IsManatee)
      {
        if (v16)
        {
          int v22 = 138412290;
          CFIndex v23 = cf1;
          _os_log_impl(&dword_1ACF98000, v15, OS_LOG_TYPE_DEFAULT, "Asked to roll key for Manatee Service Identity %@", (uint8_t *)&v22, 0xCu);
        }
        char v17 = 5;
      }
      else
      {
        if (v16)
        {
          int v22 = 138412290;
          CFIndex v23 = cf1;
          _os_log_impl(&dword_1ACF98000, v15, OS_LOG_TYPE_DEFAULT, "Asked to roll key for Non-Manatee Service Identity %@", (uint8_t *)&v22, 0xCu);
        }
        char v17 = 1;
      }

      Service = PCSIdentityCreateService((uint64_t)v7, v17, cf1, a3);
      if (Service)
      {
        CFIndex v9 = Service;
        if ((PCSIdentitySetAddIdentityWithError(a1, (uint64_t)Service, a3) & 1) == 0)
        {
          unsigned int v19 = pcsLogObjForScope("keyRoll");
          if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
LABEL_31:

            goto LABEL_32;
          }
          int v22 = 138412290;
          CFIndex v23 = cf1;
          uint64_t v20 = "Failed to add new key for Service Identity %@";
LABEL_30:
          _os_log_impl(&dword_1ACF98000, v19, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v22, 0xCu);
          goto LABEL_31;
        }
LABEL_5:
        if (PCSIdentitySetSetCurrentIdentity(a1, (uint64_t)v9))
        {
          uint64_t v10 = 1;
LABEL_7:
          CFRelease(v9);
LABEL_8:
          CFRelease(v7);
          return v10;
        }
        unsigned int v19 = pcsLogObjForScope("keyRoll");
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_31;
        }
        int v22 = 138412290;
        CFIndex v23 = cf1;
        uint64_t v20 = "Failed to set new key as current for Service Identity %@";
        goto LABEL_30;
      }
      CFAllocatorRef v21 = pcsLogObjForScope("keyRoll");
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = 138412290;
        CFIndex v23 = cf1;
        _os_log_impl(&dword_1ACF98000, v21, OS_LOG_TYPE_DEFAULT, "Failed to create key for Service Identity %@", (uint8_t *)&v22, 0xCu);
      }

LABEL_36:
      uint64_t v10 = 0;
      goto LABEL_8;
    }
    return 0;
  }
  CFRange v11 = pcsLogObjForScope("keyRoll");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = 138412290;
    CFIndex v23 = cf1;
    _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, "Skipping Rolling Service Identity for %@", (uint8_t *)&v22, 0xCu);
  }

  return 1;
}

void PCSTapToRadar(void *a1, char a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a3;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    id v21 = v5;
    __int16 v22 = 2112;
    id v23 = v6;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCS Triggering TTR: %@: %@", buf, 0x16u);
  }
  CFDataRef v7 = (void *)MEMORY[0x1AD11CE50]();
  if (_PCSIsInternalRelease() && !pendingTTREvent)
  {
    if ((a2 & 1) == 0)
    {
      uint64_t v8 = (void *)CFPreferencesCopyAppValue((CFStringRef)kPCSNextTTRDate, (CFStringRef)kPCSPreferenceDomain);
      if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      {
        CFIndex v9 = [MEMORY[0x1E4F1C9C8] date];
        uint64_t v10 = [v8 compare:v9];

        if (v10 != -1) {
          goto LABEL_14;
        }
      }
      else
      {
      }
    }
    CFStringRef v11 = (const __CFString *)kPCSNextTTRDate;
    CFRange v12 = (const void *)[MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceNow:86400.0];
    CFPreferencesSetAppValue(v11, v12, (CFStringRef)kPCSPreferenceDomain);
    CFPreferencesAppSynchronize((CFStringRef)kPCSPreferenceDomain);
    uint64_t v13 = *MEMORY[0x1E4F1D9D0];
    v18[0] = *MEMORY[0x1E4F1D9E0];
    v18[1] = v13;
    v19[0] = @"Tap-To-Radar";
    v19[1] = @"Go away";
    uint64_t v14 = *MEMORY[0x1E4F1D990];
    v18[2] = *MEMORY[0x1E4F1D9A8];
    v18[3] = v14;
    v19[2] = v5;
    v19[3] = @"PCS";
    CFDictionaryRef v15 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v19 forKeys:v18 count:4];
    objc_storeStrong((id *)&pendingTTREvent, a3);
    *(_DWORD *)buf = 0;
    CFUserNotificationRef v16 = CFUserNotificationCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0.0, 3uLL, (SInt32 *)buf, v15);
    if (v16)
    {
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __PCSTapToRadar_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = v16;
      dispatch_async(MEMORY[0x1E4F14428], block);
    }
  }
LABEL_14:
}

void __PCSTapToRadar_block_invoke(uint64_t a1)
{
  CFRunLoopSourceRef RunLoopSource = CFUserNotificationCreateRunLoopSource((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFUserNotificationRef *)(a1 + 32), (CFUserNotificationCallBack)PCSTTRUserNotificationCallback, 0);
  if (RunLoopSource)
  {
    CFIndex v2 = RunLoopSource;
    Current = CFRunLoopGetCurrent();
    CFRunLoopAddSource(Current, v2, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
    CFRelease(v2);
  }
}

void PCSTTRUserNotificationCallback(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    if (PCSTTRUserNotificationCallback_onceToken != -1) {
      dispatch_once(&PCSTTRUserNotificationCallback_onceToken, &__block_literal_global_0);
    }
    uint64_t v11 = 0;
    CFRange v12 = &v11;
    uint64_t v13 = 0x2050000000;
    CFIndex v2 = (void *)getLSApplicationWorkspaceClass_softClass;
    uint64_t v14 = getLSApplicationWorkspaceClass_softClass;
    if (!getLSApplicationWorkspaceClass_softClass)
    {
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 3221225472;
      v10[2] = __getLSApplicationWorkspaceClass_block_invoke;
      v10[3] = &unk_1E5E6DDF8;
      v10[4] = &v11;
      __getLSApplicationWorkspaceClass_block_invoke((uint64_t)v10);
      CFIndex v2 = (void *)v12[3];
    }
    id v3 = v2;
    _Block_object_dispose(&v11, 8);
    if (v3)
    {
      CFDataRef v4 = NSString;
      id v5 = [(id)pendingTTREvent stringByAddingPercentEncodingWithAllowedCharacters:PCSTTRUserNotificationCallback_queryComponent];
      id v6 = [v4 stringWithFormat:@"tap-to-radar://new?Reproducibilty=Always&Title=LocalBackup%%20IdentityMissing&ComponentName=ProtectedCloudStorage&ComponentVersion=all&Reproducibility=Not%%20Applicable&ComponentID=574585&Classification=Crash/Hang/Data%%20Loss&Description=%@", v5];

      CFDataRef v7 = [MEMORY[0x1E4F1CB10] URLWithString:v6];
      uint64_t v8 = [v3 defaultWorkspace];
      [v8 openURL:v7 configuration:0 completionHandler:&__block_literal_global_27];

      CFIndex v9 = (void *)pendingTTREvent;
      pendingTTREvent = 0;
    }
  }
}

void sub_1ACF9BB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __PCSTTRUserNotificationCallback_block_invoke()
{
  id v0 = objc_alloc_init(MEMORY[0x1E4F28E58]);
  CFURLRef v1 = (void *)PCSTTRUserNotificationCallback_queryComponent;
  PCSTTRUserNotificationCallback_queryComponent = (uint64_t)v0;

  CFIndex v2 = (void *)PCSTTRUserNotificationCallback_queryComponent;
  id v3 = [MEMORY[0x1E4F28B88] URLQueryAllowedCharacterSet];
  [v2 formUnionWithCharacterSet:v3];

  CFDataRef v4 = (void *)PCSTTRUserNotificationCallback_queryComponent;
  return [v4 removeCharactersInString:@"&"];
}

Class __getLSApplicationWorkspaceClass_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!MobileCoreServicesLibraryCore_frameworkLibrary)
  {
    v3[1] = (void *)MEMORY[0x1E4F143A8];
    v3[2] = (void *)3221225472;
    v3[3] = __MobileCoreServicesLibraryCore_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    v3[5] = v3;
    long long v4 = xmmword_1E5E6DE18;
    uint64_t v5 = 0;
    MobileCoreServicesLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!MobileCoreServicesLibraryCore_frameworkLibrary)
    {
      abort_report_np();
LABEL_8:
      __getLSApplicationWorkspaceClass_block_invoke_cold_1();
    }
    if (v3[0]) {
      free(v3[0]);
    }
  }
  Class result = objc_getClass("LSApplicationWorkspace");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    goto LABEL_8;
  }
  getLSApplicationWorkspaceClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __MobileCoreServicesLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  MobileCoreServicesLibraryCore_frameworkLibrary = result;
  return result;
}

BOOL PCSManateeShareableIdentityReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  long long v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    CFDataRef v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2)
      {
        char v17 = objc_alloc_init(PCSManateePrivateKey);
        uint64_t v18 = 16;
      }
      else
      {
        if ((v10 >> 3) != 1)
        {
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
          continue;
        }
        char v17 = objc_alloc_init(PCSManateePrivateKey);
        uint64_t v18 = 8;
      }
      objc_storeStrong((id *)(a1 + v18), v17);
      if (!PBReaderPlaceMark() || !PCSManateePrivateKeyReadFrom((uint64_t)v17, a2))
      {

        return 0;
      }
      PBReaderRecallMark();
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

__CFData *PCSFPCopyUnwrappedKey(uint64_t a1, const void *a2, const __CFData *a3, const void **a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  ccaes_ecb_decrypt_mode();
  uint64_t v8 = ccecb_context_size();
  MEMORY[0x1F4188790](v8);
  CFIndex Length = CFDataGetLength(a3);
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", v10, v11, v12, v13, v14, v15, v16, v25);
  }
  if (Length <= 23)
  {
    CFIndex v24 = Length;
    CFStringRef v22 = @"wrapped data too small: %ld";
    goto LABEL_13;
  }
  if ((Length & 7) != 0)
  {
    CFIndex v24 = Length;
    CFStringRef v22 = @"wrapped data invalid length: %ld";
    goto LABEL_13;
  }
  CFDataRef Value = *(const __CFData **)(a1 + 72);
  if (!Value)
  {
    _PCSError(a4, 25, @"can't unwrap object w/o masterkey");
    goto LABEL_14;
  }
  if (a2)
  {
    if (CFEqual(a2, *(CFTypeRef *)(a1 + 80)))
    {
      CFDataRef Value = *(const __CFData **)(a1 + 72);
    }
    else
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), a2);
      if (!Value)
      {
        _PCSError(a4, 11, @"Failed to find master key of id %@", a2);
        goto LABEL_14;
      }
    }
  }
  if (!_PCSCreateDerivedKey(Value, 20, (int)&wrappingKeyLabel, 0x10uLL, (int)&v26, 0))
  {
LABEL_14:
    Mutable = 0;
    goto LABEL_16;
  }
  ccecb_init();
  CFIndex v18 = ccwrap_unwrapped_size();
  Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v18);
  if (Mutable)
  {
    CFDataGetBytePtr(a3);
    CFDataGetMutableBytePtr(Mutable);
    uint64_t v20 = ccwrap_auth_decrypt();
    if (v20)
    {
      uint64_t v21 = v20;
      CFRelease(Mutable);
      CFIndex v24 = v21;
      CFStringRef v22 = @"auth decrypt failed (%d)";
LABEL_13:
      _PCSError(a4, 18, v22, v24);
      goto LABEL_14;
    }
    if (CFDataGetLength(Mutable)) {
      PCSFPCopyUnwrappedKey_cold_1();
    }
  }
LABEL_16:
  ccecb_context_size();
  cc_clear();
  return Mutable;
}

__CFData *PCSFPCopyWrappedKey(uint64_t a1, const __CFData *a2, const void **a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  ccaes_ecb_encrypt_mode();
  uint64_t v6 = ccecb_context_size();
  MEMORY[0x1F4188790](v6);
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", v7, v8, v9, v10, v11, v12, v13, v19);
  }
  if (!_PCSCreateDerivedKey(*(const __CFData **)(a1 + 72), 20, (int)&wrappingKeyLabel, 0x10uLL, (int)&v20, 0)) {
    goto LABEL_7;
  }
  ccecb_init();
  CFDataGetLength(a2);
  CFIndex v14 = ccwrap_wrapped_size();
  Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v14);
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  CFDataGetMutableBytePtr(Mutable);
  uint64_t v16 = ccwrap_auth_encrypt();
  if (v16)
  {
    uint64_t v17 = v16;
    if (Mutable) {
      CFRelease(Mutable);
    }
    _PCSError(a3, 19, @"wrap failed (%d)", v17);
LABEL_7:
    Mutable = 0;
    goto LABEL_9;
  }
  if (CFDataGetLength(Mutable)) {
    PCSFPCopyWrappedKey_cold_1();
  }
LABEL_9:
  ccecb_context_size();
  cc_clear();
  return Mutable;
}

__CFData *PCSFPCopyEncryptedData(uint64_t a1, const __CFData *a2, const void *a3, const void **a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = ccaes_gcm_encrypt_mode();
  MEMORY[0x1F4188790](v8);
  if (!a1)
  {
    _PCSError(a4, 128, @"EncryptedData sp argument NULL");
    goto LABEL_15;
  }
  if (!a3 || (CFTypeID v9 = CFGetTypeID(a3), v9 != CFDataGetTypeID()))
  {
    _PCSError(a4, 126, @"EncryptedData plaintext argument not CFData");
    goto LABEL_15;
  }
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", v10, v11, v12, v13, v14, v15, v16, v22);
  }
  CFDataRef v17 = *(const __CFData **)(a1 + 72);
  if (!v17)
  {
    _PCSError(a4, 25, @"can't encrypt object w/o masterkey");
    goto LABEL_15;
  }
  if (!_PCSCreateDerivedKey(v17, 20, (int)&encryptionKeyLabel, 0x10uLL, (int)&v23, 0))
  {
LABEL_15:
    Mutable = 0;
    goto LABEL_10;
  }
  ccgcm_init();
  CFIndex v18 = CFDataGetLength((CFDataRef)a3) + 30;
  Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v18);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  UInt8 *MutableBytePtr = 3;
  *(_WORD *)(MutableBytePtr + 1) = *(_WORD *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 80));
  MutableBytePtr[3] = 2;
  *((_WORD *)MutableBytePtr + 2) = *((_WORD *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 80)) + 1);
  _PCSRandomData(0xCuLL, MutableBytePtr + 6);
  ccgcm_set_iv();
  ccgcm_aad();
  if (a2)
  {
    CFDataGetLength(a2);
    CFDataGetBytePtr(a2);
    ccgcm_aad();
  }
  CFDataGetLength((CFDataRef)a3);
  CFDataGetBytePtr((CFDataRef)a3);
  ccgcm_update();
  ccgcm_finalize();
LABEL_10:
  ccgcm_context_size();
  cc_clear();
  return Mutable;
}

__CFData *PCSFPCopyDecryptedData(uint64_t a1, const void *a2, const __CFData *a3, CFTypeRef cf, const void **a5)
{
  uint64_t v25 = 0;
  char v26 = &v25;
  uint64_t v27 = 0x2000000000;
  uint64_t v28 = 0;
  if (!a1)
  {
    _PCSError(a5, 128, @"DecryptedData sp argument NULL");
    goto LABEL_16;
  }
  if (!cf || (CFTypeID v10 = CFGetTypeID(cf), v10 != CFDataGetTypeID()))
  {
    _PCSError(a5, 126, @"DecryptedData cryptotext argument not CFData");
    goto LABEL_16;
  }
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", v11, v12, v13, v14, v15, v16, v17, v23);
  }
  CFDataRef Value = *(const __CFData **)(a1 + 72);
  if (!Value)
  {
    _PCSError(a5, 25, @"can't decrypt object w/o masterkey");
    goto LABEL_16;
  }
  if (!a2)
  {
LABEL_9:
    char v19 = PCSFPCopyDecryptedDataWithKey(Value, a3, (const __CFData *)cf, a5);
    goto LABEL_10;
  }
  if (CFEqual(a2, *(CFTypeRef *)(a1 + 80)))
  {
    CFDataRef Value = *(const __CFData **)(a1 + 72);
    goto LABEL_9;
  }
  if (CFDataGetLength((CFDataRef)a2) > 4)
  {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), a2);
    if (Value) {
      goto LABEL_9;
    }
    _PCSError(a5, 11, @"Failed to find master key of id %@", a2);
LABEL_16:
    char v19 = 0;
    goto LABEL_10;
  }
  char v19 = PCSFPCopyDecryptedDataWithKey(*(const __CFData **)(a1 + 72), a3, (const __CFData *)cf, a5);
  v26[3] = (uint64_t)v19;
  if (!v19)
  {
    CFIndex Length = CFDataGetLength((CFDataRef)a2);
    CFDictionaryRef v22 = *(const __CFDictionary **)(a1 + 112);
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 0x40000000;
    context[2] = __PCSFPCopyDecryptedData_block_invoke;
    context[3] = &unk_1E5E6DE38;
    context[4] = &v25;
    context[5] = Length;
    context[6] = a2;
    context[7] = a5;
    context[8] = a3;
    context[9] = cf;
    CFDictionaryApplyFunction(v22, (CFDictionaryApplierFunction)apply_block_2, context);
    char v19 = (__CFData *)v26[3];
  }
LABEL_10:
  _Block_object_dispose(&v25, 8);
  return v19;
}

__CFData *PCSFPCopyDecryptedDataWithKey(const __CFData *a1, const __CFData *a2, const __CFData *a3, const void **a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = ccaes_gcm_decrypt_mode();
  MEMORY[0x1F4188790](v7);
  unint64_t Length = CFDataGetLength(a3);
  if (_PCSCreateDerivedKey(a1, 20, (int)&encryptionKeyLabel, 0x10uLL, (int)&v24, 0))
  {
    ccgcm_init();
    BytePtr = CFDataGetBytePtr(a3);
    CFTypeID v10 = BytePtr;
    if ((uint64_t)Length >= 1)
    {
      uint64_t v11 = *BytePtr;
      CFDictionaryRef v22 = a4;
      a4 = 0;
      size_t v12 = 12;
      switch(*BytePtr)
      {
        case 0u:
          if (_PCSIsInternalRelease())
          {
            uint64_t v11 = 0;
            a4 = 0;
            size_t v12 = 8;
            goto LABEL_13;
          }
          a4 = v22;
          _PCSError(v22, 43, @"Version 0 encrypted data only support on internal releases");
          break;
        case 1u:
          uint64_t v11 = 0;
          a4 = 0;
          size_t v12 = 12;
          goto LABEL_13;
        case 2u:
          goto LABEL_13;
        case 3u:
          if (Length <= 3) {
            goto LABEL_39;
          }
          a4 = (const void **)(BytePtr[3] + 1);
          size_t v12 = 12;
          uint64_t v11 = 2;
          goto LABEL_13;
        case 4u:
          if (Length <= 5)
          {
LABEL_39:
            CFStringRef v19 = @"Crypto text too short for header";
          }
          else
          {
            a4 = (const void **)(BytePtr[5] + 1);
            size_t v12 = 12;
            uint64_t v11 = 4;
LABEL_13:
            unint64_t v15 = (unint64_t)a4 + (v11 | 1) + v12 + 12;
            if (Length >= v15)
            {
              CFIndex v16 = CFDataGetLength(a3) - v15;
              Mutable = CFDataCreateMutable(0, 0);
              CFDataSetLength(Mutable, v16);
              if (Mutable)
              {
                uint64_t v13 = malloc_type_malloc(v12, 0xA557CBD8uLL);
                if (v13)
                {
                  ccgcm_set_iv();
                  ccgcm_aad();
                  if (a2)
                  {
                    CFDataGetLength(a2);
                    CFDataGetBytePtr(a2);
                    ccgcm_aad();
                  }
                  CFDataGetLength(Mutable);
                  CFDataGetMutableBytePtr(Mutable);
                  ccgcm_update();
                  ccgcm_finalize();
                  if (!cc_cmp_safe())
                  {
                    ccgcm_context_size();
                    cc_clear();
                    uint64_t v24 = 0;
                    uint64_t v25 = 0;
                    free(v13);
                    return Mutable;
                  }
                  if (*v10 < 3u)
                  {
                    uint64_t v20 = *v10;
                    CFStringRef v17 = @"Tag doesn't verify: version %d";
                  }
                  else
                  {
                    uint64_t v20 = v10[1];
                    uint64_t v21 = v10[2];
                    CFStringRef v17 = @"Tag doesn't verify: keyid: 0x%02x%02x";
                  }
                  a4 = v22;
                  _PCSError(v22, 21, v17, v20, v21);
LABEL_24:
                  ccgcm_context_size();
                  cc_clear();
                  uint64_t v24 = 0;
                  uint64_t v25 = 0;
                  if (v13) {
                    free(v13);
                  }
                  if (Mutable) {
                    CFRelease(Mutable);
                  }
                  if (!a4) {
                    return 0;
                  }
                  goto LABEL_29;
                }
              }
              else
              {
                uint64_t v13 = 0;
              }
              a4 = v22;
              goto LABEL_24;
            }
            CFStringRef v19 = @"Crypto text too short";
          }
          a4 = v22;
          _PCSError(v22, 20, v19);
          break;
        default:
          _PCSError(0, 43, @"Unsupported crypto data version: %u", v11);
          break;
      }
LABEL_7:
      uint64_t v13 = 0;
      Mutable = 0;
      goto LABEL_24;
    }
    if (BytePtr) {
      goto LABEL_7;
    }
  }
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  if (a4)
  {
LABEL_29:
    if (!*a4) {
      _PCSError(a4, -50, @"Failure with no CFError, made this one up.");
    }
  }
  return 0;
}

uint64_t __PCSFPCopyDecryptedData_block_invoke(uint64_t result, CFDataRef theData, const __CFData *a3)
{
  if (!*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v5 = result;
    uint64_t result = CFDataGetLength(theData);
    if (result > *(void *)(v5 + 40))
    {
      BytePtr = CFDataGetBytePtr(theData);
      uint64_t v7 = CFDataGetBytePtr(*(CFDataRef *)(v5 + 48));
      uint64_t result = memcmp(BytePtr, v7, *(void *)(v5 + 40));
      if (!result)
      {
        uint64_t v8 = *(const void ***)(v5 + 56);
        if (v8)
        {
          CFTypeID v9 = *v8;
          if (*v8)
          {
            *uint64_t v8 = 0;
            CFRelease(v9);
            uint64_t v8 = *(const void ***)(v5 + 56);
          }
        }
        uint64_t result = (uint64_t)PCSFPCopyDecryptedDataWithKey(a3, *(const __CFData **)(v5 + 64), *(const __CFData **)(v5 + 72), v8);
        *(void *)(*(void *)(*(void *)(v5 + 32) + 8) + 24) = result;
      }
    }
  }
  return result;
}

CFDataRef PCSFPCopyTruncatedKeyIDFromEncryptedData(const void *a1, const void **a2)
{
  if (!a1 || (CFTypeID v4 = CFGetTypeID(a1), v4 != CFDataGetTypeID()))
  {
    _PCSError(a2, 35, @"TruncatedKeyID is not data");
    return 0;
  }
  CFIndex Length = CFDataGetLength((CFDataRef)a1);
  if (Length >= 1)
  {
    unint64_t v6 = Length;
    BytePtr = CFDataGetBytePtr((CFDataRef)a1);
    int v8 = *BytePtr;
    if ((v8 - 2) >= 2)
    {
      if (v8 != 4)
      {
        _PCSError(a2, 43, @"Unsupported crypto data version: %u", *BytePtr);
        return 0;
      }
      if (v6 > 4)
      {
        CFTypeID v10 = (UInt8 *)(BytePtr + 1);
        CFIndex v9 = 4;
LABEL_15:
        CFDataRef result = CFDataCreate(0, v10, v9);
        if (result) {
          return result;
        }
        _PCSErrorOOM(a2);
        return 0;
      }
    }
    else if (v6 > 3)
    {
      *(_WORD *)bytes = *(_WORD *)(BytePtr + 1);
      if (v8 != 3 || BytePtr[3] < 2u)
      {
        CFIndex v9 = 2;
        goto LABEL_14;
      }
      if (v6 > 5)
      {
        __int16 v13 = *((_WORD *)BytePtr + 2);
        CFIndex v9 = 4;
LABEL_14:
        CFTypeID v10 = bytes;
        goto LABEL_15;
      }
    }
    _PCSError(a2, 20, @"Crypto text too short");
  }
  return 0;
}

uint64_t apply_block_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

char *PCSCFStringToCString(const __CFString *a1)
{
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    return strdup(CStringPtr);
  }
  else
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    unint64_t v6 = malloc_type_malloc(v5, 0x6A41BA48uLL);
    if (v6 && !CFStringGetCString(a1, (char *)v6, v5, 0x8000100u))
    {
      free(v6);
      return 0;
    }
    return (char *)v6;
  }
}

uint64_t _PCSIsInternalRelease()
{
  return os_variant_allows_internal_security_policies();
}

CFURLRef __PCSCopyLogFilePath(uint64_t a1)
{
  uint64_t v2 = CFCopyHomeDirectoryURLForUser();
  if (!v2)
  {
    CFURLRef v14 = 0;
    CFURLRef v11 = (const __CFURL *)&stru_1F03DBED0;
    goto LABEL_17;
  }
  CFURLRef v3 = (const __CFURL *)v2;
  if (a1)
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v5 = CFDateCreate(0, Current);
    if (!v5) {
      goto LABEL_22;
    }
    CFDateRef v6 = v5;
    CFLocaleRef v7 = CFLocaleCopyCurrent();
    int v8 = CFDateFormatterCreate(0, v7, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat(v8, @"yyyyMMddHHmmss");
    CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(0, v8, v6);
    if (v7) {
      CFRelease(v7);
    }
    CFRelease(v6);
    if (v8) {
      CFRelease(v8);
    }
    if (!StringWithDate)
    {
LABEL_22:
      CFRelease(&stru_1F03DBED0);
LABEL_23:
      CFURLRef v14 = 0;
      CFURLRef v11 = v3;
      goto LABEL_17;
    }
    CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"-%@-%@", StringWithDate, a1);
    CFRelease(StringWithDate);
    if (!v10) {
      goto LABEL_23;
    }
  }
  else
  {
    CFStringRef v10 = &stru_1F03DBED0;
  }
  CFURLRef v11 = CFURLCreateCopyAppendingPathComponent(0, v3, @"Library/Logs/CrashReporter/DiagnosticLogs", 0);
  if (v11)
  {
    CFStringRef v12 = CFStringCreateWithFormat(0, 0, @"ProtectedCloudStorage%@.log", v10);
    if (v12)
    {
      CFStringRef v13 = v12;
      CFURLRef v14 = CFURLCreateCopyAppendingPathComponent(0, v11, v12, 0);
      CFRelease(v13);
      if (!v10) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
  }
  CFURLRef v14 = 0;
  if (v10) {
LABEL_15:
  }
    CFRelease(v10);
LABEL_16:
  CFRelease(v3);
  if (v11) {
LABEL_17:
  }
    CFRelease(v11);
  return v14;
}

uint64_t PCSLogContextGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __PCSLogContextGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_1;
  block[4] = &PCSLogContextGetTypeID_sPCSLogContextGetTypeIDSingleton;
  if (PCSLogContextGetTypeID_sPCSLogContextGetTypeIDOnce != -1) {
    dispatch_once(&PCSLogContextGetTypeID_sPCSLogContextGetTypeIDOnce, block);
  }
  return PCSLogContextGetTypeID_sPCSLogContextGetTypeIDSingleton;
}

uint64_t __PCSLogContextGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void PCSLogContextDestroy(uint64_t a1)
{
  os_release(*(void **)(a1 + 16));
  int v2 = *(_DWORD *)(a1 + 32);
  if (v2 != -1) {
    close(v2);
  }
  CFURLRef v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 24) = 0;
    CFRelease(v3);
  }
}

BOOL PCSLogContextCompare(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

CFStringRef PCSLogContextCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, @"<PCSLogContext: %@>", *(void *)(a1 + 24));
}

uint64_t PCSCreateLogContext(const void *a1, char *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  PCSLogContextGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    if (a1
      && os_variant_allows_internal_security_policies()
      && (CFURLRef v5 = __PCSCopyLogFilePath((uint64_t)a1)) != 0)
    {
      CFURLRef v6 = v5;
      if (CFURLGetFileSystemRepresentation(v5, 1u, buffer, 1024)) {
        int v7 = open((const char *)buffer, 777, 420);
      }
      else {
        int v7 = -1;
      }
      CFRelease(v6);
    }
    else
    {
      int v7 = -1;
    }
    *(_DWORD *)(Instance + 32) = v7;
    if (a2) {
      a2 = PCSCFStringToCString((const __CFString *)a2);
    }
    if (a2) {
      int v8 = a2;
    }
    else {
      int v8 = "general";
    }
    *(void *)(Instance + 16) = os_log_create("com.apple.ProtectedCloudStorage", v8);
    if (a1) {
      CFTypeRef v9 = CFRetain(a1);
    }
    else {
      CFTypeRef v9 = 0;
    }
    *(void *)(Instance + 24) = v9;
    free(a2);
  }
  return Instance;
}

uint64_t PCSLogGetOSLog(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 16);
  }
  else {
    return MEMORY[0x1E4F14500];
  }
}

void PCSMigrationLog(uint64_t a1, CFStringRef format, ...)
{
  va_start(va, format);
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFTypeRef v9 = 0;
  if (a1)
  {
    CFStringRef v3 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
    if (v3)
    {
      CFStringRef v4 = v3;
      CFURLRef v5 = *(NSObject **)(a1 + 16);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        buf.st_dev = 138543362;
        *(void *)&buf.st_mode = v4;
        _os_log_impl(&dword_1ACF98000, v5, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
      }
      if (*(_DWORD *)(a1 + 32) == -1)
      {
        CFRelease(v4);
      }
      else
      {
        CFURLRef v6 = PCSCFStringToCString(v4);
        CFRelease(v4);
        memset(&buf, 0, sizeof(buf));
        if (!fstat(*(_DWORD *)(a1 + 32), &buf) && buf.st_size >= 50001) {
          ftruncate(*(_DWORD *)(a1 + 32), 0);
        }
        time_t v7 = time(0);
        int v8 = asprintf(&v9, "%ld - %s\n", v7, v6);
        if (v8 != -1) {
          write(*(_DWORD *)(a1 + 32), v9, v8);
        }
        free(v9);
        free(v6);
      }
    }
  }
}

const void *pcsLogObjForScope(const char *a1)
{
  pthread_mutex_lock(&loggingMutex);
  char v2 = loggingEnabled;
  pthread_mutex_unlock(&loggingMutex);
  if (v2) {
    return (const void *)MEMORY[0x1E4F14508];
  }
  CFStringRef v4 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (a1) {
    a1 = (const char *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, 0x600u);
  }
  if (a1) {
    CFURLRef v5 = (__CFString *)a1;
  }
  else {
    CFURLRef v5 = @"logging";
  }
  os_unfair_lock_lock_with_options();
  CFDictionaryRef Mutable = (const __CFDictionary *)pcsLogObjForCFScope_scopeMap;
  if (!pcsLogObjForCFScope_scopeMap)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(*v4, 0, MEMORY[0x1E4F1D048], 0);
    pcsLogObjForCFScope_scopeMap = (uint64_t)Mutable;
  }
  CFDataRef Value = CFDictionaryGetValue(Mutable, v5);
  if (!Value)
  {
    CFRetain(v5);
    CFIndex Length = CFStringGetLength(v5);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    CFTypeRef v9 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0xE17BA2BFuLL);
    if (!CFStringGetCString(v5, v9, MaximumSizeForEncoding, 0x8000100u)) {
      *CFTypeRef v9 = 0;
    }
    CFRelease(v5);
    CFStringRef v10 = (__CFDictionary *)pcsLogObjForCFScope_scopeMap;
    os_log_t v11 = os_log_create("com.apple.ProtectedCloudStorage", v9);
    CFDictionaryAddValue(v10, v5, v11);
    free(v9);
    CFDataRef Value = CFDictionaryGetValue((CFDictionaryRef)pcsLogObjForCFScope_scopeMap, v5);
  }
  os_unfair_lock_unlock(&pcsLogObjForCFScope_lock);
  if (a1) {
    CFRelease(a1);
  }
  return Value;
}

uint64_t _PCSSecureBackupEnableWithInfo()
{
  id v0 = (uint64_t (*)(void))_PCSSecureBackupSymbols[1];
  if (!v0)
  {
    id v0 = (uint64_t (*)(void))MEMORY[0x1E4F59B00];
    _PCSSecureBackupSymbols[1] = (_UNKNOWN *)MEMORY[0x1E4F59B00];
  }
  return v0();
}

uint64_t _PCSSecureBackupUpdateMetadataWithInfo()
{
  id v0 = (uint64_t (*)(void))_PCSSecureBackupSymbols[4];
  if (!v0)
  {
    id v0 = (uint64_t (*)(void))MEMORY[0x1E4F59B18];
    _PCSSecureBackupSymbols[4] = (_UNKNOWN *)MEMORY[0x1E4F59B18];
  }
  return v0();
}

__CFData *_PCSStingrayCreateRandom(size_t a1, const void **a2)
{
  CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, a1);
  if (!Mutable)
  {
    _PCSErrorOOM(a2);
    return Mutable;
  }
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!MutableBytePtr)
  {
    _PCSErrorOOM(a2);
LABEL_6:
    CFRelease(Mutable);
    return 0;
  }
  if (SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E4F3BC60], a1, MutableBytePtr)) {
    goto LABEL_6;
  }
  return Mutable;
}

__CFData *_PCSStingrayCreateRandomKey(const void **a1)
{
  return _PCSStingrayCreateRandom(0x20uLL, a1);
}

__CFData *_PCSStingrayCopyEncryptedData(const __CFData *a1, const __CFData *a2)
{
  uint64_t v4 = ccaes_gcm_encrypt_mode();
  MEMORY[0x1F4188790](v4);
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccgcm_init();
  CFIndex v5 = CFDataGetLength(a2) + 32;
  CFDictionaryRef Mutable = CFDataCreateMutable(0, v5);
  time_t v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v5);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    if (!MutableBytePtr || SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E4F3BC60], 0x10uLL, MutableBytePtr))
    {
      CFRelease(v7);
      time_t v7 = 0;
    }
    else
    {
      ccgcm_set_iv();
      CFDataGetLength(a2);
      CFDataGetBytePtr(a2);
      ccgcm_update();
      CFDataGetLength(a2);
      ccgcm_finalize();
    }
  }
  ccgcm_context_size();
  cc_clear();
  return v7;
}

__CFData *_PCSStingrayCopyDecryptedData(const __CFData *a1, const __CFData *a2)
{
  uint64_t v4 = ccaes_gcm_decrypt_mode();
  MEMORY[0x1F4188790](v4);
  CFIndex Length = CFDataGetLength(a2);
  CFIndex v6 = Length - 32;
  if (Length < 32) {
    return 0;
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccgcm_init();
  CFDataGetBytePtr(a2);
  ccgcm_set_iv();
  CFDictionaryRef Mutable = CFDataCreateMutable(0, v6);
  time_t v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v6);
    CFDataGetMutableBytePtr(v7);
    ccgcm_update();
    ccgcm_finalize();
    if (cc_cmp_safe())
    {
      CFRelease(v7);
      time_t v7 = 0;
    }
  }
  ccgcm_context_size();
  cc_clear();
  return v7;
}

intptr_t __PCS_WAITING_FOR_COM_APPLE_SBD(NSObject *a1)
{
  return dispatch_semaphore_wait(a1, 0xFFFFFFFFFFFFFFFFLL);
}

BOOL __PCSAccountHasStingrayIdentities(uint64_t a1, const __CFDictionary *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2020000000;
  uint64_t v23 = 0;
  dispatch_semaphore_t v6 = dispatch_semaphore_create(0);
  time_t v7 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)stat buf = 0;
    _os_log_impl(&dword_1ACF98000, v7, OS_LOG_TYPE_DEFAULT, "__PCSAccountHasStingrayIdentities", buf, 2u);
  }

  int v8 = __PCSCreateSecureBackupContext(a2);
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  v16[2] = ____PCSAccountHasStingrayIdentities_block_invoke;
  v16[3] = &unk_1E5E6DE80;
  CFIndex v18 = &v20;
  CFStringRef v19 = &v24;
  CFTypeRef v9 = v6;
  CFStringRef v17 = v9;
  CFStringRef v10 = (void (*)(__CFDictionary *, void *))*_PCSSecureBackupSymbols;
  if (!*_PCSSecureBackupSymbols)
  {
    *_PCSSecureBackupSymbols = (_UNKNOWN *)MEMORY[0x1E4F59B08];
    CFStringRef v10 = (void (*)(__CFDictionary *, void *))*_PCSSecureBackupSymbols;
  }
  v10(v8, v16);
  __PCS_WAITING_FOR_COM_APPLE_SBD(v9);
  if (v8) {
    CFRelease(v8);
  }
  os_log_t v11 = (const void *)v21[3];
  if (a3)
  {
    *a3 = v11;
  }
  else if (v11)
  {
    v21[3] = 0;
    CFRelease(v11);
  }
  uint64_t v12 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v25 + 24)) {
      CFStringRef v13 = "YES";
    }
    else {
      CFStringRef v13 = "NO";
    }
    *(_DWORD *)stat buf = 136315138;
    BOOL v29 = v13;
    _os_log_impl(&dword_1ACF98000, v12, OS_LOG_TYPE_DEFAULT, "PCSHasStingrayIdentities: %s", buf, 0xCu);
  }

  BOOL v14 = *((unsigned char *)v25 + 24) != 0;
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
  return v14;
}

void sub_1ACF9E2CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

__CFDictionary *__PCSCreateSecureBackupContext(const __CFDictionary *a1)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v3 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFDictionarySetValue(Mutable, kPCSSecureBackupCFContainsiCloudIdentityKey[0], (const void *)*MEMORY[0x1E4F1CFD0]);
  CFDictionarySetValue(Mutable, @"SecureBackupExcludeiCDPRecords", v3);
  uint64_t v4 = kPCSSecureBackupCFAuthenticationDSID[0];
  CFDataRef Value = CFDictionaryGetValue(a1, kPCSSetupDSID[0]);
  if (Value) {
    CFDictionarySetValue(Mutable, v4, Value);
  }
  dispatch_semaphore_t v6 = kPCSSecureBackupCFAuthenticationAppleID[0];
  time_t v7 = CFDictionaryGetValue(a1, kPCSSetupUsername[0]);
  if (v7) {
    CFDictionarySetValue(Mutable, v6, v7);
  }
  int v8 = kPCSSecureBackupCFAuthenticationPassword[0];
  CFTypeRef v9 = CFDictionaryGetValue(a1, kPCSSetupPassword[0]);
  if (v9) {
    CFDictionarySetValue(Mutable, v8, v9);
  }
  uint64_t v10 = kPCSSecureBackupCFAuthenticationAuthToken[0];
  os_log_t v11 = CFDictionaryGetValue(a1, kPCSSetupAuthToken[0]);
  if (v11) {
    CFDictionarySetValue(Mutable, v10, v11);
  }
  uint64_t v12 = kPCSSecureBackupCFAuthenticationEscrowProxyURL[0];
  uint64_t v13 = CFDictionaryGetValue(a1, kPCSSetupEscrowURL[0]);
  if (v13) {
    CFDictionarySetValue(Mutable, v12, v13);
  }
  uint64_t v14 = kPCSSecureBackupCFAuthenticationiCloudEnvironment[0];
  unint64_t v15 = CFDictionaryGetValue(a1, kPCSSetupiCloudEnvironment[0]);
  if (v15) {
    CFDictionarySetValue(Mutable, v14, v15);
  }
  CFIndex v16 = CFDictionaryGetValue(a1, kPCSSetupGuitarfish[0]);
  if (v16) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F59B50], v16);
  }
  CFStringRef v17 = CFDictionaryGetValue(a1, kPCSSetupGuitarfishToken[0]);
  if (v17) {
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F59B60], v17);
  }
  CFIndex v18 = kPCSSecureBackupCFAuthenticationRawPassword[0];
  CFStringRef v19 = CFDictionaryGetValue(a1, kPCSSetupRawPassword[0]);
  if (v19) {
    CFDictionarySetValue(Mutable, v18, v19);
  }
  uint64_t v20 = CFDictionaryGetValue(a1, kPCSSetupVerifierProtocol[0]);
  uint64_t v21 = CFDictionaryGetValue(a1, kPCSSetupVerifierSalt[0]);
  uint64_t v22 = CFDictionaryGetValue(a1, kPCSSetupVerifierIterationCount[0]);
  uint64_t v23 = v22;
  if (v20 || v21 || v22)
  {
    if (v20 && v21 && v22)
    {
      uint64_t v24 = objc_msgSend(objc_alloc(MEMORY[0x1E4F59AE8]), "initWithProto:salt:iterations:", v20, v21, objc_msgSend(v22, "intValue"));
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F59B30], v24);
      uint64_t v25 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = 138412802;
        uint64_t v28 = v20;
        __int16 v29 = 2112;
        uint64_t v30 = v23;
        __int16 v31 = 2112;
        CFNumberRef v32 = v21;
        _os_log_impl(&dword_1ACF98000, v25, OS_LOG_TYPE_DEFAULT, "setting IDMS password metadata: %@, %@, %@", (uint8_t *)&v27, 0x20u);
      }
    }
    else
    {
      uint64_t v24 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        __PCSCreateSecureBackupContext_cold_1(v24);
      }
    }
  }
  return Mutable;
}

CFDataRef __PCSCopyHSMData(uint64_t a1, void *a2, const void **a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  dispatch_semaphore_t v6 = [v5 objectForKeyedSubscript:kPCSPasswordGenerationFromExistingMetadata[0]];
  if (v6)
  {
    time_t v7 = [v5 objectForKeyedSubscript:kPCSSetupPasswordGeneration[0]];
    if (!v7)
    {
      _PCSError(a3, 233, @"No kPCSSetupPasswordGeneration provided, unable to attempt HSM p_password recovery");
LABEL_7:
      CFDataRef v9 = 0;
      goto LABEL_27;
    }
    if (([v6 isEqualToNumber:v7] & 1) == 0)
    {
      int v8 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
        __PCSCopyHSMData_cold_1((uint64_t)v7, (uint64_t)v6, v8);
      }

      _PCSError(a3, 232, @"Not attempting recovery because input (%@) password generation does not match the record (%@) password generation", v7, v6);
      goto LABEL_7;
    }
  }
  else
  {
    time_t v7 = 0;
  }
  uint64_t v30 = 0;
  __int16 v31 = &v30;
  uint64_t v32 = 0x2020000000;
  uint64_t v33 = 0;
  uint64_t v26 = 0;
  int v27 = &v26;
  uint64_t v28 = 0x2020000000;
  uint64_t v29 = 0;
  uint64_t v10 = __PCSCreateSecureBackupContext((const __CFDictionary *)v5);
  dispatch_semaphore_t v11 = dispatch_semaphore_create(0);
  *(void *)CFTypeID v36 = MEMORY[0x1E4F143A8];
  *(void *)&long long v37 = 3221225472;
  *((void *)&v37 + 1) = ____PCSCopyStingray_block_invoke;
  CFTypeID v38 = &unk_1E5E6DE80;
  CFStringRef v40 = &v30;
  CFStringRef v41 = &v26;
  uint64_t v12 = v11;
  CFStringRef v39 = v12;
  uint64_t v13 = (void (*)(__CFDictionary *, uint8_t *))_PCSSecureBackupSymbols[2];
  if (!v13)
  {
    uint64_t v13 = (void (*)(__CFDictionary *, uint8_t *))MEMORY[0x1E4F59B10];
    _PCSSecureBackupSymbols[2] = (_UNKNOWN *)MEMORY[0x1E4F59B10];
  }
  v13(v10, v36);
  CFRelease(v10);
  __PCS_WAITING_FOR_COM_APPLE_SBD(v12);
  uint64_t v14 = (const void *)v31[3];
  if (a3)
  {
    *a3 = v14;
  }
  else if (v14)
  {
    v31[3] = 0;
    CFRelease(v14);
  }
  unint64_t v15 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      CFIndex v16 = *a3;
    }
    else {
      CFIndex v16 = 0;
    }
    *(_DWORD *)stat buf = 138543362;
    CFStringRef v35 = v16;
    _os_log_impl(&dword_1ACF98000, v15, OS_LOG_TYPE_DEFAULT, "PCSCopyStingray: error: %{public}@", buf, 0xCu);
  }

  CFStringRef v17 = (const void *)v27[3];
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  if (!v17) {
    goto LABEL_7;
  }
  CFTypeID v18 = CFGetTypeID(v17);
  if (v18 == CFDictionaryGetTypeID())
  {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v17, kPCSSecureBackupCFiCloudIdentityDataKey[0]);
    CFDataRef v9 = Value;
    if (Value)
    {
      CFTypeID v20 = CFGetTypeID(Value);
      if (v20 == CFDataGetTypeID())
      {
        CFDataRef Copy = CFDataCreateCopy(0, v9);
        CFDataRef v9 = Copy;
        if (Copy)
        {
          CFTypeID v22 = CFGetTypeID(Copy);
          if (v22 == CFDataGetTypeID()) {
            goto LABEL_26;
          }
        }
      }
      else
      {
        CFDataRef v9 = 0;
      }
    }
    _PCSError(a3, 44, @"SecureBackup didn't return data key");
  }
  else
  {
    CFDataRef v9 = 0;
  }
LABEL_26:
  CFRelease(v17);
LABEL_27:
  uint64_t v23 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      uint64_t v24 = *a3;
    }
    else {
      uint64_t v24 = 0;
    }
    *(_DWORD *)CFTypeID v36 = 67109378;
    *(_DWORD *)&v36[4] = v9 != 0;
    LOWORD(v37) = 2114;
    *(void *)((char *)&v37 + 2) = v24;
    _os_log_impl(&dword_1ACF98000, v23, OS_LOG_TYPE_DEFAULT, "PCSCopyHSMData: %{BOOL}d (error: %{public}@)", v36, 0x12u);
  }

  return v9;
}

void sub_1ACF9EB98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __PCSCopyStingrayInfo(uint64_t a1, const __CFDictionary *a2, void *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2020000000;
  uint64_t v26 = 0;
  uint64_t v19 = 0;
  CFTypeID v20 = &v19;
  uint64_t v21 = 0x2020000000;
  uint64_t v22 = 0;
  dispatch_semaphore_t v6 = dispatch_semaphore_create(0);
  uint64_t v7 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)stat buf = 0;
    _os_log_impl(&dword_1ACF98000, v7, OS_LOG_TYPE_DEFAULT, "__PCSCopyStingrayInfo", buf, 2u);
  }

  uint64_t v8 = __PCSCreateSecureBackupContext(a2);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = ____PCSCopyStingrayInfo_block_invoke;
  v15[3] = &unk_1E5E6DE80;
  CFStringRef v17 = &v23;
  CFTypeID v18 = &v19;
  CFDataRef v9 = v6;
  CFIndex v16 = v9;
  uint64_t v10 = (void (*)(__CFDictionary *, void *))*_PCSSecureBackupSymbols;
  if (!*_PCSSecureBackupSymbols)
  {
    *_PCSSecureBackupSymbols = (_UNKNOWN *)MEMORY[0x1E4F59B08];
    uint64_t v10 = (void (*)(__CFDictionary *, void *))*_PCSSecureBackupSymbols;
  }
  v10(v8, v15);
  __PCS_WAITING_FOR_COM_APPLE_SBD(v9);
  if (v8) {
    CFRelease(v8);
  }
  dispatch_semaphore_t v11 = (const void *)v24[3];
  if (a3)
  {
    *a3 = v11;
  }
  else if (v11)
  {
    v24[3] = 0;
    CFRelease(v11);
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    if (v20[3]) {
      uint64_t v12 = "YES";
    }
    else {
      uint64_t v12 = "NO";
    }
    *(_DWORD *)stat buf = 136315138;
    uint64_t v28 = v12;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSCopyStingrayInfo: %s", buf, 0xCu);
  }
  uint64_t v13 = v20[3];

  _Block_object_dispose(&v19, 8);
  _Block_object_dispose(&v23, 8);
  return v13;
}

void sub_1ACF9EE1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

BOOL __PCSUpdateStingrayMetadata(uint64_t a1, const __CFDictionary *a2, const void *a3, const void *a4, void *a5)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = 0;
  int v27 = &v26;
  uint64_t v28 = 0x2020000000;
  char v29 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2020000000;
  uint64_t v25 = 0;
  CFDataRef v9 = __PCSCreateSecureBackupContext(a2);
  CFDictionarySetValue(v9, (const void *)*MEMORY[0x1E4F59B68], a3);
  CFDictionarySetValue(v9, (const void *)*MEMORY[0x1E4F59B80], a4);
  dispatch_semaphore_t v10 = dispatch_semaphore_create(0);
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 3221225472;
  v18[2] = ____PCSUpdateStingrayMetadata_block_invoke;
  v18[3] = &unk_1E5E6DEA8;
  CFTypeID v20 = &v22;
  uint64_t v21 = &v26;
  dispatch_semaphore_t v11 = v10;
  uint64_t v19 = v11;
  uint64_t v12 = (void (*)(__CFDictionary *, void *))_PCSSecureBackupSymbols[4];
  if (!v12)
  {
    uint64_t v12 = (void (*)(__CFDictionary *, void *))MEMORY[0x1E4F59B18];
    _PCSSecureBackupSymbols[4] = (_UNKNOWN *)MEMORY[0x1E4F59B18];
  }
  v12(v9, v18);
  __PCS_WAITING_FOR_COM_APPLE_SBD(v11);
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v13 = (const void *)v23[3];
  if (a5)
  {
    *a5 = v13;
  }
  else if (v13)
  {
    v23[3] = 0;
    CFRelease(v13);
  }
  uint64_t v14 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *((unsigned __int8 *)v27 + 24);
    *(_DWORD *)stat buf = 67109120;
    int v31 = v15;
    _os_log_impl(&dword_1ACF98000, v14, OS_LOG_TYPE_DEFAULT, "__PCSUpdateStingrayMetadata: %{BOOL}d", buf, 8u);
  }

  BOOL v16 = *((unsigned char *)v27 + 24) != 0;
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);
  return v16;
}

void sub_1ACF9F0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

BOOL __PCSDisableStingrayIdentity(uint64_t a1, const __CFDictionary *a2, void *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2020000000;
  char v28 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2020000000;
  uint64_t v24 = 0;
  dispatch_semaphore_t v6 = dispatch_semaphore_create(0);
  uint64_t v7 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)stat buf = 0;
    _os_log_impl(&dword_1ACF98000, v7, OS_LOG_TYPE_DEFAULT, "__PCSDisableStingrayIdentity", buf, 2u);
  }

  uint64_t v8 = __PCSCreateSecureBackupContext(a2);
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  v17[2] = ____PCSDisableStingrayIdentity_block_invoke;
  v17[3] = &unk_1E5E6DEA8;
  uint64_t v19 = &v21;
  CFTypeID v20 = &v25;
  CFDataRef v9 = v6;
  CFTypeID v18 = v9;
  uint64_t v10 = (void (*)(__CFDictionary *, void *))_PCSSecureBackupSymbols[3];
  if (!v10)
  {
    uint64_t v10 = (void (*)(__CFDictionary *, void *))MEMORY[0x1E4F59AF8];
    _PCSSecureBackupSymbols[3] = (_UNKNOWN *)MEMORY[0x1E4F59AF8];
  }
  v10(v8, v17);
  __PCS_WAITING_FOR_COM_APPLE_SBD(v9);
  if (v8) {
    CFRelease(v8);
  }
  dispatch_semaphore_t v11 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v26 + 24)) {
      uint64_t v12 = "YES";
    }
    else {
      uint64_t v12 = "NO";
    }
    uint64_t v13 = v22[3];
    *(_DWORD *)stat buf = 136446466;
    uint64_t v30 = v12;
    __int16 v31 = 2114;
    uint64_t v32 = v13;
    _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, "__PCSDisableStingrayIdentity: %{public}s: %{public}@", buf, 0x16u);
  }

  uint64_t v14 = (const void *)v22[3];
  if (a3)
  {
    *a3 = v14;
  }
  else if (v14)
  {
    v22[3] = 0;
    CFRelease(v14);
  }
  BOOL v15 = *((unsigned char *)v26 + 24) != 0;

  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  return v15;
}

void sub_1ACF9F3FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

CFDataRef __PCSCopyGuitarfishTokenData(uint64_t a1, const __CFDictionary *a2, const void **a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 0;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2020000000;
  uint64_t v28 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2020000000;
  uint64_t v24 = 0;
  id v5 = __PCSCreateSecureBackupContext(a2);
  CFDictionaryRemoveValue(v5, (const void *)*MEMORY[0x1E4F59B50]);
  CFDictionarySetValue(v5, (const void *)*MEMORY[0x1E4F59B60], (const void *)*MEMORY[0x1E4F1CFD0]);
  dispatch_semaphore_t v6 = dispatch_semaphore_create(0);
  *(void *)__int16 v31 = MEMORY[0x1E4F143A8];
  *(void *)&long long v32 = 3221225472;
  *((void *)&v32 + 1) = ____PCSRecoverGuitarfishTokenRecord_block_invoke;
  uint64_t v33 = &unk_1E5E6DE80;
  CFStringRef v35 = &v25;
  CFTypeID v36 = &v21;
  uint64_t v7 = v6;
  CFStringRef v34 = v7;
  uint64_t v8 = (void (*)(__CFDictionary *, uint8_t *))_PCSSecureBackupSymbols[2];
  if (!v8)
  {
    uint64_t v8 = (void (*)(__CFDictionary *, uint8_t *))MEMORY[0x1E4F59B10];
    _PCSSecureBackupSymbols[2] = (_UNKNOWN *)MEMORY[0x1E4F59B10];
  }
  v8(v5, v31);
  CFRelease(v5);
  __PCS_WAITING_FOR_COM_APPLE_SBD(v7);
  CFDataRef v9 = (const void *)v26[3];
  if (a3)
  {
    *a3 = v9;
  }
  else if (v9)
  {
    v26[3] = 0;
    CFRelease(v9);
  }
  uint64_t v10 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      dispatch_semaphore_t v11 = *a3;
    }
    else {
      dispatch_semaphore_t v11 = 0;
    }
    *(_DWORD *)stat buf = 138543362;
    uint64_t v30 = v11;
    _os_log_impl(&dword_1ACF98000, v10, OS_LOG_TYPE_DEFAULT, "__PCSRecoverGuitarfishTokenRecord: error: %{public}@", buf, 0xCu);
  }

  uint64_t v12 = (const void *)v22[3];
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  if (v12)
  {
    CFTypeID v13 = CFGetTypeID(v12);
    if (v13 == CFDictionaryGetTypeID())
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v12, (const void *)*MEMORY[0x1E4F59B90]);
      CFDataRef v15 = Value;
      if (Value)
      {
        CFTypeID v16 = CFGetTypeID(Value);
        if (v16 == CFDataGetTypeID())
        {
          CFDataRef Copy = CFDataCreateCopy(0, v15);
LABEL_17:
          CFRelease(v12);
          goto LABEL_18;
        }
      }
      _PCSError(a3, 44, @"SecureBackup didn't return data key");
    }
    CFDataRef Copy = 0;
    goto LABEL_17;
  }
  CFDataRef Copy = 0;
LABEL_18:
  CFTypeID v18 = PCSLogGetOSLog(a1);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      uint64_t v19 = *a3;
    }
    else {
      uint64_t v19 = 0;
    }
    *(_DWORD *)__int16 v31 = 67109378;
    *(_DWORD *)&v31[4] = Copy != 0;
    LOWORD(v32) = 2114;
    *(void *)((char *)&v32 + 2) = v19;
    _os_log_impl(&dword_1ACF98000, v18, OS_LOG_TYPE_DEFAULT, "__PCSCopyGuitarfishTokenData: %{BOOL}d (error: %{public}@)", v31, 0x12u);
  }

  return Copy;
}

void sub_1ACF9F7C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t __PCSDeleteGuitarfishTokenRecord(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2020000000;
  uint64_t v27 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2020000000;
  uint64_t v23 = 0;
  dispatch_semaphore_t v6 = __PCSCreateSecureBackupContext(a2);
  CFDictionaryRemoveValue(v6, (const void *)*MEMORY[0x1E4F59B50]);
  CFDictionarySetValue(v6, (const void *)*MEMORY[0x1E4F59B60], (const void *)*MEMORY[0x1E4F1CFD0]);
  dispatch_semaphore_t v7 = dispatch_semaphore_create(0);
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  v16[2] = ____PCSDeleteGuitarfishTokenRecord_block_invoke;
  v16[3] = &unk_1E5E6DED0;
  CFTypeID v18 = &v24;
  uint64_t v19 = a1;
  uint64_t v8 = v7;
  CFStringRef v17 = v8;
  CFDataRef v9 = (void (*)(__CFDictionary *, void *))_PCSSecureBackupSymbols[3];
  if (!v9)
  {
    CFDataRef v9 = (void (*)(__CFDictionary *, void *))MEMORY[0x1E4F59AF8];
    _PCSSecureBackupSymbols[3] = (_UNKNOWN *)MEMORY[0x1E4F59AF8];
  }
  v9(v6, v16);
  __PCS_WAITING_FOR_COM_APPLE_SBD(v8);
  if (v6) {
    CFRelease(v6);
  }
  CFDataRef Value = (void *)CFDictionaryGetValue(a2, kPCSSetupDSID[0]);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  v15[2] = ____PCSDeleteGuitarfishTokenRecord_block_invoke_93;
  v15[3] = &unk_1E5E6DEF8;
  void v15[4] = &v20;
  v15[5] = a1;
  _PCSGuitarfishDeleteKeychainItem(@"RecoveryToken", Value, v15);
  dispatch_semaphore_t v11 = v25;
  uint64_t v12 = (const void *)v25[3];
  if (v12)
  {
    if (!a3) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v12 = (const void *)v21[3];
  if (v12)
  {
    if (!a3) {
      goto LABEL_13;
    }
LABEL_10:
    *(void *)a3 = CFRetain(v12);
    dispatch_semaphore_t v11 = v25;
    uint64_t v12 = (const void *)v25[3];
    if (!v12)
    {
LABEL_12:
      a3 = 0;
      goto LABEL_13;
    }
LABEL_11:
    v11[3] = 0;
    CFRelease(v12);
    goto LABEL_12;
  }
  a3 = 1;
LABEL_13:
  CFTypeID v13 = (const void *)v21[3];
  if (v13)
  {
    v21[3] = 0;
    CFRelease(v13);
  }

  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
  return a3;
}

void sub_1ACF9FA48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t _PCSMakeDigest(uint64_t a1, const __CFData *a2, const __CFData *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 0;
  MEMORY[0x1F4188790](a1);
  dispatch_semaphore_t v11 = (char *)&v21 - v10;
  ccdigest_init();
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  ccdigest_update();
  if (a3)
  {
    CFDataGetLength(a3);
    CFDataGetBytePtr(a3);
    ccdigest_update();
  }
  unsigned int v23 = bswap32(*(_DWORD *)(a4 + 4));
  ccdigest_update();
  unsigned int v23 = bswap32(*(_DWORD *)a4);
  ccdigest_update();
  uint64_t v12 = *(unsigned int **)(a4 + 80);
  if (v12) {
    unsigned int v23 = bswap32(*v12);
  }
  else {
    unsigned int v23 = 0;
  }
  ccdigest_update();
  unsigned int v23 = bswap32(*(_DWORD *)(a4 + 8));
  ccdigest_update();
  ccdigest_update();
  uint64_t v13 = *(void *)(a4 + 104);
  if (v13)
  {
    uint64_t v14 = length_PCSAttributes(v13);
    uint64_t v15 = malloc_type_malloc(v14, 0x7AC0D2F6uLL);
    if (!v15) {
      goto LABEL_18;
    }
    CFTypeID v16 = v15;
    if (encode_PCSAttributes((uint64_t)v15 + v14 - 1, v14, *(void *)(a4 + 104), (uint64_t)&v22)) {
      goto LABEL_17;
    }
    if (v22 != v14) {
      goto LABEL_18;
    }
    ccdigest_update();
    free(v16);
  }
  uint64_t v17 = *(void *)(a4 + 96);
  if (v17)
  {
    uint64_t v18 = length_PCSSPKeyList(v17);
    uint64_t v19 = malloc_type_malloc(v18, 0xBA5927C6uLL);
    if (!v19) {
      goto LABEL_18;
    }
    CFTypeID v16 = v19;
    if (!encode_PCSSPKeyList((uint64_t)v19 + v18 - 1, v18, *(void *)(a4 + 96), (uint64_t)&v22))
    {
      if (v22 == v18)
      {
        ccdigest_update();
        free(v16);
        return (*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 56))(a1, v11, a5);
      }
LABEL_18:
      abort();
    }
LABEL_17:
    free(v16);
    goto LABEL_18;
  }
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 56))(a1, v11, a5);
}

uint64_t PCSFPCopyPublicObjectSigningKey(const __CFData *a1, const void **a2)
{
  uint64_t v11 = 0;
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v23 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  if (decode_PCSShareProtection((uint64_t)BytePtr, Length, (uint64_t)v19, (uint64_t)&v11)) {
    goto LABEL_10;
  }
  uint64_t v6 = v11;
  if (v6 != CFDataGetLength(a1))
  {
    _PCSError(a2, 16, @"Did not parse all exported PCS object");
LABEL_10:
    uint64_t PublicWithData = 0;
    goto LABEL_8;
  }
  if (!*((void *)&v20 + 1)) {
    goto LABEL_10;
  }
  if (decode_PCSObjectSignature(*(void *)(*((void *)&v20 + 1) + 24), *(void *)(*((void *)&v20 + 1) + 16), (uint64_t)&v12, (uint64_t)&v11))goto LABEL_10; {
  if (v11 != *(void *)(*((void *)&v20 + 1) + 16))
  }
    goto LABEL_10;
  CFDataRef v7 = CFDataCreate(0, (const UInt8 *)v14, *((CFIndex *)&v13 + 1));
  if (!v7) {
    goto LABEL_10;
  }
  CFDataRef v8 = v7;
  uint64_t PublicWithData = PCSKeyCreatePublicWithData(v7, a2);
  CFRelease(v8);
LABEL_8:
  free_PCSShareProtection((uint64_t)v19);
  free_PCSObjectSignature((uint64_t)&v12);
  return PublicWithData;
}

BOOL PCSFPValidateShare(const __CFData *a1, int a2, const void **a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  memset(v25, 0, sizeof(v25));
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v29 = 0;
  memset(v19, 0, sizeof(v19));
  long long v20 = 0u;
  *(_OWORD *)long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  if (decode_PCSShareProtection((uint64_t)BytePtr, Length, (uint64_t)v25, (uint64_t)&v18)) {
    goto LABEL_22;
  }
  uint64_t v8 = v18;
  if (v8 != CFDataGetLength(a1))
  {
    _PCSError(a3, 16, @"Did not parse all exported PCS object");
LABEL_22:
    BOOL v15 = 0;
    goto LABEL_19;
  }
  if (!*((void *)&v26 + 1)) {
    goto LABEL_22;
  }
  if (decode_PCSObjectSignature(*(void *)(*((void *)&v26 + 1) + 24), *(void *)(*((void *)&v26 + 1) + 16), (uint64_t)v19, (uint64_t)&v18))goto LABEL_22; {
  if (v18 != *(void *)(*((void *)&v26 + 1) + 16))
  }
    goto LABEL_22;
  CFDataRef v9 = (uint64_t *)ccsha256_di();
  uint64_t v17 = 0;
  CFIndex v10 = length_PCSSignedShareProtection((uint64_t)v25);
  CFDictionaryRef Mutable = CFDataCreateMutable(0, v10);
  if (!Mutable) {
    goto LABEL_22;
  }
  long long v12 = Mutable;
  CFDataSetLength(Mutable, v10);
  MutableBytePtr = CFDataGetMutableBytePtr(v12);
  if (encode_PCSSignedShareProtection((uint64_t)&MutableBytePtr[v10 - 1], v10, (uint64_t)v25, (uint64_t)&v17))
  {
    CFRelease(v12);
    goto LABEL_22;
  }
  if (v10 != v17) {
    asn1_abort();
  }
  if ((void)v26) {
    CFDataRef v14 = CFDataCreate(0, *(const UInt8 **)(v26 + 8), *(void *)v26);
  }
  else {
    CFDataRef v14 = 0;
  }
  _PCSMakeDigest((uint64_t)v9, v12, v14, (uint64_t)v19, (uint64_t)v30);
  BOOL v15 = (_PCSVerifyHash(a2, v21[2], *v9, (uint64_t)v30, (uint64_t)&v20 + 8, a3) & 1) != 0
     || *((void *)&v23 + 1)
     && (_PCSVerifyHash(a2, *(_DWORD *)(*((void *)&v23 + 1) + 16), *v9, (uint64_t)v30, *((uint64_t *)&v23 + 1), a3) & 1) != 0;
  CFRelease(v12);
  if (v14) {
    CFRelease(v14);
  }
LABEL_19:
  free_PCSShareProtection((uint64_t)v25);
  free_PCSObjectSignature((uint64_t)v19);
  return v15;
}

uint64_t _PCSPostHaveCredentials()
{
  return notify_post((const char *)kPCSNotificationHaveCredentialsString);
}

uint64_t PCSMeasureRelativeNanoTime()
{
  uint64_t v0 = mach_absolute_time();
  uint64_t v1 = PCSMeasureRelativeNanoTime_factor;
  if (!PCSMeasureRelativeNanoTime_factor)
  {
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    uint64_t v1 = info.numer / info.denom;
    PCSMeasureRelativeNanoTime_factor = v1;
  }
  return v1 * v0;
}

__CFString *_PCSYESNO(int a1)
{
  if (a1) {
    return @"YES";
  }
  else {
    return @"NO";
  }
}

uint64_t PCSKeyGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __PCSKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &PCSKeyGetTypeID_sPCSKeyGetTypeIDSingleton;
  if (PCSKeyGetTypeID_sPCSKeyGetTypeIDOnce != -1) {
    dispatch_once(&PCSKeyGetTypeID_sPCSKeyGetTypeIDOnce, block);
  }
  return PCSKeyGetTypeID_sPCSKeyGetTypeIDSingleton;
}

uint64_t __PCSKeyGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void PCSKeyDestroy(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 32) & 4) != 0)
  {
    free(*(void **)(a1 + 40));
    *(void *)(a1 + 40) = 0;
    CFStringRef v3 = (void **)(a1 + 48);
LABEL_6:
    char v2 = *v3;
    goto LABEL_7;
  }
  CFStringRef v3 = (void **)(a1 + 40);
  char v2 = *(void **)(a1 + 40);
  if (*(unsigned char *)(a1 + 32))
  {
    if (!v2) {
      goto LABEL_8;
    }
    cc_clear();
    goto LABEL_6;
  }
LABEL_7:
  free(v2);
  *CFStringRef v3 = 0;
LABEL_8:
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4)
  {
    free_PCSPublicKeyInfo(v4);
    free(*(void **)(a1 + 16));
  }
  id v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    *(void *)(a1 + 24) = 0;
    CFRelease(v5);
  }
}

BOOL PCSKeyCompare(const void *a1, const void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != PCSKeyGetTypeID()) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  return v5 == PCSKeyGetTypeID() && a1 == a2;
}

CFStringRef PCSKeyCopyDescription(uint64_t a1)
{
  CFDataRef v2 = PCSKeyCopyExportedPublicKey(a1);
  BytePtr = CFDataGetBytePtr(v2);
  CFIndex Length = CFDataGetLength(v2);
  CFStringRef v5 = _PCSCreateBase64((uint64_t)BytePtr, Length, 0);
  CFStringRef v6 = CFStringCreateWithFormat(0, 0, @"<PCSKey@%p keyid: %@>", a1, v5);
  if (v2) {
    CFRelease(v2);
  }
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t PCSIdentityGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __PCSIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &PCSIdentityGetTypeID_sPCSIdentityGetTypeIDSingleton;
  if (PCSIdentityGetTypeID_sPCSIdentityGetTypeIDOnce != -1) {
    dispatch_once(&PCSIdentityGetTypeID_sPCSIdentityGetTypeIDOnce, block);
  }
  return PCSIdentityGetTypeID_sPCSIdentityGetTypeIDSingleton;
}

uint64_t __PCSIdentityGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void PCSIdentityDestroy(void *a1)
{
  CFDataRef v2 = (const void *)a1[4];
  if (v2)
  {
    a1[4] = 0;
    CFRelease(v2);
  }
  CFStringRef v3 = (const void *)a1[2];
  if (v3)
  {
    a1[2] = 0;
    CFRelease(v3);
  }
  CFTypeID v4 = (const void *)a1[3];
  if (v4)
  {
    a1[3] = 0;
    CFRelease(v4);
  }
  CFStringRef v5 = (const void *)a1[8];
  if (v5)
  {
    a1[8] = 0;
    CFRelease(v5);
  }
  CFStringRef v6 = (const void *)a1[9];
  if (v6)
  {
    a1[9] = 0;
    CFRelease(v6);
  }
  CFDataRef v7 = (const void *)a1[6];
  if (v7)
  {
    a1[6] = 0;
    CFRelease(v7);
  }
  uint64_t v8 = (const void *)a1[10];
  if (v8)
  {
    a1[10] = 0;
    CFRelease(v8);
  }
}

uint64_t PCSIdentityCompare(void *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != PCSIdentityGetTypeID()) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (v5 != PCSIdentityGetTypeID()) {
    return 0;
  }
  if (a1 == a2) {
    return 1;
  }
  CFStringRef v6 = *(const void **)(a1[2] + 24);
  CFDataRef v7 = *(const void **)(a2[2] + 24);
  return CFEqual(v6, v7);
}

CFStringRef PCSIdentityCopyDescription(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    CFTypeID v4 = *(__CFString **)(a1 + 24);
  }
  else {
    CFTypeID v4 = &stru_1F03DBED0;
  }
  if (v3) {
    CFTypeID v5 = @"name: ";
  }
  else {
    CFTypeID v5 = &stru_1F03DBED0;
  }
  if (v2 && (CFStringRef v6 = *(int **)(v2 + 16)) != 0) {
    int v7 = *v6;
  }
  else {
    int v7 = 0;
  }
  uint64_t NameByIndex = PCSServiceItemGetNameByIndex(v7);
  _PCSIdentityCopyBAT(a1);
  CFDataRef v9 = (const void *)objc_claimAutoreleasedReturnValue();
  uint64_t PublicKey = PCSIdentityGetPublicKey(a1);
  uint64_t v11 = @"pubkey";
  if (PublicKey) {
    uint64_t v11 = (__CFString *)PublicKey;
  }
  CFStringRef v12 = CFStringCreateWithFormat(0, 0, @"<PCSIdentity %@%@ pubkey: %@ service: %@ BAT: %@ %@>", v5, v4, v11, NameByIndex, v9, &stru_1F03DBED0);
  if (v9) {
    CFRelease(v9);
  }
  return v12;
}

CFDataRef PCSIdentityCopyCircleFingerPrint(uint64_t a1, const void **a2)
{
  if (!PCSIdentityWithAttributesCheck(a1, a2)) {
    return 0;
  }
  CFTypeID v4 = *(unsigned int **)(*(void *)(*(void *)(a1 + 16) + 16) + 24);
  uint64_t v5 = *v4;
  if (!v5)
  {
LABEL_6:
    _PCSError(a2, 83, @"old-identity2");
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *((void *)v4 + 1);
  uint64_t v8 = 24 * v5;
  while (*(_DWORD *)(v7 + v6) != 6)
  {
    v6 += 24;
    if (v8 == v6) {
      goto LABEL_6;
    }
  }
  CFIndex v12 = 0;
  long long v13 = 0;
  uint64_t v11 = 0;
  if (decode_PCSManateeCircleFingerPrint(*(void *)(v7 + v6 + 16), *(void *)(v7 + v6 + 8), (uint64_t)&v12, (uint64_t)&v11))
  {
    _PCSError(a2, 83, @"invalid-Circle-FingerPrint");
    return 0;
  }
  if (*(void *)(*((void *)v4 + 1) + v6 + 8) == v11) {
    CFDataRef v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v13, v12);
  }
  else {
    CFDataRef v9 = 0;
  }
  free_PCSManateeCircleFingerPrint((uint64_t)&v12);
  return v9;
}

uint64_t PCSIdentityWithAttributesCheck(uint64_t a1, const void **a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 && (uint64_t v3 = *(void *)(v2 + 16)) != 0)
  {
    if (*(void *)(v3 + 24)) {
      return 1;
    }
    if (*(_DWORD *)(v3 + 4) == 1) {
      _PCSError(a2, 83, @"old-identity");
    }
    else {
      _PCSError(a2, 83, @"service");
    }
  }
  else
  {
    _PCSError(a2, 83, @"raw-identity");
  }
  return 0;
}

uint64_t PCSIdentityGetCreationTime(uint64_t a1, const void **a2)
{
  uint64_t v2 = PCSIdentityCopyBuildAndTime(a1, a2);
  if (!v2) {
    return -1;
  }
  uint64_t v3 = v2;
  uint64_t v4 = *((void *)v2 + 1);
  free_PCSBuildAndTime((uint64_t)v2);
  free(v3);
  return v4;
}

void *PCSIdentityCopyBuildAndTime(uint64_t a1, const void **a2)
{
  if (PCSIdentityWithAttributesCheck(a1, a2))
  {
    uint64_t v4 = *(unsigned int **)(*(void *)(*(void *)(a1 + 16) + 16) + 24);
    uint64_t v5 = *v4;
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 24 * v5;
      CFStringRef v8 = @"old-identity2";
      while (*(_DWORD *)(*((void *)v4 + 1) + v6) != 1)
      {
        v6 += 24;
        if (v7 == v6) {
          goto LABEL_10;
        }
      }
      CFDataRef v9 = malloc_type_malloc(0x10uLL, 0x1010040FDD9F14CuLL);
      if (!decode_PCSBuildAndTime(*(void *)(*((void *)v4 + 1) + v6 + 16), *(void *)(*((void *)v4 + 1) + v6 + 8), (uint64_t)v9, 0))return v9; {
      CFStringRef v8 = @"invalid-BAT";
      }
LABEL_10:
      _PCSError(a2, 83, v8);
    }
    else
    {
      _PCSError(a2, 83, @"old-identity2");
    }
  }
  return 0;
}

__CFString *_PCSIdentityCopyBAT(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = 0;
  uint64_t v1 = PCSIdentityCopyBuildAndTime(a1, &v7);
  if (v1)
  {
    uint64_t v2 = v1;
    memset(&v6, 0, sizeof(v6));
    gmtime_r((const time_t *)v1 + 1, &v6);
    strftime(v8, 0x1EuLL, "%Y%m%d%H%M%S", &v6);
    uint64_t v3 = (__CFString *)CFStringCreateWithFormat(0, 0, @"%s;%s", v8, *v2);
    free_PCSBuildAndTime((uint64_t)v2);
    free(v2);
  }
  else
  {
    uint64_t v4 = v7;
    if (v7)
    {
      uint64_t v7 = 0;
      CFRelease(v4);
    }
    uint64_t v3 = 0;
  }
  return v3;
}

CFDataRef PCSIdentityWebSafePublicKeyID(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 16);
    if (v1) {
      uint64_t v2 = _PCSKeyCopyExportedPublicKey(v1);
    }
    else {
      uint64_t v2 = 0;
    }
    CFDataRef v3 = _PCSCopyWebSafePublicKey(v2);
    if (v2) {
      CFRelease(v2);
    }
  }
  else
  {
    CFDataRef v3 = 0;
  }
  return v3;
}

__CFData *PCSIdentityCopyExportedPublicKey(uint64_t a1)
{
  uint64_t result = *(__CFData **)(a1 + 16);
  if (result) {
    return _PCSKeyCopyExportedPublicKey((uint64_t)result);
  }
  return result;
}

CFDataRef _PCSCopyWebSafePublicKey(const __CFData *a1)
{
  CFDataRef v1 = a1;
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    ccsha256_di();
    CFDataGetLength(v1);
    CFDataGetBytePtr(v1);
    ccdigest();
    CFDataRef v2 = CFDataCreateWithBytesNoCopy(0, bytes, 20, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    CFDataRef v3 = (void *)MEMORY[0x1AD11CE50]();
    uint64_t v4 = [(__CFData *)v2 base64EncodedStringWithOptions:0];
    CFDataRef v1 = (const __CFData *)[v4 mutableCopy];

    [(__CFData *)v1 replaceOccurrencesOfString:@"+", @"-", 0, 0, [(__CFData *)v1 length] withString options range];
    [(__CFData *)v1 replaceOccurrencesOfString:@"/", @"_", 0, 0, [(__CFData *)v1 length] withString options range];
    [(__CFData *)v1 replaceOccurrencesOfString:@"=", &stru_1F03DBED0, 0, 0, [(__CFData *)v1 length] withString options range];
    if (v2) {
      CFRelease(v2);
    }
  }
  return v1;
}

void _PCSIdentitySetPersistentReference(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(const void **)(a1 + 48);
  if (v4)
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    CFRelease(v4);
  }
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = v3;
}

id _PCSIdentityGetPersistentReference(uint64_t a1)
{
  return *(id *)(a1 + 48);
}

void _PCSIdentityCheckPCSAttributes(uint64_t a1, void *a2)
{
  id v8 = a2;
  uint64_t v3 = [v8 objectForKeyedSubscript:*MEMORY[0x1E4F3B7A8]];
  if (v3)
  {
    uint64_t v4 = (void *)v3;
    uint64_t v5 = [v8 objectForKeyedSubscript:*MEMORY[0x1E4F3B7A0]];
    if (v5)
    {
      tm v6 = (void *)v5;
      uint64_t v7 = [v8 objectForKeyedSubscript:*MEMORY[0x1E4F3B7B0]];

      if (v7) {
        *(unsigned char *)(a1 + 56) = 1;
      }
    }
    else
    {
    }
  }
}

uint64_t _PCSIdentityHavePCSCKKSAttributes(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t _PCSIdentityGetCachedCurrentBit(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t PCSPublicIdentityGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __PCSPublicIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &PCSPublicIdentityGetTypeID_sPCSPublicIdentityGetTypeIDSingleton;
  if (PCSPublicIdentityGetTypeID_sPCSPublicIdentityGetTypeIDOnce != -1) {
    dispatch_once(&PCSPublicIdentityGetTypeID_sPCSPublicIdentityGetTypeIDOnce, block);
  }
  return PCSPublicIdentityGetTypeID_sPCSPublicIdentityGetTypeIDSingleton;
}

uint64_t __PCSPublicIdentityGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void PCSPublicIdentityDestroy(uint64_t a1)
{
  CFDataRef v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 24) = 0;
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    *(void *)(a1 + 16) = 0;
    CFRelease(v3);
  }
}

uint64_t PCSPublicIdentityCompare(const void *a1, const void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != PCSPublicIdentityGetTypeID()) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (v5 != PCSPublicIdentityGetTypeID()) {
    return 0;
  }
  if (a1 == a2) {
    return 1;
  }
  PublicID = (const void *)PCSPublicIdentityGetPublicID((uint64_t)a1);
  uint64_t v7 = (const void *)PCSPublicIdentityGetPublicID((uint64_t)a2);
  return CFEqual(PublicID, v7);
}

CFStringRef PCSPublicIdentityCopyDescription(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2 && (uint64_t v3 = *(unsigned int **)(v2 + 16)) != 0) {
    uint64_t v4 = *v3;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t PublicID = PCSPublicIdentityGetPublicID(a1);
  if (PublicID) {
    tm v6 = (__CFString *)PublicID;
  }
  else {
    tm v6 = @"pubkey";
  }
  uint64_t v7 = *(void *)(a1 + 24);
  id v8 = "";
  if (v7 && (*(unsigned char *)(v7 + 32) & 4) != 0) {
    id v8 = " div";
  }
  CFDataRef v9 = PCSPublicIdentityCopyWebSafePublicKeyID(a1);
  CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"<PCSPublicIdentity@%p pubkey: %@ (%@) service: %d%s>", a1, v6, v9, v4, v8);
  if (v9) {
    CFRelease(v9);
  }
  return v10;
}

uint64_t _PCSIdentityGetKey(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t _PCSPublicIdentityGetKey(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

BOOL _PCSFillOctetString(CFIndex *a1, CFDataRef theData)
{
  size_t Length = CFDataGetLength(theData);
  CFTypeID v5 = malloc_type_malloc(Length, 0xEEFE4A86uLL);
  a1[1] = (CFIndex)v5;
  if (v5)
  {
    BytePtr = CFDataGetBytePtr(theData);
    size_t v7 = CFDataGetLength(theData);
    memcpy(v5, BytePtr, v7);
    *a1 = CFDataGetLength(theData);
  }
  return v5 != 0;
}

void PCSAbort(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void PCSAbortv(char *a1, va_list a2)
{
  uint64_t v3 = 0;
  if (vasprintf(&v3, a1, a2) >= 1 && v3 != 0) {
    syslog(3, "PCSAbort: %s", v3);
  }
  abort();
}

void PCSAbortCF(CFStringRef format, ...)
{
  va_start(va, format);
  CFStringRef v1 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  char v2 = PCSCFStringToCString(v1);
  PCSAbort("%s", v3, v4, v5, v6, v7, v8, v9, v2);
}

CFStringRef _PCSCreateBase64(uint64_t a1, unint64_t a2, int a3)
{
  if (a3) {
    unint64_t v6 = ((4 * a2 / 3 + 67) >> 6) + 1;
  }
  else {
    unint64_t v6 = 0;
  }
  uint64_t v7 = (const char *)malloc_type_malloc(v6 + 4 * a2 / 3 + 5, 0xF20FCCE0uLL);
  uint64_t v8 = (char *)v7;
  uint64_t v9 = 0;
  if (a2)
  {
    unint64_t v10 = 0;
    do
    {
      int v11 = *(unsigned __int8 *)(a1 + v10) << 8;
      if (v10 + 1 < a2) {
        v11 |= *(unsigned __int8 *)(a1 + v10 + 1);
      }
      unint64_t v12 = (v11 << 8);
      if (v10 + 2 < a2) {
        unint64_t v12 = v12 | *(unsigned __int8 *)(a1 + v10 + 2);
      }
      v10 += 3;
      long long v13 = (char *)&v7[v9];
      char *v13 = _PCSCreateBase64_base64_chars[(unint64_t)v12 >> 18];
      v13[1] = _PCSCreateBase64_base64_chars[(v12 >> 12) & 0x3F];
      if (v10 <= a2 + 1) {
        char v14 = _PCSCreateBase64_base64_chars[(v12 >> 6) & 0x3F];
      }
      else {
        char v14 = 61;
      }
      v7[v9 + 2] = v14;
      if (v10 <= a2) {
        char v15 = _PCSCreateBase64_base64_chars[v12 & 0x3F];
      }
      else {
        char v15 = 61;
      }
      v7[v9 + 3] = v15;
      uint64_t v16 = v9 + 4;
      if ((v10 & 0xF) != 0 || !a3)
      {
        v9 += 4;
      }
      else
      {
        v9 += 5;
        v7[v16] = 10;
      }
    }
    while (v10 < a2);
    if ((v10 & 0xF) != 0 && a3) {
      v7[v9++] = 10;
    }
  }
  v7[v9] = 0;
  CFStringRef v17 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, 0x600u);
  free(v8);
  return v17;
}

CFStringRef __PCSCreateExportPEM(uint64_t a1, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  CFStringRef v6 = _PCSCreateBase64((uint64_t)BytePtr, Length, 1);
  CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"-----BEGIN %@-----\n%@-----END %@-----", a1, v6, a1);
  if (v6) {
    CFRelease(v6);
  }
  return v7;
}

uint64_t __PCSCreateWithPEM(const __CFData *a1)
{
  return 0;
}

uint64_t PCSIdentityGetServiceName(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (char v2 = *(int **)(v1 + 16)) != 0) {
    return PCSServiceItemGetNameByIndex(*v2);
  }
  else {
    return PCSServiceItemGetNameByIndex(0);
  }
}

uint64_t PCSIdentityGetServiceID(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (char v2 = *(unsigned int **)(v1 + 16)) != 0) {
    return *v2;
  }
  else {
    return 0;
  }
}

uint64_t PCSIdentityGetServiceViewHint(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (char v2 = *(int **)(v1 + 16)) != 0) {
    return PCSServiceItemGetViewHintByIndex(*v2);
  }
  else {
    return PCSServiceItemGetViewHintByIndex(0);
  }
}

__CFString *PCSIdentityGetServiceAccessGroup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (char v2 = *(int **)(v1 + 16)) != 0) {
    return PCSServiceItemGetAccessGroupByIndex(*v2);
  }
  else {
    return PCSServiceItemGetAccessGroupByIndex(0);
  }
}

uint64_t _PCSSignAlgToDI(unsigned __int16 a1, const void **a2)
{
  if (a1 == 2)
  {
    return ccsha512_di();
  }
  else if (a1 == 1)
  {
    return ccsha256_di();
  }
  else
  {
    _PCSError(a2, 29, @"Unsupported signature type: %d", a1);
    return 0;
  }
}

CFTypeRef PCSKeyCreateWithPCSSPKey(unsigned int *a1, const void **a2)
{
  unsigned int v3 = *a1;
  if (*a1 > 8) {
    goto LABEL_20;
  }
  if (((1 << v3) & 0xB) == 0)
  {
    if (((1 << v3) & 0x180) != 0)
    {
      uint64_t v5 = ccec_diversified_cp();
      if (v5)
      {
        CFStringRef v6 = (void *)v5;
        PCSKeyGetTypeID();
        uint64_t Instance = _CFRuntimeCreateInstance();
        uint64_t PublicWithData = (const void *)Instance;
        if (*a1 == 8) {
          char v9 = 6;
        }
        else {
          char v9 = 4;
        }
        *(unsigned char *)(Instance + 32) = v9 | *(unsigned char *)(Instance + 32) & 0xF8;
        if (!_PCSKeyAllocateDiversizedKey(v6, Instance)
          || ccec_der_import_diversified_pub())
        {
          CFTypeRef v10 = 0;
LABEL_18:
          CFRelease(PublicWithData);
          return v10;
        }
LABEL_17:
        CFTypeRef v10 = CFRetain(PublicWithData);
        goto LABEL_18;
      }
      return 0;
    }
    if (v3 == 2)
    {
      memset(v15, 0, sizeof(v15));
      uint64_t v14 = 0;
      uint64_t v12 = decode_PCSPrivateKey(*((void *)a1 + 3), *((void *)a1 + 2), (uint64_t)v15, (uint64_t)&v14);
      if (v12)
      {
        _PCSErrorASN1(a2, (uint64_t)"decode PCSPrivateKey", v12);
      }
      else
      {
        uint64_t PublicWithData = (const void *)PCSKeyCreate((uint64_t)v15, 0, a2);
        free_PCSPrivateKey((uint64_t)v15);
        if (PublicWithData) {
          goto LABEL_17;
        }
      }
      return 0;
    }
LABEL_20:
    _PCSError(a2, 72, @"unsupported keytype: %d", *a1);
    return 0;
  }
  CFDataRef v11 = CFDataCreateWithBytesNoCopy(0, *((const UInt8 **)a1 + 3), *((void *)a1 + 2), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFTypeRef v10 = v11;
  if (v11)
  {
    uint64_t PublicWithData = (const void *)PCSKeyCreatePublicWithData(v11, a2);
    CFRelease(v10);
    if (PublicWithData) {
      goto LABEL_17;
    }
    return 0;
  }
  return v10;
}

uint64_t PCSKeyCreate(uint64_t a1, int a2, const void **a3)
{
  BOOL v9 = 0;
  if (a2 && !*(void *)(a1 + 16)) {
    return 0;
  }
  PCSKeyGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v6 = Instance;
  if (!Instance)
  {
    _PCSErrorOOM(a3);
    return v6;
  }
  *(void *)(Instance + 24) = 0;
  *(unsigned char *)(Instance + 32) = *(unsigned char *)(Instance + 32) & 0xFA | 1;
  CFStringRef v7 = CopyPrivKeyFromOctetString(a1, 0, &v9);
  *(void *)(v6 + 40) = v7;
  *(unsigned char *)(v6 + 32) = *(unsigned char *)(v6 + 32) & 0xFD | (2 * v9);
  if (!v7
    || *(void *)(a1 + 16)
    && (*(void *)(v6 + 16) = malloc_type_malloc(0x30uLL, 0x10A0040698877B7uLL), copy_PCSPublicKeyInfo())
    || !SetKeyID(v6))
  {
    _PCSErrorOOM(a3);
    CFRelease((CFTypeRef)v6);
    return 0;
  }
  return v6;
}

uint64_t PCSKeyCreatePublicWithData(const __CFData *a1, const void **a2)
{
  int v13 = 0;
  PCSKeyGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v5 = Instance;
  if (!Instance)
  {
    _PCSErrorOOM(a2);
    return v5;
  }
  *(unsigned char *)(Instance + 32) &= ~1u;
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  uint64_t v6 = (void *)ccec_diversified_cp();
  if (v6)
  {
    *(unsigned char *)(v5 + 32) |= 4u;
    if (!_PCSKeyAllocateDiversizedKey(v6, v5)) {
      goto LABEL_10;
    }
    CFDataGetLength(a1);
    CFDataGetBytePtr(a1);
    if (ccec_der_import_diversified_pub()) {
      goto LABEL_10;
    }
    int v7 = (v13 >> 1) & 2 | *(unsigned char *)(v5 + 32) & 0xFD;
  }
  else
  {
    BOOL v12 = 0;
    *(unsigned char *)(v5 + 32) &= ~4u;
    BytePtr = CFDataGetBytePtr(a1);
    CFIndex Length = CFDataGetLength(a1);
    CFTypeRef v10 = CopyPublicKeyFromData((uint64_t)BytePtr, Length, &v12, a2);
    *(void *)(v5 + 40) = v10;
    if (!v10)
    {
LABEL_10:
      _PCSErrorOOM(a2);
      CFRelease((CFTypeRef)v5);
      return 0;
    }
    LOBYTE(v7) = *(unsigned char *)(v5 + 32) & 0xFD | (2 * v12);
  }
  *(unsigned char *)(v5 + 32) = v7;
  if (!SetKeyID(v5)) {
    goto LABEL_10;
  }
  return v5;
}

uint64_t ccec_diversified_cp()
{
  ccder_decode_constructed_tl();
  uint64_t result = ccder_decode_tl();
  if (result)
  {
    uint64_t result = ccder_decode_tl();
    if (result)
    {
      if (ccec_x963_import_pub_size()) {
        return ccec_get_cp();
      }
      uint64_t result = ccec_compact_import_pub_size();
      if (result) {
        return ccec_get_cp();
      }
    }
  }
  return result;
}

uint64_t _PCSKeyAllocateDiversizedKey(void *a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 32) & 4) == 0) {
    _PCSKeyAllocateDiversizedKey_cold_1();
  }
  uint64_t v4 = malloc_type_calloc(1uLL, 24 * *a1 + 16, 0x183D841BuLL);
  *(void *)(a2 + 40) = v4;
  if (!v4) {
    return 0;
  }
  size_t v5 = 24 * *a1 + 16;
  uint64_t v6 = 1;
  int v7 = malloc_type_calloc(1uLL, v5, 0x14CB240AuLL);
  *(void *)(a2 + 4_Block_object_dispose(&a9, 8) = v7;
  if (!v7) {
    return 0;
  }
  return v6;
}

void *CopyPublicKeyFromData(uint64_t a1, uint64_t a2, BOOL *a3, const void **a4)
{
  uint64_t v8 = ccec_x963_import_pub_size();
  BOOL v9 = (void *)v8;
  if (v8 || (BOOL v9 = (void *)ccec_compact_import_pub_size()) != 0)
  {
    if (!ccec_keysize_is_supported())
    {
      _PCSError(a4, 32, @"Key size %zd unsupported", v9);
      return 0;
    }
    cp = (void *)ccec_get_cp();
    BOOL v9 = malloc_type_calloc(1uLL, 24 * *cp + 16, 0x1EE3744DuLL);
    if (v9)
    {
      if (v8)
      {
        if (MEMORY[0x1AD11C8E0](cp, a2, a1, v9))
        {
          _PCSError(a4, 33, @"Failed to import public key");
LABEL_15:
          free(v9);
          return 0;
        }
      }
      else if (ccec_compact_import_pub())
      {
        _PCSError(a4, 33, @"Failed to import compact public key");
        goto LABEL_15;
      }
      if (a3) {
        *a3 = v8 == 0;
      }
    }
    else
    {
      _PCSErrorOOM(a4);
    }
  }
  return v9;
}

BOOL SetKeyID(uint64_t a1)
{
  if (*(void *)(a1 + 24)) {
    SetKeyID_cold_1();
  }
  char v2 = *(unsigned char *)(a1 + 32);
  if ((v2 & 4) != 0)
  {
    CFIndex v7 = ccec_der_export_diversified_pub_size();
    CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v7);
    if (!Mutable) {
      goto LABEL_17;
    }
    CFDataGetMutableBytePtr(Mutable);
    if (!ccec_der_export_diversified_pub())
    {
      unsigned int v3 = 0;
LABEL_14:
      CFRelease(Mutable);
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  unsigned int v3 = *(__CFData **)(a1 + 40);
  if (v3)
  {
    unint64_t v4 = cczp_bitlen() + 7;
    if ((v2 & 2) == 0)
    {
      CFIndex v5 = (v4 >> 2) | 1;
      CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
      CFDataSetLength(Mutable, v5);
      if (Mutable)
      {
        CFDataGetMutableBytePtr(Mutable);
        ccec_export_pub();
        goto LABEL_12;
      }
LABEL_17:
      unsigned int v3 = 0;
      goto LABEL_15;
    }
    CFIndex v8 = v4 >> 3;
    CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v8);
    if (!Mutable) {
      goto LABEL_17;
    }
    CFDataGetMutableBytePtr(Mutable);
    ccec_compact_export();
LABEL_12:
    ccsha256_di();
    CFDataGetLength(Mutable);
    CFDataGetBytePtr(Mutable);
    ccdigest();
    unsigned int v3 = CFDataCreateMutable(0, 0);
    CFDataSetLength(v3, 20);
    if (v3)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(v3);
      *(_OWORD *)MutableBytePtr = v11;
      *((_DWORD *)MutableBytePtr + 4) = v12;
    }
    goto LABEL_14;
  }
LABEL_15:
  *(void *)(a1 + 24) = v3;
  return v3 != 0;
}

CFTypeRef _PCSKeyCreateKeyIDFromData(const __CFData *a1)
{
  uint64_t PublicWithData = PCSKeyCreatePublicWithData(a1, 0);
  if (!PublicWithData) {
    return 0;
  }
  char v2 = (const void *)PublicWithData;
  unsigned int v3 = *(const void **)(PublicWithData + 24);
  if (v3) {
    CFTypeRef v4 = CFRetain(v3);
  }
  else {
    CFTypeRef v4 = 0;
  }
  CFRelease(v2);
  return v4;
}

__CFData *_PCSKeyCopyExportedPublicKey(uint64_t a1)
{
  if (!a1 || !*(void *)(a1 + 40)) {
    return 0;
  }
  char v1 = *(unsigned char *)(a1 + 32);
  if ((v1 & 4) != 0)
  {
    CFIndex v5 = ccec_der_export_diversified_pub_size();
    CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v5);
    if (!Mutable) {
      return Mutable;
    }
    CFDataGetMutableBytePtr(Mutable);
    if (ccec_der_export_diversified_pub()) {
      return Mutable;
    }
    CFRelease(Mutable);
    return 0;
  }
  unint64_t v2 = cczp_bitlen() + 7;
  if ((v1 & 2) != 0)
  {
    CFIndex v6 = v2 >> 3;
    CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v6);
    if (Mutable)
    {
      CFDataGetMutableBytePtr(Mutable);
      ccec_compact_export();
    }
  }
  else
  {
    CFIndex v3 = (v2 >> 2) | 1;
    CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v3);
    CFDataGetMutableBytePtr(Mutable);
    ccec_export_pub();
  }
  return Mutable;
}

__CFData *_PCSKeyCopyExportedPrivateKey(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 32) & 1) == 0) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 32) & 2) != 0)
  {
    CFIndex v4 = ((unint64_t)(cczp_bitlen() + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL;
    CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v4);
    if (Mutable)
    {
      CFDataGetMutableBytePtr(Mutable);
      ccec_compact_export();
    }
  }
  else
  {
    uint64_t v1 = ccec_der_export_priv_size();
    if (!v1) {
      return 0;
    }
    CFIndex v2 = v1;
    CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v2);
    CFDataGetMutableBytePtr(Mutable);
    if (ccec_der_export_priv() && Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

#error "1ACFA2334: call analysis failed (funcsize=111)"

uint64_t PCSIdentityCopyPublicKeyInfo(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 16)) != 0) {
    return PCSCreateExportedPublicKeyInfo(v2);
  }
  else {
    return 0;
  }
}

uint64_t PCSCreateExportedPublicKeyInfo(uint64_t a1)
{
  CFIndex v2 = length_PCSPublicKeyInfo(a1);
  CFDictionaryRef Mutable = CFDataCreateMutable(0, v2);
  if (!Mutable) {
    return 0;
  }
  CFIndex v4 = Mutable;
  uint64_t v8 = 0;
  CFDataSetLength(Mutable, v2);
  MutableBytePtr = CFDataGetMutableBytePtr(v4);
  if (encode_PCSPublicKeyInfo((uint64_t)&MutableBytePtr[v2 - 1], v2, a1, (uint64_t)&v8))
  {
    CFRelease(v4);
    return 0;
  }
  if (v2 == v8) {
    return (uint64_t)v4;
  }
  uint64_t v7 = asn1_abort();
  return PCSIdentityCreateWithExportedPrivateKey(v7);
}

CFTypeRef PCSIdentityCreateWithExportedPrivateKey(const __CFData *a1, const void **a2)
{
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v26 = 0;
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v6 = decode_PCSPrivateKeyV2((uint64_t)BytePtr, Length, (uint64_t)&v27, (uint64_t)&v26);
  if (v6)
  {
    _PCSErrorASN1(a2, (uint64_t)"decode PCSPrivateKeyV2", v6);
    return 0;
  }
  if (v27 == 2)
  {
    uint64_t v8 = [PCSManateeShareableIdentity alloc];
    BOOL v9 = [MEMORY[0x1E4F1C9B8] dataWithBytes:(void)v28 length:*((void *)&v27 + 1)];
    CFTypeRef v10 = [(PCSManateeShareableIdentity *)v8 initWithData:v9];

    if (v10)
    {
      if ([(PCSManateeShareableIdentity *)v10 hasEncryptionPrivateKey]
        && ([(PCSManateeShareableIdentity *)v10 encryptionPrivateKey],
            long long v11 = objc_claimAutoreleasedReturnValue(),
            int v12 = [v11 hasPrivateKey],
            v11,
            v12))
      {
        if ([(PCSManateeShareableIdentity *)v10 hasSigningPrivateKey])
        {
          int v13 = [(PCSManateeShareableIdentity *)v10 signingPrivateKey];
          int v14 = [v13 hasPrivateKey];

          if (v14)
          {
            char v15 = [(PCSManateeShareableIdentity *)v10 encryptionPrivateKey];
            CFDataRef v16 = [v15 privateKey];
            CFStringRef v17 = [(PCSManateeShareableIdentity *)v10 encryptionPrivateKey];
            CFDataRef v18 = [v17 publicKeyInfo];
            uint64_t v19 = _PCSIdentityCreateFromRawWithPublic(v16, v18, 0, a2);

            if (v19)
            {
              long long v20 = [(PCSManateeShareableIdentity *)v10 signingPrivateKey];
              CFDataRef v21 = [v20 privateKey];
              long long v22 = [(PCSManateeShareableIdentity *)v10 signingPrivateKey];
              CFDataRef v23 = [v22 publicKeyInfo];
              long long v24 = _PCSIdentityCreateFromRawWithPublic(v21, v23, 0, a2);

              if (v24)
              {
                _PCSIdentitySetSigningIdentity((uint64_t)v19, v24);
                CFTypeRef v7 = CFRetain(v19);
                CFRelease(v19);
                uint64_t v19 = v24;
              }
              else
              {
                CFTypeRef v7 = 0;
              }
              CFRelease(v19);
            }
            else
            {
              CFTypeRef v7 = 0;
            }

            goto LABEL_19;
          }
        }
        _PCSError(a2, 139, @"missing signing key");
      }
      else
      {
        _PCSError(a2, 139, @"missing encryption key");
      }
    }
    else
    {
      _PCSError(a2, 139, @"failed to deserialize PCSManateeShareableIdentity");
    }

    goto LABEL_18;
  }
  if (v27 != 1)
  {
    _PCSError(a2, 8, @"unexpected choice type for PCSPrivateKeyV2: %d", v27, v26);
LABEL_18:
    CFTypeRef v7 = 0;
    goto LABEL_19;
  }
  CFTypeRef v7 = PCSIdentityCreateWithPrivateKeyV1((uint64_t)&v27 + 8, 0, a2);
LABEL_19:
  free_PCSPrivateKeyV2((uint64_t)&v27);
  return v7;
}

void *PCSIdentityCreateWithKeychainAttributes(const __CFDictionary *a1, const void **a2)
{
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F3BD38]);
  if (!Value) {
    return 0;
  }
  CFDataRef v5 = Value;
  CFTypeID v6 = CFGetTypeID(Value);
  if (v6 != CFDataGetTypeID()) {
    return 0;
  }
  CFTypeRef v7 = PCSIdentityCreateWithExportedPrivateKey(v5, a2);
  if (v7)
  {
    CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F3B8C0]);
    if (v8)
    {
      CFNumberRef v9 = v8;
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 == CFNumberGetTypeID())
      {
        int valuePtr = 0;
        if (CFNumberGetValue(v9, kCFNumberIntType, &valuePtr))
        {
          if ((valuePtr & 0x10000) != 0) {
            long long v11 = (void *)MEMORY[0x1E4F1CFD0];
          }
          else {
            long long v11 = (void *)MEMORY[0x1E4F1CFC8];
          }
          v7[11] = *v11;
        }
      }
    }
  }
  return v7;
}

CFTypeRef PCSIdentityCreateWithPrivateKeyV1(uint64_t a1, int a2, const void **a3)
{
  uint64_t Empty = _PCSIdentityCreateEmpty(a3);
  if (!Empty) {
    return 0;
  }
  CFTypeRef v7 = (void *)Empty;
  uint64_t v8 = PCSKeyCreate(a1, a2, a3);
  v7[2] = v8;
  if (v8) {
    CFTypeRef v9 = CFRetain(v7);
  }
  else {
    CFTypeRef v9 = 0;
  }
  CFRelease(v7);
  return v9;
}

uint64_t _PCSIdentityCreateEmpty(const void **a1)
{
  PCSIdentityGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    _PCSErrorOOM(a1);
  }
  return Instance;
}

CFTypeRef PCSIdentityCreateDiversifiedIdentityOptions(uint64_t a1, const __CFData *a2, const __CFDictionary *cf, const void **a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4)
  {
    unsigned int v5 = *(unsigned __int8 *)(v4 + 32);
    if (v5)
    {
      if (cf && (CFTypeID v9 = CFGetTypeID(cf), v9 == CFDictionaryGetTypeID()))
      {
        int v10 = (v5 >> 1) & 1;
        CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(cf, (const void *)kPCSKeyDiversifiedCompact);
        if (Value)
        {
          CFBooleanRef v12 = Value;
          CFTypeID v13 = CFGetTypeID(Value);
          if (v13 == CFBooleanGetTypeID()) {
            int v10 = CFBooleanGetValue(v12) != 0;
          }
        }
      }
      else
      {
        int v10 = v5 & 2;
      }
      int v14 = **(void ***)(v4 + 40);
      PCSKeyGetTypeID();
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        CFDataRef v16 = (const void *)Instance;
        char v17 = v10 ? 6 : 4;
        *(unsigned char *)(Instance + 32) = *(unsigned char *)(Instance + 32) & 0xF8 | v17;
        *(void *)(Instance + 40) = 0;
        *(void *)(Instance + 4_Block_object_dispose(&a9, 8) = 0;
        size_t v18 = MEMORY[0x1AD11C870](v14);
        uint64_t v19 = malloc_type_malloc(v18, 0x976DFCEuLL);
        if (!v19
          || (ccsha256_di(), CFDataGetLength(a2), CFDataGetBytePtr(a2), cchkdf())
          || !_PCSKeyAllocateDiversizedKey(v14, (uint64_t)v16)
          || (ccDRBGGetRngState(), ccec_diversify_pub()))
        {
          CFTypeRef v20 = 0;
        }
        else
        {
          CFTypeRef v20 = CFRetain(v16);
        }
        CFRelease(v16);
        free(v19);
        if (v20)
        {
          CFTypeRef v21 = _PCSPublicIdentityCreateWithKey(v20, a4);
          CFRelease(v20);
          return v21;
        }
      }
      _PCSErrorOOM(a4);
    }
  }
  return 0;
}

CFTypeRef _PCSPublicIdentityCreateWithKey(const void *a1, const void **a2)
{
  if (a1)
  {
    PCSPublicIdentityGetTypeID();
    uint64_t Instance = (void *)_CFRuntimeCreateInstance();
    if (Instance)
    {
      unsigned int v5 = Instance;
      Instance[2] = 0;
      Instance[4] = 0;
      Instance[5] = 0;
      Instance[3] = CFRetain(a1);
      CFTypeRef v6 = CFRetain(v5);
      CFRelease(v5);
      return v6;
    }
    _PCSErrorOOM(a2);
  }
  return 0;
}

CFTypeRef PCSIdentityCreateDiversifiedIdentityFromPublicIdentityOptions(uint64_t a1, const __CFData *a2, const __CFDictionary *cf, const void **a4)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    return 0;
  }
  CFTypeRef v6 = *(void **)(v4 + 40);
  if (v6)
  {
    unsigned int v9 = *(unsigned __int8 *)(v4 + 32);
    if (cf && (CFTypeID v10 = CFGetTypeID(cf), v10 == CFDictionaryGetTypeID()))
    {
      int v11 = (v9 >> 1) & 1;
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(cf, (const void *)kPCSKeyDiversifiedCompact);
      if (Value)
      {
        CFBooleanRef v13 = Value;
        CFTypeID v14 = CFGetTypeID(Value);
        if (v14 == CFBooleanGetTypeID()) {
          int v11 = CFBooleanGetValue(v13) != 0;
        }
      }
    }
    else
    {
      int v11 = v9 & 2;
    }
    char v15 = (void *)*v6;
    if (*v6)
    {
      size_t v16 = MEMORY[0x1AD11C870](*v6);
      PCSKeyGetTypeID();
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        size_t v18 = (void **)Instance;
        if (v11) {
          char v19 = 6;
        }
        else {
          char v19 = 4;
        }
        *(unsigned char *)(Instance + 32) = *(unsigned char *)(Instance + 32) & 0xF8 | v19;
        *(void *)(Instance + 40) = 0;
        *(void *)(Instance + 4_Block_object_dispose(&a9, 8) = 0;
        CFTypeRef v20 = malloc_type_malloc(v16, 0x8DD1129uLL);
        if (v20)
        {
          CFTypeRef v21 = v20;
          ccsha256_di();
          CFDataGetLength(a2);
          CFDataGetBytePtr(a2);
          if (cchkdf()) {
            goto LABEL_28;
          }
          if (!_PCSKeyAllocateDiversizedKey(v15, (uint64_t)v18)) {
            goto LABEL_28;
          }
          ccDRBGGetRngState();
          if (ccec_diversify_pub()) {
            goto LABEL_28;
          }
          if ((v9 & 4) == 0)
          {
            long long v22 = 0;
LABEL_23:
            CFTypeRef v24 = CFRetain(v18);
            goto LABEL_24;
          }
          free(v18[6]);
          v18[6] = 0;
          CFDataRef v23 = malloc_type_calloc(1uLL, 24 * *v15 + 16, 0x1429E3C9uLL);
          v18[6] = v23;
          if (!v23)
          {
LABEL_28:
            CFTypeRef v24 = 0;
            long long v22 = 0;
          }
          else
          {
            long long v22 = malloc_type_calloc(1uLL, 24 * *v15 + 16, 0xDB6AF433uLL);
            if (v22)
            {
              ccDRBGGetRngState();
              if (!ccec_diversify_pub()) {
                goto LABEL_23;
              }
            }
            CFTypeRef v24 = 0;
          }
LABEL_24:
          CFRelease(v18);
          memset_s(v21, v16, 0, v16);
          free(v21);
          if (v22) {
            cc_clear();
          }
          free(v22);
          if (v24)
          {
            CFTypeRef v25 = _PCSPublicIdentityCreateWithKey(v24, a4);
            CFRelease(v24);
            return v25;
          }
          goto LABEL_30;
        }
        CFRelease(v18);
      }
    }
  }
LABEL_30:
  _PCSErrorOOM(a4);
  return 0;
}

uint64_t PCSPublicIdentityGetPublicKey(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 24) + 40);
}

uint64_t PCSIdentityGetPrivateKey(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 40);
}

uint64_t _PCSIdentityGetSigningIdentity(uint64_t a1)
{
  if (!*(void *)(a1 + 80))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2 && (CFIndex v3 = *(int **)(v2 + 16)) != 0) {
      int v4 = *v3;
    }
    else {
      int v4 = 0;
    }
    if (PCSServiceItemAllowSyntheticManateeSharing(v4))
    {
      unsigned int v5 = _PCSKeyCopyExportedPrivateKey(*(void *)(a1 + 16));
      CFDataRef v6 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)"SyntheticManateeSharing", 23, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      *(void *)(a1 + 80) = PCSDeriveIdentity(v5, 0, v6);
      if (v5) {
        CFRelease(v5);
      }
      CFRelease(v6);
    }
  }
  return *(void *)(a1 + 80);
}

CFTypeRef PCSDeriveIdentity(const __CFData *a1, int a2, const __CFData *a3)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  if (a2 == 2)
  {
    ccsha512_di();
    uint64_t v5 = ccec_cp_521();
  }
  else if (a2 == 1)
  {
    ccsha256_di();
    uint64_t v5 = MEMORY[0x1AD11C7D0]();
  }
  else
  {
    if (a2) {
      return 0;
    }
    ccsha256_di();
    uint64_t v5 = MEMORY[0x1AD11C7C0]();
  }
  CFDataRef v6 = (void *)v5;
  uint64_t v7 = cczp_bitlen();
  MEMORY[0x1F4188790](v7);
  unsigned int v9 = (char *)v18 - ((v8 + 23) & 0x3FFFFFFFFFFFFFF0);
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  CFDataGetLength(a3);
  CFDataGetBytePtr(a3);
  if (cchkdf() || (PCSIdentityGetTypeID(), (uint64_t v10 = _CFRuntimeCreateInstance()) == 0))
  {
    CFTypeRef v15 = 0;
  }
  else
  {
    int v11 = (uint64_t *)v10;
    PCSKeyGetTypeID();
    uint64_t Instance = _CFRuntimeCreateInstance();
    v11[2] = Instance;
    if (Instance
      && (*(void *)(v11[2] + 40) = malloc_type_calloc(1uLL, (32 * *v6) | 0x10, 0x8C6EB793uLL)) != 0
      && (ccDRBGGetRngState(), !ccec_generate_key_deterministic())
      && (*(unsigned char *)(v11[2] + 32) |= 1u, *(unsigned char *)(v11[2] + 32) &= ~2u, SetKeyID(v11[2]))
      && (uint64_t v14 = _PCSSignKey(v11[2], *(void *)(v11[2] + 40), (*(unsigned __int8 *)(v11[2] + 32) >> 1) & 1, 0, 0, v13, 0), (*(void *)(v11[2] + 16) = v14) != 0))
    {
      CFTypeRef v15 = CFRetain(v11);
    }
    else
    {
      CFTypeRef v15 = 0;
    }
    CFRelease(v11);
  }
  uint64_t v16 = cczp_bitlen();
  bzero(v9, (unint64_t)(v16 + 7) >> 3);
  return v15;
}

void _PCSIdentitySetSigningIdentity(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 80);
  if (v3 != cf)
  {
    if (v3)
    {
      *(void *)(a1 + 80) = 0;
      CFRelease(v3);
    }
    if (cf) {
      CFRetain(cf);
    }
    *(void *)(a1 + 80) = cf;
  }
}

CFDataRef PCSPublicIdentityCopyExportedPublicKey(uint64_t a1)
{
  CFDataRef result = *(CFDataRef *)(a1 + 24);
  if (result) {
    return PCSKeyCopyExportedPublicKey((uint64_t)result);
  }
  return result;
}

CFDataRef PCSKeyCopyExportedPublicKey(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (CFIndex v2 = *(void *)(v1 + 8)) != 0)
  {
    CFTypeRef v3 = *(const UInt8 **)(v1 + 16);
    return CFDataCreate(0, v3, v2);
  }
  else
  {
    char v5 = *(unsigned char *)(a1 + 32);
    if ((v5 & 4) != 0)
    {
      CFIndex v9 = ccec_der_export_diversified_pub_size();
      CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
      CFDataSetLength(Mutable, v9);
      if (Mutable)
      {
        CFDataGetMutableBytePtr(Mutable);
        if (!ccec_der_export_diversified_pub())
        {
          CFRelease(Mutable);
          return 0;
        }
      }
    }
    else
    {
      unint64_t v6 = cczp_bitlen() + 7;
      if ((v5 & 2) != 0)
      {
        CFIndex v10 = v6 >> 3;
        CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
        CFDataSetLength(Mutable, v10);
        if (Mutable)
        {
          CFDataGetMutableBytePtr(Mutable);
          ccec_compact_export();
        }
      }
      else
      {
        CFIndex v7 = (v6 >> 2) | 1;
        CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
        CFDataSetLength(Mutable, v7);
        if (Mutable)
        {
          CFDataGetMutableBytePtr(Mutable);
          ccec_export_pub();
        }
      }
    }
    return Mutable;
  }
}

void *PCSPublicIdentityCreateWithPublicKeyInfo(const __CFData *a1, const void **a2)
{
  uint64_t v10 = 0;
  memset(v11, 0, sizeof(v11));
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v6 = decode_PCSPublicKeyInfo((uint64_t)BytePtr, Length, (uint64_t)v11, (uint64_t)&v10);
  if (v6)
  {
    _PCSErrorASN1(a2, (uint64_t)"PCSPublicKeyInfo", v6);
LABEL_7:
    uint64_t Instance = 0;
    goto LABEL_4;
  }
  PCSPublicIdentityGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v8 = PCSKeyCreateWithPKI((uint64_t)v11, a2);
    Instance[3] = v8;
    if (!v8)
    {
      CFRelease(Instance);
      goto LABEL_7;
    }
  }
LABEL_4:
  free_PCSPublicKeyInfo((uint64_t)v11);
  return Instance;
}

uint64_t PCSKeyCreateWithPKI(uint64_t a1, const void **a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 4);
  if (v3 > 8) {
    goto LABEL_13;
  }
  int v4 = 1 << v3;
  if ((v4 & 0xB) != 0)
  {
    CFDataRef v5 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(a1 + 16), *(void *)(a1 + 8), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v5)
    {
      CFDataRef v6 = v5;
      uint64_t PublicWithData = PCSKeyCreatePublicWithData(v5, a2);
      CFRelease(v6);
      goto LABEL_11;
    }
LABEL_13:
    _PCSErrorOOM(a2);
    return 0;
  }
  if ((v4 & 0x180) == 0) {
    goto LABEL_13;
  }
  uint64_t v8 = ccec_diversified_cp();
  if (!v8) {
    goto LABEL_13;
  }
  CFIndex v9 = (void *)v8;
  PCSKeyGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance) {
    goto LABEL_13;
  }
  uint64_t PublicWithData = Instance;
  *(unsigned char *)(Instance + 32) = *(unsigned char *)(Instance + 32) & 0xF8 | 4;
  if (!_PCSKeyAllocateDiversizedKey(v9, Instance)) {
    goto LABEL_15;
  }
  if (ccec_der_import_diversified_pub()) {
    goto LABEL_15;
  }
  *(unsigned char *)(PublicWithData + 32) &= ~2u;
  if (!SetKeyID(PublicWithData)) {
    goto LABEL_15;
  }
LABEL_11:
  *(void *)(PublicWithData + 16) = malloc_type_malloc(0x30uLL, 0x10A0040698877B7uLL);
  if (copy_PCSPublicKeyInfo())
  {
LABEL_15:
    _PCSErrorOOM(a2);
    CFRelease((CFTypeRef)PublicWithData);
    return 0;
  }
  return PublicWithData;
}

uint64_t PCSPublicIdentityCopyPublicKeyInfo(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 16)) != 0) {
    return PCSCreateExportedPublicKeyInfo(v2);
  }
  else {
    return 0;
  }
}

uint64_t __PCSIdentitySetGetPrivateKey(uint64_t a1, void *a2, const void **a3)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    return 0;
  }
  if (!*(void *)(v3 + 16)) {
    goto LABEL_6;
  }
  CFIndex v7 = malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040698877B7uLL);
  a2[2] = v7;
  if (v7 && !copy_PCSPublicKeyInfo())
  {
    uint64_t v3 = *(void *)(a1 + 16);
LABEL_6:
    if (CopyOctetStringFromPrivKey((*(unsigned __int8 *)(v3 + 32) >> 1) & 1, 0, *(void *)(v3 + 40), (uint64_t)a2)) {
      return 1;
    }
    _PCSError(a3, 42, @"failed to export full key");
    goto LABEL_10;
  }
  _PCSErrorOOM(a3);
LABEL_10:
  free_PCSPrivateKey((uint64_t)a2);
  return 0;
}

uint64_t CopyOctetStringFromPrivKey(int a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1 || !a1)
  {
    size_t v9 = ccec_der_export_priv_size();
    if (v9)
    {
      size_t v10 = v9;
      int v11 = malloc_type_malloc(v9, 0x1E1D8B6CuLL);
      *(void *)(a4 + _Block_object_dispose(&a9, 8) = v11;
      if (v11)
      {
        *(void *)a4 = v10;
        if (!ccec_der_export_priv()) {
          return 1;
        }
        free(*(void **)(a4 + 8));
      }
    }
    return 0;
  }
  unint64_t v5 = (unint64_t)(cczp_bitlen() + 7) >> 2;
  uint64_t v6 = v5 & 0x3FFFFFFFFFFFFFFELL;
  if ((v5 & 0x3FFFFFFFFFFFFFFELL) == 0) {
    return 0;
  }
  CFIndex v7 = malloc_type_malloc(v5 & 0x3FFFFFFFFFFFFFFELL, 0xC77071B8uLL);
  *(void *)(a4 + _Block_object_dispose(&a9, 8) = v7;
  if (!v7) {
    return 0;
  }
  *(void *)a4 = v6;
  uint64_t v8 = 1;
  ccec_compact_export();
  return v8;
}

BOOL __PCSFillCurrentsKey(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  CFDataRef v4 = *(const __CFData **)(v3 + 24);
  *(_DWORD *)a2 = **(_DWORD **)(v3 + 16);
  return _PCSFillOctetString((CFIndex *)(a2 + 8), v4);
}

CFDataRef PCSIdentityCopyExternalForm(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v43 = 0;
  BOOL v44 = &v43;
  uint64_t v45 = 0x6010000000;
  int v46 = &unk_1AD014ACD;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  uint64_t v39 = 0;
  CFStringRef v40 = &v39;
  uint64_t v41 = 0x2020000000;
  int v42 = 0;
  if (!a1)
  {
    _PCSError(a3, 125, @"PCSIdentityCopyExternalForm: identity missing");
    goto LABEL_29;
  }
  long long v49 = 0uLL;
  long long v50 = 0uLL;
  long long v47 = 0uLL;
  long long v48 = 0uLL;
  CFStringRef v6 = *(const __CFString **)(a1 + 24);
  if (v6)
  {
    CFRetain(*(CFTypeRef *)(a1 + 24));
    CFIndex Length = CFStringGetLength(v6);
    CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    size_t v9 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0xE17BA2BFuLL);
    if (!CFStringGetCString(v6, v9, MaximumSizeForEncoding, 0x8000100u)) {
      *size_t v9 = 0;
    }
    CFRelease(v6);
    size_t v10 = v44;
  }
  else
  {
    size_t v9 = strdup("");
    size_t v10 = &v43;
  }
  v10[4] = (uint64_t)v9;
  if (*(_DWORD *)(a1 + 40))
  {
    int v11 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
    v44[10] = (uint64_t)v11;
    if (!v11)
    {
      _PCSErrorOOM(a3);
      goto LABEL_29;
    }
    _DWORD *v11 = *(_DWORD *)(a1 + 40);
  }
  CFDictionaryRef v12 = *(const __CFDictionary **)(a1 + 64);
  if (v12)
  {
    if (*(void *)(*(void *)(a1 + 16) + 16))
    {
      size_t v13 = CFDictionaryGetCount(v12) + 1;
      uint64_t v14 = (CFIndex *)malloc_type_calloc(v13, 0x18uLL, 0x10800404ACF7207uLL);
      v44[8] = (uint64_t)v14;
      uint64_t v15 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t v14 = **(_DWORD **)(v15 + 16);
      _PCSFillOctetString(v14 + 1, *(CFDataRef *)(v15 + 24));
      *((_DWORD *)v40 + 6) = 1;
      CFDictionaryRef v16 = *(const __CFDictionary **)(a1 + 64);
      if (v16)
      {
        context[0] = MEMORY[0x1E4F143A8];
        context[1] = 3221225472;
        context[2] = __PCSIdentityCopyExternalForm_block_invoke;
        context[3] = &unk_1E5E6DF20;
        context[4] = &v43;
        context[5] = &v39;
        context[6] = v13;
        CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)apply_block_2_0, context);
        if (v13 != *((_DWORD *)v40 + 6)) {
          __assert_rtn("PCSIdentityCopyExternalForm", "CloudIdentity.m", 2313, "n == count");
        }
      }
    }
  }
  if (!AddPCSKey((uint64_t)(v44 + 4), *(void *)(a1 + 16), a3)) {
    goto LABEL_29;
  }
  CFDictionaryRef v17 = *(const __CFDictionary **)(a1 + 72);
  if (v17)
  {
    if (*(void *)(*(void *)(a1 + 16) + 16))
    {
      uint64_t v34 = 0;
      CFStringRef v35 = &v34;
      uint64_t v36 = 0x2020000000;
      char v37 = 0;
      v33[0] = MEMORY[0x1E4F143A8];
      v33[1] = 3221225472;
      v33[2] = __PCSIdentityCopyExternalForm_block_invoke_2;
      v33[3] = &unk_1E5E6DF48;
      v33[4] = &v34;
      v33[5] = &v43;
      v33[6] = a1;
      v33[7] = a3;
      CFDictionaryApplyFunction(v17, (CFDictionaryApplierFunction)apply_block_2_0, v33);
      int v18 = *((unsigned __int8 *)v35 + 24);
      _Block_object_dispose(&v34, 8);
      if (v18) {
        goto LABEL_29;
      }
    }
  }
  uint64_t v34 = 0;
  CFIndex v19 = length_PCSKeySet((uint64_t)(v44 + 4));
  CFDictionaryRef Mutable = CFDataCreateMutable(0, v19);
  CFTypeRef v21 = Mutable;
  if (!Mutable) {
    goto LABEL_27;
  }
  CFDataSetLength(Mutable, v19);
  MutableBytePtr = CFDataGetMutableBytePtr(v21);
  uint64_t v23 = encode_PCSKeySet((uint64_t)&MutableBytePtr[v19 - 1], v19, (uint64_t)(v44 + 4), (uint64_t)&v34);
  if (v23)
  {
LABEL_20:
    CFRelease(v21);
LABEL_28:
    _PCSError(a3, 7, @"PCSKeySet encode error: %d", v23);
LABEL_29:
    CFDataRef ExternalRepresentation = 0;
LABEL_30:
    free_PCSKeySet((uint64_t)(v44 + 4));
    _Block_object_dispose(&v39, 8);
    _Block_object_dispose(&v43, 8);
    return ExternalRepresentation;
  }
  if (v19 != v34) {
    goto LABEL_44;
  }
  CFTypeRef v24 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  v44[9] = (uint64_t)v24;
  if (!v24) {
    goto LABEL_38;
  }
  CFTypeRef v25 = malloc_type_malloc(0x20uLL, 0x37027136uLL);
  *(void *)(v44[9] + _Block_object_dispose(&a9, 8) = v25;
  uint64_t v26 = (void *)v44[9];
  if (!v26[1])
  {
    _PCSErrorOOM(a3);
    goto LABEL_38;
  }
  *uint64_t v26 = 32;
  ccsha256_di();
  CFDataGetLength(v21);
  CFDataGetBytePtr(v21);
  ccdigest();
  CFRelease(v21);
  uint64_t v34 = 0;
  CFIndex v27 = length_PCSKeySet((uint64_t)(v44 + 4));
  long long v28 = CFDataCreateMutable(0, v27);
  CFTypeRef v21 = v28;
  if (!v28)
  {
LABEL_27:
    uint64_t v23 = 12;
    goto LABEL_28;
  }
  CFDataSetLength(v28, v27);
  uint64_t v29 = CFDataGetMutableBytePtr(v21);
  uint64_t v23 = encode_PCSKeySet((uint64_t)&v29[v27 - 1], v27, (uint64_t)(v44 + 4), (uint64_t)&v34);
  if (v23) {
    goto LABEL_20;
  }
  if (v27 == v34)
  {
    if (a2 == 1)
    {
      CFStringRef v32 = __PCSCreateExportPEM(kPCSPEMIdentityCollection, v21);
      if (v32)
      {
        CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(0, v32, 0x8000100u, 0);
        CFRelease(v32);
        goto LABEL_39;
      }
    }
    else
    {
      if (!a2)
      {
        CFRetain(v21);
        CFDataRef ExternalRepresentation = v21;
LABEL_39:
        CFRelease(v21);
        goto LABEL_30;
      }
      _PCSError(a3, 7, @"Invalid format: %d", a2);
    }
LABEL_38:
    CFDataRef ExternalRepresentation = 0;
    goto LABEL_39;
  }
LABEL_44:
  CFDataRef result = (CFDataRef)asn1_abort();
  __break(1u);
  return result;
}

void sub_1ACFA3E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 176), 8);
  _Unwind_Resume(a1);
}

BOOL __PCSIdentityCopyExternalForm_block_invoke(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a1[4] + 8) + 64) + 24 * *(unsigned int *)(*(void *)(a1[5] + 8) + 24);
  uint64_t v5 = *(void *)(a3 + 16);
  CFDataRef v6 = *(const __CFData **)(v5 + 24);
  *(_DWORD *)uint64_t v4 = **(_DWORD **)(v5 + 16);
  BOOL result = _PCSFillOctetString((CFIndex *)(v4 + 8), v6);
  uint64_t v8 = *(void *)(a1[5] + 8);
  unint64_t v9 = *(unsigned int *)(v8 + 24);
  if (a1[6] <= v9) {
    __PCSIdentityCopyExternalForm_block_invoke_cold_1();
  }
  *(_DWORD *)(v8 + 24) = v9 + 1;
  *(_DWORD *)(*(void *)(a1[4] + 8) + 56) = *(_DWORD *)(*(void *)(a1[5] + 8) + 24);
  return result;
}

uint64_t AddPCSKey(uint64_t a1, uint64_t a2, const void **a3)
{
  unsigned int v4 = *(unsigned __int8 *)(a2 + 32);
  if (v4)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = *(void *)(a2 + 16);
    if (CopyOctetStringFromPrivKey((v4 >> 1) & 1, 0, *(void *)(a2 + 40), (uint64_t)&v8))
    {
      int v6 = add_PCSPrivateKeys((unsigned int *)(a1 + 8));
      free(v9);
      if (!v6) {
        return 1;
      }
      _PCSErrorOOM(a3);
    }
    else
    {
      _PCSError(a3, 42, @"failed to export full key");
    }
  }
  else
  {
    _PCSError(a3, 40, @"Identity not a full identity");
  }
  return 0;
}

uint64_t __PCSIdentityCopyExternalForm_block_invoke_2(uint64_t result, const void *a2, uint64_t *cf1)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    uint64_t v5 = result;
    BOOL result = CFEqual(cf1, *(CFTypeRef *)(result + 48));
    if (!result)
    {
      BOOL result = CFEqual(*(CFTypeRef *)(cf1[2] + 24), a2);
      if (result)
      {
        BOOL result = AddPCSKey(*(void *)(*(void *)(v5 + 40) + 8) + 32, cf1[2], *(const void ***)(v5 + 56));
        if ((result & 1) == 0) {
          *(unsigned char *)(*(void *)(*(void *)(v5 + 32) + 8) + 24) = 1;
        }
      }
    }
  }
  return result;
}

BOOL _PCSIdentityAddFromExternalForm(uint64_t a1, int a2, CFDataRef theData, const void **a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 16)) {
    abort();
  }
  uint64_t v36 = 0;
  *(_OWORD *)cStr = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v10 = decode_PCSKeySet((uint64_t)BytePtr, Length, (uint64_t)cStr, (uint64_t)&v36);
  if (v10)
  {
    _PCSError(a4, 8, @"failed to decode PCSKeySet: %d", v10);
    goto LABEL_65;
  }
  if (!VerifyChecksum((uint64_t)cStr, a4)) {
    goto LABEL_65;
  }
  if ((void)v40) {
    *(_DWORD *)(a1 + 40) = *(_DWORD *)v40;
  }
  int v11 = *(const void **)(a1 + 24);
  if (v11)
  {
    *(void *)(a1 + 24) = 0;
    CFRelease(v11);
  }
  CFStringRef v12 = CFStringCreateWithCString(0, cStr[0], 0x8000100u);
  *(void *)(a1 + 24) = v12;
  if (!v12)
  {
    free_PCSKeySet((uint64_t)cStr);
    _PCSErrorOOM(a4);
    return 0;
  }
  if (!*(void *)(a1 + 16) && !DWORD2(v38) && LODWORD(cStr[1]) == 1)
  {
    *(void *)(a1 + 16) = PCSKeyCreate(v38, 0, a4);
    free_PCSKeySet((uint64_t)cStr);
    return *(void *)(a1 + 16) != 0;
  }
  if (!*(void *)(a1 + 72)) {
    *(void *)(a1 + 72) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  if (!*(void *)(a1 + 64)) {
    *(void *)(a1 + 64) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
LABEL_65:
    uint64_t v13 = 0;
    goto LABEL_51;
  }
  if (!LODWORD(cStr[1]))
  {
LABEL_34:
    if (*(void *)(a1 + 16)) {
      goto LABEL_35;
    }
    uint64_t v30 = DWORD2(v38);
    if (!DWORD2(v38)) {
      goto LABEL_35;
    }
    uint64_t v31 = (const UInt8 **)(v39 + 16);
    while (*((_DWORD *)v31 - 4) != 1)
    {
      v31 += 3;
      if (!--v30) {
        goto LABEL_35;
      }
    }
    CFDataRef v32 = CFDataCreate(0, *v31, (CFIndex)*(v31 - 1));
    CFBooleanRef Value = (CFTypeRef *)CFDictionaryGetValue(Mutable, v32);
    if (Value)
    {
      *(void *)(a1 + 16) = CFRetain(Value[2]);
      CFDictionaryRemoveValue(Mutable, v32);
      CFRelease(v32);
LABEL_35:
      CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)AddKeysApplier, *(void **)(a1 + 72));
      unint64_t v22 = DWORD2(v38);
      if (DWORD2(v38))
      {
        uint64_t v23 = 0;
        unint64_t v24 = 0;
        CFAllocatorRef v25 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
        do
        {
          uint64_t v26 = v39 + v23;
          if (*(_DWORD *)(v39 + v23) != 1)
          {
            CFDataRef v27 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(v26 + 16), *(void *)(v26 + 8), v25);
            *(void *)bytes = 0;
            int v42 = bytes;
            uint64_t v43 = 0x2020000000;
            BOOL v44 = 0;
            BOOL v44 = CFDictionaryGetValue(Mutable, v27);
            if (*((void *)v42 + 3)
              || (context[0] = MEMORY[0x1E4F143A8],
                  context[1] = 3221225472,
                  context[2] = ___PCSIdentityAddFromExternalForm_block_invoke,
                  context[3] = &unk_1E5E6DF70,
                  context[4] = bytes,
                  context[5] = v26,
                  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)apply_block_2_0, context),
                  *((void *)v42 + 3)))
            {
              if (v27) {
                CFRelease(v27);
              }
              CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, (const void *)v26);
              if (v28)
              {
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 64), v28, *((const void **)v42 + 3));
                CFRelease(v28);
              }
            }
            else if (v27)
            {
              CFRelease(v27);
            }
            _Block_object_dispose(bytes, 8);
            unint64_t v22 = DWORD2(v38);
          }
          ++v24;
          v23 += 24;
        }
        while (v24 < v22);
      }
      uint64_t v13 = 1;
      goto LABEL_50;
    }
    free_PCSKeySet((uint64_t)cStr);
    CFRelease(v32);
    CFRelease(Mutable);
    _PCSError(a4, 11, @"Master key is missing");
    return 0;
  }
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  while (1)
  {
    char v35 = 0;
    if (!a2) {
      break;
    }
    if (!_PCSValidateKey((void *)(v38 + v15), &v35, 0, 0, a4)) {
      goto LABEL_63;
    }
    if (!v35) {
      break;
    }
LABEL_33:
    ++v16;
    v15 += 24;
    if (v16 >= LODWORD(cStr[1])) {
      goto LABEL_34;
    }
  }
  uint64_t v17 = v38;
  uint64_t Empty = (void *)_PCSIdentityCreateEmpty(a4);
  if (!Empty) {
    goto LABEL_63;
  }
  uint64_t v19 = PCSKeyCreate(v17 + v15, 1, a4);
  Empty[2] = v19;
  if (!v19) {
    goto LABEL_62;
  }
  CFDictionarySetValue(Mutable, *(const void **)(v19 + 24), Empty);
  if (!*(void *)(Empty[2] + 16))
  {
LABEL_32:
    CFRelease(Empty);
    goto LABEL_33;
  }
  ccsha256_di();
  ccdigest();
  CFDataRef v20 = CFDataCreate(0, bytes, 20);
  CFDataRef v21 = v20;
  if (v20)
  {
    if (!CFEqual(v20, *(CFTypeRef *)(Empty[2] + 24))) {
      CFDictionarySetValue(Mutable, v21, Empty);
    }
    CFRelease(v21);
    goto LABEL_32;
  }
  _PCSErrorOOM(a4);
LABEL_62:
  CFRelease(Empty);
LABEL_63:
  uint64_t v13 = 0;
LABEL_50:
  CFRelease(Mutable);
LABEL_51:
  free_PCSKeySet((uint64_t)cStr);
  return v13;
}

void sub_1ACFA45D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t VerifyChecksum(uint64_t a1, const void **a2)
{
  v25[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)(a1 + 40);
  if (v2)
  {
    if (*v2 != 32)
    {
      uint64_t v24 = *v2;
      CFStringRef v11 = @"checksum wrong length %d";
      goto LABEL_21;
    }
    *(void *)(a1 + 40) = 0;
    v25[0] = 0;
    CFIndex v5 = length_PCSKeySet(a1);
    CFDictionaryRef Mutable = CFDataCreateMutable(0, v5);
    if (!Mutable)
    {
      uint64_t v10 = 12;
      goto LABEL_7;
    }
    CFIndex v7 = Mutable;
    CFDataSetLength(Mutable, v5);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    uint64_t v9 = encode_PCSKeySet((uint64_t)&MutableBytePtr[v5 - 1], v5, a1, (uint64_t)v25);
    if (v9)
    {
      uint64_t v10 = v9;
      CFRelease(v7);
LABEL_7:
      *(void *)(a1 + 40) = v2;
      uint64_t v24 = v10;
      CFStringRef v11 = @"PCSKeySet encode error: %d";
      CFStringRef v12 = a2;
      CFIndex v13 = 7;
LABEL_8:
      _PCSError(v12, v13, v11, v24);
      return 0;
    }
    if (v5 != v25[0])
    {
      uint64_t v23 = asn1_abort();
      return _PCSValidateKey(v23);
    }
    *(void *)(a1 + 40) = v2;
    ccsha256_di();
    CFDataGetLength(v7);
    CFDataGetBytePtr(v7);
    ccdigest();
    CFRelease(v7);
    uint64_t v15 = (uint64_t *)v2[1];
    uint64_t v16 = *v15;
    uint64_t v17 = v15[1];
    uint64_t v19 = v15[2];
    uint64_t v18 = v15[3];
    if (v25[0] != v16 || v25[1] != v17 || v25[2] != v19 || v25[3] != v18)
    {
      CFStringRef v11 = @"checksum wrong";
LABEL_21:
      CFStringRef v12 = a2;
      CFIndex v13 = 9;
      goto LABEL_8;
    }
  }
  return 1;
}

BOOL _PCSValidateKey(void *a1, unsigned char *a2, const __CFDictionary *a3, __CFString *a4, const void **a5)
{
  CFStringRef v10 = _PCSCreateHexString(*(char **)(a1[2] + 16), *(void *)(a1[2] + 8));
  if (!v10)
  {
    _PCSErrorOOM(a5);
    return 0;
  }
  CFStringRef v11 = v10;
  CFDataRef v12 = CFDataCreate(0, *(const UInt8 **)(a1[2] + 16), *(void *)(a1[2] + 8));
  if (!v12)
  {
    _PCSErrorOOM(a5);
    CFRelease(v11);
    return 0;
  }
  CFDataRef v13 = v12;
  CFDataRef KeyIDFromData = (const __CFData *)_PCSKeyCreateKeyIDFromData(v12);
  CFDataRef v15 = KeyIDFromData;
  if (!KeyIDFromData)
  {
    _PCSErrorOOM(a5);
    CFDataRef v21 = 0;
    CFStringRef v19 = 0;
LABEL_24:
    BOOL v22 = 0;
    goto LABEL_12;
  }
  BytePtr = (char *)CFDataGetBytePtr(KeyIDFromData);
  CFIndex Length = CFDataGetLength(v15);
  CFStringRef v18 = _PCSCreateHexString(BytePtr, Length);
  CFStringRef v19 = v18;
  if (!v18)
  {
    _PCSErrorOOM(a5);
    CFDataRef v21 = 0;
    goto LABEL_24;
  }
  OptionallyAppend(a4, @"Key: %d %@ - %@ (priv key size %d)\n", *(unsigned int *)a1[2], v11, v18, *a1);
  if (a3 && a4)
  {
    if (CFDictionaryGetValue(a3, v19)) {
      CFStringAppendFormat(a4, 0, @"\tWARNING: key is duplicated\n");
    }
    CFDictionarySetValue(a3, v19, v11);
  }
  uint64_t v20 = PCSKeyCreate((uint64_t)a1, 1, a5);
  CFDataRef v21 = (const void *)v20;
  if (!v20) {
    goto LABEL_24;
  }
  BOOL v22 = _PCSValidatePCSKey(v20, v13, a2, a4);
LABEL_12:
  CFRelease(v13);
  CFRelease(v11);
  if (v15) {
    CFRelease(v15);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v22;
}

void AddKeysApplier(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

CFStringRef _PCSCreateHexString(char *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unsigned int v4 = (const char *)malloc_type_calloc(1uLL, (2 * a2) | 1, 0x1D8DEAECuLL);
  CFIndex v5 = v4;
  int v6 = v4;
  if (v2)
  {
    CFIndex v7 = (char *)v4;
    do
    {
      *CFIndex v7 = a0123456789abcd[(unint64_t)*a1 >> 4];
      char v8 = *a1++;
      int v6 = v7 + 2;
      v7[1] = a0123456789abcd[v8 & 0xF];
      v7 += 2;
      --v2;
    }
    while (v2);
  }
  const char *v6 = 0;
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF90];
  return CFStringCreateWithCStringNoCopy(v9, v5, 0x8000100u, v10);
}

BOOL _PCSIdentityValidate(uint64_t a1, unsigned char *a2, __CFString *a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6 && (uint64_t v7 = *(void *)(v6 + 16)) != 0)
  {
    CFDataRef v8 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(v7 + 16), *(void *)(v7 + 8), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    BOOL v9 = _PCSValidatePCSKey(*(void *)(a1 + 16), v8, a2, a3);
    if (v8) {
      CFRelease(v8);
    }
    return v9;
  }
  else
  {
    return _PCSValidatePCSKey(v6, 0, a2, a3);
  }
}

BOOL _PCSValidatePCSKey(uint64_t a1, const void *a2, unsigned char *a3, __CFString *a4)
{
  if (a3) {
    *a3 = 0;
  }
  CFDataRef v8 = _PCSKeyCopyExportedPublicKey(a1);
  if (!v8)
  {
    BOOL v28 = 0;
    LOBYTE(v10) = 0;
    if (!a3) {
      return v28;
    }
    goto LABEL_28;
  }
  CFDataRef v9 = v8;
  if (!a2 || CFEqual(v8, a2)) {
    goto LABEL_6;
  }
  OptionallyAppend(a4, @"\tWARNING: public key and private does doesn't agree on what the public key is\n");
  __int16 v30 = 0;
  BytePtr = CFDataGetBytePtr(v9);
  CFIndex Length = CFDataGetLength(v9);
  CFDataRef v21 = (void **)CopyPublicKeyFromData((uint64_t)BytePtr, Length, (BOOL *)&v30 + 1, 0);
  if (!v21)
  {
    OptionallyAppend(a4, @"\tWARNING: public key is not a public key\n");
LABEL_6:
    BOOL v10 = 0;
    goto LABEL_7;
  }
  BOOL v22 = v21;
  uint64_t v23 = CFDataGetBytePtr((CFDataRef)a2);
  CFIndex v24 = CFDataGetLength((CFDataRef)a2);
  CFAllocatorRef v25 = (void **)CopyPublicKeyFromData((uint64_t)v23, v24, (BOOL *)&v30, 0);
  if (v25)
  {
    uint64_t v26 = v25;
    if (HIBYTE(v30) != v30) {
      OptionallyAppend(a4, @"\tWARNING: public keys are of different compact-ness\n");
    }
    if (**v22 == **v26)
    {
      int v27 = ccn_cmp();
      BOOL v10 = v27 != 0;
      if (v27) {
        OptionallyAppend(a4, @"\tERROR: public keys are just different, all is lost\n");
      }
      else {
        OptionallyAppend(a4, @"\tGOOD: public keys have same X, will probably work anyway\n");
      }
    }
    else
    {
      BOOL v10 = 0;
      OptionallyAppend(a4, @"\tWARNING: public keys are of differnt N\n");
    }
    free(v22);
    free(v26);
  }
  else
  {
    OptionallyAppend(a4, @"\tWARNING: key data is not a public key\n");
    free(v22);
    BOOL v10 = 1;
  }
LABEL_7:
  CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 16);
  CFDataRef v12 = (const __SecRandom *)*MEMORY[0x1E4F3BC60];
  size_t v13 = CFDataGetLength(Mutable);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!SecRandomCopyBytes(v12, v13, MutableBytePtr))
  {
    CFDataRef v15 = _PCSKeyCopyWrappedKey(a1, Mutable, 0);
    if (v15)
    {
      uint64_t v16 = v15;
      uint64_t v17 = _PCSKeyCopyUnwrappedData(a1, v15, 0);
      if (v17)
      {
        CFStringRef v18 = v17;
        if (!CFEqual(v17, Mutable))
        {
          OptionallyAppend(a4, @"\tERROR: failed to unwrap with private key");
          BOOL v10 = 1;
        }
        CFRelease(v18);
      }
      else
      {
        OptionallyAppend(a4, @"\tERROR: failed to unwrap with private key");
        BOOL v10 = 1;
      }
      CFRelease(v16);
      if (!Mutable) {
        goto LABEL_26;
      }
    }
    else
    {
      OptionallyAppend(a4, @"\tERROR: failed to wrap with private key");
      BOOL v10 = 1;
      if (!Mutable) {
        goto LABEL_26;
      }
    }
    CFRelease(Mutable);
LABEL_26:
    BOOL v28 = !v10;
    goto LABEL_27;
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  BOOL v28 = 0;
LABEL_27:
  CFRelease(v9);
  if (a3) {
LABEL_28:
  }
    *a3 = v10;
  return v28;
}

void OptionallyAppend(__CFString *a1, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1) {
    CFStringAppendFormatAndArguments(a1, 0, format, va);
  }
}

__CFString *PCSIdentityCopyDiagnostic(const __CFData *a1, int a2, unsigned char *a3, const void **a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  CFIndex v8 = PCSServiceItemsCount();
  v41[2] = v41;
  unint64_t v9 = v8 + 1;
  uint64_t v10 = MEMORY[0x1F4188790](v8);
  CFDataRef v12 = (_DWORD *)((char *)v41 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
  MEMORY[0x1F4188790](v10);
  uint64_t v14 = (_DWORD *)((char *)v41 - v13);
  if ((v15 & 1) == 0)
  {
    bzero(v12, 4 * v8 + 4);
    bzero(v14, 4 * v8 + 4);
  }
  if (a2) {
    unint64_t v16 = 7;
  }
  else {
    unint64_t v16 = v8;
  }
  if (v16 > v9) {
    abort();
  }
  uint64_t v42 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  *a3 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable || (v18 = Mutable, (CFMutableStringRef v19 = CFStringCreateMutable(0, 0)) == 0))
  {
    _PCSErrorOOM(a4);
    *a3 = 1;
    free_PCSKeySet((uint64_t)&v43);
    return 0;
  }
  uint64_t v20 = v19;
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v23 = decode_PCSKeySet((uint64_t)BytePtr, Length, (uint64_t)&v43, (uint64_t)&v42);
  if (v23)
  {
    _PCSError(a4, 8, @"failed to decode PCSKeySet: %d", v23);
    goto LABEL_52;
  }
  uint64_t v24 = v42;
  if (v24 != CFDataGetLength(a1))
  {
    _PCSError(a4, 8, @"PCSKeySet not the full buffer");
    goto LABEL_52;
  }
  if (!VerifyChecksum((uint64_t)&v43, a4))
  {
LABEL_52:
    *a3 = 1;
    free_PCSKeySet((uint64_t)&v43);
    CFRelease(v20);
    return 0;
  }
  CFStringAppendFormat(v20, 0, @"Name: %s\n", (void)v43);
  if (*((void *)&v45 + 1)) {
    CFAllocatorRef v25 = @"YES";
  }
  else {
    CFAllocatorRef v25 = @"NO";
  }
  CFStringAppendFormat(v20, 0, @"Checksum: %@\n", v25);
  if (*((void *)&v45 + 1))
  {
    uint64_t v27 = **((void **)&v45 + 1);
    uint64_t v26 = *(char **)(*((void *)&v45 + 1) + 8);
  }
  else
  {
    v41[1] = ccsha256_di();
    CFDataGetLength(a1);
    CFDataGetBytePtr(a1);
    ccdigest();
    uint64_t v26 = &v47;
    uint64_t v27 = 32;
  }
  CFStringRef v28 = _PCSCreateHexString(v26, v27);
  CFStringAppendFormat(v20, 0, @"ksID: %@\n", v28);
  if (v28) {
    CFRelease(v28);
  }
  CFStringAppendFormat(v20, 0, @"Keys %u:\n", DWORD2(v43));
  CFStringAppendFormat(v20, 0, @"Key bag:\n");
  if (DWORD2(v43))
  {
    uint64_t v29 = 0;
    unint64_t v30 = 0;
    uint64_t v31 = v44;
    while (_PCSValidateKey((void *)(v31 + v29), a3, v18, v20, a4))
    {
      uint64_t v31 = v44;
      unint64_t v32 = **(unsigned int **)(v44 + v29 + 16);
      if (v9 > v32) {
        ++v12[v32];
      }
      ++v30;
      v29 += 24;
      if (v30 >= DWORD2(v43)) {
        goto LABEL_26;
      }
    }
    goto LABEL_52;
  }
LABEL_26:
  CFStringAppendFormat(v20, 0, @"Current keys:\n");
  if (DWORD2(v44))
  {
    uint64_t v33 = 0;
    unint64_t v34 = 0;
    uint64_t v35 = v45;
    do
    {
      CFStringRef v36 = _PCSCreateHexString(*(char **)(v35 + v33 + 16), *(void *)(v35 + v33 + 8));
      CFStringAppendFormat(v20, 0, @"keys service: %d data: %@\n", *(unsigned int *)(v45 + v33), v36);
      if (v36) {
        CFRelease(v36);
      }
      uint64_t v35 = v45;
      unint64_t v37 = *(unsigned int *)(v45 + v33);
      if (v9 > v37) {
        ++v14[v37];
      }
      ++v34;
      v33 += 24;
    }
    while (v34 < DWORD2(v44));
  }
  free_PCSKeySet((uint64_t)&v43);
  if (v16)
  {
    for (uint64_t i = 0; i != v16; ++i)
    {
      if (i)
      {
        if (!v12[i]) {
          CFStringAppendFormat(v20, 0, @"expected service not found service %d\n", i);
        }
      }
      else if (*v12)
      {
        CFStringAppendFormat(v20, 0, @"unepexcted service 0");
      }
    }
    for (uint64_t j = 0; j != v16; ++j)
    {
      if (j)
      {
        if (v14[j] != 1) {
          CFStringAppendFormat(v20, 0, @"current service found %u of service %d\n", v14[j], j);
        }
      }
      else if (*v14)
      {
        CFStringAppendFormat(v20, 0, @"unexpected service 0\n");
      }
    }
  }
  return v20;
}

uint64_t PCSIdentityIsPartial(uint64_t result)
{
  if (result) {
    return (*(unsigned __int8 *)(result + 40) >> 1) & 1;
  }
  return result;
}

uint64_t PCSIdentityGetPublicKey(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 16);
      if (v4)
      {
        *(void *)(a1 + 32) = _PCSCreateBase64(*(void *)(v4 + 16), *(void *)(v4 + 8), 0);
      }
      else
      {
        CFIndex v5 = _PCSKeyCopyExportedPublicKey(v3);
        if (v5)
        {
          CFDataRef v6 = v5;
          BytePtr = CFDataGetBytePtr(v5);
          CFIndex Length = CFDataGetLength(v6);
          *(void *)(a1 + 32) = _PCSCreateBase64((uint64_t)BytePtr, Length, 0);
          CFRelease(v6);
        }
      }
    }
  }
  return *(void *)(a1 + 32);
}

uint64_t PCSTestCDPStatus(uint64_t result)
{
  fakeCdpOnForTest = result;
  return result;
}

uint64_t PCSIdentityGetCDPStatus(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    if (+[PCSUtilities deviceNeedsCompanion])
    {
      if (PCSIdentitySetCompanionCircleMember(a1, a3)) {
        return 0;
      }
      else {
        return 30;
      }
    }
    else
    {
      uint64_t v5 = fakeCdpOnForTest;
      if (fakeCdpOnForTest == 99)
      {
        uint64_t v7 = (void *)MEMORY[0x1AD11CE50]();
        CFIndex v8 = _PCSIdentitySetGetAltDSIDorPCSAccountsModel(a1);
        if (v8)
        {
          id v9 = objc_alloc_init(MEMORY[0x1E4F3B438]);
          [v9 setAltDSID:v8];
          [v9 setContext:*MEMORY[0x1E4F3B458]];
          uint64_t v10 = (void *)[objc_alloc(MEMORY[0x1E4F3B430]) initWithContextData:v9];
          id v11 = objc_alloc_init(MEMORY[0x1E4F3B448]);
          [v11 setUseCachedAccountStatus:1];
          id v15 = 0;
          uint64_t v12 = [v10 fetchCliqueStatus:v11 error:&v15];
          id v13 = v15;
          if (v12 == 2) {
            unsigned int v14 = 10;
          }
          else {
            unsigned int v14 = 30;
          }
          if (v12) {
            uint64_t v5 = v14;
          }
          else {
            uint64_t v5 = 0;
          }
        }
        else
        {
          _PCSError(a3, 90, @"cannot determine altDSID");
          uint64_t v5 = 30;
        }
      }
    }
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 30;
  }
  return v5;
}

uint64_t PCSCurrentPersonaMatchesDSIDFromSet(uint64_t a1)
{
  uint64_t v2 = (void *)_PCSIdentitySetCopyPersonaIdentifier(a1);
  uint64_t v3 = [MEMORY[0x1E4FB36F8] sharedManager];
  uint64_t v4 = [v3 currentPersona];

  uint64_t v5 = [v4 userPersonaUniqueString];
  CFDataRef v6 = (void *)v5;
  if (!v2 || !v5 || ([v2 isEqualToString:v5] & 1) == 0)
  {
    DSID = (void *)_PCSIdentitySetGetDSID(a1);
    if (!PCSCurrentPersonaMatchesDSID(DSID))
    {
      uint64_t v8 = 0;
      goto LABEL_8;
    }
    _PCSIdentitySetSetPersonaIdentifier(a1, (uint64_t)v6);
  }
  uint64_t v8 = 1;
LABEL_8:

  return v8;
}

uint64_t PCSIdentityGetServiceStatus(uint64_t a1, void *a2, const void **a3)
{
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) == 0)
  {
    CFStringRef v9 = @"Current persona does not match chosen dsid";
    uint64_t v10 = a3;
    CFIndex v11 = 152;
LABEL_7:
    _PCSError(v10, v11, v9);
    return 30;
  }
  if (!a1)
  {
    CFStringRef v9 = @"No Identity Set Specified";
LABEL_13:
    uint64_t v10 = a3;
    CFIndex v11 = 83;
    goto LABEL_7;
  }
  if (!a2)
  {
    CFStringRef v9 = @"No Service Specified";
    goto LABEL_13;
  }
  CFDataRef v6 = PCSIdentitySetCopyCurrentIdentityWithError(a1, a2, 0);
  if (v6)
  {
    CFRelease(v6);
    return 0;
  }
  else
  {
    return PCSIdentityGetCDPStatus(a1, v7, a3);
  }
}

void *PCSIdentityCopyPublicIdentity(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  PCSPublicIdentityGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  uint64_t v3 = *(void *)(*(void *)(a1 + 16) + 16);
  if (v3)
  {
    uint64_t v4 = PCSKeyCreateWithPKI(v3, 0);
    Instance[3] = v4;
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    CFDataRef v5 = PCSKeyCopyExportedPublicKey(*(void *)(a1 + 16));
    if (v5)
    {
      CFDataRef v6 = v5;
      Instance[3] = PCSKeyCreatePublicWithData(v5, 0);
      CFRelease(v6);
      if (!Instance[3]) {
        goto LABEL_9;
      }
    }
    else if (Instance)
    {
LABEL_9:
      CFRelease(Instance);
      return 0;
    }
  }
  return Instance;
}

void *PCSIdentityCreateFromRaw(const __CFData *a1, int a2, const void **a3)
{
  return _PCSIdentityCreateFromRawWithPublic(a1, 0, a2, a3);
}

void *_PCSIdentityCreateFromRawWithPublic(const __CFData *a1, const __CFData *a2, int a3, const void **a4)
{
  uint64_t Empty = (void *)_PCSIdentityCreateEmpty(0);
  if (Empty)
  {
    BOOL v16 = 0;
    v17[1] = CFDataGetBytePtr(a1);
    v17[0] = CFDataGetLength(a1);
    PCSKeyGetTypeID();
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      uint64_t v10 = Instance;
      *(unsigned char *)(Instance + 32) = *(unsigned char *)(Instance + 32) & 0xFA | 1;
      CFIndex v11 = CopyPrivKeyFromOctetString((uint64_t)v17, a3, &v16);
      *(void *)(v10 + 40) = v11;
      if (v11)
      {
        *(unsigned char *)(v10 + 32) = *(unsigned char *)(v10 + 32) & 0xFD | (2 * v16);
        if (a2)
        {
          *(void *)(v10 + 16) = malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040698877B7uLL);
          uint64_t v15 = 0;
          BytePtr = CFDataGetBytePtr(a2);
          CFIndex Length = CFDataGetLength(a2);
          if (decode_PCSPublicKeyInfo((uint64_t)BytePtr, Length, *(void *)(v10 + 16), (uint64_t)&v15))
          {
            free(*(void **)(v10 + 16));
            *(void *)(v10 + 16) = 0;
          }
        }
        if (SetKeyID(v10))
        {
          Empty[2] = v10;
          return Empty;
        }
      }
      _PCSErrorOOM(a4);
      CFRelease((CFTypeRef)v10);
    }
    else
    {
      _PCSErrorOOM(a4);
    }
    Empty[2] = 0;
    CFRelease(Empty);
    return 0;
  }
  return Empty;
}

CFDataRef PCSIdentityCreateExportedRawCompact(uint64_t a1, const void **a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if ((*(unsigned char *)(v3 + 32) & 1) == 0)
  {
    _PCSError(a2, 40, @"Identity not a full identity");
    return 0;
  }
  if ((*(unsigned char *)(v3 + 32) & 2) == 0)
  {
    _PCSError(a2, 41, @"Identity not a compact identity");
    return 0;
  }
  CFIndex v7 = 0;
  uint64_t v8 = 0;
  if ((CopyOctetStringFromPrivKey(1, 1, *(void *)(v3 + 40), (uint64_t)&v7) & 1) == 0)
  {
    _PCSErrorOOM(a2);
    return 0;
  }
  CFDataRef v6 = v8;
  CFDataRef v4 = CFDataCreate(0, v8, v7);
  cc_clear();
  free(v6);
  if (!v4) {
    _PCSErrorOOM(a2);
  }
  return v4;
}

void *PCSIdentityCreateRandomCompactRaw(const void **a1)
{
  uint64_t Empty = (void *)_PCSIdentityCreateEmpty(a1);
  if (Empty)
  {
    uint64_t RandomFullKey = PCSKeyCreateRandomFullKey(1);
    Empty[2] = RandomFullKey;
    if (!RandomFullKey)
    {
      _PCSErrorOOM(a1);
      CFRelease(Empty);
      return 0;
    }
  }
  return Empty;
}

uint64_t PCSKeyCreateRandomFullKey(int a1)
{
  PCSKeyGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v3 = (void *)MEMORY[0x1AD11C7C0]();
    if (a1) {
      char v4 = 3;
    }
    else {
      char v4 = 1;
    }
    *(unsigned char *)(Instance + 32) = v4 | *(unsigned char *)(Instance + 32) & 0xF8;
    CFDataRef v5 = malloc_type_calloc(1uLL, (32 * *v3) | 0x10, 0xDB0553D3uLL);
    if (!v5) {
      goto LABEL_9;
    }
    CFDataRef v6 = v5;
    ccDRBGGetRngState();
    if (a1)
    {
      if (ccec_compact_generate_key())
      {
LABEL_8:
        free(v6);
LABEL_9:
        *(void *)(Instance + 40) = 0;
LABEL_12:
        CFRelease((CFTypeRef)Instance);
        return 0;
      }
    }
    else if (ccec_generate_key_fips())
    {
      goto LABEL_8;
    }
    *(void *)(Instance + 40) = v6;
    if (!SetKeyID(Instance)) {
      goto LABEL_12;
    }
  }
  return Instance;
}

CFNumberRef PCSIdentityCopyServiceNumber(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    uint64_t v1 = *(void *)(v1 + 16);
    if (v1) {
      LODWORD(v1) = *(_DWORD *)v1;
    }
  }
  int valuePtr = v1;
  return CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
}

CFTypeRef PCSIdentityCopyCurrentKeyFingerprint(uint64_t a1)
{
  return CFRetain(*(CFTypeRef *)(*(void *)(a1 + 16) + 24));
}

BOOL PCSIdentityCheckWrappable(uint64_t a1, const void **a2)
{
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 16);
  CFDataRef v5 = (const __SecRandom *)*MEMORY[0x1E4F3BC60];
  size_t Length = CFDataGetLength(Mutable);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (SecRandomCopyBytes(v5, Length, MutableBytePtr) || (uint64_t v8 = *(void *)(a1 + 16)) == 0)
  {
    uint64_t v12 = 0;
    CFStringRef v9 = 0;
    goto LABEL_10;
  }
  CFStringRef v9 = _PCSKeyCopyWrappedKey(v8, Mutable, a2);
  if (!v9 || (uint64_t v10 = *(void *)(a1 + 16)) == 0)
  {
    uint64_t v12 = 0;
LABEL_10:
    BOOL v13 = 0;
    if (!Mutable) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  CFIndex v11 = _PCSKeyCopyUnwrappedData(v10, v9, a2);
  uint64_t v12 = v11;
  if (!v11) {
    goto LABEL_10;
  }
  BOOL v13 = CFEqual(v11, Mutable) != 0;
  if (Mutable) {
LABEL_11:
  }
    CFRelease(Mutable);
LABEL_12:
  if (v9) {
    CFRelease(v9);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v13;
}

__CFData *PCSIdentityCopyWrappedKey(uint64_t a1, const __CFData *a2, const void **a3)
{
  BOOL result = *(__CFData **)(a1 + 16);
  if (result) {
    return _PCSKeyCopyWrappedKey((uint64_t)result, a2, a3);
  }
  return result;
}

__CFData *_PCSIdentityCopyUnwappedKey(uint64_t a1, const __CFData *a2, const void **a3)
{
  BOOL result = *(__CFData **)(a1 + 16);
  if (result) {
    return _PCSKeyCopyUnwrappedData((uint64_t)result, a2, a3);
  }
  return result;
}

uint64_t PCSIdentityCheckValidPublicKey(uint64_t a1, void *a2)
{
  id v3 = a2;
  char v4 = v3;
  if (a1)
  {
    uint64_t v5 = *(void *)(a1 + 16);
    id v6 = v3;
    __int16 v35 = 0;
    if (v5)
    {
      if (*(void *)(v5 + 16))
      {
        CFIndex v7 = _PCSKeyCopyExportedPublicKey(v5);
        if (v7)
        {
          uint64_t v8 = v7;
          CFDataRef v9 = CFDataCreate(0, *(const UInt8 **)(*(void *)(v5 + 16) + 16), *(void *)(*(void *)(v5 + 16) + 8));
          if (v9)
          {
            CFDataRef v10 = v9;
            if (CFEqual(v8, v9))
            {
              uint64_t v11 = 1;
LABEL_22:
              CFRelease(v8);
              CFRelease(v10);
LABEL_23:

              goto LABEL_24;
            }
            BytePtr = CFDataGetBytePtr(v8);
            CFIndex Length = CFDataGetLength(v8);
            unsigned int v14 = (void **)CopyPublicKeyFromData((uint64_t)BytePtr, Length, (BOOL *)&v35 + 1, 0);
            if (v14)
            {
              CFDataRef v21 = v14;
              BOOL v22 = CFDataGetBytePtr(v10);
              CFIndex v23 = CFDataGetLength(v10);
              uint64_t v24 = (void **)CopyPublicKeyFromData((uint64_t)v22, v23, (BOOL *)&v35, 0);
              if (v24)
              {
                uint64_t v31 = v24;
                if (HIBYTE(v35) == v35)
                {
                  if (**v21 == **v24)
                  {
                    if (!ccn_cmp())
                    {
                      uint64_t v11 = 1;
                      goto LABEL_21;
                    }
                    CFStringRef v32 = @"Different X between the keys, all is lost";
                  }
                  else
                  {
                    CFStringRef v32 = @"Different n of the keys";
                  }
                }
                else
                {
                  CFStringRef v32 = @"Different compactness";
                }
                InvalidPublicKey(v6, v32, v25, v26, v27, v28, v29, v30, v34);
                uint64_t v11 = 0;
LABEL_21:
                free(v21);
                free(v31);
                goto LABEL_22;
              }
              InvalidPublicKey(v6, @"Failed to parse the PKI from the public key", v25, v26, v27, v28, v29, v30, v34);
              free(v21);
            }
            else
            {
              InvalidPublicKey(v6, @"Failed to parse the exported public key", v15, v16, v17, v18, v19, v20, v34);
            }
            uint64_t v11 = 0;
            goto LABEL_22;
          }
          CFRelease(v8);
        }
      }
    }
    uint64_t v11 = 0;
    goto LABEL_23;
  }
  uint64_t v11 = 0;
LABEL_24:

  return v11;
}

uint64_t PCSPublicIdentityGetPublicID(uint64_t a1)
{
  if (!*(void *)(a1 + 16))
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      uint64_t v4 = *(void *)(v3 + 16);
      if (v4)
      {
        *(void *)(a1 + 16) = _PCSCreateBase64(*(void *)(v4 + 16), *(void *)(v4 + 8), 0);
      }
      else
      {
        CFDataRef v5 = PCSKeyCopyExportedPublicKey(v3);
        if (v5)
        {
          CFDataRef v6 = v5;
          BytePtr = CFDataGetBytePtr(v5);
          CFIndex Length = CFDataGetLength(v6);
          *(void *)(a1 + 16) = _PCSCreateBase64((uint64_t)BytePtr, Length, 0);
          CFRelease(v6);
        }
      }
    }
  }
  return *(void *)(a1 + 16);
}

void *PCSPublicIdentityCreateFromKeyData(const __CFData *a1, const void **a2)
{
  PCSPublicIdentityGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t PublicWithData = PCSKeyCreatePublicWithData(a1, a2);
    Instance[3] = PublicWithData;
    if (!PublicWithData)
    {
      CFRelease(Instance);
      return 0;
    }
  }
  return Instance;
}

BOOL _PCSPublicIdentityIsDiversified(uint64_t a1)
{
  BOOL result = 0;
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 24);
    if (v1)
    {
      if ((*(unsigned char *)(v1 + 32) & 4) != 0) {
        return 1;
      }
    }
  }
  return result;
}

CFTypeRef _PCSPublicIdentityCreateWithPCSSPKey(unsigned int *a1, const void **a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeRef v3 = PCSKeyCreateWithPCSSPKey(a1, a2);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  CFTypeRef v5 = _PCSPublicIdentityCreateWithKey(v3, a2);
  CFRelease(v4);
  return v5;
}

uint64_t _PCSPublicIdentityExportPCSSPKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 24);
  if (!v9 || (CFDataRef v11 = PCSKeyCopyExportedPublicKey(v9)) == 0) {
    PCSAbort("failed to get public identity:keydata != NULL", a2, a3, a4, a5, a6, a7, a8, v25);
  }
  CFDataRef v12 = v11;
  uint64_t v13 = *(void *)(a1 + 24);
  if (v13)
  {
    char v14 = *(unsigned char *)(v13 + 32);
    if (v14) {
      int v15 = 2;
    }
    else {
      int v15 = 3;
    }
    if ((v14 & 2) != 0) {
      int v16 = 8;
    }
    else {
      int v16 = 7;
    }
    if ((v14 & 4) != 0) {
      LODWORD(v13) = v16;
    }
    else {
      LODWORD(v13) = v15;
    }
  }
  *(_DWORD *)a2 = v13;
  *(void *)(a2 + _Block_object_dispose(&a9, 8) = 0;
  if (!_PCSFillOctetString((CFIndex *)(a2 + 16), v11)) {
    PCSAbort("failed to allocate keydata:_PCSFillOctetString(&data->keyData, keydata)", v17, v18, v19, v20, v21, v22, v23, v25);
  }
  CFRelease(v12);
  return 1;
}

CFDataRef PCSPublicIdentityCopyPublicKey(uint64_t a1)
{
  CFDataRef result = *(CFDataRef *)(a1 + 24);
  if (result) {
    return PCSKeyCopyExportedPublicKey((uint64_t)result);
  }
  return result;
}

uint64_t _PCSExportRandomPCSSPKey(uint64_t a1)
{
  uint64_t RandomFullKey = (const void *)PCSKeyCreateRandomFullKey(0);
  CFDataRef v3 = PCSKeyCopyExportedPublicKey((uint64_t)RandomFullKey);
  *(_DWORD *)a1 = 3;
  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
  if (!_PCSFillOctetString((CFIndex *)(a1 + 16), v3)) {
    PCSAbort("failed to allocate keydata:_PCSFillOctetString(&data->keyData, keydata)", v4, v5, v6, v7, v8, v9, v10, v12);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (RandomFullKey) {
    CFRelease(RandomFullKey);
  }
  return 1;
}

CFDataRef PCSPublicIdentityCopyWebSafePublicKeyID(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    CFDataRef v2 = PCSKeyCopyExportedPublicKey(v1);
    CFDataRef v3 = _PCSCopyWebSafePublicKey(v2);
    if (v2) {
      CFRelease(v2);
    }
    return v3;
  }
  return _PCSCopyWebSafePublicKey(0);
}

uint64_t PCSPublicIdentityGetServiceName(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1 && (CFDataRef v2 = *(int **)(v1 + 16)) != 0) {
    return PCSServiceItemGetNameByIndex(*v2);
  }
  else {
    return PCSServiceItemGetNameByIndex(0);
  }
}

uint64_t PCSPublicIdentityGetServiceID(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1 && (CFDataRef v2 = *(unsigned int **)(v1 + 16)) != 0) {
    return *v2;
  }
  else {
    return 0;
  }
}

const void *PCSPublicIdentityGetService(uint64_t a1, void *a2, void *key, const void **a4)
{
  if (!key)
  {
    int IndexByName = PCSServiceItemGetIndexByName(a2);
    if (IndexByName)
    {
      NumberByIndex = (const void *)PCSServiceItemGetNumberByIndex(IndexByName);
      if (NumberByIndex)
      {
        CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), NumberByIndex);
        if (!Value) {
          return Value;
        }
        goto LABEL_7;
      }
    }
    else
    {
      _PCSError(a4, 2, @"unknown service key: %@", a2);
    }
    return 0;
  }
  CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), key);
  if (!Value)
  {
    _PCSError(a4, 2, @"no such keyid: %@", key);
    return Value;
  }
LABEL_7:
  uint64_t TypeID = PCSPublicIdentityGetTypeID();
  if (TypeID != CFGetTypeID(Value)) {
    PCSPublicIdentityGetService_cold_1();
  }
  return Value;
}

CFTypeRef PCSPublicIdentityCopyCurrentKeyFingerprint(uint64_t a1)
{
  return CFRetain(*(CFTypeRef *)(*(void *)(a1 + 24) + 24));
}

__CFData *PCSPublicServiceIdentityCopyWrappedKey(uint64_t a1, const __CFData *a2, const void **a3)
{
  CFDataRef result = *(__CFData **)(a1 + 24);
  if (result) {
    return _PCSKeyCopyWrappedKey((uint64_t)result, a2, a3);
  }
  return result;
}

__CFData *_PCSKeyCopyWrappedKey(uint64_t a1, const __CFData *a2, const void **a3)
{
  uint64_t v6 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49F8;
  uint64_t v7 = _CopyECPGPWrappedData(a1, a2, a3);
  qword_1EB3B4A00 += PCSMeasureRelativeNanoTime() - v6;
  return v7;
}

__CFData *_PCSKeyCopyUnwrappedData(uint64_t a1, const __CFData *a2, const void **a3)
{
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v7 = PCSMeasureRelativeNanoTime();
    ++qword_1EB3B4A08;
    uint64_t v8 = _CopyECPGPUnwrappedData(a1, a2, a3);
    qword_1EB3B4A10 += PCSMeasureRelativeNanoTime() - v7;
    return v8;
  }
  else
  {
    _PCSError(a3, 40, @"Identity not a full identity");
    return 0;
  }
}

__CFData *PCSServiceIdentityCopyUnwrappedKey(uint64_t a1, const __CFData *a2, const void **a3)
{
  CFDataRef result = *(__CFData **)(a1 + 16);
  if (result) {
    return _PCSKeyCopyUnwrappedData((uint64_t)result, a2, a3);
  }
  return result;
}

uint64_t _PCSSignHash(uint64_t a1, const __CFData *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((*(unsigned char *)(a1 + 32) & 1) == 0) {
    return 0;
  }
  uint64_t result = _PCSSignAlgToDI(a3, 0);
  if (!result) {
    return result;
  }
  if (*(void *)result != a4) {
    return 0;
  }
  *(_DWORD *)(a6 + 16) = a3;
  size_t v11 = (((unint64_t)(cczp_bitlen() + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL) + 9;
  *(void *)(a6 + 24) = v11;
  *(void *)(a6 + 32) = malloc_type_malloc(v11, 0x539AEF0uLL);
  uint64_t v12 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B4A18;
  ccDRBGGetRngState();
  int v13 = ccec_sign();
  qword_1EB3B4A20 += PCSMeasureRelativeNanoTime() - v12;
  if (v13) {
    return 0;
  }
  if (!a2) {
    return 1;
  }
  uint64_t result = _PCSFillOctetString((CFIndex *)a6, a2);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t _PCSSignKey(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, const void **a7)
{
  uint64_t v12 = malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040698877B7uLL);
  uint64_t v13 = (uint64_t)v12;
  if (!v12)
  {
    _PCSErrorOOM(a7);
    return v13;
  }
  _DWORD *v12 = a4;
  if (a5)
  {
    char v14 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    *(void *)(v13 + 24) = v14;
    if (!v14 || copy_PCSAttributes()) {
      goto LABEL_16;
    }
  }
  *(_DWORD *)(v13 + 4) = 1;
  unint64_t v15 = cczp_bitlen() + 7;
  if (a3)
  {
    *(void *)(v13 + _Block_object_dispose(&a9, 8) = v15 >> 3;
    int v16 = malloc_type_malloc(v15 >> 3, 0x8B1154B8uLL);
    *(void *)(v13 + 16) = v16;
    if (v16)
    {
      ccec_compact_export();
      goto LABEL_11;
    }
LABEL_16:
    _PCSErrorOOM(a7);
LABEL_21:
    free_PCSPublicKeyInfo(v13);
    free((void *)v13);
    return 0;
  }
  size_t v17 = (v15 >> 2) | 1;
  *(void *)(v13 + _Block_object_dispose(&a9, 8) = v17;
  uint64_t v18 = malloc_type_malloc(v17, 0x40E893D6uLL);
  *(void *)(v13 + 16) = v18;
  if (!v18) {
    goto LABEL_16;
  }
  ccec_export_pub();
LABEL_11:
  CFDataRef v19 = (const __CFData *)PCSCreateExportedPublicKeyInfo(v13);
  uint64_t v20 = malloc_type_calloc(1uLL, 0x28uLL, 0x1080040EC46ECBEuLL);
  *(void *)(v13 + 32) = v20;
  if (!v20)
  {
    _PCSErrorOOM(a7);
    goto LABEL_19;
  }
  CFDataRef v21 = *(const __CFData **)(a1 + 24);
  CFIndex Length = CFDataGetLength(v19);
  BytePtr = CFDataGetBytePtr(v19);
  if ((signData(a1, v21, 1u, Length, (uint64_t)BytePtr, *(void *)(v13 + 32)) & 1) == 0)
  {
    _PCSError(a7, 16, @"Signing of service key failed");
LABEL_19:
    if (v19) {
      CFRelease(v19);
    }
    goto LABEL_21;
  }
  if (v19) {
    CFRelease(v19);
  }
  return v13;
}

uint64_t signData(uint64_t a1, const __CFData *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t result = _PCSSignAlgToDI(a3, 0);
  if (result)
  {
    uint64_t v11 = result;
    ((void (*)(void))MEMORY[0x1F4188790])();
    uint64_t v13 = (char *)v17 - v12;
    ccdigest_init();
    uint64_t v14 = ccdigest_update();
    if (a3 >= 0x10000)
    {
      v17[1] = bswap32(a3);
      uint64_t v14 = ccdigest_update();
    }
    MEMORY[0x1F4188790](v14);
    int v16 = (char *)v17 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    (*(void (**)(uint64_t, char *, char *))(v11 + 56))(v11, v13, v16);
    return _PCSSignHash(a1, a2, a3, *(void *)v11, (uint64_t)v16, a6);
  }
  return result;
}

void *_PCSVerifyHash(int a1, unsigned __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, const void **a6)
{
  uint64_t result = (void *)_PCSSignAlgToDI(a2, 0);
  if (result)
  {
    if (*result == a3)
    {
      uint64_t v9 = PCSMeasureRelativeNanoTime();
      ++qword_1EB3B4A28;
      uint64_t v10 = ccec_verify();
      qword_1EB3B4A30 += PCSMeasureRelativeNanoTime() - v9;
      _PCSError(a6, 31, @"Verification failed, ret=%d, %svalid", v10, "!");
    }
    return 0;
  }
  return result;
}

uint64_t PCSIdentityIsNewManatee(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 16);
  if (!v2) {
    return 0;
  }
  CFDataRef v3 = *(unsigned int **)(v2 + 24);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *v3;
  if (!v4) {
    return 0;
  }
  for (uint64_t i = (void *)(*((void *)v3 + 1) + 8); *((_DWORD *)i - 2) != 3 || !*i; i += 3)
  {
    if (!--v4) {
      return 0;
    }
  }
  return 1;
}

BOOL PCSIdentityIsFullManatee(uint64_t a1)
{
  v3[0] = 0;
  v3[1] = 0;
  BOOL ManateeFlags = _PCSIdentityGetManateeFlags(a1, v3);
  if (ManateeFlags) {
    free_PCSManateeFlags((uint64_t)v3);
  }
  return ManateeFlags;
}

BOOL _PCSIdentityGetManateeFlags(uint64_t a1, void *a2)
{
  *a2 = 0;
  a2[1] = 0;
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(void *)(v2 + 16);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(unsigned int **)(v3 + 24);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *v4;
  if (!v5) {
    return 0;
  }
  for (uint64_t i = (uint64_t *)(*((void *)v4 + 1) + 16); *((_DWORD *)i - 4) != 3; i += 3)
  {
    if (!--v5) {
      return 0;
    }
  }
  uint64_t v10 = 0;
  uint64_t v8 = *(i - 1);
  return v8 && decode_PCSManateeFlags(*i, v8, (uint64_t)a2, (uint64_t)&v10) == 0;
}

BOOL _PCSIdentityIsManatee(uint64_t a1)
{
  BOOL result = 1;
  if (!PCSIdentityIsFullManatee(a1))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2 && (uint64_t v3 = *(int **)(v2 + 16)) != 0) {
      int v4 = *v3;
    }
    else {
      int v4 = 0;
    }
    uint64_t NameByIndex = (void *)PCSServiceItemGetNameByIndex(v4);
    if (!NameByIndex || (PCSServiceItemTypeIsManatee(NameByIndex) & 1) == 0) {
      return 0;
    }
  }
  return result;
}

BOOL _PCSIdentityRequireManateeSigning(uint64_t a1)
{
  BOOL result = _PCSIdentityIsManatee(a1);
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3 && (int v4 = *(int **)(v3 + 16)) != 0) {
      int v5 = *v4;
    }
    else {
      int v5 = 0;
    }
    uint64_t NameByIndex = (const void *)PCSServiceItemGetNameByIndex(v5);
    BOOL result = 1;
    if (NameByIndex)
    {
      uint64_t v7 = NameByIndex;
      if (CFEqual(NameByIndex, (CFTypeRef)kPCSWalletPaymentServices2)
        || CFEqual(v7, (CFTypeRef)kPCSCoreIDVServiceMessages))
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _PCSIdentitySupportsServerSigning(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    BOOL result = _PCSIdentityIsManatee(result);
    if (result)
    {
      uint64_t v2 = *(void *)(v1 + 16);
      if (v2 && (uint64_t v3 = *(int **)(v2 + 16)) != 0) {
        int v4 = *v3;
      }
      else {
        int v4 = 0;
      }
      uint64_t NameByIndex = (const void *)PCSServiceItemGetNameByIndex(v4);
      return NameByIndex && CFEqual(NameByIndex, (CFTypeRef)kPCSEnergyKitAmiLimitedPeers);
    }
  }
  return result;
}

uint64_t _PCSIdentityIsShareableManatee(uint64_t a1)
{
  v3[0] = 0;
  v3[1] = 0;
  if (!_PCSIdentityGetManateeFlags(a1, v3)) {
    return 0;
  }
  uint64_t v1 = v3[0] & 1;
  free_PCSManateeFlags((uint64_t)v3);
  return v1;
}

uint64_t _PCSIdentityIsTooRolled(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(int **)(v1 + 16)) != 0) {
    int v3 = *v2;
  }
  else {
    int v3 = 0;
  }
  uint64_t result = PCSServiceItemGetNameByIndex(v3);
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = _PCSServiceItemsGetTooRolledServiceTypes();
    uint64_t v7 = [v6 containsObject:v5];

    return v7;
  }
  return result;
}

const void *PCSIdentityCreateFromData(const __CFData *a1, const void **a2)
{
  uint64_t Empty = _PCSIdentityCreateEmpty(a2);
  uint64_t v5 = (const void *)Empty;
  if (Empty && !_PCSIdentityAddFromExternalForm(Empty, 0, a1, a2))
  {
    CFRelease(v5);
    return 0;
  }
  return v5;
}

CFDictionaryRef PCSIdentityCopyExportedPrivateKey(uint64_t a1, const void **a2)
{
  if (!_PCSIdentityIsShareableManatee(a1))
  {
    CFIndex v37 = 0;
    long long v38 = 0;
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v39 = *(void *)(v11 + 16);
    if (CopyOctetStringFromPrivKey((*(unsigned __int8 *)(v11 + 32) >> 1) & 1, 0, *(void *)(v11 + 40), (uint64_t)&v37))
    {
      uint64_t v36 = 0;
      CFIndex v12 = length_PCSPrivateKey((uint64_t)&v37);
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, v12);
      if (Mutable)
      {
        uint64_t v14 = Mutable;
        CFDataSetLength(Mutable, v12);
        MutableBytePtr = CFDataGetMutableBytePtr(v14);
        if (!encode_PCSPrivateKey((uint64_t)&MutableBytePtr[v12 - 1], v12, (uint64_t)&v37, (uint64_t)&v36))
        {
          if (v12 != v36) {
            goto LABEL_34;
          }
          free(v38);
          return v14;
        }
        CFRelease(v14);
      }
      free(v38);
    }
    else
    {
      _PCSError(a2, 42, @"failed to export full key");
    }
    return 0;
  }
  uint64_t SigningIdentity = _PCSIdentityGetSigningIdentity(a1);
  if (!SigningIdentity)
  {
    _PCSError(a2, 144, @"identity has no signing identity");
    return 0;
  }
  uint64_t v5 = SigningIdentity;
  uint64_t v6 = objc_opt_new();
  uint64_t v7 = _PCSKeyCopyExportedPrivateKey(*(void *)(a1 + 16));
  [v6 setPrivateKey:v7];

  uint64_t v8 = *(void *)(a1 + 16);
  if (v8 && (uint64_t v9 = *(void *)(v8 + 16)) != 0) {
    uint64_t v10 = (void *)PCSCreateExportedPublicKeyInfo(v9);
  }
  else {
    uint64_t v10 = 0;
  }
  [v6 setPublicKeyInfo:v10];

  int v16 = objc_opt_new();
  size_t v17 = _PCSKeyCopyExportedPrivateKey(*(void *)(v5 + 16));
  [v16 setPrivateKey:v17];

  uint64_t v18 = *(void *)(v5 + 16);
  if (v18 && (uint64_t v19 = *(void *)(v18 + 16)) != 0) {
    uint64_t v20 = (void *)PCSCreateExportedPublicKeyInfo(v19);
  }
  else {
    uint64_t v20 = 0;
  }
  [v16 setPublicKeyInfo:v20];

  CFDataRef v21 = objc_alloc_init(PCSManateeShareableIdentity);
  [(PCSManateeShareableIdentity *)v21 setEncryptionPrivateKey:v6];
  [(PCSManateeShareableIdentity *)v21 setSigningPrivateKey:v16];
  uint64_t v22 = [(PCSManateeShareableIdentity *)v21 encryptionPrivateKey];
  if (!v22
    || (uint64_t v23 = (void *)v22,
        [(PCSManateeShareableIdentity *)v21 signingPrivateKey],
        uint64_t v24 = objc_claimAutoreleasedReturnValue(),
        v24,
        v23,
        !v24))
  {
    _PCSError(a2, 143, @"failed to create PCSManateeShareableIdentity data");
LABEL_29:
    uint64_t v14 = 0;
LABEL_30:

    return v14;
  }
  CFIndex v37 = 0;
  long long v38 = 0;
  CFDataRef v25 = [(PCSManateeShareableIdentity *)v21 data];
  _PCSFillOctetString(&v37, v25);

  uint64_t v36 = 0;
  CFIndex v26 = length_PCSPrivateKeyProtoBuf((uint64_t)&v37);
  uint64_t v27 = CFDataCreateMutable(0, v26);
  if (!v27)
  {
    uint64_t v30 = 12;
    goto LABEL_28;
  }
  uint64_t v14 = v27;
  CFDataSetLength(v27, v26);
  uint64_t v28 = CFDataGetMutableBytePtr(v14);
  uint64_t v29 = encode_PCSPrivateKeyProtoBuf((uint64_t)&v28[v26 - 1], v26, (uint64_t)&v37, (uint64_t)&v36);
  if (v29)
  {
    uint64_t v30 = v29;
    CFRelease(v14);
LABEL_28:
    free(v38);
    _PCSErrorASN1(a2, (uint64_t)"Failed to encode PCSPrivateKeyProtoBuf", v30);
    goto LABEL_29;
  }
  if (v26 == v36)
  {
    free(v38);
    goto LABEL_30;
  }
LABEL_34:
  uint64_t v32 = asn1_abort();
  return PCSIdentityGetService(v32, v33, v34, v35);
}

CFDictionaryRef PCSIdentityGetService(uint64_t a1, void *a2, void *key, const void **a4)
{
  if (key)
  {
    CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 72);
    return (const __CFDictionary *)CFDictionaryGetValue(v5, key);
  }
  else
  {
    unsigned int IndexByName = PCSServiceItemGetIndexByName(a2);
    if (IndexByName)
    {
      return _PCSIdentityGetServiceWithID(a1, IndexByName, a4);
    }
    else
    {
      return 0;
    }
  }
}

CFDictionaryRef _PCSIdentityGetServiceWithID(uint64_t a1, unsigned int a2, const void **a3)
{
  uint64_t NumberByIndex = PCSServiceItemGetNumberByIndex(a2);
  if (!NumberByIndex)
  {
    _PCSError(a3, 30, @"Service ID 0 not acceptable");
    return 0;
  }
  uint64_t v7 = (const void *)NumberByIndex;
  CFDictionaryRef result = *(const __CFDictionary **)(a1 + 64);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, v7);
    if (!result)
    {
      _PCSError(a3, 2, @"No such service identity %lu", a2);
      return 0;
    }
  }
  return result;
}

void *PCSIdentityCreateService(uint64_t a1, char a2, void *a3, const void **a4)
{
  v27[0] = 0;
  v27[1] = 0;
  int IndexByName = PCSServiceItemGetIndexByName(a3);
  if (!IndexByName) {
    return 0;
  }
  int v9 = IndexByName;
  uint64_t NumberByIndex = PCSServiceItemGetNumberByIndex(IndexByName);
  if (!NumberByIndex) {
    return 0;
  }
  uint64_t v11 = (const void *)NumberByIndex;
  int v12 = a2 & 1;
  PCSIdentityGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[2] = PCSKeyCreateRandomFullKey(v12);
  if (PCSServiceItemTypeIsManatee(a3)) {
    a2 |= 4u;
  }
  int IsShareableManatee = PCSServiceItemTypeIsShareableManatee(a3);
  int v16 = 0;
  if (IsShareableManatee) {
    char v17 = a2 | 8;
  }
  else {
    char v17 = a2;
  }
  if ((v17 & 4) == 0) {
    goto LABEL_9;
  }
  v29[1] = 0;
  v29[2] = 3;
  uint64_t v28 = 0;
  v29[0] = 0;
  if ((v17 & 8) != 0) {
    LODWORD(v29[0]) = 1;
  }
  uint64_t v19 = length_PCSManateeFlags((uint64_t)v29);
  v29[3] = v19;
  uint64_t v20 = malloc_type_malloc(v19, 0xEEFAD3A7uLL);
  uint64_t v30 = v20;
  if (!v20)
  {
    uint64_t v23 = 12;
    goto LABEL_19;
  }
  CFDataRef v21 = v20;
  uint64_t v22 = encode_PCSManateeFlags((uint64_t)v20 + v19 - 1, v19, (uint64_t)v29, (uint64_t)&v28);
  if (v22)
  {
    uint64_t v23 = v22;
    free(v21);
    uint64_t v30 = 0;
LABEL_19:
    _PCSErrorASN1(a4, (uint64_t)"ManateeFlags", v23);
    uint64_t v24 = 0;
LABEL_20:
    free(v24);
    goto LABEL_21;
  }
  if (v28 != v19) {
    abort();
  }
  if (add_PCSAttributes((unsigned int *)v27))
  {
    _PCSErrorOOM(a4);
    uint64_t v24 = v30;
    goto LABEL_20;
  }
  free(v30);
  int v16 = v27;
  PCSIdentityAddBuildAndCreationTime((unsigned int *)v27);
  if ((v17 & 8) != 0)
  {
    RandomCompactRaw = PCSIdentityCreateRandomCompactRaw(a4);
    Instance[10] = RandomCompactRaw;
    if (!RandomCompactRaw) {
      goto LABEL_21;
    }
    int v16 = v27;
  }
LABEL_9:
  uint64_t v18 = _PCSSignKey(*(void *)(a1 + 16), *(void *)(Instance[2] + 40), v12, v9, (uint64_t)v16, v15, a4);
  *(void *)(Instance[2] + 16) = v18;
  if (!v18)
  {
LABEL_21:
    free_PCSAttributes((uint64_t)v27);
    CFRelease(Instance);
    return 0;
  }
  if ((v17 & 2) != 0)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 64), v11, Instance);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), *(const void **)(Instance[2] + 24), Instance);
  }
  free_PCSAttributes((uint64_t)v27);
  return Instance;
}

BOOL PCSIdentityAddBuildAndCreationTime(unsigned int *a1)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  CFStringRef ClientInfo = (const __CFString *)PCSSupportGetClientInfo();
  if (ClientInfo)
  {
    int v3 = PCSCFStringToCString(ClientInfo);
    int v4 = v3;
  }
  else
  {
    int v4 = 0;
    int v3 = "UNKNOWN-BUILD";
  }
  v14[0] = v3;
  v14[1] = time(0);
  LODWORD(v11) = 1;
  uint64_t v5 = length_PCSBuildAndTime((uint64_t)v14);
  uint64_t v12 = v5;
  uint64_t v6 = malloc_type_malloc(v5, 0xC1C9151AuLL);
  uint64_t v13 = v6;
  if (v6)
  {
    uint64_t v7 = v6;
    if (encode_PCSBuildAndTime((uint64_t)v6 + v5 - 1, v5, (uint64_t)v14, (uint64_t)&v10))
    {
      free(v7);
      uint64_t v6 = 0;
      BOOL v8 = 0;
      uint64_t v13 = 0;
    }
    else
    {
      if (v10 != v5) {
        abort();
      }
      BOOL v8 = add_PCSAttributes(a1) == 0;
      uint64_t v6 = v13;
    }
  }
  else
  {
    BOOL v8 = 0;
  }
  free(v6);
  if (v4) {
    free(v4);
  }
  return v8;
}

CFTypeRef PCSIdentityCreateMaster(uint64_t a1, const void **a2)
{
  v25[0] = 0;
  v25[1] = 0;
  PCSIdentityGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    _PCSErrorOOM(a2);
    CFTypeRef v22 = 0;
    goto LABEL_12;
  }
  uint64_t v5 = (uint64_t *)Instance;
  uint64_t RandomFullKey = PCSKeyCreateRandomFullKey(1);
  v5[2] = RandomFullKey;
  if (!RandomFullKey)
  {
    _PCSErrorOOM(a2);
    goto LABEL_20;
  }
  if (!PCSIdentityAddBuildAndCreationTime((unsigned int *)v25))
  {
LABEL_20:
    CFTypeRef v22 = 0;
    goto LABEL_11;
  }
  if (a1)
  {
    uint64_t v8 = v5[2];
    uint64_t v26 = 0;
    CFDataRef v9 = PCSKeyCopyExportedPublicKey(*(void *)(a1 + 16));
    if (!v9) {
      goto LABEL_20;
    }
    CFDataRef v10 = v9;
    CFDataRef v11 = PCSKeyCopyExportedPublicKey(v8);
    if (v11)
    {
      CFDataRef v12 = v11;
      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
      if (Mutable)
      {
        uint64_t v14 = Mutable;
        CFDataAppendBytes(Mutable, (const UInt8 *)"PCSForwardMasterCertification", 30);
        BytePtr = CFDataGetBytePtr(v10);
        CFIndex Length = CFDataGetLength(v10);
        CFDataAppendBytes(v14, BytePtr, Length);
        char v17 = CFDataGetBytePtr(v12);
        CFIndex v18 = CFDataGetLength(v12);
        CFDataAppendBytes(v14, v17, v18);
        CFRelease(v10);
        CFRelease(v12);
        CFDataRef Signature = (const __CFData *)PCSIdentityCreateSignature(a1, 0, v14, a2);
        if (Signature)
        {
          CFDataRef v20 = Signature;
          LODWORD(v26) = 2;
          uint64_t v28 = CFDataGetBytePtr(Signature);
          CFIndex v27 = CFDataGetLength(v20);
          int v21 = add_PCSAttributes((unsigned int *)v25);
          CFRelease(v20);
          CFRelease(v14);
          if (!v21) {
            goto LABEL_10;
          }
          goto LABEL_20;
        }
        uint64_t v24 = v14;
LABEL_19:
        CFRelease(v24);
        goto LABEL_20;
      }
      CFRelease(v10);
    }
    else
    {
      CFDataRef v12 = v10;
    }
    uint64_t v24 = v12;
    goto LABEL_19;
  }
LABEL_10:
  *(void *)(v5[2] + 16) = _PCSSignKey(v5[2], *(void *)(v5[2] + 40), 1, 1, (uint64_t)v25, v7, a2);
  CFTypeRef v22 = CFRetain(v5);
LABEL_11:
  CFRelease(v5);
LABEL_12:
  free_PCSAttributes((uint64_t)v25);
  return v22;
}

uint64_t PCSIdentityGetKeyID(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 24);
}

CFDataRef PCSIdentityCopySignatureKeyID(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 16)) != 0 && (v3 = *(void *)(v2 + 32)) != 0) {
    return CFDataCreate(0, *(const UInt8 **)(v3 + 8), *(void *)v3);
  }
  else {
    return 0;
  }
}

CFDataRef PCSIdentityMasterCopyParentKeyID(uint64_t a1, const void **a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(void *)(v2 + 16);
  if (!v3) {
    return 0;
  }
  if (*(_DWORD *)(v3 + 4) != 1) {
    return 0;
  }
  int v4 = *(unsigned int **)(v3 + 24);
  if (!v4) {
    return 0;
  }
  uint64_t v6 = *v4;
  if (!v6)
  {
LABEL_9:
    CFDataRef result = CFDataCreate(0, 0, 0);
    if (result) {
      return result;
    }
    goto LABEL_14;
  }
  uint64_t v7 = (const UInt8 **)(*((void *)v4 + 1) + 16);
  while (*((_DWORD *)v7 - 4) != 2)
  {
    v7 += 3;
    if (!--v6) {
      goto LABEL_9;
    }
  }
  CFDataRef v9 = CFDataCreateWithBytesNoCopy(0, *v7, (CFIndex)*(v7 - 1), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (!v9)
  {
LABEL_14:
    _PCSErrorOOM(a2);
    return 0;
  }
  CFDataRef v10 = v9;
  CFDataRef v11 = PCSSignatureCopyKeyID(v9, 0, a2);
  CFRelease(v10);
  return v11;
}

CFDataRef PCSSignatureCopyKeyID(const __CFData *a1, unsigned char *a2, const void **a3)
{
  uint64_t v15 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v12 = 0;
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v8 = decode_PCSSignature((uint64_t)BytePtr, Length, (uint64_t)&v13, (uint64_t)&v12);
  if (v8)
  {
    _PCSError(a3, 16, @"Failed to decode signature: %d", v8);
LABEL_9:
    CFDataRef v10 = 0;
    goto LABEL_6;
  }
  uint64_t v9 = v12;
  if (v9 != CFDataGetLength(a1))
  {
    _PCSError(a3, 16, @"Did not parse all signature");
    goto LABEL_9;
  }
  CFDataRef v10 = CFDataCreate(0, *((const UInt8 **)&v13 + 1), v13);
  if (v10)
  {
    if (a2) {
      *a2 = BYTE2(v14) & 1;
    }
  }
  else
  {
    _PCSErrorOOM(a3);
  }
LABEL_6:
  free_PCSSignature((uint64_t)&v13);
  return v10;
}

const void *PCSIdentityCreatePEMParser(uint64_t a1, uint64_t a2, const __CFData *a3)
{
  return PCSIdentityCreateFromData(a3, 0);
}

CFMutableDictionaryRef *PCSPublicIdentityCreatePEMParser(int a1, int a2, CFDataRef theData)
{
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v6 = decode_PCSUserPublicKeys((uint64_t)BytePtr, Length, (uint64_t)&v63, (uint64_t)&v62);
  if (v6)
  {
    _PCSError(0, 8, @"Failed to decode PCSUserPublicKeys: %d", v6);
LABEL_65:
    free_PCSUserPublicKeys((uint64_t)&v63);
    return 0;
  }
  if (!v63) {
    goto LABEL_65;
  }
  uint64_t v7 = (CFMutableDictionaryRef *)_PCSPublicIdentityCreateFromPKI(v64);
  if (!v7) {
    goto LABEL_65;
  }
  value = v7;
  CFMutableDictionaryRef v8 = v7[3];
  if (**((_DWORD **)v8 + 2) != 1) {
    goto LABEL_62;
  }
  uint64_t v9 = v7;
  CFDictionarySetValue(v7[5], *((const void **)v8 + 3), v7);
  if (v63 < 2)
  {
LABEL_49:
    free_PCSUserPublicKeys((uint64_t)&v63);
    return v9;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 1;
  while (1)
  {
    uint64_t v12 = v64;
    uint64_t v13 = v64 + v10;
    uint64_t v15 = (uint64_t *)(v64 + v10 + 80);
    uint64_t v14 = *v15;
    if (!*v15)
    {
      _PCSError(0, 28, @"Missing signature");
      goto LABEL_62;
    }
    uint64_t v60 = v11;
    CFDictionaryRef v16 = v9[5];
    uint64_t v17 = *(void *)(v13 + 88);
    uint64_t v18 = _PCSSignAlgToDI(*(_DWORD *)(v14 + 16), 0);
    if (!v18) {
      goto LABEL_62;
    }
    uint64_t v19 = v18;
    CFDataRef v20 = CFDataCreate(0, *(const UInt8 **)(v14 + 8), *(void *)v14);
    if (!v20)
    {
      _PCSErrorOOM(0);
      goto LABEL_62;
    }
    CFDataRef cf = v20;
    int v21 = (uint64_t *)CFDictionaryGetValue(v16, v20);
    if (!v21) {
      break;
    }
    CFTypeRef v22 = v21;
    CFTypeID v23 = CFGetTypeID(v21);
    if (v23 == PCSKeyGetTypeID())
    {
      if ((v22[4] & 4) != 0)
      {
        CFDataRef v54 = cf;
        CFDataRef v57 = cf;
        CFStringRef v55 = @"Diversified keys not support for verification: %@";
        goto LABEL_59;
      }
    }
    else
    {
      CFTypeID v24 = CFGetTypeID(v22);
      if (v24 == PCSIdentityGetTypeID())
      {
        CFDataRef v25 = (uint64_t **)(v22 + 2);
      }
      else
      {
        CFTypeID v26 = CFGetTypeID(v22);
        if (v26 != PCSPublicIdentityGetTypeID()) {
          goto LABEL_67;
        }
        CFDataRef v25 = (uint64_t **)(v22 + 3);
      }
      CFTypeRef v22 = *v25;
    }
    uint64_t v27 = v22[5];
    uint64_t v28 = (_DWORD *)v22[2];
    if (v28 && *v28 != 1)
    {
      _PCSError(0, 29, @"Non-master key default signnature not allowed", v56);
      goto LABEL_57;
    }
    CFTypeRef v22 = v15 - 4;
    *uint64_t v15 = 0;
    v15[1] = 0;
    CFDataRef v29 = (const __CFData *)PCSCreateExportedPublicKeyInfo((uint64_t)(v15 - 4));
    *uint64_t v15 = v14;
    *(void *)(v13 + 8_Block_object_dispose(&a9, 8) = v17;
    if (!v29)
    {
      CFDataRef v54 = cf;
      _PCSError(0, 5, @"Couldn't get public identity for %@", cf);
      goto LABEL_60;
    }
    CFDataRef v30 = v29;
    CFIndex v31 = CFDataGetLength(v29);
    uint64_t v32 = CFDataGetBytePtr(v30);
    if (!ccec_digest_and_verify(v27, v19, v31, (uint64_t)v32, *(void *)(v14 + 24), *(void *)(v14 + 32)))
    {
      CFRelease(cf);
      CFDataRef v53 = v30;
      goto LABEL_61;
    }
    CFRelease(v30);
    if (*(void *)(v13 + 88))
    {
      uint64_t v33 = CopyPublicKeyFromData(*(void *)(v12 + v10 + 64), *(void *)(v12 + v10 + 56), 0, 0);
      if (!v33)
      {
        CFDataRef v53 = cf;
        goto LABEL_61;
      }
      char v34 = v33;
      uint64_t v35 = *(void *)(*(void *)(v13 + 88) + 8);
      if (v35)
      {
        uint64_t v36 = _PCSSignAlgToDI(*(_DWORD *)(v35 + 16), 0);
        if (v36)
        {
          uint64_t v37 = v36;
          uint64_t v38 = *(void *)(v13 + 88);
          *(void *)(v38 + _Block_object_dispose(&a9, 8) = 0;
          uint64_t v65 = 0;
          CFIndex v39 = length_SignedAttributes(v38);
          CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, v39);
          if (Mutable)
          {
            uint64_t v41 = Mutable;
            CFDataSetLength(Mutable, v39);
            MutableBytePtr = CFDataGetMutableBytePtr(v41);
            uint64_t v43 = encode_SignedAttributes((uint64_t)&MutableBytePtr[v39 - 1], v39, *(void *)(v13 + 88), (uint64_t)&v65);
            if (v43)
            {
              uint64_t v44 = v43;
              CFRelease(v41);
              goto LABEL_32;
            }
            if (v39 != v65)
            {
              asn1_abort();
LABEL_67:
              CFTypeID v58 = CFGetTypeID(v22);
              _PCSError(0, 30, @"Unsupported signer: %@ (ID: %lu)", v22, v58);
LABEL_57:
              CFDataRef v54 = cf;
              goto LABEL_60;
            }
            *(void *)(*(void *)(v13 + 88) + _Block_object_dispose(&a9, 8) = v35;
            CFIndex v46 = CFDataGetLength(v41);
            char v47 = CFDataGetBytePtr(v41);
            if (ccec_digest_and_verify((uint64_t)v34, v37, v46, (uint64_t)v47, *(void *)(v35 + 24), *(void *)(v35 + 32)))
            {
              CFRelease(v41);
              uint64_t v41 = 0;
              int v45 = 1;
            }
            else
            {
              int v45 = 0;
            }
LABEL_37:
            free(v34);
            CFRelease(cf);
            if (v41)
            {
              CFRelease(v41);
              if ((v45 & 1) == 0) {
                goto LABEL_62;
              }
            }
            else if (!v45)
            {
              goto LABEL_62;
            }
            goto LABEL_41;
          }
          uint64_t v44 = 12;
LABEL_32:
          *(void *)(*(void *)(v13 + 88) + _Block_object_dispose(&a9, 8) = v35;
          _PCSError(0, 7, @"Self signed attributes encode failure: %d", v44);
        }
      }
      else
      {
        _PCSError(0, 28, @"self asserted signature missing", v56);
      }
      int v45 = 0;
      uint64_t v41 = 0;
      goto LABEL_37;
    }
    CFRelease(cf);
LABEL_41:
    uint64_t v48 = _PCSPublicIdentityCreateFromPKI((uint64_t)v22);
    if (!v48) {
      goto LABEL_62;
    }
    long long v49 = v48;
    uint64_t NumberByIndex = (const void *)PCSServiceItemGetNumberByIndex(*(_DWORD *)v22);
    uint64_t v9 = value;
    if (NumberByIndex)
    {
      CFStringRef v51 = NumberByIndex;
      if (!CFDictionaryContainsKey(value[4], NumberByIndex)) {
        CFDictionarySetValue(value[4], v51, v49);
      }
    }
    CFDictionarySetValue(value[5], *(const void **)(v49[3] + 24), v49);
    CFRelease(v49);
    uint64_t v11 = v60 + 1;
    v10 += 48;
    if (v60 + 1 >= (unint64_t)v63) {
      goto LABEL_49;
    }
  }
  CFDataRef v54 = cf;
  CFDataRef v57 = cf;
  CFStringRef v55 = @"Can't find signature for signer: %@";
LABEL_59:
  _PCSError(0, 28, v55, v57);
LABEL_60:
  CFDataRef v53 = v54;
LABEL_61:
  CFRelease(v53);
LABEL_62:
  free_PCSUserPublicKeys((uint64_t)&v63);
  CFRelease(value);
  return 0;
}

uint64_t __PCSIdentityCreateWithNameEmpty(uint64_t a1, CFTypeRef cf, void *a3)
{
  if (!cf) {
    return 0;
  }
  if (a3)
  {
    int IndexByName = PCSServiceItemGetIndexByName(a3);
    CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"%@-%@", cf, a3);
  }
  else
  {
    CFStringRef v7 = (const __CFString *)CFRetain(cf);
    int IndexByName = 1;
  }
  PCSIdentityGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v8 = Instance;
  if (a1) {
    uint64_t v10 = a1;
  }
  else {
    uint64_t v10 = Instance;
  }
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(0, v7, 0x8000100u, 0);
  uint64_t KeyFromRandomData = PCSKeyCreateKeyFromRandomData(ExternalRepresentation, "love");
  *(void *)(v8 + 16) = KeyFromRandomData;
  *(void *)(*(void *)(v8 + 16) + 16) = _PCSSignKey(*(void *)(v10 + 16), *(void *)(KeyFromRandomData + 40), (*(unsigned __int8 *)(KeyFromRandomData + 32) >> 1) & 1, IndexByName, 0, v13, 0);
  CFRelease(ExternalRepresentation);
  CFRelease(v7);
  return v8;
}

uint64_t __PCSIdentityCreateWithName(__CFString *a1)
{
  if (a1) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = @"<unnamed>";
  }
  uint64_t Empty = _PCSIdentityCreateEmpty(0);
  CFRetain(v1);
  *(void *)(Empty + 24) = v1;
  PCSKeyGetTypeID();
  *(void *)(Empty + 16) = _CFRuntimeCreateInstance();
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  int v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  *(void *)(Empty + 64) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  *(void *)(Empty + 72) = CFDictionaryCreateMutable(0, 0, v3, v4);
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(0, v1, 0x8000100u, 0);
  uint64_t KeyFromRandomData = PCSKeyCreateKeyFromRandomData(ExternalRepresentation, "love");
  *(void *)(Empty + 16) = KeyFromRandomData;
  if (KeyFromRandomData
    && (uint64_t v8 = _PCSSignKey(KeyFromRandomData, *(void *)(KeyFromRandomData + 40), 0, 1, 0, v7, 0),
        uint64_t v9 = *(void *)(Empty + 16),
        (*(void *)(v9 + 16) = v8) != 0))
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(Empty + 72), *(const void **)(v9 + 24), (const void *)Empty);
    CFRelease(ExternalRepresentation);
    addNameService(Empty, v1, @"Bladerunner");
    addNameService(Empty, v1, @"Hyperion");
    addNameService(Empty, v1, @"Liverpool");
    addNameService(Empty, v1, @"Escrow");
    addNameService(Empty, v1, @"FDE");
    addNameService(Empty, v1, @"PianoMover");
    addNameService(Empty, v1, @"Sharing");
  }
  else
  {
    CFRelease((CFTypeRef)Empty);
    if (ExternalRepresentation) {
      CFRelease(ExternalRepresentation);
    }
    return 0;
  }
  return Empty;
}

void addNameService(uint64_t a1, const void *a2, void *a3)
{
  int IndexByName = PCSServiceItemGetIndexByName(a3);
  if (!IndexByName) {
    addNameService_cold_1();
  }
  uint64_t NumberByIndex = PCSServiceItemGetNumberByIndex(IndexByName);
  if (!NumberByIndex) {
    addNameService_cold_2();
  }
  uint64_t v8 = (const void *)NumberByIndex;
  uint64_t v9 = (void *)__PCSIdentityCreateWithNameEmpty(a1, a2, a3);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), *(const void **)(v9[2] + 24), v9);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 64), v8, v9);
  CFRelease(v9);
}

uint64_t *__PCSPublicIdentityCreateWithName(const __CFString *a1)
{
  PCSPublicIdentityGetTypeID();
  uint64_t Instance = (uint64_t *)_CFRuntimeCreateInstance();
  PCSKeyGetTypeID();
  Instance[3] = _CFRuntimeCreateInstance();
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(0, a1, 0x8000100u, 0);
  uint64_t KeyFromRandomData = PCSKeyCreateKeyFromRandomData(ExternalRepresentation, "love");
  Instance[3] = KeyFromRandomData;
  if (!KeyFromRandomData)
  {
    if (ExternalRepresentation) {
      CFRelease(ExternalRepresentation);
    }
    CFDataRef ExternalRepresentation = (CFDataRef)Instance;
    uint64_t Instance = 0;
    goto LABEL_3;
  }
  uint64_t v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  Instance[4] = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, v5, v6);
  Instance[5] = (uint64_t)Mutable;
  CFDictionarySetValue(Mutable, *(const void **)(Instance[3] + 24), Instance);
  *(void *)(Instance[3] + 16) = _PCSSignKey(Instance[3], *(void *)(Instance[3] + 40), 0, 1, 0, v8, 0);
  addPublicNameService((uint64_t)Instance, (uint64_t)a1, @"Bladerunner");
  addPublicNameService((uint64_t)Instance, (uint64_t)a1, @"Hyperion");
  addPublicNameService((uint64_t)Instance, (uint64_t)a1, @"Liverpool");
  addPublicNameService((uint64_t)Instance, (uint64_t)a1, @"Escrow");
  addPublicNameService((uint64_t)Instance, (uint64_t)a1, @"FDE");
  addPublicNameService((uint64_t)Instance, (uint64_t)a1, @"PianoMover");
  *(unsigned char *)(Instance[3] + 32) &= ~1u;
  if (ExternalRepresentation) {
LABEL_3:
  }
    CFRelease(ExternalRepresentation);
  return Instance;
}

void addPublicNameService(uint64_t a1, uint64_t a2, void *a3)
{
  int IndexByName = PCSServiceItemGetIndexByName(a3);
  if (!IndexByName) {
    addPublicNameService_cold_1();
  }
  int v7 = IndexByName;
  uint64_t NumberByIndex = PCSServiceItemGetNumberByIndex(IndexByName);
  if (!NumberByIndex) {
    addPublicNameService_cold_2();
  }
  uint64_t v9 = (const void *)NumberByIndex;
  CFStringRef v10 = CFStringCreateWithFormat(0, 0, @"%@-%@", a2, a3);
  PCSPublicIdentityGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(0, v10, 0x8000100u, 0);
  uint64_t KeyFromRandomData = PCSKeyCreateKeyFromRandomData(ExternalRepresentation, "love");
  Instance[3] = KeyFromRandomData;
  *(unsigned char *)(KeyFromRandomData + 32) &= ~1u;
  CFRelease(ExternalRepresentation);
  CFRelease(v10);
  uint64_t v15 = _PCSSignKey(*(void *)(a1 + 24), *(void *)(Instance[3] + 40), 0, v7, 0, v14, 0);
  uint64_t v16 = Instance[3];
  *(void *)(v16 + 16) = v15;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), *(const void **)(v16 + 24), Instance);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v9, Instance);
  CFRelease(Instance);
}

uint64_t PCSGetPublicIdentitites()
{
  if (PCSGetPublicIdentitites_onceToken != -1) {
    dispatch_once(&PCSGetPublicIdentitites_onceToken, &__block_literal_global_1);
  }
  return PCSGetPublicIdentitites_dict;
}

void __PCSGetPublicIdentitites_block_invoke()
{
  uint64_t v0 = 0;
  PCSGetPublicIdentitites_dict = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v1 = (const void *)*MEMORY[0x1E4F1CFD0];
  do
    CFDictionarySetValue((CFMutableDictionaryRef)PCSGetPublicIdentitites_dict, PCSGetPublicIdentitites_publicIdentities[v0++], v1);
  while (v0 != 7);
}

CFTypeRef PCSIdentityCollectionSetup(const void *a1, const void **a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12) = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSIdentityCollectionSetup", (uint8_t *)&v12, 2u);
  }
  if (a1
    && (CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a1, (const void *)kPCSSetupRecoverMode)) != 0
    && (CFBooleanRef v5 = Value, v6 = CFGetTypeID(Value), v6 == CFBooleanGetTypeID())
    && CFBooleanGetValue(v5))
  {
    CFTypeRef v7 = PCSIdentityRecoverFDE(a1, a2);
  }
  else
  {
    CFTypeRef v7 = PCSIdentitySetup(a1, a2);
  }
  uint64_t v8 = v7;
  if (v7)
  {
    if ((PCSCurrentPersonaMatchesDSIDFromSet((uint64_t)v7) & 1) == 0)
    {
      _PCSError(a2, 152, @"Current persona does not match chosen dsid");
      CFTypeRef IdentityFromSet = 0;
LABEL_19:
      CFRelease(v8);
      return IdentityFromSet;
    }
    CFTypeRef IdentityFromSet = CreateIdentityFromSet((uint64_t)v8, a2);
  }
  else
  {
    CFTypeRef IdentityFromSet = 0;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      CFStringRef v10 = *a2;
    }
    else {
      CFStringRef v10 = 0;
    }
    int v12 = 138412546;
    CFTypeRef v13 = IdentityFromSet;
    __int16 v14 = 2112;
    uint64_t v15 = v10;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSIdentityCollectionSetup: return %@ error: %@", (uint8_t *)&v12, 0x16u);
  }
  if (v8) {
    goto LABEL_19;
  }
  return IdentityFromSet;
}

CFTypeRef CreateIdentityFromSet(uint64_t a1, const void **a2)
{
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) == 0)
  {
    _PCSError(a2, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
  int v4 = _PCSIdentitySetCopyCurrentIdentityInternal(a1, kPCSServiceMaster, a2);
  if (!v4) {
    return 0;
  }
  CFBooleanRef v5 = v4;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  v5[9] = Mutable;
  if (Mutable
    && (CFMutableDictionaryRef v7 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]), (v5[8] = v7) != 0)
    && (CFDictionaryRef v8 = (const __CFDictionary *)PCSIdentitySetCopyIdentities(a1, 0)) != 0)
  {
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __CreateIdentityFromSet_block_invoke;
    _OWORD v11[3] = &__block_descriptor_48_e15_v24__0r_v8r_v16l;
    v11[4] = a1;
    v11[5] = v5;
    CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)apply_block_2_0, v11);
    CFTypeRef v9 = CFRetain(v5);
  }
  else
  {
    CFTypeRef v9 = 0;
  }
  CFRelease(v5);
  return v9;
}

CFTypeRef PCSIdentityCollectionCopyCurrent(const __CFDictionary *a1, const void **a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v12) = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSIdentityCollectionCopyCurrent", (uint8_t *)&v12, 2u);
  }
  if (a1)
  {
    if (CFDictionaryGetValue(a1, kPCSSetupDSID[0]))
    {
      int v4 = 0;
      goto LABEL_9;
    }
    MutableCFDataRef Copy = CFDictionaryCreateMutableCopy(0, 0, a1);
  }
  else
  {
    MutableCFDataRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  int v4 = MutableCopy;
  CFDictionarySetValue(MutableCopy, kPCSSetupDSID[0], kPCSSetupDSIDAny[0]);
  a1 = v4;
LABEL_9:
  CFTypeID v6 = (uint64_t *)PCSIdentitySetCreate(a1, 0, a2);
  if (!v6) {
    goto LABEL_22;
  }
  CFMutableDictionaryRef v7 = v6;
  if (PCSCurrentPersonaMatchesDSIDFromSet((uint64_t)v6))
  {
    CFTypeRef IdentityFromSet = CreateIdentityFromSet((uint64_t)v7, a2);
    if (IdentityFromSet) {
      goto LABEL_14;
    }
    CFRelease(v7);
    Classic = PCSIdentitySetCreateClassic(a1, 0, (uint64_t *)a2);
    if (Classic)
    {
      CFMutableDictionaryRef v7 = Classic;
      CFTypeRef IdentityFromSet = CreateIdentityFromSet((uint64_t)Classic, a2);
LABEL_14:
      CFTypeRef v10 = IdentityFromSet;
      CFRelease(v7);
      if (!v4) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
LABEL_22:
    CFTypeRef v10 = 0;
    if (!v4)
    {
LABEL_16:
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 138412290;
        CFTypeRef v13 = v10;
        _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSIdentityCollectionCopyCurrent: return %@", (uint8_t *)&v12, 0xCu);
      }
      return v10;
    }
LABEL_15:
    CFRelease(v4);
    goto LABEL_16;
  }
  _PCSError(a2, 152, @"Current persona does not match chosen dsid");
  CFRelease(v7);
  if (v4) {
    CFRelease(v4);
  }
  return 0;
}

uint64_t PCSIdentityCollectionDestroy(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4)
{
  v38[1] = *MEMORY[0x1E4F143B8];
  CFMutableDictionaryRef v7 = (const void *)PCSCreateLogContext(@"Destroy", 0);
  if (!a2) {
    goto LABEL_11;
  }
  CFBooleanRef Value = (void *)CFDictionaryGetValue(a2, kPCSSetupDSID[0]);
  CFTypeRef v9 = Value;
  if (!Value) {
    goto LABEL_12;
  }
  if (!CFEqual(Value, kPCSSetupDSIDAny[0]) && (CFTypeID v10 = CFGetTypeID(v9), v10 == CFStringGetTypeID()))
  {
    CFTypeID v11 = CFGetTypeID(v9);
    if (v11 == CFStringGetTypeID()
      && (!kPCSSetupDSIDAny[0] || !CFEqual(v9, kPCSSetupDSIDAny[0]))
      && !PCSCurrentPersonaMatchesDSID(v9))
    {
      if (a4)
      {
        int v12 = (void *)MEMORY[0x1E4F28C58];
        CFTypeRef v13 = kPCSErrorDomain;
        uint64_t v37 = *MEMORY[0x1E4F28568];
        v38[0] = @"Current persona does not match chosen dsid";
        uint64_t v14 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v38 forKeys:&v37 count:1];
        *(void *)a4 = [v12 errorWithDomain:v13 code:152 userInfo:v14];

        return 0;
      }
      return a4;
    }
  }
  else
  {
LABEL_11:
    CFTypeRef v9 = 0;
  }
LABEL_12:
  uint64_t v15 = PCSCopyPIIClearedOptions(a2);
  uint64_t v16 = PCSLogGetOSLog((uint64_t)v7);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v33 = 138543618;
    uint64_t v34 = a1;
    __int16 v35 = 2114;
    uint64_t v36 = v15;
    _os_log_impl(&dword_1ACF98000, v16, OS_LOG_TYPE_DEFAULT, "PCSIdentityCollectionDestroy: %{public}@ options: %{public}@", (uint8_t *)&v33, 0x16u);
  }

  uint64_t v17 = [(__CFDictionary *)a2 objectForKeyedSubscript:kPCSSetupGuitarfish[0]];
  int v18 = [v17 BOOLValue];

  if (__PCSDeleteFromKeychain(v18, (CFErrorRef *)a4, v19, v20, v21, v22, v23, v24)
    && __PCSDeleteFromKeychainICDP(v9, (CFErrorRef *)a4, v25, v26, v27, v28, v29, v30)
    && __PCSDeleteKeyfile(v9, (const void **)a4))
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotification(DarwinNotifyCenter, (CFNotificationName)kPCSNotificationRemovedCredentials, 0, 0, 0);
    a4 = 1;
    if (!v7) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  a4 = 0;
  if (v7) {
LABEL_18:
  }
    CFRelease(v7);
LABEL_19:
  if (v15) {
    CFRelease(v15);
  }
  return a4;
}

BOOL PCSCurrentPersonaMatchesDSID(void *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (PCSSupportsPersonaMultiuser())
  {
    if (v1)
    {
      uint64_t v2 = (void *)MEMORY[0x1AD11CE50]();
      uint64_t v3 = +[PCSAccountsModel accountForCurrentPersona];
      if (!v3)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)stat buf = 0;
          _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSCurrentPersonaMatchesDSID: account is nil", buf, 2u);
        }
        BOOL v13 = 1;
        goto LABEL_33;
      }
      int v4 = +[PCSAccountsModel defaultAccountsModel];
      CFBooleanRef v5 = [v4 store];

      if (!v5)
      {
        CFBooleanRef v5 = [MEMORY[0x1E4F179C8] defaultStore];
      }
      long long v27 = 0u;
      long long v28 = 0u;
      long long v25 = 0u;
      long long v26 = 0u;
      CFTypeID v6 = objc_msgSend(v5, "aa_appleAccounts");
      id v7 = (id)[v6 countByEnumeratingWithState:&v25 objects:v31 count:16];
      if (v7)
      {
        int v24 = v2;
        uint64_t v8 = *(void *)v26;
        while (2)
        {
          for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v26 != v8) {
              objc_enumerationMutation(v6);
            }
            CFTypeID v10 = *(void **)(*((void *)&v25 + 1) + 8 * i);
            CFTypeID v11 = objc_msgSend(v10, "aa_personID");
            int v12 = [v1 isEqualToString:v11];

            if (v12)
            {
              id v7 = v10;
              goto LABEL_19;
            }
          }
          id v7 = (id)[v6 countByEnumeratingWithState:&v25 objects:v31 count:16];
          if (v7) {
            continue;
          }
          break;
        }
LABEL_19:
        uint64_t v2 = v24;
      }

      uint64_t v14 = objc_msgSend(v3, "aa_personID");
      char v15 = [v14 isEqualToString:v1];

      if (v15)
      {
        BOOL v13 = 1;
LABEL_32:

LABEL_33:
        goto LABEL_34;
      }
      uint64_t v16 = [MEMORY[0x1E4FB3700] currentPersona];
      uint64_t v17 = [v7 personaIdentifier];
      int v18 = [v16 generateAndRestorePersonaContextWithPersonaUniqueString:v17];

      BOOL v13 = v18 == 0;
      BOOL v19 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
      if (v18)
      {
        if (v19)
        {
          *(_DWORD *)stat buf = 138412290;
          int v30 = v18;
          int v20 = MEMORY[0x1E4F14500];
          int v21 = "generateAndRestorePersonaContextWithPersonaUniqueString failed with: %@";
          uint32_t v22 = 12;
LABEL_30:
          _os_log_impl(&dword_1ACF98000, v20, OS_LOG_TYPE_DEFAULT, v21, buf, v22);
        }
      }
      else if (v19)
      {
        *(_WORD *)stat buf = 0;
        int v20 = MEMORY[0x1E4F14500];
        int v21 = "generateAndRestorePersonaContextWithPersonaUniqueString succeeded!";
        uint32_t v22 = 2;
        goto LABEL_30;
      }

      goto LABEL_32;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)stat buf = 0;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSCurrentPersonaMatchesDSID: dsid is nil", buf, 2u);
    }
  }
  BOOL v13 = 1;
LABEL_34:

  return v13;
}

__CFData *PCSFDECopyUnwrappedDataWithSet(uint64_t a1, const __CFData *a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    CFDictionaryRef v6 = (const __CFDictionary *)PCSIdentitySetCopyIdentities(a1, 0);
    uint64_t v13 = 0;
    uint64_t v14 = &v13;
    uint64_t v15 = 0x2020000000;
    uint64_t v16 = 0;
    if (!v6) {
      goto LABEL_8;
    }
    CFDictionaryRef v7 = v6;
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __PCSFDECopyUnwrappedDataWithSet_block_invoke;
    context[3] = &unk_1E5E6DFD0;
    context[4] = &v13;
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)apply_block_2_0, context);
    CFRelease(v7);
    uint64_t v8 = v14;
    CFTypeRef v9 = (uint64_t *)v14[3];
    if (v9)
    {
      if (v9[2])
      {
        CFTypeID v10 = _PCSKeyCopyUnwrappedData(v9[2], a2, a3);
        uint64_t v8 = v14;
        CFTypeRef v9 = (uint64_t *)v14[3];
        if (!v9) {
          goto LABEL_11;
        }
      }
      else
      {
        CFTypeID v10 = 0;
      }
      v8[3] = 0;
      CFRelease(v9);
    }
    else
    {
LABEL_8:
      _PCSError(a3, 27, @"Failed to copy FDE identity");
      CFTypeID v10 = 0;
    }
LABEL_11:
    _Block_object_dispose(&v13, 8);
    return v10;
  }
  _PCSError(a3, 152, @"Current persona does not match chosen dsid");
  return 0;
}

void sub_1ACFA918C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__PCSFDECopyUnwrappedDataWithSet_block_invoke(void *result, int a2, void *cf)
{
  if (!*(void *)(*(void *)(result[4] + 8) + 24))
  {
    uint64_t v3 = cf[2];
    if (v3)
    {
      int v4 = *(_DWORD **)(v3 + 16);
      if (v4)
      {
        if (*v4 == 6)
        {
          CFBooleanRef v5 = result;
          CFDataRef result = CFRetain(cf);
          *(void *)(*(void *)(v5[4] + 8) + 24) = result;
        }
      }
    }
  }
  return result;
}

__CFData *PCSCopyUnwrappedDataForFDEWithIdentity(uint64_t a1, const __CFData *a2, const void **a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  if (!v6 || (CFDictionaryRef v7 = *(_DWORD **)(v6 + 16)) == 0 || *v7 != 6)
  {
    CFDictionaryRef ServiceWithID = _PCSIdentityGetServiceWithID(a1, 6u, a3);
    if (ServiceWithID)
    {
      uint64_t v6 = *((void *)ServiceWithID + 2);
      if (v6) {
        goto LABEL_6;
      }
    }
    else
    {
      _PCSError(a3, 27, @"Failed to copy FDE identity");
    }
    return 0;
  }
LABEL_6:
  return _PCSKeyCopyUnwrappedData(v6, a2, a3);
}

__CFData *PCSCopyWrappedDataWithFDEWithIdentity(const __CFDictionary *ServiceWithID, const __CFData *a2, const void **a3)
{
  uint64_t v5 = *((void *)ServiceWithID + 2);
  if (!v5 || (uint64_t v6 = *(_DWORD **)(v5 + 16)) == 0 || *v6 != 6)
  {
    CFDictionaryRef ServiceWithID = _PCSIdentityGetServiceWithID((uint64_t)ServiceWithID, 6u, a3);
    if (!ServiceWithID)
    {
      _PCSError(a3, 27, @"Failed to copy FDE identity");
      return 0;
    }
  }
  CFDictionaryRef v7 = PCSIdentityCopyPublicIdentity((uint64_t)ServiceWithID);
  if (!v7)
  {
    _PCSError(a3, 5, @"Failed to copy public FDE identity");
    return 0;
  }
  uint64_t v8 = v7;
  uint64_t v9 = v7[3];
  if (v9) {
    CFTypeID v10 = _PCSKeyCopyWrappedKey(v9, a2, a3);
  }
  else {
    CFTypeID v10 = 0;
  }
  CFRelease(v8);
  return v10;
}

uint64_t PCSIdentityCreateSignature(uint64_t a1, int a2, const __CFData *a3, const void **a4)
{
  BOOL v8 = (unsigned __int16)a2 == 0;
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t v9 = *(void *)(a1 + 16);
  if ((a2 & 0x10000) != 0)
  {
    if (!v9)
    {
      CFDataRef v11 = 0;
      goto LABEL_6;
    }
    CFDataRef v10 = _PCSKeyCopyExportedPublicKey(v9);
  }
  else
  {
    CFDataRef v10 = (const __CFData *)CFRetain(*(CFTypeRef *)(v9 + 24));
  }
  CFDataRef v11 = v10;
LABEL_6:
  uint64_t v12 = *(void *)(a1 + 16);
  if (!v12 || (*(unsigned char *)(v12 + 32) & 1) == 0)
  {
    _PCSError(a4, 16, @"no key to sign with");
    goto LABEL_14;
  }
  unsigned int v13 = v8 | a2;
  CFIndex Length = CFDataGetLength(a3);
  BytePtr = CFDataGetBytePtr(a3);
  if ((signData(v12, v11, v13, Length, (uint64_t)BytePtr, (uint64_t)v26) & 1) == 0)
  {
    _PCSError(a4, 16, @"Signing of service key failed");
    goto LABEL_14;
  }
  uint64_t v25 = 0;
  CFIndex v16 = length_PCSSignature((uint64_t)v26);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, v16);
  if (!Mutable)
  {
    uint64_t v21 = 12;
    goto LABEL_13;
  }
  int v18 = Mutable;
  CFDataSetLength(Mutable, v16);
  MutableBytePtr = CFDataGetMutableBytePtr(v18);
  uint64_t v20 = encode_PCSSignature((uint64_t)&MutableBytePtr[v16 - 1], v16, (uint64_t)v26, (uint64_t)&v25);
  if (v20)
  {
    uint64_t v21 = v20;
    CFRelease(v18);
LABEL_13:
    _PCSError(a4, 16, @"Failed encoding signature: %d", v21);
LABEL_14:
    int v18 = 0;
    goto LABEL_16;
  }
  if (v16 != v25)
  {
    int v23 = asn1_abort();
    return PCSValidateSignature(v23, v24);
  }
LABEL_16:
  if (v11) {
    CFRelease(v11);
  }
  free_PCSSignature((uint64_t)v26);
  return (uint64_t)v18;
}

uint64_t PCSValidateSignature(uint64_t *a1, CFDataRef theData, const __CFData *a3, const void **a4)
{
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  uint64_t v14 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v10 = decode_PCSSignature((uint64_t)BytePtr, Length, (uint64_t)v15, (uint64_t)&v14);
  if (v10)
  {
    _PCSError(a4, 16, @"Failed to decode signature: %d", v10);
LABEL_7:
    uint64_t v12 = 0;
    goto LABEL_4;
  }
  uint64_t v11 = v14;
  if (v11 != CFDataGetLength(theData))
  {
    _PCSError(a4, 16, @"Did not parse all signature");
    goto LABEL_7;
  }
  uint64_t v12 = _PCSValidateSignature(a1, v15, a3, a4);
LABEL_4:
  free_PCSSignature((uint64_t)v15);
  return v12;
}

uint64_t _PCSValidateSignature(uint64_t *a1, void *a2, const __CFData *a3, const void **a4)
{
  uint64_t v8 = _PCSSignAlgToDI(*((_DWORD *)a2 + 4), a4);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8;
  if (a1)
  {
    uint64_t PublicWithData = 0;
    goto LABEL_9;
  }
  if ((*((unsigned char *)a2 + 18) & 1) == 0)
  {
    _PCSError(a4, 27, @"No signer and signature doesn't use public key");
    return 0;
  }
  CFDataRef v12 = CFDataCreate(0, (const UInt8 *)a2[1], *a2);
  if (!v12)
  {
    _PCSErrorOOM(a4);
    return 0;
  }
  CFDataRef v13 = v12;
  uint64_t PublicWithData = (uint64_t *)PCSKeyCreatePublicWithData(v12, a4);
  CFRelease(v13);
  a1 = PublicWithData;
  if (!PublicWithData) {
    return 0;
  }
LABEL_9:
  CFTypeID v14 = CFGetTypeID(a1);
  if (v14 == PCSKeyGetTypeID())
  {
    if ((a1[4] & 4) == 0)
    {
      uint64_t v15 = a1[5];
      if ((*((unsigned char *)a2 + 18) & 1) == 0)
      {
        uint64_t v16 = (const void *)a1[3];
LABEL_21:
        CFDataRef v20 = (const __CFData *)CFRetain(v16);
        goto LABEL_24;
      }
      uint64_t v18 = (uint64_t)a1;
      goto LABEL_23;
    }
    goto LABEL_45;
  }
  CFTypeID v17 = CFGetTypeID(a1);
  if (v17 == PCSIdentityGetTypeID())
  {
    uint64_t v18 = a1[2];
    uint64_t v15 = *(void *)(v18 + 40);
    if (*((unsigned char *)a2 + 18))
    {
LABEL_23:
      CFDataRef v20 = _PCSKeyCopyExportedPublicKey(v18);
      goto LABEL_24;
    }
    goto LABEL_20;
  }
  CFTypeID v19 = CFGetTypeID(a1);
  if (v19 != PCSPublicIdentityGetTypeID())
  {
    CFTypeID v33 = CFGetTypeID(a1);
    _PCSError(a4, 30, @"Unsupported signer: %@ (ID: %lu)", a1, v33);
    goto LABEL_41;
  }
  uint64_t v18 = a1[3];
  if (!v18 || (*(unsigned char *)(v18 + 32) & 4) != 0)
  {
LABEL_45:
    _PCSError(a4, 30, @"Unsupported signer: %@"), a1);
LABEL_41:
    uint64_t v11 = 0;
    if (!PublicWithData) {
      return v11;
    }
    goto LABEL_38;
  }
  uint64_t v15 = *(void *)(v18 + 40);
  if ((*((unsigned char *)a2 + 18) & 1) == 0)
  {
LABEL_20:
    uint64_t v16 = *(const void **)(v18 + 24);
    goto LABEL_21;
  }
  CFDataRef v20 = PCSKeyCopyExportedPublicKey(v18);
LABEL_24:
  CFDataRef v21 = v20;
  if (CFDataGetLength(v20) != *a2)
  {
    CFIndex Length = CFDataGetLength(v21);
    _PCSError(a4, 155, @"Unsupported length of signerID %d vs %d", Length, *a2);
    goto LABEL_30;
  }
  uint32_t v22 = (const void *)a2[1];
  BytePtr = CFDataGetBytePtr(v21);
  unint64_t v24 = *a2;
  if (memcmp(v22, BytePtr, *a2))
  {
    CFStringRef v25 = _PCSCreateBase64(a2[1], v24, 0);
    long long v26 = CFDataGetBytePtr(v21);
    CFIndex v27 = CFDataGetLength(v21);
    CFStringRef v28 = _PCSCreateBase64((uint64_t)v26, v27, 0);
    _PCSError(a4, 154, @"signerID of signature %@ doesn't match signer: %@", v25, v28);
    if (v28) {
      CFRelease(v28);
    }
    if (v25) {
      CFRelease(v25);
    }
LABEL_30:
    uint64_t v11 = 0;
    if (!v21) {
      goto LABEL_37;
    }
LABEL_36:
    CFRelease(v21);
    goto LABEL_37;
  }
  int v29 = malloc_type_calloc(1uLL, *(void *)(v9 + 8) + *(void *)(v9 + 16) + 12, 0x59DABBC9uLL);
  if (!v29)
  {
    _PCSErrorOOM(a4);
    goto LABEL_30;
  }
  int v30 = v29;
  ccdigest_init();
  CFDataGetLength(a3);
  CFDataGetBytePtr(a3);
  ccdigest_update();
  if (*((_DWORD *)a2 + 4) >= 0x10000u) {
    ccdigest_update();
  }
  uint64_t v11 = ccec_verify_di(v15, v9, (uint64_t)v30, a2[3], a2[4], a4);
  free(v30);
  if (v21) {
    goto LABEL_36;
  }
LABEL_37:
  if (PublicWithData) {
LABEL_38:
  }
    CFRelease(PublicWithData);
  return v11;
}

uint64_t *PCSValidateSignatureGetSigner(const __CFDictionary *a1, CFDataRef theData, const __CFData *a3, const void **a4)
{
  uint64_t v20 = 0;
  memset(v19, 0, sizeof(v19));
  uint64_t v18 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v10 = decode_PCSSignature((uint64_t)BytePtr, Length, (uint64_t)v19, (uint64_t)&v18);
  if (v10)
  {
    _PCSError(a4, 16, @"Failed to decode signature: %d", v10);
LABEL_14:
    free_PCSSignature((uint64_t)v19);
    return 0;
  }
  uint64_t v11 = v18;
  if (v11 != CFDataGetLength(theData))
  {
    _PCSError(a4, 16, @"Did not parse all signature");
    goto LABEL_14;
  }
  CFDataRef v12 = CFDataCreate(0, *((const UInt8 **)&v19[0] + 1), *(CFIndex *)&v19[0]);
  if (!v12)
  {
    _PCSErrorOOM(a4);
    goto LABEL_14;
  }
  CFDataRef v13 = v12;
  CFBooleanRef Value = (uint64_t *)CFDictionaryGetValue(a1, v12);
  if (Value)
  {
    uint64_t v15 = Value;
    if (_PCSValidateSignature(Value, v19, a3, a4)) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = 0;
    }
  }
  else
  {
    _PCSError(a4, 28, @"Can't find signature for signer: %@", v13);
    uint64_t v16 = 0;
  }
  free_PCSSignature((uint64_t)v19);
  CFRelease(v13);
  return v16;
}

CFTypeRef PCSValidateSignatureWithSet(uint64_t a1, CFDataRef theData, const __CFData *a3, const void **a4)
{
  uint64_t v22 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v19 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v10 = decode_PCSSignature((uint64_t)BytePtr, Length, (uint64_t)&v20, (uint64_t)&v19);
  if (v10)
  {
    _PCSError(a4, 16, @"Failed to decode signature: %d", v10);
    goto LABEL_16;
  }
  uint64_t v11 = v19;
  if (v11 != CFDataGetLength(theData))
  {
    _PCSError(a4, 16, @"Did not parse all signature");
    goto LABEL_16;
  }
  if ((BYTE2(v21) & 1) == 0)
  {
    CFDataRef v12 = CFDataCreate(0, *((const UInt8 **)&v20 + 1), v20);
    if (v12)
    {
      CFDataRef v13 = v12;
      uint64_t v14 = PCSIdentitySetCopyIdentityByKeyID(a1, (uint64_t)v12);
      goto LABEL_8;
    }
LABEL_13:
    _PCSErrorOOM(a4);
LABEL_16:
    free_PCSSignature((uint64_t)&v20);
    return 0;
  }
  CFStringRef v15 = _PCSCreateBase64(*((uint64_t *)&v20 + 1), v20, 0);
  if (!v15) {
    goto LABEL_13;
  }
  CFDataRef v13 = v15;
  uint64_t v14 = PCSIdentitySetCopyIdentity(a1, (uint64_t)v15);
LABEL_8:
  uint64_t v16 = (void *)v14;
  CFRelease(v13);
  if (!v16) {
    goto LABEL_13;
  }
  if (PCSValidateSignature((uint64_t *)v16, theData, a3, a4)) {
    CFTypeRef v17 = CFRetain(v16);
  }
  else {
    CFTypeRef v17 = 0;
  }
  free_PCSSignature((uint64_t)&v20);
  CFRelease(v16);
  return v17;
}

CFDictionaryRef PCSIdentitySetCopyPublishableIdentities(uint64_t a1, CFDictionaryRef Copy, const void **a3)
{
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) == 0)
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
  if (!Copy) {
    return Copy;
  }
  uint64_t v6 = (const void *)PCSIdentitySetCopyOrderedIdentities(a1, (uint64_t)Copy);
  if (!v6) {
    return 0;
  }
  CFDictionaryRef v7 = v6;
  CFTypeID v8 = CFGetTypeID(v6);
  if (v8 != CFArrayGetTypeID()
    || !CFArrayGetCount((CFArrayRef)v7)
    || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])) == 0)
  {
    CFRelease(v7);
    return 0;
  }
  uint64_t v10 = Mutable;
  CFMutableArrayRef v11 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFMutableArrayRef v12 = v11;
  if (v11)
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    void v14[2] = __PCSIdentitySetCopyPublishableIdentities_block_invoke;
    v14[3] = &__block_descriptor_48_e10_v16__0r_v8l;
    v14[4] = Copy;
    v14[5] = v11;
    v15.length = CFArrayGetCount((CFArrayRef)v7);
    v15.CFIndex location = 0;
    CFArrayApplyFunction((CFArrayRef)v7, v15, (CFArrayApplierFunction)apply_block_1, v14);
    CFDictionarySetValue(v10, kPCSSecureBackupCFKeyRegistryPublicIdentities[0], v12);
    CFDataRef Copy = CFDictionaryCreateCopy(0, v10);
  }
  else
  {
    CFDataRef Copy = 0;
  }
  CFRelease(v7);
  CFRelease(v10);
  if (v12) {
    CFRelease(v12);
  }
  return Copy;
}

void __PCSIdentitySetCopyPublishableIdentities_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  char v16 = 0;
  if (!_PCSIdentityValidate(a2, &v16, 0) && v16)
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)stat buf = 138412290;
    uint64_t v18 = a2;
    int v4 = MEMORY[0x1E4F14500];
    uint64_t v5 = "PCSIdentitySetCopyPublishableIdentities found unpublishable identity: %@";
    uint32_t v6 = 12;
LABEL_17:
    _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, v5, buf, v6);
    return;
  }
  uint64_t v7 = *(void *)(a2 + 16);
  if (v7 && (CFTypeID v8 = *(int **)(v7 + 16)) != 0) {
    int v9 = *v8;
  }
  else {
    int v9 = 0;
  }
  uint64_t NameByIndex = (const void *)PCSServiceItemGetNameByIndex(v9);
  if (!NameByIndex || !CFEqual(*(CFTypeRef *)(a1 + 32), NameByIndex))
  {
    if (!os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v15 = *(void *)(a1 + 32);
    *(_DWORD *)stat buf = 138412546;
    uint64_t v18 = v15;
    __int16 v19 = 2112;
    long long v20 = NameByIndex;
    int v4 = MEMORY[0x1E4F14500];
    uint64_t v5 = "PCSIdentitySetCopyPublishableIdentities found invalid match: expected %@ found %@";
    uint32_t v6 = 22;
    goto LABEL_17;
  }
  uint64_t v11 = *(void *)(a2 + 16);
  if (v11)
  {
    uint64_t v12 = *(void *)(v11 + 16);
    if (v12)
    {
      CFDataRef v13 = (const void *)PCSCreateExportedPublicKeyInfo(v12);
      if (v13)
      {
        uint64_t v14 = v13;
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v13);
        CFRelease(v14);
      }
    }
  }
}

__CFData *_CopyECPGPWrappedData(uint64_t a1, CFDataRef theData, const void **a3)
{
  if (!theData)
  {
    _PCSError(a3, 12, @"input data to key wrapping missing");
    return 0;
  }
  char v5 = *(unsigned char *)(a1 + 32);
  CFDataGetLength(theData);
  CFIndex v6 = ccec_rfc6637_wrap_key_size();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v6);
  if ((v5 & 4) == 0)
  {
    if (Mutable)
    {
      CFDataGetMutableBytePtr(Mutable);
      CFDataGetLength(theData);
      CFDataGetBytePtr(theData);
      uint64_t v10 = (const char *)ccDRBGGetRngState();
      uint64_t v8 = ccec_rfc6637_wrap_key();
      goto LABEL_7;
    }
LABEL_10:
    _PCSErrorOOM(a3);
    return Mutable;
  }
  if (!Mutable) {
    goto LABEL_10;
  }
  CFDataGetMutableBytePtr(Mutable);
  CFDataGetLength(theData);
  CFDataGetBytePtr(theData);
  ccDRBGGetRngState();
  uint64_t v10 = "fingerprint";
  uint64_t v8 = ccec_rfc6637_wrap_key_diversified();
LABEL_7:
  if (v8)
  {
    _PCSError(a3, 12, @"wrap failed with %d", v8, v10);
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

__CFData *_CopyECPGPUnwrappedData(uint64_t a1, CFDataRef theData, const void **a3)
{
  CFIndex v6 = CFDataGetLength(theData);
  CFIndex length = v6;
  if ((*(unsigned char *)(a1 + 32) & 1) == 0) {
    return 0;
  }
  CFIndex v7 = v6;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v7);
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetLength(theData);
    BytePtr = CFDataGetBytePtr(theData);
    uint64_t v9 = ccec_rfc6637_unwrap_key();
    if (v9) {
      _PCSError(a3, 13, @"unwrap failed with %d", v9, BytePtr, length);
    }
    CFRelease(Mutable);
    return 0;
  }
  _PCSErrorOOM(a3);
  return Mutable;
}

void *CopyPrivKeyFromOctetString(uint64_t a1, int a2, BOOL *a3)
{
  *a3 = 0;
  if (a2 || !ccec_compact_import_priv_size())
  {
    if (ccec_der_import_priv_keytype())
    {
      *a3 = a2 == 1;
      ccec_cp_192();
      MEMORY[0x1AD11C7B0]();
      MEMORY[0x1AD11C7C0]();
      MEMORY[0x1AD11C7D0]();
      ccec_cp_521();
      char v5 = (void *)ccec_curve_for_length_lookup();
      if (!v5) {
        return 0;
      }
      CFIndex v6 = v5;
      CFIndex v7 = malloc_type_malloc((32 * *v5) | 0x10, 0x889939E2uLL);
      uint64_t v8 = v7;
      if (!v7) {
        return v8;
      }
      *CFIndex v7 = v6;
      if (!ccn_read_uint())
      {
        int v9 = *a3;
        uint64_t v10 = (uint64_t)v6;
LABEL_19:
        if (generate_publickey(v10, v9)) {
          return v8;
        }
      }
    }
    else
    {
      ccec_cp_192();
      MEMORY[0x1AD11C7B0]();
      MEMORY[0x1AD11C7C0]();
      MEMORY[0x1AD11C7D0]();
      ccec_cp_521();
      uint64_t v12 = (void *)ccec_curve_for_length_lookup();
      if (!v12) {
        return 0;
      }
      CFDataRef v13 = v12;
      uint64_t v14 = malloc_type_malloc((32 * *v12) | 0x10, 0xD4C1EC1FuLL);
      uint64_t v8 = v14;
      if (!v14) {
        return v8;
      }
      void *v14 = v13;
      if (!ccec_der_import_priv())
      {
        if (a2 == 1)
        {
          *a3 = 1;
          ccec_compact_transform_key();
        }
        ccDRBGGetRngState();
        if (ccec_pairwise_consistency_check()) {
          return v8;
        }
        int v9 = *a3;
        uint64_t v10 = (uint64_t)v13;
        goto LABEL_19;
      }
    }
LABEL_21:
    free(v8);
    return 0;
  }
  if (!ccec_keysize_is_supported()) {
    return 0;
  }
  cp = (void *)ccec_get_cp();
  uint64_t v8 = malloc_type_malloc((32 * *cp) | 0x10, 0x32A0705AuLL);
  if (v8)
  {
    if (!ccec_compact_import_priv())
    {
      *a3 = 1;
      return v8;
    }
    goto LABEL_21;
  }
  return v8;
}

BOOL generate_publickey(uint64_t a1, int a2)
{
  unint64_t v3 = (unint64_t)(cczp_bitlen() + 7) >> 3;
  uint64_t v4 = MEMORY[0x1AD11C6F0](v3, 0, 0);
  uint64_t v5 = MEMORY[0x1F4188790](v4);
  MEMORY[0x1F4188790](v5);
  ccn_write_uint_padded();
  if (ccder_encode_eckey())
  {
    int v6 = ccec_der_import_priv();
    BOOL v7 = v6 == 0;
    if (v6) {
      BOOL v8 = 1;
    }
    else {
      BOOL v8 = a2 == 0;
    }
    if (!v8)
    {
      ccec_compact_transform_key();
      BOOL v7 = 1;
    }
  }
  else
  {
    BOOL v7 = 0;
  }
  cc_clear();
  cc_clear();
  return v7;
}

uint64_t apply_block_2_0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void InvalidPublicKey(void *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a1;
  CFStringRef v11 = CFStringCreateWithFormatAndArguments(0, 0, a2, &a9);
  CFStringRef v12 = v11;
  if (v10 && v11) {
    v10[2](v10, v11);
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)stat buf = 138412290;
    CFStringRef v14 = v12;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSKeyCheckForInvalidPublicKey: %@", buf, 0xCu);
  }
  if (v12) {
    CFRelease(v12);
  }
}

void *_PCSPublicIdentityCreateFromPKI(uint64_t a1)
{
  PCSPublicIdentityGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    uint64_t v3 = PCSKeyCreateWithPKI(a1, 0);
    Instance[3] = v3;
    if (v3)
    {
      if (*(_DWORD *)(*(void *)(v3 + 16) + 4) == 1)
      {
        uint64_t v4 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
        uint64_t v5 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
        Instance[5] = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        Instance[4] = CFDictionaryCreateMutable(0, 0, v4, v5);
      }
    }
    else
    {
      CFRelease(Instance);
      return 0;
    }
  }
  return Instance;
}

uint64_t ccec_digest_and_verify(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1);
  CFStringRef v11 = (char *)v13 - v10;
  ccdigest_init();
  ccdigest_update();
  return ccec_verify_di(a1, a2, (uint64_t)v11, a5, a6, 0);
}

uint64_t ccec_verify_di(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void **a6)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  HIBYTE(v16) = 0;
  MEMORY[0x1F4188790](a1);
  (*(void (**)(uint64_t, uint64_t, char *))(v8 + 56))(v8, v9, (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v10 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B4A28;
  uint64_t v11 = ccec_verify();
  qword_1EB3B4A30 += PCSMeasureRelativeNanoTime() - v10;
  if (v11) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = HIBYTE(v16) == 0;
  }
  uint64_t v13 = !v12;
  if (v12)
  {
    if (HIBYTE(v16)) {
      uint64_t v15 = "";
    }
    else {
      uint64_t v15 = "!";
    }
    _PCSError(a6, 31, @"Verification failed, ret=%d, %svalid", v11, v15);
  }
  return v13;
}

void __CreateIdentityFromSet_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (_PCSIdentitySetIsCurrentIdentity(*(void *)(a1 + 32), (uint64_t)a3))
  {
    CFNumberRef v5 = CFNumberCreate(0, kCFNumberSInt32Type, *(const void **)(a3[2] + 16));
    if (v5)
    {
      CFNumberRef v6 = v5;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 40) + 64), v5, a3);
      CFRelease(v6);
    }
  }
  if (!CFEqual(*(CFTypeRef *)(a1 + 40), a3))
  {
    uint64_t v7 = *(__CFDictionary **)(*(void *)(a1 + 40) + 72);
    uint64_t v8 = *(const void **)(a3[2] + 24);
    CFDictionarySetValue(v7, v8, a3);
  }
}

uint64_t apply_block_1(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1ACFABEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id *location,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  objc_destroyWeak(location);
  _Block_object_dispose((const void *)(v41 - 248), 8);
  objc_destroyWeak((id *)(v41 - 216));
  _Unwind_Resume(a1);
}

void sub_1ACFAC484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFDictionary *CFDictionaryCreateMutableForCFTypesWith(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v14 = (const void **)&a10;
  uint64_t v11 = key;
  if (key)
  {
    do
    {
      CFDictionarySetValue(Mutable, v11, *v14);
      BOOL v12 = v14 + 1;
      v14 += 2;
      uint64_t v11 = *v12;
    }
    while (*v12);
  }
  return Mutable;
}

__CFData *PCSCloudKitShareTokenCopyEncryptedData(const __CFData *a1, const __CFData *a2)
{
  uint64_t v4 = ccaes_gcm_encrypt_mode();
  MEMORY[0x1F4188790](v4);
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccgcm_init();
  CFIndex v5 = CFDataGetLength(a2) + 32;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, v5);
  uint64_t v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v5);
    MutableBytePtr = CFDataGetMutableBytePtr(v7);
    if (!MutableBytePtr || SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E4F3BC60], 0x10uLL, MutableBytePtr))
    {
      CFRelease(v7);
      uint64_t v7 = 0;
    }
    else
    {
      ccgcm_set_iv();
      CFDataGetLength(a2);
      CFDataGetBytePtr(a2);
      ccgcm_update();
      CFDataGetLength(a2);
      ccgcm_finalize();
    }
  }
  ccgcm_context_size();
  cc_clear();
  return v7;
}

__CFData *PCSCloudKitShareTokenCopyDecryptedData(const __CFData *a1, const __CFData *a2)
{
  uint64_t v4 = ccaes_gcm_decrypt_mode();
  MEMORY[0x1F4188790](v4);
  CFIndex Length = CFDataGetLength(a2);
  CFIndex v6 = Length - 32;
  if (Length < 32) {
    return 0;
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccgcm_init();
  CFDataGetBytePtr(a2);
  ccgcm_set_iv();
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, v6);
  uint64_t v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v6);
    CFDataGetMutableBytePtr(v7);
    ccgcm_update();
    ccgcm_finalize();
    if (cc_cmp_safe())
    {
      CFRelease(v7);
      uint64_t v7 = 0;
    }
  }
  ccgcm_context_size();
  cc_clear();
  return v7;
}

BOOL PCSDaemonKeyRollIsPending(uint64_t a1, void *a2)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1AD11CE50]();
  if (PCSServiceItemCanRoll(a2))
  {
    if (commonUserDefaults_once != -1) {
      dispatch_once(&commonUserDefaults_once, &__block_literal_global_2);
    }
    CFIndex v5 = (void *)commonUserDefaults_defaults;
    if (commonUserDefaults_defaults)
    {
      id v6 = 0;
    }
    else
    {
      uint64_t v8 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v9 = kPCSErrorDomain;
      v22[0] = *MEMORY[0x1E4F28568];
      uint64_t v10 = [NSString stringWithFormat:@"Could not get ProtectedCloudKeyStorage defaults"];
      *(void *)uint64_t v21 = v10;
      uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v21 forKeys:v22 count:1];
      id v6 = [v8 errorWithDomain:v9 code:134 userInfo:v11];

      CFIndex v5 = (void *)commonUserDefaults_defaults;
    }
    id v12 = v5;
    id v13 = v6;
    if (v12)
    {
      CFStringRef v14 = [v12 objectForKey:kPCSPendingRollEpoch];
      if (v14
        && ([MEMORY[0x1E4F1C9C8] date],
            uint64_t v15 = objc_claimAutoreleasedReturnValue(),
            uint64_t v16 = [v15 compare:v14],
            v15,
            v16 != -1)
        && ([v14 timeIntervalSinceNow], fabs(v17) <= 2419200.0)
        && (CurrentCreationTime = PCSIdentitySetGetCurrentCreationTime(a1, (uint64_t)a2, 0)) != 0)
      {
        __int16 v19 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSince1970:(double)(uint64_t)CurrentCreationTime];
        BOOL v7 = [v14 compare:v19] != -1;
      }
      else
      {
        BOOL v7 = 0;
      }
    }
    else
    {
      BOOL v7 = 0;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v21 = 138412290;
        *(void *)&int v21[4] = v13;
        _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSDaemonKeyRollIsPending error: %@", v21, 0xCu);
        BOOL v7 = 0;
      }
    }
  }
  else
  {
    BOOL v7 = 0;
  }
  return v7;
}

uint64_t __commonUserDefaults_block_invoke()
{
  id v0 = objc_alloc(MEMORY[0x1E4F1CB18]);
  commonUserDefaults_defaults = [v0 initWithSuiteName:kPCSSettingsSuiteName];
  return MEMORY[0x1F41817F8]();
}

BOOL PCSSupportsPersonaMultiuser()
{
  if (gPCSSupportsPersonaMultiuserStatus) {
    return gPCSSupportsPersonaMultiuserStatus == 1;
  }
  if (PCSSupportsPersonaMultiuser_onceToken != -1) {
    dispatch_once(&PCSSupportsPersonaMultiuser_onceToken, &__block_literal_global_3);
  }
  return PCSSupportsPersonaMultiuser_ffPCSSupportsPersonaMultiuserStatus != 0;
}

void __PCSSupportsPersonaMultiuser_block_invoke()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  PCSSupportsPersonaMultiuser_ffPCSSupportsPersonaMultiuserStatus = _os_feature_enabled_impl();
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    if (PCSSupportsPersonaMultiuser_ffPCSSupportsPersonaMultiuserStatus) {
      id v0 = "enabled";
    }
    else {
      id v0 = "disabled";
    }
    int v1 = 136315138;
    uint64_t v2 = v0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSSupportsMultiuser is %s", (uint8_t *)&v1, 0xCu);
  }
}

void PCSSetSupportsPersonaMultiuser(int a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a1) {
    int v2 = 1;
  }
  else {
    int v2 = 2;
  }
  gPCSSupportsPersonaMultiuserStatus = v2;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = "disabled";
    if (a1) {
      uint64_t v3 = "enabled";
    }
    int v4 = 136315138;
    CFIndex v5 = v3;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSSupportsMultiuser overriden to %s", (uint8_t *)&v4, 0xCu);
  }
}

void PCSClearSupportsPersonaMultiuserOverride()
{
  gPCSSupportsPersonaMultiuserStatus = 0;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v0 = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSSupportsMultiuser override removed", v0, 2u);
  }
}

BOOL __PCSStoreIniCloudKeychain(int a1, int a2, uint64_t a3, const void **a4)
{
  CFIndex v5 = (const void *)*MEMORY[0x1E4F1CFD0];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, (int)kPCSDefaultKeychainGroup[0], *MEMORY[0x1E4F3B848], *MEMORY[0x1E4F3BD38], *MEMORY[0x1E4F3B698], *MEMORY[0x1E4F3B870], (int)@"PCS-MasterKey", (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  CFDictionaryRef v7 = MutableForCFTypesWith;
  if (MutableForCFTypesWith)
  {
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B878], v5);
    }
    uint64_t v8 = PCSMeasureRelativeNanoTime();
    ++PCSMeasure;
    SecItemAdd(v7, 0);
    qword_1EB3B49C0 += PCSMeasureRelativeNanoTime() - v8;
    CFRelease(v7);
  }
  else
  {
    _PCSErrorOOM(a4);
  }
  return v7 != 0;
}

BOOL __PCSUpdateIniCloudKeychain(uint64_t a1, int a2, uint64_t a3, const void **a4, uint64_t a5, uint64_t a6, int a7, int a8)
{
  uint64_t v10 = (const void *)*MEMORY[0x1E4F1CFD0];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)kPCSDefaultKeychainGroup[0], a2, *MEMORY[0x1E4F3B848], *MEMORY[0x1E4F3B698], *MEMORY[0x1E4F3B870], (int)@"PCS-MasterKey", a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  CFDictionaryRef v19 = MutableForCFTypesWith;
  if (MutableForCFTypesWith)
  {
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B878], v10);
    }
    long long v20 = CFDictionaryCreateMutableForCFTypesWith((int)MutableForCFTypesWith, v12, v13, v14, v15, v16, v17, v18, (void *)*MEMORY[0x1E4F3BD38], a1);
    uint64_t v21 = PCSMeasureRelativeNanoTime();
    ++qword_1EB3B49C8;
    SecItemUpdate(v19, v20);
    qword_1EB3B49D0 += PCSMeasureRelativeNanoTime() - v21;
    CFRelease(v19);
    if (v20) {
      CFRelease(v20);
    }
  }
  else
  {
    _PCSErrorOOM(a4);
  }
  return v19 != 0;
}

CFTypeRef __PCSCopyFromiCloudKeychain(const void *a1, int a2, const void **a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v10 = &kPCSiCloudServiceGuitarfishName;
  CFTypeRef result = 0;
  if (!a2) {
    uint64_t v10 = &kPCSiCloudServiceName;
  }
  uint64_t v11 = (const void *)*MEMORY[0x1E4F1CFD0];
  uint64_t v27 = *MEMORY[0x1E4F3BB90];
  uint64_t v25 = *MEMORY[0x1E4F1CFD0];
  uint64_t v26 = *MEMORY[0x1E4F3BB80];
  int v23 = kPCSAccount[0];
  uint64_t v24 = *MEMORY[0x1E4F3BC70];
  uint64_t v21 = *v10;
  uint64_t v22 = *MEMORY[0x1E4F3B5C0];
  uint64_t v20 = *MEMORY[0x1E4F3B838];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)a1, a2, (int)a3, a4, a5, a6, a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  if (!MutableForCFTypesWith)
  {
    _PCSErrorOOM(a3);
    return 0;
  }
  int v13 = MutableForCFTypesWith;
  if (a1) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B848], a1);
  }
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F3B878], v11);
  }
  uint64_t v14 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  OSStatus v15 = SecItemCopyMatching(v13, &result);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v14;
  if (v15)
  {
    PCSSecError(v15, (CFErrorRef *)a3, @"SecItem failed to %@ %@", @"fetch", kPCSiCloudServiceName, v20, v21, v22, v23, v24, v25, v26, v27, 0);
  }
  else if (result)
  {
    CFTypeID v16 = CFGetTypeID(result);
    if (v16 == CFDataGetTypeID())
    {
      CFTypeRef v17 = CFRetain(result);
      goto LABEL_12;
    }
  }
  CFTypeRef v17 = 0;
LABEL_12:
  CFRelease(v13);
  CFTypeRef v18 = result;
  if (result)
  {
    CFTypeRef result = 0;
    CFRelease(v18);
  }
  return v17;
}

uint64_t __PCSStoreInKeychain(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 1) == 0)
  {
    uint64_t v10 = kPCSServiceName[0];
    uint64_t v11 = (const void *)*MEMORY[0x1E4F3B978];
    uint64_t v12 = *MEMORY[0x1E4F3B988];
    uint64_t v13 = *MEMORY[0x1E4F3B5C0];
    uint64_t v14 = (const void *)*MEMORY[0x1E4F3B558];
    OSStatus v15 = (const void *)*MEMORY[0x1E4F3B550];
    uint64_t v48 = *MEMORY[0x1E4F3BD38];
    int v45 = kPCSDefaultKeychainGroup[0];
    uint64_t v46 = *MEMORY[0x1E4F3B688];
    uint64_t v43 = *MEMORY[0x1E4F1CFD0];
    uint64_t v44 = *MEMORY[0x1E4F3B550];
    uint64_t v41 = *MEMORY[0x1E4F3B578];
    uint64_t v42 = *MEMORY[0x1E4F3BD08];
    uint64_t v38 = kPCSAccount[0];
    uint64_t v40 = *MEMORY[0x1E4F3B558];
    uint64_t v36 = kPCSServiceName[0];
    uint64_t v37 = *MEMORY[0x1E4F3B5C0];
    uint64_t v35 = *MEMORY[0x1E4F3B850];
    CFDictionaryRef v16 = CFDictionaryCreateForCFTypes(a1, a2, a3, (uint64_t)a4, a5, a6, a7, a8, *MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B988]);
    if (!v16)
    {
      _PCSErrorOOM(a4);
      return 0;
    }
    CFDictionaryRef v17 = v16;
    long long v50 = (CFErrorRef *)a4;
    uint64_t v18 = PCSMeasureRelativeNanoTime();
    ++PCSMeasure;
    OSStatus v19 = SecItemAdd(v17, 0);
    qword_1EB3B49C0 += PCSMeasureRelativeNanoTime() - v18;
    if (v19 == -25299)
    {
      MutableCFDataRef Copy = CFDictionaryCreateMutableCopy(0, 0, v17);
      if (MutableCopy)
      {
        uint64_t v21 = MutableCopy;
        CFDictionaryRemoveValue(MutableCopy, v11);
        CFDictionaryRemoveValue(v21, v14);
        CFDictionaryRemoveValue(v21, v15);
        CFIndex v39 = kPCSAccount[0];
        CFDictionaryRef v30 = CFDictionaryCreateForCFTypes(v22, v23, v24, v25, v26, v27, v28, v29, (uint64_t)v11, v12);
        if (v30)
        {
          CFDictionaryRef v31 = v30;
          uint64_t v32 = PCSMeasureRelativeNanoTime();
          ++qword_1EB3B49C8;
          OSStatus v33 = SecItemUpdate(v31, v21);
          qword_1EB3B49D0 += PCSMeasureRelativeNanoTime() - v32;
          CFRelease(v21);
          CFRelease(v31);
          if (v33)
          {
            PCSSecError(v33, v50, @"Failed to update: %@: item: %@ query: %@", v10, v17, 0, v10, v13, v39, 0);
LABEL_16:
            uint64_t v8 = 0;
            goto LABEL_11;
          }
LABEL_10:
          _PCSPostHaveCredentials();
          uint64_t v8 = 1;
LABEL_11:
          CFRelease(v17);
          return v8;
        }
        CFRelease(v21);
      }
      _PCSErrorOOM((const void **)v50);
      goto LABEL_16;
    }
    PCSSecError(v19, v50, @"SecItem failed to %@ %@", @"add", v10, v35, v36, v37, v38, v40, v41, v42, v43, v44, v45, v46, a3, v48, a2,
      0,
      v12);
    goto LABEL_10;
  }
  return 1;
}

CFDictionaryRef CFDictionaryCreateForCFTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v23 = &a10;
  unint64_t v10 = 0;
  if (a9)
  {
    do
    {
      v10 += 2;
      uint64_t v11 = v23;
      v23 += 2;
    }
    while (v11[1]);
  }
  uint64_t v24 = &a9;
  uint64_t v12 = (const void **)malloc_type_calloc(v10 >> 1, 8uLL, 0xC0040B8AA526DuLL);
  uint64_t v13 = (const void **)malloc_type_calloc(v10 >> 1, 8uLL, 0xC0040B8AA526DuLL);
  uint64_t v14 = v13;
  if (v10)
  {
    OSStatus v15 = (const void *)*MEMORY[0x1E4F1D260];
    CFDictionaryRef v16 = v12;
    CFDictionaryRef v17 = v13;
    unint64_t v18 = v10 >> 1;
    do
    {
      OSStatus v19 = v24;
      *v16++ = (const void *)*v24;
      v24 += 2;
      uint64_t v20 = (const void *)v19[1];
      if (!v20) {
        uint64_t v20 = v15;
      }
      *v17++ = v20;
      --v18;
    }
    while (v18);
  }
  CFDictionaryRef v21 = CFDictionaryCreate(0, v12, v13, v10 >> 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  free(v12);
  free(v14);
  return v21;
}

CFTypeRef __PCSCopyFromKeychain(char a1, const __CFString *a2, const __CFString *a3, const void **a4, int a5, int a6, int a7, int a8)
{
  CFTypeRef v8 = 0;
  CFTypeRef result = 0;
  if (a1) {
    return v8;
  }
  uint64_t v12 = kPCSServiceName[0];
  uint64_t v59 = *MEMORY[0x1E4F3BB90];
  uint64_t v57 = *MEMORY[0x1E4F1CFD0];
  uint64_t v58 = *MEMORY[0x1E4F3BB80];
  uint64_t v55 = *MEMORY[0x1E4F1CFD0];
  uint64_t v56 = *MEMORY[0x1E4F3BC78];
  uint64_t v53 = *MEMORY[0x1E4F1CFD0];
  uint64_t v54 = *MEMORY[0x1E4F3BC68];
  CFStringRef v51 = kPCSAccount[0];
  uint64_t v52 = *MEMORY[0x1E4F3BC70];
  long long v49 = kPCSServiceName[0];
  uint64_t v50 = *MEMORY[0x1E4F3B5C0];
  uint64_t v48 = *MEMORY[0x1E4F3B850];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(*MEMORY[0x1E4F3BB90], (int)a2, (int)a3, (int)a4, a5, a6, a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B988]);
  if (!MutableForCFTypesWith)
  {
    _PCSErrorOOM(a4);
    goto LABEL_27;
  }
  uint64_t v14 = MutableForCFTypesWith;
  uint64_t v15 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  OSStatus v16 = SecItemCopyMatching(v14, &result);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v15;
  if (!v16)
  {
    CFRelease(v14);
    if (!result) {
      return 0;
    }
    CFTypeID v17 = CFGetTypeID(result);
    if (v17 != CFDictionaryGetTypeID()) {
      goto LABEL_27;
    }
    CFBooleanRef Value = CFDictionaryGetValue((CFDictionaryRef)result, (const void *)*MEMORY[0x1E4F3BD38]);
    CFTypeRef v8 = Value;
    if (!Value) {
      goto LABEL_32;
    }
    CFTypeID v19 = CFGetTypeID(Value);
    if (v19 != CFDataGetTypeID()) {
      goto LABEL_27;
    }
    uint64_t v20 = *MEMORY[0x1E4F3B688];
    CFDataRef v21 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)result, (const void *)*MEMORY[0x1E4F3B688]);
    if (v21)
    {
      CFDataRef v22 = v21;
      CFTypeID v23 = CFGetTypeID(v21);
      if (v23 == CFDataGetTypeID())
      {
        CFStringRef v24 = CFStringCreateFromExternalRepresentation(0, v22, 0x8000100u);
        if (!v24) {
          goto LABEL_27;
        }
LABEL_14:
        if (CFStringFind(v24, @"@", 0).location == -1)
        {
          if (a3 && CFStringCompare(a3, v24, 0))
          {
            PCSSecError(0, (CFErrorRef *)a4, @"The item we where looking for %@ was not found, instead we found %@", a3, v22);
LABEL_26:
            CFRelease(v24);
LABEL_27:
            CFTypeRef v8 = 0;
            goto LABEL_32;
          }
        }
        else if (a2)
        {
          CFTypeID v26 = CFGetTypeID(a2);
          if (v26 == CFStringGetTypeID())
          {
            CFComparisonResult v27 = CFStringCompare(v24, a2, 0);
            uint64_t v14 = 0;
            if (!a3 || v27) {
              goto LABEL_29;
            }
            key = (void *)*MEMORY[0x1E4F3BD40];
            uint64_t v29 = CFDictionaryGetValue((CFDictionaryRef)result, (const void *)*MEMORY[0x1E4F3BD40]);
            if (v29)
            {
              uint64_t v14 = CFDictionaryCreateMutableForCFTypesWith((int)v29, v30, v31, v32, v33, v34, v35, v36, key, (uint64_t)v29);
              CFDictionaryRef v44 = CFDictionaryCreateForCFTypes((uint64_t)v14, v37, v38, v39, v40, v41, v42, v43, v20, (uint64_t)a3);
              if (!v44)
              {
                _PCSErrorOOM(a4);
                CFTypeRef v8 = 0;
LABEL_30:
                CFRelease(v24);
                if (!v14) {
                  goto LABEL_32;
                }
                goto LABEL_31;
              }
              CFDictionaryRef v45 = v44;
              SecItemUpdate(v14, v44);
              CFRelease(v45);
LABEL_29:
              CFTypeRef v8 = CFRetain(v8);
              goto LABEL_30;
            }
            goto LABEL_26;
          }
        }
        uint64_t v14 = 0;
        goto LABEL_29;
      }
      CFTypeID v25 = CFGetTypeID(v22);
      if (v25 == CFStringGetTypeID())
      {
        CFStringRef v24 = (const __CFString *)CFRetain(v22);
        if (v24) {
          goto LABEL_14;
        }
      }
    }
    CFTypeRef v8 = CFRetain(v8);
    goto LABEL_32;
  }
  PCSSecError(v16, (CFErrorRef *)a4, @"SecItem failed to %@ %@", @"fetch", v12, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, 0);
  CFTypeRef v8 = 0;
LABEL_31:
  CFRelease(v14);
LABEL_32:
  CFTypeRef v46 = result;
  if (result)
  {
    CFTypeRef result = 0;
    CFRelease(v46);
  }
  return v8;
}

uint64_t _PCSSecItemDeleteIfPresent(uint64_t a1)
{
  uint64_t v2 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49D8;
  unsigned int v3 = off_1EB3B39C8(a1);
  qword_1EB3B49E0 += PCSMeasureRelativeNanoTime() - v2;
  if (v3 == -25300) {
    return 0;
  }
  else {
    return v3;
  }
}

BOOL __PCSDeleteFromKeychain(int a1, CFErrorRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, (int)a2, a3, a4, a5, a6, a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B988]);
  if (MutableForCFTypesWith)
  {
    unint64_t v10 = MutableForCFTypesWith;
    int v11 = _PCSSecItemDeleteIfPresent((uint64_t)MutableForCFTypesWith);
    BOOL v12 = PCSSecError(v11, a2, @"SecItem failed to delete on private identity");
    CFRelease(v10);
    return v12;
  }
  else
  {
    _PCSErrorOOM((const void **)a2);
    return 0;
  }
}

BOOL __PCSDeleteFromKeychainICDP(const void *a1, CFErrorRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  unint64_t v9 = 0;
  BOOL v10 = 0;
  v23[4] = *MEMORY[0x1E4F143B8];
  v23[0] = kPCSServiceName[0];
  v23[1] = kPCSiCloudServiceMarkerName[0];
  v23[2] = kPCSiCloudServiceName;
  v23[3] = kPCSiCloudServiceGuitarfishName;
  CFDataRef v22 = (void *)*MEMORY[0x1E4F3B978];
  uint64_t v21 = *MEMORY[0x1E4F3B998];
  int v11 = (const void *)*MEMORY[0x1E4F1CFD0];
  key = (void *)*MEMORY[0x1E4F3B848];
  unint64_t v18 = (void *)*MEMORY[0x1E4F3B878];
  do
  {
    uint64_t v12 = v23[v9];
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)a1, (int)a2, a3, a4, a5, a6, a7, a8, v22, v21);
    if (!MutableForCFTypesWith) {
      break;
    }
    uint64_t v14 = MutableForCFTypesWith;
    if (a1) {
      CFDictionarySetValue(MutableForCFTypesWith, key, a1);
    }
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(v14, v18, v11);
    }
    int v15 = _PCSSecItemDeleteIfPresent((uint64_t)v14);
    BOOL v16 = PCSSecError(v15, a2, @"SecItem failed to delete iCDP %@ domain", v12);
    CFRelease(v14);
    if (!v16) {
      break;
    }
    BOOL v10 = v9++ > 2;
  }
  while (v9 != 4);
  return v10;
}

__CFDictionary *__PCSDeleteFromKeychainICDPForRPD(const void *a1, CFErrorRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v10 = kPCSiCloudServiceGuitarfishName;
  int v11 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFTypeRef result = CFDictionaryCreateMutableForCFTypesWith((int)a1, (int)a2, a3, a4, a5, a6, a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  if (result)
  {
    uint64_t v13 = result;
    if (a1) {
      CFDictionarySetValue(result, (const void *)*MEMORY[0x1E4F3B848], a1);
    }
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F3B878], v11);
    }
    int v14 = _PCSSecItemDeleteIfPresent((uint64_t)v13);
    BOOL v15 = PCSSecError(v14, a2, @"SecItem failed to delete iCDP %@ domain", v10);
    CFRelease(v13);
    return (__CFDictionary *)v15;
  }
  return result;
}

void sub_1ACFAEFE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1ACFAF278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getUMUserManagerClass()
{
  uint64_t v4 = 0;
  CFIndex v5 = &v4;
  uint64_t v6 = 0x2050000000;
  id v0 = (void *)getUMUserManagerClass_softClass;
  uint64_t v7 = getUMUserManagerClass_softClass;
  if (!getUMUserManagerClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    void v3[2] = __getUMUserManagerClass_block_invoke;
    v3[3] = &unk_1E5E6DDF8;
    v3[4] = &v4;
    __getUMUserManagerClass_block_invoke((uint64_t)v3);
    id v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1ACFAF3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1ACFAF638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_1ACFAF8F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1ACFAFB90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1ACFAFE5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1ACFB0948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getACAccountStoreClass_block_invoke(uint64_t a1)
{
  AccountsLibrary();
  Class result = objc_getClass("ACAccountStore");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    __getACAccountStoreClass_block_invoke_cold_1();
  }
  getACAccountStoreClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t AccountsLibrary()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!AccountsLibraryCore_frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    void v3[2] = 3221225472;
    v3[3] = __AccountsLibraryCore_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5E6E120;
    uint64_t v5 = 0;
    AccountsLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  uint64_t v0 = AccountsLibraryCore_frameworkLibrary;
  id v1 = (void *)v3[0];
  if (!AccountsLibraryCore_frameworkLibrary)
  {
    id v1 = (void *)abort_report_np();
    goto LABEL_7;
  }
  if (v3[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

uint64_t __AccountsLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  AccountsLibraryCore_frameworkLibrary = result;
  return result;
}

void *__getACDAccountStoreDidChangeNotificationSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)AccountsLibrary();
  uint64_t result = dlsym(v2, "ACDAccountStoreDidChangeNotification");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACDAccountStoreDidChangeNotificationSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getACAccountTypeIdentifierKeySymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)AccountsLibrary();
  uint64_t result = dlsym(v2, "ACAccountTypeIdentifierKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACAccountTypeIdentifierKeySymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getACAccountTypeIdentifierAppleAccountSymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)AccountsLibrary();
  uint64_t result = dlsym(v2, "ACAccountTypeIdentifierAppleAccount");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getACAccountTypeIdentifierAppleAccountSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class __getUMUserManagerClass_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!UserManagementLibraryCore_frameworkLibrary)
  {
    v3[1] = (void *)MEMORY[0x1E4F143A8];
    void v3[2] = (void *)3221225472;
    v3[3] = __UserManagementLibraryCore_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5E6E138;
    uint64_t v5 = 0;
    UserManagementLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!UserManagementLibraryCore_frameworkLibrary)
    {
      abort_report_np();
LABEL_8:
      __getUMUserManagerClass_block_invoke_cold_1();
    }
    if (v3[0]) {
      free(v3[0]);
    }
  }
  Class result = objc_getClass("UMUserManager");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    goto LABEL_8;
  }
  getUMUserManagerClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __UserManagementLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  UserManagementLibraryCore_frameworkLibrary = result;
  return result;
}

uint64_t __AppleAccountLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  AppleAccountLibraryCore_frameworkLibrary = result;
  return result;
}

Class __getAKAccountManagerClass_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!AuthKitLibraryCore_frameworkLibrary)
  {
    v3[1] = (void *)MEMORY[0x1E4F143A8];
    void v3[2] = (void *)3221225472;
    v3[3] = __AuthKitLibraryCore_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5E6E168;
    uint64_t v5 = 0;
    AuthKitLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!AuthKitLibraryCore_frameworkLibrary)
    {
      abort_report_np();
LABEL_8:
      __getAKAccountManagerClass_block_invoke_cold_1();
    }
    if (v3[0]) {
      free(v3[0]);
    }
  }
  Class result = objc_getClass("AKAccountManager");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    goto LABEL_8;
  }
  getAKAccountManagerClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __AuthKitLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  AuthKitLibraryCore_frameworkLibrary = result;
  return result;
}

uint64_t PCSShareProtectionGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __PCSShareProtectionGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &PCSShareProtectionGetTypeID_sPCSShareProtectionGetTypeIDSingleton;
  if (PCSShareProtectionGetTypeID_sPCSShareProtectionGetTypeIDOnce != -1) {
    dispatch_once(&PCSShareProtectionGetTypeID_sPCSShareProtectionGetTypeIDOnce, block);
  }
  return PCSShareProtectionGetTypeID_sPCSShareProtectionGetTypeIDSingleton;
}

uint64_t __PCSShareProtectionGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t PCSShareProtectionDestroy(uint64_t a1)
{
  uint64_t v2 = *(__CFData **)(a1 + 72);
  if (v2)
  {
    CFDataGetLength(*(CFDataRef *)(a1 + 72));
    CFDataGetMutableBytePtr(v2);
    cc_clear();
    unsigned int v3 = *(const void **)(a1 + 72);
    if (v3)
    {
      *(void *)(a1 + 72) = 0;
      CFRelease(v3);
    }
  }
  long long v4 = *(const void **)(a1 + 80);
  if (v4)
  {
    *(void *)(a1 + 80) = 0;
    CFRelease(v4);
  }
  uint64_t v5 = *(const void **)(a1 + 112);
  if (v5)
  {
    *(void *)(a1 + 112) = 0;
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 88);
  if (v6)
  {
    *(void *)(a1 + 8_Block_object_dispose(&a9, 8) = 0;
    CFRelease(v6);
  }
  uint64_t v7 = *(const void **)(a1 + 96);
  if (v7)
  {
    *(void *)(a1 + 96) = 0;
    CFRelease(v7);
  }
  CFTypeRef v8 = *(const void **)(a1 + 104);
  if (v8)
  {
    *(void *)(a1 + 104) = 0;
    CFRelease(v8);
  }
  unint64_t v9 = *(__CFData **)(a1 + 64);
  if (v9)
  {
    CFDataGetLength(*(CFDataRef *)(a1 + 64));
    CFDataGetMutableBytePtr(v9);
    cc_clear();
    uint64_t v10 = *(const void **)(a1 + 64);
    if (v10)
    {
      *(void *)(a1 + 64) = 0;
      CFRelease(v10);
    }
  }
  int v11 = *(const void **)(a1 + 16);
  if (v11)
  {
    *(void *)(a1 + 16) = 0;
    CFRelease(v11);
  }
  uint64_t v12 = *(const void **)(a1 + 40);
  if (v12)
  {
    *(void *)(a1 + 40) = 0;
    CFRelease(v12);
  }
  uint64_t v13 = *(const void **)(a1 + 48);
  if (v13)
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    CFRelease(v13);
  }
  int v14 = *(const void **)(a1 + 56);
  if (v14)
  {
    *(void *)(a1 + 56) = 0;
    CFRelease(v14);
  }
  BOOL v15 = *(const void **)(a1 + 176);
  if (v15)
  {
    *(void *)(a1 + 176) = 0;
    CFRelease(v15);
  }
  BOOL v16 = *(const void **)(a1 + 184);
  if (v16)
  {
    *(void *)(a1 + 184) = 0;
    CFRelease(v16);
  }
  CFTypeID v17 = *(const void **)(a1 + 144);
  if (v17)
  {
    *(void *)(a1 + 144) = 0;
    CFRelease(v17);
  }
  unint64_t v18 = *(const void **)(a1 + 152);
  if (v18)
  {
    *(void *)(a1 + 152) = 0;
    CFRelease(v18);
  }
  CFTypeID v19 = *(const void **)(a1 + 160);
  if (v19)
  {
    *(void *)(a1 + 160) = 0;
    CFRelease(v19);
  }
  uint64_t v20 = *(const void **)(a1 + 168);
  if (v20)
  {
    *(void *)(a1 + 16_Block_object_dispose(&a9, 8) = 0;
    CFRelease(v20);
  }
  uint64_t v21 = *(const void **)(a1 + 24);
  if (v21)
  {
    *(void *)(a1 + 24) = 0;
    CFRelease(v21);
  }
  CFDataRef v22 = *(const void **)(a1 + 32);
  if (v22)
  {
    *(void *)(a1 + 32) = 0;
    CFRelease(v22);
  }
  CFTypeID v23 = *(const void **)(a1 + 192);
  if (v23)
  {
    *(void *)(a1 + 192) = 0;
    CFRelease(v23);
  }
  uint64_t result = free_PCSAttributes(a1 + 128);
  *(unsigned char *)(a1 + 20_Block_object_dispose(&a9, 8) = 0;
  *(_DWORD *)(a1 + 216) = 0;
  return result;
}

uint64_t PCSShareProtectionCompare(void *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != PCSShareProtectionGetTypeID()) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (v5 != PCSShareProtectionGetTypeID()) {
    return 0;
  }
  uint64_t v6 = (const void *)a1[9];
  uint64_t v7 = (const void *)a2[9];
  return CFEqual(v6, v7);
}

CFStringRef PCSShareProtectionCopyDescription(uint64_t a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)PCSIdentitySetCopyIdentities(*(void *)(a1 + 16), 0);
  CFDataRef v3 = *(const __CFData **)(a1 + 80);
  if (v3)
  {
    BytePtr = (char *)CFDataGetBytePtr(v3);
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 80));
    CFStringRef v6 = _PCSCreateHexString(BytePtr, Length);
  }
  else
  {
    CFStringRef v6 = @"<no-masterkey>";
  }
  BOOL v7 = CFDictionaryGetCount(v2) != 0;
  CFTypeRef v8 = _PCSYESNO(v7);
  BOOL v9 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40)) != 0;
  uint64_t v10 = _PCSYESNO(v9);
  int v11 = _PCSYESNO(*(unsigned __int8 *)(a1 + 208));
  uint64_t v12 = _PCSYESNO(*(_DWORD *)(a1 + 204) == 3);
  uint64_t v13 = _PCSYESNO(*(_DWORD *)(a1 + 204) == 0);
  int v14 = _PCSYESNO(*(unsigned char *)(a1 + 209) == 0);
  CFStringRef v15 = CFStringCreateWithFormat(0, 0, @"<PCSShareProtection@%p: [ MasterKey ID: %@ PCSKey: %@ PCSPublic: %@ validated: %@ version2: %@ light: %@ readwrite: %@] >", a1, v6, v8, v10, v11, v12, v13, v14);
  if (v6) {
    CFRelease(v6);
  }
  if (v2) {
    CFRelease(v2);
  }
  return v15;
}

uint64_t ShareEntryGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __ShareEntryGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &ShareEntryGetTypeID_sShareEntryGetTypeIDSingleton;
  if (ShareEntryGetTypeID_sShareEntryGetTypeIDOnce != -1) {
    dispatch_once(&ShareEntryGetTypeID_sShareEntryGetTypeIDOnce, block);
  }
  return ShareEntryGetTypeID_sShareEntryGetTypeIDSingleton;
}

uint64_t __ShareEntryGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void ShareEntryDestroy(uint64_t a1)
{
  CFDictionaryRef v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0;
    CFRelease(v2);
  }
}

uint64_t ShareEntryCompare(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = CFGetTypeID((CFTypeRef)a1);
  if (v4 != ShareEntryGetTypeID()) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID((CFTypeRef)a2);
  if (v5 != ShareEntryGetTypeID()) {
    return 0;
  }
  uint64_t result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if (result) {
    return *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24);
  }
  return result;
}

CFStringRef ShareEntryCopyDescription(uint64_t a1)
{
  uint64_t PublicID = PCSPublicIdentityGetPublicID(*(void *)(a1 + 16));
  return CFStringCreateWithFormat(0, 0, @"<ShareEntry: %p: identity %@ flags: 0x%08x>", a1, PublicID, *(unsigned int *)(a1 + 24));
}

uint64_t _PCSRandomData(size_t count, void *bytes)
{
  uint64_t result = SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E4F3BC60], count, bytes);
  if (result) {
    abort();
  }
  return result;
}

BOOL _PCSCreateDerivedKey(const __CFData *a1, int a2, int a3, unint64_t a4, int a5, const void **a6)
{
  if (a4 >= 0x41)
  {
    _PCSError(a6, 17, @"Derivation to sizes larger than %d not supported (%d requested)", 64, a4);
  }
  else
  {
    ccsha256_di();
    CFDataGetLength(a1);
    CFDataGetBytePtr(a1);
    ccnistkdf_ctr_hmac();
  }
  return a4 < 0x41;
}

CFTypeRef PCSShareProtectionCreate(const void **a1)
{
  return PCSFPCreate((void *)kPCSFPTypeClassic, 0, a1);
}

CFTypeRef PCSFPCreate(void *a1, void *a2, const void **a3)
{
  id v5 = a1;
  id v6 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0
    || v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
    || (uint64_t Empty = __PCSShareProtectionCreateEmpty(a3)) == 0)
  {
    CFTypeRef v28 = 0;
    goto LABEL_31;
  }
  uint64_t v8 = (uint64_t)Empty;
  RandomKey = CreateRandomKey();
  if (!RandomKey)
  {
    CFTypeRef v28 = 0;
    goto LABEL_30;
  }
  uint64_t v10 = RandomKey;
  *(unsigned char *)(v8 + 20_Block_object_dispose(&a9, 8) = 1;
  if ([v5 isEqualToString:kPCSFPTypeClassic])
  {
    *(_DWORD *)(v8 + 204) = 2;
    CFDataRef v11 = (const __CFData *)CFRetain(v10);
    *(void *)(v8 + 72) = v11;
    generateObjectKey((void *)v8, v11, 0);
  }
  else if ([v5 isEqualToString:kPCSFPTypeShare])
  {
    *(_DWORD *)(v8 + 204) = 3;
    *(_WORD *)(v8 + 209) = 0;
    *(unsigned char *)(v8 + 213) = 0;
    generateOtherKeysFromRWMasterKey(v8, v10, v12, v13, v14, v15, v16, v17);
  }
  else
  {
    if (![v5 isEqualToString:kPCSFPTypeLight])
    {
      CFTypeRef v28 = 0;
      goto LABEL_28;
    }
    *(_DWORD *)(v8 + 204) = 0;
    generateObjectKey((void *)v8, v10, 0);
    *(void *)(v8 + 72) = CFRetain(v10);
  }
  *(void *)(v8 + 176) = PCFPOptionCopyIdentity(v6);
  unint64_t v18 = PCFPOptionCopyIdentity(v6);
  if (v18)
  {
    CFTypeID v19 = v18;
    uint64_t SigningIdentity = (const void *)_PCSIdentityGetSigningIdentity((uint64_t)v18);
    uint64_t v21 = SigningIdentity;
    if (SigningIdentity) {
      CFRetain(SigningIdentity);
    }
    CFRelease(v19);
  }
  else
  {
    uint64_t v21 = 0;
  }
  *(void *)(v8 + 184) = v21;
  id v22 = v6;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    CFTypeID v23 = [v22 objectForKeyedSubscript:kPCSFPService];
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      char v24 = PCSServiceItemRequireAuthorship(v23);
    }
    else {
      char v24 = 0;
    }
  }
  else
  {
    char v24 = 0;
  }

  *(unsigned char *)(v8 + 214) = v24;
  CFTypeID v25 = [v22 objectForKeyedSubscript:kPCSFPZoneObject];

  if (v25)
  {
    int v26 = v25[50];
    if (v26) {
      *(_DWORD *)(v8 + 200) = v26;
    }
  }
  KeyIDFromKey = CreateKeyIDFromKey(*(const __CFData **)(v8 + 72));
  *(void *)(v8 + 80) = KeyIDFromKey;
  if (!KeyIDFromKey)
  {
    CFTypeRef v28 = 0;
    uint64_t v29 = (const void *)v8;
    uint64_t v8 = (uint64_t)v10;
    goto LABEL_29;
  }
  CFTypeRef v28 = CFRetain((CFTypeRef)v8);
LABEL_28:
  uint64_t v29 = v10;
LABEL_29:
  CFRelease(v29);
LABEL_30:
  CFRelease((CFTypeRef)v8);
LABEL_31:

  return v28;
}

CFTypeRef PCSFPCreateLight(const void **a1)
{
  return PCSFPCreate((void *)kPCSFPTypeLight, 0, a1);
}

CFTypeRef PCSFPCreateShare(const void **a1)
{
  return PCSFPCreate((void *)kPCSFPTypeShare, 0, a1);
}

void *__PCSShareProtectionCreateEmpty(const void **a1)
{
  PCSShareProtectionGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  CFDataRef v3 = (void *)Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 216) = 1192348414;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    v3[14] = Mutable;
    if (!Mutable
      || (CFTypeRef v5 = PCSIdentitySetCreateMutable(a1), (v3[2] = v5) == 0)
      || (CFMutableDictionaryRef v6 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]), (v3[5] = v6) == 0))
    {
      CFRelease(v3);
      return 0;
    }
  }
  return v3;
}

__CFData *CreateRandomKey()
{
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 16);
  if (Mutable)
  {
    size_t Length = CFDataGetLength(Mutable);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    _PCSRandomData(Length, MutableBytePtr);
  }
  return Mutable;
}

CFDataRef generateObjectKey(void *a1, const __CFData *a2, int a3)
{
  CFMutableDictionaryRef v6 = (const void *)a1[13];
  if (v6)
  {
    a1[13] = 0;
    CFRelease(v6);
  }
  if (a3)
  {
    getObjectKey((uint64_t)a1);
    a1[13] = a1[11];
    a1[11] = 0;
  }
  else
  {
    BOOL v7 = (const void *)a1[11];
    if (v7)
    {
      a1[11] = 0;
      CFRelease(v7);
    }
  }
  CFDataRef result = CFDataCreateCopy(0, a2);
  a1[12] = result;
  return result;
}

BOOL generateOtherKeysFromRWMasterKey(uint64_t a1, CFDataRef theData, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 204) != 3) {
    PCSAbort("getting other key when not version2 ?:sp->version == VERSION2", (uint64_t)theData, a3, a4, a5, a6, a7, a8, v20);
  }
  if (*(unsigned char *)(a1 + 210)) {
    PCSAbort("getting other key when not version2 ?:!sp->flags.rolled", (uint64_t)theData, a3, a4, a5, a6, a7, a8, v20);
  }
  uint64_t v10 = *(const void **)(a1 + 64);
  if (v10)
  {
    *(void *)(a1 + 64) = 0;
    CFRelease(v10);
  }
  CFDataRef v11 = *(const void **)(a1 + 80);
  if (v11)
  {
    *(void *)(a1 + 80) = 0;
    CFRelease(v11);
  }
  uint64_t v12 = *(const void **)(a1 + 72);
  if (v12)
  {
    *(void *)(a1 + 72) = 0;
    CFRelease(v12);
  }
  MutableCFDataRef Copy = CFDataCreateMutableCopy(0, 0, theData);
  *(void *)(a1 + 64) = MutableCopy;
  if (!MutableCopy) {
    goto LABEL_14;
  }
  generateObjectKey((void *)a1, MutableCopy, 1);
  CFIndex Length = CFDataGetLength(theData);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, Length);
  *(void *)(a1 + 72) = Mutable;
  CFDataRef v16 = *(const __CFData **)(a1 + 64);
  CFIndex v17 = CFDataGetLength(Mutable);
  int MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(a1 + 72));
  BOOL result = _PCSCreateDerivedKey(v16, 20, (int)&MasterROKeyInputData, v17, MutableBytePtr, 0);
  if (!result) {
LABEL_14:
  }
    abort();
  *(_DWORD *)(a1 + 204) = 3;
  return result;
}

void *PCFPOptionCopyIdentity(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_19;
  }
  CFDictionaryRef v2 = [v1 objectForKeyedSubscript:kPCSFPIdentity];

  if (v2)
  {
    CFTypeID v3 = CFGetTypeID(v2);
    if (v3 == PCSIdentityGetTypeID())
    {
      CFTypeID v4 = CFRetain(v2);
LABEL_18:
      BOOL v9 = v4;
      goto LABEL_20;
    }
  }
  CFTypeRef v5 = [v1 objectForKeyedSubscript:kPCSFPIdentitySet];

  if (!v5 || (CFTypeID v6 = CFGetTypeID(v5), v6 != PCSIdentitySetGetTypeID()))
  {
    BOOL v9 = [v1 objectForKeyedSubscript:kPCSFPZoneObject];

    if (!v9) {
      goto LABEL_20;
    }
    CFTypeID v11 = CFGetTypeID(v9);
    if (v11 == PCSShareProtectionGetTypeID())
    {
      uint64_t v12 = v9[2];
      if (v12)
      {
        CFTypeID v4 = PCSIdentitySetCopyCurrentIdentityWithError(v12, kPCSServiceRaw, 0);
        goto LABEL_18;
      }
    }
LABEL_19:
    BOOL v9 = 0;
    goto LABEL_20;
  }
  BOOL v7 = [v1 objectForKeyedSubscript:kPCSFPService];

  if (!v7) {
    goto LABEL_19;
  }
  CFTypeID v8 = CFGetTypeID(v7);
  if (v8 != CFStringGetTypeID()) {
    goto LABEL_19;
  }
  CFTypeRef cf = 0;
  BOOL v9 = PCSIdentitySetCopyCurrentIdentityWithError((uint64_t)v5, v7, &cf);
  if (!v9 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)stat buf = 138412290;
    CFTypeRef v16 = cf;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCFPOptionCopyIdentity(kPCSFPIdentitySet) but failed to find identity: %@", buf, 0xCu);
  }
  CFTypeRef v10 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v10);
  }
LABEL_20:

  return v9;
}

__CFData *CreateKeyIDFromKey(const __CFData *a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v2 = (CFIndex *)ccsha256_di();
  if (!_PCSCreateDerivedKey(a1, 20, (int)&MasterKeyIDLabel, 0x10uLL, (int)&v6, 0)) {
    return 0;
  }
  CFIndex v3 = *v2;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v3);
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    cchmac();
  }
  return Mutable;
}

uint64_t MarkForCounterSigning(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = *(void *)(a2 + 16);
      if (result)
      {
        uint64_t result = (uint64_t)PCSIdentitySetCopyCurrentIdentityWithError(result, kPCSServiceRaw, 0);
        if (result)
        {
          uint64_t v5 = result;
          char v6 = *(const void **)(a1 + 176);
          if (v6)
          {
            *(void *)(a1 + 176) = 0;
            CFRelease(v6);
          }
          uint64_t v7 = *(const void **)(a1 + 184);
          if (v7)
          {
            *(void *)(a1 + 184) = 0;
            CFRelease(v7);
          }
          *(void *)(a1 + 176) = v5;
          uint64_t SigningIdentity = (const void *)_PCSIdentityGetSigningIdentity(v5);
          BOOL v9 = SigningIdentity;
          if (SigningIdentity) {
            CFRetain(SigningIdentity);
          }
          *(void *)(a1 + 184) = v9;
          uint64_t result = 1;
          *(unsigned char *)(a1 + 214) = 1;
          int v10 = *(_DWORD *)(a2 + 200);
          if (v10) {
            *(_DWORD *)(a1 + 200) = v10;
          }
        }
      }
    }
  }
  return result;
}

const void *PCSFPCopyCurrentPrivateKey(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 16)) != 0) {
    return PCSIdentitySetCopyCurrentIdentityWithError(v1, kPCSServiceRaw, 0);
  }
  else {
    return 0;
  }
}

CFTypeRef PCSFPCopyObject(CFTypeRef cf)
{
  CFTypeRef v1 = cf;
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == PCSShareProtectionGetTypeID() && (uint64_t Empty = __PCSShareProtectionCreateEmpty(0)) != 0)
    {
      CFTypeID v4 = Empty;
      uint64_t v5 = (const void *)Empty[2];
      if (v5)
      {
        v4[2] = 0;
        CFRelease(v5);
      }
      uint64_t v6 = PCSIdentitySetCopySet(*((void *)v1 + 2), 0);
      v4[2] = v6;
      if (!v6) {
        goto LABEL_52;
      }
      uint64_t v7 = *((void *)v1 + 3);
      if (v7)
      {
        uint64_t v8 = PCSIdentitySetCopySet(v7, 0);
        v4[3] = v8;
        if (!v8) {
          goto LABEL_52;
        }
      }
      uint64_t v9 = *((void *)v1 + 4);
      if (v9)
      {
        uint64_t v10 = PCSIdentitySetCopySet(v9, 0);
        v4[4] = v10;
        if (!v10) {
          goto LABEL_52;
        }
      }
      CFTypeID v11 = (const void *)v4[5];
      if (v11)
      {
        v4[5] = 0;
        CFRelease(v11);
      }
      MutableCFDataRef Copy = CFDictionaryCreateMutableCopy(0, 0, *((CFDictionaryRef *)v1 + 5));
      v4[5] = MutableCopy;
      if (!MutableCopy) {
        goto LABEL_52;
      }
      CFArrayRef v13 = (const __CFArray *)*((void *)v1 + 6);
      if (v13)
      {
        CFMutableArrayRef v14 = CFArrayCreateMutableCopy(0, 0, v13);
        void v4[6] = v14;
        if (!v14) {
          goto LABEL_52;
        }
      }
      CFDictionaryRef v15 = (const __CFDictionary *)*((void *)v1 + 7);
      if (v15)
      {
        CFMutableDictionaryRef v16 = CFDictionaryCreateMutableCopy(0, 0, v15);
        v4[7] = v16;
        if (!v16) {
          goto LABEL_52;
        }
      }
      CFDataRef v17 = (const __CFData *)*((void *)v1 + 8);
      if (v17) {
        CFMutableDataRef v18 = CFDataCreateMutableCopy(0, 0, v17);
      }
      else {
        CFMutableDataRef v18 = 0;
      }
      v4[8] = v18;
      CFDataRef v19 = (const __CFData *)*((void *)v1 + 9);
      if (v19) {
        CFMutableDataRef v20 = CFDataCreateMutableCopy(0, 0, v19);
      }
      else {
        CFMutableDataRef v20 = 0;
      }
      v4[9] = v20;
      uint64_t v21 = *((void *)v1 + 10);
      if (v21) {
        CFRetain(*((CFTypeRef *)v1 + 10));
      }
      v4[10] = v21;
      uint64_t v22 = *((void *)v1 + 11);
      if (v22) {
        CFRetain(*((CFTypeRef *)v1 + 11));
      }
      v4[11] = v22;
      uint64_t v23 = *((void *)v1 + 12);
      if (v23) {
        CFRetain(*((CFTypeRef *)v1 + 12));
      }
      v4[12] = v23;
      uint64_t v24 = *((void *)v1 + 13);
      if (v24) {
        CFRetain(*((CFTypeRef *)v1 + 13));
      }
      if (((v4[13] = v24, (CFTypeID v25 = (const void *)v4[14]) == 0)
         || (v4[14] = 0,
             CFRelease(v25),
             CFMutableDictionaryRef v26 = CFDictionaryCreateMutableCopy(0, 0, *((CFDictionaryRef *)v1 + 14)),
             (v4[14] = v26) != 0))
        && (v4[15] = *((void *)v1 + 15), !copy_PCSAttributes()))
      {
        uint64_t v27 = *((void *)v1 + 18);
        if (v27) {
          CFRetain(*((CFTypeRef *)v1 + 18));
        }
        v4[18] = v27;
        uint64_t v28 = *((void *)v1 + 19);
        if (v28) {
          CFRetain(*((CFTypeRef *)v1 + 19));
        }
        v4[19] = v28;
        uint64_t v29 = *((void *)v1 + 20);
        if (v29) {
          CFRetain(*((CFTypeRef *)v1 + 20));
        }
        v4[20] = v29;
        uint64_t v30 = *((void *)v1 + 21);
        if (v30) {
          CFRetain(*((CFTypeRef *)v1 + 21));
        }
        v4[21] = v30;
        uint64_t v31 = *((void *)v1 + 22);
        if (v31) {
          CFRetain(*((CFTypeRef *)v1 + 22));
        }
        v4[22] = v31;
        uint64_t v32 = *((void *)v1 + 22);
        if (v32)
        {
          uint64_t SigningIdentity = (const void *)_PCSIdentityGetSigningIdentity(v32);
          int v34 = SigningIdentity;
          if (SigningIdentity) {
            CFRetain(SigningIdentity);
          }
        }
        else
        {
          int v34 = 0;
        }
        v4[23] = v34;
        *((_DWORD *)v4 + 51) = *((_DWORD *)v1 + 51);
        *((_DWORD *)v4 + 52) = *((_DWORD *)v1 + 52);
        *((_WORD *)v4 + 106) = *((_WORD *)v1 + 106);
        *((unsigned char *)v4 + 214) = *((unsigned char *)v1 + 214);
        CFTypeRef v1 = CFRetain(v4);
      }
      else
      {
LABEL_52:
        CFTypeRef v1 = 0;
      }
      CFRelease(v4);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

BOOL PCSFPIsReadWrite(uint64_t a1)
{
  return *(_DWORD *)(a1 + 204) != 3 || *(unsigned char *)(a1 + 209) == 0;
}

BOOL PCSFPSupportFeature(uint64_t a1, int a2)
{
  if (a2 == 2)
  {
    return (*(_DWORD *)(a1 + 204) & 0xFFFFFFFE) == 2;
  }
  else
  {
    if (a2 != 1) {
      return 0;
    }
    if (*(_DWORD *)(a1 + 204) != 3) {
      return 1;
    }
    return *(unsigned char *)(a1 + 209) == 0;
  }
}

BOOL PCSFPIsLight(uint64_t a1)
{
  return *(_DWORD *)(a1 + 204) == 0;
}

uint64_t PCSFPGetUnwrapPublicIdentity(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

uint64_t PCSFPStatus(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    return 24;
  }
  if (!*(void *)(a1 + 72)) {
    return 11;
  }
  if (!*(void *)(a1 + 80)) {
    return 23;
  }
  if (*(void *)(a1 + 16)) {
    return 0;
  }
  return 11;
}

CFDataRef PCSFPCreateUniqueID(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2020000000;
  uint64_t v25 = 0;
  CFDictionaryRef v2 = (const __CFDictionary *)PCSIdentitySetCopyIdentities(*(void *)(a1 + 16), 0);
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  v23[3] = (uint64_t)Mutable;
  CFArrayAppendValue(Mutable, *(const void **)(a1 + 72));
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = __PCSFPCreateUniqueID_block_invoke;
  context[3] = &unk_1E5E6DFD0;
  context[4] = &v22;
  CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)apply_block_2_1, context);
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 40);
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  v20[2] = __PCSFPCreateUniqueID_block_invoke_2;
  v20[3] = &unk_1E5E6DFD0;
  v20[4] = &v22;
  CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)apply_block_2_1, v20);
  CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 112);
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 3221225472;
  _OWORD v19[2] = __PCSFPCreateUniqueID_block_invoke_3;
  v19[3] = &unk_1E5E6DFD0;
  void v19[4] = &v22;
  CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)apply_block_2_1, v19);
  if (v2) {
    CFRelease(v2);
  }
  CFArrayRef v6 = (const __CFArray *)v23[3];
  v27.CFIndex length = CFArrayGetCount(v6);
  v27.CFIndex location = 0;
  CFArraySortValues(v6, v27, (CFComparatorFunction)ArraySortCompare, 0);
  uint64_t v7 = ccsha256_di();
  MEMORY[0x1F4188790](v7);
  uint64_t v9 = (char *)v19 - v8;
  ccdigest_init();
  CFIndex Count = CFArrayGetCount((CFArrayRef)v23[3]);
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v23[3], i);
      CFTypeID v13 = CFGetTypeID(ValueAtIndex);
      if (v13 == CFStringGetTypeID())
      {
        CFMutableArrayRef v14 = PCSCFStringToCString(ValueAtIndex);
        strlen(v14);
        ccdigest_update();
        free(v14);
      }
      else
      {
        CFDataGetLength((CFDataRef)ValueAtIndex);
        CFDataGetBytePtr((CFDataRef)ValueAtIndex);
        ccdigest_update();
      }
    }
  }
  CFRelease((CFTypeRef)v23[3]);
  CFIndex v15 = *(void *)v7;
  MEMORY[0x1F4188790](v16);
  (*(void (**)(uint64_t, char *, char *))(v7 + 56))(v7, v9, (char *)v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
  CFDataRef v17 = CFDataCreate(0, (const UInt8 *)v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0), v15);
  _Block_object_dispose(&v22, 8);
  return v17;
}

void sub_1ACFB292C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void __PCSFPCreateUniqueID_block_invoke(uint64_t a1, const void *a2)
{
}

void __PCSFPCreateUniqueID_block_invoke_2(uint64_t a1, const void *a2)
{
}

void __PCSFPCreateUniqueID_block_invoke_3(uint64_t a1, int a2, void *value)
{
}

CFComparisonResult ArraySortCompare(const __CFString *a1, const __CFString *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    CFTypeID v5 = CFGetTypeID(a2);
    if (v5 == CFStringGetTypeID())
    {
      return CFStringCompare(a1, a2, 0);
    }
    return 1;
  }
  CFTypeID v7 = CFGetTypeID(a1);
  if (v7 != CFDataGetTypeID()) {
    PCSAbort("unknown type in array", v8, v9, v10, v11, v12, v13, v14, v24);
  }
  CFTypeID v15 = CFGetTypeID(a2);
  if (v15 != CFDataGetTypeID()) {
    return -1;
  }
  unint64_t Length = CFDataGetLength((CFDataRef)a1);
  unint64_t v17 = CFDataGetLength((CFDataRef)a2);
  unint64_t v18 = v17;
  if (Length >= v17) {
    size_t v19 = v17;
  }
  else {
    size_t v19 = Length;
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  uint64_t v21 = CFDataGetBytePtr((CFDataRef)a2);
  int v22 = memcmp(BytePtr, v21, v19);
  if (v22 > 0 || !v22 && Length > v18) {
    return 1;
  }
  LODWORD(v23) = v22 == 0;
  if (Length >= v18) {
    LODWORD(v23) = 0;
  }
  if (v22 < 0) {
    uint64_t v23 = 1;
  }
  else {
    uint64_t v23 = v23;
  }
  return v23 << 63 >> 63;
}

CFStringRef PCSFPCreatePEMData(CFDataRef theData)
{
  return __PCSCreateExportPEM(@"PCS SHARE PROTECTION", theData);
}

__CFString *PCSFPCopyDiagnostic(uint64_t a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)PCSIdentitySetCopyIdentities(*(void *)(a1 + 16), 0);
  uint64_t v41 = 0;
  uint64_t v42 = &v41;
  uint64_t v43 = 0x2020000000;
  int v44 = 0;
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0, 0);
  if (!Mutable) {
    goto LABEL_35;
  }
  CFDataRef v4 = *(const __CFData **)(a1 + 72);
  if (v4)
  {
    BytePtr = CFDataGetBytePtr(v4);
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 72));
    CFStringRef v7 = _PCSCreateBase64((uint64_t)BytePtr, Length, 0);
    CFStringRef v8 = v7;
    if (!v7) {
      goto LABEL_35;
    }
    CFStringAppendFormat(Mutable, 0, @"Masterkey: %@\n", v7);
    CFRelease(v8);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, @"Masterkey: ---- NO MASTERKEY available----\n");
  }
  CFDataRef v9 = *(const __CFData **)(a1 + 80);
  if (!v9)
  {
LABEL_9:
    uint64_t v14 = _PCSYESNO(*(unsigned __int8 *)(a1 + 208));
    CFStringAppendFormat(Mutable, 0, @"Validated: %@\n", v14);
    int v15 = *(_DWORD *)(a1 + 204) != 3 || *(unsigned char *)(a1 + 209) == 0;
    uint64_t v16 = _PCSYESNO(v15);
    CFStringAppendFormat(Mutable, 0, @"ReadWrite: %@\n", v16);
    unint64_t v17 = _PCSYESNO((*(_DWORD *)(a1 + 204) & 0xFFFFFFFE) == 2);
    CFStringAppendFormat(Mutable, 0, @"Expose zone key: %@\n", v17);
    unint64_t v18 = _PCSYESNO(*(_DWORD *)(a1 + 204) == 3);
    CFStringAppendFormat(Mutable, 0, @"Version2: %@\n", v18);
    size_t v19 = _PCSYESNO(*(_DWORD *)(a1 + 204) == 0);
    CFStringAppendFormat(Mutable, 0, @"Light: %@\n", v19);
    *((_DWORD *)v42 + 6) = 0;
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __PCSFPCopyDiagnostic_block_invoke;
    context[3] = &unk_1E5E6DF70;
    context[4] = &v41;
    void context[5] = Mutable;
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)apply_block_2_1, context);
    *((_DWORD *)v42 + 6) = 0;
    CFDictionaryRef v20 = *(const __CFDictionary **)(a1 + 40);
    v39[0] = MEMORY[0x1E4F143A8];
    v39[1] = 3221225472;
    v39[2] = __PCSFPCopyDiagnostic_block_invoke_2;
    v39[3] = &unk_1E5E6DF70;
    v39[4] = &v41;
    v39[5] = Mutable;
    CFDictionaryApplyFunction(v20, (CFDictionaryApplierFunction)apply_block_2_1, v39);
    CFDictionaryRef v21 = *(const __CFDictionary **)(a1 + 112);
    if (v21)
    {
      *((_DWORD *)v42 + 6) = 0;
      v38[0] = MEMORY[0x1E4F143A8];
      v38[1] = 3221225472;
      void v38[2] = __PCSFPCopyDiagnostic_block_invoke_3;
      v38[3] = &unk_1E5E6DF70;
      v38[4] = &v41;
      v38[5] = Mutable;
      CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)apply_block_2_1, v38);
    }
    CFArrayRef v22 = *(const __CFArray **)(a1 + 48);
    if (v22)
    {
      *((_DWORD *)v42 + 6) = 0;
      v37[0] = MEMORY[0x1E4F143A8];
      v37[1] = 3221225472;
      v37[2] = __PCSFPCopyDiagnostic_block_invoke_4;
      v37[3] = &unk_1E5E6E188;
      v37[4] = &v41;
      v37[5] = Mutable;
      uint64_t v23 = v37;
      v45.CFIndex length = CFArrayGetCount(v22);
      v45.CFIndex location = 0;
      CFArrayApplyFunction(v22, v45, (CFArrayApplierFunction)apply_block_1_0, v23);
    }
    if (v2) {
      CFRelease(v2);
    }
    CFStringAppendFormat(Mutable, 0, @"Top Level Service ID: %u\n", *(unsigned int *)(a1 + 200));
    uint64_t v24 = *(void *)(a1 + 168);
    if (v24)
    {
      CFDataRef v25 = PCSPublicIdentityCopyPublicKey(v24);
      CFDataRef v26 = v25;
      if (v25)
      {
        CFRange v27 = CFDataGetBytePtr(v25);
        CFIndex v28 = CFDataGetLength(v26);
        CFStringRef v29 = _PCSCreateBase64((uint64_t)v27, v28, 0);
      }
      else
      {
        CFStringRef v29 = 0;
      }
      CFStringAppendFormat(Mutable, 0, @"Validation identity: %@\n", v29);
      if (v29) {
        CFRelease(v29);
      }
      if (v26) {
        CFRelease(v26);
      }
    }
    uint64_t v30 = *(void *)(a1 + 160);
    if (v30)
    {
      CFDataRef v31 = PCSPublicIdentityCopyPublicKey(v30);
      CFDataRef v32 = v31;
      if (v31)
      {
        int v33 = CFDataGetBytePtr(v31);
        CFIndex v34 = CFDataGetLength(v32);
        CFStringRef v35 = _PCSCreateBase64((uint64_t)v33, v34, 0);
      }
      else
      {
        CFStringRef v35 = 0;
      }
      CFStringAppendFormat(Mutable, 0, @"Owner identity: %@\n", v35);
      if (v35) {
        CFRelease(v35);
      }
      if (v32) {
        CFRelease(v32);
      }
    }
    goto LABEL_34;
  }
  uint64_t v10 = (char *)CFDataGetBytePtr(v9);
  CFIndex v11 = CFDataGetLength(*(CFDataRef *)(a1 + 80));
  CFStringRef v12 = _PCSCreateHexString(v10, v11);
  CFStringRef v13 = v12;
  if (v12)
  {
    CFStringAppendFormat(Mutable, 0, @"MasterkeyID: %@\n", v12);
    CFRelease(v13);
    goto LABEL_9;
  }
LABEL_35:
  if (v2) {
    CFRelease(v2);
  }
  if (Mutable)
  {
    CFRelease(Mutable);
    CFMutableDictionaryRef Mutable = 0;
  }
LABEL_34:
  _Block_object_dispose(&v41, 8);
  return Mutable;
}

void sub_1ACFB2FF0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void __PCSFPCopyDiagnostic_block_invoke(uint64_t a1, uint64_t a2)
{
}

void __PCSFPCopyDiagnostic_block_invoke_2(uint64_t a1, const void *a2, uint64_t a3)
{
  CFDataRef v6 = PCSPublicIdentityCopyWebSafePublicKeyID(*(void *)(a3 + 16));
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, @"Share peer %d: %@ (%@) flags: %d\n", *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), a2, v6, *(unsigned int *)(a3 + 24));
  if (v6) {
    CFRelease(v6);
  }
  CFDictionaryRef v7 = (const __CFDictionary *)PCSGetPublicIdentitites();
  if (CFDictionaryGetValue(v7, a2)) {
    CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, @"\tis CloudKit Public Identity\n");
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void __PCSFPCopyDiagnostic_block_invoke_3(uint64_t a1, const __CFData *a2, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  CFStringRef v8 = _PCSCreateBase64((uint64_t)BytePtr, Length, 0);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, @"old master key %d: %@\n", *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v8);
  if (v8) {
    CFRelease(v8);
  }
  CFDataRef v9 = (char *)CFDataGetBytePtr(a2);
  CFIndex v10 = CFDataGetLength(a2);
  CFStringRef v11 = _PCSCreateHexString(v9, v10);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, @"old master key ID %d: %@\n", *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v11);
  if (v11) {
    CFRelease(v11);
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void __PCSFPCopyDiagnostic_block_invoke_4(uint64_t a1, uint64_t a2)
{
  CFDataRef v4 = PCSPublicIdentityCopyWebSafePublicKeyID(a2);
  BOOL IsDiversified = _PCSPublicIdentityIsDiversified(a2);
  CFDataRef v6 = *(__CFString **)(a1 + 40);
  uint64_t v7 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t PublicID = PCSPublicIdentityGetPublicID(a2);
  CFDataRef v9 = "";
  if (IsDiversified) {
    CFDataRef v9 = " div";
  }
  CFStringAppendFormat(v6, 0, @"public identity %d: %@ (%@)%s\n", v7, PublicID, v4, v9);
  if (v4) {
    CFRelease(v4);
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

__CFData *_PCSFPCopyExportedWithOptions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v123 = 0;
  v124 = &v123;
  uint64_t v125 = 0x7810000000;
  v126 = &unk_1AD014ACD;
  long long v127 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  uint64_t v132 = 0;
  uint64_t v116 = 0;
  v117 = &v116;
  uint64_t v118 = 0x3810000000;
  v119 = &unk_1AD014ACD;
  uint64_t v120 = 0;
  uint64_t v121 = 0;
  uint64_t v122 = 0;
  uint64_t v112 = 0;
  v113 = &v112;
  uint64_t v114 = 0x2020000000;
  int v115 = 0;
  if (*(_DWORD *)(a1 + 216) != 1192348414)
  {
    v100 = "PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive";
    goto LABEL_132;
  }
  int v10 = a3;
  int v11 = a2;
  if ((a2 | a3) == 1 && !a4)
  {
    _PCSError(a5, 141, @"cannot sign or request PPPCS signature without a public identity");
    goto LABEL_136;
  }
  if (!*(_DWORD *)(a1 + 204))
  {
    LightPCSObject = _CreateLightPCSObject(a1, a5);
LABEL_121:
    _Block_object_dispose(&v112, 8);
    _Block_object_dispose(&v116, 8);
    _Block_object_dispose(&v123, 8);
    return LightPCSObject;
  }
  uint64_t v132 = 0;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v128 = 0u;
  long long v129 = 0u;
  long long v127 = 0u;
  uint64_t v121 = 0;
  uint64_t v122 = 0;
  uint64_t v120 = 0;
  if (!*(void *)(a1 + 72))
  {
    _PCSError(a5, 25, @"can't export object w/o masterkey");
LABEL_136:
    LightPCSObject = 0;
    v103 = 0;
    v75 = 0;
LABEL_117:
    free_PCSEncryptedKeys((uint64_t)(v117 + 4));
    free_PCSShareProtection((uint64_t)(v124 + 4));
    if (v103)
    {
      free_PCSSPKeyList((uint64_t)v103);
      free(v103);
    }
    if (v75)
    {
      free_PCSSignature((uint64_t)v75);
      free(v75);
    }
    goto LABEL_121;
  }
  if (*(unsigned char *)(a1 + 209))
  {
    _PCSError(a5, 48, @"share is readonly for unwrapping identity");
    goto LABEL_136;
  }
  size_t Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40));
  size_t v14 = Count;
  if (!Count) {
    goto LABEL_136;
  }
  int v15 = malloc_type_calloc(Count, 0x38uLL, 0x109004004F1B07DuLL);
  uint64_t v16 = v124;
  v124[6] = (uint64_t)v15;
  if (!v15) {
    goto LABEL_136;
  }
  *((_DWORD *)v16 + 10) = v14;
  *((_DWORD *)v113 + 6) = 0;
  CFDictionaryRef v17 = *(const __CFDictionary **)(a1 + 40);
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = ___PCSFPCopyExportedWithOptions_block_invoke;
  context[3] = &unk_1E5E6E1B0;
  void context[6] = a1;
  void context[7] = a5;
  context[4] = &v123;
  void context[5] = &v112;
  context[8] = v14;
  CFDictionaryApplyFunction(v17, (CFDictionaryApplierFunction)apply_block_2_1, context);
  if (v14 != *((_DWORD *)v113 + 6))
  {
    v100 = "wrong number of PublicKeys:n == count";
    goto LABEL_132;
  }
  if (*(_DWORD *)(a1 + 204) != 3) {
    *(_DWORD *)(a1 + 204) = 2;
  }
  CFArrayRef v18 = (const __CFArray *)PCSIdentitySetCopyOrderedIdentities(*(void *)(a1 + 16), kPCSServiceRaw);
  CFArrayRef theArray = v18;
  if (!v18 || (size_t v19 = CFArrayGetCount(v18)) == 0)
  {
    v103 = 0;
    goto LABEL_19;
  }
  v103 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  if (!v103)
  {
    _PCSErrorOOM(a5);
    LightPCSObject = 0;
    v103 = 0;
    goto LABEL_147;
  }
  v103[1] = malloc_type_calloc(v19, 0x20uLL, 0x1090040863882BEuLL);
  CFDictionaryRef v20 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  v117[6] = (uint64_t)v20;
  if (!v20 || (CFDictionaryRef v21 = malloc_type_calloc(v19, 0x20uLL, 0x1090040863882BEuLL), (*(void *)(v117[6] + 8) = v21) == 0))
  {
    _PCSErrorOOM(a5);
    LightPCSObject = 0;
LABEL_147:
    v75 = 0;
    int v33 = 0;
    uint64_t v52 = 0;
    CFArrayRef v96 = theArray;
    goto LABEL_112;
  }
  *((_DWORD *)v113 + 6) = 0;
  v110[0] = MEMORY[0x1E4F143A8];
  v110[1] = 3221225472;
  v110[2] = ___PCSFPCopyExportedWithOptions_block_invoke_2;
  v110[3] = &unk_1E5E6E1D8;
  v110[4] = &v116;
  v110[5] = &v112;
  v110[6] = v103;
  v110[7] = v19;
  CFArrayRef v22 = v110;
  v133.CFIndex length = CFArrayGetCount(theArray);
  v133.CFIndex location = 0;
  CFArrayApplyFunction(theArray, v133, (CFArrayApplierFunction)apply_block_1_0, v22);

LABEL_19:
  size_t v23 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 112));
  if (v23)
  {
    uint64_t v24 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    v117[4] = (uint64_t)v24;
    CFDataRef v25 = malloc_type_calloc(v23, 0x10uLL, 0x108004057E67DB5uLL);
    *(void *)(v117[4] + _Block_object_dispose(&a9, 8) = v25;
    *((_DWORD *)v113 + 6) = 0;
    CFDictionaryRef v26 = *(const __CFDictionary **)(a1 + 112);
    v109[0] = MEMORY[0x1E4F143A8];
    v109[1] = 3221225472;
    v109[2] = ___PCSFPCopyExportedWithOptions_block_invoke_3;
    v109[3] = &unk_1E5E6E200;
    v109[4] = &v116;
    v109[5] = &v112;
    CFDictionaryApplyFunction(v26, (CFDictionaryApplierFunction)apply_block_2_1, v109);
    if (v23 != *((_DWORD *)v113 + 6)) {
      __assert_rtn("_PCSFPCopyExportedWithOptions", "PCSShareProtection.m", 1746, "n == count");
    }
  }
  CFRange v27 = malloc_type_calloc(1uLL, 0x20uLL, 0x1090040863882BEuLL);
  CFIndex v28 = v117;
  v117[5] = (uint64_t)v27;
  if (!v27) {
    goto LABEL_134;
  }
  *(void *)&long long v105 = 0;
  CFIndex v29 = length_PCSEncryptedKeys((uint64_t)(v28 + 4));
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, v29);
  CFDataRef v31 = Mutable;
  if (!Mutable) {
    goto LABEL_134;
  }
  CFDataSetLength(Mutable, v29);
  int MutableBytePtr = CFDataGetMutableBytePtr(v31);
  if (encode_PCSEncryptedKeys((uint64_t)&MutableBytePtr[v29 - 1], v29, (uint64_t)(v117 + 4), (uint64_t)&v105))
  {
    CFRelease(v31);
LABEL_134:
    uint64_t v52 = 0;
    int v33 = 0;
    goto LABEL_63;
  }
  if (v29 == (void)v105)
  {
    int v33 = PCSFPCopyEncryptedData(a1, 0, v31, a5);
    CFRelease(v31);
    if (!v33) {
      goto LABEL_62;
    }
    CFIndex v34 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    v124[12] = (uint64_t)v34;
    if (!v34 {
      || (CFStringRef v35 = malloc_type_malloc(4uLL, 0x28CD1F66uLL),
    }
          *(void *)(v124[12] + _Block_object_dispose(&a9, 8) = v35,
          (int v36 = *(_DWORD **)(v124[12] + 8)) == 0))
    {
      _PCSErrorOOM(a5);
      goto LABEL_62;
    }
    *int v36 = *(_DWORD *)CFDataGetBytePtr(*(CFDataRef *)(a1 + 80));
    *(void *)v124[12] = 4;
    if (v10)
    {
      if (!a4)
      {
        _PCSError(a5, 141, @"cannot request PPPCS signature without a public identity");
        goto LABEL_62;
      }
      v108 = 0;
      *(_OWORD *)v106 = 0u;
      long long v107 = xmmword_1ACFFF2B8;
      long long v105 = 0u;
      if ((_PCSPublicIdentityExportPCSSPKey(a4, (uint64_t)&v105, v37, v38, v39, v40, v41, v42) & 1) == 0) {
        PCSAbort("failed to fill manatee sharee PCSSPKey:_PCSPublicIdentityExportPCSSPKey(shareeSignatureIdentity, &expectedPublicKey)", v43, v44, v45, v46, v47, v48, v49, v101);
      }
      if (_PCSFPMustEncryptManateeSharingAttributes(a1))
      {
        uint64_t v104 = 0;
        CFIndex v50 = length_PCSSPKey((uint64_t)&v105);
        CFStringRef v51 = CFDataCreateMutable(0, v50);
        uint64_t v52 = v51;
        if (!v51) {
          goto LABEL_62;
        }
        CFDataSetLength(v51, v50);
        uint64_t v53 = CFDataGetMutableBytePtr(v52);
        if (encode_PCSSPKey((uint64_t)&v53[v50 - 1], v50, (uint64_t)&v105, (uint64_t)&v104))
        {
LABEL_144:
          CFRelease(v52);
          goto LABEL_62;
        }
        if (v50 != v104) {
          goto LABEL_157;
        }
        CFDataRef v54 = CFDataCreate(0, (const UInt8 *)"PCSSignatureKeyIDEncryption", 27);
        uint64_t v55 = PCSFPCopyEncryptedData(a1, v54, v52, a5);
        if (v54) {
          CFRelease(v54);
        }
        CFRelease(v52);
        if (!v55) {
          goto LABEL_62;
        }
        LODWORD(v107) = 11;
        FillOctetString((CFIndex *)&v107 + 1, v55);
        CFRelease(v55);
      }
      else
      {
        uint64_t v104 = 0;
        *((void *)&v107 + 1) = length_PCSSPKey((uint64_t)&v105);
        v74 = malloc_type_malloc(*((size_t *)&v107 + 1), 0x1B535954uLL);
        v108 = v74;
        if (!v74) {
          goto LABEL_62;
        }
        if (encode_PCSSPKey((uint64_t)v74 + *((void *)&v107 + 1) - 1, *((uint64_t *)&v107 + 1), (uint64_t)&v105, (uint64_t)&v104))goto LABEL_61; {
      }
        }
      uint64_t v56 = (unsigned int *)v124[7];
      if (!v56)
      {
        uint64_t v56 = (unsigned int *)malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
        v124[7] = (uint64_t)v56;
      }
      PCSReplaceOrUpdateAttribute(v56, v107, (uint64_t)&v107 + 8);
      free_PCSSPKey((uint64_t)&v105);
      free_PCSTypeValue((uint64_t)&v107);
    }
    uint64_t v57 = *(void *)(a1 + 160);
    if (!v57) {
      goto LABEL_49;
    }
    v108 = 0;
    *(_OWORD *)v106 = 0u;
    long long v107 = xmmword_1ACFFF2D0;
    long long v105 = 0u;
    uint64_t v104 = 0;
    if ((_PCSPublicIdentityExportPCSSPKey(v57, (uint64_t)&v105, v37, v38, v39, v40, v41, v42) & 1) == 0) {
      PCSAbort("failed to fill ownerIdentity PCSSPKey:_PCSPublicIdentityExportPCSSPKey(sp->ownerIdentity, &ownerPublicKey)", v58, v59, v60, v61, v62, v63, v64, v101);
    }
    *((void *)&v107 + 1) = length_PCSSPKey((uint64_t)&v105);
    uint64_t v65 = malloc_type_malloc(*((size_t *)&v107 + 1), 0xFD5715B8uLL);
    v108 = v65;
    if (!v65) {
      goto LABEL_62;
    }
    if (!encode_PCSSPKey((uint64_t)v65 + *((void *)&v107 + 1) - 1, *((uint64_t *)&v107 + 1), (uint64_t)&v105, (uint64_t)&v104))
    {
      v66 = (unsigned int *)v124[7];
      if (!v66)
      {
        v66 = (unsigned int *)malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
        v124[7] = (uint64_t)v66;
      }
      PCSReplaceOrUpdateAttribute(v66, v107, (uint64_t)&v107 + 8);
      free_PCSSPKey((uint64_t)&v105);
      free_PCSTypeValue((uint64_t)&v107);
LABEL_49:
      *(void *)&long long v105 = 0;
      CFIndex v67 = length_PCSSignedShareProtection((uint64_t)(v124 + 4));
      v68 = CFDataCreateMutable(0, v67);
      uint64_t v52 = v68;
      if (v68)
      {
        CFDataSetLength(v68, v67);
        v69 = CFDataGetMutableBytePtr(v52);
        if (!encode_PCSSignedShareProtection((uint64_t)&v69[v67 - 1], v67, (uint64_t)(v124 + 4), (uint64_t)&v105))
        {
          if (v67 != (void)v105) {
            goto LABEL_157;
          }
          int v70 = *(_DWORD *)(a1 + 204);
          if (v70 == 2)
          {
            if (getObjectKey(a1))
            {
              v71 = malloc_type_calloc(1uLL, 0x20uLL, 0x1090040863882BEuLL);
              v124[9] = (uint64_t)v71;
              if (v71)
              {
                int v72 = 5;
                goto LABEL_68;
              }
LABEL_139:
              _PCSErrorOOM(a5);
              goto LABEL_63;
            }
            v100 = "no ObjectKey, yet public keys:getObjectKey(sp)";
          }
          else
          {
            if (v70 != 3)
            {
LABEL_69:
              v76 = v124;
              uint64_t v77 = v124[9];
              if (v77) {
                uint64_t v78 = v77 + 16;
              }
              else {
                uint64_t v78 = 0;
              }
              if (!*(unsigned char *)(a1 + 214) || !*(void *)(a1 + 176)) {
                goto LABEL_76;
              }
              if (!v77)
              {
                _PCSError(a5, 89, @"can't do authorship w/o selfSign");
                goto LABEL_63;
              }
              v79 = malloc_type_calloc(1uLL, 0x28uLL, 0x1080040EC46ECBEuLL);
              v76 = v124;
              v124[13] = (uint64_t)v79;
              if (v79)
              {
LABEL_76:
                if (!v11)
                {
                  v75 = 0;
LABEL_82:
                  if (!CreateSignature(a1, v52, v33, v103, (_DWORD *)(a1 + 128), (size_t *)v76 + 10, v78, v76[13], (uint64_t)v75, a5))goto LABEL_64; {
                  v81 = (CFIndex *)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
                  }
                  v124[8] = (uint64_t)v81;
                  if (!v81)
                  {
LABEL_137:
                    _PCSErrorOOM(a5);
                    goto LABEL_64;
                  }
                  FillOctetString(v81, v33);
                  if (*(_DWORD *)(a1 + 204) <= 2u && !*(unsigned char *)(a1 + 214) && (v124[7] || v124[13] || v124[14])) {
                    goto LABEL_64;
                  }
                  if (!v11) {
                    goto LABEL_100;
                  }
                  if (!v75) {
                    goto LABEL_64;
                  }
                  v106[0] = 0;
                  long long v105 = xmmword_1ACFFF2E8;
                  if (!_PCSFPMustEncryptManateeSharingAttributes(a1))
                  {
                    *(void *)&long long v107 = 0;
                    *((void *)&v105 + 1) = length_PCSSignature((uint64_t)v75);
                    v98 = malloc_type_malloc(*((size_t *)&v105 + 1), 0xA0C2FE83uLL);
                    v106[0] = v98;
                    if (v98)
                    {
                      uint64_t v99 = encode_PCSSignature((uint64_t)v98 + *((void *)&v105 + 1) - 1, *((uint64_t *)&v105 + 1), (uint64_t)v75, (uint64_t)&v107);
                      if (!v99)
                      {
LABEL_99:
                        add_PCSAttributes((unsigned int *)v124[14]);
                        free_PCSTypeValue((uint64_t)&v105);
LABEL_100:
                        if (_PCSIdentitySupportsServerSigning(*(void *)(a1 + 176)))
                        {
                          CFArrayRef v88 = *(const __CFArray **)(a1 + 192);
                          if (v88)
                          {
                            CFIndex v89 = CFArrayGetCount(v88);
                            if (v89 >= 1)
                            {
                              CFIndex v90 = 0;
                              do
                              {
                                CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 192), v90);
                                v106[0] = 0;
                                long long v105 = xmmword_1ACFFF300;
                                if (!v124[14])
                                {
                                  v92 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
                                  v124[14] = (uint64_t)v92;
                                  if (!v92) {
                                    goto LABEL_137;
                                  }
                                }
                                FillOctetString((CFIndex *)&v105 + 1, ValueAtIndex);
                                add_PCSAttributes((unsigned int *)v124[14]);
                                free_PCSTypeValue((uint64_t)&v105);
                              }
                              while (v89 != ++v90);
                            }
                          }
                        }
                        *(void *)&long long v105 = 0;
                        CFIndex v93 = length_PCSShareProtection((uint64_t)(v124 + 4));
                        v94 = CFDataCreateMutable(0, v93);
                        LightPCSObject = v94;
                        if (v94)
                        {
                          CFDataSetLength(v94, v93);
                          v95 = CFDataGetMutableBytePtr(LightPCSObject);
                          if (encode_PCSShareProtection((uint64_t)&v95[v93 - 1], v93, (uint64_t)(v124 + 4), (uint64_t)&v105))
                          {
                            CFRelease(LightPCSObject);
                            goto LABEL_64;
                          }
                          if (v93 == (void)v105)
                          {
                            *(unsigned char *)(a1 + 210) = 0;
LABEL_111:
                            CFArrayRef v96 = theArray;
                            if (!theArray)
                            {
LABEL_113:
                              if (v33) {
                                CFRelease(v33);
                              }
                              if (v52) {
                                CFRelease(v52);
                              }
                              goto LABEL_117;
                            }
LABEL_112:
                            CFRelease(v96);
                            goto LABEL_113;
                          }
                          goto LABEL_157;
                        }
LABEL_64:
                        LightPCSObject = 0;
                        goto LABEL_111;
                      }
                      free(v106[0]);
                      v106[0] = 0;
                    }
                    else
                    {
                      uint64_t v99 = 12;
                    }
                    _PCSErrorASN1(a5, (uint64_t)"encode PCSSignature", v99);
                    goto LABEL_64;
                  }
                  *(void *)&long long v107 = 0;
                  CFIndex v82 = length_PCSSignature((uint64_t)v75);
                  v83 = CFDataCreateMutable(0, v82);
                  v84 = v83;
                  if (!v83) {
                    goto LABEL_64;
                  }
                  CFDataSetLength(v83, v82);
                  v85 = CFDataGetMutableBytePtr(v84);
                  if (encode_PCSSignature((uint64_t)&v85[v82 - 1], v82, (uint64_t)v75, (uint64_t)&v107))
                  {
                    CFRelease(v84);
                    goto LABEL_64;
                  }
                  if (v82 == (void)v107)
                  {
                    CFDataRef v86 = CFDataCreate(0, (const UInt8 *)"PCSSignatureEncryption", 22);
                    v87 = PCSFPCopyEncryptedData(a1, v86, v84, a5);
                    if (v86) {
                      CFRelease(v86);
                    }
                    CFRelease(v84);
                    if (!v87) {
                      goto LABEL_64;
                    }
                    LODWORD(v105) = 10;
                    FillOctetString((CFIndex *)&v105 + 1, v87);
                    CFRelease(v87);
                    goto LABEL_99;
                  }
LABEL_157:
                  uint64_t result = (__CFData *)asn1_abort();
                  goto LABEL_158;
                }
                if (!*(void *)(a1 + 184))
                {
                  _PCSError(a5, 142, @"can't do pppcs signing without a signing key");
                  goto LABEL_63;
                }
                v75 = malloc_type_calloc(1uLL, 0x28uLL, 0x1080040EC46ECBEuLL);
                if (v75)
                {
                  v76 = v124;
                  if (!v124[14])
                  {
                    v80 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
                    v76 = v124;
                    v124[14] = (uint64_t)v80;
                  }
                  goto LABEL_82;
                }
              }
              goto LABEL_139;
            }
            if (*(unsigned char *)(a1 + 209))
            {
              v100 = "version 2 but read only:!sp->flags.readonly";
            }
            else
            {
              if (getObjectKey(a1))
              {
                v71 = malloc_type_calloc(1uLL, 0x20uLL, 0x1090040863882BEuLL);
                v124[9] = (uint64_t)v71;
                if (v71)
                {
                  int v72 = 4;
LABEL_68:
                  _DWORD *v71 = v72;
                  goto LABEL_69;
                }
                goto LABEL_139;
              }
              v100 = "no ObjectKey, yet version2:getObjectKey(sp)";
            }
          }
LABEL_132:
          PCSAbort(v100, a2, a3, a4, (uint64_t)a5, a6, a7, a8, v101);
        }
        goto LABEL_144;
      }
LABEL_62:
      uint64_t v52 = 0;
LABEL_63:
      v75 = 0;
      goto LABEL_64;
    }
LABEL_61:
    free(v108);
    goto LABEL_62;
  }
  uint64_t result = (__CFData *)asn1_abort();
LABEL_158:
  __break(1u);
  return result;
}

void sub_1ACFB4254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  _Block_object_dispose(&a46, 8);
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose((const void *)(v50 - 224), 8);
  _Unwind_Resume(a1);
}

CFDataRef _CreateLightPCSObject(uint64_t a1, const void **a2)
{
  values[1] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = 0;
  if (*(_DWORD *)(a1 + 204))
  {
    _PCSError(a2, 64, @"Not a light object");
    return 0;
  }
  if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40)) != 1)
  {
    _PCSError(a2, 65, @"More than one share object");
    return 0;
  }
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 40), 0, (const void **)values);
  uint64_t v5 = MEMORY[0x1AD11C7C0]();
  uint64_t v6 = ccsha256_di();
  ccaes_ecb_encrypt_mode();
  unint64_t v7 = (unint64_t)(cczp_bitlen() + 7) >> 3;
  CFDataGetLength(*(CFDataRef *)(a1 + 72));
  uint64_t v8 = ccwrap_wrapped_size();
  CFIndex v29 = &v24;
  uint64_t v9 = MEMORY[0x1F4188790](v8);
  uint64_t v30 = v23;
  MEMORY[0x1F4188790](v9);
  uint64_t v10 = ccecb_context_size();
  uint64_t v11 = MEMORY[0x1F4188790](v10);
  MEMORY[0x1F4188790](v11);
  CFDataRef v31 = &v23[-((v7 + 15) & 0x3FFFFFFFFFFFFFF0)];
  CFDataRef PublicKey = (const __CFData *)PCSPublicIdentityGetPublicKey(*((void *)values[0] + 2));
  if (PublicKey)
  {
    uint64_t v27 = v8;
    uint64_t v28 = v6;
    unint64_t v26 = v7 + 1;
    unint64_t v13 = v7 + 1 + v8;
    size_t v14 = v13 + 2;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v13 + 2);
    if (!Mutable
      || (unint64_t v25 = v13,
          int MutableBytePtr = CFDataGetMutableBytePtr(Mutable),
          bzero(MutableBytePtr, v14),
          UInt8 *MutableBytePtr = -1,
          ccDRBGGetRngState(),
          ccec_generate_key_fips())
      || (unint64_t v33 = v7, ccDRBGGetRngState(), ccecdh_compute_shared_secret()))
    {
      CFDataRef PublicKey = 0;
    }
    else
    {
      CFDataRef PublicKey = PCSPublicIdentityCopyExportedPublicKey(*((void *)values[0] + 2));
      if (PublicKey && v7 == (unint64_t)(cczp_bitlen() + 7) >> 3)
      {
        uint64_t v24 = v5;
        ccec_compact_export();
        CFDataGetLength(PublicKey);
        CFDataGetBytePtr(PublicKey);
        if (cchkdf()) {
          goto LABEL_22;
        }
        ccecb_init();
        uint64_t v17 = v27;
        uint64_t v32 = v27;
        CFDataGetLength(*(CFDataRef *)(a1 + 72));
        CFDataGetBytePtr(*(CFDataRef *)(a1 + 72));
        int v18 = ccwrap_auth_encrypt();
        ccecb_context_size();
        cc_clear();
        if (v18)
        {
LABEL_22:
          CFDataRef Copy = 0;
        }
        else
        {
          if (v32 != v17) {
            _CreateLightPCSObject_cold_1();
          }
          BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 80));
          *(_WORD *)&MutableBytePtr[v25] = *(_WORD *)BytePtr;
          CFDataRef Copy = CFDataCreateCopy(0, Mutable);
        }
        goto LABEL_16;
      }
    }
  }
  else
  {
    CFMutableDictionaryRef Mutable = 0;
  }
  CFDataRef Copy = 0;
LABEL_16:
  cc_clear();
  if (PublicKey) {
    CFRelease(PublicKey);
  }
  rsize_t v20 = (unint64_t)(cczp_bitlen() + 7) >> 3;
  uint64_t v21 = cczp_bitlen();
  memset_s(v31, v20, 0, (unint64_t)(v21 + 7) >> 3);
  memset_s(v30, 0x10uLL, 0, 0x10uLL);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return Copy;
}

BOOL FillOctetString(CFIndex *a1, CFDataRef theData)
{
  size_t Length = CFDataGetLength(theData);
  uint64_t v5 = malloc_type_malloc(Length, 0x2408A2FBuLL);
  a1[1] = (CFIndex)v5;
  if (v5)
  {
    BytePtr = CFDataGetBytePtr(theData);
    size_t v7 = CFDataGetLength(theData);
    memcpy(v5, BytePtr, v7);
    *a1 = CFDataGetLength(theData);
  }
  return v5 != 0;
}

BOOL _PCSFPMustEncryptManateeSharingAttributes(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 176);
  if (v2)
  {
    int ServiceID = PCSIdentityGetServiceID(v2);
    if (!ServiceID) {
      return 0;
    }
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 160);
    if (!v4) {
      return 0;
    }
    int ServiceID = PCSPublicIdentityGetServiceID(v4);
    if (!ServiceID) {
      return 0;
    }
  }
  return PCSServiceItemAnonymousSharingByIndex(ServiceID);
}

unsigned int *PCSReplaceOrUpdateAttribute(unsigned int *result, int a2, uint64_t a3)
{
  uint64_t v4 = result;
  uint64_t v5 = *result;
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *((void *)result + 1);
    uint64_t v8 = 24 * v5;
    while (*(_DWORD *)(v7 + v6) != a2)
    {
      v6 += 24;
      if (v8 == v6) {
        goto LABEL_5;
      }
    }
    free(*(void **)(v7 + v6 + 16));
    uint64_t v9 = *((void *)v4 + 1) + v6 + 8;
    return (unsigned int *)MEMORY[0x1F417F6B0](a3, v9);
  }
  else
  {
LABEL_5:
    if (*(void *)(a3 + 8)) {
      return (unsigned int *)add_PCSAttributes(result);
    }
  }
  return result;
}

uint64_t getObjectKey(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 88);
  if (!result)
  {
    uint64_t result = *(void *)(a1 + 96);
    if (result)
    {
      uint64_t result = PCSKeyCreateKeyFromRandomData(result, "full master key");
      *(void *)(a1 + 8_Block_object_dispose(&a9, 8) = result;
      CFIndex v3 = *(const void **)(a1 + 96);
      if (v3)
      {
        *(void *)(a1 + 96) = 0;
        CFRelease(v3);
        return *(void *)(a1 + 88);
      }
    }
  }
  return result;
}

BOOL CreateSignature(uint64_t a1, const __CFData *a2, const __CFData *a3, _DWORD *a4, _DWORD *a5, size_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, const void **a10)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  long long v50 = 0u;
  long long v51 = 0u;
  memset(v49, 0, sizeof(v49));
  if (!a7)
  {
    int v36 = 0;
LABEL_30:
    BOOL Hmac = makeHmac(a1, a2, a3, a7, a6);
LABEL_31:
    if (!v36)
    {
LABEL_33:
      free_PCSObjectSignature((uint64_t)v49);
      return Hmac;
    }
LABEL_32:
    CFRelease(v36);
    goto LABEL_33;
  }
  uint64_t v45 = a6;
  uint64_t v46 = a8;
  uint64_t v16 = (uint64_t *)ccsha256_di();
  uint64_t v47 = v43;
  MEMORY[0x1F4188790](v16);
  int v18 = &v43[-((v17 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v48 = 0;
  uint64_t ObjectKey = getObjectKey(a1);
  if ((*(_DWORD *)(a1 + 204) & 0xFFFFFFFE) != 2) {
    PCSAbort("unexpected version:sp->version == VERSION2 || sp->version == VERSION1_5", v20, v21, v22, v23, v24, v25, v26, v43[0]);
  }
  uint64_t v27 = ObjectKey;
  if (!ObjectKey) {
    PCSAbort("no object key:objectKey", v20, v21, v22, v23, v24, v25, v26, v43[0]);
  }
  uint64_t v28 = _PCSKeyCopyExportedPublicKey(ObjectKey);
  if (v28)
  {
    CFIndex v29 = v28;
    uint64_t v44 = a10;
    DWORD2(v49[0]) = 1;
    FillOctetString((CFIndex *)&v49[1] + 1, v28);
    CFRelease(v29);
    if (a4)
    {
      if (*a4)
      {
        *(void *)&long long v51 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
        if (!(void)v51 || copy_PCSSPKeyList()) {
          goto LABEL_50;
        }
      }
    }
    if (a5)
    {
      if (*a5)
      {
        *((void *)&v51 + 1) = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
        if (!*((void *)&v51 + 1) || copy_PCSAttributes()) {
          goto LABEL_50;
        }
      }
    }
    unsigned int v30 = *(_DWORD *)(a1 + 124);
    int v31 = *(_DWORD *)(a1 + 120) + 1;
    *(_DWORD *)(a1 + 120) = v31;
    *(void *)&v49[0] = __PAIR64__(v30, v31);
    if (*(unsigned char *)(a1 + 214)) {
      DWORD1(v49[0]) = v30 | 3;
    }
    if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 112)))
    {
      uint64_t v32 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
      *(void *)&long long v50 = v32;
      if (!v32) {
        goto LABEL_50;
      }
      *uint64_t v32 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 112));
    }
    _PCSMakeDigest((uint64_t)v16, a2, a3, (uint64_t)v49, (uint64_t)v18);
    if (_PCSSignHash(v27, 0, 1, *v16, (uint64_t)v18, (uint64_t)&v49[2] + 8))
    {
      if (!*(void *)(a1 + 104)) {
        goto LABEL_22;
      }
      unint64_t v33 = malloc_type_calloc(1uLL, 0x28uLL, 0x1080040EC46ECBEuLL);
      *((void *)&v50 + 1) = v33;
      if (v33)
      {
        if (!_PCSSignHash(*(void *)(a1 + 104), 0, 1, *v16, (uint64_t)v18, (uint64_t)v33))
        {
LABEL_26:
          int v36 = 0;
LABEL_27:
          BOOL Hmac = 0;
          goto LABEL_31;
        }
LABEL_22:
        size_t v34 = length_PCSObjectSignature((uint64_t)v49);
        *(void *)a7 = v34;
        CFStringRef v35 = malloc_type_malloc(v34, 0xF3205574uLL);
        *(void *)(a7 + _Block_object_dispose(&a9, 8) = v35;
        if (!v35)
        {
LABEL_25:
          free_PCSObjectSignature((uint64_t)v49);
          goto LABEL_26;
        }
        if (encode_PCSObjectSignature((uint64_t)v35 + *(void *)a7 - 1, *(void *)a7, (uint64_t)v49, (uint64_t)&v48))
        {
          free(*(void **)(a7 + 8));
          *(void *)(a7 + _Block_object_dispose(&a9, 8) = 0;
          goto LABEL_25;
        }
        free_PCSObjectSignature((uint64_t)v49);
        if (*(void *)a7 != v48) {
          abort();
        }
        if (v46)
        {
          uint64_t Key = _PCSIdentityGetKey(*(void *)(a1 + 176));
          if (!Key) {
            goto LABEL_26;
          }
          uint64_t v40 = Key;
          int v36 = _PCSKeyCopyExportedPublicKey(Key);
          if (!v36) {
            goto LABEL_52;
          }
          if (!_PCSSignHash(v40, v36, 1, *v16, (uint64_t)v18, v46)) {
            goto LABEL_49;
          }
        }
        else
        {
          int v36 = 0;
        }
        if (!a9)
        {
LABEL_48:
          a6 = v45;
          goto LABEL_30;
        }
        uint64_t v41 = _PCSIdentityGetKey(*(void *)(a1 + 184));
        if (!v41)
        {
          _PCSError(v44, 142, @"PCSShareProtection missing signing identity; cannot generate pppcs signature");
          goto LABEL_27;
        }
        uint64_t v42 = v41;
        if (v36) {
          CFRelease(v36);
        }
        int v36 = _PCSKeyCopyExportedPublicKey(v42);
        if (v36)
        {
          if (!_PCSSignHash(v42, v36, 1, *v16, (uint64_t)v18, a9))
          {
LABEL_49:
            BOOL Hmac = 0;
            goto LABEL_32;
          }
          goto LABEL_48;
        }
LABEL_52:
        _PCSErrorOOM(v44);
        goto LABEL_27;
      }
LABEL_50:
      _PCSErrorOOM(v44);
      goto LABEL_26;
    }
  }
  return 0;
}

__CFData *PCSFPCopyExported(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _PCSFPCopyExportedWithOptions(a1, 0, 0, 0, a2, a6, a7, a8);
}

_DWORD *PCSFPCreateWithExported(uint64_t a1, uint64_t a2, const void **a3)
{
  if (!a2)
  {
    _PCSError(a3, 27, @"PCSFPCreateWithExported need an identity");
    return 0;
  }
  CFTypeRef Mutable = PCSIdentitySetCreateMutable(a3);
  if (!Mutable) {
    return 0;
  }
  uint64_t v7 = Mutable;
  if (PCSIdentitySetAddIdentity((uint64_t)Mutable, a2)) {
    uint64_t v8 = CreateWithExportedInternal(a1, (uint64_t)v7, 0, 0, 0, 0, 0, a3);
  }
  else {
    uint64_t v8 = 0;
  }
  CFRelease(v7);
  return v8;
}

_DWORD *CreateWithExportedInternal(uint64_t a1, uint64_t a2, void *a3, int a4, char a5, void *a6, void *a7, const void **a8)
{
  id v129 = a6;
  id v130 = a7;
  uint64_t v143 = 0;
  v144[0] = 0;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v150 = 0u;
  v151 = 0;
  v144[1] = 0;
  v145 = 0;
  if (!a1) {
    goto LABEL_172;
  }
  CFTypeID v13 = CFGetTypeID((CFTypeRef)a1);
  if (v13 != CFDataGetTypeID() || CFDataGetLength((CFDataRef)a1) < 1)
  {
    a1 = 0;
LABEL_172:
    CFDataRef v59 = 0;
    uint64_t v60 = 0;
    CFMutableArrayRef Mutable = 0;
LABEL_181:
    uint64_t v61 = 0;
    goto LABEL_157;
  }
  if (*CFDataGetBytePtr((CFDataRef)a1) != 255) {
    goto LABEL_5;
  }
  uint64_t v152 = 0;
  v153 = &v152;
  uint64_t v154 = 0x2020000000;
  uint64_t v155 = 0;
  uint64_t Empty = __PCSShareProtectionCreateEmpty(a8);
  v153[3] = (uint64_t)Empty;
  if (!Empty || CFDataGetLength((CFDataRef)a1) < 4 || (BytePtr = CFDataGetBytePtr((CFDataRef)a1), *BytePtr != 255))
  {
LABEL_187:
    CFDictionaryRef v22 = 0;
    uint64_t v61 = 0;
    goto LABEL_108;
  }
  if (!a2)
  {
    CFIndex Length = CFDataGetLength((CFDataRef)a1);
    CFIndex v82 = CFDataGetBytePtr((CFDataRef)a1);
    CFDataRef v83 = CFDataCreate(0, &v82[Length - 2], 2);
    v84 = v153;
    *(void *)(v153[3] + 80) = v83;
    uint64_t v23 = v84[3];
    if (*(void *)(v23 + 80))
    {
      CFDictionaryRef v22 = 0;
      goto LABEL_107;
    }
    _PCSErrorOOM(a8);
    goto LABEL_187;
  }
  CFDictionaryRef v22 = (const __CFDictionary *)PCSIdentitySetCopyIdentities(a2, 0);
  *(void *)&long long context = MEMORY[0x1E4F143A8];
  *((void *)&context + 1) = 3221225472;
  *(void *)&long long v135 = __CreateLightObject_block_invoke;
  *((void *)&v135 + 1) = &unk_1E5E6E350;
  *(void *)&long long v136 = &v152;
  *((void *)&v136 + 1) = a1;
  *(void *)&long long v137 = BytePtr;
  CFDictionaryApplyFunction(v22, (CFDictionaryApplierFunction)apply_block_2_1, &context);
  uint64_t v23 = v153[3];
  if (*(void *)(v23 + 72))
  {
    *(unsigned char *)(v23 + 20_Block_object_dispose(&a9, 8) = 1;
LABEL_107:
    *(_DWORD *)(v23 + 204) = 0;
    uint64_t v61 = CFRetain((CFTypeRef)v23);
    goto LABEL_108;
  }
  noMatchingIdentity(a2, 0, a8);
  uint64_t v61 = 0;
LABEL_108:
  v85 = (const void *)v153[3];
  if (v85)
  {
    v153[3] = 0;
    CFRelease(v85);
  }
  if (v22) {
    CFRelease(v22);
  }
  _Block_object_dispose(&v152, 8);
  if (v61) {
    goto LABEL_165;
  }
LABEL_5:
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (!Mutable)
  {
    _PCSErrorOOM(a8);
LABEL_179:
    a1 = 0;
    goto LABEL_180;
  }
  int v15 = CFDataGetBytePtr((CFDataRef)a1);
  CFIndex v16 = CFDataGetLength((CFDataRef)a1);
  uint64_t v17 = decode_PCSShareProtection((uint64_t)v15, v16, (uint64_t)&v146, (uint64_t)&v143);
  if (v17)
  {
    _PCSErrorASN1(a8, (uint64_t)"decode PCSShareProtection", v17);
    goto LABEL_179;
  }
  int v18 = __PCSShareProtectionCreateEmpty(0);
  a1 = (uint64_t)v18;
  if (!v18) {
    goto LABEL_180;
  }
  CFArrayRef theArray = Mutable;
  if (*((void *)&v148 + 1))
  {
    if (**((_DWORD **)&v148 + 1) == 4)
    {
      int v19 = 3;
    }
    else
    {
      if (**((_DWORD **)&v148 + 1) != 5) {
        goto LABEL_21;
      }
      int v19 = 2;
    }
  }
  else
  {
    int v19 = 1;
  }
  *((_DWORD *)v18 + 51) = v19;
LABEL_21:
  char v126 = a5;
  long long v127 = a3;
  if (DWORD2(v146))
  {
    uint64_t v24 = 0;
    unint64_t v25 = 0;
    CFAllocatorRef bytesDeallocator = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
    do
    {
      uint64_t v26 = v147;
      uint64_t v27 = (_DWORD *)(v147 + v24);
      uint64_t v28 = *(int **)(v147 + v24 + 48);
      if (v28) {
        int v29 = *v28;
      }
      else {
        int v29 = 0;
      }
      CFTypeRef v30 = _PCSPublicIdentityCreateWithPCSSPKey((unsigned int *)(v147 + v24), a8);
      *(void *)&long long context = 0;
      *((void *)&context + 1) = &context;
      long long v135 = 0x2020000000uLL;
      uint64_t v152 = 0;
      v153 = &v152;
      uint64_t v154 = 0x2020000000;
      uint64_t v155 = 0;
      if (!v30) {
        goto LABEL_168;
      }
      int v31 = v30;
      CFArrayAppendValue(theArray, v30);
      uint64_t v32 = (const void *)ShareEntryCreate(v31, v29);
      uint64_t PublicID = (const void *)PCSPublicIdentityGetPublicID((uint64_t)v31);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), PublicID, v32);
      if (v32) {
        CFRelease(v32);
      }
      if (a2 && !*(void *)(a1 + 72))
      {
        if ((*v27 - 7) < 2
          || (_PCSPublicIdentityIsDiversified((uint64_t)v31) | ((v29 & 4) >> 2)) == 1)
        {
          CFDictionaryRef v40 = (const __CFDictionary *)PCSIdentitySetCopyIdentities(a2, 0);
          CFDictionaryRef v41 = v40;
          if (!v40)
          {
            _PCSError(a8, 27, @"diversified keys needs a non empty set");
LABEL_168:
            _Block_object_dispose(&v152, 8);
            _Block_object_dispose(&context, 8);
LABEL_71:
            CFDataRef v59 = 0;
            uint64_t v60 = 0;
            goto LABEL_72;
          }
          v141[0] = MEMORY[0x1E4F143A8];
          v141[1] = 3221225472;
          v141[2] = __CreateWithExportedInternal_block_invoke;
          v141[3] = &unk_1E5E6E328;
          v141[4] = &context;
          v141[5] = &v152;
          v141[6] = v26 + v24;
          int v142 = v29;
          v141[7] = a1;
          v141[8] = PublicID;
          CFDictionaryApplyFunction(v40, (CFDictionaryApplierFunction)apply_block_2_1, v141);
          CFRelease(v41);
        }
        else
        {
          uint64_t v55 = PCSIdentitySetCopyIdentity(a2, (uint64_t)PublicID);
          v153[3] = v55;
          if (v55)
          {
            CFDataRef v56 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(v26 + v24 + 40), *(void *)(v26 + v24 + 32), bytesDeallocator);
            uint64_t v57 = _PCSIdentityCopyUnwappedKey(v153[3], v56, a8);
            *(void *)(*((void *)&context + 1) + 24) = v57;
            if (v56) {
              CFRelease(v56);
            }
          }
          else if (v130)
          {
            [v130 addObject:PublicID];
          }
        }
      }
      CFDataRef v42 = *(const __CFData **)(*((void *)&context + 1) + 24);
      if (v42)
      {
        int v43 = *(_DWORD *)(a1 + 204);
        if (v43 != 3 || (v29 & 1) != 0)
        {
          if (v43 == 3)
          {
            *(unsigned char *)(a1 + 209) = 1;
            *(void *)(a1 + 72) = v42;
          }
          else
          {
            *(void *)(a1 + 72) = v42;
            generateObjectKey((void *)a1, v42, 0);
          }
        }
        else
        {
          generateOtherKeysFromRWMasterKey(a1, v42, v34, v35, v36, v37, v38, v39);
          CFRelease(*(CFTypeRef *)(*((void *)&context + 1) + 24));
        }
        uint64_t v44 = *(const void **)(a1 + 176);
        if (v44)
        {
          *(void *)(a1 + 176) = 0;
          CFRelease(v44);
        }
        *(void *)(a1 + 176) = CFRetain((CFTypeRef)v153[3]);
        uint64_t v45 = *(const void **)(a1 + 184);
        if (v45)
        {
          *(void *)(a1 + 184) = 0;
          CFRelease(v45);
        }
        uint64_t SigningIdentity = (const void *)_PCSIdentityGetSigningIdentity(v153[3]);
        uint64_t v47 = SigningIdentity;
        if (SigningIdentity) {
          CFRetain(SigningIdentity);
        }
        *(void *)(a1 + 184) = v47;
        uint64_t v48 = *(const void **)(a1 + 144);
        if (v48)
        {
          *(void *)(a1 + 144) = 0;
          CFRelease(v48);
        }
        uint64_t v49 = PCSIdentityCopyPublicIdentity(v153[3]);
        *(void *)(a1 + 144) = v49;
        if (!v49)
        {
          _PCSErrorOOM(a8);
          goto LABEL_168;
        }
        int ServiceID = a4;
        if (!a4) {
          int ServiceID = PCSIdentityGetServiceID(*(void *)(a1 + 176));
        }
        *(_DWORD *)(a1 + 200) = ServiceID;
        uint64_t ServiceName = PCSIdentityGetServiceName(v153[3]);
        uint64_t v52 = _PCSIdentitySetCopyCurrentIdentityInternal(a2, ServiceName, 0);
        uint64_t v53 = v52;
        if (v52)
        {
          if (!CFEqual(v52, (CFTypeRef)v153[3]))
          {
            *(unsigned char *)(a1 + 211) = 1;
            PCSIdentitySetRepairCurrentIdentity(a2, ServiceName, (uint64_t)v53, 0);
          }
          CFRelease(v53);
        }
        if ((v29 & 2) != 0) {
          *(unsigned char *)(a1 + 213) = 1;
        }
      }
      CFDataRef v54 = (const void *)v153[3];
      if (v54)
      {
        v153[3] = 0;
        CFRelease(v54);
      }
      CFRelease(v31);
      _Block_object_dispose(&v152, 8);
      _Block_object_dispose(&context, 8);
      ++v25;
      v24 += 56;
    }
    while (v25 < DWORD2(v146));
  }
  uint64_t v58 = *(void *)(a1 + 72);
  if (a2 && !v58)
  {
    noMatchingIdentity(a2, a1, a8);
    goto LABEL_71;
  }
  CFMutableArrayRef Mutable = theArray;
  if (!v58)
  {
    if (!(void)v150
      || (CFDataRef v65 = CFDataCreate(0, *(const UInt8 **)(v150 + 8), *(void *)v150), (*(void *)(a1 + 80) = v65) != 0))
    {
      if (*((void *)&v148 + 1))
      {
        long long v139 = 0u;
        long long v140 = 0u;
        long long v137 = 0u;
        long long v138 = 0u;
        long long v135 = 0u;
        long long v136 = 0u;
        long long context = 0u;
        uint64_t v66 = decode_PCSObjectSignature(*(void *)(*((void *)&v148 + 1) + 24), *(void *)(*((void *)&v148 + 1) + 16), (uint64_t)&context, 0);
        if (v66)
        {
          _PCSErrorASN1(a8, (uint64_t)"decode PCSObjectSignature", v66);
          goto LABEL_71;
        }
        *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
        CFIndex v67 = (unsigned int *)v140;
        if ((void)v140)
        {
          uint64_t v68 = 0;
          uint64_t v69 = -1;
          do
          {
            if (++v69 >= (unint64_t)*v67) {
              break;
            }
            uint64_t v70 = *((void *)v67 + 1);
            if (*(_DWORD *)(v70 + v68) != 3) {
              goto LABEL_71;
            }
            CFDataRef v71 = CFDataCreate(0, *(const UInt8 **)(v70 + v68 + 24), *(void *)(v70 + v68 + 16));
            if (!v71) {
              goto LABEL_175;
            }
            CFDataRef v72 = v71;
            v73 = PCSPublicIdentityCreateFromKeyData(v71, a8);
            CFRelease(v72);
            if (!v73) {
              goto LABEL_176;
            }
            v68 += 32;
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v73);
            CFRelease(v73);
            CFIndex v67 = (unsigned int *)v140;
          }
          while ((void)v140);
        }
        if (*((void *)&v140 + 1))
        {
          if (copy_PCSAttributes())
          {
LABEL_175:
            _PCSErrorOOM(a8);
LABEL_176:
            free_PCSObjectSignature((uint64_t)&context);
            goto LABEL_71;
          }
          uint64_t v74 = *((void *)&v140 + 1);
          unint64_t v75 = **((_DWORD **)&v140 + 1);
          if (v75)
          {
            for (unint64_t i = 0; i < v75; ++i)
            {
              uint64_t v77 = *(void *)(v74 + 8);
              if (*(_DWORD *)(v77 + 24 * i) == 5)
              {
                uint64_t v152 = 0;
                v153 = 0;
                if (decode_PCSMasterKeyIDs(*(void *)(v77 + 24 * i + 16), *(void *)(v77 + 24 * i + 8), (uint64_t)&v152, 0))goto LABEL_175; {
                if (v152)
                }
                {
                  uint64_t v78 = 0;
                  unint64_t v79 = 0;
                  do
                  {
                    CFDataRef v80 = CFDataCreate(0, (const UInt8 *)v153[v78 + 1], v153[v78]);
                    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 112), v80, v80);
                    if (v80) {
                      CFRelease(v80);
                    }
                    ++v79;
                    v78 += 2;
                  }
                  while (v79 < v152);
                }
                free_PCSMasterKeyIDs((uint64_t)&v152);
                uint64_t v74 = *((void *)&v140 + 1);
                unint64_t v75 = **((_DWORD **)&v140 + 1);
              }
            }
          }
        }
        free_PCSObjectSignature((uint64_t)&context);
      }
      CFDataRef v59 = 0;
      uint64_t v60 = 0;
      goto LABEL_138;
    }
    _PCSErrorOOM(a8);
    goto LABEL_180;
  }
  *(void *)&long long context = 0;
  CFIndex v62 = length_PCSSignedShareProtection((uint64_t)&v146);
  uint64_t v63 = CFDataCreateMutable(0, v62);
  if (!v63)
  {
LABEL_180:
    CFDataRef v59 = 0;
    uint64_t v60 = 0;
    goto LABEL_181;
  }
  uint64_t v60 = v63;
  CFDataSetLength(v63, v62);
  int MutableBytePtr = CFDataGetMutableBytePtr(v60);
  if (encode_PCSSignedShareProtection((uint64_t)&MutableBytePtr[v62 - 1], v62, (uint64_t)&v146, (uint64_t)&context))
  {
    CFRelease(v60);
    goto LABEL_180;
  }
  if (v62 != (void)context)
  {
    v124 = (_Unwind_Exception *)asn1_abort();
    _Block_object_dispose(&v152, 8);
    _Block_object_dispose(&context, 8);
    _Unwind_Resume(v124);
  }
  if ((void)v148) {
    CFDataRef v59 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(v148 + 8), *(void *)v148, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  }
  else {
    CFDataRef v59 = 0;
  }
  KeyIDFromuint64_t Key = CreateKeyIDFromKey(*(const __CFData **)(a1 + 72));
  *(void *)(a1 + 80) = KeyIDFromKey;
  if (!KeyIDFromKey) {
    goto LABEL_72;
  }
  if ((void)v148)
  {
    v87 = PCSFPCopyDecryptedData(a1, 0, 0, v59, a8);
    if (!v87) {
      goto LABEL_72;
    }
    CFDataRef v88 = v87;
    CFIndex v89 = CFDataGetBytePtr(v87);
    CFIndex v90 = CFDataGetLength(v88);
    uint64_t v91 = decode_PCSEncryptedKeys((uint64_t)v89, v90, (uint64_t)v144, (uint64_t)&v143);
    CFRelease(v88);
    if (v91)
    {
      _PCSErrorASN1(a8, (uint64_t)"decode PCSEncryptedKeys", v91);
      goto LABEL_72;
    }
    v92 = v145;
    if (v145 && *v145)
    {
      uint64_t v93 = 0;
      unint64_t v94 = 0;
      CFAllocatorRef v95 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
      do
      {
        CFDataRef v96 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(*((void *)v92 + 1) + v93 + 24), *(void *)(*((void *)v92 + 1) + v93 + 16), v95);
        v97 = PCSIdentityCreateFromData(v96, 0);
        if (v96) {
          CFRelease(v96);
        }
        if (!v97) {
          goto LABEL_72;
        }
        PCSIdentitySetAddIdentity(*(void *)(a1 + 16), (uint64_t)v97);
        CFRelease(v97);
        ++v94;
        v92 = v145;
        v93 += 32;
      }
      while (v94 < *v145);
    }
    uint64_t v98 = v144[0];
    if (v144[0] && *(_DWORD *)v144[0])
    {
      uint64_t v99 = 0;
      unint64_t v100 = 0;
      do
      {
        CFDataRef v101 = CFDataCreate(0, *(const UInt8 **)(*(void *)(v98 + 8) + v99 + 8), *(void *)(*(void *)(v98 + 8) + v99));
        v102 = CreateKeyIDFromKey(v101);
        if (!v102)
        {
          if (v101) {
            CFRelease(v101);
          }
          goto LABEL_72;
        }
        v103 = v102;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 112), v102, v101);
        CFRelease(v103);
        if (v101) {
          CFRelease(v101);
        }
        ++v100;
        uint64_t v98 = v144[0];
        v99 += 16;
      }
      while (v100 < *(unsigned int *)v144[0]);
    }
  }
  if ((*(_DWORD *)(a1 + 204) & 0xFFFFFFFE) == 2) {
    uint64_t v104 = (uint64_t *)(*((void *)&v148 + 1) + 16);
  }
  else {
    uint64_t v104 = 0;
  }
  CFMutableArrayRef Mutable = theArray;
  if (!ValidateSignature(a1, v60, v59, &v149, v104, theArray, *((CFIndex *)&v150 + 1), *((unsigned int **)&v147 + 1), v151, v126 ^ 1u, v127, v129, a8))goto LABEL_181; {
  *(unsigned char *)(a1 + 20_Block_object_dispose(&a9, 8) = 1;
  }
LABEL_138:
  unint64_t v105 = *(unsigned int *)(a1 + 128);
  if (!v105)
  {
LABEL_156:
    uint64_t v61 = CFRetain((CFTypeRef)a1);
    CFMutableArrayRef Mutable = theArray;
    if (v61[54] != 1192348414) {
      PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(spret)->alive == pcsfpTruelyAlive", v116, v117, v118, v119, v120, v121, v122, v125);
    }
    goto LABEL_157;
  }
  uint64_t v106 = 0;
  unint64_t v107 = 0;
  while (1)
  {
    uint64_t v108 = *(void *)(a1 + 136);
    if (*(_DWORD *)(v108 + v106) != 4) {
      goto LABEL_155;
    }
    uint64_t v109 = v108 + v106;
    long long context = 0u;
    long long v135 = 0u;
    uint64_t v152 = 0;
    uint64_t v110 = decode_PCSObjectChaining(*(void *)(v108 + v106 + 16), *(void *)(v108 + v106 + 8), (uint64_t)&context, (uint64_t)&v152);
    if (v110) {
      break;
    }
    if (v152 != *(void *)(v109 + 8)) {
      abort();
    }
    if ((void)v135 && *(void *)v135)
    {
      uint64_t v111 = *(_DWORD *)(a1 + 204) <= 2u ? 72 : 64;
      CFDataRef v112 = *(const __CFData **)(a1 + v111);
      if (v112)
      {
        CFTypeRef v113 = ProcessChainKeys(v112, v135, a8);
        *(void *)(a1 + 24) = v113;
        if (!v113) {
          goto LABEL_170;
        }
      }
    }
    if (*((void *)&v135 + 1))
    {
      if (**((void **)&v135 + 1))
      {
        CFDataRef v114 = *(const __CFData **)(a1 + 72);
        if (v114)
        {
          CFTypeRef v115 = ProcessChainKeys(v114, *((uint64_t *)&v135 + 1), a8);
          *(void *)(a1 + 32) = v115;
          if (!v115) {
            goto LABEL_170;
          }
        }
      }
    }
    free_PCSObjectChaining((uint64_t)&context);
    unint64_t v105 = *(unsigned int *)(a1 + 128);
LABEL_155:
    ++v107;
    v106 += 24;
    if (v107 >= v105) {
      goto LABEL_156;
    }
  }
  _PCSErrorASN1(a8, (uint64_t)"decode PCSObjectChaining", v110);
LABEL_170:
  free_PCSObjectChaining((uint64_t)&context);
LABEL_72:
  uint64_t v61 = 0;
  CFMutableArrayRef Mutable = theArray;
LABEL_157:
  free_PCSEncryptedKeys((uint64_t)v144);
  free_PCSShareProtection((uint64_t)&v146);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v60) {
    CFRelease(v60);
  }
  if (v59) {
    CFRelease(v59);
  }
  if (a1) {
    CFRelease((CFTypeRef)a1);
  }
LABEL_165:

  return v61;
}

_DWORD *PCSFPCopyRecoverPCS(uint64_t a1, const void **a2)
{
  return CreateWithExportedInternal(a1, 0, 0, 0, 0, 0, 0, a2);
}

_DWORD *PCSObjectCreateFromExportedWithIdentities(uint64_t a1, uint64_t a2, const void **a3)
{
  return PCSObjectCreateFromExportedWithIdentitiesAndOptions(a1, a2, a2, a3);
}

_DWORD *PCSObjectCreateFromExportedWithIdentitiesAndOptions(uint64_t a1, int a2, uint64_t a3, const void **a4)
{
  if (a1)
  {
    return CreateWithExportedInternal(a3, a1, 0, 0, 0, 0, 0, a4);
  }
  else
  {
    _PCSError(a4, 27, @"PCSFPCreateWithExported need an identity", v4, v5);
    return 0;
  }
}

void PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync(const void *a1, void *a2, const void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  if (a1 && a3)
  {
    if (PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_once != -1) {
      dispatch_once(&PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_once, &__block_literal_global_5);
    }
    CFRetain(a1);
    CFRetain(a3);
    uint64_t v9 = PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_queue;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_2;
    block[3] = &unk_1E5E6E250;
    int v15 = a1;
    CFIndex v16 = a3;
    id v13 = v7;
    id v14 = v8;
    dispatch_block_t v10 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, block);
    dispatch_async(v9, v10);
  }
  else
  {
    uint64_t v17 = 0;
    _PCSError(&v17, 27, @"identities and data required");
    (*((void (**)(id, void, const void *))v8 + 2))(v8, 0, v17);
    uint64_t v11 = v17;
    if (v17)
    {
      uint64_t v17 = 0;
      CFRelease(v11);
    }
  }
}

void __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke()
{
  uint64_t v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v0 = dispatch_queue_create("PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync", v2);
  uint64_t v1 = (void *)PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_queue;
  PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_queue = (uint64_t)v0;
}

void __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_2(uint64_t a1)
{
  CFIndex v16 = 0;
  uint64_t v2 = (void *)PCSIdentitySetCopyService(*(void *)(a1 + 48));
  id v3 = objc_alloc_init(MEMORY[0x1E4F1CA80]);
  uint64_t v4 = CreateWithExportedInternal(*(void *)(a1 + 56), *(void *)(a1 + 48), 0, 0, 0, 0, v3, &v16);
  if (!v4)
  {
    if ([v3 count]) {
      BOOL v6 = v2 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6)
    {
      id v7 = *(id *)(a1 + 32);
      if (_os_feature_enabled_impl())
      {
        id v8 = [v7 objectForKeyedSubscript:kPCSFPAllowFetch];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          int v9 = [v8 BOOLValue];

          if (v9)
          {
            unsigned __int8 v10 = atomic_load(initialSyncComplete);
            if ((v10 & 1) == 0)
            {
              v12[0] = MEMORY[0x1E4F143A8];
              v12[1] = 3221225472;
              v12[2] = __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_3;
              v12[3] = &unk_1E5E6E228;
              id v13 = *(id *)(a1 + 40);
              id v14 = v16;
              long long v15 = *(_OWORD *)(a1 + 48);
              _PCSCKKSOutOfBandFetchIdentities(v3, v2, 0, v12);

              goto LABEL_18;
            }
          }
          goto LABEL_14;
        }
      }
    }
LABEL_14:
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_15;
  }
  uint64_t v5 = v4;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  CFRelease(v5);
LABEL_15:
  uint64_t v11 = v16;
  if (v16)
  {
    CFIndex v16 = 0;
    CFRelease(v11);
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
  CFRelease(*(CFTypeRef *)(a1 + 56));
LABEL_18:
}

void __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a2 || a3)
  {
    if (a3)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_3_cold_2((uint64_t)a3);
      }
      id v7 = a3;
      id v8 = [v7 domain];
      if ([v8 isEqualToString:@"CKKSErrorDomain"])
      {
        uint64_t v9 = [v7 code];
        uint64_t v10 = kPCSCKKSErrorOutOfBandFetchingDisallowed;

        if (v9 == v10)
        {
          atomic_store(1u, initialSyncComplete);
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
            __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_3_cold_1();
          }
        }
      }
      else
      {
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    CFTypeRef cf = 0;
    uint64_t v5 = CreateWithExportedInternal(*(void *)(a1 + 56), a2, 0, 0, 0, 0, 0, &cf);
    if (v5)
    {
      BOOL v6 = v5;
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
      CFRelease(v6);
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_3_cold_3((uint64_t *)&cf);
      }
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    }
    CFTypeRef v11 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v11);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 48));
  CFRelease(*(CFTypeRef *)(a1 + 56));
}

_DWORD *PCSObjectCreateFromExportedWithKeyedPCS(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    return CreateWithExportedInternal(a2, v3, *(void **)(a1 + 168), *(_DWORD *)(a1 + 200), 0, 0, 0, a3);
  }
  else {
    return 0;
  }
}

_DWORD *PCSObjectCreateFromExportedWithKeyedPCSAndOptions(uint64_t a1, uint64_t a2, uint64_t a3, const void **a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    return CreateWithExportedInternal(a3, v4, *(void **)(a1 + 168), *(_DWORD *)(a1 + 200), 0, 0, 0, a4);
  }
  else {
    return 0;
  }
}

_DWORD *PCSObjectCreateFromExportedWithKeyedPCSAndOptionsWithTrusts(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, const void **a5)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (v5) {
    return CreateWithExportedInternal(a3, v5, *(void **)(a1 + 168), *(_DWORD *)(a1 + 200), 0, a4, 0, a5);
  }
  else {
    return 0;
  }
}

CFMutableArrayRef PCSFPCopyKeyIDs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v12);
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  uint64_t v10 = *(void *)(a1 + 16);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  void v13[2] = __PCSFPCopyKeyIDs_block_invoke;
  v13[3] = &__block_descriptor_40_e21_v16__0____CFString__8l;
  v13[4] = Mutable;
  PCSIdentitySetEnumeratePublicKeys(v10, v13);
  return Mutable;
}

void __PCSFPCopyKeyIDs_block_invoke(uint64_t a1, const void *a2)
{
}

uint64_t PCSFPCopyPublicIdentities(uint64_t a1)
{
  uint64_t v14 = 0;
  long long v15 = &v14;
  uint64_t v16 = 0x2020000000;
  CFMutableArrayRef Mutable = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", v2, v3, v4, v5, v6, v7, v8, v12);
  }
  CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 40);
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = __PCSFPCopyPublicIdentities_block_invoke;
  context[3] = &unk_1E5E6DFD0;
  context[4] = &v14;
  CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)apply_block_2_1, context);
  uint64_t v10 = v15[3];
  _Block_object_dispose(&v14, 8);
  return v10;
}

void sub_1ACFB6824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __PCSFPCopyPublicIdentities_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void _PCSFPEnumeratePublicIdentities(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", v4, v5, v6, v7, v8, v9, v10, v13);
  }
  CFDictionaryRef v11 = *(const __CFDictionary **)(a1 + 40);
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = ___PCSFPEnumeratePublicIdentities_block_invoke;
  context[3] = &unk_1E5E6E298;
  id v15 = v3;
  id v12 = v3;
  CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)apply_block_2_1, context);
}

uint64_t PCSFPAddPublicIdentityWithShareFlags(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v16);
  }
  if (!a2) {
    return 0;
  }
  int v9 = a3;
  int v11 = *(_DWORD *)(a1 + 204);
  if (v11)
  {
    if (v11 == 3 && *(unsigned char *)(a1 + 209)) {
      return 0;
    }
  }
  else if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40)) > 0)
  {
    return 0;
  }
  uint64_t result = ShareEntryCreate(a2, v9);
  if (result)
  {
    char v13 = (const void *)result;
    uint64_t v14 = *(__CFDictionary **)(a1 + 40);
    uint64_t PublicID = (const void *)PCSPublicIdentityGetPublicID((uint64_t)a2);
    CFDictionarySetValue(v14, PublicID, v13);
    CFRelease(v13);
    return 1;
  }
  return result;
}

uint64_t ShareEntryCreate(const void *a1, int a2)
{
  ShareEntryGetTypeID();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(void *)(Instance + 16) = CFRetain(a1);
    *(_DWORD *)(Instance + 24) = a2;
  }
  return Instance;
}

BOOL PCSFPAddCurrentIdentity(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v21);
  }
  int v8 = a4;
  int v12 = *(_DWORD *)(a1 + 204);
  if (v12)
  {
    if (v12 == 3 && *(unsigned char *)(a1 + 209)) {
      return 0;
    }
  }
  else if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40)) > 0)
  {
    return 0;
  }
  char v13 = PCSIdentitySetCopyCurrentPublicIdentityWithError(a2, a3, 0);
  if (!v13) {
    return 0;
  }
  uint64_t v14 = v13;
  uint64_t v15 = ShareEntryCreate(v13, v8);
  BOOL v16 = v15 != 0;
  if (v15)
  {
    uint64_t v17 = (const void *)v15;
    int v18 = *(__CFDictionary **)(a1 + 40);
    uint64_t PublicID = (const void *)PCSPublicIdentityGetPublicID((uint64_t)v14);
    CFDictionarySetValue(v18, PublicID, v17);
    CFRelease(v17);
  }
  CFRelease(v14);
  return v16;
}

uint64_t PCSFPAddEncryptedSharePCS(uint64_t a1, CFDataRef theData, uint64_t a3, const void **a4)
{
  uint64_t v31 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  memset(v27, 0, sizeof(v27));
  uint64_t v26 = 0;
  memset(v32, 0, sizeof(v32));
  long long v33 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v10 = decode_PCSShareProtection((uint64_t)BytePtr, Length, (uint64_t)v27, (uint64_t)&v26);
  if (v10)
  {
    uint64_t v24 = v10;
    unint64_t v25 = "decode PCSShareProtection";
LABEL_18:
    _PCSErrorASN1(a4, (uint64_t)v25, v24);
LABEL_19:
    char v21 = 0;
    CFDataRef v15 = 0;
    goto LABEL_20;
  }
  CFIndex v11 = CFDataGetLength(theData);
  if (v11 != v26 || !*((void *)&v28 + 1)) {
    goto LABEL_19;
  }
  uint64_t v12 = decode_PCSObjectSignature(*(void *)(*((void *)&v28 + 1) + 24), *(void *)(*((void *)&v28 + 1) + 16), (uint64_t)v32, 0);
  if (v12)
  {
    uint64_t v24 = v12;
    unint64_t v25 = "decode PCSObjectSignature";
    goto LABEL_18;
  }
  if (!(void)v33) {
    goto LABEL_19;
  }
  if (!*(_DWORD *)v33) {
    goto LABEL_19;
  }
  uint64_t v13 = *(void *)(v33 + 8);
  if (*(_DWORD *)v13 != 3) {
    goto LABEL_19;
  }
  CFDataRef v14 = CFDataCreate(0, *(const UInt8 **)(v13 + 24), *(void *)(v13 + 16));
  CFDataRef v15 = v14;
  if (v14)
  {
    char v21 = PCSPublicIdentityCreateFromKeyData(v14, a4);
    if (v21)
    {
      uint64_t v22 = PCSFPAddPublicIdentityWithShareFlags(a1, v21, a3, v16, v17, v18, v19, v20);
      goto LABEL_11;
    }
  }
  else
  {
    _PCSErrorOOM(a4);
    char v21 = 0;
  }
LABEL_20:
  uint64_t v22 = 0;
LABEL_11:
  free_PCSShareProtection((uint64_t)v27);
  free_PCSObjectSignature((uint64_t)v32);
  if (v15) {
    CFRelease(v15);
  }
  if (v21) {
    CFRelease(v21);
  }
  return v22;
}

uint64_t PCSFPAddPublicIdentity(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return PCSFPAddPublicIdentityWithShareFlags(a1, a2, 0, a4, a5, a6, a7, a8);
}

uint64_t PCSFPRemovePublicIdentity(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 204) == 3 && *(unsigned char *)(a1 + 209)) {
    return 0;
  }
  id v3 = *(__CFDictionary **)(a1 + 40);
  uint64_t PublicID = (const void *)PCSPublicIdentityGetPublicID(a2);
  CFDictionaryRemoveValue(v3, PublicID);
  return 1;
}

uint64_t PCSFPAddSharePCSWithFlags(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v21);
  }
  if (!*(void *)(a1 + 72) || *(_DWORD *)(a1 + 204) == 3 && *(unsigned char *)(a1 + 209)) {
    return 0;
  }
  CFIndex v11 = PCSIdentitySetCopyCurrentIdentityWithError(*(void *)(a2 + 16), kPCSServiceRaw, 0);
  if (!v11) {
    return 0;
  }
  uint64_t v12 = v11;
  uint64_t v13 = PCSIdentityCopyPublicIdentity((uint64_t)v11);
  if (v13)
  {
    uint64_t v19 = v13;
    uint64_t v10 = PCSFPAddPublicIdentityWithShareFlags(a1, v13, a3, v14, v15, v16, v17, v18);
    CFRelease(v12);
    uint64_t v12 = v19;
  }
  else
  {
    uint64_t v10 = 0;
  }
  CFRelease(v12);
  return v10;
}

uint64_t PCSFPAddSharePCS(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return PCSFPAddSharePCSWithFlags(a1, a2, 0, a4, a5, a6, a7, a8);
}

uint64_t PCSFPRemoveSharePCS(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v11);
  }
  if (!*(void *)(a1 + 72) || *(_DWORD *)(a1 + 204) == 3 && *(unsigned char *)(a1 + 209)) {
    return 0;
  }
  uint64_t result = PCSIdentitySetCopyIdentities(*(void *)(a2 + 16), 0);
  if (result)
  {
    uint64_t v10 = (const void *)result;
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __PCSFPRemoveSharePCS_block_invoke;
    context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    void context[4] = a1;
    CFDictionaryApplyFunction((CFDictionaryRef)result, (CFDictionaryApplierFunction)apply_block_2_1, context);
    CFRelease(v10);
    return 1;
  }
  return result;
}

void __PCSFPRemoveSharePCS_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (!cf || (CFTypeID v4 = CFGetTypeID(cf), v4 != CFStringGetTypeID())) {
    abort();
  }
  uint64_t v5 = *(__CFDictionary **)(*(void *)(a1 + 32) + 40);
  CFDictionaryRemoveValue(v5, cf);
}

void *PCSFPCreatePrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v12);
  }
  if (!*(void *)(a1 + 72) || !*(void *)(a1 + 16)) {
    return 0;
  }
  RandomCompactRaw = PCSIdentityCreateRandomCompactRaw(0);
  if (RandomCompactRaw)
  {
    if (!PCSIdentitySetSetCurrentIdentity(*(void *)(a1 + 16), (uint64_t)RandomCompactRaw))
    {
      uint64_t v10 = RandomCompactRaw;
      RandomCompactRaw = 0;
      goto LABEL_8;
    }
    uint64_t v10 = *(const void **)(a1 + 48);
    if (v10)
    {
      *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
LABEL_8:
      CFRelease(v10);
    }
  }
  return RandomCompactRaw;
}

uint64_t PCSFPAddPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v13);
  }
  if (!*(void *)(a1 + 72)) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (!v9) {
    return 0;
  }
  char v11 = *(const void **)(a1 + 48);
  if (v11)
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    CFRelease(v11);
    uint64_t v9 = *(void *)(a1 + 16);
  }
  return PCSIdentitySetAddIdentity(v9, a2);
}

uint64_t PCSFPSetCurrentPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v13);
  }
  if (!*(void *)(a1 + 72)) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (!v9) {
    return 0;
  }
  char v11 = *(const void **)(a1 + 48);
  if (v11)
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    CFRelease(v11);
    uint64_t v9 = *(void *)(a1 + 16);
  }
  return PCSIdentitySetSetCurrentIdentity(v9, a2);
}

uint64_t PCSFPCopyPrivateKey(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && (uint64_t v2 = *(void *)(a1 + 16)) != 0) {
    return PCSIdentitySetCopyIdentity(v2, a2);
  }
  else {
    return 0;
  }
}

uint64_t PCSFPRemovePrivateKey(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  if (!a2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = *(const void **)(a1 + 48);
  if (v5)
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    CFRelease(v5);
    uint64_t v4 = *(void *)(a1 + 16);
  }
  return PCSIdentitySetRemoveIdentity(v4, a2);
}

uint64_t PCSFPGetChainingKeyset(uint64_t a1, int a2)
{
  uint64_t v2 = 32;
  if (a2) {
    uint64_t v2 = 24;
  }
  return *(void *)(a1 + v2);
}

const void *PCSFPChainingCreateIdentity(uint64_t a1, int a2, const void **a3)
{
  uint64_t v6 = 32;
  if (a2) {
    uint64_t v6 = 24;
  }
  uint64_t v7 = *(void *)(a1 + v6);
  if (!v7 || (RandomCompactRaw = PCSIdentitySetCopyCurrentIdentityWithError(v7, kPCSServiceRaw, 0)) == 0)
  {
    RandomCompactRaw = PCSIdentityCreateRandomCompactRaw(a3);
    if (RandomCompactRaw && (PCSFPChainingSetCurrentIdentity(a1, a2, (uint64_t)RandomCompactRaw, a3) & 1) == 0)
    {
      CFRelease(RandomCompactRaw);
      return 0;
    }
  }
  return RandomCompactRaw;
}

const void *PCSFPChainingCopyCurrentIdentity(uint64_t a1, int a2)
{
  uint64_t v2 = 32;
  if (a2) {
    uint64_t v2 = 24;
  }
  uint64_t result = *(const void **)(a1 + v2);
  if (result) {
    return PCSIdentitySetCopyCurrentIdentityWithError((uint64_t)result, kPCSServiceRaw, 0);
  }
  return result;
}

uint64_t PCSFPChainingSetCurrentIdentity(uint64_t a1, int a2, uint64_t a3, const void **a4)
{
  CFTypeRef v7 = PCSFPGetChainingSet(a1, a2);
  if (!v7 || !PCSIdentitySetSetCurrentIdentity((uint64_t)v7, a3)) {
    return 0;
  }
  return regenFPChainingAttribute(a1, a4);
}

uint64_t PCSFPChainingAddIdentity(uint64_t a1, int a2, uint64_t a3, const void **a4)
{
  CFTypeRef v7 = PCSFPGetChainingSet(a1, a2);
  if (v7 && PCSIdentitySetAddIdentity((uint64_t)v7, a3)) {
    regenFPChainingAttribute(a1, a4);
  }
  return 0;
}

CFTypeRef PCSFPGetChainingSet(uint64_t a1, int a2)
{
  if (a2)
  {
    CFTypeRef result = *(CFTypeRef *)(a1 + 24);
    if (!result)
    {
      CFTypeRef result = PCSIdentitySetCreateMutable(0);
      *(void *)(a1 + 24) = result;
    }
  }
  else
  {
    CFTypeRef result = *(CFTypeRef *)(a1 + 32);
    if (!result)
    {
      CFTypeRef result = PCSIdentitySetCreateMutable(0);
      *(void *)(a1 + 32) = result;
    }
  }
  return result;
}

uint64_t regenFPChainingAttribute(uint64_t a1, const void **a2)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    uint64_t v5 = 72;
    if (*(_DWORD *)(a1 + 204) > 2u) {
      uint64_t v5 = 64;
    }
    CFDataRef v6 = *(const __CFData **)(a1 + v5);
    if (!v6) {
      goto LABEL_17;
    }
    CFArrayRef v7 = (const __CFArray *)PCSIdentitySetCopyOrderedIdentities(v4, kPCSServiceRaw);
    if (!v7 || !fillChainingKeys(v6, v7, (CFIndex **)&v20, &v19, a2)) {
      goto LABEL_18;
    }
    CFRelease(v7);
  }
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8)
  {
    CFArrayRef v7 = (const __CFArray *)PCSIdentitySetCopyOrderedIdentities(v8, kPCSServiceRaw);
    if (!v7
      || !fillChainingKeys(*(const __CFData **)(a1 + 72), v7, (CFIndex **)&v20 + 1, (void *)&v19 + 1, a2))
    {
      goto LABEL_18;
    }
    CFRelease(v7);
  }
  uint64_t v9 = length_PCSObjectChaining((uint64_t)&v19);
  uint64_t v17 = v9;
  uint64_t v10 = malloc_type_malloc(v9, 0x99FFC367uLL);
  uint64_t v18 = v10;
  if (!v10)
  {
    uint64_t v13 = 12;
    goto LABEL_16;
  }
  char v11 = v10;
  uint64_t v12 = encode_PCSObjectChaining((uint64_t)v10 + v9 - 1, v9, (uint64_t)&v19, (uint64_t)&v16);
  if (v12)
  {
    uint64_t v13 = v12;
    free(v11);
    uint64_t v18 = 0;
LABEL_16:
    _PCSErrorASN1(a2, (uint64_t)"encode PCSObjectChaining", v13);
LABEL_17:
    CFArrayRef v7 = 0;
LABEL_18:
    uint64_t v14 = 0;
    goto LABEL_19;
  }
  if (v16 != v9) {
    abort();
  }
  PCSReplaceOrUpdateAttribute((unsigned int *)(a1 + 128), 4, (uint64_t)&v17);
  CFArrayRef v7 = 0;
  uint64_t v14 = 1;
LABEL_19:
  free_PCSObjectChaining((uint64_t)&v19);
  if (v18) {
    free(v18);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v14;
}

uint64_t PCSFPChainingRemoveIdentity(uint64_t a1, int a2, uint64_t a3, const void **a4)
{
  uint64_t v5 = 32;
  if (a2) {
    uint64_t v5 = 24;
  }
  uint64_t v6 = *(void *)(a1 + v5);
  if (!v6 || !PCSIdentitySetRemoveIdentity(v6, a3)) {
    return 0;
  }
  return regenFPChainingAttribute(a1, a4);
}

uint64_t PCSShareProtectionAddPCSKey(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t PCSShareProtectionDeletePCSKey(uint64_t a1, uint64_t a2)
{
  return PCSIdentitySetRemoveIdentity(*(void *)(a1 + 16), a2);
}

BOOL PCSShareProtectionAddKeyWithAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = PCSFPCreatePrivateKey(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v9 = v8;
  if (v8) {
    CFRelease(v8);
  }
  return v9 != 0;
}

uint64_t PCSShareProtectionCopyKeys(uint64_t a1, uint64_t a2)
{
  return PCSIdentitySetCopyIdentities(*(void *)(a1 + 16), a2);
}

CFArrayRef PCSShareProtectionCopyPublicKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v11);
  }
  if (!*(void *)(a1 + 48))
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFDictionaryRef v9 = (const __CFDictionary *)PCSIdentitySetCopyIdentities(*(void *)(a1 + 16), 0);
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __PCSShareProtectionCopyPublicKeys_block_invoke;
    context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    void context[4] = a1;
    CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)apply_block_2_1, context);
    if (v9) {
      CFRelease(v9);
    }
  }
  return CFArrayCreateCopy(0, *(CFArrayRef *)(a1 + 48));
}

void __PCSShareProtectionCopyPublicKeys_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = PCSIdentityCopyPublicIdentity(a3);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(a1 + 32) + 48), v4);
  if (v4)
  {
    CFRelease(v4);
  }
}

CFDataRef PCSFPCreateDerivedDataFromMasterKey(uint64_t a1, const __CFData *a2, const __CFData *a3, size_t a4)
{
  CFDataRef v8 = CFDataCreate(0, (const UInt8 *)"DerivedDataFromMasterKey", 24);
  CFDataRef v9 = *(const __CFData **)(a1 + 72);
  size_t Length = CFDataGetLength(v9);
  CFDataRef v11 = deriveHKDF(v9, 0, v8, Length);
  if (v8) {
    CFRelease(v8);
  }
  if (!v11) {
    return 0;
  }
  CFDataRef v12 = deriveHKDF(v11, a2, a3, a4);
  CFRelease(v11);
  return v12;
}

CFDataRef deriveHKDF(const __CFData *a1, CFDataRef theData, const __CFData *a3, size_t a4)
{
  if (theData)
  {
    CFDataGetBytePtr(theData);
    CFDataGetLength(theData);
    if (!a3) {
      goto LABEL_5;
    }
    goto LABEL_3;
  }
  if (a3)
  {
LABEL_3:
    CFDataGetBytePtr(a3);
    CFDataGetLength(a3);
  }
LABEL_5:
  int Hkdf = CCKDFParametersCreateHkdf();
  if (Hkdf)
  {
    int v9 = Hkdf;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      deriveHKDF_cold_2(v9);
    }
    return 0;
  }
  else
  {
    CFDataRef v11 = malloc_type_malloc(a4, 0x9FDB79C2uLL);
    CFDataGetBytePtr(a1);
    CFDataGetLength(a1);
    int v12 = CCDeriveKey();
    if (v12)
    {
      int v13 = v12;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        deriveHKDF_cold_1(v13);
      }
      free(v11);
      CFDataRef v10 = 0;
    }
    else
    {
      CFDataRef v10 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v11, a4, (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
    }
    CCKDFParametersDestroy();
  }
  return v10;
}

uint64_t PCSFPGetCurrentMasterKeyID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return *(void *)(a1 + 80);
}

uint64_t PCSFPGetCurrentMasterKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v11);
  }
  int v9 = *(_DWORD *)(a1 + 200);
  if (v9 && PCSServiceItemAllowKeyExportByIndex(v9)) {
    return *(void *)(a1 + 72);
  }
  else {
    return 0;
  }
}

const void *PCSFPGetMasterKeyForKeyID(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFBooleanRef Value = 0;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 216) != 1192348414) {
      PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v15[0]);
    }
    int v11 = *(_DWORD *)(a1 + 200);
    if (v11 && PCSServiceItemAllowKeyExportByIndex(v11))
    {
      if (CFEqual(a2, *(CFTypeRef *)(a1 + 80))) {
        goto LABEL_7;
      }
      if (CFDataGetLength((CFDataRef)a2) > 4)
      {
        CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 112), a2);
        goto LABEL_13;
      }
      CFDataRef v12 = *(const __CFData **)(a1 + 80);
      v20.CFIndex length = CFDataGetLength(v12);
      v20.CFIndex location = 0;
      if (!(unint64_t)CFDataFind(v12, (CFDataRef)a2, v20, 2uLL).location)
      {
LABEL_7:
        CFBooleanRef Value = *(const void **)(a1 + 72);
LABEL_13:
        v17[3] = (uint64_t)Value;
        goto LABEL_14;
      }
      CFDictionaryRef v13 = *(const __CFDictionary **)(a1 + 112);
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 3221225472;
      _OWORD v15[2] = __PCSFPGetMasterKeyForKeyID_block_invoke;
      void v15[3] = &unk_1E5E6DF70;
      void v15[4] = &v16;
      v15[5] = a2;
      CFDictionaryApplyFunction(v13, (CFDictionaryApplierFunction)apply_block_2_1, v15);
      CFBooleanRef Value = (const void *)v17[3];
    }
    else
    {
      CFBooleanRef Value = 0;
    }
  }
LABEL_14:
  _Block_object_dispose(&v16, 8);
  return Value;
}

void sub_1ACFB7BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFIndex __PCSFPGetMasterKeyForKeyID_block_invoke(CFIndex result, CFDataRef theData, uint64_t a3)
{
  if (!*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24))
  {
    CFIndex v5 = result;
    CFDataRef v6 = *(const __CFData **)(result + 40);
    v7.CFIndex length = CFDataGetLength(theData);
    v7.CFIndex location = 0;
    CFTypeRef result = CFDataFind(theData, v6, v7, 2uLL).location;
    if (!result) {
      *(void *)(*(void *)(*(void *)(v5 + 32) + 8) + 24) = a3;
    }
  }
  return result;
}

__CFArray *PCSFPCopyAvailableMasterKeyIDs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, v12);
  }
  if (!*(void *)(a1 + 80))
  {
    syslog(3, "PCSShareProtection %p have a NULL master key");
    return 0;
  }
  if (!*(void *)(a1 + 112))
  {
    syslog(3, "PCSShareProtection %p have a NULL oldMasterKeys");
    return 0;
  }
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFDataRef v10 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, *(const void **)(a1 + 80));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 112), (CFDictionaryApplierFunction)addKeyToArray, v10);
  }
  return v10;
}

void addKeyToArray(void *value, int a2, CFMutableArrayRef theArray)
{
}

const void *PCSFPSetOwnerIdentity(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4 = *(const void **)(a1 + 160);
  if (v4)
  {
    *(void *)(a1 + 160) = 0;
    CFRelease(v4);
  }
  CFTypeID v5 = CFGetTypeID(cf);
  if (v5 == PCSIdentityGetTypeID())
  {
    CFTypeRef result = PCSIdentityCopyPublicIdentity((uint64_t)cf);
    CFTypeRef cf = result;
  }
  else
  {
    CFTypeID v7 = CFGetTypeID(cf);
    CFTypeRef result = (const void *)PCSPublicIdentityGetTypeID();
    if ((const void *)v7 != result) {
      return result;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
  }
  *(void *)(a1 + 160) = cf;
  return result;
}

uint64_t PCSFPGetOwnerIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return *(void *)(a1 + 160);
}

_DWORD *PCSFPSetAuthorshipIdentity(_DWORD *result, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result[54] != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", (uint64_t)cf, a3, a4, a5, a6, a7, a8, v11);
  }
  if (cf)
  {
    int v9 = result;
    CFDataRef v10 = (const void *)*((void *)result + 22);
    if (v10)
    {
      v9[22] = 0;
      CFRelease(v10);
    }
    CFTypeRef result = CFRetain(cf);
    v9[22] = cf;
  }
  return result;
}

uint64_t PCSFPGetAuthorshipIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return *(void *)(a1 + 176);
}

uint64_t PCSFPRollMasterKey(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v31);
  }
  char v9 = a2;
  if (*(_DWORD *)(a1 + 204) == 3 && *(unsigned char *)(a1 + 209))
  {
    _PCSError(a3, 48, @"Share is a readonly share");
    return 0;
  }
  if (*(unsigned char *)(a1 + 210))
  {
    _PCSError(a3, 49, @"Share is rolled w/o export");
    return 0;
  }
  if ((unint64_t)CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 112)) >> 31)
  {
    _PCSError(a3, 136, @"Share master key rolled too much");
    return 0;
  }
  if ((v9 & 1) == 0) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 112), *(const void **)(a1 + 80), *(const void **)(a1 + 72));
  }
  Randomuint64_t Key = 0;
  char v12 = 0;
  while (1)
  {
    if (RandomKey) {
      CFRelease(RandomKey);
    }
    Randomuint64_t Key = CreateRandomKey();
    if (!RandomKey) {
      break;
    }
    uint64_t v20 = *(void *)(a1 + 64);
    if (*(_DWORD *)(a1 + 204) == 3)
    {
      if (!v20) {
        PCSAbort("read write master key NULL in version 2 key:sp->readwriteMasterKey", v13, v14, v15, v16, v17, v18, v19, v31);
      }
      generateOtherKeysFromRWMasterKey(a1, RandomKey, v14, v15, v16, v17, v18, v19);
    }
    else
    {
      if (v20) {
        PCSAbort("read write master key not NULL in version 1 key:sp->readwriteMasterKey == NULL", v13, v14, v15, v16, v17, v18, v19, v31);
      }
      char v21 = *(const void **)(a1 + 72);
      if (v21)
      {
        *(void *)(a1 + 72) = 0;
        CFRelease(v21);
      }
      MutableCFDataRef Copy = CFDataCreateMutableCopy(0, 0, RandomKey);
      *(void *)(a1 + 72) = MutableCopy;
      if (!MutableCopy) {
        break;
      }
      generateObjectKey((void *)a1, RandomKey, 1);
    }
    KeyIDFromuint64_t Key = CreateKeyIDFromKey(*(const __CFData **)(a1 + 72));
    if (!KeyIDFromKey)
    {
      _PCSErrorOOM(a3);
      uint64_t v29 = 0;
      goto LABEL_29;
    }
    char v12 = KeyIDFromKey;
    uint64_t v24 = *(const void **)(a1 + 80);
    if (v24)
    {
      *(void *)(a1 + 80) = 0;
      CFRelease(v24);
    }
    CFDataRef v25 = (const __CFData *)CFRetain(v12);
    *(void *)(a1 + 80) = v25;
    uint64_t v33 = 0;
    uint64_t v34 = &v33;
    uint64_t v35 = 0x2020000000;
    char v36 = 0;
    if ((unint64_t)CFDataGetLength(v25) >= 4)
    {
      CFDictionaryRef v26 = *(const __CFDictionary **)(a1 + 112);
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 3221225472;
      context[2] = ___PCSFPMasterKeyIDHintConflict_block_invoke;
      context[3] = &unk_1E5E6E350;
      void context[4] = &v33;
      void context[5] = 4;
      void context[6] = v25;
      CFDictionaryApplyFunction(v26, (CFDictionaryApplierFunction)apply_block_2_1, context);
    }
    int v27 = *((unsigned __int8 *)v34 + 24);
    _Block_object_dispose(&v33, 8);
    if (!v27)
    {
      uint64_t v28 = 1;
      *(unsigned char *)(a1 + 210) = 1;
      PCSFPUpdateMasterKeyIDAttribute(a1);
LABEL_27:
      CFRelease(v12);
      uint64_t v29 = v28;
      goto LABEL_28;
    }
  }
  _PCSErrorOOM(a3);
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  if (v12) {
    goto LABEL_27;
  }
LABEL_28:
  if (!RandomKey) {
    return v29;
  }
LABEL_29:
  CFRelease(RandomKey);
  return v29;
}

void sub_1ACFB8140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void PCSFPUpdateMasterKeyIDAttribute(uint64_t a1)
{
  uint64_t v25 = 0;
  CFDictionaryRef v26 = 0;
  long long v24 = 0uLL;
  uint64_t v20 = 0;
  char v21 = &v20;
  uint64_t v22 = 0x2020000000;
  int v23 = 0;
  uint64_t v19 = 0;
  unsigned int Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 112));
  LODWORD(v24) = Count;
  *((void *)&v24 + 1) = malloc_type_calloc(Count, 0x10uLL, 0x108004057E67DB5uLL);
  if (*((void *)&v24 + 1))
  {
    CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 112);
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __PCSFPUpdateMasterKeyIDAttribute_block_invoke;
    context[3] = &unk_1E5E6E3A0;
    long long v17 = v24;
    void context[4] = &v20;
    uint64_t v18 = 4;
    CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)apply_block_2_1, context);
    if (*((_DWORD *)v21 + 6) != Count)
    {
      uint64_t v14 = "old master key length incorrect:n == ids.len";
      goto LABEL_10;
    }
    uint64_t v11 = length_PCSMasterKeyIDs((uint64_t)&v24);
    uint64_t v25 = v11;
    char v12 = malloc_type_malloc(v11, 0xF7C6A72CuLL);
    uint64_t v13 = v12;
    CFDictionaryRef v26 = v12;
    if (v12)
    {
      if (encode_PCSMasterKeyIDs((uint64_t)v12 + v11 - 1, v11, (uint64_t)&v24, (uint64_t)&v19))
      {
        free(v13);
        CFDictionaryRef v26 = 0;
        goto LABEL_8;
      }
      if (v11 == v19)
      {
        PCSReplaceOrUpdateAttribute((unsigned int *)(a1 + 128), 5, (uint64_t)&v25);
        goto LABEL_8;
      }
      uint64_t v14 = "asn1 encoding failure:data.length == length";
LABEL_10:
      PCSAbort(v14, v4, v5, v6, v7, v8, v9, v10, v15);
    }
  }
LABEL_8:
  free(*((void **)&v24 + 1));
  free(v26);
  _Block_object_dispose(&v20, 8);
}

void sub_1ACFB8310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t PCSFPRemoveMasterKey(uint64_t a1, CFDataRef theData, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", (uint64_t)theData, (uint64_t)a3, a4, a5, a6, a7, a8, v23);
  }
  CFIndex Length = CFDataGetLength(theData);
  int64_t v12 = Length;
  if (Length == 4 || Length == 32)
  {
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 112), theData))
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 112), theData);
LABEL_6:
      PCSFPUpdateMasterKeyIDAttribute(a1);
      return 1;
    }
    CFArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFDictionaryRef v15 = *(const __CFDictionary **)(a1 + 112);
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __PCSFPRemoveMasterKey_block_invoke;
    context[3] = &__block_descriptor_56_e15_v24__0r_v8r_v16l;
    void context[4] = theData;
    void context[5] = v12;
    void context[6] = Mutable;
    CFDictionaryApplyFunction(v15, (CFDictionaryApplierFunction)apply_block_2_1, context);
    CFIndex Count = CFArrayGetCount(Mutable);
    if (Count == 1)
    {
      char v21 = *(__CFDictionary **)(a1 + 112);
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, 0);
      CFDictionaryRemoveValue(v21, ValueAtIndex);
      if (Mutable) {
        CFRelease(Mutable);
      }
      goto LABEL_6;
    }
    if (Count)
    {
      _PCSError(a3, 163, @"Multiple matching master keys found");
    }
    else if (*(void *)(a1 + 80) {
           && ((BytePtr = CFDataGetBytePtr(theData),
    }
                uint64_t v18 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 80)),
                CFIndex v19 = CFDataGetLength(*(CFDataRef *)(a1 + 80)),
                v12 >= v19)
             ? (size_t v20 = v19)
             : (size_t v20 = v12),
               !memcmp(BytePtr, v18, v20)))
    {
      _PCSError(a3, 162, @"Cannot remove current master key");
    }
    else
    {
      _PCSError(a3, 25, @"No matching master key found");
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  else
  {
    _PCSError(a3, 32, @"Invalid key ID length");
  }
  return 0;
}

void __PCSFPRemoveMasterKey_block_invoke(uint64_t a1, CFDataRef theData)
{
  CFIndex Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 32));
  uint64_t v6 = CFDataGetBytePtr(theData);
  if (*(void *)(a1 + 40) >= Length) {
    size_t v7 = Length;
  }
  else {
    size_t v7 = *(void *)(a1 + 40);
  }
  if (!memcmp(BytePtr, v6, v7))
  {
    uint64_t v8 = *(__CFArray **)(a1 + 48);
    CFArrayAppendValue(v8, theData);
  }
}

uint64_t PCSFPShouldRoll(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return *(unsigned __int8 *)(a1 + 211);
}

uint64_t _PCSFPSetShouldRoll(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(result + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  *(unsigned char *)(result + 211) = a2;
  return result;
}

uint64_t PCSNeedsRollAndCounterSign(const __CFData *a1, const void **a2)
{
  uint64_t v15 = 0;
  memset(v16, 0, sizeof(v16));
  long long v17 = 0u;
  uint64_t v18 = 0;
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v6 = decode_PCSShareProtection((uint64_t)BytePtr, Length, (uint64_t)v16, (uint64_t)&v15);
  if (v6)
  {
    _PCSErrorASN1(a2, (uint64_t)"decode PCSShareProtection", v6);
    BOOL v11 = 0;
    BOOL v13 = 1;
  }
  else
  {
    if (v18 && (uint64_t v7 = *v18, v7))
    {
      uint64_t v8 = (int *)*((void *)v18 + 1);
      uint64_t v9 = v7 - 1;
      do
      {
        int v10 = *v8;
        v8 += 6;
        BOOL v11 = v10 == 12;
      }
      while (v10 != 12 && v9-- != 0);
    }
    else
    {
      BOOL v11 = 0;
    }
    BOOL v13 = *((void *)&v17 + 1) == 0;
  }
  free_PCSShareProtection((uint64_t)v16);
  return v11 & v13;
}

uint64_t PCSFPIsOutOfNetwork(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return *(unsigned __int8 *)(a1 + 213);
}

uint64_t PCSFPShouldUpdate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return *(unsigned __int8 *)(a1 + 212);
}

uint64_t PCSFPGetAuthorIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, a3, a4, a5, a6, a7, a8, vars0);
  }
  return *(void *)(a1 + 152);
}

uint64_t PCSFPUpdateZoneKey(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _PCSFPUpdateIdentityKey(a1, *(void *)(a2 + 16), a3, a4, a5, a6, a7, a8);
}

uint64_t _PCSFPUpdateIdentityKey(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
LABEL_45:
  }
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v33[0]);
  uint64_t v9 = (const void *)a2;
  if (!a2)
  {
LABEL_55:
    uint64_t v15 = 0;
    CFDictionaryRef v14 = 0;
    goto LABEL_56;
  }
  int v11 = *(_DWORD *)(a1 + 204);
  if (v11 == 3)
  {
    if (*(unsigned char *)(a1 + 209))
    {
      _PCSError(a3, 48, @"RO object can't upgrade key");
LABEL_54:
      uint64_t v9 = 0;
      goto LABEL_55;
    }
  }
  else if (!v11)
  {
    _PCSError(a3, 65, @"Light object can't upgrade key");
    goto LABEL_54;
  }
  if (!*(unsigned char *)(a1 + 211))
  {
    _PCSError(a3, 49, @"Rolling not required, refusing to roll");
    goto LABEL_54;
  }
  uint64_t v12 = *(void *)(a1 + 176);
  if (!v12)
  {
    _PCSError(a3, 94, @"Wrap identity not known");
    goto LABEL_54;
  }
  uint64_t ServiceName = (void *)PCSIdentityGetServiceName(v12);
  if (!ServiceName)
  {
    _PCSError(a3, 94, @"Wrap identity service type is not known");
    uint64_t v9 = 0;
    uint64_t v15 = 0;
    CFDictionaryRef v14 = 0;
    goto LABEL_18;
  }
  CFDictionaryRef v14 = (const __CFDictionary *)PCSIdentitySetCopyIdentities((uint64_t)v9, 0);
  if (!v14)
  {
    _PCSErrorOOM(a3);
    uint64_t v9 = 0;
    uint64_t v15 = 0;
    goto LABEL_56;
  }
  uint64_t v15 = PCSIdentitySetCopyCurrentPublicIdentityWithError((uint64_t)v9, ServiceName, a3);
  if (!v15)
  {
    uint64_t v9 = 0;
    goto LABEL_56;
  }
  uint64_t v9 = PCSIdentitySetCopyCurrentIdentityWithError((uint64_t)v9, ServiceName, a3);
  if (!v9)
  {
LABEL_56:
    uint64_t ServiceName = 0;
    goto LABEL_18;
  }
  uint64_t PublicID = PCSPublicIdentityGetPublicID((uint64_t)v15);
  if (!PublicID)
  {
    _PCSError(a3, 60, @"Failed to get rolling identity");
    goto LABEL_56;
  }
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    goto LABEL_45;
  }
  uint64_t v17 = PublicID;
  uint64_t v18 = *(const void **)(a1 + 152);
  if (v18 && CFEqual(v18, v15))
  {
    _PCSError(a3, 96, @"Asked to roll, but we're already using that service identity");
    uint64_t ServiceName = 0;
    *(unsigned char *)(a1 + 211) = 0;
  }
  else
  {
    uint64_t ServiceName = CFDictionaryCreateMutableCopy(0, 0, *(CFDictionaryRef *)(a1 + 40));
    if (ServiceName)
    {
      uint64_t v24 = ShareEntryCreate(v15, 0);
      if (v24)
      {
        uint64_t v25 = (const void *)v24;
        CFDictionaryRef v26 = (const void *)PCSPublicIdentityGetPublicID((uint64_t)v15);
        CFDictionarySetValue((CFMutableDictionaryRef)ServiceName, v26, v25);
        v33[0] = MEMORY[0x1E4F143A8];
        v33[1] = 3221225472;
        v33[2] = ___PCSFPUpdateIdentityKey_block_invoke;
        v33[3] = &__block_descriptor_48_e15_v24__0r_v8r_v16l;
        v33[4] = v17;
        v33[5] = ServiceName;
        CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)apply_block_2_1, v33);
        int v27 = *(const void **)(a1 + 40);
        if (v27)
        {
          *(void *)(a1 + 40) = 0;
          CFRelease(v27);
        }
        *(void *)(a1 + 40) = CFRetain(ServiceName);
        *(unsigned char *)(a1 + 211) = 0;
        uint64_t v28 = *(const void **)(a1 + 176);
        if (v28)
        {
          *(void *)(a1 + 176) = 0;
          CFRelease(v28);
        }
        *(void *)(a1 + 176) = CFRetain(v9);
        uint64_t v29 = *(const void **)(a1 + 184);
        if (v29)
        {
          *(void *)(a1 + 184) = 0;
          CFRelease(v29);
        }
        uint64_t SigningIdentity = (const void *)_PCSIdentityGetSigningIdentity((uint64_t)v9);
        char v31 = SigningIdentity;
        if (SigningIdentity) {
          CFRetain(SigningIdentity);
        }
        *(void *)(a1 + 184) = v31;
        uint64_t v32 = *(const void **)(a1 + 152);
        if (v32)
        {
          *(void *)(a1 + 152) = 0;
          CFRelease(v32);
        }
        *(void *)(a1 + 152) = CFRetain(v15);
        CFRelease(v25);
        uint64_t v21 = 1;
        goto LABEL_43;
      }
    }
    _PCSErrorOOM(a3);
  }
LABEL_18:
  if (*a3)
  {
    CFIndex v19 = pcsLogObjForScope("fprollKeys");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      size_t v20 = *a3;
      *(_DWORD *)stat buf = 138412290;
      uint64_t v35 = v20;
      _os_log_impl(&dword_1ACF98000, v19, OS_LOG_TYPE_DEFAULT, "Not rolling zone key %@", buf, 0xCu);
    }
  }
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if (!ServiceName)
  {
    if (!v14) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
LABEL_43:
  CFRelease(ServiceName);
  uint64_t v22 = v21;
  if (v14) {
LABEL_24:
  }
    CFRelease(v14);
LABEL_25:
  if (v15) {
    CFRelease(v15);
  }
  if (v9) {
    CFRelease(v9);
  }
  return v22;
}

uint64_t PCSFPUpdateIdentityAndRollZoneKey(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t ServiceName = PCSIdentityGetServiceName(*(void *)(a1 + 176));
  if ((_PCSFPUpdateIdentityKey(a1, a2, a3, v7, v8, v9, v10, v11) & 1) == 0)
  {
    char v23 = pcsLogObjForScope("fpkeyRoll");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = *a3;
      int v25 = 138412546;
      uint64_t v26 = a1;
      __int16 v27 = 2112;
      uint64_t v28 = v24;
      _os_log_impl(&dword_1ACF98000, v23, OS_LOG_TYPE_DEFAULT, "FP Failed Roll for zone %@ %@", (uint8_t *)&v25, 0x16u);
    }

    return 0;
  }
  CFIndex v19 = PCSFPCreatePrivateKey(a1, v12, v13, v14, v15, v16, v17, v18);
  if (!v19)
  {
    _PCSErrorOOM(a3);
    return 0;
  }
  size_t v20 = v19;
  uint64_t v21 = pcsLogObjForScope("fpkeyRoll");
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = 138412290;
    uint64_t v26 = ServiceName;
    _os_log_impl(&dword_1ACF98000, v21, OS_LOG_TYPE_DEFAULT, "FP Rolled for Zone %@", (uint8_t *)&v25, 0xCu);
  }

  CFRelease(v20);
  return 1;
}

void sub_1ACFB8F74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t apply_block_2_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t apply_block_1_0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL makeHmac(uint64_t a1, const __CFData *a2, const __CFData *a3, uint64_t a4, size_t *a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = ccsha256_di();
  size_t v11 = *(void *)MEMORY[0x1F4188790](v10);
  *a5 = v11;
  a5[1] = (size_t)malloc_type_malloc(v11, 0xDD2D803EuLL);
  BOOL v12 = _PCSCreateDerivedKey(*(const __CFData **)(a1 + 72), 20, (int)&hmacLabel, 0x10uLL, (int)&v14, 0);
  if (v12)
  {
    cchmac_init();
    CFDataGetLength(a2);
    CFDataGetBytePtr(a2);
    cchmac_update();
    if (a3)
    {
      CFDataGetLength(a3);
      CFDataGetBytePtr(a3);
      cchmac_update();
    }
    if (a4) {
      cchmac_update();
    }
    cchmac_final();
  }
  return v12;
}

void __CreateWithExportedInternal_block_invoke(uint64_t a1, uint64_t a2, const void *a3)
{
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    CFDataRef v5 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(*(void *)(a1 + 48) + 40), *(void *)(*(void *)(a1 + 48) + 32), (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = _PCSIdentityCopyUnwappedKey((uint64_t)a3, v5, 0);
    if (v5) {
      CFRelease(v5);
    }
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = CFRetain(a3);
      if ((*(unsigned char *)(a1 + 72) & 4) != 0)
      {
        if (!*(void *)(*(void *)(a1 + 56) + 56)) {
          *(void *)(*(void *)(a1 + 56) + 56) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        }
        CFDataRef v6 = CFDataCreate(0, *(const UInt8 **)(*(void *)(a1 + 48) + 40), *(void *)(*(void *)(a1 + 48) + 32));
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 56) + 56), *(const void **)(a1 + 64), v6);
        CFRelease(v6);
      }
    }
  }
}

void noMatchingIdentity(uint64_t a1, uint64_t a2, const void **a3)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint64_t v7 = Mutable;
    CFMutableArrayRef v8 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    if (v8)
    {
      CFArrayRef v9 = v8;
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 3221225472;
      v20[2] = __noMatchingIdentity_block_invoke;
      v20[3] = &__block_descriptor_40_e21_v16__0____CFString__8l;
      v20[4] = v8;
      PCSIdentitySetEnumeratePublicKeys(a1, v20);
      CFStringRef v10 = CFStringCreateByCombiningStrings(0, v9, @", ");
      if (v10)
      {
        CFStringRef v11 = v10;
        CFDictionarySetValue(v7, (const void *)kPCSErrorSetIdentities, v9);
        CFRelease(v9);
        CFMutableArrayRef v12 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
        if (!v12)
        {
          CFStringRef v15 = 0;
          goto LABEL_10;
        }
        CFArrayRef v13 = v12;
        if (a2) {
          CFDictionaryApplyFunction(*(CFDictionaryRef *)(a2 + 40), (CFDictionaryApplierFunction)addKeyToArray, v12);
        }
        else {
          CFArrayAppendValue(v12, @"light-object");
        }
        CFStringRef v14 = CFStringCreateByCombiningStrings(0, v13, @", ");
        if (v14)
        {
          CFStringRef v15 = v14;
          CFDictionarySetValue(v7, (const void *)kPCSErrorObjectIdentities, v13);
          CFRelease(v13);
          _PCSErrorUserInfo(0, a3, 73, v7, @"PCS object didn't contain any of the identities [%@], it contained [%@]", v16, v17, v18, (char)v11);
LABEL_10:
          CFRelease(v7);
          CFRelease(v11);
          if (!v15) {
            return;
          }
          CFIndex v19 = (__CFDictionary *)v15;
          goto LABEL_12;
        }
        CFRelease(v13);
        CFRelease(v7);
        CFIndex v19 = (__CFDictionary *)v11;
      }
      else
      {
        CFRelease(v9);
        CFIndex v19 = v7;
      }
LABEL_12:
      CFRelease(v19);
      return;
    }
    CFRelease(v7);
  }
}

uint64_t ValidateSignature(uint64_t a1, const __CFData *a2, const __CFData *a3, void *a4, uint64_t *a5, const __CFAllocator *a6, CFIndex a7, unsigned int *a8, unsigned int *a9, char a10, void *a11, void *a12, const void **a13)
{
  CFAllocatorRef v164 = a6;
  v162 = a4;
  CFDataRef v167 = a2;
  CFDataRef v168 = a3;
  uint64_t v17 = a9;
  uint64_t v192 = *MEMORY[0x1E4F143B8];
  id v18 = a12;
  uint64_t ServiceID = *(void *)(a1 + 176);
  if (!ServiceID)
  {
    BOOL v21 = 0;
    long long v189 = 0u;
    long long v190 = 0u;
    long long v187 = 0u;
    long long v188 = 0u;
    long long v185 = 0u;
    long long v186 = 0u;
    CFIndex v25 = a7;
    BOOL v22 = a7 == 0;
    long long v184 = 0u;
    goto LABEL_10;
  }
  BOOL IsManatee = _PCSIdentityIsManatee(ServiceID);
  BOOL v21 = _PCSIdentityRequireManateeSigning(*(void *)(a1 + 176));
  uint64_t ServiceID = *(void *)(a1 + 176);
  long long v184 = 0u;
  long long v185 = 0u;
  long long v186 = 0u;
  long long v187 = 0u;
  long long v188 = 0u;
  long long v189 = 0u;
  BOOL v22 = a7 == 0;
  long long v190 = 0u;
  if (!ServiceID)
  {
    CFIndex v25 = a7;
LABEL_10:
    CFDataRef v23 = v168;
    if (!a5) {
      goto LABEL_69;
    }
    goto LABEL_11;
  }
  CFDataRef v23 = v168;
  if (a7 || !IsManatee)
  {
    CFIndex v25 = a7;
    if (!a5)
    {
LABEL_69:
      if (!v22)
      {
        _PCSError(a13, 16, @"Author signature exists, but no self signature");
        goto LABEL_75;
      }
      uint64_t v24 = a13;
      if (!v21)
      {
LABEL_76:
        v173 = 0;
        v165 = 0;
        goto LABEL_165;
      }
      if (!ServiceID) {
        goto LABEL_73;
      }
      goto LABEL_72;
    }
LABEL_11:
    a7 = v25;
    goto LABEL_12;
  }
  BOOL v22 = 1;
  *(unsigned char *)(a1 + 212) = 1;
  if (!a5)
  {
    uint64_t v24 = a13;
    if (!v21) {
      goto LABEL_76;
    }
LABEL_72:
    uint64_t ServiceID = PCSIdentityGetServiceID(ServiceID);
LABEL_73:
    _PCSError(v24, 16, @"Author signature or server signature required for service: %d", ServiceID);
    goto LABEL_75;
  }
LABEL_12:
  LODWORD(v163) = v22;
  uint64_t v183 = 0;
  uint64_t v26 = decode_PCSObjectSignature(a5[1], *a5, (uint64_t)&v184, (uint64_t)&v183);
  if (v26)
  {
    _PCSErrorASN1(a13, (uint64_t)"decode PCSObjectSignature", v26);
    goto LABEL_75;
  }
  if (*a5 != v183)
  {
    _PCSError(a13, 16, @"Signature of wrong length");
    goto LABEL_75;
  }
  if (*((void *)&v190 + 1) && copy_PCSAttributes())
  {
    _PCSErrorOOM(a13);
    goto LABEL_75;
  }
  uint64_t v27 = _PCSSignAlgToDI(WORD4(v187), a13);
  if (!v27)
  {
LABEL_75:
    free_PCSObjectSignature((uint64_t)&v184);
    uint64_t v86 = 0;
    goto LABEL_185;
  }
  uint64_t v28 = (uint64_t *)v27;
  v161 = v155;
  uint64_t v29 = MEMORY[0x1F4188790](v27);
  v170 = &v155[-((v30 + 15) & 0xFFFFFFFFFFFFFFF0)];
  _PCSMakeDigest(v29, v167, v23, (uint64_t)&v184, (uint64_t)v170);
  if (!*(unsigned char *)(a1 + 209))
  {
    uint64_t ObjectKey = getObjectKey(a1);
    if (!ObjectKey)
    {
      _PCSError(a13, 48, @"No verification key");
LABEL_66:
      v173 = 0;
      goto LABEL_67;
    }
    if ((*(_DWORD *)(a1 + 204) & 0xFFFFFFFE) != 2) {
      PCSAbort("self sign but not version 1.5 or 2:sp->version == VERSION2 || sp->version == VERSION1_5", v39, v40, v41, v42, v43, v44, v45, v155[0]);
    }
    if (!_PCSVerifyHash(ObjectKey, WORD4(v187), *v28, (uint64_t)v170, (uint64_t)&v186 + 8, a13))
    {
      CFDataRef v87 = 0;
      v173 = 0;
      CFDataRef v88 = 0;
      goto LABEL_162;
    }
  }
  BOOL v112 = (BYTE4(v184) & 3) == 0;
  *(unsigned char *)(a1 + 214) = (BYTE4(v184) & 3) != 0;
  if (v112) {
    int v46 = 0;
  }
  else {
    int v46 = v163;
  }
  uint64_t v171 = a1;
  v159 = a8;
  v160 = a5;
  if (v46 != 1)
  {
    CFIndex v158 = a7;
    v169 = v28;
    v173 = 0;
    uint64_t v24 = a13;
    if (!a8) {
      goto LABEL_58;
    }
    goto LABEL_50;
  }
  if (!a9 || (_PCSIdentitySupportsServerSigning(*(void *)(a1 + 176)) & 1) == 0)
  {
    uint64_t v85 = *(void *)(a1 + 176);
    if (v85) {
      uint64_t v85 = PCSIdentityGetServiceID(v85);
    }
    _PCSError(a13, 16, @"Author signature or server signature required for service: %d", v85);
    goto LABEL_66;
  }
  CFIndex v158 = a7;
  v169 = v28;
  v165 = a13;
  id v166 = v18;
  id v172 = [MEMORY[0x1E4F1CA60] dictionary];
  v173 = malloc_type_calloc(*a9, 0x28uLL, 0x1080040EC46ECBEuLL);
  unint64_t v47 = *a9;
  if (v47)
  {
    uint64_t v48 = 0;
    unint64_t v49 = 0;
    CFAllocatorRef v50 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    long long v51 = v173;
    do
    {
      uint64_t v52 = *((void *)a9 + 1);
      if (*(_DWORD *)(v52 + v48) == 12)
      {
        uint64_t v54 = *(void *)(v52 + v48 + 8);
        uint64_t v53 = *(void *)(v52 + v48 + 16);
        *(void *)&long long v177 = 0;
        if (!decode_PCSSignature(v53, v54, (uint64_t)v51, (uint64_t)&v177))
        {
          uint64_t v55 = (void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytes:v51[1] length:*v51];
          CFMutableDictionaryRef Mutable = *(__CFArray **)(a1 + 192);
          if (Mutable
            || (CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v50, 0, MEMORY[0x1E4F1D510]), (*(void *)(a1 + 192) = Mutable) != 0))
          {
            CFArrayAppendValue(Mutable, v55);
          }
          uint64_t v57 = [NSNumber numberWithInt:v49];
          [v172 setObject:v57 forKeyedSubscript:v55];

          a1 = v171;
        }
        unint64_t v47 = *a9;
      }
      ++v49;
      v51 += 5;
      v48 += 24;
    }
    while (v49 < v47);
  }
  v157 = a9;
  long long v181 = 0u;
  long long v182 = 0u;
  long long v179 = 0u;
  long long v180 = 0u;
  uint64_t v58 = [v172 allKeys];
  uint64_t v59 = [v58 countByEnumeratingWithState:&v179 objects:v191 count:16];
  id v18 = v166;
  if (!v59) {
    goto LABEL_46;
  }
  uint64_t v60 = v59;
  uint64_t v61 = *(void *)v180;
LABEL_39:
  uint64_t v62 = 0;
  while (1)
  {
    if (*(void *)v180 != v61) {
      objc_enumerationMutation(v58);
    }
    CFDataRef v63 = *(const __CFData **)(*((void *)&v179 + 1) + 8 * v62);
    uint64_t v64 = [v172 objectForKey:v63];
    if (+[TrustEvaluator validatePublicKey:v63 trustRefs:v18])
    {
      int PublicWithData = PCSKeyCreatePublicWithData(v63, 0);
      unsigned __int16 v66 = WORD4(v187);
      uint64_t v67 = *v169;
      int v68 = [v64 intValue];
      uint64_t v69 = v67;
      id v18 = v166;
      if (_PCSVerifyHash(PublicWithData, v66, v69, (uint64_t)v170, (uint64_t)&v173[5 * v68], v165)) {
        break;
      }
    }

    if (v60 == ++v62)
    {
      uint64_t v60 = [v58 countByEnumeratingWithState:&v179 objects:v191 count:16];
      if (!v60)
      {
LABEL_46:

        uint64_t v70 = *(void *)(v171 + 176);
        if (v70) {
          uint64_t v70 = PCSIdentityGetServiceID(v70);
        }
        _PCSError(v165, 161, @"Unable to find a valid server signature for service: %d", v70);

        uint64_t v17 = v157;
        goto LABEL_67;
      }
      goto LABEL_39;
    }
  }

  uint64_t v17 = v157;
  uint64_t v24 = v165;
  a1 = v171;
  a8 = v159;
  a5 = v160;
  if (v159)
  {
LABEL_50:
    unint64_t v71 = *a8;
    if (v71)
    {
      uint64_t v72 = 0;
      for (unint64_t i = 0; i < v71; ++i)
      {
        uint64_t v74 = *((void *)a8 + 1);
        if (*(_DWORD *)(v74 + v72) == 9)
        {
          uint64_t v76 = *(void *)(v74 + v72 + 8);
          uint64_t v75 = *(void *)(v74 + v72 + 16);
          long long v177 = 0u;
          long long v178 = 0u;
          uint64_t v176 = 0;
          uint64_t v77 = decode_PCSSPKey(v75, v76, (uint64_t)&v177, (uint64_t)&v176);
          if (v77)
          {
            _PCSErrorASN1(v24, (uint64_t)"decode PCSSPKey", v77);
            goto LABEL_67;
          }
          CFTypeRef v78 = _PCSPublicIdentityCreateWithPCSSPKey((unsigned int *)&v177, v24);
          CFTypeRef v79 = v78;
          *(void *)(a1 + 160) = v78;
          if (v78) {
            CFRetain(v78);
          }
          *(void *)(a1 + 16_Block_object_dispose(&a9, 8) = v79;
          free_PCSSPKey((uint64_t)&v177);
          unint64_t v71 = *a8;
        }
        v72 += 24;
      }
    }
  }
LABEL_58:
  id v172 = a11;
  uint64_t v80 = v158;
  if (v163) {
    goto LABEL_106;
  }
  v81 = v169;
  id v82 = v172;
  if (v172 && *(unsigned char *)(a1 + 214))
  {
    *(void *)&long long v177 = 0;
    int Key = _PCSPublicIdentityGetKey((uint64_t)v172);
    if (_PCSVerifyHash(Key, WORD4(v187), *v81, (uint64_t)v170, v80, (const void **)&v177))
    {
      v84 = (void *)CFRetain(v82);
      goto LABEL_88;
    }
    CFIndex v89 = (const void *)v177;
    if ((void)v177)
    {
      *(void *)&long long v177 = 0;
      CFRelease(v89);
    }
  }
  if (*(_DWORD *)(a1 + 204) != 2)
  {
    CFIndex Count = CFArrayGetCount(v164);
    if (Count < 1)
    {
LABEL_104:
      if (!*(void *)(a1 + 152))
      {
        _PCSError(v24, 54, @"Couldn't find validation identity.");
        if (!*(void *)(a1 + 152)) {
          goto LABEL_67;
        }
      }
    }
    else
    {
      CFIndex v93 = Count;
      CFIndex v94 = 0;
      while (!*(void *)(a1 + 152))
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v164, v94);
        *(void *)&long long v177 = 0;
        uint64_t v96 = _PCSPublicIdentityGetKey((uint64_t)ValueAtIndex);
        int v97 = v96;
        uint64_t v98 = _PCSKeyCopyExportedPublicKey(v96);
        CFDataRef v99 = v98;
        if (v98)
        {
          if (CFDataGetLength(v98) == *(void *)v80)
          {
            BytePtr = CFDataGetBytePtr(v99);
            if (!memcmp(BytePtr, *(const void **)(v80 + 8), *(void *)v80)
              && (!*(unsigned char *)(v171 + 214)
               || _PCSVerifyHash(v97, WORD4(v187), *v169, (uint64_t)v170, v80, (const void **)&v177)))
            {
              CFTypeRef v101 = CFRetain(ValueAtIndex);
              *(void *)(v171 + 152) = v101;
            }
          }
        }
        v102 = (const void *)v177;
        if ((void)v177)
        {
          *(void *)&long long v177 = 0;
          CFRelease(v102);
        }
        a5 = v160;
        if (v99) {
          CFRelease(v99);
        }
        ++v94;
        a1 = v171;
        if (v93 == v94) {
          goto LABEL_104;
        }
      }
    }
    goto LABEL_106;
  }
  uint64_t v90 = *(void *)(a1 + 176);
  if (!v90) {
    PCSAbort("identity missing:sp->identity", v31, v32, v33, v34, v35, v36, v37, v155[0]);
  }
  if (*(unsigned char *)(a1 + 214))
  {
    int v91 = _PCSIdentityGetKey(v90);
    if (!_PCSVerifyHash(v91, WORD4(v187), *v81, (uint64_t)v170, v80, v24)) {
      goto LABEL_67;
    }
    uint64_t v90 = *(void *)(a1 + 176);
  }
  v84 = PCSIdentityCopyPublicIdentity(v90);
LABEL_88:
  *(void *)(a1 + 152) = v84;
  if (!v84) {
    goto LABEL_67;
  }
LABEL_106:
  if (v172) {
    *(void *)(a1 + 16_Block_object_dispose(&a9, 8) = CFRetain(v172);
  }
  *(void *)(a1 + 120) = v184;
  CFDataRef v23 = v168;
  v103 = v159;
  if ((void)v190 && *(_DWORD *)v190)
  {
    CFStringRef v104 = _PCSCreateBase64(*(void *)(*(void *)(v190 + 8) + 24), *(void *)(*(void *)(v190 + 8) + 16), 0);
    if (!v104)
    {
      _PCSErrorOOM(v24);
      goto LABEL_67;
    }
    CFStringRef v105 = v104;
    uint64_t v106 = (const void *)PCSIdentitySetCopyIdentity(*(void *)(a1 + 16), (uint64_t)v104);
    CFRelease(v105);
    if (v106)
    {
      PCSIdentitySetSetCurrentIdentity(*(void *)(a1 + 16), (uint64_t)v106);
      CFRelease(v106);
      goto LABEL_113;
    }
LABEL_67:
    uint64_t v86 = 0;
    CFDataRef v87 = 0;
    goto LABEL_176;
  }
LABEL_113:
  v165 = 0;
  if (!v103 || !a10)
  {
LABEL_165:
    size_t v174 = 0;
    v175 = 0;
    if (makeHmac(a1, v167, v23, (uint64_t)a5, &v174))
    {
      if (*v162 == v174)
      {
        long long v146 = v175;
        int v147 = cc_cmp_safe();
        free(v146);
        if (!v147)
        {
          CFDataRef v87 = 0;
          uint64_t v86 = 1;
          goto LABEL_169;
        }
        _PCSError(v24, 38, @"HMAC doesn't match");
      }
      else
      {
        free(v175);
      }
    }
    CFDataRef v87 = 0;
    uint64_t v86 = 0;
LABEL_169:
    CFDataRef v88 = v165;
    if (!v165) {
      goto LABEL_176;
    }
    goto LABEL_170;
  }
  unint64_t v107 = *v103;
  if (!v107)
  {
    v165 = 0;
    goto LABEL_165;
  }
  uint64_t v108 = 0;
  v165 = 0;
  id v172 = 0;
  char v109 = 0;
  CFAllocatorRef v164 = (CFAllocatorRef)*MEMORY[0x1E4F1CFA0];
  while (1)
  {
    uint64_t v110 = *((void *)v103 + 1) + 24 * v108;
    int v111 = *(_DWORD *)v110;
    BOOL v112 = *(_DWORD *)v110 == 11 || v111 == 8;
    if (!v112) {
      goto LABEL_158;
    }
    if (!v17)
    {
      _PCSError(v24, 140, @"require pppcs signature, but no unsigned attributes are present");
LABEL_198:
      CFDataRef v87 = 0;
      goto LABEL_161;
    }
    if ((v109 & 1) == 0) {
      break;
    }
    char v109 = 1;
LABEL_158:
    if (++v108 >= v107)
    {

      goto LABEL_165;
    }
  }
  CFIndex Length = *(void *)(v110 + 8);
  CFDataRef v114 = *(const UInt8 **)(v110 + 16);
  uint64_t v163 = v108;
  if (v172)
  {
LABEL_143:
    if (v111 == 11)
    {
      CFDataRef v132 = CFDataCreateWithBytesNoCopy(0, v114, Length, v164);
      if (!v132) {
        goto LABEL_198;
      }
      CFDataRef v133 = v132;
      CFDataRef v134 = CFDataCreate(0, (const UInt8 *)"PCSSignatureKeyIDEncryption", 27);
      CFDataRef v87 = PCSFPCopyDecryptedData(a1, 0, v134, v133, v24);
      if (v134) {
        CFRelease(v134);
      }
      CFRelease(v133);
      if (!v87) {
        goto LABEL_161;
      }
      CFDataRef v114 = CFDataGetBytePtr(v87);
      CFIndex Length = CFDataGetLength(v87);
    }
    else
    {
      CFDataRef v87 = 0;
    }
    long long v177 = 0u;
    long long v178 = 0u;
    uint64_t v176 = 0;
    uint64_t v135 = decode_PCSSPKey((uint64_t)v114, Length, (uint64_t)&v177, (uint64_t)&v176);
    if (v87) {
      CFRelease(v87);
    }
    if (v135)
    {
      _PCSErrorASN1(v24, (uint64_t)"decode PCSSPKey", v135);
      goto LABEL_198;
    }
    CFDataRef v87 = (const __CFData *)_PCSPublicIdentityCreateWithPCSSPKey((unsigned int *)&v177, v24);
    free_PCSSPKey((uint64_t)&v177);
    if (!v87) {
      goto LABEL_198;
    }
    uint64_t v136 = _PCSPublicIdentityGetKey((uint64_t)v87);
    int v137 = v136;
    long long v138 = _PCSKeyCopyExportedPublicKey(v136);
    if (!v138) {
      goto LABEL_161;
    }
    long long v139 = v138;
    long long v140 = [v172 objectForKey:v138];
    if (!v140)
    {
      _PCSError(v24, 140, @"did not find pppcs signature for key: %@", v139);

      goto LABEL_161;
    }
    v141 = v140;
    id v142 = v18;
    unsigned __int16 v143 = WORD4(v187);
    uint64_t v144 = *v169;
    int v145 = [v140 intValue];
    if (!_PCSVerifyHash(v137, v143, v144, (uint64_t)v170, (uint64_t)&v165[5 * v145], v24))
    {

      id v18 = v142;
      goto LABEL_161;
    }
    CFRelease(v87);

    v103 = v159;
    a5 = v160;
    unint64_t v107 = *v159;
    char v109 = 1;
    id v18 = v142;
    a1 = v171;
    CFDataRef v23 = v168;
    uint64_t v108 = v163;
    goto LABEL_158;
  }
  LODWORD(v157) = v111;
  CFIndex v158 = Length;
  CFTypeRef v115 = (const void **)malloc_type_calloc(*v17, 0x28uLL, 0x1080040EC46ECBEuLL);
  id v172 = [MEMORY[0x1E4F1CA60] dictionary];
  unint64_t v116 = *v17;
  v165 = v115;
  if (!v116)
  {
LABEL_142:
    CFIndex Length = v158;
    int v111 = (int)v157;
    goto LABEL_143;
  }
  v156 = v114;
  id v166 = v18;
  uint64_t v117 = 0;
  unint64_t v118 = 0;
  uint64_t v119 = v115;
  while (1)
  {
    uint64_t v120 = *((void *)v17 + 1) + v117;
    CFIndex v121 = *(void *)(v120 + 8);
    uint64_t v122 = *(const UInt8 **)(v120 + 16);
    if (*(_DWORD *)v120 == 7)
    {
      long long v128 = 0;
      goto LABEL_136;
    }
    if (*(_DWORD *)v120 == 10) {
      break;
    }
LABEL_140:
    ++v118;
    v119 += 5;
    v117 += 24;
    if (v118 >= v116)
    {
      id v18 = v166;
      CFDataRef v114 = v156;
      goto LABEL_142;
    }
  }
  CFDataRef v123 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(v120 + 16), v121, v164);
  if (!v123) {
    goto LABEL_188;
  }
  CFDataRef v124 = v123;
  CFDataRef v125 = CFDataCreate(0, (const UInt8 *)"PCSSignatureEncryption", 22);
  uint64_t v126 = a1;
  CFDataRef v127 = v125;
  long long v128 = PCSFPCopyDecryptedData(v126, 0, v125, v124, v24);
  if (v127) {
    CFRelease(v127);
  }
  CFRelease(v124);
  if (!v128) {
    goto LABEL_188;
  }
  uint64_t v122 = CFDataGetBytePtr(v128);
  CFIndex v121 = CFDataGetLength(v128);
  a1 = v171;
LABEL_136:
  *(void *)&long long v177 = 0;
  uint64_t v129 = decode_PCSSignature((uint64_t)v122, v121, (uint64_t)v119, (uint64_t)&v177);
  if (v128) {
    CFRelease(v128);
  }
  if (!v129)
  {
    id v130 = (void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytes:v119[1] length:*v119];
    long long v131 = [NSNumber numberWithInt:v118];
    [v172 setObject:v131 forKeyedSubscript:v130];

    unint64_t v116 = *v17;
    goto LABEL_140;
  }
  _PCSErrorASN1(v24, (uint64_t)"decode PCSSignature", v129);
LABEL_188:
  CFDataRef v87 = 0;
  id v18 = v166;
LABEL_161:

  CFDataRef v88 = v165;
LABEL_162:
  uint64_t v86 = 0;
  if (v88)
  {
LABEL_170:
    unint64_t v148 = *v17;
    if (v148)
    {
      unint64_t v149 = 0;
      uint64_t v150 = (uint64_t)v88;
      do
      {
        if (*(void *)(v150 + 24))
        {
          free_PCSSignature(v150);
          unint64_t v148 = *v17;
        }
        ++v149;
        v150 += 40;
      }
      while (v149 < v148);
    }
    free(v88);
  }
LABEL_176:
  if (v173)
  {
    unint64_t v151 = *v17;
    if (v151)
    {
      unint64_t v152 = 0;
      v153 = v173;
      do
      {
        if (v153[3])
        {
          free_PCSSignature((uint64_t)v153);
          unint64_t v151 = *v17;
        }
        ++v152;
        v153 += 5;
      }
      while (v152 < v151);
    }
    free(v173);
  }
  free_PCSObjectSignature((uint64_t)&v184);
  if (v87) {
    CFRelease(v87);
  }
LABEL_185:

  return v86;
}

void __CreateLightObject_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 72))
  {
    MEMORY[0x1AD11C7C0]();
    uint64_t v5 = ccsha256_di();
    ccaes_ecb_decrypt_mode();
    unint64_t v6 = (unint64_t)(cczp_bitlen() + 7) >> 3;
    if (CFDataGetLength(*(CFDataRef *)(a1 + 40)) >= v6 + 3)
    {
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
      rsize_t v8 = Length - (v6 + 3);
      if (v8 <= 0x28 && (v8 & 7) == 0)
      {
        v30[2] = v5;
        v30[4] = v30;
        uint64_t v10 = MEMORY[0x1F4188790](Length);
        v30[3] = v29;
        uint64_t v11 = MEMORY[0x1F4188790](v10);
        uint64_t v31 = &v29[-((v8 + 15) & 0xFFFFFFFFFFFFFFF0)];
        MEMORY[0x1F4188790](v11);
        uint64_t v12 = ccecb_context_size();
        MEMORY[0x1F4188790](v12);
        v30[1] = &v29[-v13];
        uint64_t v14 = cczp_bitlen();
        MEMORY[0x1F4188790](v14);
        unint64_t v34 = (unint64_t)(cczp_bitlen() + 7) >> 3;
        if (PCSIdentityGetPrivateKey(a3))
        {
          if (!ccec_compact_import_pub())
          {
            ccDRBGGetRngState();
            if (!ccecdh_compute_shared_secret())
            {
              CFDataRef v32 = PCSIdentityCopyExportedPublicKey(a3);
              if (CFDataGetLength(v32) == v6)
              {
                CFDataRef v15 = v32;
                CFDataGetLength(v32);
                CFDataGetBytePtr(v15);
                if (!cchkdf())
                {
                  ccecb_init();
                  size_t v33 = 32;
                  int v16 = ccwrap_auth_decrypt();
                  ccecb_context_size();
                  cc_clear();
                  if (!v16)
                  {
                    CFIndex v17 = v33;
                    id v18 = v31;
                    if (v33 == 32 || v33 == 16)
                    {
                      CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, 0);
                      CFDataSetLength(Mutable, v17);
                      *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 72) = Mutable;
                      int MutableBytePtr = CFDataGetMutableBytePtr(*(CFMutableDataRef *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                               + 24)
                                                                                   + 72));
                      memcpy(MutableBytePtr, v18, v33);
                      *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 80) = CreateKeyIDFromKey(*(const __CFData **)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 72));
                      uint64_t v21 = *(void *)(a1 + 48);
                      if (*(unsigned __int16 *)(v21 + v6 + 1 + v8) != *(unsigned __int16 *)CFDataGetBytePtr(*(CFDataRef *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 80)))
                      {
                        uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                        CFDataRef v23 = *(const void **)(v22 + 72);
                        if (v23)
                        {
                          *(void *)(v22 + 72) = 0;
                          CFRelease(v23);
                          uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                        }
                        uint64_t v24 = *(const void **)(v22 + 80);
                        if (v24)
                        {
                          *(void *)(v22 + 80) = 0;
                          CFRelease(v24);
                        }
                        goto LABEL_26;
                      }
                      CFIndex v25 = PCSIdentityCopyPublicIdentity(a3);
                      if (v25)
                      {
                        uint64_t v26 = v25;
                        uint64_t v27 = (const void *)ShareEntryCreate(v25, 0);
                        uint64_t PublicID = (const void *)PCSPublicIdentityGetPublicID((uint64_t)v26);
                        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 40), PublicID, v27);
                        if (v27) {
                          CFRelease(v27);
                        }
                        CFRelease(v26);
                      }
                    }
                    memset_s(v18, v8, 0, v8);
                  }
                }
              }
LABEL_26:
              if (v32) {
                CFRelease(v32);
              }
            }
          }
        }
      }
    }
  }
}

void __noMatchingIdentity_block_invoke(uint64_t a1, const void *a2)
{
}

CFTypeRef ProcessChainKeys(const __CFData *a1, uint64_t a2, const void **a3)
{
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  CFDataRef v6 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(a2 + 8), *(void *)a2, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (!v6)
  {
    CFTypeRef v20 = 0;
    goto LABEL_14;
  }
  CFDataRef v7 = v6;
  rsize_t v8 = PCSCloudKitShareTokenCopyDecryptedData(a1, v6);
  if (!v8)
  {
    CFTypeRef v20 = 0;
    CFDataRef v9 = v7;
    goto LABEL_13;
  }
  CFDataRef v9 = v8;
  BytePtr = CFDataGetBytePtr(v8);
  CFIndex Length = CFDataGetLength(v9);
  uint64_t v12 = decode_PCSSPKeyList((uint64_t)BytePtr, Length, (uint64_t)&v23, (uint64_t)&v22);
  if (v12)
  {
    _PCSErrorASN1(a3, (uint64_t)"decode PCSSPKeyList", v12);
  }
  else
  {
    CFTypeRef Mutable = PCSIdentitySetCreateMutable(a3);
    if (Mutable)
    {
      uint64_t v14 = Mutable;
      if (v23)
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        while (1)
        {
          CFDataRef v17 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(v24 + v15 + 24), *(void *)(v24 + v15 + 16), v5);
          if (!v17) {
            break;
          }
          CFDataRef v18 = v17;
          CFTypeRef v19 = PCSIdentityCreateWithExportedPrivateKey(v17, a3);
          CFRelease(v18);
          if (!v19) {
            break;
          }
          PCSIdentitySetAddIdentity((uint64_t)v14, (uint64_t)v19);
          CFRelease(v19);
          ++v16;
          v15 += 32;
          if (v16 >= v23) {
            goto LABEL_10;
          }
        }
        CFTypeRef v20 = 0;
      }
      else
      {
LABEL_10:
        CFTypeRef v20 = CFRetain(v14);
      }
      CFRelease(v14);
      goto LABEL_12;
    }
  }
  CFTypeRef v20 = 0;
LABEL_12:
  CFRelease(v7);
LABEL_13:
  CFRelease(v9);
LABEL_14:
  free_PCSSPKeyList((uint64_t)&v23);
  return v20;
}

uint64_t fillChainingKeys(const __CFData *a1, const __CFArray *a2, CFIndex **a3, void *a4, const void **a5)
{
  uint64_t v30 = 0;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x3010000000;
  uint64_t v24 = 0;
  CFIndex v25 = &v24;
  uint64_t v26 = 0x3010000000;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v27 = &unk_1AD014ACD;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  size_t v33 = &unk_1AD014ACD;
  v23[0] = MEMORY[0x1E4F143A8];
  v23[1] = 3221225472;
  v23[2] = __fillChainingKeys_block_invoke;
  v23[3] = &unk_1E5E6E378;
  v23[4] = &v30;
  v23[5] = &v24;
  uint64_t v10 = v23;
  v36.CFIndex length = CFArrayGetCount(a2);
  v36.CFIndex location = 0;
  CFArrayApplyFunction(a2, v36, (CFArrayApplierFunction)apply_block_1_0, v10);

  uint64_t v22 = 0;
  CFIndex v11 = length_PCSSPKeyList((uint64_t)(v25 + 4));
  CFTypeRef Mutable = CFDataCreateMutable(0, v11);
  uint64_t v13 = Mutable;
  if (!Mutable)
  {
    uint64_t v15 = 12;
    goto LABEL_5;
  }
  CFDataSetLength(Mutable, v11);
  int MutableBytePtr = CFDataGetMutableBytePtr(v13);
  uint64_t v15 = encode_PCSSPKeyList((uint64_t)&MutableBytePtr[v11 - 1], v11, (uint64_t)(v25 + 4), (uint64_t)&v22);
  if (v15)
  {
    CFRelease(v13);
LABEL_5:
    _PCSErrorASN1(a5, (uint64_t)"encode PCSSPKeyList", v15);
    uint64_t v16 = 0;
LABEL_15:
    free_PCSSPKeyList((uint64_t)(v31 + 4));
    free_PCSSPKeyList((uint64_t)(v25 + 4));
    _Block_object_dispose(&v24, 8);
    _Block_object_dispose(&v30, 8);
    return v16;
  }
  if (v11 == v22)
  {
    CFDataRef v17 = PCSCloudKitShareTokenCopyEncryptedData(a1, v13);
    if (!v17)
    {
      uint64_t v16 = 0;
      goto LABEL_14;
    }
    CFDataRef v18 = (CFIndex *)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    *a3 = v18;
    if (v18)
    {
      if (FillOctetString(v18, v17))
      {
        CFTypeRef v19 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
        *a4 = v19;
        if (v19)
        {
          uint64_t v20 = copy_PCSSPKeyList();
          if (!v20)
          {
            uint64_t v16 = 1;
LABEL_13:
            CFRelease(v17);
LABEL_14:
            CFRelease(v13);
            goto LABEL_15;
          }
          _PCSErrorASN1(a5, (uint64_t)"copy PCSSPKeyList", v20);
        }
      }
    }
    uint64_t v16 = 0;
    goto LABEL_13;
  }
  uint64_t result = asn1_abort();
  __break(1u);
  return result;
}

void sub_1ACFBB02C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __fillChainingKeys_block_invoke(uint64_t a1, uint64_t a2)
{
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t v4 = PCSIdentityCopyExportedPublicKey(a2);
  if (v4)
  {
    CFAllocatorRef v5 = v4;
    LODWORD(v_Block_object_dispose(&a9, 8) = 3;
    if (!FillOctetString((CFIndex *)&v9, v4)
      || add_PCSSPKeyList((unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 32)))
    {
LABEL_7:
      CFRelease(v5);
      return free_PCSSPKey((uint64_t)&v8);
    }
    CFRelease(v5);
    free_PCSSPKey((uint64_t)&v8);
    CFDataRef v6 = PCSIdentityCopyExportedPrivateKey(a2, 0);
    if (v6)
    {
      CFAllocatorRef v5 = v6;
      LODWORD(v_Block_object_dispose(&a9, 8) = 2;
      if (FillOctetString((CFIndex *)&v9, v6)) {
        add_PCSSPKeyList((unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 32));
      }
      goto LABEL_7;
    }
  }
  return free_PCSSPKey((uint64_t)&v8);
}

const UInt8 *__PCSFPUpdateMasterKeyIDAttribute_block_invoke(void *a1, CFDataRef theData)
{
  uint64_t result = CFDataGetBytePtr(theData);
  uint64_t v4 = a1[6];
  uint64_t v5 = a1[7];
  *(void *)(v4 + 16 * *(unsigned int *)(*(void *)(a1[4] + 8) + 24) + _Block_object_dispose(&a9, 8) = result;
  *(void *)(v4 + 16 * (*(_DWORD *)(*(void *)(a1[4] + 8) + 24))++) = v5;
  return result;
}

uint64_t PCSKeyRollingEnabled()
{
  return allow_rolling;
}

BOOL PCSManateeKeyRollingEnabled()
{
  if (allow_rolling) {
    BOOL v0 = allow_manatee_rolling == 0;
  }
  else {
    BOOL v0 = 1;
  }
  return !v0;
}

BOOL PCSMasterKeyRollingEnabled()
{
  if (allow_rolling) {
    BOOL v0 = allow_masterkey_rolling == 0;
  }
  else {
    BOOL v0 = 1;
  }
  return !v0;
}

BOOL PCSAllServiceKeyRollingEnabled()
{
  if (allow_rolling) {
    BOOL v0 = allow_allserviceidentity_rolling == 0;
  }
  else {
    BOOL v0 = 1;
  }
  return !v0;
}

uint64_t PCSSetKeyRollingFlags(uint64_t result, char a2, char a3, char a4)
{
  allow_rolling = result;
  allow_manatee_rolling = a2;
  allow_masterkey_rolling = a3;
  allow_allserviceidentity_rolling = a4;
  return result;
}

uint64_t PCSIdentitySetRollManateeServices(uint64_t a1, int a2, unsigned char *a3, const void **a4)
{
  v12[0] = 0;
  v12[1] = v12;
  v12[2] = 0x2020000000;
  time_t v13 = 0;
  time_t v13 = time(0);
  if (a3) {
    *a3 = 0;
  }
  if (allow_rolling) {
    BOOL v8 = allow_manatee_rolling == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    _PCSError(a4, 98, @"Identity rolling disabled");
  }
  else
  {
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3221225472;
    v10[2] = __PCSIdentitySetRollManateeServices_block_invoke;
    v10[3] = &unk_1E5E6E3F0;
    int v11 = a2;
    v10[4] = v12;
    void v10[5] = a1;
    v10[6] = a3;
    PCSServiceItemsInfoIteration(v10);
  }
  _Block_object_dispose(v12, 8);
  return 1;
}

void sub_1ACFBB434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __PCSIdentitySetRollManateeServices_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  if (a6 >= 1 && a5 && a4)
  {
    v24[5] = v6;
    v24[6] = v7;
    v24[0] = 0;
    CurrentCreationTime = PCSIdentitySetGetCurrentCreationTime(*(void *)(a1 + 40), a3, v24);
    if (CurrentCreationTime)
    {
      int v12 = *(_DWORD *)(a1 + 56);
      if (v12 == -1) {
        int v12 = a6;
      }
      if ((uint64_t)CurrentCreationTime + v12 <= *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
      {
        dispatch_semaphore_t v13 = dispatch_semaphore_create(0);
        v19[0] = MEMORY[0x1E4F143A8];
        v19[1] = 3221225472;
        _OWORD v19[2] = __PCSIdentitySetRollManateeServices_block_invoke_2;
        v19[3] = &unk_1E5E6E3C8;
        int v23 = *(_DWORD *)(a1 + 56);
        uint64_t v15 = *(void *)(a1 + 40);
        uint64_t v14 = *(void *)(a1 + 48);
        uint64_t v21 = a3;
        uint64_t v22 = v14;
        uint64_t v16 = v13;
        uint64_t v20 = v16;
        PCSIdentitySetCreateManatee(v15, a3, 0, v19);
        CFDataRef v17 = v24[0];
        if (v24[0])
        {
          v24[0] = 0;
          CFRelease(v17);
        }
        dispatch_semaphore_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
      }
    }
    else
    {
      CFDataRef v18 = v24[0];
      if (v24[0])
      {
        v24[0] = 0;
        CFRelease(v18);
      }
    }
  }
}

intptr_t __PCSIdentitySetRollManateeServices_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = pcsLogObjForScope("keyRoll");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      int v7 = *(_DWORD *)(a1 + 56);
      int v11 = 138412546;
      uint64_t v12 = v6;
      __int16 v13 = 1024;
      int v14 = v7;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "Rolled Service Identity %@ expiration %d", (uint8_t *)&v11, 0x12u);
    }

    **(unsigned char **)(a1 + 4_Block_object_dispose(&a9, 8) = 1;
  }
  else
  {
    if (v5)
    {
      uint64_t v8 = *(void *)(a1 + 40);
      int v9 = *(_DWORD *)(a1 + 56);
      int v11 = 138412546;
      uint64_t v12 = v8;
      __int16 v13 = 1024;
      int v14 = v9;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "Rolled Service Identity %@ expiration %d", (uint8_t *)&v11, 0x12u);
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t PCSEnvelopedKeyMaterialReadFrom(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  BOOL v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    int v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        uint64_t v24 = PBReaderReadData();
        uint64_t v25 = 8;
      }
      else
      {
        if (v17 != 2)
        {
          if (v17 == 1)
          {
            char v18 = 0;
            unsigned int v19 = 0;
            uint64_t v20 = 0;
            *(unsigned char *)(a1 + 28) |= 1u;
            while (1)
            {
              uint64_t v21 = *v3;
              unint64_t v22 = *(void *)(a2 + v21);
              if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
              *(void *)(a2 + v21) = v22 + 1;
              v20 |= (unint64_t)(v23 & 0x7F) << v18;
              if ((v23 & 0x80) == 0) {
                goto LABEL_34;
              }
              v18 += 7;
              BOOL v14 = v19++ >= 9;
              if (v14)
              {
                LODWORD(v20) = 0;
                goto LABEL_36;
              }
            }
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_34:
            if (*(unsigned char *)(a2 + *v5)) {
              LODWORD(v20) = 0;
            }
LABEL_36:
            *(_DWORD *)(a1 + 24) = v20;
          }
          else
          {
            uint64_t result = PBReaderSkipValueWithTag();
            if (!result) {
              return result;
            }
          }
          continue;
        }
        uint64_t v24 = PBReaderReadData();
        uint64_t v25 = 16;
      }
      uint64_t v26 = *(void **)(a1 + v25);
      *(void *)(a1 + v25) = v24;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

CFTypeRef PCSIdentitySetCreateNamed(const void *a1, const void **a2)
{
  CFTypeRef Mutable = PCSIdentitySetCreateMutable(a2);
  if (!Mutable) {
    return 0;
  }
  BOOL v5 = Mutable;
  if (addNamedServiceToSet((uint64_t)Mutable, 0, a1, 0)
    && (uint64_t v6 = _PCSIdentitySetCopyCurrentIdentityInternal((uint64_t)v5, kPCSServiceMaster, a2)) != 0)
  {
    int v7 = v6;
    if (addNamedServiceToSet((uint64_t)v5, (uint64_t)v6, a1, @"Bladerunner")
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, @"Hyperion")
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, @"Liverpool")
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceEscrow)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServicePianoMover)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceBackup)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceNotes)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceNews)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceFDE)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceSharing)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceKeyboardServices)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceActivities)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceGaming)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceiAD)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceBulkMail)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceBTPairing)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceBTAnnouncement)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceTTYCallHistory)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceContinuity)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceSafari)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSServiceCloudKitApple)
      && addNamedServiceToSet((uint64_t)v5, (uint64_t)v7, a1, kPCSHealthSync2))
    {
      CFTypeRef v8 = CFRetain(v5);
    }
    else
    {
      CFTypeRef v8 = 0;
    }
    CFRelease(v5);
  }
  else
  {
    CFTypeRef v8 = 0;
    int v7 = v5;
  }
  CFRelease(v7);
  return v8;
}

BOOL addNamedServiceToSet(uint64_t a1, uint64_t a2, CFTypeRef cf, void *a4)
{
  BOOL v5 = (const void *)__PCSIdentityCreateWithNameEmpty(a2, cf, a4);
  if (v5)
  {
    PCSIdentitySetAddIdentity(a1, (uint64_t)v5);
    CFRelease(v5);
  }
  return v5 != 0;
}

void sub_1ACFBDA34(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFBDAAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1ACFBDD84(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFBDE0C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFBDFB4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFBE17C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

__n128 _PCSUpdateKeychainForwardTable(uint64_t a1)
{
  xmmword_1E9A24AD0 = xmmword_1EB3B39D0;
  unk_1E9A24AE0 = *(_OWORD *)&off_1EB3B39E0;
  qword_1E9A24AF0 = (uint64_t)off_1EB3B39F0;
  savedPCSKeychainForwardTable = _PCSKeychainForwardTable;
  unk_1E9A24AC0 = *(_OWORD *)&qword_1EB3B39C0;
  long long v2 = *(_OWORD *)(a1 + 32);
  long long v1 = *(_OWORD *)(a1 + 48);
  long long v3 = *(_OWORD *)(a1 + 16);
  off_1EB3B39F0 = *(_UNKNOWN **)(a1 + 64);
  xmmword_1EB3B39D0 = v2;
  *(_OWORD *)&off_1EB3B39E0 = v1;
  *(_OWORD *)&qword_1EB3B39C0 = v3;
  __n128 result = *(__n128 *)a1;
  _PCSKeychainForwardTable = *(_OWORD *)a1;
  return result;
}

double _PCSResetKeychainForwardTable()
{
  xmmword_1EB3B39D0 = xmmword_1E9A24AD0;
  *(_OWORD *)&off_1EB3B39E0 = unk_1E9A24AE0;
  off_1EB3B39F0 = (_UNKNOWN *)qword_1E9A24AF0;
  double result = dbl_1E9A24AC0[0];
  _PCSKeychainForwardTable = savedPCSKeychainForwardTable;
  *(_OWORD *)&qword_1EB3B39C0 = *(_OWORD *)dbl_1E9A24AC0;
  return result;
}

uint64_t PCSIdentitySetCopyIdentity(uint64_t a1, uint64_t a2)
{
  if (!PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
    return 0;
  }
  return PCSIdentitySetCopyIdentityWithError(a1, a2, 0);
}

uint64_t PCSIdentitySetCopyIdentityWithError(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 8);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetCopyIdentityByKeyID(uint64_t a1, uint64_t a2)
{
  if (!PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 16) + 16);
  return v4(a1, a2);
}

const void *PCSIdentitySetCopyCurrentIdentityWithError(uint64_t a1, void *a2, const void **a3)
{
  long long v3 = PCSIdentitySetCopyCurrentIdentityPointer(a1, a2, a3);
  uint64_t v4 = (const void *)[v3 identity];
  BOOL v5 = v4;
  if (v4) {
    CFRetain(v4);
  }

  return v5;
}

id PCSIdentitySetCopyCurrentIdentityPointer(uint64_t a1, void *a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    if (!a2)
    {
      a2 = *(void **)(a1 + 32);
      if (!a2) {
        goto LABEL_6;
      }
    }
    if (!PCSServiceItemTypeIsManatee(a2) || CFEqual(**(CFTypeRef **)(a1 + 16), @"Memory")) {
      goto LABEL_6;
    }
    if (PCSIdentityGetCDPStatus(a1, (uint64_t)a2, a3))
    {
      _PCSError(a3, 130, @"Manatee is not available");
    }
    else
    {
      if (!PCSDaemonKeyRollIsPending(a1, a2))
      {
LABEL_6:
        uint64_t v6 = __PCSIdentitySetCopyCurrentIdentityPointerInternal(a1, (uint64_t)a2, a3);
        goto LABEL_9;
      }
      _PCSError(a3, 135, @"Cannot retrieve the current identity for %@ while a keyroll is pending", a2);
    }
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
  }
  uint64_t v6 = 0;
LABEL_9:
  return v6;
}

id __PCSIdentitySetCopyCurrentIdentityPointerInternal(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    if (!a2) {
      a2 = *(void *)(a1 + 32);
    }
    uint64_t v6 = (*(void (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 24))(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    uint64_t v6 = 0;
  }
  return v6;
}

const void *_PCSIdentitySetCopyCurrentIdentityInternal(uint64_t a1, uint64_t a2, const void **a3)
{
  long long v3 = __PCSIdentitySetCopyCurrentIdentityPointerInternal(a1, a2, a3);
  uint64_t v4 = (const void *)[v3 identity];
  BOOL v5 = v4;
  if (v4) {
    CFRetain(v4);
  }

  return v5;
}

void *PCSIdentitySetCopyCurrentPublicIdentityWithError(uint64_t a1, void *a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = PCSIdentitySetCopyCurrentIdentityWithError(a1, a2, a3);
    if (v6)
    {
      int v7 = v6;
      CFTypeRef v8 = PCSIdentityCopyPublicIdentity((uint64_t)v6);
      CFRelease(v7);
      return v8;
    }
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
  }
  return 0;
}

uint64_t PCSIdentitySetAddIdentity(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (!PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
    return 0;
  }
  CFTypeRef cf = 0;
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)(a1 + 16) + 40))(a1, a2, &cf);
  if ((v4 & 1) == 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)stat buf = 138412290;
    CFTypeRef v9 = cf;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSIdentitySetAddIdentity failed with: %@", buf, 0xCu);
  }
  CFTypeRef v5 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v5);
  }
  return v4;
}

uint64_t PCSIdentitySetAddIdentityWithError(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 40);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetRemoveIdentity(uint64_t a1, uint64_t a2)
{
  uint64_t result = PCSCurrentPersonaMatchesDSIDFromSet(a1);
  if (result)
  {
    CFTypeRef v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 16) + 48);
    return v5(a1, a2);
  }
  return result;
}

uint64_t PCSIdentitySetSetCurrentIdentity(uint64_t a1, uint64_t a2)
{
  uint64_t result = PCSCurrentPersonaMatchesDSIDFromSet(a1);
  if (result)
  {
    CFTypeRef v5 = *(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 16) + 56);
    return v5(a1, a2, 0);
  }
  return result;
}

uint64_t PCSIdentitySetSetCurrentIdentityWithError(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 56);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetUnsetCurrentIdentity(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 64);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t _PCSIdentitySetIsCurrentIdentity(uint64_t a1, uint64_t a2)
{
  uint64_t result = PCSCurrentPersonaMatchesDSIDFromSet(a1);
  if (result)
  {
    CFTypeRef v5 = *(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 16) + 32);
    return v5(a1, a2, 0);
  }
  return result;
}

uint64_t _PCSIdentitySetIsCurrentIdentityPreferCache(uint64_t a1, uint64_t a2)
{
  uint64_t result = PCSCurrentPersonaMatchesDSIDFromSet(a1);
  if (result)
  {
    CFTypeRef v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 16) + 32);
    return v5(a1, a2, 1);
  }
  return result;
}

uint64_t PCSIdentitySetEnumerateIdentities(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, id))(*(void *)(a1 + 16) + 72))(a1, a2, v5);
  }
  else {
    uint64_t v6 = 0;
  }

  return v6;
}

uint64_t PCSIdentitySetCopyIdentities(uint64_t a1, uint64_t a2)
{
  if (!PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 16) + 80);
  return v4(a1, a2);
}

uint64_t PCSIdentitySetCopyOrderedIdentities(uint64_t a1, uint64_t a2)
{
  if (!PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 16) + 88);
  return v4(a1, a2);
}

void PCSIdentitySetEnumeratePublicKeys(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
    (*(void (**)(uint64_t, id))(*(void *)(a1 + 16) + 96))(a1, v3);
  }
}

void PCSIdentitySetRepairCurrentIdentity(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v7 = a4;
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t, void (**)(id, void, CFTypeRef)))(*(void *)(a1 + 16) + 104))(a1, a2, a3, v7);
  }
  else if (v7)
  {
    CFTypeRef cf = 0;
    _PCSError(&cf, 152, @"Current persona does not match chosen dsid");
    v7[2](v7, 0, cf);
    CFTypeRef v8 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v8);
    }
  }
}

uint64_t PCSIdentitySetIsICDP(uint64_t a1, const void **a2)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, const void **))(*(void *)(a1 + 16) + 112);
    return v4(a1, a2);
  }
  else
  {
    _PCSError(a2, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetCompanionCircleMember(uint64_t a1, const void **a2)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, const void **))(*(void *)(a1 + 16) + 176);
    return v4(a1, a2);
  }
  else
  {
    _PCSError(a2, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetEnableCompanionCircleMember(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 184);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetIsICDPNetwork(uint64_t a1, const void **a2)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    return PCSIdentitySetIsICDPNetworkWithOptions(a1, 0, a2);
  }
  else
  {
    _PCSError(a2, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetIsICDPNetworkWithOptions(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 120);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetEnableICDP(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 128);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetIsPlesio(uint64_t a1, const void **a2)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, const void **))(*(void *)(a1 + 16) + 136);
    return v4(a1, a2);
  }
  else
  {
    _PCSError(a2, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetSetPlesio(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 144);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetIsWalrus(uint64_t a1, const void **a2)
{
  return PCSIdentitySetIsWalrusWithForceFetch(a1, 0, a2);
}

uint64_t PCSIdentitySetIsWalrusWithForceFetch(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 152);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetSetWalrus(uint64_t a1, uint64_t a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, const void **))(*(void *)(a1 + 16) + 160);
    return v6(a1, a2, a3);
  }
  else
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetCopySet(uint64_t a1, const void **a2)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t, const void **))(*(void *)(a1 + 16) + 168);
    return v4(a1, a2);
  }
  else
  {
    _PCSError(a2, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

BOOL _PCSRunningInUnitTests()
{
  return CFEqual(kPCSServiceName[0], @"ProtectedCloudStorage") == 0;
}

CFComparisonResult _PCSIdentityComparePublicKey(uint64_t a1, uint64_t a2)
{
  CFStringRef PublicKey = (const __CFString *)PCSIdentityGetPublicKey(a1);
  CFStringRef v4 = (const __CFString *)PCSIdentityGetPublicKey(a2);
  return CFStringCompare(PublicKey, v4, 0);
}

uint64_t PCSIdentitySetCreateExternalForm(uint64_t a1, uint64_t a2, char a3, const __CFArray *a4, const void **a5)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a2))
  {
    return PCSIdentitySetCreateExternalFormWithName(a1, a2, 0, a3, a4, a5);
  }
  else
  {
    _PCSError(a5, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
}

uint64_t PCSIdentitySetCreateExternalFormWithName(uint64_t a1, uint64_t a2, const __CFString *a3, char a4, const __CFArray *a5, const void **a6)
{
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a2) & 1) == 0)
  {
    _PCSError(a6, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
  uint64_t v52 = 0;
  uint64_t v53 = &v52;
  uint64_t v54 = 0x6010000000;
  uint64_t v55 = &unk_1AD014ACD;
  uint64_t v48 = 0;
  unint64_t v49 = &v48;
  uint64_t v50 = 0x2020000000;
  int v51 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    _PCSErrorOOM(a6);
    BOOL v14 = 0;
LABEL_53:
    free_PCSKeySet((uint64_t)(v53 + 4));
    _Block_object_dispose(&v48, 8);
    _Block_object_dispose(&v52, 8);
    return (uint64_t)v14;
  }
  if (!a2)
  {
    _PCSError(a6, 125, @"%s: identity missing", "CFDataRef PCSIdentitySetCreateExternalFormWithName(PCSLogContextRef, PCSIdentitySetRef, CFStringRef, BOOL, CFArrayRef, CFErrorRef *)");
LABEL_42:
    BOOL v14 = 0;
    CFArrayRef v16 = 0;
    CFDictionaryRef v15 = 0;
LABEL_43:
    CFArrayRef v17 = 0;
    goto LABEL_44;
  }
  if (a3) {
    char v13 = PCSCFStringToCString(a3);
  }
  else {
    char v13 = strdup("ks");
  }
  v53[4] = (uint64_t)v13;
  if (!PCSCurrentPersonaMatchesDSIDFromSet(a2)) {
    goto LABEL_42;
  }
  CFDictionaryRef v15 = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, void))(*(void *)(a2 + 16) + 80))(a2, 0);
  if (!v15)
  {
LABEL_56:
    BOOL v14 = 0;
    CFArrayRef v16 = 0;
    goto LABEL_43;
  }
  CFArrayRef v16 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (!v16)
  {
    _PCSErrorOOM(a6);
    goto LABEL_56;
  }
  CFArrayRef v17 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (!v17)
  {
    _PCSErrorOOM(a6);
    BOOL v14 = 0;
    goto LABEL_43;
  }
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = __PCSIdentitySetCreateExternalFormWithName_block_invoke;
  context[3] = &__block_descriptor_57_e15_v24__0r_v8r_v16l;
  char v47 = a4;
  void context[4] = a5;
  void context[5] = a1;
  void context[6] = v16;
  CFDictionaryApplyFunction(v15, (CFDictionaryApplierFunction)apply_block_2_2, context);
  v60.CFIndex length = CFArrayGetCount(v16);
  v60.CFIndex location = 0;
  CFArraySortValues(v16, v60, (CFComparatorFunction)_PCSIdentityComparePublicKey, 0);
  v45[0] = MEMORY[0x1E4F143A8];
  v45[1] = 3221225472;
  v45[2] = __PCSIdentitySetCreateExternalFormWithName_block_invoke_40;
  v45[3] = &unk_1E5E6E488;
  v45[4] = &v48;
  v45[5] = &v52;
  v45[6] = a6;
  v45[7] = a2;
  v45[8] = v17;
  v45[9] = Mutable;
  char v18 = v45;
  v61.CFIndex length = CFArrayGetCount(v16);
  v61.CFIndex location = 0;
  CFArrayApplyFunction(v16, v61, (CFArrayApplierFunction)apply_block_1_1, v18);

  v44[0] = MEMORY[0x1E4F143A8];
  v44[1] = 3221225472;
  v44[2] = __PCSIdentitySetCreateExternalFormWithName_block_invoke_2;
  v44[3] = &__block_descriptor_40_e10_v16__0r_v8l;
  v44[4] = Mutable;
  unsigned int v19 = v44;
  v62.CFIndex length = CFArrayGetCount(v17);
  v62.CFIndex location = 0;
  CFArrayApplyFunction(v17, v62, (CFArrayApplierFunction)apply_block_1_1, v19);

  if ((_os_feature_enabled_impl() & 1) == 0)
  {
    v43[0] = MEMORY[0x1E4F143A8];
    v43[1] = 3221225472;
    v43[2] = __PCSIdentitySetCreateExternalFormWithName_block_invoke_3;
    v43[3] = &__block_descriptor_48_e15_v24__0r_v8r_v16l;
    v43[4] = v17;
    v43[5] = a2;
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)apply_block_2_2, v43);
  }
  v63.CFIndex length = CFArrayGetCount(v16);
  v63.CFIndex location = 0;
  CFArraySortValues(v16, v63, (CFComparatorFunction)PCSIdentityCompareServiceNumber, 0);
  int64_t Count = CFArrayGetCount(v17);
  uint64_t v21 = malloc_type_calloc(Count, 0x18uLL, 0x10800404ACF7207uLL);
  unint64_t v22 = v53;
  v53[8] = (uint64_t)v21;
  if (Count >= 1)
  {
    uint64_t v23 = 0;
    CFIndex v24 = 0;
    do
    {
      uint64_t v25 = v22[8];
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v17, v24);
      __PCSFillCurrentsKey((uint64_t)ValueAtIndex, v25 + v23);
      ++v24;
      unint64_t v22 = v53;
      *((_DWORD *)v53 + 14) = v24;
      v23 += 24;
    }
    while (Count != v24);
  }
  uint64_t v27 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  v53[10] = (uint64_t)v27;
  if (!v27)
  {
    _PCSErrorOOM(a6);
    goto LABEL_37;
  }
  *uint64_t v27 = 5;
  if (a5)
  {
    *(_DWORD *)v53[10] |= 2u;
    if (CFArrayGetCount(a5) == 1)
    {
      v64.CFIndex location = 0;
      v64.CFIndex length = 1;
      if (CFArrayContainsValue(a5, v64, kPCSServiceFDE)) {
        *(_DWORD *)v53[10] |= 8u;
      }
    }
  }
  uint64_t v42 = 0;
  CFIndex v28 = length_PCSKeySet((uint64_t)(v53 + 4));
  uint64_t v29 = CFDataCreateMutable(0, v28);
  uint64_t v30 = v29;
  if (!v29) {
    goto LABEL_35;
  }
  CFDataSetLength(v29, v28);
  int MutableBytePtr = CFDataGetMutableBytePtr(v30);
  int v32 = encode_PCSKeySet((uint64_t)&MutableBytePtr[v28 - 1], v28, (uint64_t)(v53 + 4), (uint64_t)&v42);
  *((_DWORD *)v49 + 6) = v32;
  if (v32)
  {
    CFRelease(v30);
    uint64_t v33 = *((unsigned int *)v49 + 6);
    if (v33) {
      goto LABEL_36;
    }
    uint64_t v30 = 0;
  }
  else if (v28 != v42)
  {
    goto LABEL_61;
  }
  uint64_t v34 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  v53[9] = (uint64_t)v34;
  if (!v34)
  {
LABEL_60:
    BOOL v14 = 0;
    goto LABEL_45;
  }
  uint64_t v35 = malloc_type_malloc(0x20uLL, 0x40DE3AC1uLL);
  *(void *)(v53[9] + _Block_object_dispose(&a9, 8) = v35;
  CFRange v36 = (void *)v53[9];
  if (!v36[1])
  {
    _PCSErrorOOM(a6);
    goto LABEL_60;
  }
  *CFRange v36 = 32;
  ccsha256_di();
  CFDataGetLength(v30);
  CFDataGetBytePtr(v30);
  ccdigest();
  if (v30) {
    CFRelease(v30);
  }
  uint64_t v42 = 0;
  CFIndex v37 = length_PCSKeySet((uint64_t)(v53 + 4));
  uint64_t v38 = CFDataCreateMutable(0, v37);
  BOOL v14 = v38;
  if (!v38)
  {
LABEL_35:
    uint64_t v33 = 12;
    *((_DWORD *)v49 + 6) = 12;
    goto LABEL_36;
  }
  CFDataSetLength(v38, v37);
  uint64_t v39 = CFDataGetMutableBytePtr(v14);
  int v40 = encode_PCSKeySet((uint64_t)&v39[v37 - 1], v37, (uint64_t)(v53 + 4), (uint64_t)&v42);
  *((_DWORD *)v49 + 6) = v40;
  if (v40)
  {
    CFRelease(v14);
    uint64_t v33 = *((unsigned int *)v49 + 6);
    if (!v33)
    {
LABEL_37:
      BOOL v14 = 0;
LABEL_44:
      uint64_t v30 = 0;
      goto LABEL_45;
    }
LABEL_36:
    _PCSError(a6, 7, @"PCSKeySet encode error: %d", v33);
    goto LABEL_37;
  }
  if (v37 == v42)
  {
    CFRetain(v14);
    uint64_t v30 = v14;
LABEL_45:
    CFRelease(Mutable);
    if (v16) {
      CFRelease(v16);
    }
    if (v15) {
      CFRelease(v15);
    }
    if (v17) {
      CFRelease(v17);
    }
    if (v30) {
      CFRelease(v30);
    }
    goto LABEL_53;
  }
LABEL_61:
  uint64_t result = asn1_abort();
  __break(1u);
  return result;
}

void sub_1ACFBFB9C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 232), 8);
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Unwind_Resume(a1);
}

void __PCSIdentitySetCreateExternalFormWithName_block_invoke(uint64_t a1, int a2, void *value)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 56) && _PCSIdentityIsManatee((uint64_t)value)) {
    return;
  }
  if (!*(void *)(a1 + 32)) {
    goto LABEL_12;
  }
  uint64_t ServiceName = PCSIdentityGetServiceName((uint64_t)value);
  if (!ServiceName)
  {
    CFTypeRef v9 = PCSLogGetOSLog(*(void *)(a1 + 40));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138543362;
      uint64_t v11 = value;
      _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "Identity have unknown service: %{public}@", (uint8_t *)&v10, 0xCu);
    }

    goto LABEL_12;
  }
  uint64_t v6 = (const void *)ServiceName;
  CFArrayRef v7 = *(const __CFArray **)(a1 + 32);
  v13.CFIndex length = CFArrayGetCount(v7);
  v13.CFIndex location = 0;
  if (CFArrayContainsValue(v7, v13, v6))
  {
LABEL_12:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), value);
    return;
  }
  CFTypeRef v8 = PCSLogGetOSLog(*(void *)(a1 + 40));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 138543362;
    uint64_t v11 = value;
    _os_log_impl(&dword_1ACF98000, v8, OS_LOG_TYPE_DEFAULT, "Identity not selected for migration: %{public}@", (uint8_t *)&v10, 0xCu);
  }
}

void __PCSIdentitySetCreateExternalFormWithName_block_invoke_40(uint64_t a1, const void *a2)
{
  memset(v8, 0, sizeof(v8));
  if (__PCSIdentitySetGetPrivateKey((uint64_t)a2, v8, *(const void ***)(a1 + 48)))
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = add_PCSPrivateKeys((unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
    free_PCSPrivateKey((uint64_t)v8);
    if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      CFNumberRef v4 = PCSIdentityCopyServiceNumber((uint64_t)a2);
      uint64_t v5 = *(void *)(a1 + 56);
      if (PCSCurrentPersonaMatchesDSIDFromSet(v5)
        && (*(unsigned int (**)(uint64_t, const void *, void))(*(void *)(v5 + 16) + 32))(v5, a2, 0))
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 64), a2);
        uint64_t v6 = (CFMutableDictionaryRef *)(a1 + 72);
      }
      else
      {
        CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 72);
        uint64_t v6 = (CFMutableDictionaryRef *)(a1 + 72);
        if (CFDictionaryGetValue(v7, v4))
        {
LABEL_8:
          CFRelease(v4);
          return;
        }
      }
      CFDictionarySetValue(*v6, v4, a2);
      goto LABEL_8;
    }
  }
}

void __PCSIdentitySetCreateExternalFormWithName_block_invoke_2(uint64_t a1, uint64_t a2)
{
  CFNumberRef v3 = PCSIdentityCopyServiceNumber(a2);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v3);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t __PCSIdentitySetCreateExternalFormWithName_block_invoke_3(uint64_t a1, int a2, void *value)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), value);
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t result = PCSCurrentPersonaMatchesDSIDFromSet(v5);
  if (result)
  {
    CFDictionaryRef v7 = *(uint64_t (**)(uint64_t, void *, void))(*(void *)(v5 + 16) + 56);
    return v7(v5, value, 0);
  }
  return result;
}

uint64_t PCSIdentityCompareServiceNumber(uint64_t a1, uint64_t a2)
{
  unsigned int ServiceID = PCSIdentityGetServiceID(a1);
  unsigned int v4 = PCSIdentityGetServiceID(a2);
  if (ServiceID >= v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = -1;
  }
  if (ServiceID > v4) {
    return 1;
  }
  else {
    return v5;
  }
}

void *PCSIdentitySetCreateFromExternalForm(const __CFDictionary *a1, const __CFData *a2, _DWORD *a3, const void **a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, kPCSSetupForceValidateKey[0]);
    v11 = Value && (CFBooleanRef v9 = Value, v10 = CFGetTypeID(Value), v10 == CFBooleanGetTypeID()) && CFBooleanGetValue(v9) != 0;
    CFBooleanRef v12 = (const __CFBoolean *)CFDictionaryGetValue(a1, kPCSSetupDontImportManatee[0]);
    BOOL v15 = v12 && (v13 = v12, v14 = CFGetTypeID(v12), v14 == CFBooleanGetTypeID()) && CFBooleanGetValue(v13) != 0;
  }
  else
  {
    BOOL v15 = 0;
    BOOL v11 = 0;
  }
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  if (!a2)
  {
    _PCSError(a4, 126, @"%s: data missing", "PCSIdentitySetRef PCSIdentitySetCreateFromExternalForm(CFDictionaryRef, CFDataRef, uint32_t *, CFErrorRef *)");
LABEL_70:
    free_PCSKeySet((uint64_t)&v54);
    return 0;
  }
  BytePtr = CFDataGetBytePtr(a2);
  CFIndex Length = CFDataGetLength(a2);
  uint64_t v18 = decode_PCSKeySet((uint64_t)BytePtr, Length, (uint64_t)&v54, 0);
  if (v18)
  {
    _PCSError(a4, 8, @"PCSKeySet decode error: %d", v18);
    goto LABEL_70;
  }
  if (a3 && (void)v57) {
    *a3 = *(_DWORD *)v57;
  }
  CFDictionaryRef Mutable = PCSIdentitySetCreateMutable(a4);
  if (!Mutable) {
    goto LABEL_70;
  }
  uint64_t v20 = Mutable;
  uint64_t v21 = *((void *)&v56 + 1);
  if (*((void *)&v56 + 1))
  {
    if (**((void **)&v56 + 1) != 32)
    {
      uint64_t v53 = **((void **)&v56 + 1);
      CFStringRef v28 = @"checksum wrong length %d";
      goto LABEL_38;
    }
    *((void *)&v56 + 1) = 0;
    uint64_t v58 = 0;
    CFIndex v22 = length_PCSKeySet((uint64_t)&v54);
    uint64_t v23 = CFDataCreateMutable(0, v22);
    if (!v23)
    {
      uint64_t v27 = 12;
      goto LABEL_23;
    }
    CFIndex v24 = v23;
    CFDataSetLength(v23, v22);
    int MutableBytePtr = CFDataGetMutableBytePtr(v24);
    uint64_t v26 = encode_PCSKeySet((uint64_t)&MutableBytePtr[v22 - 1], v22, (uint64_t)&v54, (uint64_t)&v58);
    if (v26)
    {
      uint64_t v27 = v26;
      CFRelease(v24);
LABEL_23:
      *((void *)&v56 + 1) = v21;
      uint64_t v53 = v27;
      CFStringRef v28 = @"PCSKeySet encode error: %d";
      uint64_t v29 = a4;
      CFIndex v30 = 7;
LABEL_24:
      _PCSError(v29, v30, v28, v53);
      goto LABEL_25;
    }
    if (v22 != v58)
    {
      uint64_t v52 = (const void **)asn1_abort();
      return PCSIdentitySetCreateMutable(v52);
    }
    *((void *)&v56 + 1) = v21;
    ccsha256_di();
    CFDataGetLength(v24);
    CFDataGetBytePtr(v24);
    ccdigest();
    CFRelease(v24);
    int v32 = *(uint64_t **)(v21 + 8);
    uint64_t v33 = *v32;
    uint64_t v34 = v32[1];
    uint64_t v36 = v32[2];
    uint64_t v35 = v32[3];
    if ((void)buf != v33 || *((void *)&buf + 1) != v34 || v60 != v36 || v61 != v35)
    {
      CFStringRef v28 = @"checksum wrong";
LABEL_38:
      uint64_t v29 = a4;
      CFIndex v30 = 9;
      goto LABEL_24;
    }
  }
  if (DWORD2(v54))
  {
    uint64_t v40 = 0;
    unint64_t v41 = 0;
    uint64_t v42 = MEMORY[0x1E4F14500];
    do
    {
      LOBYTE(v5_Block_object_dispose(&a9, 8) = 0;
      if (!v11) {
        goto LABEL_46;
      }
      if (!_PCSValidateKey((void *)(v55 + v40), &v58, 0, 0, a4)) {
        goto LABEL_25;
      }
      if ((_BYTE)v58)
      {
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109120;
          DWORD1(buf) = v41;
          _os_log_impl(&dword_1ACF98000, v42, OS_LOG_TYPE_DEFAULT, "skipping key since its broken: %u", (uint8_t *)&buf, 8u);
        }
      }
      else
      {
LABEL_46:
        CFTypeRef v43 = PCSIdentityCreateWithPrivateKeyV1(v55 + v40, 1, a4);
        if (!v43) {
          goto LABEL_25;
        }
        uint64_t v44 = v43;
        if (v15 && _PCSIdentityIsManatee((uint64_t)v43))
        {
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v44;
            _os_log_impl(&dword_1ACF98000, v42, OS_LOG_TYPE_DEFAULT, "skipping import of manatee identity %@", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          PCSIdentitySetAddIdentity((uint64_t)v20, (uint64_t)v44);
        }
        CFRelease(v44);
      }
      ++v41;
      v40 += 24;
    }
    while (v41 < DWORD2(v54));
  }
  if (!DWORD2(v55))
  {
LABEL_64:
    CFRetain(v20);
    uint64_t v31 = v20;
    goto LABEL_65;
  }
  uint64_t v45 = 0;
  unint64_t v46 = 0;
  CFAllocatorRef v47 = (const __CFAllocator *)*MEMORY[0x1E4F1CFA0];
  while (1)
  {
    CFDataRef v48 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(v56 + v45 + 16), *(void *)(v56 + v45 + 8), v47);
    if (!v48) {
      break;
    }
    CFDataRef v49 = v48;
    if (!PCSCurrentPersonaMatchesDSIDFromSet((uint64_t)v20))
    {
      CFDataRef v50 = v49;
LABEL_62:
      CFRelease(v50);
      goto LABEL_63;
    }
    CFDataRef v50 = (CFDataRef)(*(uint64_t (**)(void *, CFDataRef))(v20[2] + 16))(v20, v49);
    CFRelease(v49);
    if (v50)
    {
      if (PCSCurrentPersonaMatchesDSIDFromSet((uint64_t)v20)) {
        (*(void (**)(void *, CFDataRef, void))(v20[2] + 56))(v20, v50, 0);
      }
      goto LABEL_62;
    }
LABEL_63:
    ++v46;
    v45 += 24;
    if (v46 >= DWORD2(v55)) {
      goto LABEL_64;
    }
  }
  _PCSErrorOOM(a4);
LABEL_25:
  uint64_t v31 = 0;
LABEL_65:
  free_PCSKeySet((uint64_t)&v54);
  CFRelease(v20);
  return v31;
}

CFTypeRef PCSIdentitySetCreateMutable(const void **a1)
{
  PCSIdentitySetGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    CFNumberRef v3 = Instance;
    _PCSIdentitySetInitialize(Instance);
    void v3[2] = &PCSIdentitySetMemory;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    v3[7] = Mutable;
    if (Mutable
      && (CFMutableDictionaryRef v5 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]), (v3[8] = v5) != 0)
      && (CFMutableDictionaryRef v6 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]), (v3[9] = v6) != 0))
    {
      *((unsigned char *)v3 + 8_Block_object_dispose(&a9, 8) = 0;
      CFTypeRef v7 = CFRetain(v3);
    }
    else
    {
      _PCSErrorOOM(a1);
      CFTypeRef v7 = 0;
    }
    CFRelease(v3);
  }
  else
  {
    _PCSErrorOOM(a1);
    return 0;
  }
  return v7;
}

uint64_t PCSIdentitySetGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __PCSIdentitySetGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = &PCSIdentitySetGetTypeID_sPCSIdentitySetGetTypeIDSingleton;
  if (PCSIdentitySetGetTypeID_sPCSIdentitySetGetTypeIDOnce != -1) {
    dispatch_once(&PCSIdentitySetGetTypeID_sPCSIdentitySetGetTypeIDOnce, block);
  }
  return PCSIdentitySetGetTypeID_sPCSIdentitySetGetTypeIDSingleton;
}

uint64_t __PCSIdentitySetGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void PCSIdentitySetDestroy(void *a1)
{
  long long v2 = (void *)a1[3];
  a1[3] = 0;

  CFNumberRef v3 = (const void *)a1[4];
  if (v3)
  {
    a1[4] = 0;
    CFRelease(v3);
  }
  unsigned int v4 = (const void *)a1[5];
  if (v4)
  {
    a1[5] = 0;
    CFRelease(v4);
  }
  CFMutableDictionaryRef v5 = (const void *)a1[6];
  if (v5)
  {
    a1[6] = 0;
    CFRelease(v5);
  }
  CFMutableDictionaryRef v6 = (const void *)a1[9];
  if (v6)
  {
    a1[9] = 0;
    CFRelease(v6);
  }
  CFTypeRef v7 = (const void *)a1[7];
  if (v7)
  {
    a1[7] = 0;
    CFRelease(v7);
  }
  CFTypeRef v8 = (const void *)a1[8];
  if (v8)
  {
    a1[8] = 0;
    CFRelease(v8);
  }
  CFBooleanRef v9 = (const void *)a1[10];
  if (v9)
  {
    a1[10] = 0;
    CFRelease(v9);
  }
}

BOOL PCSIdentitySetCompare(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

CFStringRef PCSIdentitySetCopyDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, @"<PCSIdentitySet:%p>", a1);
}

void _PCSIdentitySetInitialize(void *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 0x40uLL, "PCSIdentitySet.%p", a1);
  dispatch_queue_t v2 = dispatch_queue_create(__str, 0);
  CFNumberRef v3 = (void *)a1[3];
  a1[3] = v2;
}

uint64_t *PCSIdentitySetCreateClassic(CFDictionaryRef theDict, const void *a2, uint64_t *a3)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  if (!theDict) {
    goto LABEL_5;
  }
  CFBooleanRef Value = (__CFString *)CFDictionaryGetValue(theDict, kPCSSetupDSID[0]);
  CFTypeRef v7 = Value;
  if (!Value) {
    goto LABEL_6;
  }
  CFTypeID v8 = CFGetTypeID(Value);
  if (v8 != CFStringGetTypeID())
  {
    _PCSError((const void **)a3, 47, @"DSID not a string");
    return 0;
  }
  if (!CFEqual(v7, kPCSSetupDSIDAny[0]))
  {
LABEL_6:
    if (PCSCurrentPersonaMatchesDSID(v7)) {
      goto LABEL_7;
    }
    if (!a3) {
      return a3;
    }
    CFIndex v22 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v23 = kPCSErrorDomain;
    uint64_t v25 = *MEMORY[0x1E4F28568];
    v26[0] = @"Current persona does not match chosen dsid";
    CFIndex v24 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v26 forKeys:&v25 count:1];
    *a3 = [v22 errorWithDomain:v23 code:152 userInfo:v24];

    return 0;
  }
LABEL_5:
  CFTypeRef v7 = 0;
LABEL_7:
  CFBooleanRef v9 = [(__CFDictionary *)theDict objectForKeyedSubscript:kPCSSetupGuitarfish[0]];
  int v10 = [v9 BOOLValue];

  CFDataRef v20 = (const __CFData *)__PCSCopyFromiCloudKeychain(v7, v10, 0, v11, v12, v13, v14, v15);
  if (!v20)
  {
    CFDataRef v20 = (const __CFData *)__PCSCopyFromKeychain(v10, 0, v7, (const void **)a3, v16, v17, v18, v19);
    if (!v20) {
      return 0;
    }
  }
  a3 = PCSIdentitySetCreateFromExternalForm(theDict, v20, 0, (const void **)a3);
  if (a3)
  {
    if (a2) {
      CFRetain(a2);
    }
    a3[4] = (uint64_t)a2;
  }
  CFRelease(v20);
  return a3;
}

BOOL _PCSKeychainAmendCKKSEntry(uint64_t a1, __CFDictionary *a2)
{
  unsigned int v4 = PCSIdentityCopyExportedPublicKey(a1);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t v6 = PCSIdentityCopyPublicKeyInfo(a1);
  BOOL v7 = v6 != 0;
  if (v6)
  {
    CFTypeID v8 = (const void *)v6;
    CFNumberRef v9 = PCSIdentityCopyServiceNumber(a1);
    if (v9)
    {
      CFDictionarySetValue(a2, (const void *)*MEMORY[0x1E4F3B7A8], v5);
      CFDictionarySetValue(a2, (const void *)*MEMORY[0x1E4F3B7A0], v8);
      CFDictionarySetValue(a2, (const void *)*MEMORY[0x1E4F3B7B0], v9);
    }
    CFRelease(v5);
    CFRelease(v8);
    if (!v9) {
      return 0;
    }
  }
  else
  {
    CFNumberRef v9 = v5;
  }
  CFRelease(v9);
  return v7;
}

CFTypeRef _PCSIdentityCopyKeychainAttributes(uint64_t a1)
{
  uint64_t v27 = 0;
  uint64_t ServiceName = PCSIdentityGetServiceName(a1);
  if (!ServiceName) {
    return 0;
  }
  CFNumberRef v3 = (void *)ServiceName;
  CFNumberRef v25 = IdentityCopyServiceNumber(a1, 0);
  if (!v25) {
    return 0;
  }
  CFStringRef PublicKey = (const __CFString *)PCSIdentityGetPublicKey(a1);
  if (!PublicKey
    || (v28.location = 0, v28.length = 8, (CFStringRef v5 = CFStringCreateWithSubstring(0, PublicKey, v28)) == 0))
  {
    CFNumberRef v22 = v25;
LABEL_20:
    CFRelease(v22);
    return 0;
  }
  CFStringRef v6 = v5;
  if (!PCSIdentityGetKeyID(a1) || (CFStringRef v26 = CFStringCreateWithFormat(0, 0, @"PCS %@ - %@", v3, v6)) == 0)
  {
    CFRelease(v25);
    CFNumberRef v22 = (CFNumberRef)v6;
    goto LABEL_20;
  }
  CFDictionaryRef v7 = PCSIdentityCopyExportedPrivateKey(a1, &v27);
  if (v7)
  {
    key = (void *)*MEMORY[0x1E4F3B978];
    uint64_t v23 = *MEMORY[0x1E4F3B998];
    PCSServiceItemGetAccessClassByName(v3);
    CFTypeID v8 = (const void *)*MEMORY[0x1E4F1CFD0];
    int AccessGroupByName = PCSServiceItemGetAccessGroupByName(v3);
    CFNumberRef v10 = v25;
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(AccessGroupByName, v11, v12, v13, v14, v15, v16, v17, key, v23);
    ServiceViewHint = (const void *)PCSIdentityGetServiceViewHint(a1);
    if (ServiceViewHint) {
      CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B870], ServiceViewHint);
    }
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B878], v8);
    }
    _PCSKeychainAmendCKKSEntry(a1, MutableForCFTypesWith);
    CFTypeRef v20 = CFRetain(MutableForCFTypesWith);
  }
  else
  {
    MutableForCFTypesWith = 0;
    CFTypeRef v20 = 0;
    CFNumberRef v10 = v25;
  }
  CFRelease(v10);
  CFRelease(v26);
  CFRelease(v6);
  if (v7) {
    CFRelease(v7);
  }
  if (MutableForCFTypesWith) {
    CFRelease(MutableForCFTypesWith);
  }
  return v20;
}

CFNumberRef IdentityCopyServiceNumber(uint64_t a1, int a2)
{
  int ServiceID = PCSIdentityGetServiceID(a1);
  if (!ServiceID) {
    return 0;
  }
  int valuePtr = ServiceID | a2;
  return CFNumberCreate(0, kCFNumberIntType, &valuePtr);
}

id _PCSIdentitySetGetAltDSIDorPCSAccountsModel(uint64_t a1)
{
  id v2 = *(id *)(a1 + 48);
  if (!v2)
  {
    id v3 = *(id *)(a1 + 40);
    if (v3)
    {
      unsigned int v4 = v3;
      id v2 = +[PCSAccountsModel altDSIDForDSID:v3];
    }
    else
    {
      id v2 = 0;
    }
  }
  return v2;
}

uint64_t _PCSIdentitySetGetAltDSID(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t _PCSIdentitySetGetDSID(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t PCSIdentityCreateFromPersistentReference(void *a1, void *a2)
{
  return PCSIdentityCreateFromPersistentReferenceAndGetSHA1(a1, a2, 0);
}

uint64_t PCSIdentityCreateFromPersistentReferenceAndGetSHA1(void *a1, void *a2, void *a3)
{
  v33[3] = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  CFTypeRef cf = 0;
  id v26 = 0;
  uint64_t v7 = *MEMORY[0x1E4F3BC70];
  v32[0] = *MEMORY[0x1E4F3BC68];
  v32[1] = v7;
  v33[0] = MEMORY[0x1E4F1CC38];
  v33[1] = MEMORY[0x1E4F1CC38];
  v32[2] = *MEMORY[0x1E4F3BD40];
  v33[2] = v5;
  uint64_t v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v33 forKeys:v32 count:3];
  CFNumberRef v9 = (void *)v8;
  if (a3) {
    *a3 = 0;
  }
  int v10 = _PCSKeychainForwardTable(v8, &v26);
  if (!v10)
  {
    id v13 = v26;
    if (a3)
    {
      *a3 = [v26 objectForKeyedSubscript:*MEMORY[0x1E4F3B830]];
    }
    if (v6)
    {
      int v14 = [v13 objectForKeyedSubscript:*MEMORY[0x1E4F3B848]];
      char v15 = [v14 isEqualToString:v6];

      if ((v15 & 1) == 0)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          int v18 = MEMORY[0x1E4F14500];
          int v19 = "invalid identity: incorrect dsid";
          goto LABEL_22;
        }
LABEL_23:
        uint64_t v12 = 0;
LABEL_24:

        goto LABEL_25;
      }
    }
    int v16 = [v13 objectForKeyedSubscript:*MEMORY[0x1E4F3B5C0]];
    int v17 = [v16 isEqualToString:kPCSAccount[0]];

    if (v17)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v18 = MEMORY[0x1E4F14500];
        int v19 = "invalid identity: incorrect acct";
LABEL_22:
        _os_log_impl(&dword_1ACF98000, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 2u);
        goto LABEL_23;
      }
      goto LABEL_23;
    }
    CFTypeRef v20 = [v13 objectForKeyedSubscript:*MEMORY[0x1E4F3B838]];
    int v21 = [v20 isEqualToString:kPCSServiceName[0]];

    if ((v21 & 1) == 0)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v18 = MEMORY[0x1E4F14500];
        int v19 = "invalid identity: incorrect sdmn";
        goto LABEL_22;
      }
      goto LABEL_23;
    }
    CFNumberRef v22 = [v13 objectForKeyedSubscript:*MEMORY[0x1E4F3BD38]];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v23 = PCSIdentityCreateWithKeychainAttributes((const __CFDictionary *)v13, &cf);
      if (v23)
      {
        uint64_t v12 = (uint64_t)v23;
        _PCSIdentitySetPersistentReference((uint64_t)v23, v5);
        _PCSIdentityCheckPCSAttributes(v12, v13);
LABEL_33:

        goto LABEL_24;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        id v29 = v5;
        __int16 v30 = 2112;
        CFTypeRef v31 = cf;
        _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to parse identity item: %@: %@", buf, 0x16u);
      }
      CFTypeRef v25 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v25);
      }
    }
    else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "invalid identity: no data", buf, 2u);
    }
    uint64_t v12 = 0;
    goto LABEL_33;
  }
  int v11 = v10;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    id v29 = v5;
    __int16 v30 = 1024;
    LODWORD(v31) = v11;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to fetch item: %@: %d", buf, 0x12u);
  }
  uint64_t v12 = 0;
LABEL_25:

  return v12;
}

CFTypeRef PCSIdentitySetCreateKeychain(const __CFDictionary *a1, const void *a2, const void **a3)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    _PCSError(a3, 47, @"Options parameter missing");
    return 0;
  }
  PCSIdentitySetGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (!Instance)
  {
    _PCSErrorOOM(a3);
    return 0;
  }
  uint64_t v7 = Instance;
  _PCSIdentitySetInitialize(Instance);
  v7[2] = &PCSIdentitySetKeychain;
  CFBooleanRef Value = CFDictionaryGetValue(a1, kPCSSetupDSID[0]);
  if (Value && (CFNumberRef v9 = Value, v10 = CFGetTypeID(Value), v10 == CFStringGetTypeID()))
  {
    int v11 = CFDictionaryGetValue(a1, kPCSSetupAltDSID[0]);
    uint64_t v12 = v11;
    if (!v11 || (CFTypeID v13 = CFGetTypeID(v11), v13 == CFStringGetTypeID()))
    {
      if (kPCSSetupDSIDAny[0] && CFEqual(v9, kPCSSetupDSIDAny[0]))
      {
        v7[5] = 0;
LABEL_13:
        if (a2) {
          CFRetain(a2);
        }
        v7[4] = a2;
        CFTypeRef v14 = CFRetain(v7);
        goto LABEL_16;
      }
      CFRetain(v9);
      v7[5] = v9;
      if (v12) {
        CFRetain(v12);
      }
      v7[6] = v12;
      if (PCSCurrentPersonaMatchesDSIDFromSet((uint64_t)v7)) {
        goto LABEL_13;
      }
      if (a3)
      {
        char v15 = (void *)MEMORY[0x1E4F28C58];
        int v16 = kPCSErrorDomain;
        uint64_t v19 = *MEMORY[0x1E4F28568];
        v20[0] = @"Current persona does not match chosen dsid";
        int v17 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v20 forKeys:&v19 count:1];
        *a3 = [v15 errorWithDomain:v16 code:152 userInfo:v17];
      }
      CFRelease(v7);
      return 0;
    }
    _PCSError(a3, 47, @"altDSID not a string");
  }
  else
  {
    _PCSError(a3, 47, @"DSID not a string");
  }
  CFTypeRef v14 = 0;
LABEL_16:
  CFRelease(v7);
  return v14;
}

__CFDictionary *PCSCopyPIIClearedOptions(CFDictionaryRef theDict)
{
  if (!theDict) {
    return 0;
  }
  MutableCFDataRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  id v2 = MutableCopy;
  if (MutableCopy)
  {
    _PCSHideKeyValue(MutableCopy, kPCSSetupAuthToken[0]);
    _PCSHideKeyValue(v2, kPCSSetupDSID[0]);
    _PCSHideKeyValue(v2, kPCSSetupAltDSID[0]);
    _PCSHideKeyValue(v2, kPCSSetupPassword[0]);
    _PCSHideKeyValue(v2, kPCSSetupRawPassword[0]);
    _PCSHideKeyValue(v2, kPCSSetupRecoveryToken[0]);
    _PCSHideKeyValue(v2, kPCSSetupVerifierIterationCount[0]);
    _PCSHideKeyValue(v2, kPCSSetupVerifierSalt[0]);
    _PCSHideKeyValue(v2, kPCSSetupUsername[0]);
    _PCSHideKeyValue(v2, kPCSSetupHSMContent[0]);
    _PCSHideKeyValue(v2, kPCSSetupHSMMetaData[0]);
  }
  return v2;
}

void _PCSHideKeyValue(__CFDictionary *a1, const void *a2)
{
  if (CFDictionaryContainsKey(a1, a2))
  {
    CFDictionarySetValue(a1, a2, @"<<VALUE>>");
  }
}

CFTypeRef PCSIdentitySetCreate(const __CFDictionary *a1, const void *a2, const void **a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFBooleanRef Value = CFDictionaryGetValue(a1, kPCSSetupLogContext[0]);
    uint64_t v7 = PCSCopyPIIClearedOptions(a1);
    uint64_t v8 = PCSLogGetOSLog((uint64_t)Value);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138543618;
      int v11 = a2;
      __int16 v12 = 2114;
      CFTypeID v13 = v7;
      _os_log_impl(&dword_1ACF98000, v8, OS_LOG_TYPE_DEFAULT, "PCSIdentitySetCreate: %{public}@ %{public}@", (uint8_t *)&v10, 0x16u);
    }

    if (v7) {
      CFRelease(v7);
    }
  }
  return PCSIdentitySetCreateKeychain(a1, a2, a3);
}

uint64_t PCSIdentitySetCopyService(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    CFRetain(*(CFTypeRef *)(a1 + 32));
  }
  return v1;
}

void _PCSIdentitySetSetService(uint64_t a1, CFTypeRef cf)
{
  unsigned int v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    *(void *)(a1 + 32) = 0;
    CFRelease(v4);
  }
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 32) = cf;
}

const void *PCSIdentitySetGetCurrentCreationTime(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t result = _PCSIdentitySetCopyCurrentIdentityInternal(a1, a2, a3);
  if (result)
  {
    id v5 = result;
    uint64_t CreationTime = PCSIdentityGetCreationTime((uint64_t)result, a3);
    CFRelease(v5);
    return (const void *)CreationTime;
  }
  return result;
}

uint64_t _PCSIdentitySetCopyPersonaIdentifier(uint64_t a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  uint64_t v1 = *(NSObject **)(a1 + 24);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___PCSIdentitySetCopyPersonaIdentifier_block_invoke;
  v4[3] = &unk_1E5E6E4D0;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync(v1, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void _PCSIdentitySetSetPersonaIdentifier(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(NSObject **)(a1 + 24);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = ___PCSIdentitySetSetPersonaIdentifier_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = a1;
  void v3[5] = a2;
  dispatch_sync(v2, v3);
}

uint64_t apply_block_2_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t apply_block_1_1(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFTypeRef MemoryCopyIdentity(uint64_t a1, const void *a2, const void **a3)
{
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) == 0)
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
  CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
  if (!Value)
  {
    _PCSError(a3, 27, @"service %@ not found", a2);
    return 0;
  }
  uint64_t v7 = Value;
  uint64_t v8 = *(void **)(a1 + 32);
  if (v8)
  {
    unsigned int IndexByName = PCSServiceItemGetIndexByName(v8);
    if (IndexByName != PCSIdentityGetServiceID((uint64_t)v7)) {
      return 0;
    }
  }
  return CFRetain(v7);
}

const void *MemoryCopyByKeyID(uint64_t a1, const void *a2)
{
  if (!PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
    return 0;
  }
  CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
  uint64_t v5 = Value;
  if (Value) {
    CFRetain(Value);
  }
  return v5;
}

PCSCurrentIdentity *MemoryCopyCurrentIdentity(uint64_t a1, void *a2, const void **a3)
{
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    if (a2 || (a2 = *(void **)(a1 + 32)) != 0)
    {
      NumberByName = (PCSCurrentIdentity *)PCSServiceItemGetNumberByName(a2);
      if (!NumberByName) {
        goto LABEL_9;
      }
      CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), NumberByName);
      if (Value)
      {
        NumberByName = [[PCSCurrentIdentity alloc] initWithIdentity:Value currentItemPointerModificationTime:0];
        goto LABEL_9;
      }
      __int16 v12 = a2;
      CFStringRef v8 = @"Identity of service type %@ missing in memory keyset";
    }
    else
    {
      CFStringRef v8 = @"service missing";
    }
    CFNumberRef v9 = a3;
    CFIndex v10 = 27;
  }
  else
  {
    CFStringRef v8 = @"Current persona does not match chosen dsid";
    CFNumberRef v9 = a3;
    CFIndex v10 = 152;
  }
  _PCSError(v9, v10, v8, v12);
  NumberByName = 0;
LABEL_9:
  return NumberByName;
}

BOOL MemoryIsCurrentIdentity(uint64_t a1, const void *a2)
{
  CFNumberRef v4 = PCSIdentityCopyServiceNumber((uint64_t)a2);
  if (!v4) {
    return 0;
  }
  CFNumberRef v5 = v4;
  CFBooleanRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), v4);
  if (Value) {
    BOOL v7 = CFEqual(Value, a2) != 0;
  }
  else {
    BOOL v7 = 0;
  }
  CFRelease(v5);
  return v7;
}

uint64_t MemoryAddIdentity(uint64_t a1, const void *a2, const void **a3)
{
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) == 0)
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
  if (*(unsigned char *)(a1 + 88))
  {
    _PCSError(a3, 107, @"Memory set readonly");
    return 0;
  }
  BOOL v7 = *(__CFDictionary **)(a1 + 56);
  CFStringRef PublicKey = (const void *)PCSIdentityGetPublicKey((uint64_t)a2);
  CFDictionarySetValue(v7, PublicKey, a2);
  CFNumberRef v9 = *(__CFDictionary **)(a1 + 64);
  KeyID = (const void *)PCSIdentityGetKeyID((uint64_t)a2);
  CFDictionarySetValue(v9, KeyID, a2);
  CFNumberRef v11 = PCSIdentityCopyServiceNumber((uint64_t)a2);
  if (v11)
  {
    CFNumberRef v12 = v11;
    if (!CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), v11))
    {
      if (PCSCurrentPersonaMatchesDSIDFromSet(a1)) {
        (*(void (**)(uint64_t, const void *, void))(*(void *)(a1 + 16) + 56))(a1, a2, 0);
      }
    }
    CFRelease(v12);
  }
  return 1;
}

uint64_t MemoryRemoveIdentity(uint64_t a1, const void *a2)
{
  uint64_t result = PCSCurrentPersonaMatchesDSIDFromSet(a1);
  if (result)
  {
    if (*(unsigned char *)(a1 + 88))
    {
      return 0;
    }
    else
    {
      uint64_t result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
      if (result)
      {
        uint64_t v5 = result;
        char v6 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 16) + 32))(a1, result, 0);
        uint64_t result = 0;
        if ((v6 & 1) == 0)
        {
          BOOL v7 = *(__CFDictionary **)(a1 + 64);
          KeyID = (const void *)PCSIdentityGetKeyID(v5);
          CFDictionaryRemoveValue(v7, KeyID);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 56), a2);
          return 1;
        }
      }
    }
  }
  return result;
}

CFNumberRef MemorySetCurrentIdentity(uint64_t a1, const void *a2, const void **a3)
{
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) == 0)
  {
    _PCSError(a3, 152, @"Current persona does not match chosen dsid");
    return 0;
  }
  if (*(unsigned char *)(a1 + 88))
  {
    _PCSError(a3, 107, @"Memory set readonly");
    return 0;
  }
  CFNumberRef result = PCSIdentityCopyServiceNumber((uint64_t)a2);
  if (result)
  {
    BOOL v7 = result;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), result, a2);
    CFStringRef v8 = *(__CFDictionary **)(a1 + 56);
    CFStringRef PublicKey = (const void *)PCSIdentityGetPublicKey((uint64_t)a2);
    CFDictionarySetValue(v8, PublicKey, a2);
    CFIndex v10 = *(__CFDictionary **)(a1 + 64);
    KeyID = (const void *)PCSIdentityGetKeyID((uint64_t)a2);
    CFDictionarySetValue(v10, KeyID, a2);
    CFRelease(v7);
    return (CFNumberRef)1;
  }
  return result;
}

uint64_t MemoryUnsetCurrentIdentity(uint64_t a1, void *a2)
{
  NumberByName = (const void *)PCSServiceItemGetNumberByName(a2);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 72), NumberByName);
  return 1;
}

uint64_t MemoryEnumerateIdentities(uint64_t a1, const void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = PCSCurrentPersonaMatchesDSIDFromSet(a1);
  if (v6)
  {
    CFBooleanRef Value = *(const void **)(a1 + 32);
    if (a2)
    {
      CFTypeID v8 = CFGetTypeID(a2);
      if (v8 == CFDictionaryGetTypeID() && !Value) {
        CFBooleanRef Value = CFDictionaryGetValue((CFDictionaryRef)a2, kPCSSetupService[0]);
      }
    }
    CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 56);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __MemoryEnumerateIdentities_block_invoke;
    _OWORD v11[3] = &unk_1E5E6E518;
    CFTypeID v13 = Value;
    id v12 = v5;
    CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)apply_block_2_2, v11);
  }
  return v6;
}

CFMutableDictionaryRef MemoryCopyIdentities(uint64_t a1, const void *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef v5 = Mutable;
  if (Mutable)
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = __MemoryCopyIdentities_block_invoke;
    v7[3] = &__block_descriptor_40_e27_v16__0___PCSIdentityData__8l;
    v7[4] = Mutable;
    if ((MemoryEnumerateIdentities(a1, a2, v7) & 1) == 0)
    {
      CFRelease(v5);
      return 0;
    }
  }
  return v5;
}

CFArrayRef MemoryCopyOrderedIdentities(uint64_t a1, void *a2)
{
  uint64_t v19 = 0;
  CFTypeRef v20 = &v19;
  uint64_t v21 = 0x2020000000;
  char v22 = 0;
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) != 0
    && (CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510])) != 0)
  {
    CFMutableDictionaryRef v5 = MemoryCopyCurrentIdentity(a1, a2, 0);
    uint64_t v6 = v5;
    if (v5
      && (uint64_t v7 = [v5 identity], _PCSIdentityValidate(v7, (unsigned char *)v20 + 24, 0))
      && !*((unsigned char *)v20 + 24))
    {
      CFArrayAppendValue(Mutable, (const void *)[v6 identity]);
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v8 = 0;
    }
    CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 56);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    void v14[2] = __MemoryCopyOrderedIdentities_block_invoke;
    v14[3] = &unk_1E5E6E560;
    int v17 = a2;
    id v10 = v6;
    id v15 = v10;
    int v16 = &v19;
    int v18 = Mutable;
    CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)apply_block_2_2, v14);
    v11.CFIndex length = CFArrayGetCount(Mutable) - v8;
    if (v11.length >= 2)
    {
      v11.CFIndex location = v8;
      CFArraySortValues(Mutable, v11, (CFComparatorFunction)_PCSIdentityComparePublicKey, 0);
    }
    CFArrayRef Copy = CFArrayCreateCopy(0, Mutable);
    CFRelease(Mutable);
  }
  else
  {
    CFArrayRef Copy = 0;
  }
  _Block_object_dispose(&v19, 8);
  return Copy;
}

void sub_1ACFC2318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void MemoryEnumeratePublicKeys(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (PCSCurrentPersonaMatchesDSIDFromSet(a1))
  {
    CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 56);
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = __MemoryEnumeratePublicKeys_block_invoke;
    v5[3] = &unk_1E5E6E518;
    uint64_t v7 = a1;
    id v6 = v3;
    CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)apply_block_2_2, v5);
  }
}

uint64_t MemoryRepairCurrentIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(a4 + 16))(a4, 1, 0);
  }
  return result;
}

uint64_t MemoryIsICDP(int a1, const void **a2)
{
  return 0;
}

uint64_t MemoryIsICDPNetwork(int a1, int a2, const void **a3)
{
  return 0;
}

uint64_t MemorySetICDP(int a1, int a2, const void **a3)
{
  return 0;
}

uint64_t MemoryIsPlesio(int a1, const void **a2)
{
  return 0;
}

uint64_t MemorySetPlesio(int a1, int a2, const void **a3)
{
  return 0;
}

uint64_t MemoryIsWalrus(int a1, int a2, const void **a3)
{
  return 0;
}

uint64_t MemorySetWalrus(int a1, int a2, const void **a3)
{
  return 0;
}

CFTypeRef MemoryCopySet(CFDictionaryRef *a1, const void **a2)
{
  PCSIdentitySetGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    CFMutableDictionaryRef v5 = Instance;
    _PCSIdentitySetInitialize(Instance);
    v5[2] = &PCSIdentitySetMemory;
    MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0, 0, a1[7]);
    v5[7] = MutableCopy;
    if (MutableCopy
      && (CFMutableDictionaryRef v7 = CFDictionaryCreateMutableCopy(0, 0, a1[8]), (v5[8] = v7) != 0)
      && (CFMutableDictionaryRef v8 = CFDictionaryCreateMutableCopy(0, 0, a1[9]), (v5[9] = v8) != 0))
    {
      *((unsigned char *)v5 + 8_Block_object_dispose(&a9, 8) = 0;
      CFTypeRef v9 = CFRetain(v5);
    }
    else
    {
      _PCSErrorOOM(a2);
      CFTypeRef v9 = 0;
    }
    CFRelease(v5);
  }
  else
  {
    _PCSErrorOOM(a2);
    return 0;
  }
  return v9;
}

uint64_t MemoryIsCircleMember(int a1, const void **a2)
{
  return 0;
}

uint64_t MemorySetCircleMember(int a1, int a2, const void **a3)
{
  return 0;
}

uint64_t __MemoryEnumerateIdentities_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFMutableDictionaryRef v5 = *(const void **)(a1 + 40);
  if (v5)
  {
    CFTypeID v6 = CFGetTypeID(v5);
    if (v6 == CFStringGetTypeID())
    {
      uint64_t result = PCSIdentityGetServiceName(a3);
      CFMutableDictionaryRef v8 = *(const void **)(a1 + 40);
      if (result && v8)
      {
        uint64_t result = CFEqual((CFTypeRef)result, v8);
        if (!result) {
          return result;
        }
      }
      else if ((const void *)result != v8)
      {
        return result;
      }
    }
  }
  CFTypeRef v9 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  return v9();
}

void __MemoryCopyIdentities_block_invoke(uint64_t a1, const void *a2)
{
  id v3 = *(__CFDictionary **)(a1 + 32);
  CFStringRef PublicKey = (const void *)PCSIdentityGetPublicKey((uint64_t)a2);
  CFDictionarySetValue(v3, PublicKey, a2);
}

void __MemoryCopyOrderedIdentities_block_invoke(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t ServiceName = (const void *)PCSIdentityGetServiceName((uint64_t)a3);
  CFTypeID v6 = *(const void **)(a1 + 48);
  if (ServiceName && v6)
  {
    if (!CFEqual(ServiceName, v6)) {
      return;
    }
  }
  else if (ServiceName != v6)
  {
    return;
  }
  if (!CFEqual(a3, (CFTypeRef)[*(id *)(a1 + 32) identity])
    && _PCSIdentityValidate((uint64_t)a3, (unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0)
    && !*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    CFMutableDictionaryRef v7 = *(__CFArray **)(a1 + 56);
    CFArrayAppendValue(v7, a3);
  }
}

uint64_t __MemoryEnumeratePublicKeys_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDictionaryRef v4 = *(const void **)(*(void *)(a1 + 40) + 32);
  if (v4)
  {
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 == CFStringGetTypeID())
    {
      uint64_t result = PCSIdentityGetServiceName(a3);
      CFMutableDictionaryRef v8 = *(const void **)(*(void *)(a1 + 40) + 32);
      if (result && v8)
      {
        uint64_t result = CFEqual((CFTypeRef)result, v8);
        if (!result) {
          return result;
        }
      }
      else if ((const void *)result != v8)
      {
        return result;
      }
    }
  }
  CFTypeRef v9 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  return v9();
}

CFTypeRef KeychainCopyIdentity(uint64_t a1, uint64_t a2, CFErrorRef *a3, int a4, int a5, int a6, int a7, int a8)
{
  CFTypeRef v49 = 0;
  CFRange v11 = (const void *)*MEMORY[0x1E4F1CFD0];
  uint64_t v48 = *MEMORY[0x1E4F1CFD0];
  uint64_t v46 = *MEMORY[0x1E4F1CFD0];
  uint64_t v47 = *MEMORY[0x1E4F3BC68];
  uint64_t v44 = *MEMORY[0x1E4F3BB88];
  uint64_t v45 = *MEMORY[0x1E4F3BC70];
  uint64_t v43 = *MEMORY[0x1E4F3BB80];
  uint64_t v40 = kPCSServiceName[0];
  uint64_t v41 = *MEMORY[0x1E4F3B5C0];
  uint64_t v39 = *MEMORY[0x1E4F3B838];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, (int)a3, a4, a5, a6, a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  if (!MutableForCFTypesWith) {
    return 0;
  }
  CFTypeID v13 = MutableForCFTypesWith;
  uint64_t v14 = *(const void **)(a1 + 40);
  if (v14) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B848], v14);
  }
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F3B878], v11);
  }
  uint64_t v15 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  uint64_t v16 = _PCSKeychainForwardTable(v13, &v49);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v15;
  if (v16)
  {
    PCSSecError(v16, a3, @"Failed to find identity %@ in keychain: %d", a2, v16, v39, v40, v41, a2, v43, v44, v45, v46, v47, v48, 0);
  }
  else if (v49)
  {
    CFTypeID v17 = CFGetTypeID(v49);
    if (v17 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)v49);
      if (Count >= 1)
      {
        CFIndex v19 = Count;
        CFDictionaryRef v20 = 0;
        CFDictionaryRef v21 = 0;
        CFIndex v22 = 0;
        uint64_t v23 = (const void *)*MEMORY[0x1E4F3BD38];
        CFIndex v24 = (const void *)*MEMORY[0x1E4F3B870];
        do
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v49, v22);
          CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, v23);
          if (Value)
          {
            CFTypeID v27 = CFGetTypeID(Value);
            if (v27 == CFDataGetTypeID())
            {
              CFRange v28 = CFDictionaryGetValue(ValueAtIndex, v24);
              char v29 = IsViewHintPreferred((uint64_t)v28);
              if (v20) {
                CFDictionaryRef v30 = v20;
              }
              else {
                CFDictionaryRef v30 = ValueAtIndex;
              }
              if (v29) {
                CFDictionaryRef v21 = ValueAtIndex;
              }
              else {
                CFDictionaryRef v20 = v30;
              }
            }
          }
          ++v22;
        }
        while (v19 != v22);
        if (v21)
        {
          CFTypeRef v31 = PCSIdentityCreateWithKeychainAttributes(v21, 0);
          int v32 = v31;
          CFDictionaryRef v33 = v21;
LABEL_24:
          UpdateCKKSIdentity((uint64_t)v31, v33);
          if (v32
            && ((uint64_t v34 = *(void **)(a1 + 32)) == 0
             || (unsigned int IndexByName = PCSServiceItemGetIndexByName(v34),
                 IndexByName == PCSIdentityGetServiceID((uint64_t)v32))))
          {
            CFTypeRef v36 = CFRetain(v32);
          }
          else
          {
            CFTypeRef v36 = 0;
          }
          goto LABEL_32;
        }
        if (v20)
        {
          CFTypeRef v31 = PCSIdentityCreateWithKeychainAttributes(v20, 0);
          int v32 = v31;
          CFDictionaryRef v33 = v20;
          goto LABEL_24;
        }
      }
    }
  }
  CFTypeRef v36 = 0;
  int v32 = 0;
LABEL_32:
  CFRelease(v13);
  CFTypeRef v37 = v49;
  if (v49)
  {
    CFTypeRef v49 = 0;
    CFRelease(v37);
  }
  if (v32) {
    CFRelease(v32);
  }
  return v36;
}

void *KeychainCopyByKeyID(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  CFTypeRef v34 = 0;
  CFTypeRef v9 = (const void *)*MEMORY[0x1E4F1CFD0];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  if (!MutableForCFTypesWith) {
    return 0;
  }
  CFRange v11 = MutableForCFTypesWith;
  id v12 = *(const void **)(a1 + 40);
  if (v12) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B848], v12);
  }
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v11, (const void *)*MEMORY[0x1E4F3B878], v9);
  }
  uint64_t v13 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  int v14 = _PCSKeychainForwardTable(v11, &v34);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v13;
  if (!v14)
  {
    if (v34)
    {
      CFTypeID v15 = CFGetTypeID(v34);
      if (v15 == CFArrayGetTypeID())
      {
        CFIndex Count = CFArrayGetCount((CFArrayRef)v34);
        if (Count >= 1)
        {
          CFIndex v17 = Count;
          CFDictionaryRef v18 = 0;
          CFIndex v19 = 0;
          CFDictionaryRef v20 = 0;
          CFDictionaryRef v21 = (const void *)*MEMORY[0x1E4F3BD38];
          CFIndex v22 = (const void *)*MEMORY[0x1E4F3B870];
          do
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v34, v19);
            CFBooleanRef Value = CFDictionaryGetValue(ValueAtIndex, v21);
            if (Value)
            {
              CFTypeID v25 = CFGetTypeID(Value);
              if (v25 == CFDataGetTypeID())
              {
                id v26 = CFDictionaryGetValue(ValueAtIndex, v22);
                char v27 = IsViewHintPreferred((uint64_t)v26);
                if (v18) {
                  CFDictionaryRef v28 = v18;
                }
                else {
                  CFDictionaryRef v28 = ValueAtIndex;
                }
                if (v27) {
                  CFDictionaryRef v20 = ValueAtIndex;
                }
                else {
                  CFDictionaryRef v18 = v28;
                }
              }
            }
            ++v19;
          }
          while (v17 != v19);
          if (v20)
          {
            char v29 = PCSIdentityCreateWithKeychainAttributes(v20, 0);
            CFDictionaryRef v30 = v29;
            CFDictionaryRef v31 = v20;
LABEL_24:
            UpdateCKKSIdentity((uint64_t)v29, v31);
            goto LABEL_26;
          }
          if (v18)
          {
            char v29 = PCSIdentityCreateWithKeychainAttributes(v18, 0);
            CFDictionaryRef v30 = v29;
            CFDictionaryRef v31 = v18;
            goto LABEL_24;
          }
        }
      }
    }
  }
  CFDictionaryRef v30 = 0;
LABEL_26:
  CFRelease(v11);
  CFTypeRef v32 = v34;
  if (v34)
  {
    CFTypeRef v34 = 0;
    CFRelease(v32);
  }
  return v30;
}

id KeychainCopyCurrentIdentity(uint64_t a1, void *a2, const void **a3)
{
  v56[1] = *MEMORY[0x1E4F143B8];
  if (!a2
    || !*(void *)(a1 + 40)
    || (PCSServiceItemTypeIsManatee(a2) & 1) == 0 && !_os_feature_enabled_impl()
    || !CFEqual(kPCSServiceName[0], @"ProtectedCloudStorage"))
  {
    goto LABEL_10;
  }
  if (!PCSSupportsPersonaMultiuser())
  {
    if (!_PCSIsMultiDevice(0)) {
      goto LABEL_17;
    }
    if (PCSServiceItemTypeIsManatee(a2))
    {
      _PCSError(a3, 145, @"No CKKS on multiuser device");
LABEL_35:
      CFMutableDictionaryRef v7 = 0;
      goto LABEL_11;
    }
LABEL_10:
    CFMutableDictionaryRef v7 = KeychainCopyXIdentityWithCount(a1, a2, 0, a3);
    goto LABEL_11;
  }
  CFTypeID v6 = pcsLogObjForScope("ckks");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, v6, OS_LOG_TYPE_DEFAULT, "KeychainCopyCurrentIdentity: ATVSupportsMU enabled", buf, 2u);
  }

LABEL_17:
  if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) == 0)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "dsid does not match current persona's account dsid", buf, 2u);
    }
    uint64_t v23 = (void *)MEMORY[0x1E4F28C58];
    CFIndex v24 = kPCSErrorDomain;
    uint64_t v55 = *MEMORY[0x1E4F28568];
    v56[0] = @"dsid does not match current persona's account dsid";
    CFTypeID v25 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v56 forKeys:&v55 count:1];
    id v26 = [v23 errorWithDomain:v24 code:146 userInfo:v25];

    if (a3) {
      *a3 = v26;
    }

    goto LABEL_35;
  }
  *(void *)long long buf = 0;
  CFDataRef v50 = buf;
  uint64_t v51 = 0x3032000000;
  uint64_t v52 = __Block_byref_object_copy__0;
  uint64_t v53 = __Block_byref_object_dispose__0;
  id v54 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = &v45;
  uint64_t v47 = 0x2020000000;
  uint64_t v48 = 0;
  v43[0] = 0;
  v43[1] = v43;
  v43[2] = 0x2020000000;
  char v44 = 0;
  dispatch_queue_t v9 = dispatch_queue_create("KeychainCopyCurrentIdentity", 0);
  dispatch_semaphore_t v10 = dispatch_semaphore_create(0);
  CFRange v11 = off_1EB3B39F0;
  int AccessGroupByName = PCSServiceItemGetAccessGroupByName(a2);
  CKKSViewByName = PCSServiceItemGetCKKSViewByName(a2);
  v35[0] = MEMORY[0x1E4F143A8];
  v35[1] = 3221225472;
  v35[2] = __KeychainCopyCurrentIdentity_block_invoke;
  v35[3] = &unk_1E5E6E5B0;
  int v14 = v9;
  CFTypeRef v36 = v14;
  uint64_t v38 = v43;
  uint64_t v41 = a2;
  uint64_t v42 = a1;
  uint64_t v39 = &v45;
  uint64_t v40 = buf;
  CFTypeID v15 = v10;
  CFTypeRef v37 = v15;
  ((void (*)(__CFString *, void *, __CFString *, void, void *))v11)(AccessGroupByName, a2, CKKSViewByName, 0, v35);
  dispatch_time_t v16 = dispatch_time(0, 1000000000 * (void)*(&xmmword_1EB3B39D0 + 1));
  if (dispatch_semaphore_wait(v15, v16))
  {
    CFIndex v17 = pcsLogObjForScope("ckks");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(cf) = 0;
      _os_log_impl(&dword_1ACF98000, v17, OS_LOG_TYPE_DEFAULT, "Failed to fetch identity from security within timeout", (uint8_t *)&cf, 2u);
    }

    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __KeychainCopyCurrentIdentity_block_invoke_130;
    block[3] = &unk_1E5E6E038;
    void block[4] = v43;
    void block[5] = &v45;
    dispatch_sync(v14, block);
  }
  int v18 = _os_feature_enabled_impl();
  CFIndex v19 = v46;
  if (!v18) {
    goto LABEL_39;
  }
  if (!v46[3]
    || (PCSServiceItemTypeIsManatee(a2) & 1) != 0
    || (CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)v46[3]), !CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E4F3B468]))
    || CFErrorGetCode((CFErrorRef)v46[3]) != 61)
  {
    CFTypeRef cf = 0;
    if (!*((void *)v50 + 5))
    {
      if (PCSServiceItemTypeIsManatee(a2))
      {
        CFTypeRef v28 = cf;
      }
      else
      {
        char IsWalrus = KeychainIsWalrus(a1, 0, &cf);
        CFTypeRef v28 = cf;
        if (cf) {
          char v30 = 1;
        }
        else {
          char v30 = IsWalrus;
        }
        if ((v30 & 1) == 0)
        {
          CFTypeRef v32 = (const void *)v46[3];
          if (v32)
          {
            v46[3] = 0;
            CFRelease(v32);
          }
          goto LABEL_29;
        }
      }
      if (v28)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
          KeychainCopyCurrentIdentity_cold_1((uint64_t *)&cf);
        }
        CFTypeRef v31 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v31);
        }
      }
    }
    if (!*((void *)v50 + 5) && (CFEqual(a2, kPCSServiceMaster) || CFEqual(a2, kPCSServiceFDE)))
    {
      CFDictionaryRef v21 = (const void *)v46[3];
      if (!v21) {
        goto LABEL_29;
      }
      goto LABEL_28;
    }
    CFIndex v19 = v46;
LABEL_39:
    char v27 = (const void *)v19[3];
    if (v27)
    {
      if (a3)
      {
        *a3 = v27;
      }
      else
      {
        v19[3] = 0;
        CFRelease(v27);
      }
    }
    id v22 = *((id *)v50 + 5);
    goto LABEL_45;
  }
  CFDictionaryRef v21 = (const void *)v46[3];
  if (v21)
  {
LABEL_28:
    v46[3] = 0;
    CFRelease(v21);
  }
LABEL_29:
  KeychainCopyXIdentityWithCount(a1, a2, 0, a3);
  id v22 = (id)objc_claimAutoreleasedReturnValue();
LABEL_45:
  CFMutableDictionaryRef v7 = v22;

  _Block_object_dispose(v43, 8);
  _Block_object_dispose(&v45, 8);
  _Block_object_dispose(buf, 8);

LABEL_11:
  return v7;
}

void sub_1ACFC34CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v31 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t KeychainIsCurrentIdentity(uint64_t a1, uint64_t a2, char a3)
{
  CFDictionaryRef v30 = 0;
  int valuePtr = 0;
  if (a3)
  {
    uint64_t CachedCurrentBit = _PCSIdentityGetCachedCurrentBit(a2);
    CFTypeID v6 = (const void *)*MEMORY[0x1E4F1CFD0];
    uint64_t v7 = CachedCurrentBit == *MEMORY[0x1E4F1CFD0];
    if (CachedCurrentBit) {
      return v7;
    }
  }
  else
  {
    CFTypeID v6 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  key = (void *)*MEMORY[0x1E4F3B978];
  uint64_t v9 = *MEMORY[0x1E4F3B998];
  int PublicKey = PCSIdentityGetPublicKey(a2);
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(PublicKey, v10, v11, v12, v13, v14, v15, v16, key, v9);
  if (!MutableForCFTypesWith) {
    return 0;
  }
  int v18 = MutableForCFTypesWith;
  CFIndex v19 = *(const void **)(a1 + 40);
  if (v19) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B848], v19);
  }
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v18, (const void *)*MEMORY[0x1E4F3B878], v6);
  }
  uint64_t v20 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  int v21 = _PCSKeychainForwardTable(v18, &v30);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v20;
  if (!v21
    && v30
    && (CFTypeID v22 = CFGetTypeID(v30), v22 == CFDictionaryGetTypeID())
    && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v30, (const void *)*MEMORY[0x1E4F3B8C0])) != 0
    && (CFNumberRef v24 = Value, v25 = CFGetTypeID(Value), v25 == CFNumberGetTypeID())
    && CFNumberGetValue(v24, kCFNumberSInt32Type, &valuePtr))
  {
    uint64_t v7 = BYTE2(valuePtr) & 1;
  }
  else
  {
    uint64_t v7 = 0;
  }
  CFRelease(v18);
  CFDictionaryRef v26 = v30;
  if (v30)
  {
    CFDictionaryRef v30 = 0;
    CFRelease(v26);
  }
  return v7;
}

BOOL KeychainAddIdentity(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  CFTypeRef cf = 0;
  if (!*(void *)(a1 + 40)) {
    return 0;
  }
  CFDictionaryRef v4 = (__CFDictionary *)_PCSIdentityCopyKeychainAttributes(a2);
  if (!v4) {
    return 0;
  }
  CFMutableDictionaryRef v5 = v4;
  CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E4F3BC80], (const void *)*MEMORY[0x1E4F1CFD0]);
  uint64_t v6 = PCSMeasureRelativeNanoTime();
  ++PCSMeasure;
  int v7 = (*(&_PCSKeychainForwardTable + 1))(v5, &cf);
  qword_1EB3B49C0 += PCSMeasureRelativeNanoTime() - v6;
  BOOL v8 = v7 == 0;
  if (v7) {
    PCSSecError(v7, a3, @"SecItemAdd");
  }
  CFRelease(v5);
  CFTypeRef v9 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v9);
  }
  return v8;
}

BOOL KeychainRemoveIdentity(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  if (!*(void *)(a1 + 40)) {
    return 0;
  }
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  if (!MutableForCFTypesWith) {
    return 0;
  }
  CFTypeRef v9 = MutableForCFTypesWith;
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B878], (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  uint64_t v10 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49D8;
  int v11 = off_1EB3B39C8(v9);
  qword_1EB3B49E0 += PCSMeasureRelativeNanoTime() - v10;
  BOOL v12 = v11 == 0;
  CFRelease(v9);
  return v12;
}

uint64_t KeychainSetCurrentIdentity(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  CFNumberRef v6 = IdentityCopyServiceNumber(a2, 0);
  CFNumberRef v7 = IdentityCopyServiceNumber(a2, 0x10000);
  int v15 = v7;
  if (!*(void *)(a1 + 40))
  {
    CFDictionaryRef v28 = 0;
    char v27 = 0;
LABEL_29:
    uint64_t v48 = 0;
    goto LABEL_18;
  }
  int v16 = (void *)*MEMORY[0x1E4F3B978];
  uint64_t v17 = *MEMORY[0x1E4F3B998];
  uint64_t v18 = *MEMORY[0x1E4F3B8C0];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)v7, v8, v9, v10, v11, v12, v13, v14, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  char v27 = MutableForCFTypesWith;
  if (!MutableForCFTypesWith)
  {
    CFDictionaryRef v28 = 0;
    goto LABEL_29;
  }
  uint64_t v52 = a3;
  uint64_t v53 = (uint64_t)v15;
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B878], (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  CFDictionaryRef v28 = CFDictionaryCreateForCFTypes((uint64_t)MutableForCFTypesWith, v20, v21, v22, v23, v24, v25, v26, v18, (uint64_t)v6);
  uint64_t v29 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49C8;
  int v30 = qword_1EB3B39C0(v27, v28);
  qword_1EB3B49D0 += PCSMeasureRelativeNanoTime() - v29;
  if (v30 != -25300 && v30)
  {
    PCSSecError(v30, v52, @"Failed to remove current on attributes", key);
    goto LABEL_16;
  }
  CFRelease(v27);
  if (v28) {
    CFRelease(v28);
  }
  int PublicKey = PCSIdentityGetPublicKey(a2);
  uint64_t v38 = CFDictionaryCreateMutableForCFTypesWith(PublicKey, v31, v32, v33, v34, v35, v36, v37, v16, v17);
  char v27 = v38;
  int v15 = (const void *)v53;
  if (v38)
  {
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(v38, (const void *)*MEMORY[0x1E4F3B878], (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    CFDictionaryRef v28 = CFDictionaryCreateForCFTypes((uint64_t)v38, v39, v40, v41, v42, v43, v44, v45, v18, v53);
    if (v28)
    {
      uint64_t v46 = PCSMeasureRelativeNanoTime();
      ++qword_1EB3B49C8;
      int v47 = qword_1EB3B39C0(v27, v28);
      qword_1EB3B49D0 += PCSMeasureRelativeNanoTime() - v46;
      if (!v47)
      {
        uint64_t v48 = 1;
LABEL_17:
        int v15 = (const void *)v53;
        goto LABEL_18;
      }
      PCSSecError(v47, v52, @"Failed to mark %@ as current", a2);
LABEL_16:
      uint64_t v48 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    CFDictionaryRef v28 = 0;
  }
  uint64_t v48 = 0;
LABEL_18:
  if (v6) {
    CFRelease(v6);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (v28) {
    CFRelease(v28);
  }
  return v48;
}

uint64_t KeychainUnsetCurrentIdentity(uint64_t a1, void *a2, CFErrorRef *a3)
{
  if (!*(void *)(a1 + 40)) {
    return 0;
  }
  unsigned int valuePtr = PCSServiceItemGetIndexByName(a2);
  if (!valuePtr) {
    return 0;
  }
  CFNumberRef v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  valuePtr |= 0x10000u;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  uint64_t v6 = *MEMORY[0x1E4F3B8C0];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)v5, v7, v8, v9, v10, v11, v12, v13, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  uint64_t v22 = MutableForCFTypesWith;
  if (MutableForCFTypesWith)
  {
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B878], (const void *)*MEMORY[0x1E4F1CFD0]);
    }
    CFDictionaryRef v23 = CFDictionaryCreateForCFTypes((uint64_t)MutableForCFTypesWith, v15, v16, v17, v18, v19, v20, v21, v6, (uint64_t)v4);
    if (v23)
    {
      uint64_t v24 = PCSMeasureRelativeNanoTime();
      ++qword_1EB3B49C8;
      int v25 = qword_1EB3B39C0(v22, v23);
      qword_1EB3B49D0 += PCSMeasureRelativeNanoTime() - v24;
      uint64_t v26 = 1;
      if (v25 == -25300 || !v25) {
        goto LABEL_11;
      }
      PCSSecError(v25, a3, @"Failed to remove current on attributes");
    }
  }
  else
  {
    CFDictionaryRef v23 = 0;
  }
  uint64_t v26 = 0;
LABEL_11:
  if (v4) {
    CFRelease(v4);
  }
  if (v5) {
    CFRelease(v5);
  }
  if (v22) {
    CFRelease(v22);
  }
  if (v23) {
    CFRelease(v23);
  }
  return v26;
}

uint64_t KeychainEnumerateIdentities(uint64_t a1, const void *a2, void *a3)
{
  id TypeID = a3;
  int v13 = TypeID;
  if (!a1) {
    goto LABEL_20;
  }
  int v14 = *(void **)(a1 + 32);
  if (a2)
  {
    CFTypeID v15 = CFGetTypeID(a2);
    id TypeID = (id)CFDictionaryGetTypeID();
    if ((id)v15 == TypeID && !v14)
    {
      id TypeID = (id)CFDictionaryGetValue((CFDictionaryRef)a2, kPCSSetupService[0]);
      int v14 = TypeID;
    }
  }
  uint64_t v16 = (const void *)*MEMORY[0x1E4F1CFD0];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)TypeID, v6, v7, v8, v9, v10, v11, v12, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  if (!MutableForCFTypesWith)
  {
LABEL_20:
    uint64_t v28 = 0;
    goto LABEL_19;
  }
  uint64_t v18 = MutableForCFTypesWith;
  uint64_t v19 = *(const void **)(a1 + 40);
  if (v19) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B848], v19);
  }
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v18, (const void *)*MEMORY[0x1E4F3B878], v16);
  }
  if (v14)
  {
    CFTypeID v20 = CFGetTypeID(v14);
    if (v20 == CFStringGetTypeID())
    {
      unsigned int valuePtr = PCSServiceItemGetIndexByName(v14);
      CFNumberRef v21 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      if (!v21) {
        goto LABEL_21;
      }
      CFNumberRef v22 = v21;
      CFDictionaryRef v23 = (const void *)*MEMORY[0x1E4F3B8C0];
      CFDictionarySetValue(v18, (const void *)*MEMORY[0x1E4F3B8C0], v21);
      CFRelease(v22);
      processQuery((uint64_t)v18, v13);
      valuePtr += 0x10000;
      CFNumberRef v24 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      if (!v24
        || (CFNumberRef v25 = v24,
            CFDictionarySetValue(v18, v23, v24),
            CFRelease(v25),
            processQuery((uint64_t)v18, v13),
            valuePtr += 0x10000,
            (CFNumberRef v26 = CFNumberCreate(0, kCFNumberIntType, &valuePtr)) == 0))
      {
LABEL_21:
        uint64_t v28 = 0;
        goto LABEL_18;
      }
      CFNumberRef v27 = v26;
      CFDictionarySetValue(v18, v23, v26);
      CFRelease(v27);
    }
  }
  processQuery((uint64_t)v18, v13);
  uint64_t v28 = 1;
LABEL_18:
  CFRelease(v18);
LABEL_19:

  return v28;
}

CFMutableDictionaryRef KeychainCopyIdentities(uint64_t a1, const void *a2)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef v5 = Mutable;
  if (Mutable)
  {
    v7[0] = MEMORY[0x1E4F143A8];
    v7[1] = 3221225472;
    v7[2] = __KeychainCopyIdentities_block_invoke;
    v7[3] = &__block_descriptor_40_e27_v16__0___PCSIdentityData__8l;
    v7[4] = Mutable;
    if ((KeychainEnumerateIdentities(a1, a2, v7) & 1) == 0)
    {
      CFRelease(v5);
      return 0;
    }
  }
  return v5;
}

CFArrayRef KeychainCopyOrderedIdentities(uint64_t a1, void *a2)
{
  uint64_t v23 = 0;
  CFNumberRef v24 = &v23;
  uint64_t v25 = 0x2020000000;
  char v26 = 0;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  int v12 = Mutable;
  if (!Mutable)
  {
    CFArrayRef Copy = 0;
    CFTypeID v15 = 0;
    goto LABEL_20;
  }
  if (a2)
  {
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)Mutable, v5, v6, v7, v8, v9, v10, v11, kPCSSetupService[0], (uint64_t)a2);
    if (!MutableForCFTypesWith)
    {
      CFArrayRef Copy = 0;
      CFTypeID v15 = 0;
      goto LABEL_19;
    }
  }
  else
  {
    MutableForCFTypesWith = 0;
  }
  uint64_t v16 = KeychainCopyCurrentIdentity(a1, a2, 0);
  CFTypeID v15 = v16;
  if (v16 && (uint64_t v17 = (const void *)[v16 identity], (v18 = v17) != 0))
  {
    CFRetain(v17);
    CFDictionaryRef v19 = KeychainCopyIdentities(a1, MutableForCFTypesWith);
    if (v19)
    {
      if (_PCSIdentityValidate((uint64_t)v18, (unsigned char *)v24 + 24, 0) && !*((unsigned char *)v24 + 24)) {
        CFArrayAppendValue(v12, v18);
      }
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 3221225472;
      context[2] = __KeychainCopyOrderedIdentities_block_invoke;
      context[3] = &unk_1E5E6E350;
      void context[4] = &v23;
      void context[5] = v18;
      void context[6] = v12;
      CFDictionaryApplyFunction(v19, (CFDictionaryApplierFunction)apply_block_2_2, context);
      CFIndex Count = CFArrayGetCount(v12);
      if (Count >= 2)
      {
        v27.CFIndex length = Count - 1;
        v27.CFIndex location = 1;
        CFArraySortValues(v12, v27, (CFComparatorFunction)_PCSIdentityComparePublicKey, 0);
      }
      CFArrayRef Copy = CFArrayCreateCopy(0, v12);
    }
    else
    {
      CFArrayRef Copy = 0;
    }
    CFRelease(v18);
    if (v19) {
      CFRelease(v19);
    }
    if (!MutableForCFTypesWith) {
      goto LABEL_19;
    }
  }
  else
  {
    CFArrayRef Copy = 0;
    if (!MutableForCFTypesWith) {
      goto LABEL_19;
    }
  }
  CFRelease(MutableForCFTypesWith);
LABEL_19:
  CFRelease(v12);
LABEL_20:
  _Block_object_dispose(&v23, 8);

  return Copy;
}

void sub_1ACFC43B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void KeychainEnumeratePublicKeys(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFNumberRef v4 = (const void *)*MEMORY[0x1E4F1CFD0];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)v3, v5, v6, v7, v8, v9, v10, v11, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  int v13 = MutableForCFTypesWith;
  int v14 = *(const void **)(a1 + 40);
  if (v14) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B848], v14);
  }
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E4F3B878], v4);
  }
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  void v20[2] = __KeychainEnumeratePublicKeys_block_invoke;
  v20[3] = &unk_1E5E6E600;
  CFNumberRef v22 = v13;
  id v15 = v3;
  id v21 = v15;
  uint64_t v16 = (void (**)(void, void))MEMORY[0x1AD11D080](v20);
  uint64_t v17 = *(const void **)(a1 + 32);
  if (v17)
  {
    CFTypeID v18 = CFGetTypeID(v17);
    if (v18 == CFStringGetTypeID())
    {
      CFNumberRef IndexByName = PCSServiceItemGetIndexByName(*(void **)(a1 + 32));
      ((void (**)(void, const __CFNumber *))v16)[2](v16, IndexByName);
      v16[2](v16, IndexByName | 0x10000);
      v16[2](v16, IndexByName | 0x20000);
      if (!v13) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  v16[2](v16, 0);
  if (v13) {
LABEL_10:
  }
    CFRelease(v13);
LABEL_11:
}

void KeychainRepairCurrentIdentity(const void *a1, void *a2, const void *a3, void *a4)
{
  int v7 = a4;
  if (PCSServiceItemTypeIsManatee(a2))
  {
    if (v7) {
      v7[2](v7, 1, 0);
    }
  }
  else
  {
    CFRetain(a1);
    CFRetain(a2);
    CFRetain(a3);
    int v8 = dispatch_get_global_queue(21, 0);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __KeychainRepairCurrentIdentity_block_invoke;
    v9[3] = &unk_1E5E6E628;
    int v11 = a1;
    int v12 = a2;
    int v13 = a3;
    int v10 = v7;
    dispatch_async(v8, v9);
  }
}

uint64_t KeychainIsICDP(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8)
{
  int v9 = 0;
  return KeychainGetSecurityDomainStatus(a1, kPCSiCloudServiceMarkerName[0], &v9, a2, a5, a6, a7, a8);
}

uint64_t KeychainIsICDPNetwork(uint64_t a1, const __CFDictionary *a2, const void **a3, uint64_t a4, int a5, int a6, int a7, int a8)
{
  v24[1] = *MEMORY[0x1E4F143B8];
  int v20 = 0;
  uint64_t SecurityDomainStatus = KeychainGetSecurityDomainStatus(a1, kPCSiCloudServiceMarkerName[0], &v20, a3, a5, a6, a7, a8);
  int v12 = 0;
  if ((SecurityDomainStatus & 1) == 0 && v20 == -25300)
  {
    if (a2 && (CFTypeID v13 = CFGetTypeID(a2), v13 == CFDictionaryGetTypeID())) {
      MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0, 0, a2);
    }
    else {
      MutableCFArrayRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    int v12 = MutableCopy;
    if (!CFDictionaryGetValue(MutableCopy, kPCSSetupDSID[0]) && *(void *)(a1 + 40))
    {
      if ((PCSCurrentPersonaMatchesDSIDFromSet(a1) & 1) == 0)
      {
        if (a3)
        {
          uint64_t v17 = (void *)MEMORY[0x1E4F28C58];
          CFTypeID v18 = kPCSErrorDomain;
          uint64_t v23 = *MEMORY[0x1E4F28568];
          v24[0] = @"Current persona does not match chosen dsid";
          CFDictionaryRef v19 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v24 forKeys:&v23 count:1];
          *a3 = [v17 errorWithDomain:v18 code:152 userInfo:v19];
        }
        uint64_t SecurityDomainStatus = 0;
        if (v12) {
          goto LABEL_17;
        }
        return SecurityDomainStatus;
      }
      CFDictionarySetValue(v12, kPCSSetupDSID[0], *(const void **)(a1 + 40));
    }
    CFDictionaryRef v15 = (const __CFDictionary *)__PCSCopyStingrayInfo(0, v12, a3);
    if (v12) {
      CFRelease(v12);
    }
    if (v15)
    {
      uint64_t SecurityDomainStatus = (uint64_t)_PCSIsiCDPEnabled(v15, 1);
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        int v22 = SecurityDomainStatus;
        _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "_PCSIsiCDPEnabled: status: %d", buf, 8u);
      }
      int v12 = v15;
    }
    else
    {
      int v12 = 0;
      uint64_t SecurityDomainStatus = 0;
    }
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    int v22 = SecurityDomainStatus;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "KeychainIsICDPNetwork: status: %d", buf, 8u);
  }
  if (v12) {
LABEL_17:
  }
    CFRelease(v12);
  return SecurityDomainStatus;
}

uint64_t KeychainSetICDP(uint64_t a1, int a2, CFErrorRef *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v6 = _PCSIdentitySetGetAltDSIDorPCSAccountsModel(a1);
  if (v6)
  {
    id v7 = objc_alloc_init(MEMORY[0x1E4F3B438]);
    [v7 setAltDSID:v6];
    id v12 = 0;
    char v8 = [MEMORY[0x1E4F3B430] setCDPEnabled:v7 error:&v12];
    id v9 = v12;
    if ((v8 & 1) == 0 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v14 = v9;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "setting Octagon CDP failed: %@", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "unable to determine altDSID, not setting Octagon CDP", buf, 2u);
  }
  uint64_t v10 = KeychainSetSecurityDomainStatus(a1, kPCSiCloudServiceMarkerName[0], a2, a3);

  return v10;
}

uint64_t KeychainIsPlesio(uint64_t a1, const void **a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8)
{
  int v15 = 0;
  if (KeychainGetSecurityDomainStatus(a1, kPCSPlesioMarkerNewName[0], &v15, a2, a5, a6, a7, a8)) {
    return 1;
  }
  else {
    return KeychainGetSecurityDomainStatus(a1, kPCSPlesioMarkerName[0], &v15, a2, v10, v11, v12, v13);
  }
}

uint64_t KeychainSetPlesio(uint64_t a1, int a2, CFErrorRef *a3)
{
  KeychainSetSecurityDomainStatus(a1, kPCSPlesioMarkerName[0], a2, a3);
  int v6 = kPCSPlesioMarkerNewName[0];
  return KeychainSetSecurityDomainStatus(a1, v6, a2, a3);
}

uint64_t KeychainIsWalrus(uint64_t a1, uint64_t a2, const void **a3)
{
  if (KeychainIsWalrus_once != -1) {
    dispatch_once(&KeychainIsWalrus_once, &__block_literal_global_8);
  }
  int v6 = (void *)MEMORY[0x1AD11CE50]();
  uint64_t v27 = 0;
  uint64_t v28 = &v27;
  uint64_t v29 = 0x3032000000;
  int v30 = __Block_byref_object_copy__0;
  int v31 = __Block_byref_object_dispose__0;
  id v32 = 0;
  if (objc_opt_class())
  {
    id v7 = _PCSIdentitySetGetAltDSIDorPCSAccountsModel(a1);
    char v8 = v7;
    if (v7)
    {
      if ((a2 & 1) == 0)
      {
        id v9 = KeychainIsWalrus_queue;
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = __KeychainIsWalrus_block_invoke_190;
        block[3] = &unk_1E5E6E100;
        char v26 = &v27;
        id v25 = v7;
        dispatch_sync(v9, block);
        int v10 = (void *)v28[5];
        if (v10)
        {
          int v11 = [v10 walrus];
          uint64_t v12 = [v11 enabled];

          id v13 = 0;
          id v14 = 0;
LABEL_16:

          goto LABEL_17;
        }
      }
      id v14 = objc_alloc_init(MEMORY[0x1E4F3B438]);
      [v14 setAltDSID:v8];
      [v14 setContext:*MEMORY[0x1E4F3B458]];
      id v23 = 0;
      uint64_t v15 = [MEMORY[0x1E4F3B430] fetchAccountWideSettingsDefaultWithForceFetch:a2 configuration:v14 error:&v23];
      id v13 = v23;
      uint64_t v16 = (void *)v28[5];
      v28[5] = v15;

      if (v28[5])
      {
        uint64_t v17 = KeychainIsWalrus_queue;
        v20[0] = MEMORY[0x1E4F143A8];
        v20[1] = 3221225472;
        void v20[2] = __KeychainIsWalrus_block_invoke_2_191;
        v20[3] = &unk_1E5E6E0D8;
        id v21 = v8;
        int v22 = &v27;
        dispatch_barrier_async(v17, v20);
        CFTypeID v18 = [(id)v28[5] walrus];
        uint64_t v12 = [v18 enabled];
      }
      else
      {
        uint64_t v12 = 0;
        if (a3 && v13)
        {
          id v13 = v13;
          uint64_t v12 = 0;
          *a3 = v13;
        }
      }
      goto LABEL_16;
    }
    _PCSError(a3, 90, @"altDSID not available");
    id v13 = 0;
    id v14 = 0;
    uint64_t v12 = 0;
    goto LABEL_16;
  }
  _PCSError(a3, 15, @"OctagonTrust not available");
  id v13 = 0;
  id v14 = 0;
  uint64_t v12 = 0;
LABEL_17:
  _Block_object_dispose(&v27, 8);

  return v12;
}

void sub_1ACFC4F2C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t KeychainSetWalrus(uint64_t a1, uint64_t a2, const void **a3)
{
  if (objc_opt_class())
  {
    int v6 = _PCSIdentitySetGetAltDSIDorPCSAccountsModel(a1);
    if (v6)
    {
      id v7 = objc_alloc_init(MEMORY[0x1E4F3B438]);
      [v7 setAltDSID:v6];
      [v7 setContext:*MEMORY[0x1E4F3B458]];
      char v8 = (void *)[objc_alloc(MEMORY[0x1E4F3B430]) initWithContextData:v7];
      id v9 = objc_alloc_init(MEMORY[0x1E4F83A48]);
      id v10 = objc_alloc_init(MEMORY[0x1E4F83A50]);
      [v9 setWalrus:v10];

      int v11 = [v9 walrus];
      [v11 setEnabled:a2];

      id v16 = 0;
      uint64_t v12 = [v8 setAccountSetting:v9 error:&v16];
      id v13 = v16;
      id v14 = v13;
      if (a3 && (v12 & 1) == 0)
      {
        id v14 = v13;
        uint64_t v12 = 0;
        *a3 = v14;
      }
    }
    else
    {
      _PCSError(a3, 90, @"altDSID not available");
      id v14 = 0;
      id v7 = 0;
      char v8 = 0;
      id v9 = 0;
      uint64_t v12 = 0;
    }
  }
  else
  {
    _PCSError(a3, 15, @"OctagonTrust not available");
    return 0;
  }
  return v12;
}

uint64_t KeychainSetCopySet(int a1, const void **a2)
{
  return 0;
}

uint64_t KeychainIsCircleMember()
{
  return 0;
}

uint64_t KeychainSetCircleMember()
{
  return 0;
}

uint64_t IsViewHintPreferred(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (const void *)result;
    if (CFEqual((CFTypeRef)result, (CFTypeRef)*MEMORY[0x1E4F3B8D0])) {
      return 1;
    }
    if (CFEqual(v1, (CFTypeRef)*MEMORY[0x1E4F3B8E0])) {
      return 1;
    }
    if (CFEqual(v1, (CFTypeRef)*MEMORY[0x1E4F3B8F0])) {
      return 1;
    }
    if (CFEqual(v1, (CFTypeRef)*MEMORY[0x1E4F3B8C8])) {
      return 1;
    }
    uint64_t result = CFEqual(v1, (CFTypeRef)*MEMORY[0x1E4F3B8E8]);
    if (result) {
      return 1;
    }
  }
  return result;
}

void UpdateCKKSIdentity(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1 && theDict && !CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F3B7B0]))
  {
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(0, v4, v5, v6, v7, v8, v9, v10, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (_PCSKeychainAmendCKKSEntry(a1, Mutable))
    {
      CopyValueValue(theDict, MutableForCFTypesWith, (void *)*MEMORY[0x1E4F3B870]);
      CopyValueValue(theDict, MutableForCFTypesWith, (void *)*MEMORY[0x1E4F3B838]);
      CopyValueValue(theDict, MutableForCFTypesWith, (void *)*MEMORY[0x1E4F3B5C0]);
      CopyValueValue(theDict, MutableForCFTypesWith, (void *)*MEMORY[0x1E4F3B8C0]);
      CopyValueValue(theDict, MutableForCFTypesWith, (void *)*MEMORY[0x1E4F3B848]);
      int v13 = qword_1EB3B39C0(MutableForCFTypesWith, Mutable);
      if (MutableForCFTypesWith) {
        CFRelease(MutableForCFTypesWith);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      if (v13)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          uint64_t v15 = a1;
          __int16 v16 = 1024;
          int v17 = v13;
          _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to update identity %@ to set CKKS PCS public attributes: %d", buf, 0x12u);
        }
      }
    }
    else
    {
      if (MutableForCFTypesWith) {
        CFRelease(MutableForCFTypesWith);
      }
      if (Mutable)
      {
        CFRelease(Mutable);
      }
    }
  }
}

void CopyValueValue(const __CFDictionary *a1, __CFDictionary *a2, void *key)
{
  CFNumberRef Value = CFDictionaryGetValue(a1, key);
  if (Value)
  {
    CFDictionarySetValue(a2, key, Value);
  }
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void __KeychainCopyCurrentIdentity_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = *(NSObject **)(a1 + 32);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __KeychainCopyCurrentIdentity_block_invoke_2;
  block[3] = &unk_1E5E6E588;
  id v14 = v5;
  id v15 = v6;
  long long v8 = *(_OWORD *)(a1 + 72);
  long long v17 = *(_OWORD *)(a1 + 56);
  long long v18 = v8;
  long long v12 = *(_OWORD *)(a1 + 40);
  id v9 = (id)v12;
  long long v16 = v12;
  id v10 = v6;
  id v11 = v5;
  dispatch_sync(v7, block);
}

intptr_t __KeychainCopyCurrentIdentity_block_invoke_2(intptr_t result)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 56) + 8) + 24))
  {
    intptr_t v1 = result;
    uint64_t v2 = [*(id *)(result + 32) persistentRef];
    if (!v2 || (uint64_t v3 = *(void *)(v1 + 40), v2, v3))
    {
      int v4 = *(void **)(v1 + 40);
      if (v4) {
        *(void *)(*(void *)(*(void *)(v1 + 64) + 8) + 24) = v4;
      }
      id v5 = pcsLogObjForScope("ckks");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(v1 + 80);
        uint64_t v7 = *(void *)(v1 + 40);
        *(_DWORD *)long long buf = 138543618;
        uint64_t v17 = v6;
        __int16 v18 = 2114;
        uint64_t v19 = v7;
        _os_log_impl(&dword_1ACF98000, v5, OS_LOG_TYPE_DEFAULT, "Failed to get CKKS current service %{public}@: %{public}@", buf, 0x16u);
      }
    }
    long long v8 = [*(id *)(v1 + 32) persistentRef];

    if (v8)
    {
      id v9 = [*(id *)(v1 + 32) persistentRef];
      SHA1 = (const void *)PCSIdentityCreateFromPersistentReferenceAndGetSHA1(v9, *(void **)(*(void *)(v1 + 88) + 40), 0);

      if (SHA1)
      {
        if (_PCSIdentityHavePCSCKKSAttributes((uint64_t)SHA1))
        {
          id v11 = [PCSCurrentIdentity alloc];
          long long v12 = [*(id *)(v1 + 32) currentItemPointerModificationTime];
          uint64_t v13 = [(PCSCurrentIdentity *)v11 initWithIdentity:SHA1 currentItemPointerModificationTime:v12];
          uint64_t v14 = *(void *)(*(void *)(v1 + 72) + 8);
          id v15 = *(void **)(v14 + 40);
          *(void *)(v14 + 40) = v13;
        }
        else
        {
          _PCSError((const void **)(*(void *)(*(void *)(v1 + 64) + 8) + 24), 106, @"Identity missing CKKS attributes: %@", SHA1);
        }
        CFRelease(SHA1);
      }
    }
    return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v1 + 48));
  }
  return result;
}

CFIndex __KeychainCopyCurrentIdentity_block_invoke_130(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v3 = *(const void **)(v2 + 24);
  if (v3)
  {
    *(void *)(v2 + 24) = 0;
    CFRelease(v3);
    uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  return _PCSError((const void **)(v2 + 24), 27, @"identity timed out fetching from local store");
}

PCSCurrentIdentity *KeychainCopyXIdentityWithCount(uint64_t a1, void *a2, CFIndex *a3, const void **a4)
{
  uint64_t v6 = a2;
  CFArrayRef v47 = 0;
  int valuePtr = 0;
  if (!a2)
  {
    uint64_t v6 = *(void **)(a1 + 32);
    if (!v6)
    {
      _PCSError(a4, 27, @"service missing");
      goto LABEL_36;
    }
  }
  unsigned int IndexByName = PCSServiceItemGetIndexByName(v6);
  int valuePtr = IndexByName;
  if (!IndexByName)
  {
LABEL_36:
    uint64_t v41 = 0;
    uint64_t v20 = 0;
    CFNumberRef v17 = 0;
    goto LABEL_41;
  }
  int valuePtr = IndexByName | 0x10000;
  CFNumberRef v9 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFNumberRef v17 = v9;
  if (!v9)
  {
    _PCSErrorOOM(a4);
    uint64_t v41 = 0;
    uint64_t v20 = 0;
    goto LABEL_41;
  }
  __int16 v18 = (const void *)*MEMORY[0x1E4F1CFD0];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith((int)v9, v10, v11, v12, v13, v14, v15, v16, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  uint64_t v20 = MutableForCFTypesWith;
  if (MutableForCFTypesWith)
  {
    id v21 = *(const void **)(a1 + 40);
    if (v21) {
      CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B848], v21);
    }
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(v20, (const void *)*MEMORY[0x1E4F3B878], v18);
    }
    uint64_t v22 = PCSMeasureRelativeNanoTime();
    ++qword_1EB3B49E8;
    int v23 = _PCSKeychainForwardTable(v20, &v47);
    qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v22;
    if (v23)
    {
      PCSSecError(v23, (CFErrorRef *)a4, @"Failed finding service %@", v6);
    }
    else if (v47 && (CFTypeID v24 = CFGetTypeID(v47), v24 == CFArrayGetTypeID()))
    {
      CFIndex Count = CFArrayGetCount(v47);
      CFIndex v26 = Count;
      if (a3) {
        *a3 = Count;
      }
      if (Count >= 1)
      {
        uint64_t v45 = a4;
        CFDictionaryRef v27 = 0;
        CFDictionaryRef v28 = 0;
        CFIndex v29 = 0;
        int v30 = (const void *)*MEMORY[0x1E4F3BD38];
        int v31 = (const void *)*MEMORY[0x1E4F3B870];
        do
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v47, v29);
          if (ValueAtIndex)
          {
            CFDictionaryRef v33 = ValueAtIndex;
            CFTypeID v34 = CFGetTypeID(ValueAtIndex);
            if (v34 == CFDictionaryGetTypeID())
            {
              CFNumberRef Value = CFDictionaryGetValue(v33, v30);
              if (Value)
              {
                CFTypeID v36 = CFGetTypeID(Value);
                if (v36 == CFDataGetTypeID())
                {
                  int v37 = CFDictionaryGetValue(v33, v31);
                  if (IsViewHintPreferred((uint64_t)v37)
                    && (!v28 || IdentityAttributesCompare(v33, v28) == kCFCompareGreaterThan))
                  {
                    CFDictionaryRef v28 = v33;
                  }
                  else if (!v27 || IdentityAttributesCompare(v33, v27) == kCFCompareGreaterThan)
                  {
                    CFDictionaryRef v27 = v33;
                  }
                }
              }
            }
          }
          ++v29;
        }
        while (v26 != v29);
        if (v28)
        {
          uint64_t v38 = PCSIdentityCreateWithKeychainAttributes(v28, v45);
          uint64_t v39 = v38;
          CFDictionaryRef v40 = v28;
          goto LABEL_33;
        }
        if (v27)
        {
          uint64_t v38 = PCSIdentityCreateWithKeychainAttributes(v27, v45);
          uint64_t v39 = v38;
          CFDictionaryRef v40 = v27;
LABEL_33:
          UpdateCKKSIdentity((uint64_t)v38, v40);
          if (v39)
          {
            uint64_t v41 = [[PCSCurrentIdentity alloc] initWithIdentity:v39 currentItemPointerModificationTime:0];
            CFRelease(v39);
            goto LABEL_41;
          }
        }
      }
    }
    else
    {
      _PCSError(a4, 21, @"return data not array");
    }
  }
  uint64_t v41 = 0;
LABEL_41:
  CFArrayRef v42 = v47;
  if (v47)
  {
    CFArrayRef v47 = 0;
    CFRelease(v42);
  }
  if (v20) {
    CFRelease(v20);
  }
  CFArrayRef v43 = v47;
  if (v47)
  {
    CFArrayRef v47 = 0;
    CFRelease(v43);
  }
  if (v17) {
    CFRelease(v17);
  }
  return v41;
}

CFComparisonResult IdentityAttributesCompare(const __CFDictionary *a1, const __CFDictionary *a2)
{
  int v4 = (const void *)*MEMORY[0x1E4F3B668];
  CFNumberRef Value = CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F3B668]);
  uint64_t v6 = CFDictionaryGetValue(a2, v4);
  if (!Value
    || ((uint64_t v7 = v6, v8 = CFGetTypeID(Value), v8 == CFDateGetTypeID()) ? (v9 = v7 == 0) : (v9 = 1),
        v9
     || (CFTypeID v10 = CFGetTypeID(v7), v10 != CFDateGetTypeID())
     || (CFComparisonResult result = CFDateCompare((CFDateRef)Value, (CFDateRef)v7, 0)) == kCFCompareEqualTo))
  {
    int v12 = (const void *)*MEMORY[0x1E4F3B5C0];
    CFStringRef v13 = (const __CFString *)CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F3B5C0]);
    CFStringRef v14 = (const __CFString *)CFDictionaryGetValue(a2, v12);
    if (v13
      && ((CFStringRef v15 = v14, v16 = CFGetTypeID(v13), v16 == CFStringGetTypeID()) ? (v17 = v15 == 0) : (v17 = 1),
          !v17 && (CFTypeID v18 = CFGetTypeID(v15), v18 == CFStringGetTypeID())))
    {
      return CFStringCompare(v13, v15, 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void processQuery(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeRef cf = 0;
  uint64_t v4 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  LODWORD(a1) = _PCSKeychainForwardTable(a1, &cf);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v4;
  if (a1) {
    goto LABEL_2;
  }
  if (!cf) {
    goto LABEL_10;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)cf))
  {
    CFArrayRef v7 = (const __CFArray *)cf;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __processQuery_block_invoke;
    v9[3] = &unk_1E5E6E5D8;
    id v10 = v3;
    v12.CFIndex length = CFArrayGetCount(v7);
    v12.CFIndex location = 0;
    CFArrayApplyFunction(v7, v12, (CFArrayApplierFunction)apply_block_1_1, v9);
    CFTypeRef v8 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v8);
    }
  }
  else
  {
LABEL_2:
    CFTypeRef v5 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v5);
    }
  }
LABEL_10:
}

void __processQuery_block_invoke(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFNumberRef Value = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F3BD38]);
  CFTypeRef v8 = 0;
  if (Value)
  {
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFDataGetTypeID())
    {
      CFTypeID v6 = PCSIdentityCreateWithKeychainAttributes(theDict, &v8);
      if (v6)
      {
        CFArrayRef v7 = v6;
        UpdateCKKSIdentity((uint64_t)v6, theDict);
        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
LABEL_9:
        CFRelease(v7);
        return;
      }
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v10 = v8;
        _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to parse identity from keychain: %@", buf, 0xCu);
      }
      CFArrayRef v7 = v8;
      if (v8)
      {
        CFTypeRef v8 = 0;
        goto LABEL_9;
      }
    }
  }
}

void __KeychainCopyIdentities_block_invoke(uint64_t a1, const void *a2)
{
  id v3 = *(__CFDictionary **)(a1 + 32);
  int PublicKey = (const void *)PCSIdentityGetPublicKey((uint64_t)a2);
  CFDictionarySetValue(v3, PublicKey, a2);
}

void __KeychainCopyOrderedIdentities_block_invoke(void *a1, int a2, CFTypeRef cf2)
{
  CFTypeRef v5 = (CFTypeRef)a1[5];
  if (cf2 && v5)
  {
    if (CFEqual(v5, cf2)) {
      return;
    }
  }
  else if (v5 == cf2)
  {
    return;
  }
  if (_PCSIdentityValidate((uint64_t)cf2, (unsigned char *)(*(void *)(a1[4] + 8) + 24), 0)
    && !*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    CFTypeID v6 = (__CFArray *)a1[6];
    CFArrayAppendValue(v6, cf2);
  }
}

void __KeychainEnumeratePublicKeys_block_invoke(uint64_t a1, int a2)
{
  int valuePtr = a2;
  CFTypeRef cf = 0;
  id v3 = (const void **)MEMORY[0x1E4F3B8C0];
  if (a2)
  {
    CFNumberRef v4 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), *v3, v4);
    if (v4) {
      CFRelease(v4);
    }
  }
  uint64_t v5 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  _PCSKeychainForwardTable(*(void *)(a1 + 40), &cf);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v5;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFArrayGetTypeID())
    {
      CFArrayRef v7 = (const __CFArray *)cf;
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 3221225472;
      context[2] = __KeychainEnumeratePublicKeys_block_invoke_2;
      context[3] = &unk_1E5E6E5D8;
      id v10 = *(id *)(a1 + 32);
      v13.CFIndex length = CFArrayGetCount(v7);
      v13.CFIndex location = 0;
      CFArrayApplyFunction(v7, v13, (CFArrayApplierFunction)apply_block_1_1, context);
    }
    CFTypeRef v8 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v8);
    }
  }
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 40), *v3);
}

const void *__KeychainEnumeratePublicKeys_block_invoke_2(uint64_t a1, CFDictionaryRef theDict)
{
  CFComparisonResult result = CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x1E4F3B5C0]);
  if (result)
  {
    CFTypeID v4 = CFGetTypeID(result);
    CFComparisonResult result = (const void *)CFStringGetTypeID();
    if ((const void *)v4 == result)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
      return (const void *)v5();
    }
  }
  return result;
}

void __KeychainRepairCurrentIdentity_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFIndex v10 = 0;
  uint64_t v2 = KeychainCopyXIdentityWithCount(*(void *)(a1 + 40), *(void **)(a1 + 48), &v10, 0);
  id v3 = v2;
  CFTypeRef cf = 0;
  if (v10 <= 1 && (!v2 || CFEqual((CFTypeRef)[v2 identity], *(CFTypeRef *)(a1 + 56))))
  {
LABEL_9:
    uint64_t v6 = 1;
    goto LABEL_13;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "current pointer/bit mismatch detected", buf, 2u);
  }
  int v4 = KeychainSetCurrentIdentity(*(void *)(a1 + 40), *(void *)(a1 + 56), (CFErrorRef *)&cf);
  BOOL v5 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v5)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "successfully set current identity", buf, 2u);
    }
    goto LABEL_9;
  }
  if (v5)
  {
    *(_DWORD *)long long buf = 138412290;
    CFTypeRef v12 = cf;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "failed to set current identity: %@", buf, 0xCu);
  }
  uint64_t v6 = 0;
LABEL_13:
  uint64_t v7 = *(void *)(a1 + 32);
  CFTypeRef v8 = cf;
  if (v7)
  {
    (*(void (**)(uint64_t, uint64_t, CFTypeRef))(v7 + 16))(v7, v6, cf);
    CFTypeRef v8 = cf;
  }
  if (v8)
  {
    CFTypeRef cf = 0;
    CFRelease(v8);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 48));
  CFRelease(*(CFTypeRef *)(a1 + 56));
}

uint64_t KeychainGetSecurityDomainStatus(uint64_t a1, __CFString *a2, int *a3, const void **a4, int a5, int a6, int a7, int a8)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  CFTypeRef v88 = 0;
  uint64_t v10 = *MEMORY[0x1E4F3B5C0];
  uint64_t v11 = (__CFString *)*MEMORY[0x1E4F1CFD0];
  uint64_t v12 = *MEMORY[0x1E4F3BB80];
  uint64_t v13 = (__CFString *)*MEMORY[0x1E4F3BB90];
  int v68 = (__CFString *)*MEMORY[0x1E4F3BB90];
  uint64_t v69 = 0;
  unsigned __int16 v66 = (__CFString *)*MEMORY[0x1E4F1CFD0];
  uint64_t v67 = *MEMORY[0x1E4F3BB80];
  uint64_t v85 = *MEMORY[0x1E4F3BC70];
  CFRange v64 = kPCSAccount[0];
  uint64_t v65 = *MEMORY[0x1E4F3BC70];
  uint64_t v63 = *MEMORY[0x1E4F3B5C0];
  uint64_t v61 = *MEMORY[0x1E4F3B838];
  uint64_t v62 = a2;
  uint64_t v82 = *MEMORY[0x1E4F3B838];
  uint64_t v83 = *MEMORY[0x1E4F3B998];
  uint64_t v86 = (void *)*MEMORY[0x1E4F3B978];
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, (int)a2, (int)a3, (int)a4, a5, a6, a7, a8, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  CFStringRef v15 = MutableForCFTypesWith;
  CFTypeID v16 = *(const void **)(a1 + 40);
  if (v16) {
    CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B848], v16);
  }
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v15, (const void *)*MEMORY[0x1E4F3B878], v11);
  }
  uint64_t v17 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  *a3 = _PCSKeychainForwardTable(v15, &v88);
  uint64_t v18 = PCSMeasureRelativeNanoTime();
  qword_1EB3B49F0 += v18 - v17;
  if (*a3 != -25300) {
    goto LABEL_13;
  }
  if (v15) {
    CFRelease(v15);
  }
  int v68 = v13;
  uint64_t v69 = 0;
  unsigned __int16 v66 = v11;
  uint64_t v67 = v12;
  CFRange v64 = kPCSAccount[0];
  uint64_t v65 = v85;
  uint64_t v63 = v10;
  uint64_t v61 = *MEMORY[0x1E4F3B850];
  uint64_t v62 = a2;
  uint64_t v80 = *MEMORY[0x1E4F3B850];
  uint64_t v81 = *MEMORY[0x1E4F3B988];
  CFIndex v26 = CFDictionaryCreateMutableForCFTypesWith(v18, v19, v20, v21, v22, v23, v24, v25, v86, *MEMORY[0x1E4F3B988]);
  CFStringRef v15 = v26;
  CFDictionaryRef v27 = *(const void **)(a1 + 40);
  if (v27) {
    CFDictionarySetValue(v26, (const void *)*MEMORY[0x1E4F3B688], v27);
  }
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v15, (const void *)*MEMORY[0x1E4F3B878], v11);
  }
  uint64_t v28 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  *a3 = _PCSKeychainForwardTable(v15, &v88);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v28;
  if (*a3) {
    goto LABEL_13;
  }
  uint64_t v39 = *(__CFString **)(a1 + 40);
  if (!v39) {
    goto LABEL_13;
  }
  CFTypeRef v40 = v88;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "upgradeServiceMarker", buf, 2u);
  }
  CFTypeRef v78 = v40;
  uint64_t v79 = 0;
  uint64_t v76 = @"PCS-MasterKey";
  uint64_t v77 = *MEMORY[0x1E4F3BD38];
  uint64_t v74 = v39;
  uint64_t v75 = *MEMORY[0x1E4F3B870];
  uint64_t v72 = kPCSDefaultKeychainGroup[0];
  uint64_t v73 = *MEMORY[0x1E4F3B848];
  uint64_t v70 = v11;
  uint64_t v71 = *MEMORY[0x1E4F3B550];
  int v68 = (__CFString *)*MEMORY[0x1E4F3B570];
  uint64_t v69 = *MEMORY[0x1E4F3BD08];
  unsigned __int16 v66 = kPCSAccount[0];
  uint64_t v67 = *MEMORY[0x1E4F3B558];
  CFRange v64 = kPCSiCloudServiceMarkerName[0];
  uint64_t v65 = v10;
  uint64_t v63 = v82;
  uint64_t v61 = *MEMORY[0x1E4F3B788];
  uint64_t v62 = @"PCS iCloud Data Protection";
  CFArrayRef v47 = CFDictionaryCreateMutableForCFTypesWith((int)@"PCS-MasterKey", *MEMORY[0x1E4F3BD38], v41, v42, v43, v44, v45, v46, v86, v83);
  if (v47)
  {
    uint64_t v55 = v47;
    if (PCSUseSyncKeychain) {
      CFDictionarySetValue(v47, (const void *)*MEMORY[0x1E4F3B878], v11);
    }
    uint64_t v72 = v13;
    uint64_t v73 = 0;
    uint64_t v70 = v11;
    uint64_t v71 = v12;
    int v68 = v11;
    uint64_t v69 = v85;
    unsigned __int16 v66 = v39;
    uint64_t v67 = *MEMORY[0x1E4F3B698];
    CFRange v64 = kPCSAccount[0];
    uint64_t v65 = *MEMORY[0x1E4F3B688];
    uint64_t v62 = kPCSiCloudServiceMarkerName[0];
    uint64_t v63 = v10;
    uint64_t v61 = v80;
    long long v56 = CFDictionaryCreateMutableForCFTypesWith((int)v47, v48, v49, v50, v51, v52, v53, v54, v86, v81);
    if (v56)
    {
      long long v57 = v56;
      CFIndex v29 = a2;
      if (PCSUseSyncKeychain) {
        CFDictionarySetValue(v56, (const void *)*MEMORY[0x1E4F3B878], v11);
      }
      int v58 = (*(&_PCSKeychainForwardTable + 1))(v55, 0);
      if (!v58 || v58 == -25299) {
        off_1EB3B39C8(v57);
      }
      CFRelease(v55);
    }
    else
    {
      long long v57 = v55;
      CFIndex v29 = a2;
    }
    CFRelease(v57);
  }
  else
  {
LABEL_13:
    CFIndex v29 = a2;
  }
  if (!CFEqual(v29, kPCSPlesioMarkerName[0])
    && !CFEqual(v29, kPCSPlesioMarkerNewName[0])
    && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v30 = *a3;
    *(_DWORD *)long long buf = 138412546;
    uint64_t v90 = v29;
    __int16 v91 = 1024;
    LODWORD(v92) = v30;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "KeychainGetStatus(%@): keychain: %d", buf, 0x12u);
  }
  uint64_t v31 = *a3;
  if (v31)
  {
    if (v31 != -25300) {
      _PCSError(a4, 50, @"Marker (%@) return unexpected error code: %d", v29, v31, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74,
    }
        v75,
        v76,
        v77,
        v78,
        v79);
    goto LABEL_54;
  }
  if (!v88 || (CFTypeID v32 = CFGetTypeID(v88), v32 != CFDataGetTypeID()))
  {
    _PCSError(a4, 50, @"Failed getting iCDP data", key, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74,
      v75,
      v76,
      v77,
      v78,
      v79);
LABEL_54:
    CFDataRef v34 = 0;
    goto LABEL_25;
  }
  CFDataRef v33 = CFDataCreate(0, (const UInt8 *)iCloudDataProtection, 21);
  CFDataRef v34 = v33;
  if (v33)
  {
    if (CFEqual(v33, v88))
    {
      uint64_t v35 = 1;
      goto LABEL_26;
    }
    _PCSError(a4, 50, @"Entry in iCDP not iCDP!");
  }
  else
  {
    _PCSErrorOOM(a4);
  }
LABEL_25:
  uint64_t v35 = 0;
LABEL_26:
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    CFTypeID v36 = "off";
    if (v35) {
      CFTypeID v36 = "on";
    }
    *(_DWORD *)long long buf = 138412546;
    uint64_t v90 = v29;
    __int16 v91 = 2080;
    v92 = v36;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "KeychainGetStatus(%@): status: %s", buf, 0x16u);
  }
  if (v15) {
    CFRelease(v15);
  }
  CFTypeRef v37 = v88;
  if (v88)
  {
    CFTypeRef v88 = 0;
    CFRelease(v37);
  }
  if (v34) {
    CFRelease(v34);
  }
  return v35;
}

uint64_t KeychainSetSecurityDomainStatus(uint64_t a1, CFTypeRef cf1, int a3, CFErrorRef *a4)
{
  *(void *)((char *)&v67[2] + 2) = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    CFErrorRef v8 = *a4;
    if (*a4)
    {
      *a4 = 0;
      CFRelease(v8);
    }
  }
  if (!*(void *)(a1 + 40)) {
    return 0;
  }
  int v9 = CFEqual(cf1, kPCSPlesioMarkerName[0]);
  if (!v9)
  {
    int v9 = CFEqual(cf1, kPCSPlesioMarkerNewName[0]);
    if (!v9)
    {
      int v9 = os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT);
      if (v9)
      {
        uint64_t v17 = "off";
        if (a3) {
          uint64_t v17 = "on";
        }
        *(_DWORD *)long long buf = 138412546;
        CFTypeRef v65 = cf1;
        __int16 v66 = 2080;
        v67[0] = v17;
        _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "KeychainSetICDP: setting %@ status to %s", buf, 0x16u);
      }
    }
  }
  if (!a3)
  {
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(v9, v10, v11, v12, v13, v14, v15, v16, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
    if (MutableForCFTypesWith)
    {
      long long v57 = MutableForCFTypesWith;
      if (PCSUseSyncKeychain) {
        CFDictionarySetValue(MutableForCFTypesWith, (const void *)*MEMORY[0x1E4F3B878], (const void *)*MEMORY[0x1E4F1CFD0]);
      }
      uint64_t v58 = PCSMeasureRelativeNanoTime();
      ++qword_1EB3B49D8;
      int v59 = off_1EB3B39C8(v57);
      qword_1EB3B49E0 += PCSMeasureRelativeNanoTime() - v58;
      uint64_t v53 = 1;
      if (v59 != -25300 && v59)
      {
        PCSSecError(v59, a4, @"Failed to delete: %@", cf1);
        uint64_t v53 = 0;
      }
      uint64_t v60 = v57;
      goto LABEL_36;
    }
    goto LABEL_38;
  }
  CFDataRef v18 = CFDataCreate(0, (const UInt8 *)iCloudDataProtection, 21);
  if (!v18)
  {
LABEL_38:
    _PCSErrorOOM((const void **)a4);
    return 0;
  }
  int v24 = v18;
  uint64_t v62 = (const void **)a4;
  int v25 = (void *)*MEMORY[0x1E4F3B978];
  uint64_t v26 = *MEMORY[0x1E4F3B998];
  CFDictionaryRef v27 = (const void *)*MEMORY[0x1E4F1CFD0];
  key = (void *)*MEMORY[0x1E4F3BD38];
  CFIndex v29 = CFDictionaryCreateMutableForCFTypesWith((int)@"PCS-MasterKey", *MEMORY[0x1E4F3B5C0], *MEMORY[0x1E4F3B848], v19, v20, v21, v22, v23, (void *)*MEMORY[0x1E4F3B978], *MEMORY[0x1E4F3B998]);
  if (!v29)
  {
LABEL_39:
    _PCSErrorOOM(v62);
    CFRelease(v24);
    return 0;
  }
  int v30 = v29;
  uint64_t v31 = v26;
  uint64_t v63 = (uint64_t)v24;
  CFTypeID v32 = v25;
  if (PCSUseSyncKeychain) {
    CFDictionarySetValue(v29, (const void *)*MEMORY[0x1E4F3B878], v27);
  }
  uint64_t v33 = PCSMeasureRelativeNanoTime();
  ++PCSMeasure;
  int v34 = (*(&_PCSKeychainForwardTable + 1))(v30, 0);
  qword_1EB3B49C0 += PCSMeasureRelativeNanoTime() - v33;
  if (v34 == -25299)
  {
    uint64_t v35 = v32;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412802;
      CFTypeRef v65 = cf1;
      __int16 v66 = 1024;
      LODWORD(v67[0]) = -25299;
      WORD2(v67[0]) = 2112;
      *(void *)((char *)v67 + 6) = v30;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "KeychainSetSecurityDomainStatus(%@): failed to store keychain with %d: %@", buf, 0x1Cu);
    }
    CFRelease(v30);
    int v24 = (const void *)v63;
    int v44 = CFDictionaryCreateMutableForCFTypesWith(v36, v37, v38, v39, v40, v41, v42, v43, key, v63);
    if (v44)
    {
      int v30 = v44;
      int v52 = CFDictionaryCreateMutableForCFTypesWith((int)v44, v45, v46, v47, v48, v49, v50, v51, v35, v31);
      uint64_t v53 = (uint64_t)v52;
      if (v52)
      {
        if (PCSUseSyncKeychain) {
          CFDictionarySetValue(v52, (const void *)*MEMORY[0x1E4F3B878], v27);
        }
        uint64_t v54 = PCSMeasureRelativeNanoTime();
        ++qword_1EB3B49C8;
        int v55 = qword_1EB3B39C0(v53, v30);
        qword_1EB3B49D0 += PCSMeasureRelativeNanoTime() - v54;
        CFRelease((CFTypeRef)v53);
        if (v55)
        {
          PCSSecError(v55, (CFErrorRef *)v62, @"Failed to update: %@", cf1);
          uint64_t v53 = 0;
        }
        else
        {
          uint64_t v53 = 1;
        }
      }
      else
      {
        _PCSErrorOOM(v62);
      }
      goto LABEL_35;
    }
    goto LABEL_39;
  }
  if (v34)
  {
    PCSSecError(v34, (CFErrorRef *)v62, @"Failed to add: %@", cf1);
    uint64_t v53 = 0;
  }
  else
  {
    uint64_t v53 = 1;
  }
  int v24 = (const void *)v63;
LABEL_35:
  CFRelease(v24);
  uint64_t v60 = v30;
LABEL_36:
  CFRelease(v60);
  return v53;
}

void __KeychainIsWalrus_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  BOOL v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("com.apple.ProtectedCloudStorage.OTAccountSettings", v0);
  uint64_t v2 = (void *)KeychainIsWalrus_queue;
  KeychainIsWalrus_queue = (uint64_t)v1;

  uint32_t v3 = notify_register_dispatch("_CDPWalrusStateChangeDarwinNotification", &KeychainIsWalrus_cdpStateToken, (dispatch_queue_t)KeychainIsWalrus_queue, &__block_literal_global_180);
  if (v3)
  {
    uint32_t v4 = v3;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 67109120;
      uint32_t v8 = v4;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "notify_register_dispatch failed: %u", (uint8_t *)&v7, 8u);
    }
  }
  uint32_t v5 = notify_register_dispatch("com.apple.security.octagon.peer-changed", &KeychainIsWalrus_peerChangeToken, (dispatch_queue_t)KeychainIsWalrus_queue, &__block_literal_global_180);
  if (v5)
  {
    uint32_t v6 = v5;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 67109120;
      uint32_t v8 = v6;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "notify_register_dispatch failed: %u", (uint8_t *)&v7, 8u);
    }
  }
}

void __KeychainIsWalrus_block_invoke_2()
{
  BOOL v0 = (void *)KeychainIsWalrus_cachedSettings;
  KeychainIsWalrus_cachedSettings = 0;
}

uint64_t __KeychainIsWalrus_block_invoke_190(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [(id)KeychainIsWalrus_cachedSettings objectForKeyedSubscript:*(void *)(a1 + 32)];
  return MEMORY[0x1F41817F8]();
}

uint64_t __KeychainIsWalrus_block_invoke_2_191(uint64_t a1)
{
  uint64_t v2 = (void *)KeychainIsWalrus_cachedSettings;
  if (!KeychainIsWalrus_cachedSettings)
  {
    id v3 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    uint32_t v4 = (void *)KeychainIsWalrus_cachedSettings;
    KeychainIsWalrus_cachedSettings = (uint64_t)v3;

    uint64_t v2 = (void *)KeychainIsWalrus_cachedSettings;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  return [v2 setObject:v6 forKeyedSubscript:v5];
}

void sub_1ACFC77DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getCDPFollowUpContextClass()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  BOOL v0 = (void *)getCDPFollowUpContextClass_softClass;
  uint64_t v7 = getCDPFollowUpContextClass_softClass;
  if (!getCDPFollowUpContextClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    void v3[2] = __getCDPFollowUpContextClass_block_invoke;
    v3[3] = &unk_1E5E6DDF8;
    v3[4] = &v4;
    __getCDPFollowUpContextClass_block_invoke((uint64_t)v3);
    BOOL v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1ACFC78C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _PCSIsMultiDevice(uint64_t a1)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___PCSIsMultiDevice_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = a1;
  if (_PCSIsMultiDevice_onceToken != -1) {
    dispatch_once(&_PCSIsMultiDevice_onceToken, block);
  }
  return _PCSIsMultiDevice_deviceModeIsMultiUser;
}

CFDictionaryRef _PCSIsiCDPEnabled(const __CFDictionary *a1, int a2)
{
  CFDictionaryRef result = GetiCDPMetadata(a1);
  if (result)
  {
    CFDictionaryRef v5 = result;
    if ((_PCSIsiCDPIsWalrus(a1) & 1) != 0 || _PCSIsiCDPIsPlesio(a1))
    {
      CFNumberRef Value = (const void *)*MEMORY[0x1E4F1CFD0];
      if (!*MEMORY[0x1E4F1CFD0]) {
        return 0;
      }
    }
    else
    {
      if (a2) {
        uint64_t v7 = kPCSMetadataiCDPArmed;
      }
      else {
        uint64_t v7 = kPCSMetadataiCDP;
      }
      CFNumberRef Value = CFDictionaryGetValue(v5, *v7);
      if (!Value) {
        return 0;
      }
    }
    CFTypeID v8 = CFGetTypeID(Value);
    if (v8 != CFBooleanGetTypeID()) {
      return 0;
    }
    return (const __CFDictionary *)(CFBooleanGetValue((CFBooleanRef)Value) != 0);
  }
  return result;
}

CFDictionaryRef GetiCDPMetadata(const __CFDictionary *a1)
{
  CFDictionaryRef result = GetHSMClientMetaData(a1);
  if (result)
  {
    CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(result, kPCSSecureBackupCFiCloudDataProtectionKey[0]);
    if (result)
    {
      CFDictionaryRef v2 = result;
      CFTypeID v3 = CFGetTypeID(result);
      if (v3 == CFDictionaryGetTypeID()) {
        return v2;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

CFDictionaryRef _PCSIsiCDPIsWalrus(const __CFDictionary *a1)
{
  CFDictionaryRef result = GetiCDPMetadata(a1);
  if (result)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(result, kPCSMetadataiCDPWalrus[0]);
    CFDictionaryRef result = 0;
    if (Value)
    {
      CFBooleanRef v3 = Value;
      CFTypeID v4 = CFGetTypeID(Value);
      if (v4 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v3)) {
          return (const __CFDictionary *)1;
        }
      }
    }
  }
  return result;
}

CFDictionaryRef _PCSIsiCDPIsPlesio(const __CFDictionary *a1)
{
  CFDictionaryRef result = GetiCDPMetadata(a1);
  if (result)
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(result, kPCSMetadataiCDPDrop[0]);
    CFDictionaryRef result = 0;
    if (Value)
    {
      CFBooleanRef v3 = Value;
      CFTypeID v4 = CFGetTypeID(Value);
      if (v4 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v3)) {
          return (const __CFDictionary *)1;
        }
      }
    }
  }
  return result;
}

id _PCSMessagesBackupPath(uint64_t a1)
{
  return LocalStorageCreatePath(a1, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/Backup", @"messages");
}

id LocalStorageCreatePath(uint64_t a1, void *a2, void *a3)
{
  CFDictionaryRef v5 = (objc_class *)NSString;
  id v6 = a3;
  id v7 = a2;
  id v8 = [v5 alloc];
  uint64_t v9 = (void *)[v8 initWithFormat:@"%@/%@-%@.%@", v7, kPCSServiceName[0], a1, v6];

  return v9;
}

uint64_t PCSIdentitySynchronizeKeys(CFTypeRef cf, const void **a2)
{
  return PCSIdentityMigrateEngineExecute((uint64_t)&synchronizeKeys, @"SynchronizeKeys", cf, a2);
}

uint64_t PCSIdentityMigrateEngineExecute(uint64_t a1, const void *a2, CFTypeRef cf, const void **a4)
{
  CFDictionaryRef v5 = PCSIdentityMigrateEngineCreate(a1, a2, 1, cf, a4);
  id v6 = v5;
  if (v5) {
    uint64_t v7 = PCSIdentityMigrateEngineRun(v5, (uint64_t *)a4);
  }
  else {
    uint64_t v7 = 0;
  }

  return v7;
}

uint64_t PCSIdentityMigrateToiCDP(void *a1, void *a2)
{
  id v7 = 0;
  uint64_t v3 = PCSAccountMigrateToiCDP(0, a1, &v7);
  id v4 = v7;
  CFDictionaryRef v5 = v4;
  if (a2 && v4) {
    *a2 = v4;
  }

  return v3;
}

uint64_t _PCSIdentityMigrateToiCDP(CFTypeRef cf, const void **a2)
{
  return PCSIdentityMigrateEngineExecute((uint64_t)&migrateiCDP, @"MigrateiCDP", cf, a2);
}

uint64_t PCSIdentityMigrateCloseDoor(CFTypeRef cf, const void **a2)
{
  return PCSIdentityMigrateEngineExecute((uint64_t)&migrateCloseDoor, @"CloseDoor", cf, a2);
}

uint64_t PCSIdentityMigrateDropStingray(CFTypeRef cf, const void **a2)
{
  return PCSIdentityMigrateEngineExecute((uint64_t)&migrateDropHSM, @"MigrateDropHSM", cf, a2);
}

uint64_t PCSIdentityMigrateRestoreHSM(CFTypeRef cf, const void **a2)
{
  return PCSIdentityMigrateEngineExecute((uint64_t)&migrateRestoreHSM, @"MigrateRestoreHSM", cf, a2);
}

uint64_t _PCSIdentityMigrateEnableWalrus(const void *a1, const void **a2)
{
  id v4 = (void *)os_transaction_create();
  CFDictionaryRef v5 = +[PCSLockManager manager];
  id v6 = [NSString stringWithUTF8String:"com.apple.protectedcloudstorage.migrateenablewalrus"];
  id v7 = [v5 lockAssertion:v6];

  if ([v7 holdAssertion])
  {
    uint64_t v8 = PCSIdentityMigrateEngineExecute((uint64_t)&migrateEnableWalrus, @"MigrateEnableWalrus", a1, a2);
    [v7 dropAssertion];
  }
  else
  {
    PCSMigrationLog(0, @"Failed to get lock assertion, failing migration step");
    _PCSError(a2, 151, @"Failed to get lock assertion");
    uint64_t v8 = 0;
  }

  return v8;
}

uint64_t _PCSIdentityMigrateDisableWalrus(const void *a1, const void **a2)
{
  id v4 = (void *)os_transaction_create();
  CFDictionaryRef v5 = +[PCSLockManager manager];
  id v6 = [NSString stringWithUTF8String:"com.apple.protectedcloudstorage.migratedisablewalrus"];
  id v7 = [v5 lockAssertion:v6];

  if ([v7 holdAssertion])
  {
    uint64_t v8 = PCSIdentityMigrateEngineExecute((uint64_t)&migrateDisableWalrus, @"MigrateDisableWalrus", a1, a2);
    [v7 dropAssertion];
  }
  else
  {
    PCSMigrationLog(0, @"Failed to get lock assertion, failing migration step");
    _PCSError(a2, 151, @"Failed to get lock assertion");
    uint64_t v8 = 0;
  }

  return v8;
}

CFTypeRef PCSIdentitySetup(CFTypeRef cf, const void **a2)
{
  uint64_t v3 = PCSIdentityMigrateEngineCreate((uint64_t)&setupIdentities, @"SetupIdentities", 1, cf, a2);
  id v4 = v3;
  if (v3 && PCSIdentityMigrateEngineRun(v3, (uint64_t *)a2) && [v4 set]) {
    CFTypeRef v5 = CFRetain((CFTypeRef)[v4 set]);
  }
  else {
    CFTypeRef v5 = 0;
  }

  return v5;
}

PCSMigrationState *PCSIdentityMigrateEngineCreate(uint64_t a1, const void *a2, int a3, CFTypeRef cf, const void **a5)
{
  if (!cf || (CFTypeID v10 = CFGetTypeID(cf), v10 != CFDictionaryGetTypeID()))
  {
    _PCSError(a5, 127, @"Missing options dictionary");
    goto LABEL_22;
  }
  CFBooleanRef Value = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, kPCSSetupLogFacility[0]);
  if (Value)
  {
    int v12 = Value;
    CFTypeID v13 = CFGetTypeID(Value);
    if (v13 != CFStringGetTypeID())
    {
      _PCSError(a5, 126, @"Log facility not a string");
LABEL_22:
      CFDataRef v18 = 0;
      goto LABEL_18;
    }
  }
  else if (a3)
  {
    int v12 = @"PCSMigration";
  }
  else
  {
    int v12 = @"PCSMisc";
  }
  if (a3) {
    int v14 = a2;
  }
  else {
    int v14 = 0;
  }
  uint64_t v15 = PCSCreateLogContext(v14, (char *)v12);
  if (!v15) {
    goto LABEL_22;
  }
  int v16 = (const void *)v15;
  uint64_t v17 = objc_alloc_init(PCSMigrationState);
  CFDataRef v18 = v17;
  if (v17)
  {
    [(PCSMigrationState *)v17 setFirstStep:a1];
    [(PCSMigrationState *)v18 setCurrentStep:a1];
    [(PCSMigrationState *)v18 setOptions:CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)cf)];
    [(PCSMigrationState *)v18 setLog:CFRetain(v16)];
    [(PCSMigrationState *)v18 setType:CFRetain(a2)];
    [(PCSMigrationState *)v18 setNewIdentity:0];
    [(PCSMigrationState *)v18 setModified:0];
    CFDictionaryRef v19 = [(PCSMigrationState *)v18 options];
    if (!CFDictionaryGetValue(v19, kPCSSetupLogContext[0]))
    {
      int v20 = [(PCSMigrationState *)v18 options];
      CFDictionarySetValue(v20, kPCSSetupLogContext[0], v16);
    }
    int v21 = v18;
  }
  CFRelease(v16);
LABEL_18:

  return v18;
}

uint64_t PCSIdentityMigrateEngineRun(void *a1, uint64_t *a2)
{
  id v3 = a1;
  int v24 = (void *)MEMORY[0x1AD11CE50]();
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  int v23 = (void *)os_transaction_create();
  PCSMigrationLog([v3 log], @"%@ start", objc_msgSend(v3, "type"));
  id v4 = _os_activity_create(&dword_1ACF98000, "PCSMigrationEngine", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  CFTypeRef v5 = v4;
  if (v4) {
    os_activity_scope_enter(v4, &state);
  }
  while (*(void *)([v3 currentStep] + 8))
  {
    if ([v3 done]) {
      break;
    }
    uint64_t v6 = [v3 currentStep];
    objc_msgSend(v3, "setCurrentStep:", objc_msgSend(v3, "currentStep") + 16);
    uint64_t v7 = [v3 log];
    uint64_t v8 = [v3 type];
    uint64_t v9 = *(void *)v6;
    if ([v3 modified]) {
      CFTypeID v10 = " (modified)";
    }
    else {
      CFTypeID v10 = "";
    }
    PCSMigrationLog(v7, @"  running %@ step %@%s", v8, v9, v10);
    if (!(*(unsigned int (**)(id, uint64_t *))(v6 + 8))(v3, a2)) {
      goto LABEL_16;
    }
    if ([v3 restart])
    {
      if ([v3 restartCounter] > 4) {
        goto LABEL_16;
      }
      PCSMigrationLog([v3 log], @"  starting migration to the begining: %u", objc_msgSend(v3, "restartCounter"));
      [v3 setRestart:0];
      objc_msgSend(v3, "setCurrentStep:", objc_msgSend(v3, "firstStep"));
      objc_msgSend(v3, "setRestartCounter:", objc_msgSend(v3, "restartCounter") + 1);
      [v3 softReset];
      uint32_t v11 = arc4random_uniform(2 * [v3 restartCounter] + 10);
      sleep(v11 + 5);
    }
  }
  if (*(void *)([v3 currentStep] + 8) && !objc_msgSend(v3, "done")) {
LABEL_16:
  }
    uint64_t v12 = 0;
  else {
    uint64_t v12 = 1;
  }
  CFDictionaryRef v13 = (const __CFDictionary *)[v3 options];
  int v14 = CFDictionaryGetValue(v13, kPCSSetupStatistics[0]);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v15 = objc_msgSend(NSNumber, "numberWithUnsignedInt:", objc_msgSend(v3, "numberIdentityMissing"));
    [v14 setObject:v15 forKeyedSubscript:@"numberIdentityMissing"];

    int v16 = objc_msgSend(NSNumber, "numberWithBool:", objc_msgSend(v3, "modified"));
    [v14 setObject:v16 forKeyedSubscript:@"modified"];

    if ([v3 missingFromRegistry]) {
      objc_msgSend(v14, "setObject:forKeyedSubscript:", objc_msgSend(v3, "missingFromRegistry"), @"missingFromRegistry");
    }
    if ([v3 brokenEncryptedMetadatakeys]) {
      [v14 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:@"brokenEncryptedMetadatakeys"];
    }
  }
  uint64_t v17 = [v3 log];
  uint64_t v18 = [v3 type];
  CFDictionaryRef v19 = @"failed";
  if (v12) {
    CFDictionaryRef v19 = @"success";
  }
  if (a2) {
    char v20 = v12;
  }
  else {
    char v20 = 1;
  }
  if (v20) {
    uint64_t v21 = 0;
  }
  else {
    uint64_t v21 = *a2;
  }
  PCSMigrationLog(v17, @"%@ complete: %@ (error: %@)", v18, v19, v21);
  if (v5) {
    os_activity_scope_leave(&state);
  }

  return v12;
}

CFTypeRef PCSIdentityLegacySetup(CFTypeRef cf, const void **a2)
{
  id v3 = PCSIdentityMigrateEngineCreate((uint64_t)&legacySetupIdentities, @"LegacySetupIdentities", 1, cf, a2);
  if (!v3) {
    goto LABEL_9;
  }
  if (GetLegacyServiceArray_onceToken != -1) {
    dispatch_once(&GetLegacyServiceArray_onceToken, &__block_literal_global_1062);
  }
  [v3 setLimitLocalStoring:GetLegacyServiceArray_array];
  id v4 = (const void *)[v3 limitLocalStoring];
  if (v4) {
    CFRetain(v4);
  }
  if (PCSIdentityMigrateEngineRun(v3, (uint64_t *)a2) && [v3 set]) {
    CFTypeRef v5 = CFRetain((CFTypeRef)[v3 set]);
  }
  else {
LABEL_9:
  }
    CFTypeRef v5 = 0;

  return v5;
}

uint64_t PCSIdentitySetValidate(const void *a1, CFTypeRef cf, uint64_t a3, const void **a4)
{
  int v9 = cf
    && (CFTypeID v8 = CFGetTypeID(cf), v8 == CFDictionaryGetTypeID())
    && CFDictionaryGetValue((CFDictionaryRef)cf, kPCSSetupForceLogging[0]) != 0;
  if (!a3)
  {
    _PCSError(a4, 123, @"needPassword param missing");
    CFTypeID v10 = 0;
    goto LABEL_20;
  }
  *(unsigned char *)a3 = 0;
  CFTypeID v10 = PCSIdentityMigrateEngineCreate((uint64_t)&validateKeys, @"ValidateCredentials", v9, cf, a4);
  if (!v10) {
    goto LABEL_21;
  }
  [v10 setSet:CFRetain(a1)];
  if (!a1) {
    goto LABEL_21;
  }
  CFDictionaryRef v11 = (const __CFDictionary *)[v10 options];
  CFBooleanRef Value = CFDictionaryGetValue(v11, kPCSSetupForceValidateKey[0]);
  if (!Value || (CFTypeID v13 = CFGetTypeID(Value), v13 != CFBooleanGetTypeID())) {
    [v10 setRequireIdentityInHSM:1];
  }
  int v14 = PCSIdentityMigrateEngineRun(v10, (uint64_t *)a4);
  int v15 = v14;
  if (a4)
  {
    if ((v14 & 1) == 0)
    {
      if (*a4)
      {
        CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)*a4);
        if (CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E4F289A0]))
        {
          PCSMigrationLog([v10 log], @"PCS skipping validation failure since error is network issue: %@", *a4);
          uint64_t v17 = *a4;
          if (*a4)
          {
            *a4 = 0;
            CFRelease(v17);
          }
          [v10 setNeedPassword:0];
          goto LABEL_19;
        }
      }
    }
  }
  if (!v15)
  {
LABEL_21:
    a3 = 0;
    goto LABEL_20;
  }
LABEL_19:
  *(unsigned char *)a3 = [v10 needPassword];
  a3 = 1;
LABEL_20:

  return a3;
}

BOOL PCSIdentityHaveiCloudIdentityLocally(void *a1, int a2)
{
  id v3 = a1;
  id v4 = v3;
  if (v3 && ([v3 isEqualToString:kPCSSetupDSIDAny[0]] & 1) == 0 && PCSCurrentPersonaMatchesDSID(v4))
  {
    CFTypeID v10 = (void *)__PCSCopyFromiCloudKeychain(v4, a2, 0, v5, v6, v7, v8, v9);
    BOOL v11 = v10 != 0;
  }
  else
  {
    BOOL v11 = 0;
  }

  return v11;
}

uint64_t PCSIdentityMigrateRestoreLocalBackup(CFTypeRef cf, const void **a2)
{
  return PCSIdentityMigrateEngineExecute((uint64_t)&restoreLocalBackup, @"MigrateRestoreLocalBackup", cf, a2);
}

BOOL PCSIdentityiCDPSignOut(void *a1, const void **a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  if (a1)
  {
    __PCSDeleteFromKeychainICDP(a1, 0, a3, a4, a5, a6, a7, a8);
    __PCSDeleteKeyfile(a1, 0);
    _PCSGuitarfishDeleteKeychainState(a1);
  }
  else
  {
    _PCSError(a2, 121, @"iCDPSignOut missing DSID");
  }
  return a1 != 0;
}

uint64_t __PCSDeleteKeyfile(const void *a1, const void **a2)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 != CFStringGetTypeID())
    {
      _PCSErrorContext(0, a2, 121, @"Missing parameter: dsid");
      return 0;
    }
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    v54[0] = @"backup";
    v54[1] = @"witness";
    int v5 = [MEMORY[0x1E4F1C978] arrayWithObjects:v54 count:2];
    uint64_t v6 = [v5 countByEnumeratingWithState:&v40 objects:v55 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)v41;
      do
      {
        uint64_t v9 = 0;
        do
        {
          if (*(void *)v41 != v8) {
            objc_enumerationMutation(v5);
          }
          CFTypeID v10 = LocalStorageCreatePath((uint64_t)a1, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/LocalBackup", *(void **)(*((void *)&v40 + 1) + 8 * v9));
          BOOL v11 = [MEMORY[0x1E4F28CB8] defaultManager];
          [v11 removeItemAtPath:v10 error:0];

          ++v9;
        }
        while (v7 != v9);
        uint64_t v7 = [v5 countByEnumeratingWithState:&v40 objects:v55 count:16];
      }
      while (v7);
    }

    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    int v52 = @"messages";
    uint64_t v12 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v52 count:1];
    uint64_t v13 = [v12 countByEnumeratingWithState:&v36 objects:v53 count:16];
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = *(void *)v37;
      do
      {
        uint64_t v16 = 0;
        do
        {
          if (*(void *)v37 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = LocalStorageCreatePath((uint64_t)a1, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/Backup", *(void **)(*((void *)&v36 + 1) + 8 * v16));
          uint64_t v18 = [MEMORY[0x1E4F28CB8] defaultManager];
          [v18 removeItemAtPath:v17 error:0];

          ++v16;
        }
        while (v14 != v16);
        uint64_t v14 = [v12 countByEnumeratingWithState:&v36 objects:v53 count:16];
      }
      while (v14);
    }
  }
  else
  {
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    v57[0] = @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/LocalBackup";
    v57[1] = @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/Backup";
    obuint64_t j = [MEMORY[0x1E4F1C978] arrayWithObjects:v57 count:2];
    uint64_t v19 = [obj countByEnumeratingWithState:&v48 objects:v58 count:16];
    if (v19)
    {
      uint64_t v20 = v19;
      uint64_t v35 = *(void *)v49;
      do
      {
        uint64_t v21 = 0;
        do
        {
          if (*(void *)v49 != v35) {
            objc_enumerationMutation(obj);
          }
          uint64_t v22 = *(void *)(*((void *)&v48 + 1) + 8 * v21);
          int v23 = [MEMORY[0x1E4F28CB8] defaultManager];
          int v24 = [v23 contentsOfDirectoryAtPath:v22 error:0];

          long long v46 = 0u;
          long long v47 = 0u;
          long long v44 = 0u;
          long long v45 = 0u;
          id v25 = v24;
          uint64_t v26 = [v25 countByEnumeratingWithState:&v44 objects:v56 count:16];
          if (v26)
          {
            uint64_t v27 = v26;
            uint64_t v28 = *(void *)v45;
            do
            {
              uint64_t v29 = 0;
              do
              {
                if (*(void *)v45 != v28) {
                  objc_enumerationMutation(v25);
                }
                uint64_t v30 = *(void *)(*((void *)&v44 + 1) + 8 * v29);
                uint64_t v31 = [MEMORY[0x1E4F28CB8] defaultManager];
                CFTypeID v32 = [@"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/LocalBackup" stringByAppendingPathComponent:v30];
                [v31 removeItemAtPath:v32 error:0];

                ++v29;
              }
              while (v27 != v29);
              uint64_t v27 = [v25 countByEnumeratingWithState:&v44 objects:v56 count:16];
            }
            while (v27);
          }

          ++v21;
        }
        while (v21 != v20);
        uint64_t v20 = [obj countByEnumeratingWithState:&v48 objects:v58 count:16];
      }
      while (v20);
    }
  }
  return 1;
}

CFTypeRef PCSIdentityRecoverFDE(CFTypeRef cf, const void **a2)
{
  CFTypeID v4 = PCSIdentityMigrateEngineCreate((uint64_t)&recoverFDE, @"RecoveryFDE", 1, cf, a2);
  int v5 = v4;
  if (!v4 || !PCSIdentityMigrateEngineRun(v4, (uint64_t *)a2))
  {
    CFTypeRef v6 = 0;
    goto LABEL_10;
  }
  if ([v5 set])
  {
    CFTypeRef v6 = CFRetain((CFTypeRef)[v5 set]);
    if (!cf) {
      goto LABEL_10;
    }
  }
  else
  {
    CFTypeRef v6 = 0;
    if (!cf) {
      goto LABEL_10;
    }
  }
  CFBooleanRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, kPCSSetupService[0]);
  if (Value)
  {
    uint64_t v8 = Value;
    CFTypeID v9 = CFGetTypeID(Value);
    if (v9 == CFStringGetTypeID()) {
      _PCSIdentitySetSetService([v5 set], v8);
    }
  }
LABEL_10:

  return v6;
}

uint64_t PCSIdentityiCDPWalrus(uint64_t a1, uint64_t a2, const void **a3)
{
  return PCSIdentitySetIsWalrusWithForceFetch(a1, 0, a3);
}

CFDictionaryRef PCSIdentityiCDPPlesio(uint64_t a1, int a2, const __CFDictionary *a3, const void **a4)
{
  if (a2)
  {
    CFDictionaryRef result = (const __CFDictionary *)__PCSCopyStingrayInfo(0, a3, a4);
    if (result)
    {
      CFDictionaryRef v5 = result;
      CFDictionaryRef v6 = _PCSIsiCDPIsPlesio(result);
      CFRelease(v5);
      return v6;
    }
  }
  else
  {
    return (const __CFDictionary *)PCSIdentitySetIsPlesio(a1, a4);
  }
  return result;
}

void __getCDPFollowUpContextClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("CDPFollowUpContext");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getCDPFollowUpContextClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    __getCDPFollowUpContextClass_block_invoke_cold_1();
    CoreCDPLibrary();
  }
}

void CoreCDPLibrary()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v1[0] = 0;
  if (!CoreCDPLibraryCore_frameworkLibrary)
  {
    v1[1] = MEMORY[0x1E4F143A8];
    v1[2] = 3221225472;
    v1[3] = __CoreCDPLibraryCore_block_invoke;
    v1[4] = &__block_descriptor_40_e5_v8__0l;
    v1[5] = v1;
    long long v2 = xmmword_1E5E6E668;
    uint64_t v3 = 0;
    CoreCDPLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  BOOL v0 = (void *)v1[0];
  if (!CoreCDPLibraryCore_frameworkLibrary)
  {
    BOOL v0 = (void *)abort_report_np();
    goto LABEL_7;
  }
  if (v1[0]) {
LABEL_7:
  }
    free(v0);
}

uint64_t __CoreCDPLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreCDPLibraryCore_frameworkLibrary = result;
  return result;
}

CFDictionaryRef __getCDPFollowUpControllerClass_block_invoke(uint64_t a1)
{
  CoreCDPLibrary();
  CFDictionaryRef result = objc_getClass("CDPFollowUpController");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getCDPFollowUpControllerClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    CFDictionaryRef v3 = (const __CFDictionary *)__getCDPFollowUpControllerClass_block_invoke_cold_1();
    return GetHSMClientMetaData(v3);
  }
  return result;
}

CFDictionaryRef GetHSMClientMetaData(const __CFDictionary *a1)
{
  CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(a1, (const void *)*MEMORY[0x1E4F59B88]);
  if (result)
  {
    CFDictionaryRef v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFDictionaryGetTypeID())
    {
      CFDictionaryRef result = (const __CFDictionary *)CFDictionaryGetValue(v2, kPCSSecureBackupCFClientMetadataKey[0]);
      if (result)
      {
        CFDictionaryRef v4 = result;
        CFTypeID v5 = CFGetTypeID(result);
        if (v5 == CFDictionaryGetTypeID()) {
          return v4;
        }
        else {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t PCSEngineLogStatus(void *a1)
{
  id v1 = a1;
  CFTypeRef cf = 0;
  CFTypeRef v2 = PCSIdentitySetCreate((const __CFDictionary *)[v1 options], 0, &cf);
  CFTypeID v3 = v2;
  if (v2)
  {
    CFDictionaryRef v4 = _PCSIdentitySetCopyCurrentIdentityInternal((uint64_t)v2, kPCSServiceMaster, &cf);
    uint64_t v5 = [v1 log];
    if (v4)
    {
      PCSMigrationLog(v5, @"Master identity: %@", v4);
    }
    else
    {
      PCSMigrationLog(v5, @"Failed getting master key: %@", cf);
      CFTypeRef v8 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v8);
      }
    }
    unsigned int IsICDP = PCSIdentitySetIsICDP((uint64_t)v3, &cf);
    CFTypeRef v10 = cf;
    uint64_t v11 = [v1 log];
    if (v10) {
      PCSMigrationLog(v11, @"Failed getting iCDPState: %@", cf);
    }
    else {
      PCSMigrationLog(v11, @"Local iCDP status is %d", IsICDP);
    }
  }
  else
  {
    uint64_t v6 = [v1 log];
    PCSMigrationLog(v6, @"No local credential store: %@", cf);
    CFTypeRef v7 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v7);
    }
    CFDictionaryRef v4 = 0;
  }
  uint64_t v12 = PCSCopyPIIClearedOptions((CFDictionaryRef)[v1 options]);
  PCSMigrationLog([v1 log], @"PCS%@ options: %@", objc_msgSend(v1, "type"), v12);
  uint64_t v13 = [MEMORY[0x1E4FB36F8] sharedManager];
  uint64_t v14 = [v13 currentPersona];

  uint64_t v15 = [v1 log];
  uint64_t v16 = [v14 userPersonaUniqueString];
  PCSMigrationLog(v15, @"Current persona: %@", v16);

  if (v12) {
    CFRelease(v12);
  }
  CFTypeRef v17 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v17);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }

  return 1;
}

uint64_t PCSEnginePreCheckKeychain(void *a1, const void **a2)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  CFDictionaryRef v4 = (const __CFDictionary *)[v3 options];
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSSetupStingray[0]);
  if (Value)
  {
    CFBooleanRef v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFBooleanGetTypeID() && !CFBooleanGetValue(v6))
    {
      uint64_t v13 = 1;
      goto LABEL_11;
    }
  }
  CFDictionaryRef v8 = (const __CFDictionary *)[v3 options];
  CFTypeID v9 = (void *)CFDictionaryGetValue(v8, kPCSSetupDSID[0]);
  if (!v9 || (v10 = v9, CFTypeID v11 = CFGetTypeID(v9), v11 != CFStringGetTypeID()))
  {
    _PCSErrorContext([v3 log], a2, 121, @"Missing parameter: dsid");
    goto LABEL_9;
  }
  BOOL v12 = PCSCurrentPersonaMatchesDSID(v10);
  uint64_t v13 = 1;
  if (a2 && !v12)
  {
    uint64_t v14 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v15 = kPCSErrorDomain;
    uint64_t v18 = *MEMORY[0x1E4F28568];
    v19[0] = @"Current persona does not match chosen dsid";
    uint64_t v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v19 forKeys:&v18 count:1];
    *a2 = [v14 errorWithDomain:v15 code:152 userInfo:v16];

LABEL_9:
    uint64_t v13 = 0;
  }
LABEL_11:

  return v13;
}

BOOL PCSEngineFetchMetaData(void *a1, void *a2)
{
  id v3 = a1;
  [v3 clearMetadata];
  objc_msgSend(v3, "setMetadata:", __PCSCopyStingrayInfo(objc_msgSend(v3, "log"), (const __CFDictionary *)objc_msgSend(v3, "options"), a2));
  uint64_t v4 = [v3 metadata];

  return v4 != 0;
}

uint64_t PCSEnginePrepareMetaData(void *a1)
{
  id v1 = a1;
  uint64_t v2 = CaptureMetadata(v1, (const __CFDictionary *)[v1 metadata]);
  if (v2)
  {
    CFDictionaryRef v3 = GetiCDPMetadata((const __CFDictionary *)[v1 metadata]);
    if (v3)
    {
      CFDictionaryRef v4 = v3;
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v3, kPCSMetadataiCDP[0]);
      v8 = Value && (v6 = Value, CFTypeID v7 = CFGetTypeID(Value), v7 == CFBooleanGetTypeID()) && CFBooleanGetValue(v6) != 0;
      [v1 setICDPHSM:v8];
      CFBooleanRef v9 = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSMetadataiCDPArmed[0]);
      v12 = v9 && (v10 = v9, CFTypeID v11 = CFGetTypeID(v9), v11 == CFBooleanGetTypeID()) && CFBooleanGetValue(v10) != 0;
      [v1 setICDPHSMArmed:v12];
      CFBooleanRef v13 = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSMetadataiCDPWalrus[0]);
      v16 = v13 && (v14 = v13, CFTypeID v15 = CFGetTypeID(v13), v15 == CFBooleanGetTypeID()) && CFBooleanGetValue(v14) != 0;
      [v1 setICDPHSMWalrus:v16];
      CFBooleanRef v17 = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSMetadataiCDPDrop[0]);
      if (v17 && (v18 = v17, CFTypeID v19 = CFGetTypeID(v17), v19 == CFBooleanGetTypeID()))
      {
        BOOL v20 = CFBooleanGetValue(v18) != 0;
        uint64_t v21 = v1;
      }
      else
      {
        uint64_t v21 = v1;
        BOOL v20 = 0;
      }
      [v21 setICDPHSMPlesio:v20];
    }
    else
    {
      CFDictionaryRef v22 = (const __CFDictionary *)[v1 options];
      int v23 = CFDictionaryGetValue(v22, kPCSSetupDSID[0]);
      id v28 = 0;
      BOOL v24 = +[PCSAccountsModel adpEnabledForDSID:v23 error:&v28];
      id v25 = v28;
      uint64_t v26 = [v1 log];
      if (v24)
      {
        PCSMigrationLog(v26, @"iCDP metadata is missing, but OTAccountSettings indicate that ADP is enabled");
        [v1 setICDPHSMWalrus:1];
      }
      else
      {
        PCSMigrationLog(v26, @"Unable to determine ADP state: %@", v25);
      }
    }
    PCSMigrationLog([v1 log], @"Stingray iCDP status is armed %d icdp %d walrus %d plesio %d", objc_msgSend(v1, "iCDPHSMArmed"), objc_msgSend(v1, "iCDPHSM"), objc_msgSend(v1, "iCDPHSMWalrus"), objc_msgSend(v1, "iCDPHSMPlesio"));
  }

  return v2;
}

uint64_t PCSEngineCheckForceUpdate(void *a1)
{
  id v1 = a1;
  CFDictionaryRef v2 = (const __CFDictionary *)[v1 options];
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v2, kPCSSetupForceUpdate[0]);
  if (Value)
  {
    CFBooleanRef v4 = Value;
    CFTypeID v5 = CFGetTypeID(Value);
    if (v5 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v4)) {
        [v1 setModified:1];
      }
    }
  }
  if ([v1 metadata])
  {
    CFDictionaryRef v6 = (const __CFDictionary *)[v1 metadata];
    CFDictionaryRef v7 = (const __CFDictionary *)CFDictionaryGetValue(v6, (const void *)*MEMORY[0x1E4F59B88]);
    if (v7)
    {
      CFDictionaryRef v8 = v7;
      CFTypeID v9 = CFGetTypeID(v7);
      if (v9 == CFDictionaryGetTypeID())
      {
        if (([v1 iCDPHSMWalrus] & 1) == 0 && (objc_msgSend(v1, "iCDPHSMPlesio") & 1) == 0)
        {
          CFBooleanRef v10 = (const __CFBoolean *)CFDictionaryGetValue(v8, kPCSSecureBackupCFTriggerUpdate[0]);
          if (v10)
          {
            CFBooleanRef v11 = v10;
            CFTypeID v12 = CFGetTypeID(v10);
            if (v12 == CFBooleanGetTypeID()) {
              [v1 setTriggerUpdate:CFBooleanGetValue(v11) != 0];
            }
          }
        }
        if ([v1 triggerUpdate]) {
          [v1 setModified:1];
        }
      }
    }
  }

  return 1;
}

uint64_t PCSEngineDifferentOnDroppedKeys(void *a1)
{
  id v1 = a1;
  if (([v1 iCDPHSMWalrus] & 1) != 0 || objc_msgSend(v1, "iCDPHSMPlesio"))
  {
    if (PCSEngineHaveSyncEnoughToCreateIdentities(v1, 0)) {
      [v1 setCurrentStep:&validationInNoTouchHSMContent];
    }
    else {
      [v1 setDone:1];
    }
  }

  return 1;
}

uint64_t PCSEngineEnsureClassicContent(void *a1, const void **a2)
{
  v72[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  CFDictionaryRef v4 = (const __CFDictionary *)[v3 options];
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v4, kPCSSetupUsername[0]);
  CFDictionaryRef v6 = (const __CFDictionary *)[v3 options];
  CFDictionaryRef v7 = CFDictionaryGetValue(v6, kPCSSetupPassword[0]);
  CFDictionaryRef v8 = (const __CFDictionary *)[v3 options];
  CFTypeID v9 = (__CFString *)CFDictionaryGetValue(v8, kPCSSetupDSID[0]);
  BOOL v10 = PCSCurrentPersonaMatchesDSID(v9);
  if (a2 && !v10)
  {
    CFBooleanRef v11 = (void *)MEMORY[0x1E4F28C58];
    CFTypeID v12 = kPCSErrorDomain;
    uint64_t v71 = *MEMORY[0x1E4F28568];
    v72[0] = @"Current persona does not match chosen dsid";
    CFBooleanRef v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v72 forKeys:&v71 count:1];
    *a2 = [v11 errorWithDomain:v12 code:152 userInfo:v13];

LABEL_4:
    uint64_t v14 = 0;
    goto LABEL_5;
  }
  if (![v3 metadata])
  {
    _PCSErrorContext([v3 log], a2, 126, @"Metadata missing");
    goto LABEL_21;
  }
  CFDictionaryRef v16 = (const __CFDictionary *)[v3 metadata];
  CFBooleanRef v17 = CFDictionaryGetValue(v16, kPCSSecureBackupCFContainsiCloudIdentityKey[0]);
  if (!v17) {
    goto LABEL_17;
  }
  CFBooleanRef v18 = v17;
  CFTypeID v19 = CFGetTypeID(v17);
  if (v19 != CFBooleanGetTypeID())
  {
    CFTypeID v21 = CFGetTypeID(v18);
    if (v21 == CFNumberGetTypeID())
    {
      LODWORD(valuePtr) = 0;
      if (CFNumberGetValue((CFNumberRef)v18, kCFNumberSInt32Type, &valuePtr)) {
        BOOL v20 = valuePtr == 0;
      }
      else {
        BOOL v20 = 1;
      }
      goto LABEL_14;
    }
LABEL_17:
    int v22 = 0;
    goto LABEL_18;
  }
  BOOL v20 = CFBooleanGetValue((CFBooleanRef)v18) == 0;
LABEL_14:
  int v22 = !v20;
LABEL_18:
  if ([v3 iCDP] && (v22 & 1) == 0)
  {
    _PCSErrorContext([v3 log], a2, 58, @"iCDP enabled and no stingray content");
    goto LABEL_21;
  }
  if ((([v3 requireIdentityInHSM] ^ 1 | v22) & 1) == 0)
  {
    _PCSErrorContext([v3 log], a2, 58, @"No writing allowed");
    uint64_t v14 = 1;
    [v3 setNeedPassword:1];
    [v3 setDone:1];
    goto LABEL_5;
  }
  uint64_t IsGuitarfish = _PCSMigrationStateIsGuitarfish(v3);
  if (!v22)
  {
    if (!v7)
    {
      _PCSErrorContext([v3 log], a2, 123, @"Need password to push identities");
      goto LABEL_21;
    }
    objc_msgSend(v3, "setClassicContent:", __PCSCopyFromiCloudKeychain(v9, IsGuitarfish, 0, v26, v27, v28, v29, v30));
    uint64_t v36 = [v3 classicContent];
    if (!v36) {
      objc_msgSend(v3, "setClassicContent:", __PCSCopyFromKeychain(IsGuitarfish, Value, v9, 0, v43, v44, v45, v46));
    }
    if (![v3 classicContent])
    {
      [v3 setNewIdentity:1];
      uint64_t v60 = pcsLogObjForScope("migration");
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(valuePtr) = 0;
        _os_log_impl(&dword_1ACF98000, v60, OS_LOG_TYPE_DEFAULT, "Classic content is missing; requesting new identities",
          (uint8_t *)&valuePtr,
          2u);
      }

      goto LABEL_70;
    }
    PCSMigrationLog([v3 log], @"Detected missing/lost escrow data, will attempt to restore.");
    [v3 setEscrowMissing:1];
LABEL_64:
    if (v36)
    {
      CFTypeRef v62 = __PCSCopyFromKeychain(IsGuitarfish, Value, v9, 0, v47, v48, v49, v50);
      if (v62)
      {
        uint64_t v63 = v62;
        if (!CFEqual(v62, (CFTypeRef)[v3 classicContent])) {
          PCSMigrationLog([v3 log], @"sync and non sync keychain doesn't match!");
        }
        CFRelease(v63);
      }
      goto LABEL_70;
    }
    goto LABEL_69;
  }
  objc_msgSend(v3, "setClassicContent:", __PCSCopyFromiCloudKeychain(v9, IsGuitarfish, 0, v26, v27, v28, v29, v30));
  uint64_t v36 = [v3 classicContent];
  if (!v36) {
    objc_msgSend(v3, "setClassicContent:", __PCSCopyFromKeychain(IsGuitarfish, Value, v9, 0, v32, v33, v34, v35));
  }
  if ([v3 classicContent])
  {
    int v37 = _PCSMigrationStateIsGuitarfish(v3);
    uint64_t v38 = [v3 log];
    if (v37)
    {
      PCSMigrationLog(v38, @"copy of escrow data found in keychain");
      int valuePtr = 0;
      if (checkData([v3 log], (CFDictionaryRef)objc_msgSend(v3, "metadata"), (const __CFData *)objc_msgSend(v3, "classicContent"), &valuePtr))
      {
        goto LABEL_70;
      }
      uint64_t v39 = [v3 log];
      PCSMigrationLog(v39, @"local escrow data invalid, replacing with contents from escrow: %@", valuePtr);
      long long v40 = valuePtr;
      if (valuePtr)
      {
        int valuePtr = 0;
        CFRelease(v40);
      }
      long long v41 = _PCSMigrationRecoverPPasswordFromStashedKey(v3, v9);
      if (v41)
      {
        CFRelease((CFTypeRef)[v3 classicContent]);
        CFDataRef v42 = v41;
      }
      else
      {
        if (!fail_and_cfu_if_no_password(0, 1, v3, (const __CFDictionary *)[v3 options], (uint64_t *)a2))goto LABEL_82; {
        CFRelease((CFTypeRef)[v3 classicContent]);
        }
        CFDataRef v42 = __PCSCopyHSMData([v3 log], objc_msgSend(v3, "options"), a2);
      }
      [v3 setClassicContent:v42];
      if ([v3 classicContent])
      {
        uint64_t v64 = [v3 classicContent];
        BOOL v69 = __PCSUpdateIniCloudKeychain(v64, (int)v9, IsGuitarfish, a2, v65, v66, v67, v68);

        if (!v69) {
          goto LABEL_21;
        }
        goto LABEL_70;
      }
      PCSMigrationLog([v3 log], @"__PCSCopyHSMData failed");
LABEL_82:

      goto LABEL_21;
    }
    PCSMigrationLog(v38, @"No need to use escrow proxy at this point");
    int valuePtr = 0;
    if (!checkData([v3 log], (CFDictionaryRef)objc_msgSend(v3, "metadata"), (const __CFData *)objc_msgSend(v3, "classicContent"), &valuePtr))
    {
      uint64_t v61 = [v3 log];
      PCSMigrationLog(v61, @"Merge required: %@", valuePtr);
      CFRelease(valuePtr);
      objc_msgSend(v3, "setEscrowMergeNeeded:", objc_msgSend(v3, "classicContent"));
      if (!fail_and_cfu_if_no_password(0, 1, v3, (const __CFDictionary *)[v3 options], (uint64_t *)a2))goto LABEL_21; {
      objc_msgSend(v3, "setClassicContent:", __PCSCopyHSMData(objc_msgSend(v3, "log"), objc_msgSend(v3, "options"), a2));
      }
      if (![v3 classicContent])
      {
        PCSMigrationLog([v3 log], @"PCSCopyStingrayData failed");
        goto LABEL_21;
      }
    }
    goto LABEL_64;
  }
  if (!v9)
  {
    _PCSErrorContext([v3 log], a2, 121, @"DSID not provided for sign-in");
    goto LABEL_21;
  }
  if (_PCSMigrationStateIsGuitarfish(v3))
  {
    long long v51 = _PCSMigrationRecoverPPasswordFromStashedKey(v3, v9);
    int v52 = v51;
    if (v51) {
      [v3 setClassicContent:v51];
    }
  }
  if (![v3 classicContent])
  {
    if (!fail_and_cfu_if_no_password(0, 1, v3, (const __CFDictionary *)[v3 options], (uint64_t *)a2))goto LABEL_21; {
    PCSMigrationLog([v3 log], @"Attempting to obtain classicContent from HSM");
    }
    objc_msgSend(v3, "setClassicContent:", __PCSCopyHSMData(objc_msgSend(v3, "log"), objc_msgSend(v3, "options"), a2));
  }
  uint64_t v53 = [v3 classicContent];
  uint64_t v54 = [v3 log];
  if (!v53)
  {
    PCSMigrationLog(v54, @"PCSCopyStingrayData failed, NULL classicContent");
    goto LABEL_21;
  }
  if (checkData(v54, (CFDictionaryRef)[v3 metadata], (const __CFData *)objc_msgSend(v3, "classicContent"), a2))
  {
    uint64_t v55 = [v3 classicContent];
    if (__PCSStoreInKeychain(IsGuitarfish, v55, (uint64_t)v9, a2, v56, v57, v58, v59))
    {
LABEL_69:
      if (!__PCSStoreIniCloudKeychain([v3 classicContent], (int)v9, IsGuitarfish, a2)) {
        goto LABEL_21;
      }
LABEL_70:
      uint64_t v14 = 1;
      goto LABEL_5;
    }
  }
LABEL_21:
  uint64_t v23 = [v3 classicContent];
  uint64_t v14 = 0;
  if (a2 && !v23)
  {
    if (!*a2) {
      goto LABEL_4;
    }
    if (CFErrorGetCode((CFErrorRef)*a2) != 33) {
      goto LABEL_4;
    }
    CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)*a2);
    if (!CFEqual(Domain, kPCSSecureBackupErrorDomain)) {
      goto LABEL_4;
    }
    PCSMigrationLog([v3 log], @"Congestion event at read happen restarting state machine");
    id v25 = *a2;
    if (*a2)
    {
      *a2 = 0;
      CFRelease(v25);
    }
    uint64_t v14 = 1;
    [v3 setRestart:1];
  }
LABEL_5:

  return v14;
}

uint64_t PCSEngineExtractKeys(void *a1, const void **a2)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (![v3 metadata])
  {
    uint64_t v61 = *a2;
    if (*a2)
    {
      *a2 = 0;
      CFRelease(v61);
    }
    goto LABEL_118;
  }
  if ([v3 newIdentity])
  {
    CFDictionaryRef v4 = pcsLogObjForScope("migration");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "New identites requested; creating empty set",
        (uint8_t *)&buf,
        2u);
    }

    [v3 clearSet];
    [v3 setSet:PCSIdentitySetCreateMutable(a2)];
    if ([v3 set])
    {
      uint64_t v5 = 1;
      goto LABEL_111;
    }
    _PCSErrorOOM(a2);
LABEL_118:
    uint64_t v5 = 0;
    goto LABEL_111;
  }
  int v80 = 0;
  CFDictionaryRef v6 = pcsLogObjForScope("migration");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = [v3 classicContent];
    CFDictionaryRef v8 = @"present";
    if (!v7) {
      CFDictionaryRef v8 = @"not present";
    }
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_impl(&dword_1ACF98000, v6, OS_LOG_TYPE_DEFAULT, "extracting keys; classicContent is %@",
      (uint8_t *)&buf,
      0xCu);
  }

  if (![v3 classicContent])
  {
    CFTypeRef v62 = *a2;
    if (*a2)
    {
      *a2 = 0;
      CFRelease(v62);
    }
    goto LABEL_122;
  }
  MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)[v3 options]);
  CFDictionaryRef v10 = MutableCopy;
  if (!MutableCopy)
  {
    _PCSErrorOOM(a2);
LABEL_122:
    int v28 = 0;
    BOOL v24 = 0;
    CFTypeRef v29 = 0;
    CFDictionaryRef v10 = 0;
    goto LABEL_130;
  }
  CFDictionarySetValue(MutableCopy, kPCSSetupDontImportManatee[0], (const void *)*MEMORY[0x1E4F1CFD0]);
  if ((_PCSMigrationStateIsGuitarfish(v3) & 1) == 0)
  {
    objc_msgSend(v3, "setSet:", PCSIdentitySetCreateFromExternalForm(v10, (const __CFData *)objc_msgSend(v3, "classicContent"), &v80, a2));
    CFBooleanRef v11 = pcsLogObjForScope("migration");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = [v3 set];
      CFBooleanRef v13 = @"present";
      if (!v12) {
        CFBooleanRef v13 = @"not present";
      }
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v13;
      _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, "parsed classicContent set is %@", (uint8_t *)&buf, 0xCu);
    }

    if (![v3 set]) {
      goto LABEL_128;
    }
    uint64_t v14 = [v3 set];
    objc_msgSend(v3, "setEscrowIdentity:", _PCSIdentitySetCopyCurrentIdentityInternal(v14, kPCSServiceEscrow, 0));
  }
  CFDictionaryRef v15 = GetiCDPMetadata((const __CFDictionary *)[v3 metadata]);
  if (v15)
  {
    CFDictionaryRef v16 = kPCSMetadataEscrowedKeys[0];
    if (_PCSMigrationStateIsGuitarfish(v3)) {
      CFDictionaryRef v16 = @"SecureBackupWrappedKeys";
    }
    CFStringRef Value = (void *)CFDictionaryGetValue(v15, v16);
    CFBooleanRef v18 = Value;
    if (!Value)
    {
      int v34 = pcsLogObjForScope("migration");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v16;
        _os_log_impl(&dword_1ACF98000, v34, OS_LOG_TYPE_DEFAULT, "No serialized keys found (at key path %@)", (uint8_t *)&buf, 0xCu);
      }
      int v28 = 0;
      BOOL v24 = 0;
      goto LABEL_77;
    }
    CFTypeID v19 = CFGetTypeID(Value);
    if (v19 == CFDataGetTypeID())
    {
      if (_PCSMigrationStateIsGuitarfish(v3))
      {
        if ([v3 BOOLOption:kPCSSetupGuitarfishReEnroll[0]])
        {
          *(void *)&long long buf = 0;
          *((void *)&buf + 1) = &buf;
          uint64_t v82 = 0x3032000000;
          uint64_t v83 = __Block_byref_object_copy__1;
          v84 = __Block_byref_object_dispose__1;
          id v85 = 0;
          uint64_t v74 = 0;
          uint64_t v75 = &v74;
          uint64_t v76 = 0x3032000000;
          uint64_t v77 = __Block_byref_object_copy__1;
          CFTypeRef v78 = __Block_byref_object_dispose__1;
          id v79 = 0;
          dispatch_semaphore_t v20 = dispatch_semaphore_create(0);
          v69[0] = MEMORY[0x1E4F143A8];
          v69[1] = 3221225472;
          v69[2] = __PCSEngineExtractKeys_block_invoke;
          v69[3] = &unk_1E5E6E728;
          p_long long buf = &buf;
          id v70 = v3;
          uint64_t v73 = &v74;
          CFTypeID v21 = v20;
          uint64_t v71 = v21;
          _PCSBackupGuitarfishDecodeOuterRecord(v18, v69);
          dispatch_semaphore_wait(v21, 0xFFFFFFFFFFFFFFFFLL);
          if (a2)
          {
            int v22 = (void *)v75[5];
            if (v22) {
              *a2 = v22;
            }
          }
          uint64_t v23 = *(void **)(*((void *)&buf + 1) + 40);
          if (!v23 || v75[5])
          {
            char v27 = 0;
            BOOL v24 = 0;
            id v25 = 0;
            char v26 = 1;
          }
          else
          {
            id v68 = 0;
            BOOL v24 = PCSGuitarfishUnwrapKeysUsingWrappingKey(v23, v18, &v68);
            id v25 = v68;
            char v26 = 0;
            char v27 = 1;
          }

          _Block_object_dispose(&v74, 8);
          _Block_object_dispose(&buf, 8);

          if (v26)
          {

            if ((v27 & 1) == 0)
            {
              int v28 = 0;
              BOOL v24 = 0;
              CFTypeRef v29 = 0;
              uint64_t v5 = 0;
LABEL_104:
              CFRelease(v10);
              goto LABEL_105;
            }
            goto LABEL_49;
          }
        }
        else
        {
          CFDictionaryRef v38 = (const __CFDictionary *)[v3 options];
          uint64_t v39 = (void *)CFDictionaryGetValue(v38, kPCSSetupDSID[0]);
          id v67 = 0;
          BOOL v24 = PCSGuitarfishUnwrapKeys(v39, v18, &v67);
          id v25 = v67;
        }
        if (v25)
        {
          long long v40 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
            PCSEngineExtractKeys_cold_1();
          }

          if (a2) {
            *a2 = v25;
          }
        }
        long long v41 = pcsLogObjForScope("migration");
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          CFDataRef v42 = @"present";
          if (!v24) {
            CFDataRef v42 = @"not present";
          }
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v42;
          _os_log_impl(&dword_1ACF98000, v41, OS_LOG_TYPE_DEFAULT, "unwrappedKeys are %@", (uint8_t *)&buf, 0xCu);
        }

        if (v24)
        {
          int v43 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&dword_1ACF98000, v43, OS_LOG_TYPE_DEFAULT, "unwrapped PCSKeys in ExtractKeys successfully", (uint8_t *)&buf, 2u);
          }

LABEL_66:
          if (_PCSMigrationStateIsGuitarfish(v3))
          {
            objc_msgSend(v3, "setSet:", PCSIdentitySetCreateFromExternalForm(v10, (const __CFData *)v24, 0, a2));
            int v44 = pcsLogObjForScope("migration");
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v45 = [v3 set];
              int v46 = @"present";
              if (!v45) {
                int v46 = @"not present";
              }
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v46;
              _os_log_impl(&dword_1ACF98000, v44, OS_LOG_TYPE_DEFAULT, "parsed identity set is %@", (uint8_t *)&buf, 0xCu);
            }

            if ([v3 set])
            {
              uint64_t v47 = [v3 set];
              objc_msgSend(v3, "setEscrowIdentity:", _PCSIdentitySetCopyCurrentIdentityInternal(v47, kPCSServiceEscrow, 0));
              int v34 = pcsLogObjForScope("migration");
              if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v48 = [v3 escrowIdentity];
                int v49 = @"present";
                if (!v48) {
                  int v49 = @"not present";
                }
                LODWORD(buf) = 138412290;
                *(void *)((char *)&buf + 4) = v49;
                _os_log_impl(&dword_1ACF98000, v34, OS_LOG_TYPE_DEFAULT, "escrow identity is %@", (uint8_t *)&buf, 0xCu);
              }
              int v28 = 0;
LABEL_77:
              CFTypeRef v29 = 0;
              CFDictionaryRef v33 = 0;
LABEL_90:

              if ((_PCSIsiCDPIsWalrus((const __CFDictionary *)[v3 metadata]) & 1) == 0
                && (_PCSIsiCDPIsPlesio((const __CFDictionary *)[v3 metadata]) & 1) == 0
                && ![v3 escrowIdentity])
              {
                _PCSErrorContext([v3 log], a2, 57, @"No escrow identity, even with iCDP data");
                goto LABEL_113;
              }
              goto LABEL_93;
            }
            int v28 = 0;
            goto LABEL_129;
          }
          CFTypeRef v29 = CFRetain((CFTypeRef)[v3 set]);
          [v3 clearSet];
          objc_msgSend(v3, "setSet:", PCSIdentitySetCreateFromExternalForm(v10, (const __CFData *)v24, 0, a2));
          int v50 = pcsLogObjForScope("migration");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v51 = [v3 set];
            int v52 = @"present";
            if (!v51) {
              int v52 = @"not present";
            }
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v52;
            _os_log_impl(&dword_1ACF98000, v50, OS_LOG_TYPE_DEFAULT, "parsed identity set is %@", (uint8_t *)&buf, 0xCu);
          }

          if ([v3 set])
          {
            uint64_t v53 = [v3 set];
            int v28 = _PCSIdentitySetCopyCurrentIdentityInternal(v53, kPCSServiceEscrow, a2);
            if (!v28 || !CFEqual(v28, (CFTypeRef)[v3 escrowIdentity]))
            {
              PCSIdentitySetSetCurrentIdentity([v3 set], objc_msgSend(v3, "escrowIdentity"));
              [v3 setModified:1];
            }
            CFDictionaryRef v33 = (const __CFDictionary *)PCSIdentitySetCopyIdentities((uint64_t)v29, 0);
            uint64_t v54 = context;
            context[0] = MEMORY[0x1E4F143A8];
            context[1] = 3221225472;
            context[2] = __PCSEngineExtractKeys_block_invoke_592;
            context[3] = &unk_1E5E6E778;
            void context[4] = v3;
            CFDictionaryApplyFunction(v33, (CFDictionaryApplierFunction)apply_block_2_3, context);
            goto LABEL_89;
          }
          int v28 = 0;
LABEL_130:
          CFDictionaryRef v33 = 0;
          goto LABEL_113;
        }
      }
      else
      {
        if ([v3 escrowIdentity])
        {
          BOOL v24 = PCSBackupCopyRecoveredKeysetWithIdentity([v3 escrowIdentity], (CFDataRef)v18, a2);
          int v35 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&dword_1ACF98000, v35, OS_LOG_TYPE_DEFAULT, "Not guitarfish state, not unwrapping", (uint8_t *)&buf, 2u);
          }

          if (!v24)
          {
LABEL_49:
            uint64_t v36 = [v3 log];
            if (a2)
            {
              PCSMigrationLog(v36, @"Encrypted metadata keys failure: %@", *a2);
              int v37 = *a2;
              if (*a2)
              {
                *a2 = 0;
                CFRelease(v37);
              }
            }
            else
            {
              PCSMigrationLog(v36, @"Encrypted metadata keys failure: %@", 0);
            }
            uint64_t v55 = [v3 escrowIdentity];
            uint64_t v54 = v66;
            v66[0] = MEMORY[0x1E4F143A8];
            v66[1] = 3221225472;
            v66[2] = __PCSEngineExtractKeys_block_invoke_587;
            v66[3] = &unk_1E5E6E750;
            id v56 = v3;
            v66[4] = v56;
            PCSIdentityCheckValidPublicKey(v55, v66);
            [v56 setBrokenEncryptedMetadatakeys:1];
            [v56 setModified:1];
            int v28 = 0;
            BOOL v24 = 0;
            CFTypeRef v29 = 0;
            CFDictionaryRef v33 = 0;
LABEL_89:
            int v34 = v54[4];
            goto LABEL_90;
          }
          goto LABEL_66;
        }
        _PCSErrorContext([v3 log], a2, 57, @"Have escrowed keys, but no escrow identity");
      }
    }
    else
    {
      _PCSErrorContext([v3 log], a2, 57, @"Escrowed keys not CFData");
    }
LABEL_128:
    int v28 = 0;
    BOOL v24 = 0;
LABEL_129:
    CFTypeRef v29 = 0;
    goto LABEL_130;
  }
  int v30 = pcsLogObjForScope("migration");
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v31 = [v3 escrowIdentity];
    int v32 = @"present";
    if (!v31) {
      int v32 = @"not present";
    }
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v32;
    _os_log_impl(&dword_1ACF98000, v30, OS_LOG_TYPE_DEFAULT, "No 'iCDP' metadata present; (escrow identity is %@)",
      (uint8_t *)&buf,
      0xCu);
  }

  if (![v3 escrowIdentity])
  {
    _PCSErrorContext([v3 log], a2, 57, @"No escrow identity, even with only classic keys");
    goto LABEL_128;
  }
  int v28 = 0;
  BOOL v24 = 0;
  CFTypeRef v29 = 0;
  CFDictionaryRef v33 = 0;
LABEL_93:
  if (v80 & 8) == 0 || ([v3 iCDPHSMWalrus] & 1) != 0 || (objc_msgSend(v3, "iCDPHSMPlesio"))
  {
    if (![v3 escrowMergeNeeded]) {
      goto LABEL_101;
    }
    uint64_t v57 = pcsLogObjForScope("migration");
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_1ACF98000, v57, OS_LOG_TYPE_DEFAULT, "Beginning escrow merge", (uint8_t *)&buf, 2u);
    }

    uint64_t v58 = PCSIdentitySetCreateFromExternalForm(0, (const __CFData *)[v3 escrowMergeNeeded], 0, a2);
    uint64_t v59 = v58;
    if (v58)
    {
      CFDictionaryRef v33 = (const __CFDictionary *)PCSIdentitySetCopyIdentities((uint64_t)v58, 0);
      v63[0] = MEMORY[0x1E4F143A8];
      v63[1] = 3221225472;
      v63[2] = __PCSEngineExtractKeys_block_invoke_603;
      v63[3] = &unk_1E5E6E778;
      id v64 = v3;
      CFDictionaryApplyFunction(v33, (CFDictionaryApplierFunction)apply_block_2_3, v63);
      CFRelease(v59);

LABEL_101:
      uint64_t v5 = 1;
      if (!v33) {
        goto LABEL_103;
      }
      goto LABEL_102;
    }
  }
  else
  {
    _PCSErrorContext([v3 log], a2, 68, @"Keyset was a dropped keyset, metadata was not");
  }
LABEL_113:
  uint64_t v5 = 0;
  if (v33) {
LABEL_102:
  }
    CFRelease(v33);
LABEL_103:
  if (v10) {
    goto LABEL_104;
  }
LABEL_105:
  if (v29) {
    CFRelease(v29);
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v28) {
    CFRelease(v28);
  }
LABEL_111:

  return v5;
}

void sub_1ACFCB5B0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t PCSEngineSynchronizeiCDP(void *a1, const void **a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  CFDictionaryRef v4 = GetiCDPMetadata((const __CFDictionary *)[v3 metadata]);
  if (v4)
  {
    CFDictionaryRef v5 = v4;
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSMetadataiCDP[0]);
    if (Value)
    {
      CFBooleanRef v7 = Value;
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 == CFBooleanGetTypeID()) {
        [v3 setICDPHSM:CFBooleanGetValue(v7) != 0];
      }
    }
    CFBooleanRef v9 = (const __CFBoolean *)CFDictionaryGetValue(v5, kPCSMetadataiCDPArmed[0]);
    if (v9)
    {
      CFBooleanRef v10 = v9;
      CFTypeID v11 = CFGetTypeID(v9);
      if (v11 == CFBooleanGetTypeID()) {
        [v3 setICDPHSMArmed:CFBooleanGetValue(v10) != 0];
      }
    }
  }
  if ([v3 newIdentity])
  {
    uint64_t v12 = 0;
    int IsICDP = 0;
  }
  else
  {
    CFTypeRef v14 = PCSIdentitySetCreate((const __CFDictionary *)[v3 options], 0, a2);
    uint64_t v12 = v14;
    if (v14) {
      int IsICDP = PCSIdentitySetIsICDP((uint64_t)v14, 0);
    }
    else {
      int IsICDP = 0;
    }
    CFDictionaryRef v15 = pcsLogObjForScope("migration");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      CFDictionaryRef v16 = @"OFF";
      if (IsICDP) {
        CFDictionaryRef v16 = @"ON";
      }
      *(_DWORD *)long long buf = 138412290;
      int v22 = v16;
      _os_log_impl(&dword_1ACF98000, v15, OS_LOG_TYPE_DEFAULT, "Not creating new identity; local store iCDP state is %@",
        buf,
        0xCu);
    }
  }
  objc_msgSend(v3, "setICDP:", objc_msgSend(v3, "iCDPHSM"));
  int v17 = [v3 iCDPHSMArmed];
  if (IsICDP)
  {
    if ((v17 & 1) == 0)
    {
      PCSMigrationLog([v3 log], @"iCDP state mismatching, using the most restrictive (local)");
      [v3 setModified:1];
      [v3 setICDP:0];
    }
    [v3 setICDPArmed:1];
  }
  else if (v17)
  {
    PCSMigrationLog([v3 log], @"iCDP state mismatching, using the most restrictive (remote)");
    [v3 setICDPArmed:1];
    [v3 setModified:1];
  }
  uint64_t v18 = [v3 log];
  CFTypeID v19 = _PCSYESNO([v3 iCDPArmed]);
  PCSMigrationLog(v18, @"   iCDP state is (%@)", v19);
  if (v12) {
    CFRelease(v12);
  }

  return 1;
}

uint64_t PCSEngineOverrideiCDP(void *a1, uint64_t *a2)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (![v3 iCDP] || (objc_msgSend(v3, "iCDPArmed") & 1) == 0)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)[v3 options];
    CFDictionaryRef v5 = CFDictionaryGetValue(v4, kPCSSetupDSID[0]);
    CFDictionaryRef v6 = +[PCSAccountsModel altDSIDForDSID:v5];
    uint64_t v7 = [v3 log];
    if (v6)
    {
      PCSMigrationLog(v7, @"No iCDP, now checking Octagon CDP status");
      id v8 = objc_alloc_init(MEMORY[0x1E4F3B438]);
      [v8 setAltDSID:v6];
      BOOL v9 = PCSCurrentPersonaMatchesDSID(v5);
      if (a2) {
        int v10 = v9;
      }
      else {
        int v10 = 1;
      }
      if (v10)
      {
        id v18 = 0;
        uint64_t v11 = [MEMORY[0x1E4F3B430] getCDPStatus:v8 error:&v18];
        id v12 = v18;
        switch(v11)
        {
          case 2:
            PCSMigrationLog([v3 log], @"Octagon CDP is enabled, overriding iCDP value");
            [v3 setICDP:1];
            [v3 setICDPArmed:1];
            [v3 setModified:1];
            break;
          case 1:
            PCSMigrationLog([v3 log], @"Octagon CDP is disabled");
            break;
          case 0:
            PCSMigrationLog([v3 log], @"Unable to check Octagon CDP status: %@", v12);
            break;
        }
      }
      else
      {
        CFBooleanRef v13 = (void *)MEMORY[0x1E4F28C58];
        CFTypeRef v14 = kPCSErrorDomain;
        uint64_t v19 = *MEMORY[0x1E4F28568];
        v20[0] = @"Current persona does not match chosen dsid";
        CFDictionaryRef v15 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v20 forKeys:&v19 count:1];
        *a2 = [v13 errorWithDomain:v14 code:152 userInfo:v15];

        id v12 = 0;
      }

      if (!v10)
      {
        uint64_t v16 = 0;
        goto LABEL_19;
      }
    }
    else
    {
      PCSMigrationLog(v7, @"Unable to determine altDSID, skipping Octagon CDP check");
    }
  }
  uint64_t v16 = 1;
LABEL_19:

  return v16;
}

uint64_t PCSEngineSynchronizeWithLocalstore(void *a1, const void **a2)
{
  id v3 = a1;
  CFArrayRef CFArrayOfNames = (const __CFArray *)PCSServiceItemsGetCFArrayOfNames();
  CFTypeRef v5 = PCSIdentitySetCreate((const __CFDictionary *)[v3 options], 0, a2);
  if (!v5) {
    goto LABEL_13;
  }
  CFDictionaryRef v6 = v5;
  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
  if (!Mutable)
  {
    CFRelease(v6);
LABEL_13:
    uint64_t v15 = 0;
    goto LABEL_14;
  }
  CFMutableSetRef v8 = Mutable;
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = __PCSEngineSynchronizeWithLocalstore_block_invoke;
  context[3] = &unk_1E5E6E7A0;
  id v9 = v3;
  id v25 = v9;
  CFMutableSetRef v26 = v8;
  v27.CFIndex length = CFArrayGetCount(CFArrayOfNames);
  v27.CFIndex location = 0;
  CFArrayApplyFunction(CFArrayOfNames, v27, (CFArrayApplierFunction)apply_block_1_2, context);
  CFDictionaryRef v10 = (const __CFDictionary *)PCSIdentitySetCopyIdentities((uint64_t)v6, 0);
  if (v10)
  {
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    void v20[2] = __PCSEngineSynchronizeWithLocalstore_block_invoke_2;
    v20[3] = &unk_1E5E6E7C8;
    id v21 = v9;
    CFMutableSetRef v22 = v8;
    uint64_t v23 = v6;
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)apply_block_2_3, v20);
  }
  CFDictionaryRef v11 = (const __CFDictionary *)[v9 options];
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v11, kPCSSetupPreferLocalKeyPreference[0]);
  if (Value)
  {
    CFBooleanRef v13 = Value;
    CFTypeID v14 = CFGetTypeID(Value);
    if (v14 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v13))
      {
        v17[0] = MEMORY[0x1E4F143A8];
        v17[1] = 3221225472;
        _DWORD v17[2] = __PCSEngineSynchronizeWithLocalstore_block_invoke_3;
        v17[3] = &unk_1E5E6E7A0;
        uint64_t v19 = v6;
        id v18 = v9;
        v28.CFIndex length = CFArrayGetCount(CFArrayOfNames);
        v28.CFIndex location = 0;
        CFArrayApplyFunction(CFArrayOfNames, v28, (CFArrayApplierFunction)apply_block_1_2, v17);
      }
    }
  }
  CFRelease(v6);
  if (v10) {
    CFRelease(v10);
  }
  CFRelease(v8);

  uint64_t v15 = 1;
LABEL_14:

  return v15;
}

uint64_t PCSEngineSynchronizeLocalKeyFile(void *a1, const void **a2)
{
  CFTypeRef cf = 0;
  id v3 = a1;
  SynchronizeLocalKeyFile(v3, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/LocalBackup", @"backup", &cf);
  SynchronizeLocalKeyFile(v3, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/Backup", @"messages", a2);

  CFTypeRef v4 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v4);
  }
  return 1;
}

uint64_t PCSEngineStepValidateRegistry(void *a1)
{
  id v1 = a1;
  CFArrayRef CFArrayOfNames = (const __CFArray *)PCSServiceItemsGetCFArrayOfNames();
  id v3 = _PCSServiceItemsGetTooRolledServiceTypes();
  if (([v1 iCDPHSMWalrus] & 1) != 0 || objc_msgSend(v1, "iCDPHSMPlesio"))
  {
    PCSMigrationLog([v1 log], @"  Skipping registry validation");
  }
  else
  {
    if ([v1 oldRegistry])
    {
      CFDictionaryRef v4 = (const __CFDictionary *)[v1 options];
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSSetupRegistryCleanup[0]);
      v8 = Value && (v6 = Value, CFTypeID v7 = CFGetTypeID(Value), v7 == CFBooleanGetTypeID()) && CFBooleanGetValue(v6) != 0;
      CFDictionaryRef v9 = (const __CFDictionary *)[v1 oldRegistry];
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 3221225472;
      context[2] = __PCSEngineStepValidateRegistry_block_invoke;
      context[3] = &unk_1E5E6E818;
      id v15 = v3;
      id v16 = v1;
      BOOL v17 = v8;
      CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)apply_block_2_3, context);
    }
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __PCSEngineStepValidateRegistry_block_invoke_2;
    _OWORD v11[3] = &unk_1E5E6E840;
    id v12 = v3;
    id v13 = v1;
    v18.CFIndex length = CFArrayGetCount(CFArrayOfNames);
    v18.CFIndex location = 0;
    CFArrayApplyFunction(CFArrayOfNames, v18, (CFArrayApplierFunction)apply_block_1_2, v11);
  }
  return 1;
}

BOOL PCSEngineAddMissingFromRegistry(void *a1, const void **a2)
{
  id v3 = a1;
  CFDictionaryRef v4 = _PCSServiceItemsGetTooRolledServiceTypes();
  unsigned __int8 v31 = 0;
  if ([v3 missingFromRegistry])
  {
    uint64_t v5 = [v3 set];
    CFBooleanRef v6 = _PCSIdentitySetCopyCurrentIdentityInternal(v5, kPCSServiceMaster, 0);
    if (v6
      || (CFArrayRef v8 = (const __CFArray *)[v3 missingFromRegistry],
          v32.CFIndex length = CFArrayGetCount((CFArrayRef)[v3 missingFromRegistry]),
          v32.CFIndex location = 0,
          !CFArrayContainsValue(v8, v32, kPCSServiceMaster)))
    {
      CFTypeRef cf = v6;
      PCSMigrationLog([v3 log], @"   master identity NOT missing from registry, refusing to add one");
    }
    else
    {
      CFTypeRef Master = PCSIdentityCreateMaster(0, a2);
      if (!Master)
      {
        BOOL v7 = 0;
        goto LABEL_37;
      }
      CFDictionaryRef v10 = Master;
      PCSMigrationLog([v3 log], @"   master identity missing from registry, adding one");
      if (!PCSIdentitySetAddIdentity([v3 set], (uint64_t)v10)
        || !PCSIdentitySetSetCurrentIdentity([v3 set], (uint64_t)v10))
      {
        BOOL v7 = 0;
LABEL_36:
        CFRelease(v10);
        goto LABEL_37;
      }
      CFTypeRef cf = v10;
      [v3 setModified:1];
    }
    CFArrayRef v11 = (const __CFArray *)[v3 missingFromRegistry];
    id v12 = (const void *)kPCSServiceMaster;
    v33.CFIndex length = CFArrayGetCount(v11);
    v33.CFIndex location = 0;
    FirstIndexOfCFBooleanRef Value = CFArrayGetFirstIndexOfValue(v11, v33, v12);
    if (FirstIndexOfValue != -1)
    {
      for (CFIndex i = FirstIndexOfValue; i != -1; CFIndex i = CFArrayGetFirstIndexOfValue(v11, v34, v12))
      {
        CFArrayRemoveValueAtIndex(v11, i);
        v34.CFIndex length = CFArrayGetCount(v11);
        v34.CFIndex location = 0;
      }
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)[v3 missingFromRegistry]);
    if (Count >= 1)
    {
      CFIndex v16 = Count;
      CFRange v28 = a2;
      BOOL v7 = 0;
      CFIndex v17 = 0;
      while (1)
      {
        CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex((CFArrayRef)[v3 missingFromRegistry], v17);
        CFStringRef v19 = @"   not creating Manatee service: %@";
        if ((PCSServiceItemTypeIsManatee(ValueAtIndex) & 1) != 0
          || (CFStringRef v19 = @"   not creating tooRolled service: %@",
              ([v4 containsObject:ValueAtIndex] & 1) != 0))
        {
          PCSMigrationLog([v3 log], v19, ValueAtIndex);
        }
        else if (![v3 limitLocalStoring] {
               || (CFArrayRef v20 = (const __CFArray *)[v3 limitLocalStoring],
        }
                   v35.CFIndex length = CFArrayGetCount((CFArrayRef)[v3 limitLocalStoring]),
                   v35.CFIndex location = 0,
                   CFArrayContainsValue(v20, v35, ValueAtIndex)))
        {
          if (CFEqual(ValueAtIndex, kPCSServiceEscrow))
          {
            if ([v3 newIdentity])
            {
              id v21 = pcsLogObjForScope("migration");
              if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl(&dword_1ACF98000, v21, OS_LOG_TYPE_DEFAULT, "Creating new Escrow identity", buf, 2u);
              }

              if (!AddService(v3, (uint64_t)cf, kPCSServiceEscrow, v28)) {
                goto LABEL_35;
              }
              uint64_t v22 = [v3 set];
              objc_msgSend(v3, "setEscrowIdentity:", _PCSIdentitySetCopyCurrentIdentityInternal(v22, kPCSServiceEscrow, v28));
              if (![v3 escrowIdentity]) {
                goto LABEL_35;
              }
            }
          }
          else
          {
            uint64_t v23 = _PCSIdentitySetCopyCurrentIdentityInternal([v3 set], (uint64_t)ValueAtIndex, 0);
            if (!v23
              || (BOOL v24 = v23, v25 = _PCSIdentityValidate((uint64_t)v23, &v31, 0), v26 = v31, CFRelease(v24), !v25)
              || v26)
            {
              if ((AddService(v3, (uint64_t)cf, ValueAtIndex, v28) & 1) == 0) {
                goto LABEL_35;
              }
            }
          }
        }
        BOOL v7 = ++v17 >= v16;
        if (v16 == v17) {
          goto LABEL_35;
        }
      }
    }
    BOOL v7 = 1;
LABEL_35:
    CFDictionaryRef v10 = cf;
    if (cf) {
      goto LABEL_36;
    }
  }
  else
  {
    BOOL v7 = 1;
  }
LABEL_37:

  return v7;
}

uint64_t PCSEngineStepValidateLooseLeaves(void *a1, const void **a2)
{
  id v3 = a1;
  CFDictionaryRef v4 = _PCSServiceItemsGetTooRolledServiceTypes();
  if (![v3 stableMetadata])
  {
    objc_msgSend(v3, "setStableMetadata:", CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]));
    if (![v3 stableMetadata]) {
      goto LABEL_43;
    }
  }
  CFDictionaryRef v5 = (const __CFDictionary *)[v3 stableMetadata];
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v5, kPCSSecureBackupCFStableLooseLeaves[0]);
  if (([v3 iCDPHSMWalrus] & 1) != 0 || objc_msgSend(v3, "iCDPHSMPlesio"))
  {
    uint64_t v7 = [v3 log];
    if (Value)
    {
      PCSMigrationLog(v7, @"  Removing loose leaves");
      CFArrayRef v8 = (__CFDictionary *)[v3 stableMetadata];
      CFDictionaryRemoveValue(v8, kPCSSecureBackupCFStableLooseLeaves[0]);
      [v3 setModified:1];
    }
    else
    {
      PCSMigrationLog(v7, @"  Skipping validation of loose leaves");
    }
    CFDictionaryRef v9 = (const __CFDictionary *)[v3 metadata];
    if (CFDictionaryGetValue(v9, kPCSSecureBackupCFiCloudIdentityPublicDataKey[0])) {
      [v3 setModified:1];
    }
    goto LABEL_40;
  }
  if (![v3 escrowIdentity]) {
    goto LABEL_40;
  }
  if (Value && (CFTypeID v10 = CFGetTypeID(Value), v10 == CFDictionaryGetTypeID())) {
    MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0, 0, Value);
  }
  else {
    MutableCFArrayRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  }
  CFMutableDictionaryRef v12 = MutableCopy;
  if (!MutableCopy)
  {
LABEL_43:
    _PCSErrorOOM(a2);
    goto LABEL_40;
  }
  CFTypeRef v29 = a2;
  CFArrayRef CFArrayOfNames = (const __CFArray *)PCSServiceItemsGetCFArrayOfNames();
  CFTypeRef cf = PCSIdentitySetCreateMutable(0);
  CFIndex Count = CFArrayGetCount(CFArrayOfNames);
  if (Count < 1)
  {
LABEL_33:
    CFRange v27 = (__CFDictionary *)[v3 stableMetadata];
    CFDictionarySetValue(v27, kPCSSecureBackupCFStableLooseLeaves[0], v12);
    CFArrayRef v19 = 0;
    CFDictionaryRef Mutable = 0;
    goto LABEL_34;
  }
  CFIndex v15 = Count;
  CFIndex v16 = 0;
  unsigned __int8 v31 = v4;
  while (1)
  {
    CFDictionaryRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(CFArrayOfNames, v16);
    if (!PCSServiceItemTypeIsManatee(ValueAtIndex)) {
      break;
    }
LABEL_21:
    CFDictionaryRemoveValue(v12, ValueAtIndex);
LABEL_22:
    if (v15 == ++v16) {
      goto LABEL_33;
    }
  }
  if ([v4 containsObject:ValueAtIndex])
  {
    PCSMigrationLog([v3 log], @"Skipping too rolled identity for loose leaves: %@", ValueAtIndex);
    goto LABEL_21;
  }
  uint64_t v18 = PCSIdentitySetCopyOrderedIdentities([v3 set], (uint64_t)ValueAtIndex);
  if (!v18) {
    goto LABEL_22;
  }
  CFArrayRef v19 = (const __CFArray *)v18;
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (!Mutable)
  {
    _PCSErrorOOM(v29);
    goto LABEL_34;
  }
  CFArrayRef v21 = (const __CFArray *)CFDictionaryGetValue(v12, ValueAtIndex);
  if (v21)
  {
    CFArrayRef v22 = v21;
    CFTypeID v23 = CFGetTypeID(v21);
    if (v23 == CFArrayGetTypeID())
    {
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 3221225472;
      context[2] = __PCSEngineStepValidateLooseLeaves_block_invoke;
      context[3] = &unk_1E5E6E868;
      id v40 = v3;
      CFTypeRef v41 = cf;
      CFDataRef v42 = ValueAtIndex;
      CFDictionaryRef v43 = Mutable;
      v44.CFIndex length = CFArrayGetCount(v22);
      v44.CFIndex location = 0;
      CFArrayApplyFunction(v22, v44, (CFArrayApplierFunction)apply_block_1_2, context);
    }
  }
  CFMutableArrayRef v24 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  if (v24)
  {
    CFMutableArrayRef v25 = v24;
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 3221225472;
    v35[2] = __PCSEngineStepValidateLooseLeaves_block_invoke_2;
    v35[3] = &unk_1E5E6E890;
    CFDictionaryRef v37 = Mutable;
    CFMutableArrayRef v38 = v24;
    id v26 = v3;
    id v36 = v26;
    v45.CFIndex length = CFArrayGetCount(v19);
    v45.CFIndex location = 0;
    CFArrayApplyFunction(v19, v45, (CFArrayApplierFunction)apply_block_1_2, v35);
    if (CFArrayGetCount(v25))
    {
      v32[0] = MEMORY[0x1E4F143A8];
      v32[1] = 3221225472;
      v32[2] = __PCSEngineStepValidateLooseLeaves_block_invoke_3;
      void v32[3] = &unk_1E5E6E8B8;
      CFMutableArrayRef v34 = v25;
      id v33 = v26;
      CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)apply_block_2_3, v32);
      CFDictionarySetValue(v12, ValueAtIndex, v25);
    }
    CFRelease(Mutable);
    CFRelease(v19);
    CFRelease(v25);

    CFDictionaryRef v4 = v31;
    goto LABEL_22;
  }
  _PCSErrorOOM(v29);
  CFDictionaryRef v4 = v31;
LABEL_34:
  if (cf) {
    CFRelease(cf);
  }
  CFRelease(v12);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v19) {
    CFRelease(v19);
  }
LABEL_40:

  return 1;
}

uint64_t PCSEngineStoreHSM(void *a1, const void **a2)
{
  id v3 = a1;
  uint64_t v202 = 0;
  v203 = &v202;
  uint64_t v204 = 0x2020000000;
  char v205 = 0;
  dispatch_semaphore_t v157 = dispatch_semaphore_create(0);
  if [v3 newIdentity] && (objc_msgSend(v3, "dropHSM")) {
    goto LABEL_182;
  }
  if ([v3 newIdentity])
  {
    CFDictionaryRef v4 = pcsLogObjForScope("migration");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "Creating new identity", buf, 2u);
    }

    if (GetClassicServiceArray_onceToken != -1) {
      dispatch_once(&GetClassicServiceArray_onceToken, &__block_literal_global_10);
    }
    objc_msgSend(v3, "setNewHSMContent:", PCSIdentitySetCreateExternalForm(objc_msgSend(v3, "log"), objc_msgSend(v3, "set"), 1, (const __CFArray *)GetClassicServiceArray_array, a2));
    if (![v3 newHSMContent]) {
      goto LABEL_182;
    }
    [v3 setModified:1];
  }
  if ([v3 restoreHSM])
  {
    if ([v3 iCDPHSMWalrus] & 1) != 0 || (objc_msgSend(v3, "iCDPHSMPlesio"))
    {
      _PCSError(a2, 69, @"Asked to restore HSM content, but flag in HSM doesn't match");
      goto LABEL_182;
    }
    if (_PCSMigrationStateIsGuitarfish(v3))
    {
      uint64_t v5 = [v3 set];
      objc_msgSend(v3, "setEscrowIdentity:", _PCSIdentitySetCopyCurrentIdentityInternal(v5, kPCSServiceEscrow, a2));
      uint64_t v6 = [v3 escrowIdentity];
    }
    else
    {
      objc_msgSend(v3, "setNewHSMContent:", PCSStateCopyKeychainClassicIdentities(v3, 1, a2));
      uint64_t v6 = [v3 newHSMContent];
    }
    if (!v6) {
      goto LABEL_182;
    }
    [v3 setModified:1];
  }
  if ([v3 dropHSM])
  {
    if (([v3 iCDPHSMWalrus] & 1) == 0 && (objc_msgSend(v3, "iCDPHSMPlesio") & 1) == 0)
    {
      _PCSError(a2, 69, @"Asked to drop HSM content, but flag in HSM already set");
      goto LABEL_182;
    }
    if (_PCSMigrationStateIsGuitarfish(v3))
    {
      [v3 setNewHSMContent:0];
    }
    else
    {
      if (GetDroppedServiceArray_onceToken != -1) {
        dispatch_once(&GetDroppedServiceArray_onceToken, &__block_literal_global_798);
      }
      objc_msgSend(v3, "setNewHSMContent:", PCSIdentitySetCreateExternalForm(objc_msgSend(v3, "log"), objc_msgSend(v3, "set"), 1, (const __CFArray *)GetDroppedServiceArray_array, a2));
      if (![v3 newHSMContent]) {
        goto LABEL_182;
      }
    }
    [v3 setModified:1];
  }
  if ([v3 escrowMissing])
  {
    objc_msgSend(v3, "setNewHSMContent:", CFRetain((CFTypeRef)objc_msgSend(v3, "classicContent")));
    [v3 setModified:1];
  }
  if ([v3 escrowMergeNeeded])
  {
    [v3 setNewHSMContent:0];
    [v3 setModified:1];
  }
  if (_PCSMigrationStateIsGuitarfish(v3))
  {
    uint64_t v7 = (void *)[v3 options];
    CFArrayRef v8 = [v7 objectForKeyedSubscript:kPCSSetupForceEnroll[0]];

    if (v8) {
      [v3 setModified:1];
    }
  }
  if (_PCSMigrationStateIsGuitarfish(v3))
  {
    if (![v3 escrowIdentity])
    {
      uint64_t v9 = [v3 set];
      objc_msgSend(v3, "setEscrowIdentity:", _PCSIdentitySetCopyCurrentIdentityInternal(v9, kPCSServiceEscrow, a2));
      if (![v3 escrowIdentity]) {
        goto LABEL_182;
      }
    }
    CFTypeID v10 = (const void *)[v3 escrowIdentity];
    CFArrayRef v11 = v10;
    if (v10) {
      CFRetain(v10);
    }
    v159 = 0;
    goto LABEL_52;
  }
  if ([v3 newHSMContent] && (objc_msgSend(v3, "dropHSM") & 1) == 0)
  {
    CFMutableDictionaryRef v12 = (const void *)[v3 newHSMContent];
    goto LABEL_45;
  }
  if ([v3 escrowMergeNeeded])
  {
    CFMutableDictionaryRef v12 = (const void *)[v3 classicContent];
LABEL_45:
    CFDataRef v13 = (const __CFData *)CFRetain(v12);
    goto LABEL_47;
  }
  CFDataRef v13 = (const __CFData *)PCSStateCopyKeychainClassicIdentities(v3, 0, a2);
  if (v13)
  {
LABEL_47:
    v159 = PCSIdentitySetCreateFromExternalForm(0, v13, 0, a2);
    if (v13) {
      CFRelease(v13);
    }
    if (!v159) {
      goto LABEL_182;
    }
    CFTypeID v14 = _PCSIdentitySetCopyCurrentIdentityInternal((uint64_t)v159, kPCSServiceEscrow, a2);
    CFArrayRef v11 = v14;
    if (!v14)
    {
      _PCSError(a2, 70, @"Escrow identity not in escrowed set");
LABEL_181:
      CFRelease(v159);
      goto LABEL_182;
    }
    if (!PCSIdentityCheckWrappable((uint64_t)v14, a2))
    {
      MutableForCFTypesWith = 0;
      CFMutableDictionaryRef theDict = 0;
      uint64_t v63 = 0;
      value = 0;
      uint64_t v154 = 0;
      CFDataRef ExternalForm = 0;
      CFTypeRef cf = 0;
      goto LABEL_165;
    }
LABEL_52:
    if (![v3 modified])
    {
      uint64_t v154 = 0;
      CFDataRef ExternalForm = 0;
      CFTypeRef cf = 0;
      value = 0;
      CFMutableDictionaryRef theDict = 0;
      MutableForCFTypesWith = 0;
      goto LABEL_107;
    }
    uint64_t v16 = [v3 set];
    CFIndex v17 = _PCSIdentitySetCopyCurrentIdentityInternal(v16, kPCSServiceBladerunner, 0);
    CFTypeRef cf = v17;
    if (v17) {
      uint64_t v154 = (void *)PCSIdentityCopyPublicKeyInfo((uint64_t)v17);
    }
    else {
      uint64_t v154 = 0;
    }
    key = kPCSMetadataiCDP[0];
    int v20 = [v3 iCDP];
    int v21 = [v3 iCDPArmed];
    CFTypeRef v29 = (const void *)*MEMORY[0x1E4F1CFD0];
    if (v20) {
      uint64_t v30 = *MEMORY[0x1E4F1CFD0];
    }
    else {
      uint64_t v30 = *MEMORY[0x1E4F1CFC8];
    }
    CFMutableDictionaryRef theDict = CFDictionaryCreateMutableForCFTypesWith(v21, v22, v23, v24, v25, v26, v27, v28, key, v30);
    if (!theDict)
    {
      _PCSErrorOOM(a2);
      CFDataRef ExternalForm = 0;
      value = 0;
      uint64_t v63 = 0;
      CFMutableDictionaryRef theDict = 0;
      goto LABEL_244;
    }
    if ([v3 iCDPHSMWalrus])
    {
      CFDictionarySetValue(theDict, kPCSMetadataiCDPWalrus[0], v29);
      if (_PCSMigrationStateIsGuitarfish(v3))
      {
LABEL_67:
        if (!v11)
        {
          _PCSError(a2, 70, @"Escrow identity not in escrowed set (in modified path)");
          uint64_t v63 = 0;
          BOOL v112 = 0;
          CFDataRef v110 = 0;
          char v109 = v154;
          CFMutableDictionaryRef v111 = theDict;
          goto LABEL_169;
        }
        if ([v3 escrowIdentity] && !CFEqual((CFTypeRef)objc_msgSend(v3, "escrowIdentity"), v11))
        {
          _PCSError(a2, 71, @"Escrow identity not same");
        }
        else
        {
          if ([v3 iCDPHSMWalrus])
          {
            if ((_PCSMigrationStateIsGuitarfish(v3) & 1) == 0)
            {
              _os_assert_log();
              uint64_t v151 = _os_crash();
              PCSEngineStoreHSM_cold_1(v151);
            }
            if (GetDroppedServiceArray_onceToken != -1) {
              dispatch_once(&GetDroppedServiceArray_onceToken, &__block_literal_global_798);
            }
            CFArrayRef v31 = (const __CFArray *)GetDroppedServiceArray_array;
          }
          else
          {
            CFArrayRef v31 = 0;
          }
          CFDataRef ExternalForm = (const __CFData *)PCSIdentitySetCreateExternalForm([v3 log], objc_msgSend(v3, "set"), 1, v31, a2);
          if (ExternalForm)
          {
            if (!_PCSMigrationStateIsGuitarfish(v3))
            {
              value = PCSBackupCreateEscrowedKeysetWithIdentity((uint64_t)v11, ExternalForm, 0, a2);
              if (!value)
              {
LABEL_237:
                MutableForCFTypesWith = 0;
                uint64_t v63 = 0;
                value = 0;
                goto LABEL_165;
              }
              goto LABEL_82;
            }
            char v32 = [v3 BOOLOption:kPCSSetupGuitarfishReEnroll[0]];
            if ((v32 & 1) == 0)
            {
              CFDataRef v114 = (void *)[v3 metadata];
              CFTypeRef v115 = [v114 objectForKeyedSubscript:*MEMORY[0x1E4F59B88]];
              unint64_t v116 = [v115 objectForKeyedSubscript:kPCSSecureBackupCFClientMetadataKey[0]];
              uint64_t v117 = [v116 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
              CFMutableArrayRef v34 = [v117 objectForKeyedSubscript:@"SecureBackupWrappedKeys"];

              if (v34) {
                goto LABEL_185;
              }
              int v147 = (void *)[v3 options];
              unint64_t v148 = [v147 objectForKeyedSubscript:kPCSSetupOuterGuitarfishEncodedTemplate[0]];

              if (!v148)
              {
LABEL_234:
                uint64_t v150 = pcsLogObjForScope("Guitarfish");
                if (os_log_type_enabled(v150, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl(&dword_1ACF98000, v150, OS_LOG_TYPE_DEFAULT, "No existing data, create one from the options stub", buf, 2u);
                }

                _PCSError(a2, 204, @"no template to create record from, must create record first through PCSGuitarfishSetupIdentities");
                goto LABEL_237;
              }
              unint64_t v149 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl(&dword_1ACF98000, v149, OS_LOG_TYPE_DEFAULT, "previous metadata blob does not exist, so creating a new one from the template", buf, 2u);
              }
            }
            id v33 = (void *)[v3 options];
            CFMutableArrayRef v34 = [v33 objectForKeyedSubscript:kPCSSetupOuterGuitarfishEncodedTemplate[0]];
            if (!v34) {
              goto LABEL_234;
            }
LABEL_185:
            *(void *)long long buf = 0;
            uint64_t v207 = (uint64_t)buf;
            uint64_t v208 = 0x3032000000;
            v209 = __Block_byref_object_copy__1;
            v210 = __Block_byref_object_dispose__1;
            id v211 = 0;
            CFDictionaryRef v118 = (const __CFDictionary *)[v3 options];
            uint64_t v119 = (void *)CFDictionaryGetValue(v118, kPCSSetupDSID[0]);
            uint64_t context = 0;
            p_uint64_t context = (uint64_t)&context;
            uint64_t v215 = 0x3032000000;
            v216 = __Block_byref_object_copy__1;
            v217 = __Block_byref_object_dispose__1;
            CFMutableDictionaryRef v218 = 0;
            dispatch_semaphore_t v120 = dispatch_semaphore_create(0);
            v199[0] = MEMORY[0x1E4F143A8];
            v199[1] = 3221225472;
            v199[2] = __PCSEngineStoreHSM_block_invoke;
            v199[3] = &unk_1E5E6E6D8;
            v201 = &context;
            CFIndex v121 = v120;
            v200 = v121;
            _PCSGuitarfishGetKeychainItem(@"WrappingKey", v119, v199);
            dispatch_semaphore_wait(v121, 0xFFFFFFFFFFFFFFFFLL);
            if ([v3 newHSMContent])
            {
              uint64_t v122 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v193 = 0;
                _os_log_impl(&dword_1ACF98000, v122, OS_LOG_TYPE_DEFAULT, "unsetting previous state.newHSMContent", v193, 2u);
              }

              CFRelease((CFTypeRef)[v3 newHSMContent]);
              [v3 setNewHSMContent:0];
            }
            *(void *)v193 = 0;
            v194 = v193;
            uint64_t v195 = 0x3032000000;
            v196 = __Block_byref_object_copy__1;
            v197 = __Block_byref_object_dispose__1;
            id v198 = 0;
            if (!*(void *)(p_context + 40))
            {
              _PCSError(a2, 215, @"unable to get wrappingKey from Keychain");
              value = 0;
              int v141 = 4;
LABEL_222:
              _Block_object_dispose(v193, 8);

              _Block_object_dispose(&context, 8);
              _Block_object_dispose(buf, 8);

              if (v141)
              {
                MutableForCFTypesWith = 0;
                uint64_t v63 = 0;
LABEL_165:
                CFRelease(v11);
LABEL_166:
                if (MutableForCFTypesWith) {
                  CFRelease(MutableForCFTypesWith);
                }
                char v109 = v154;
                CFDataRef v110 = ExternalForm;
                CFMutableDictionaryRef v111 = theDict;
                BOOL v112 = value;
                if (!theDict)
                {
LABEL_170:
                  if (v63) {
                    CFRelease(v63);
                  }
                  if (v112) {
                    CFRelease(v112);
                  }
                  if (cf) {
                    CFRelease(cf);
                  }
                  if (v109) {
                    CFRelease(v109);
                  }
                  if (v110) {
                    CFRelease(v110);
                  }
                  if (!v159) {
                    goto LABEL_182;
                  }
                  goto LABEL_181;
                }
LABEL_169:
                CFRelease(v111);
                goto LABEL_170;
              }
LABEL_82:
              CFRange v35 = kPCSMetadataEscrowedKeys[0];
              if (_PCSMigrationStateIsGuitarfish(v3)) {
                id v36 = @"SecureBackupWrappedKeys";
              }
              else {
                id v36 = v35;
              }
              CFDictionarySetValue(theDict, v36, value);
              goto LABEL_86;
            }
            uint64_t v187 = 0;
            long long v188 = &v187;
            uint64_t v189 = 0x3032000000;
            long long v190 = __Block_byref_object_copy__1;
            v191 = __Block_byref_object_dispose__1;
            id v192 = 0;
            uint64_t v181 = 0;
            long long v182 = &v181;
            uint64_t v183 = 0x3032000000;
            long long v184 = __Block_byref_object_copy__1;
            long long v185 = __Block_byref_object_dispose__1;
            id v186 = 0;
            CFDataRef v123 = *(void **)(p_context + 40);
            v180[0] = MEMORY[0x1E4F143A8];
            v180[1] = 3221225472;
            v180[2] = __PCSEngineStoreHSM_block_invoke_739;
            v180[3] = &unk_1E5E6E8E0;
            v180[4] = &v187;
            v180[5] = v193;
            v180[6] = &v181;
            v180[7] = a2;
            _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(v123, v34, v180);
            if (!v188[5]) {
              goto LABEL_260;
            }
            int v124 = [v3 iCDPHSMWalrus];
            uint64_t v125 = *((void *)v194 + 5);
            if (v124)
            {
              if (v125)
              {
                _PCSError(a2, 239, @"outer ASN contains p_recovery");
                goto LABEL_260;
              }
              if (v182[5])
              {
                _PCSError(a2, 239, @"outer ASN contains mnemonic");
LABEL_260:
                value = 0;
                int v141 = 4;
                goto LABEL_221;
              }
            }
            else if (!v125 || !v182[5])
            {
              goto LABEL_260;
            }
            if (([v3 iCDPHSMWalrus] & 1) == 0)
            {
              uint64_t v126 = v182[5];
              v179[0] = MEMORY[0x1E4F143A8];
              v179[1] = 3221225472;
              v179[2] = __PCSEngineStoreHSM_block_invoke_746;
              v179[3] = &unk_1E5E6E908;
              v179[4] = buf;
              v179[5] = a2;
              PCSGuitarfishDeriveRecoveryKeyFromMnemonic(v126, v179);
              CFDataRef v127 = *(const void **)(v207 + 40);
              if (!v127) {
                goto LABEL_260;
              }
              CFDictionarySetValue(theDict, @"DerivedDBRSeedAESPID", v127);
            }
            if ((v32 & 1) != 0
              || [v3 classicContent]
              && (long long v128 = (void *)[v3 classicContent],
                  ([v128 isEqualToData:v188[5]] & 1) == 0))
            {
              uint64_t v129 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long v178 = 0;
                _os_log_impl(&dword_1ACF98000, v129, OS_LOG_TYPE_DEFAULT, "Setting new HSM content since it does not exist or is incorrect", v178, 2u);
              }

              [v3 setNewHSMContent:(id)v188[5]];
            }
            if (([v3 iCDPHSMWalrus] & 1) == 0)
            {
              objc_msgSend((id)objc_msgSend(v3, "options"), "setObject:forKeyedSubscript:", *((void *)v194 + 5), @"kPRecoveryUseAfterStoreHSMForRTStoreHSM");
              objc_msgSend((id)objc_msgSend(v3, "options"), "setObject:forKeyedSubscript:", v182[5], @"kMnemonicUseAfterStoreHSMForRTStoreHSM");
            }
            id v130 = (void *)v182[5];
            long long v131 = (void *)v188[5];
            CFDataRef v132 = (void *)*((void *)v194 + 5);
            v177[1] = 0;
            CFDataRef v133 = _PCSBackupGuitarfishEncodeInnerRecord(ExternalForm, v130, v131, v132);
            id v134 = 0;
            uint64_t v135 = v134;
            if (a2 && v134) {
              *a2 = v134;
            }
            uint64_t v136 = v121;
            if (!v133)
            {
              value = 0;
              int v141 = 4;
              goto LABEL_220;
            }
            int v137 = *(void **)(p_context + 40);
            v177[0] = 0;
            long long v138 = _PCSBackupGuitarfishEncodeOuterRecord(v137, (__CFData *)[v3 escrowIdentity], 0, 0, v133, v34, (uint64_t)v177);
            id v139 = v177[0];
            long long v140 = v139;
            if (a2 && v139)
            {
              value = 0;
              *a2 = v139;
            }
            else
            {
              if (!v139)
              {
                value = v138;
                int v141 = 0;
                goto LABEL_219;
              }
              value = 0;
            }
            int v141 = 4;
LABEL_219:

LABEL_220:
            CFIndex v121 = v136;
LABEL_221:
            _Block_object_dispose(&v181, 8);

            _Block_object_dispose(&v187, 8);
            goto LABEL_222;
          }
        }
        MutableForCFTypesWith = 0;
        uint64_t v63 = 0;
        value = 0;
        CFDataRef ExternalForm = 0;
        goto LABEL_165;
      }
    }
    else
    {
      if (![v3 iCDPHSMPlesio]) {
        goto LABEL_67;
      }
      CFDictionarySetValue(theDict, kPCSMetadataiCDPDrop[0], v29);
    }
    CFDataRef ExternalForm = 0;
    value = 0;
LABEL_86:
    if ([v3 stableMetadata]
      || (objc_msgSend(v3, "setStableMetadata:", CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540])), objc_msgSend(v3, "stableMetadata")))
    {
      if (v11)
      {
        CFDictionaryRef v37 = (__CFDictionary *)[v3 stableMetadata];
        CFMutableArrayRef v38 = kPCSSecureBackupCFStableEscrowKey[0];
        int PublicKey = (const void *)PCSIdentityGetPublicKey((uint64_t)v11);
        CFDictionarySetValue(v37, v38, PublicKey);
      }
      else
      {
        uint64_t v48 = (__CFDictionary *)[v3 stableMetadata];
        CFDictionaryRemoveValue(v48, kPCSSecureBackupCFStableEscrowKey[0]);
      }
      MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(v40, v41, v42, v43, v44, v45, v46, v47, kPCSSecureBackupCFiCloudDataProtectionKey[0], (uint64_t)theDict);
      if (MutableForCFTypesWith)
      {
        if ([v3 stableMetadata]
          && CFDictionaryGetCount((CFDictionaryRef)[v3 stableMetadata]) >= 1)
        {
          CFDictionarySetValue(MutableForCFTypesWith, kPCSSecureBackupCFStableMetadataKey[0], (const void *)[v3 stableMetadata]);
        }
        if (([v3 iCDPHSMWalrus] & 1) == 0)
        {
          char v49 = [v3 iCDPHSMPlesio];
          char v50 = v154 ? v49 : 1;
          if ((v50 & 1) == 0) {
            CFDictionarySetValue(MutableForCFTypesWith, kPCSSecureBackupCFiCloudIdentityPublicDataKey[0], v154);
          }
        }
        id v51 = v3;
        CFArrayRef CFArrayOfNames = (const __CFArray *)PCSServiceItemsGetCFArrayOfNames();
        uint64_t v53 = _PCSServiceItemsGetTooRolledServiceTypes();
        if (([v51 iCDPHSMWalrus] & 1) != 0 || objc_msgSend(v51, "iCDPHSMPlesio"))
        {
          PCSMigrationLog([v51 log], @"  Skipping registry creation");
        }
        else
        {
          if ([v51 oldRegistry]) {
            MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)[v51 oldRegistry]);
          }
          else {
            MutableCFArrayRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
          }
          CFMutableDictionaryRef v142 = MutableCopy;
          if (MutableCopy)
          {
            if ([v51 removeFromRegistry])
            {
              CFArrayRef v143 = (const __CFArray *)[v51 removeFromRegistry];
              uint64_t context = MEMORY[0x1E4F143A8];
              p_uint64_t context = 3221225472;
              uint64_t v215 = (uint64_t)__CreateKeyRegistry_block_invoke;
              v216 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E5E6E7A0;
              v217 = (void (*)(uint64_t))v51;
              CFMutableDictionaryRef v218 = v142;
              v219.CFIndex length = CFArrayGetCount(v143);
              v219.CFIndex location = 0;
              CFArrayApplyFunction(v143, v219, (CFArrayApplierFunction)apply_block_1_2, &context);
            }
            *(void *)long long buf = MEMORY[0x1E4F143A8];
            uint64_t v207 = 3221225472;
            uint64_t v208 = (uint64_t)__CreateKeyRegistry_block_invoke_2;
            v209 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E5E6E9A8;
            CFMutableDictionaryRef v212 = v142;
            uint64_t v144 = v53;
            v210 = v144;
            id v145 = v51;
            id v211 = v145;
            v220.CFIndex length = CFArrayGetCount(CFArrayOfNames);
            v220.CFIndex location = 0;
            CFArrayApplyFunction(CFArrayOfNames, v220, (CFArrayApplierFunction)apply_block_1_2, buf);
            CFTypeRef v146 = CFRetain(v142);

            CFRelease(v142);
            if (v146)
            {
              CFDictionarySetValue(MutableForCFTypesWith, kPCSSecureBackupCFSecureBackupKeyRegistry[0], v146);
              CFRelease(v146);
            }
            goto LABEL_105;
          }
        }

LABEL_105:
        CFStringRef ClientInfo = (const void *)PCSSupportGetClientInfo();
        if (ClientInfo) {
          CFDictionarySetValue(MutableForCFTypesWith, kPCSSecureBackupCFVersionMetadataKey[0], ClientInfo);
        }
LABEL_107:
        if (objc_msgSend(v3, "newIdentity", ClientInfo))
        {
          uint64_t v54 = pcsLogObjForScope("migration");
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1ACF98000, v54, OS_LOG_TYPE_DEFAULT, "New identity was requested, prepping new record creation", buf, 2u);
          }

          _PCSIdentityGuitarfishOptionsToMetadata(v3, MutableForCFTypesWith);
          uint64_t v55 = kPCSSecureBackupCFContainsiCloudIdentityKey[0];
          int v152 = [v3 newHSMContent];
          uint64_t v63 = CFDictionaryCreateMutableForCFTypesWith(v152, v56, v57, v58, v59, v60, v61, v62, v55, *MEMORY[0x1E4F1CFD0]);
          applyOptions(v3, v63);
          if ([v3 metadata])
          {
            CFDictionaryRef v64 = (const __CFDictionary *)[v3 metadata];
            uint64_t v65 = CFDictionaryGetValue(v64, kPCSSecureBackupCFStingrayMetadataHashKey[0]);
            if (v65) {
              CFDictionarySetValue(v63, kPCSSecureBackupCFStingrayMetadataHashKey[0], v65);
            }
            else {
              PCSMigrationLog([v3 log], @"MetadataHashKey missing");
            }
          }
          if (!fail_and_cfu_if_no_password(1, 1, v3, (const __CFDictionary *)[v3 options], (uint64_t *)a2))goto LABEL_164; {
          uint64_t v169 = MEMORY[0x1E4F143A8];
          }
          uint64_t v170 = 3221225472;
          uint64_t v171 = __PCSEngineStoreHSM_block_invoke_754;
          id v172 = &unk_1E5E6E930;
          id v173 = v3;
          v175 = &v202;
          uint64_t v176 = a2;
          size_t v174 = v157;
          _PCSSecureBackupEnableWithInfo();
          __PCS_WAITING_FOR_COM_APPLE_SBD(v174);
        }
        else if ([v3 modified])
        {
          CFDictionaryRef v66 = (const __CFDictionary *)[v3 metadata];
          id v67 = CFDictionaryGetValue(v66, kPCSSecureBackupCFStingrayMetadataHashKey[0]);
          _PCSIdentityGuitarfishOptionsToMetadata(v3, MutableForCFTypesWith);
          uint64_t v63 = CFDictionaryCreateMutableForCFTypesWith(v68, v69, v70, v71, v72, v73, v74, v75, kPCSSecureBackupCFContainsiCloudIdentityKey[0], *MEMORY[0x1E4F1CFD0]);
          if (!v63)
          {
            _PCSErrorOOM(a2);
            uint64_t v63 = 0;
            goto LABEL_164;
          }
          applyOptions(v3, v63);
          if (_PCSMigrationStateIsGuitarfish(v3))
          {
            CFDictionaryRef v76 = (const __CFDictionary *)[v3 options];
            uint64_t v77 = CFDictionaryGetValue(v76, kPCSSetupForceEnroll[0]);
            if (v77)
            {
              CFTypeID v78 = CFGetTypeID(v77);
              if (v78 == CFBooleanGetTypeID())
              {
                CFDictionaryRef v79 = (const __CFDictionary *)[v3 options];
                CFBooleanRef v80 = (const __CFBoolean *)CFDictionaryGetValue(v79, kPCSSetupForceEnroll[0]);
                if (CFBooleanGetValue(v80))
                {
                  if (![v3 newHSMContent] && objc_msgSend(v3, "classicContent"))
                  {
                    PCSMigrationLog([v3 log], @"including previous classicContent for force-enroll");
                    CFDictionarySetValue(v63, kPCSSecureBackupCFiCloudIdentityDataKey[0], (const void *)[v3 classicContent]);
                  }
                }
              }
            }
          }
          if ([v3 newHSMContent])
          {
            PCSMigrationLog([v3 log], @"New HSM content (update)");
            CFDictionarySetValue(v63, kPCSSecureBackupCFiCloudIdentityDataKey[0], (const void *)[v3 newHSMContent]);
          }
          if (v67)
          {
            CFDictionarySetValue(v63, kPCSSecureBackupCFStingrayMetadataHashKey[0], v67);
          }
          else
          {
            uint64_t v82 = [v3 log];
            uint64_t v83 = [v3 newHSMContent];
            v84 = "with content, this will not end well";
            if (!v83) {
              v84 = "no content";
            }
            PCSMigrationLog(v82, @"MetadataHashKey missing: %s", v84);
          }
          v164[0] = MEMORY[0x1E4F143A8];
          v164[1] = 3221225472;
          v164[2] = __PCSEngineStoreHSM_block_invoke_2;
          v164[3] = &unk_1E5E6E930;
          id v85 = v3;
          id v165 = v85;
          CFDataRef v167 = &v202;
          CFDataRef v168 = a2;
          uint64_t v86 = v157;
          id v166 = v86;
          CFDataRef v87 = (void *)MEMORY[0x1AD11D080](v164);
          if ([v85 newHSMContent]
            || _PCSMigrationStateIsGuitarfish(v85)
            && (CFDictionaryRef v88 = (const __CFDictionary *)[v85 options],
                (CFIndex v89 = CFDictionaryGetValue(v88, kPCSSetupForceEnroll[0])) != 0)
            && (CFTypeID v90 = CFGetTypeID(v89), v90 == CFBooleanGetTypeID())
            && (CFDictionaryRef v91 = (const __CFDictionary *)[v85 options],
                CFBooleanRef v92 = (const __CFBoolean *)CFDictionaryGetValue(v91, kPCSSetupForceEnroll[0]),
                CFBooleanGetValue(v92))
            && CFDictionaryGetValue(v63, kPCSSecureBackupCFiCloudIdentityDataKey[0]))
          {
            PCSMigrationLog([v85 log], @"StoreHSM Performing Enable");
            if (!fail_and_cfu_if_no_password(1, 1, v85, (const __CFDictionary *)[v85 options], (uint64_t *)a2))
            {

              goto LABEL_164;
            }
            _PCSSecureBackupEnableWithInfo();
          }
          else
          {
            PCSMigrationLog([v85 log], @"StoreHSM Performing Update");
            _PCSSecureBackupUpdateMetadataWithInfo();
          }
          __PCS_WAITING_FOR_COM_APPLE_SBD(v86);
          if (a2)
          {
            if (!*((unsigned char *)v203 + 24) && CFErrorGetCode((CFErrorRef)*a2) == 22)
            {
              CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)*a2);
              if (CFEqual(Domain, kPCSCloudServicesErrorDomain[0]))
              {
                PCSMigrationLog([v85 log], @"Congestion event happen restarting state machine: %@", *a2);
                CFIndex v94 = *a2;
                if (*a2)
                {
                  *a2 = 0;
                  CFRelease(v94);
                }
                [v85 setRestart:1];
                *((unsigned char *)v203 + 24) = 1;
              }
            }
          }
        }
        else
        {
          uint64_t v63 = 0;
          *((unsigned char *)v203 + 24) = 1;
        }
        if (!_PCSMigrationStateIsGuitarfish(v3)) {
          goto LABEL_164;
        }
        if ([v3 iCDPHSMWalrus]) {
          goto LABEL_164;
        }
        CFAllocatorRef v95 = objc_msgSend((id)objc_msgSend(v3, "options"), "objectForKeyedSubscript:", @"kPRecoveryUseAfterStoreHSMForRTStoreHSM");
        if (v95)
        {
          uint64_t v96 = objc_msgSend((id)objc_msgSend(v3, "options"), "objectForKeyedSubscript:", @"kMnemonicUseAfterStoreHSMForRTStoreHSM");

          if (v96) {
            goto LABEL_164;
          }
        }
        dispatch_semaphore_t v97 = dispatch_semaphore_create(0);
        CFDictionaryRef v98 = (const __CFDictionary *)[v3 options];
        CFDataRef v99 = (void *)CFDictionaryGetValue(v98, kPCSSetupDSID[0]);
        *(void *)long long buf = 0;
        uint64_t v207 = (uint64_t)buf;
        uint64_t v208 = 0x3032000000;
        v209 = __Block_byref_object_copy__1;
        v210 = __Block_byref_object_dispose__1;
        id v211 = 0;
        v161[0] = MEMORY[0x1E4F143A8];
        v161[1] = 3221225472;
        v161[2] = __PCSEngineStoreHSM_block_invoke_3;
        v161[3] = &unk_1E5E6E6D8;
        uint64_t v163 = buf;
        unint64_t v100 = v97;
        v162 = v100;
        _PCSGuitarfishGetKeychainItem(@"WrappingKey", v99, v161);
        dispatch_semaphore_wait(v100, 0xFFFFFFFFFFFFFFFFLL);
        CFTypeRef v101 = (void *)[v3 metadata];
        v102 = [v101 objectForKeyedSubscript:*MEMORY[0x1E4F59B88]];
        v103 = [v102 objectForKeyedSubscript:kPCSSecureBackupCFClientMetadataKey[0]];
        CFStringRef v104 = [v103 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
        CFStringRef v105 = [v104 objectForKeyedSubscript:@"SecureBackupWrappedKeys"];

        if (!v105)
        {
          _PCSError(a2, 200, @"sync: unable to get existing outerblob from metadata");
          int v108 = 4;
LABEL_163:

          _Block_object_dispose(buf, 8);
          if ((v108 | 4) != 4) {
            goto LABEL_183;
          }
LABEL_164:
          if (!v11) {
            goto LABEL_166;
          }
          goto LABEL_165;
        }
        uint64_t context = 0;
        p_uint64_t context = (uint64_t)&context;
        uint64_t v215 = 0x3032000000;
        v216 = __Block_byref_object_copy__1;
        v217 = __Block_byref_object_dispose__1;
        CFMutableDictionaryRef v218 = 0;
        if (!*(void *)(v207 + 40))
        {
          _PCSError(a2, 223, @"sync: unable to get wrappingKey from Keychain");
          int v108 = 4;
          goto LABEL_162;
        }
        *(void *)v193 = 0;
        v194 = v193;
        uint64_t v195 = 0x3032000000;
        v196 = __Block_byref_object_copy__1;
        v197 = __Block_byref_object_dispose__1;
        id v198 = 0;
        uint64_t v106 = *(void **)(v207 + 40);
        v160[0] = MEMORY[0x1E4F143A8];
        v160[1] = 3221225472;
        v160[2] = __PCSEngineStoreHSM_block_invoke_790;
        v160[3] = &unk_1E5E6E958;
        v160[4] = &context;
        v160[5] = v193;
        v160[6] = a2;
        _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(v106, v105, v160);
        uint64_t v107 = *(void *)(p_context + 40);
        if (v107)
        {
          if (*((void *)v194 + 5))
          {
            objc_msgSend((id)objc_msgSend(v3, "options"), "setObject:forKeyedSubscript:", v107, @"kPRecoveryUseAfterStoreHSMForRTStoreHSM");
            objc_msgSend((id)objc_msgSend(v3, "options"), "setObject:forKeyedSubscript:", *((void *)v194 + 5), @"kMnemonicUseAfterStoreHSMForRTStoreHSM");
            int v108 = 0;
LABEL_161:
            _Block_object_dispose(v193, 8);

LABEL_162:
            _Block_object_dispose(&context, 8);

            goto LABEL_163;
          }
          _PCSError(a2, 223, @"sync: unable to recover mnemonicArr from wrappingKey");
        }
        else
        {
          _PCSError(a2, 223, @"sync: unable to recover p_recovery from wrappingKey");
        }
        int v108 = 4;
        goto LABEL_161;
      }
      _PCSErrorOOM(a2);
    }
    uint64_t v63 = 0;
LABEL_244:
    MutableForCFTypesWith = 0;
    goto LABEL_164;
  }
LABEL_182:
  LOBYTE(MutableForCFTypesWith) = *((unsigned char *)v203 + 24) != 0;
LABEL_183:

  _Block_object_dispose(&v202, 8);
  return MutableForCFTypesWith & 1;
}

void sub_1ACFCE514(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x250], 8);
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Block_object_dispose((const void *)(v1 - 240), 8);
  _Unwind_Resume(a1);
}

uint64_t PCSEngineStoreRTHSM(void *a1, uint64_t *a2)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (_PCSMigrationStateIsGuitarfish(v3))
  {
    if ([v3 iCDPHSMWalrus])
    {
      uint64_t v73 = 0;
      if ((__PCSDeleteGuitarfishTokenRecord([v3 log], (const __CFDictionary *)objc_msgSend(v3, "options"), (uint64_t)&v73) & 1) == 0)
      {
        uint64_t v4 = [v3 log];
        PCSMigrationLog(v4, @"Failed to delete Guitarfish token record: %@", v73);
      }
      goto LABEL_5;
    }
    uint64_t v65 = a2;
    uint64_t v6 = (__CFDictionary *)objc_alloc_init(MEMORY[0x1E4F1CA60]);
    applyOptions(v3, v6);
    [(__CFDictionary *)v6 setObject:0 forKeyedSubscript:kPCSSecureBackupCFGuitarfishKey[0]];
    uint64_t v7 = MEMORY[0x1E4F1CC38];
    [(__CFDictionary *)v6 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:kPCSSecureBackupCFContainsiCloudIdentityKey[0]];
    [(__CFDictionary *)v6 setObject:v7 forKeyedSubscript:*MEMORY[0x1E4F59B60]];
    [(__CFDictionary *)v6 setObject:v7 forKeyedSubscript:kPCSSetupGuitarfishToken[0]];
    int v68 = (void *)__PCSCopyStingrayInfo([v3 log], v6, 0);
    id v67 = objc_msgSend((id)objc_msgSend(v3, "options"), "objectForKeyedSubscript:", @"kPRecoveryUseAfterStoreHSMForRTStoreHSM");
    CFDictionaryRef v66 = objc_msgSend((id)objc_msgSend(v3, "options"), "objectForKeyedSubscript:", @"kMnemonicUseAfterStoreHSMForRTStoreHSM");
    uint64_t v5 = 0;
    if (!v67) {
      goto LABEL_61;
    }
    CFArrayRef v8 = v66;
    if (!v66)
    {
LABEL_62:

      goto LABEL_63;
    }
    objc_msgSend((id)objc_msgSend(v3, "options"), "setObject:forKeyedSubscript:", 0, @"kPRecoveryUseAfterStoreHSMForRTStoreHSM");
    objc_msgSend((id)objc_msgSend(v3, "options"), "setObject:forKeyedSubscript:", 0, @"kMnemonicUseAfterStoreHSMForRTStoreHSM");
    uint64_t v73 = 0;
    int v74 = &v73;
    uint64_t v75 = 0x3032000000;
    CFDictionaryRef v76 = __Block_byref_object_copy__1;
    uint64_t v77 = __Block_byref_object_dispose__1;
    id v78 = 0;
    v72[0] = MEMORY[0x1E4F143A8];
    v72[1] = 3221225472;
    void v72[2] = __PCSEngineStoreRTHSM_block_invoke;
    v72[3] = &unk_1E5E6E908;
    v72[4] = &v73;
    v72[5] = v65;
    PCSGuitarfishDeriveRecoveryKeyFromMnemonic((uint64_t)v66, v72);
    if (!v74[5])
    {
      int v45 = 0;
      int v46 = 0;
      uint64_t v5 = 0;
      goto LABEL_60;
    }
    uint64_t v9 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeID v10 = [(id)v74[5] base64EncodedStringWithOptions:0];
      *(_DWORD *)long long buf = 138412290;
      v84 = v10;
      _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "Primary Record PID: %@", buf, 0xCu);
    }
    uint64_t v11 = *MEMORY[0x1E4F59B58];
    if (!v68
      || ([v68 objectForKeyedSubscript:*MEMORY[0x1E4F59B58]],
          CFMutableDictionaryRef v12 = objc_claimAutoreleasedReturnValue(),
          BOOL v13 = v12 == 0,
          v12,
          v13))
    {
      int v21 = 0;
    }
    else
    {
      CFTypeID v14 = [v68 objectForKeyedSubscript:v11];
      CFIndex v15 = [v14 objectForKeyedSubscript:*MEMORY[0x1E4F59B38]];
      uint64_t v16 = [v15 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
      CFIndex v17 = [v16 objectForKeyedSubscript:@"DerivedDBRSeedAESPID"];

      uint64_t v18 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        CFArrayRef v19 = [v17 base64EncodedStringWithOptions:0];
        *(_DWORD *)long long buf = 138412290;
        v84 = v19;
        _os_log_impl(&dword_1ACF98000, v18, OS_LOG_TYPE_DEFAULT, "RT Record PID: %@", buf, 0xCu);
      }
      if (v17 && ([(id)v74[5] isEqualToData:v17] & 1) != 0)
      {
        int v20 = pcsLogObjForScope("Guitarfish");
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1ACF98000, v20, OS_LOG_TYPE_DEFAULT, "RT Record PID matches Primary Record PID", buf, 2u);
        }
        int v21 = 0;
      }
      else
      {
        int v20 = pcsLogObjForScope("Guitarfish");
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
          PCSEngineStoreRTHSM_cold_2();
        }
        int v21 = 1;
      }
    }
    int v22 = [v68 objectForKeyedSubscript:v11];
    uint64_t v23 = *MEMORY[0x1E4F59B48];
    int v24 = [v22 objectForKeyedSubscript:*MEMORY[0x1E4F59B48]];
    if (v24)
    {
      int v25 = [v68 objectForKeyedSubscript:v11];
      uint64_t v26 = *MEMORY[0x1E4F59B40];
      int v27 = [v25 objectForKeyedSubscript:*MEMORY[0x1E4F59B40]];
      BOOL v28 = v27 == 0;

      if (v28) {
        goto LABEL_34;
      }
      CFTypeRef v29 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        CFDictionaryRef v64 = [v68 objectForKeyedSubscript:v11];
        uint64_t v30 = [v64 objectForKeyedSubscript:v23];
        CFArrayRef v31 = [v68 objectForKeyedSubscript:v11];
        char v32 = [v31 objectForKeyedSubscript:v26];
        *(_DWORD *)long long buf = 138412546;
        v84 = v30;
        __int16 v85 = 2112;
        uint64_t v86 = v32;
        _os_log_impl(&dword_1ACF98000, v29, OS_LOG_TYPE_DEFAULT, "RT Record Existing Federation: %@, Expected Federation: %@", buf, 0x16u);
      }
      id v33 = [v68 objectForKeyedSubscript:v11];
      CFMutableArrayRef v34 = [v33 objectForKeyedSubscript:v23];
      CFRange v35 = [v68 objectForKeyedSubscript:v11];
      id v36 = [v35 objectForKeyedSubscript:v26];
      char v37 = [v34 isEqual:v36];

      if (v37)
      {
LABEL_34:
        CFMutableArrayRef v38 = [v68 objectForKeyedSubscript:v11];
        uint64_t v39 = [v38 objectForKeyedSubscript:*MEMORY[0x1E4F59B78]];

        if (v39 && [v39 isEqualToNumber:&unk_1F03F7450])
        {
          int v40 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1ACF98000, v40, OS_LOG_TYPE_DEFAULT, "RT Record is terminal, re-enroll needed", buf, 2u);
          }

          int v21 = 1;
        }
        else
        {
          if (v68) {
            char v41 = v21;
          }
          else {
            char v41 = 1;
          }
          if ((v41 & 1) == 0)
          {
            int v42 = [v68 objectForKeyedSubscript:v11];
            BOOL v43 = v42 == 0;

            if (!v43)
            {
              int v44 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl(&dword_1ACF98000, v44, OS_LOG_TYPE_DEFAULT, "RT Record already exists", buf, 2u);
              }
              int v45 = 0;
              int v46 = 0;
              uint64_t v5 = 1;
              goto LABEL_59;
            }
            int v21 = 0;
          }
        }
        int v47 = pcsLogObjForScope("Guitarfish");
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109120;
          LODWORD(v84) = v21;
          _os_log_impl(&dword_1ACF98000, v47, OS_LOG_TYPE_DEFAULT, "Creating RT Record: re-enroll: %d", buf, 8u);
        }

        uint64_t v81 = kPCSSecureBackupCFiCloudDataProtectionKey[0];
        uint64_t v48 = v74[5];
        CFDictionaryRef v79 = @"DerivedDBRSeedAESPID";
        uint64_t v80 = v48;
        char v49 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v80 forKeys:&v79 count:1];
        uint64_t v82 = v49;
        int v46 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v82 forKeys:&v81 count:1];

        id v71 = 0;
        char v50 = _PCSGuitarfishDerivePTokenFromPRecoveryAndMnemonic(v67, v66, &v71);
        id v51 = v71;
        int v44 = v51;
        if (!v50 || v51)
        {
          int v52 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
            PCSEngineStoreRTHSM_cold_1();
          }
        }
        if (v50
          && !v44
          && (-[__CFDictionary setObject:forKeyedSubscript:](v6, "setObject:forKeyedSubscript:", v46, kPCSSecureBackupCFMetadataKey[0]), -[__CFDictionary setObject:forKeyedSubscript:](v6, "setObject:forKeyedSubscript:", v50, kPCSSecureBackupCFiCloudIdentityDataKey[0]), fail_and_cfu_if_no_password(1, 0, v3, (const __CFDictionary *)[v3 options], v65)))
        {
          uint64_t v53 = [AAFAnalyticsEventPCS alloc];
          uint64_t v54 = (void *)[v3 options];
          uint64_t v55 = [v54 objectForKeyedSubscript:kPCSAltDSID[0]];
          int v56 = (void *)[v3 options];
          int v57 = [v56 objectForKeyedSubscript:kPCSFlowID[0]];
          int v58 = (void *)[v3 options];
          int v59 = [v58 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
          LOBYTE(v63) = 1;
          int v60 = [(AAFAnalyticsEventPCS *)v53 initWithPCSMetrics:0 altDSID:v55 flowID:v57 deviceSessionID:v59 eventName:@"com.apple.pcs.enrollRecoveryToken" testsAreEnabled:0 canSendMetrics:v63 category:0x1F03F7498];

          dispatch_semaphore_t v61 = dispatch_semaphore_create(0);
          int v69 = v60;
          id v70 = v3;
          int v45 = v61;
          _PCSSecureBackupEnableWithInfo();
          __PCS_WAITING_FOR_COM_APPLE_SBD(v45);

          uint64_t v5 = 1;
          int v44 = v50;
        }
        else
        {

          int v45 = 0;
          uint64_t v5 = 0;
        }
LABEL_59:

LABEL_60:
        _Block_object_dispose(&v73, 8);

LABEL_61:
        CFArrayRef v8 = v66;
        goto LABEL_62;
      }
      int v22 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1ACF98000, v22, OS_LOG_TYPE_DEFAULT, "RT Record Federation Migration Needed", buf, 2u);
      }
      int v21 = 1;
    }

    goto LABEL_34;
  }
LABEL_5:
  uint64_t v5 = 1;
LABEL_63:

  return v5;
}

void sub_1ACFCF150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t PCSEngineStoreLocal(void *a1, const void **a2)
{
  id v3 = a1;
  CFTypeRef v4 = PCSIdentitySetCreate((const __CFDictionary *)[v3 options], 0, a2);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = [v3 set];
    uint64_t v30 = MEMORY[0x1E4F143A8];
    uint64_t v31 = 3221225472;
    char v32 = __PCSEngineStoreLocal_block_invoke;
    id v33 = &unk_1E5E6E9F8;
    id v7 = v3;
    id v34 = v7;
    CFRange v35 = v5;
    PCSIdentitySetEnumerateIdentities(v6, 0, &v30);
    uint64_t IsGuitarfish = _PCSMigrationStateIsGuitarfish(v7);
    if (objc_msgSend(v7, "newHSMContent", v30, v31, v32, v33)
      && ([v7 dropHSM] & 1) == 0
      && ([v7 restoreHSM] & 1) == 0)
    {
      CFDictionaryRef v9 = (const __CFDictionary *)[v7 options];
      CFDictionaryRef Value = (void *)CFDictionaryGetValue(v9, kPCSSetupDSID[0]);
      if (!PCSCurrentPersonaMatchesDSID(Value)) {
        goto LABEL_15;
      }
      uint64_t v11 = [v7 newHSMContent];
      if (!__PCSStoreInKeychain(IsGuitarfish, v11, (uint64_t)Value, a2, v12, v13, v14, v15)
        || !__PCSStoreIniCloudKeychain([v7 newHSMContent], (int)Value, IsGuitarfish, a2))
      {
        goto LABEL_18;
      }
    }
    if (![v7 escrowMergeNeeded])
    {
LABEL_12:
      [v7 clearSet];
      [v7 setSet:CFRetain(v5)];
      uint64_t v28 = 1;
LABEL_13:
      CFRelease(v5);
LABEL_16:

      goto LABEL_17;
    }
    CFDictionaryRef v16 = (const __CFDictionary *)[v7 options];
    CFIndex v17 = (void *)CFDictionaryGetValue(v16, kPCSSetupDSID[0]);
    if (PCSCurrentPersonaMatchesDSID(v17))
    {
      uint64_t v18 = [v7 classicContent];
      if (__PCSStoreInKeychain(IsGuitarfish, v18, (uint64_t)v17, a2, v19, v20, v21, v22))
      {
        uint64_t v23 = [v7 classicContent];
        if (__PCSUpdateIniCloudKeychain(v23, (int)v17, IsGuitarfish, a2, v24, v25, v26, v27)) {
          goto LABEL_12;
        }
      }
LABEL_18:
      uint64_t v28 = 0;
      goto LABEL_13;
    }
LABEL_15:
    _PCSError(a2, 152, @"current persona does not match dsid");
    uint64_t v28 = 0;
    goto LABEL_16;
  }
  uint64_t v28 = 0;
LABEL_17:

  return v28;
}

uint64_t PCSEngineStoreLocalKeyfile(void *a1, const void **a2)
{
  v24[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (![v3 modified]) {
    goto LABEL_16;
  }
  CFDictionaryRef v4 = (const __CFDictionary *)[v3 options];
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(v4, kPCSSetupDSID[0]);
  if (!Value || (v6 = Value, CFTypeID v7 = CFGetTypeID(Value), v7 != CFStringGetTypeID()))
  {
    _PCSErrorContext([v3 log], a2, 121, @"Missing parameter: dsid");
    goto LABEL_9;
  }
  if (!CFEqual(v6, kPCSSetupDSIDAny[0]))
  {
    BOOL v8 = PCSCurrentPersonaMatchesDSID(v6);
    if (a2 && !v8)
    {
      CFDictionaryRef v9 = (void *)MEMORY[0x1E4F28C58];
      CFTypeID v10 = kPCSErrorDomain;
      uint64_t v23 = *MEMORY[0x1E4F28568];
      v24[0] = @"Current persona does not match chosen dsid";
      uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v24 forKeys:&v23 count:1];
      *a2 = [v9 errorWithDomain:v10 code:152 userInfo:v11];

      goto LABEL_9;
    }
    if (!StoreLocalKeyfile(v3, (uint64_t)v6, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/LocalBackup", @"backup", 0, 0x20000000, a2))goto LABEL_9; {
    uint64_t v13 = LocalStorageCreatePath((uint64_t)v6, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/LocalBackup", @"witness");
    }
    if (!v13) {
      goto LABEL_9;
    }
    uint64_t v14 = (void *)v13;
    uint64_t v15 = [MEMORY[0x1E4F1C9C8] date];
    CFDictionaryRef v16 = [v15 description];
    [v16 writeToFile:v14 atomically:0 encoding:4 error:0];

    CFIndex v17 = +[PCSMobileBackup defaultMobileBackup];
    if ([v17 isBackupEnabled])
    {
      uint64_t v22 = kPCSMessages3;
      uint64_t v18 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v22 count:1];
      StoreLocalKeyfile(v3, (uint64_t)v6, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/Backup", @"messages", v18, 0x40000000, 0);
    }
    else
    {
      uint64_t v19 = LocalStorageCreatePath((uint64_t)v6, @"/var/mobile/Library/Application Support/com.apple.ProtectedCloudStorage/Backup", @"messages");
      uint64_t v20 = [MEMORY[0x1E4F28CB8] defaultManager];
      [v20 removeItemAtPath:v19 error:0];
    }
LABEL_16:
    uint64_t v12 = 1;
    goto LABEL_17;
  }
LABEL_9:
  uint64_t v12 = 0;
LABEL_17:

  return v12;
}

uint64_t PCSEngineStoreiCDPStatus(void *a1, const void **a2)
{
  return _PCSEngineStoreiCDPStatus(a1, 0, a2);
}

uint64_t PCSEngineAddMissingCurrentPointers(void *a1, const void **a2)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!_PCSRunningInUnitTests())
  {
    if ([v3 iCDP])
    {
      CFDictionaryRef v4 = (const __CFDictionary *)[v3 options];
      CFDictionaryRef Value = (void *)CFDictionaryGetValue(v4, kPCSSetupDSID[0]);
      if (!Value || (v6 = Value, CFTypeID v7 = CFGetTypeID(Value), v7 != CFStringGetTypeID()))
      {
        _PCSErrorContext([v3 log], a2, 121, @"Missing parameter: dsid");
        goto LABEL_11;
      }
      BOOL v8 = PCSCurrentPersonaMatchesDSID(v6);
      if (a2 && !v8)
      {
        CFDictionaryRef v9 = (void *)MEMORY[0x1E4F28C58];
        CFTypeID v10 = kPCSErrorDomain;
        uint64_t v17 = *MEMORY[0x1E4F28568];
        v18[0] = @"Current persona does not match chosen dsid";
        uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v18 forKeys:&v17 count:1];
        *a2 = [v9 errorWithDomain:v10 code:152 userInfo:v11];

LABEL_11:
        uint64_t v12 = 0;
        goto LABEL_12;
      }
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      void v14[2] = __PCSEngineAddMissingCurrentPointers_block_invoke;
      v14[3] = &unk_1E5E6EA70;
      CFDictionaryRef v16 = v6;
      id v15 = v3;
      PCSServiceItemsGetEachName(v14);
    }
    else
    {
      PCSMigrationLog([v3 log], @"CDP not enabled, skipping AddMissingCurrentPointers");
    }
  }
  uint64_t v12 = 1;
LABEL_12:

  return v12;
}

uint64_t CaptureMetadata(void *a1, const __CFDictionary *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  CFDictionaryRef HSMClientMetaData = GetHSMClientMetaData(a2);
  if (HSMClientMetaData)
  {
    CFDictionaryRef v5 = HSMClientMetaData;
    CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(HSMClientMetaData, kPCSSecureBackupCFStableMetadataKey[0]);
    if (Value)
    {
      CFDictionaryRef v7 = Value;
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 != CFDictionaryGetTypeID()
        || ([v3 clearStableMetadata],
            objc_msgSend(v3, "setStableMetadata:", CFDictionaryCreateMutableCopy(0, 0, v7)),
            ![v3 stableMetadata]))
      {
        uint64_t v28 = 0;
        goto LABEL_24;
      }
    }
    CFDictionaryRef v9 = (void *)[v3 options];
    CFTypeID v10 = [v9 objectForKeyedSubscript:kPCSPasswordGenerationFromExistingMetadata[0]];

    if (!v10)
    {
      uint64_t v11 = [(__CFDictionary *)v5 objectForKeyedSubscript:@"IdMSPasswordGeneration"];
      uint64_t v12 = (void *)[v3 options];
      [v12 setObject:v11 forKeyedSubscript:kPCSPasswordGenerationFromExistingMetadata[0]];
    }
    id v13 = v3;
    if (_PCSMigrationStateIsGuitarfish(v13))
    {
      id v30 = v3;
      uint64_t v14 = __PCSIdentityOptionsToMetaMapping();
      long long v31 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      id v15 = [v14 allKeys];
      uint64_t v16 = [v15 countByEnumeratingWithState:&v31 objects:v35 count:16];
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = *(void *)v32;
        do
        {
          for (uint64_t i = 0; i != v17; ++i)
          {
            if (*(void *)v32 != v18) {
              objc_enumerationMutation(v15);
            }
            uint64_t v20 = *(const void **)(*((void *)&v31 + 1) + 8 * i);
            uint64_t v21 = [v14 objectForKeyedSubscript:v20];
            if (!CFDictionaryContainsKey((CFDictionaryRef)[v13 options], v20)
              && CFDictionaryContainsKey(v5, v21))
            {
              uint64_t v22 = (__CFDictionary *)[v13 options];
              uint64_t v23 = CFDictionaryGetValue(v5, v21);
              CFDictionarySetValue(v22, v20, v23);
            }
          }
          uint64_t v17 = [v15 countByEnumeratingWithState:&v31 objects:v35 count:16];
        }
        while (v17);
      }

      id v3 = v30;
    }

    [v13 clearOldRegistry];
    objc_msgSend(v13, "setOldRegistry:", CFDictionaryGetValue(v5, kPCSSecureBackupCFSecureBackupKeyRegistry[0]));
    if ([v13 oldRegistry])
    {
      CFRetain((CFTypeRef)[v13 oldRegistry]);
      CFDictionaryRef v24 = (const __CFDictionary *)[v13 options];
      CFDictionaryGetValue(v24, kPCSSetupCallbackKeyRegistry[0]);
      uint64_t v25 = (void (**)(void, void, void))objc_claimAutoreleasedReturnValue();
      if (v25)
      {
        CFDictionaryRef v26 = (const __CFDictionary *)[v13 options];
        int v27 = CFDictionaryGetValue(v26, kPCSSetupDSID[0]);
        ((void (**)(void, const void *, uint64_t))v25)[2](v25, v27, [v13 oldRegistry]);
      }
    }
  }
  uint64_t v28 = 1;
LABEL_24:

  return v28;
}

uint64_t _PCSMigrationStateIsGuitarfish(void *a1)
{
  uint64_t v1 = (void *)[a1 options];
  CFDictionaryRef v2 = [v1 objectForKeyedSubscript:kPCSSetupGuitarfish[0]];
  uint64_t v3 = [v2 BOOLValue];

  return v3;
}

id __PCSIdentityOptionsToMetaMapping()
{
  v3[4] = *MEMORY[0x1E4F143B8];
  v2[0] = kPCSSetupVerifierIterationCount[0];
  v2[1] = kPCSSetupVerifierProtocol[0];
  v3[0] = @"IdMSPasswordVerifierIterations";
  v3[1] = @"IdMSPasswordVerifierProto";
  v2[2] = kPCSSetupVerifierSalt[0];
  v2[3] = kPCSSetupPasswordGeneration[0];
  void v3[2] = kPCSSetupVerifierSalt[0];
  v3[3] = @"IdMSPasswordGeneration";
  BOOL v0 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v3 forKeys:v2 count:4];
  return v0;
}

uint64_t PCSEngineHaveSyncEnoughToCreateIdentities(void *a1, const void **a2)
{
  id v3 = a1;
  if (![v3 set])
  {
    objc_msgSend(v3, "setSet:", PCSIdentitySetCreate((const __CFDictionary *)objc_msgSend(v3, "options"), 0, a2));
    if (![v3 set])
    {
      CFDictionaryRef v7 = 0;
      CFTypeRef v4 = 0;
      goto LABEL_38;
    }
  }
  CFTypeRef v4 = PCSStateCopyKeychainClassicIdentities(v3, 0, a2);
  if (!v4)
  {
    CFDictionaryRef v7 = 0;
    goto LABEL_38;
  }
  uint64_t v5 = [v3 set];
  uint64_t v6 = _PCSIdentitySetCopyCurrentIdentityInternal(v5, kPCSServiceMaster, a2);
  CFDictionaryRef v7 = v6;
  if (!v6)
  {
LABEL_38:
    uint64_t v28 = 0;
    int PublicKey = 0;
    goto LABEL_27;
  }
  int PublicKey = (const void *)PCSIdentityGetPublicKey((uint64_t)v6);
  if (PublicKey)
  {
    if ([v3 oldRegistry])
    {
      CFDictionaryRef v9 = (const __CFDictionary *)[v3 oldRegistry];
      if (!v9) {
        goto LABEL_25;
      }
      CFDictionaryRef v10 = v9;
      CFTypeID v11 = CFGetTypeID(v9);
      if (v11 != CFDictionaryGetTypeID()) {
        goto LABEL_25;
      }
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v10, kPCSServiceMaster);
      if (Value
        && (CFDictionaryRef v13 = Value, v14 = CFGetTypeID(Value), v14 == CFDictionaryGetTypeID())
        && (CFArrayRef v15 = (const __CFArray *)CFDictionaryGetValue(v13, kPCSSecureBackupCFKeyRegistryPublicIdentities[0])) != 0
        && (v16 = v15, CFTypeID v17 = CFGetTypeID(v15), v17 == CFArrayGetTypeID())
        && (CFIndex Count = CFArrayGetCount(v16), Count >= 1))
      {
        CFIndex v19 = Count;
        BOOL v20 = 0;
        uint64_t v21 = 1;
        do
        {
          CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v16, v21 - 1);
          if (ValueAtIndex)
          {
            CFDataRef v23 = ValueAtIndex;
            CFTypeID v24 = CFGetTypeID(ValueAtIndex);
            if (v24 == CFDataGetTypeID())
            {
              uint64_t v25 = PCSPublicIdentityCreateWithPublicKeyInfo(v23, 0);
              if (v25)
              {
                CFDictionaryRef v26 = v25;
                uint64_t PublicID = (const void *)PCSPublicIdentityGetPublicID((uint64_t)v25);
                if (PublicID) {
                  BOOL v20 = CFEqual(PublicID, PublicKey) != 0;
                }
                CFRelease(v26);
              }
            }
          }
          if (v21 >= v19) {
            break;
          }
          ++v21;
        }
        while (!v20);
      }
      else
      {
LABEL_25:
        BOOL v20 = 0;
      }
      uint64_t v28 = v20;
    }
    else
    {
      uint64_t v28 = 1;
    }
  }
  else
  {
    uint64_t v28 = 0;
  }
LABEL_27:
  uint64_t v29 = [v3 log];
  id v30 = _PCSYESNO(v28);
  if ([v3 oldRegistry]) {
    long long v31 = @"Registry";
  }
  else {
    long long v31 = @"First modern";
  }
  long long v32 = _PCSYESNO(v4 != 0);
  PCSMigrationLog(v29, @"EnoughToUpdate: %@ though %@ (master %@, content %@)", v30, v31, PublicKey, v32);
  if (v4) {
    CFRelease(v4);
  }
  if (v7) {
    CFRelease(v7);
  }

  return v28;
}

CFTypeRef PCSStateCopyKeychainClassicIdentities(void *a1, int a2, const void **a3)
{
  id v5 = a1;
  CFDictionaryRef v6 = (const __CFDictionary *)[v5 options];
  CFDictionaryRef Value = (__CFString *)CFDictionaryGetValue(v6, kPCSSetupDSID[0]);
  CFDictionaryRef v8 = (const __CFDictionary *)[v5 options];
  CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(v8, kPCSSetupUsername[0]);
  CFErrorRef v53 = 0;
  CFErrorRef err = 0;
  if (!Value || (v10 = v9, CFTypeID v11 = CFGetTypeID(Value), v11 != CFStringGetTypeID()))
  {
    _PCSError(a3, 3, @"DSID not a string", v53);
    goto LABEL_9;
  }
  if (!PCSCurrentPersonaMatchesDSID(Value))
  {
    _PCSError(a3, 152, @"current persona does not match dsid", v53);
    goto LABEL_9;
  }
  int IsGuitarfish = _PCSMigrationStateIsGuitarfish(v5);
  char v13 = IsGuitarfish;
  CFTypeRef v19 = __PCSCopyFromiCloudKeychain(Value, IsGuitarfish, (const void **)&err, v14, v15, v16, v17, v18);
  CFTypeRef v24 = __PCSCopyFromKeychain(v13, v10, Value, (const void **)&v53, v20, v21, v22, v23);
  BOOL v25 = 0;
  CFErrorRef v26 = err;
  if (err && v53)
  {
    BOOL v25 = CFErrorGetCode(err) == -25300 && CFErrorGetCode(v53) == -25300;
    CFErrorRef v26 = err;
  }
  if (v26)
  {
    CFErrorRef err = 0;
    CFRelease(v26);
  }
  CFErrorRef v27 = v53;
  if (v53)
  {
    CFErrorRef v53 = 0;
    CFRelease(v27);
  }
  if (v19 && v24)
  {
    if (CFEqual(v19, v24))
    {
      CFRelease(v24);
      CFTypeRef v24 = 0;
      goto LABEL_20;
    }
    _PCSError(a3, 74, @"local and iCKC not the same PCS keys");
    CFRelease(v24);
    CFRelease(v19);
LABEL_9:
    CFTypeRef v19 = 0;
    goto LABEL_71;
  }
LABEL_20:
  if (v19) {
    int v28 = 1;
  }
  else {
    int v28 = v25;
  }
  if (a2 && v28)
  {
    id v29 = v5;
    uint64_t v64 = 0;
    uint64_t v65 = &v64;
    uint64_t v66 = 0x2020000000;
    char v67 = 0;
    uint64_t v60 = 0;
    dispatch_semaphore_t v61 = &v60;
    uint64_t v62 = 0x2020000000;
    uint64_t v63 = 0;
    id v59 = 0;
    id v30 = [MEMORY[0x1E4F3B3F8] controlObject:&v59];
    id v31 = v59;
    long long v32 = v31;
    if (!v30)
    {
      if (a3) {
        *a3 = v31;
      }

      _Block_object_dispose(&v60, 8);
      _Block_object_dispose(&v64, 8);
      goto LABEL_65;
    }
    dispatch_semaphore_t v33 = dispatch_semaphore_create(0);
    v55[0] = MEMORY[0x1E4F143A8];
    v55[1] = 3221225472;
    v55[2] = __PCSFetchCKKSWithTimeout_block_invoke;
    v55[3] = &unk_1E5E6E688;
    int v57 = &v64;
    int v58 = &v60;
    long long v34 = v33;
    int v56 = v34;
    [v30 rpcFetchAndProcessChangesIfNoRecentFetch:@"ProtectedCloudStorage" reply:v55];
    dispatch_time_t v35 = dispatch_time(0, 20000000000);
    if (dispatch_semaphore_wait(v34, v35))
    {
      _PCSError(a3, 99, @"rpcFetchAndProcessChanges timed out");
      BOOL v36 = 0;
    }
    else
    {
      char v37 = v61;
      if (a3)
      {
        CFMutableArrayRef v38 = (const void *)v61[3];
        if (v38)
        {
          *a3 = CFRetain(v38);
          char v37 = v61;
        }
      }
      uint64_t v39 = (const void *)v37[3];
      if (v39)
      {
        v37[3] = 0;
        CFRelease(v39);
      }
      BOOL v36 = *((unsigned char *)v65 + 24) != 0;
    }

    _Block_object_dispose(&v60, 8);
    _Block_object_dispose(&v64, 8);
    if (v36)
    {
      if (v19)
      {
        int v40 = PCSIdentitySetCreateFromExternalForm(0, (const __CFData *)v19, 0, a3);
        if (!v40) {
          goto LABEL_65;
        }
        char v41 = v40;
        int v42 = _PCSIdentitySetCopyCurrentIdentityInternal((uint64_t)v40, kPCSServiceMaster, 0);
        BOOL v43 = _PCSIdentitySetCopyCurrentIdentityInternal((uint64_t)v41, kPCSServiceEscrow, 0);
        CFRelease(v41);
        if (v42 && v43)
        {
          CFRelease(v42);
          CFRelease(v43);
          uint64_t ExternalForm = (uint64_t)CFRetain(v19);
LABEL_66:

          if (v24) {
            CFRelease(v24);
          }
          if (v19) {
            CFRelease(v19);
          }
          CFTypeRef v19 = (CFTypeRef)ExternalForm;
          goto LABEL_71;
        }
        if (v42) {
          CFRelease(v42);
        }
        if (v43) {
          CFRelease(v43);
        }
      }
      uint64_t v45 = objc_msgSend(v29, "set", v53);
      int v46 = _PCSIdentitySetCopyCurrentIdentityInternal(v45, kPCSServiceMaster, 0);
      if (v46) {
        goto LABEL_54;
      }
      CFTypeRef Master = PCSIdentityCreateMaster(0, a3);
      if (Master)
      {
        int v46 = Master;
        if (!PCSIdentitySetAddIdentityWithError([v29 set], (uint64_t)Master, a3)
          || !PCSIdentitySetSetCurrentIdentityWithError([v29 set], (uint64_t)v46, a3))
        {
          uint64_t ExternalForm = 0;
LABEL_64:
          CFRelease(v46);
          goto LABEL_66;
        }
LABEL_54:
        if (GetClassicServiceArray_onceToken != -1) {
          dispatch_once(&GetClassicServiceArray_onceToken, &__block_literal_global_10);
        }
        CFArrayRef v48 = (const __CFArray *)GetClassicServiceArray_array;
        if (CFArrayGetCount((CFArrayRef)GetClassicServiceArray_array) < 1)
        {
LABEL_63:
          uint64_t ExternalForm = PCSIdentitySetCreateExternalForm([v29 log], objc_msgSend(v29, "set"), 1, v48, a3);
          goto LABEL_64;
        }
        CFIndex v49 = 0;
        while (1)
        {
          CFDataRef ValueAtIndex = (void *)CFArrayGetValueAtIndex(v48, v49);
          if (!CFEqual(ValueAtIndex, kPCSServiceMaster))
          {
            id v51 = _PCSIdentitySetCopyCurrentIdentityInternal([v29 set], (uint64_t)ValueAtIndex, 0);
            if (v51)
            {
              CFRelease(v51);
            }
            else if ((AddService(v29, (uint64_t)v46, ValueAtIndex, a3) & 1) == 0)
            {
              uint64_t ExternalForm = 0;
              goto LABEL_64;
            }
          }
          if (++v49 >= CFArrayGetCount(v48)) {
            goto LABEL_63;
          }
        }
      }
    }
LABEL_65:
    uint64_t ExternalForm = 0;
    goto LABEL_66;
  }
  if (!v19)
  {
    CFTypeRef v19 = v24;
    if (!v24) {
      _PCSError(a3, 74, @"no PCS keys in keychain!");
    }
  }
LABEL_71:

  return v19;
}

void sub_1ACFD0518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

const void *isArray(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFArrayGetTypeID());
  }
  return result;
}

uint64_t AddService(void *a1, uint64_t a2, void *a3, const void **a4)
{
  id v7 = a1;
  unsigned int FlagsByName = PCSServiceItemGetFlagsByName(a3);
  if (CFEqual(a3, kPCSServiceMaster))
  {
    _PCSErrorContext([v7 log], a4, 54, @"Can't add master to set %@", objc_msgSend(v7, "set"));
    goto LABEL_15;
  }
  CFStringRef v9 = _PCSIdentitySetCopyCurrentIdentityInternal([v7 set], (uint64_t)a3, 0);
  if (!v9)
  {
    uint64_t v12 = [v7 log];
    char v13 = _PCSYESNO(1);
    uint64_t v14 = _PCSYESNO(0);
    uint64_t v15 = _PCSYESNO((FlagsByName >> 2) & 1);
    PCSMigrationLog(v12, @"   service %@ identity missing: %@ invalid: %@, manatee: %@. adding one", a3, v13, v14, v15);
    goto LABEL_7;
  }
  CFStringRef v10 = v9;
  if ((PCSIdentityCheckValidPublicKey((uint64_t)v9, 0) & 1) == 0)
  {
    uint64_t v16 = [v7 log];
    int v17 = _PCSYESNO(0);
    int v18 = _PCSYESNO(1);
    CFTypeRef v19 = _PCSYESNO((FlagsByName >> 2) & 1);
    PCSMigrationLog(v16, @"   service %@ identity missing: %@ invalid: %@, manatee: %@. adding one", a3, v17, v18, v19);
    CFRelease(v10);
LABEL_7:
    Service = PCSIdentityCreateService(a2, FlagsByName | 1, a3, a4);
    if (Service)
    {
      CFStringRef v10 = Service;
      if (PCSIdentitySetAddIdentity([v7 set], (uint64_t)Service)
        && PCSIdentitySetSetCurrentIdentity([v7 set], (uint64_t)v10))
      {
        uint64_t v11 = 1;
        [v7 setModified:1];
      }
      else
      {
        uint64_t v11 = 0;
      }
      goto LABEL_11;
    }
LABEL_15:
    uint64_t v11 = 0;
    goto LABEL_12;
  }
  uint64_t v11 = 1;
LABEL_11:
  CFRelease(v10);
LABEL_12:

  return v11;
}

void __PCSFetchCKKSWithTimeout_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v3 == 0;
  id v4 = v3;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v4;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t __GetClassicServiceArray_block_invoke()
{
  v1[7] = *MEMORY[0x1E4F143B8];
  v1[0] = kPCSServiceMaster;
  v1[1] = kPCSServiceBladerunner;
  v1[2] = kPCSServiceHyperion;
  v1[3] = kPCSServiceLiverpool;
  v1[4] = kPCSServiceEscrow;
  v1[5] = kPCSServiceFDE;
  void v1[6] = kPCSServicePianoMover;
  uint64_t result = [MEMORY[0x1E4F1C978] arrayWithObjects:v1 count:7];
  GetClassicServiceArray_array = result;
  return result;
}

uint64_t PCSEngineValidateStepEnsureServicesHaveCurrentSet(void *a1)
{
  id v1 = a1;
  CFArrayRef CFArrayOfNames = (const __CFArray *)PCSServiceItemsGetCFArrayOfNames();
  if ([v1 set])
  {
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __PCSEngineValidateStepEnsureServicesHaveCurrentSet_block_invoke;
    context[3] = &unk_1E5E6E6B0;
    id v5 = v1;
    v6.CFIndex length = CFArrayGetCount(CFArrayOfNames);
    v6.CFIndex location = 0;
    CFArrayApplyFunction(CFArrayOfNames, v6, (CFArrayApplierFunction)apply_block_1_2, context);
  }
  return 1;
}

uint64_t PCSEngineStepValidateEscrowedKeys(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (([v1 iCDPHSMWalrus] & 1) == 0 && (objc_msgSend(v1, "iCDPHSMPlesio") & 1) == 0)
  {
    uint64_t v2 = [v1 set];
    id v3 = _PCSIdentitySetCopyCurrentIdentityInternal(v2, kPCSServiceEscrow, 0);
    if (v3)
    {
      id v4 = v3;
      if ((PCSIdentityCheckValidPublicKey((uint64_t)v3, 0) & 1) == 0)
      {
        CFDictionaryRef v5 = GetiCDPMetadata((const __CFDictionary *)[v1 metadata]);
        if (v5)
        {
          CFDictionaryRef v6 = v5;
          id v7 = kPCSMetadataEscrowedKeys[0];
          CFDictionaryRef v8 = _PCSMigrationStateIsGuitarfish(v1) ? @"SecureBackupWrappedKeys" : v7;
          CFDictionaryRef Value = (void *)CFDictionaryGetValue(v6, v8);
          if (Value)
          {
            CFStringRef v10 = Value;
            CFTypeID v11 = CFGetTypeID(Value);
            if (v11 == CFDataGetTypeID())
            {
              if (!_PCSMigrationStateIsGuitarfish(v1)) {
                goto LABEL_17;
              }
              CFDictionaryRef v12 = (const __CFDictionary *)[v1 options];
              char v13 = (void *)CFDictionaryGetValue(v12, kPCSSetupDSID[0]);
              id v18 = 0;
              CFStringRef v10 = PCSGuitarfishUnwrapKeys(v13, v10, &v18);
              id v14 = v18;
              if (v14)
              {
                uint64_t v15 = pcsLogObjForScope("Guitarfish");
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138412290;
                  id v20 = v14;
                  _os_log_impl(&dword_1ACF98000, v15, OS_LOG_TYPE_DEFAULT, "Error during PCSGuitarfishUnwrapKeys: %@", buf, 0xCu);
                }

                goto LABEL_20;
              }

              if (v10)
              {
LABEL_17:
                uint64_t v16 = PCSBackupCopyRecoveredKeysetWithIdentity((uint64_t)v4, (CFDataRef)v10, 0);
                if (v16) {
                  CFRelease(v16);
                }
                else {
                  [v1 setModified:1];
                }
              }
            }
          }
        }
      }
LABEL_20:
      CFRelease(v4);
    }
  }

  return 1;
}

void __PCSEngineValidateStepEnsureServicesHaveCurrentSet_block_invoke(uint64_t a1, void *a2)
{
  if ((![*(id *)(a1 + 32) limitLocalStoring] || IsLocalStoringService(*(void **)(a1 + 32), a2))
    && (([*(id *)(a1 + 32) iCDP] & 1) != 0 || (PCSServiceItemTypeIsManatee(a2) & 1) == 0))
  {
    id v4 = _PCSIdentitySetCopyCurrentIdentityInternal([*(id *)(a1 + 32) set], (uint64_t)a2, 0);
    if (v4)
    {
LABEL_6:
      CFRelease(v4);
      return;
    }
    CFArrayRef v5 = (const __CFArray *)PCSIdentitySetCopyOrderedIdentities([*(id *)(a1 + 32) set], (uint64_t)a2);
    if (!v5) {
      return;
    }
    CFArrayRef v6 = v5;
    if (!CFArrayGetCount(v5))
    {
      id v4 = v6;
      goto LABEL_6;
    }
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v6, 0);
    PCSIdentitySetSetCurrentIdentity([*(id *)(a1 + 32) set], (uint64_t)ValueAtIndex);
    CFRelease(v6);
    CFDictionaryRef v8 = *(void **)(a1 + 32);
    [v8 setModified:1];
  }
}

BOOL IsLocalStoringService(void *a1, const void *a2)
{
  id v3 = a1;
  if (![v3 limitLocalStoring]) {
    IsLocalStoringService_cold_1();
  }
  CFArrayRef v4 = (const __CFArray *)[v3 limitLocalStoring];
  v7.CFIndex length = CFArrayGetCount((CFArrayRef)[v3 limitLocalStoring]);
  v7.CFIndex location = 0;
  BOOL v5 = CFArrayContainsValue(v4, v7, a2) != 0;

  return v5;
}

uint64_t apply_block_1_2(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

__CFString *_PCSMigrationRecoverPPasswordFromStashedKey(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (_PCSMigrationStateIsGuitarfish(v3))
  {
    BOOL v5 = (void *)[v3 metadata];
    CFArrayRef v6 = [v5 objectForKeyedSubscript:*MEMORY[0x1E4F59B88]];
    CFRange v7 = [v6 objectForKeyedSubscript:kPCSSecureBackupCFClientMetadataKey[0]];
    CFDictionaryRef v8 = [v7 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
    CFStringRef v9 = [v8 objectForKeyedSubscript:@"SecureBackupWrappedKeys"];

    if (v9)
    {
      uint64_t v28 = 0;
      id v29 = &v28;
      uint64_t v30 = 0x3032000000;
      id v31 = __Block_byref_object_copy__1;
      long long v32 = __Block_byref_object_dispose__1;
      id v33 = 0;
      dispatch_semaphore_t v10 = dispatch_semaphore_create(0);
      CFTypeID v11 = @"WrappingKey";
      v25[0] = MEMORY[0x1E4F143A8];
      v25[1] = 3221225472;
      void v25[2] = ___PCSMigrationRecoverPPasswordFromStashedKey_block_invoke;
      v25[3] = &unk_1E5E6E6D8;
      CFErrorRef v27 = &v28;
      CFDictionaryRef v12 = v10;
      CFErrorRef v26 = v12;
      _PCSGuitarfishGetKeychainItem(@"WrappingKey", v4, v25);
      dispatch_semaphore_wait(v12, 0xFFFFFFFFFFFFFFFFLL);
      char v13 = (void *)v29[5];
      if (!v13) {
        goto LABEL_11;
      }
      uint64_t v19 = 0;
      id v20 = &v19;
      uint64_t v21 = 0x3032000000;
      int v22 = __Block_byref_object_copy__1;
      int v23 = __Block_byref_object_dispose__1;
      id v24 = 0;
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 3221225472;
      void v18[2] = ___PCSMigrationRecoverPPasswordFromStashedKey_block_invoke_546;
      v18[3] = &unk_1E5E6E700;
      void v18[4] = &v19;
      _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(v13, v9, v18);
      uint64_t v14 = v20[5];
      if (v14)
      {
        PCSMigrationLog([v3 log], @"Recovered p_password via stashed keychain wrappingKey by inner unwrap of record");
        CFTypeID v11 = (__CFString *)(id)v20[5];
      }
      _Block_object_dispose(&v19, 8);

      if (v14) {
        int v16 = 0;
      }
      else {
LABEL_11:
      }
        int v16 = 1;

      _Block_object_dispose(&v28, 8);
      if (v16) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = v11;
      }
    }
    else
    {
      uint64_t v15 = 0;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }

  return v15;
}

void sub_1ACFD0FE0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t fail_and_cfu_if_no_password(int a1, int a2, void *a3, const __CFDictionary *a4, uint64_t *a5)
{
  if (!_PCSMigrationStateIsGuitarfish(a3)
    || (!a1 || CFDictionaryContainsKey(a4, kPCSSetupPassword[0]))
    && (!a2 || CFDictionaryContainsKey(a4, kPCSSetupRawPassword[0])))
  {
    return 1;
  }
  id v16 = 0;
  BOOL v10 = +[PCSFollowupController postEDPStateRepair:&v16];
  id v11 = v16;
  CFDictionaryRef v12 = pcsLogObjForScope("cfu-repair");
  char v13 = v12;
  if (v10)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl(&dword_1ACF98000, v13, OS_LOG_TYPE_DEFAULT, "could not perform operation due to insufficient information, CFU posted successfully", v15, 2u);
    }
  }
  else if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    fail_and_cfu_if_no_password_cold_1();
  }

  if (a5)
  {
    id v14 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    [v14 setObject:@"could not perform operation due to insufficient information" forKeyedSubscript:*MEMORY[0x1E4F28568]];
    [v14 setObject:v11 forKeyedSubscript:*MEMORY[0x1E4F28A50]];
    *a5 = [MEMORY[0x1E4F28C58] errorWithDomain:kPCSErrorDomain code:228 userInfo:v14];
  }
  return 0;
}

BOOL checkData(uint64_t a1, CFDictionaryRef theDict, const __CFData *a3, const void **a4)
{
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, @"SecureBackupStingrayMetadata");
  if (!Value || (CFDictionaryRef v8 = Value, v9 = CFGetTypeID(Value), v9 != CFDictionaryGetTypeID()))
  {
    _PCSErrorContext(a1, a4, 126, @"Metadata missing");
    return 0;
  }
  BOOL v10 = CFDictionaryGetValue(v8, @"BackupKeybagSHA256");
  id v11 = v10;
  if (!v10 && (id v11 = CFDictionaryGetValue(v8, @"BackupKeybagDigest")) == 0
    || (CFTypeID v12 = CFGetTypeID(v11), v12 != CFDataGetTypeID()))
  {
    _PCSErrorContext(a1, a4, 126, @"KeybagSHA256/KeybagDigest missing");
    return 0;
  }
  CFDictionaryRef Mutable = CFDataCreateMutable(0, 0);
  id v14 = Mutable;
  if (!v10)
  {
    CFDataSetLength(Mutable, 20);
    if (v14)
    {
      ccsha1_di();
      goto LABEL_11;
    }
    goto LABEL_16;
  }
  CFDataSetLength(Mutable, 32);
  if (!v14)
  {
LABEL_16:
    _PCSErrorOOM(a4);
    return 0;
  }
  ccsha256_di();
LABEL_11:
  CFDataGetLength(a3);
  CFDataGetBytePtr(a3);
  CFDataGetMutableBytePtr(v14);
  ccdigest();
  int v15 = CFEqual(v14, v11);
  BOOL v16 = v15 != 0;
  if (!v15) {
    _PCSErrorContext(a1, a4, 129, @"Keybag hash mismatch");
  }
  CFRelease(v14);
  return v16;
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

void __PCSEngineExtractKeys_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v8 = a2;
  id v9 = a6;
  if (v8)
  {
    BOOL v10 = (void *)[*(id *)(a1 + 32) classicContent];
    uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8);
    obuint64_t j = *(id *)(v11 + 40);
    uint64_t v12 = _PCSGuitarfishUnwrapKeyWithAESKey(v8, v10, &obj);
    objc_storeStrong((id *)(v11 + 40), obj);
    uint64_t v13 = *(void *)(*(void *)(a1 + 48) + 8);
    id v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = v12;
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), a6);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

void __PCSEngineExtractKeys_block_invoke_587(uint64_t a1, uint64_t a2)
{
}

void __PCSEngineExtractKeys_block_invoke_592(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = (const void *)PCSIdentitySetCopyIdentity([*(id *)(a1 + 32) set], a2);
  if (v5)
  {
    CFRelease(v5);
  }
  else
  {
    PCSIdentitySetAddIdentity([*(id *)(a1 + 32) set], a3);
    CFArrayRef v6 = *(void **)(a1 + 32);
    [v6 setModified:1];
  }
}

void __PCSEngineExtractKeys_block_invoke_603(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = (const void *)PCSIdentitySetCopyIdentity([*(id *)(a1 + 32) set], a2);
  if (v5)
  {
    CFRelease(v5);
  }
  else
  {
    PCSIdentitySetAddIdentity([*(id *)(a1 + 32) set], a3);
    CFArrayRef v6 = *(void **)(a1 + 32);
    [v6 setModified:1];
  }
}

uint64_t apply_block_2_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void __PCSEngineSynchronizeWithLocalstore_block_invoke(uint64_t a1, const void *a2)
{
  id v4 = _PCSIdentitySetCopyCurrentIdentityInternal([*(id *)(a1 + 32) set], (uint64_t)a2, 0);
  if (v4)
  {
    CFRelease(v4);
  }
  else
  {
    BOOL v5 = *(__CFSet **)(a1 + 40);
    CFSetAddValue(v5, a2);
  }
}

void __PCSEngineSynchronizeWithLocalstore_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ServiceName = (const void *)PCSIdentityGetServiceName(a3);
  CFRange v7 = (const void *)PCSIdentitySetCopyIdentity([*(id *)(a1 + 32) set], a2);
  if (v7)
  {
    CFRelease(v7);
    return;
  }
  PCSMigrationLog([*(id *)(a1 + 32) log], @"adding local service to memory store: %@", a3);
  if (ServiceName && CFSetContainsValue(*(CFSetRef *)(a1 + 40), ServiceName))
  {
    int IsCurrentIdentity = _PCSIdentitySetIsCurrentIdentity(*(void *)(a1 + 48), a3);
    uint64_t v9 = [*(id *)(a1 + 32) set];
    if (IsCurrentIdentity)
    {
      PCSIdentitySetSetCurrentIdentity(v9, a3);
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v9 = [*(id *)(a1 + 32) set];
  }
  PCSIdentitySetAddIdentity(v9, a3);
LABEL_11:
  BOOL IsManatee = _PCSIdentityIsManatee(a3);
  uint64_t v11 = *(void **)(a1 + 32);
  if (IsManatee)
  {
    uint64_t v12 = [v11 log];
    PCSMigrationLog(v12, @"was a manatee identity, skipping update of metadata");
  }
  else
  {
    [v11 setModified:1];
  }
}

void __PCSEngineSynchronizeWithLocalstore_block_invoke_3(uint64_t a1, uint64_t a2)
{
  id v4 = _PCSIdentitySetCopyCurrentIdentityInternal(*(void *)(a1 + 40), a2, 0);
  if (v4)
  {
    BOOL v5 = v4;
    CFArrayRef v6 = _PCSIdentitySetCopyCurrentIdentityInternal([*(id *)(a1 + 32) set], a2, 0);
    if (v6)
    {
      CFRange v7 = v6;
      if (!CFEqual(v5, v6)) {
        PCSIdentitySetSetCurrentIdentity([*(id *)(a1 + 32) set], (uint64_t)v5);
      }
      CFRelease(v5);
    }
    else
    {
      PCSIdentitySetSetCurrentIdentity([*(id *)(a1 + 32) set], (uint64_t)v5);
      CFRange v7 = v5;
    }
    CFRelease(v7);
  }
}

void SynchronizeLocalKeyFile(void *a1, void *a2, void *a3, const void **a4)
{
  v40[1] = *(id *)MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  BOOL v10 = _PCSServiceItemsGetTooRolledServiceTypes();
  v37[0] = 0;
  v37[1] = v37;
  v37[2] = 0x3032000000;
  v37[3] = __Block_byref_object_copy__1;
  v37[4] = __Block_byref_object_dispose__1;
  id v38 = 0;
  id v11 = v7;
  id v12 = v8;
  id v13 = v9;
  CFDictionaryRef v14 = (const __CFDictionary *)[v11 options];
  CFDictionaryRef Value = (void *)CFDictionaryGetValue(v14, kPCSSetupDSID[0]);
  BOOL v16 = Value;
  if (!Value || (CFTypeID v17 = CFGetTypeID(Value), v17 != CFStringGetTypeID()))
  {
    _PCSErrorContext([v11 log], a4, 121, @"Missing parameter: dsid");
    goto LABEL_13;
  }
  BOOL v18 = PCSCurrentPersonaMatchesDSID(v16);
  if (a4) {
    char v19 = v18;
  }
  else {
    char v19 = 1;
  }
  if ((v19 & 1) == 0)
  {
    id v24 = (void *)MEMORY[0x1E4F28C58];
    BOOL v25 = kPCSErrorDomain;
    uint64_t v39 = *MEMORY[0x1E4F28568];
    v40[0] = @"Current persona does not match chosen dsid";
    CFErrorRef v26 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v40 forKeys:&v39 count:1];
    *a4 = [v24 errorWithDomain:v25 code:152 userInfo:v26];

LABEL_13:
    CFDataRef v21 = 0;
    id v20 = 0;
LABEL_14:
    id v22 = 0;
LABEL_15:
    int v23 = 0;
    goto LABEL_16;
  }
  if (kPCSSetupDSIDAny[0] && CFEqual(v16, kPCSSetupDSIDAny[0])) {
    goto LABEL_13;
  }
  id v20 = LocalStorageCreatePath((uint64_t)v16, v12, v13);
  if (!v20)
  {
    CFDataRef v21 = 0;
    goto LABEL_14;
  }
  v40[0] = 0;
  CFDataRef v21 = [MEMORY[0x1E4F1C9B8] dataWithContentsOfFile:v20 options:0 error:v40];
  id v22 = v40[0];
  if (v21)
  {
    int v23 = PCSIdentitySetCreateFromExternalForm(0, v21, 0, a4);
    goto LABEL_16;
  }
  PCSMigrationLog([v11 log], @"Failed reading local backup: %@: %@", v12, v22);
  if (!a4)
  {
    CFDataRef v21 = 0;
    goto LABEL_15;
  }
  long long v32 = *a4;
  if (*a4)
  {
    *a4 = 0;
    CFRelease(v32);
  }
  id v22 = v22;
  CFDataRef v21 = 0;
  int v23 = 0;
  *a4 = v22;
LABEL_16:

  if (v23)
  {
    CFDictionaryRef v27 = (const __CFDictionary *)PCSIdentitySetCopyIdentities((uint64_t)v23, 0);
    if (v27)
    {
      context[0] = MEMORY[0x1E4F143A8];
      context[1] = 3221225472;
      context[2] = __SynchronizeLocalKeyFile_block_invoke;
      context[3] = &unk_1E5E6E7F0;
      id v34 = v11;
      id v35 = v10;
      BOOL v36 = v37;
      CFDictionaryApplyFunction(v27, (CFDictionaryApplierFunction)apply_block_2_3, context);
      CFRelease(v23);
      CFRelease(v27);
      if (a4)
      {
        uint64_t v28 = *a4;
        if (*a4)
        {
          *a4 = 0;
          CFRelease(v28);
        }
      }
    }
    else
    {
      CFRelease(v23);
    }
  }
  else
  {
    uint64_t v29 = [v11 log];
    if (a4) {
      uint64_t v30 = *a4;
    }
    else {
      uint64_t v30 = 0;
    }
    PCSMigrationLog(v29, @" open local storage failed: %@", v30);
    if (a4)
    {
      id v31 = *a4;
      if (*a4)
      {
        *a4 = 0;
        CFRelease(v31);
      }
    }
  }
  _Block_object_dispose(v37, 8);
}

void sub_1ACFD1DCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __SynchronizeLocalKeyFile_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ServiceName = PCSIdentityGetServiceName(a3);
  id v7 = (const void *)PCSIdentitySetCopyIdentity([*(id *)(a1 + 32) set], a2);
  if (v7)
  {
    CFRelease(v7);
    return;
  }
  if (_PCSIdentityIsManatee(a3) && (PCSIdentityIsNewManatee(a3) & 1) == 0)
  {
    PCSMigrationLog([*(id *)(a1 + 32) log], @"Skip recovering old manatee identity (%@) from keyfile", a3);
    return;
  }
  if (ServiceName && [*(id *)(a1 + 40) containsObject:ServiceName])
  {
    PCSMigrationLog([*(id *)(a1 + 32) log], @"Skip tooRolled identity (%@) from keyfile", a3);
    return;
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
  {
    if (ServiceName)
    {
LABEL_12:
      id v8 = _PCSIdentitySetCopyCurrentIdentityInternal([*(id *)(a1 + 32) set], ServiceName, 0);
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v9 = [MEMORY[0x1E4F28E78] string];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    if (ServiceName) {
      goto LABEL_12;
    }
  }
  id v8 = 0;
LABEL_16:
  PCSIdentitySetAddIdentity([*(id *)(a1 + 32) set], a3);
  if (ServiceName && !v8) {
    PCSIdentitySetSetCurrentIdentity([*(id *)(a1 + 32) set], a3);
  }
  [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) appendFormat:@"Identity %@ of service %@ existed in backup (but not in local storage)\n", PCSIdentityGetPublicKey(a3), ServiceName];
  if (v8) {
    CFRelease(v8);
  }
  id v12 = *(void **)(a1 + 32);
  [v12 setModified:1];
}

void __PCSEngineStepValidateRegistry_block_invoke(uint64_t a1, void *a2)
{
  if ((PCSServiceItemTypeIsManatee(a2) & 1) != 0 || [*(id *)(a1 + 32) containsObject:a2])
  {
    PCSMigrationLog([*(id *)(a1 + 40) log], @"Registry contains Manatee service: %@", a2);
    if (*(unsigned char *)(a1 + 48))
    {
      if (![*(id *)(a1 + 40) removeFromRegistry]) {
        objc_msgSend(*(id *)(a1 + 40), "setRemoveFromRegistry:", CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]));
      }
      CFArrayAppendValue((CFMutableArrayRef)[*(id *)(a1 + 40) removeFromRegistry], a2);
      id v4 = *(void **)(a1 + 40);
      [v4 setModified:1];
    }
  }
}

void __PCSEngineStepValidateRegistry_block_invoke_2(uint64_t a1, void *a2)
{
  if (PCSServiceItemTypeIsManatee(a2) & 1) != 0 || ([*(id *)(a1 + 32) containsObject:a2]) {
    return;
  }
  id v4 = _PCSIdentitySetCopyCurrentIdentityInternal([*(id *)(a1 + 40) set], (uint64_t)a2, 0);
  if (!v4 || (BOOL v5 = v4, v6 = PCSIdentityCheckValidPublicKey((uint64_t)v4, 0), CFRelease(v5), v6))
  {
    CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
    CFArrayRef v8 = (const __CFArray *)PCSIdentitySetCopyOrderedIdentities([*(id *)(a1 + 40) set], (uint64_t)a2);
    if (!v8) {
      goto LABEL_29;
    }
    CFArrayRef v9 = v8;
    context[0] = MEMORY[0x1E4F143A8];
    context[1] = 3221225472;
    context[2] = __PCSEngineStepValidateRegistry_block_invoke_3;
    context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    void context[4] = Mutable;
    v28.CFIndex length = CFArrayGetCount(v8);
    v28.CFIndex location = 0;
    CFArrayApplyFunction(v9, v28, (CFArrayApplierFunction)apply_block_1_2, context);
    CFRelease(v9);
    if (![*(id *)(a1 + 40) oldRegistry]) {
      goto LABEL_29;
    }
    CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)[*(id *)(a1 + 40) oldRegistry], a2);
    if (PCSEngineIgnoreService(a2))
    {
      if (Value) {
        [*(id *)(a1 + 40) setModified:1];
      }
      goto LABEL_10;
    }
    if (!Value
      || (CFTypeID v11 = CFGetTypeID(Value), v11 != CFDictionaryGetTypeID())
      || (id v12 = CFDictionaryGetValue((CFDictionaryRef)Value, kPCSSecureBackupCFKeyRegistryPublicIdentities[0]),
          !isArray(v12))
      || (CFIndex Count = CFArrayGetCount((CFArrayRef)v12)) == 0)
    {
LABEL_29:
      BOOL v23 = 1;
      goto LABEL_30;
    }
    CFIndex v14 = Count;
    if (Count < 1)
    {
      if (!CFSetGetCount(Mutable))
      {
LABEL_10:
        if (Mutable) {
          CFRelease(Mutable);
        }
        return;
      }
      BOOL v23 = 0;
    }
    else
    {
      char v26 = 0;
      uint64_t v15 = 1;
      while (1)
      {
        CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)v12, v15 - 1);
        if (!ValueAtIndex) {
          break;
        }
        CFDataRef v17 = ValueAtIndex;
        CFTypeID v18 = CFGetTypeID(ValueAtIndex);
        if (v18 != CFDataGetTypeID()) {
          break;
        }
        char v19 = PCSPublicIdentityCreateWithPublicKeyInfo(v17, 0);
        if (!v19)
        {
          PCSMigrationLog([*(id *)(a1 + 40) log], @"Failed to parse identity: %@", v17);
          break;
        }
        id v20 = v19;
        uint64_t ServiceName = (const void *)PCSPublicIdentityGetServiceName((uint64_t)v19);
        id v22 = ServiceName;
        BOOL v23 = ServiceName == 0;
        if (ServiceName)
        {
          if (CFEqual(ServiceName, a2))
          {
            uint64_t PublicID = PCSPublicIdentityGetPublicID((uint64_t)v20);
            if (PublicID)
            {
              BOOL v25 = (const void *)PublicID;
              PCSMigrationLog([*(id *)(a1 + 40) log], @"Found identity %@ in registry for %@", PublicID, a2);
              CFSetRemoveValue(Mutable, v25);
            }
          }
          else
          {
            PCSMigrationLog([*(id *)(a1 + 40) log], @"Need regen of registry since %@ have the service %@ (%@) in it", a2, v20, v22);
            char v26 = 1;
          }
        }
        CFRelease(v20);
        if (v15 < v14)
        {
          ++v15;
          if (v22) {
            continue;
          }
        }
        goto LABEL_42;
      }
      BOOL v23 = 1;
LABEL_42:
      if (!CFSetGetCount(Mutable))
      {
        if ((v26 & 1) == 0)
        {
LABEL_30:
          if (Mutable)
          {
            CFRelease(Mutable);
            if (!v23) {
              return;
            }
          }
          else if (!v23)
          {
            return;
          }
          goto LABEL_34;
        }
LABEL_44:
        PCSMigrationLog([*(id *)(a1 + 40) log], @"Triggering update for metadata");
        [*(id *)(a1 + 40) setModified:1];
        goto LABEL_30;
      }
    }
    PCSMigrationLog([*(id *)(a1 + 40) log], @"Identities not in registry, updating needed: %@", a2);
    goto LABEL_44;
  }
LABEL_34:
  if (![*(id *)(a1 + 40) missingFromRegistry]) {
    objc_msgSend(*(id *)(a1 + 40), "setMissingFromRegistry:", CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]));
  }
  CFArrayAppendValue((CFMutableArrayRef)[*(id *)(a1 + 40) missingFromRegistry], a2);
  [*(id *)(a1 + 40) setModified:1];
}

void __PCSEngineStepValidateRegistry_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(__CFSet **)(a1 + 32);
  int PublicKey = (const void *)PCSIdentityGetPublicKey(a2);
  CFSetAddValue(v2, PublicKey);
}

BOOL PCSEngineIgnoreService(const void *a1)
{
  return CFEqual(a1, kPCSServiceFDE) || CFEqual(a1, kPCSServiceEscrow) != 0;
}

void __PCSEngineStepValidateLooseLeaves_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDataGetTypeID())
    {
      CFTypeRef v5 = PCSBackupCopyRecoveredKeyWithIdentitySet([*(id *)(a1 + 32) set], *(void *)(a1 + 40), (CFDataRef)cf, 0);
      if (v5)
      {
        int v6 = v5;
        int PublicKey = (const void *)PCSIdentityGetPublicKey((uint64_t)v5);
        CFArrayRef v8 = (const void *)PCSIdentitySetCopyIdentity([*(id *)(a1 + 32) set], (uint64_t)PublicKey);
        if (v8)
        {
          CFRelease(v8);
        }
        else
        {
          PCSMigrationLog([*(id *)(a1 + 32) log], @"Identity %@ not found locally, adding it from LooseLeaves", v6);
          PCSIdentitySetAddIdentity([*(id *)(a1 + 32) set], (uint64_t)v6);
          [*(id *)(a1 + 32) setModified:1];
        }
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), PublicKey, v6);
        CFRelease(v6);
      }
      else
      {
        PCSMigrationLog([*(id *)(a1 + 32) log], @"Service %@ have an un-decrypted item", *(void *)(a1 + 48));
      }
    }
  }
}

uint64_t __PCSEngineStepValidateLooseLeaves_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int PublicKey = (const void *)PCSIdentityGetPublicKey(a2);
  uint64_t result = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), PublicKey);
  if (!result)
  {
    uint64_t result = _PCSIdentityIsManatee(a2);
    if ((result & 1) == 0)
    {
      AddLeaf(*(__CFArray **)(a1 + 48), [*(id *)(a1 + 32) escrowIdentity], a2);
      PCSMigrationLog([*(id *)(a1 + 32) log], @"Local identity %@ missing in LooseLeaves, adding it", a2);
      int v6 = *(void **)(a1 + 32);
      return [v6 setModified:1];
    }
  }
  return result;
}

void AddLeaf(__CFArray *a1, uint64_t a2, uint64_t a3)
{
  EscrowedKeyWithIdentity = PCSBackupCreateEscrowedKeyWithIdentity(a2, a3, 0);
  if (EscrowedKeyWithIdentity)
  {
    CFTypeRef v5 = EscrowedKeyWithIdentity;
    CFArrayAppendValue(a1, EscrowedKeyWithIdentity);
    CFRelease(v5);
  }
}

uint64_t __PCSEngineStepValidateLooseLeaves_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = _PCSIdentityIsManatee(a3);
  if ((result & 1) == 0)
  {
    AddLeaf(*(__CFArray **)(a1 + 40), [*(id *)(a1 + 32) escrowIdentity], a3);
    PCSMigrationLog([*(id *)(a1 + 32) log], @"Re-adding preexisting LooseLeaves identity %@", a3);
    int v6 = *(void **)(a1 + 32);
    return [v6 setModified:1];
  }
  return result;
}

void __PCSEngineStoreHSM_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  id v7 = a3;
  CFArrayRef v8 = v7;
  if (!v6 || v7)
  {
    CFArrayRef v9 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 138412290;
      CFIndex v14 = v8;
      uint64_t v10 = "unable to recover wrapping key from keychain: %@";
      CFTypeID v11 = v9;
      uint32_t v12 = 12;
      goto LABEL_7;
    }
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    CFArrayRef v9 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      uint64_t v10 = "recovered wrapping key from keychain";
      CFTypeID v11 = v9;
      uint32_t v12 = 2;
LABEL_7:
      _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v13, v12);
    }
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSEngineStoreHSM_block_invoke_739(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a4);
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a5);
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a3);
  if (v14)
  {
    uint64_t v15 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      ___PCSMigrationRecoverPPasswordFromStashedKey_block_invoke_546_cold_1();
    }

    if (*(void *)(a1 + 56)) {
      **(void **)(a1 + 56) = v14;
    }
  }
}

void __PCSEngineStoreHSM_block_invoke_746(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v9 = a4;
  if (v9 && *(void *)(a1 + 40)) {
    **(void **)(a1 + 40) = v9;
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  CFArrayRef v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;
}

void _PCSIdentityGuitarfishOptionsToMetadata(void *a1, __CFDictionary *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (_PCSMigrationStateIsGuitarfish(v3))
  {
    CFTypeID v4 = __PCSIdentityOptionsToMetaMapping();
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    CFTypeRef v5 = objc_msgSend(v4, "allKeys", 0);
    uint64_t v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)v14;
      do
      {
        for (uint64_t i = 0; i != v7; ++i)
        {
          if (*(void *)v14 != v8) {
            objc_enumerationMutation(v5);
          }
          uint64_t v10 = *(const void **)(*((void *)&v13 + 1) + 8 * i);
          id v11 = [v4 objectForKeyedSubscript:v10];
          if (CFDictionaryContainsKey((CFDictionaryRef)[v3 options], v10))
          {
            CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)[v3 options], v10);
            CFDictionarySetValue(a2, v11, Value);
          }
        }
        uint64_t v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
      }
      while (v7);
    }
  }
}

void applyOptions(void *a1, __CFDictionary *a2)
{
  id v3 = a1;
  CFDictionaryRef v4 = (const __CFDictionary *)[v3 options];
  CFTypeRef v5 = CFDictionaryGetValue(v4, kPCSSetupUsername[0]);
  CFDictionaryRef v6 = (const __CFDictionary *)[v3 options];
  uint64_t v7 = CFDictionaryGetValue(v6, kPCSSetupPassword[0]);
  CFDictionaryRef v8 = (const __CFDictionary *)[v3 options];
  id v9 = CFDictionaryGetValue(v8, kPCSSetupGuitarfish[0]);
  CFDictionaryRef v10 = (const __CFDictionary *)[v3 options];
  id v11 = CFDictionaryGetValue(v10, kPCSSetupRawPassword[0]);
  CFDictionaryRef v12 = (const __CFDictionary *)[v3 options];
  long long v13 = CFDictionaryGetValue(v12, kPCSSetupVerifierProtocol[0]);
  CFDictionaryRef v14 = (const __CFDictionary *)[v3 options];
  long long v15 = CFDictionaryGetValue(v14, kPCSSetupVerifierSalt[0]);
  CFDictionaryRef v16 = (const __CFDictionary *)[v3 options];
  CFDataRef v17 = CFDictionaryGetValue(v16, kPCSSetupVerifierIterationCount[0]);
  CFDictionaryRef v18 = (const __CFDictionary *)[v3 options];
  value = (void *)CFDictionaryGetValue(v18, kPCSSetupAuthToken[0]);
  CFDictionaryRef v19 = (const __CFDictionary *)[v3 options];
  id v24 = (void *)CFDictionaryGetValue(v19, kPCSSetupEscrowURL[0]);
  CFDictionaryRef v20 = (const __CFDictionary *)[v3 options];
  char v26 = (void *)CFDictionaryGetValue(v20, kPCSSetupiCloudEnvironment[0]);
  CFDictionaryRef v21 = (const __CFDictionary *)[v3 options];

  id v22 = (void *)CFDictionaryGetValue(v21, kPCSSetupDSID[0]);
  if (v5) {
    CFDictionarySetValue(a2, kPCSSecureBackupCFAuthenticationAppleID[0], v5);
  }
  if (v7) {
    CFDictionarySetValue(a2, kPCSSecureBackupCFAuthenticationPassword[0], v7);
  }
  if (v9) {
    CFDictionarySetValue(a2, kPCSSecureBackupCFGuitarfishKey[0], v9);
  }
  if (v11) {
    CFDictionarySetValue(a2, kPCSSecureBackupCFAuthenticationRawPassword[0], v11);
  }
  if (v13 || v15 || v17)
  {
    if (v13 && v15 && v17)
    {
      BOOL v23 = objc_msgSend(objc_alloc(MEMORY[0x1E4F59AE8]), "initWithProto:salt:iterations:", v13, v15, objc_msgSend(v17, "intValue"));
      CFDictionarySetValue(a2, (const void *)*MEMORY[0x1E4F59B30], v23);
    }
    else
    {
      BOOL v23 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        applyOptions_cold_1();
      }
    }
  }
  if (value) {
    CFDictionarySetValue(a2, kPCSSecureBackupCFAuthenticationAuthToken[0], value);
  }
  if (v24) {
    CFDictionarySetValue(a2, kPCSSecureBackupCFAuthenticationEscrowProxyURL[0], v24);
  }
  if (v22)
  {
    if (!PCSCurrentPersonaMatchesDSID(v22)) {
      goto LABEL_28;
    }
    CFDictionarySetValue(a2, kPCSSecureBackupCFAuthenticationDSID[0], v22);
  }
  if (v26) {
    CFDictionarySetValue(a2, kPCSSecureBackupCFAuthenticationiCloudEnvironment[0], v26);
  }
LABEL_28:
}

intptr_t __PCSEngineStoreHSM_block_invoke_754(uint64_t a1, const void *a2)
{
  if (a2)
  {
    PCSMigrationLog([*(id *)(a1 + 32) log], @"_PCSSecureBackupEnableWithInfo: %@", a2);
    CFDictionaryRef v4 = *(void **)(a1 + 56);
    if (v4)
    {
      *CFDictionaryRef v4 = a2;
      CFRetain(a2);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
  CFTypeRef v5 = *(NSObject **)(a1 + 40);
  return dispatch_semaphore_signal(v5);
}

intptr_t __PCSEngineStoreHSM_block_invoke_2(uint64_t a1, const void *a2)
{
  uint64_t v4 = [*(id *)(a1 + 32) log];
  uint64_t v5 = [*(id *)(a1 + 32) newHSMContent];
  CFDictionaryRef v6 = "Enable";
  if (!v5) {
    CFDictionaryRef v6 = "UpdateMetadata";
  }
  PCSMigrationLog(v4, @"_PCSSecureBackup%sWithInfo: %@", v6, a2);
  if (a2)
  {
    if (*(void *)(a1 + 56)) {
      **(void **)(a1 + 56) = CFRetain(a2);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
  uint64_t v7 = *(NSObject **)(a1 + 40);
  return dispatch_semaphore_signal(v7);
}

void __PCSEngineStoreHSM_block_invoke_3(uint64_t a1, void *a2, void *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  id v7 = a3;
  CFDictionaryRef v8 = v7;
  if (!v6 || v7)
  {
    id v9 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 138412290;
      CFDictionaryRef v14 = v8;
      CFDictionaryRef v10 = "unable to recover wrapping key from keychain: %@";
      id v11 = v9;
      uint32_t v12 = 12;
      goto LABEL_7;
    }
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    id v9 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      CFDictionaryRef v10 = "recovered wrapping key from keychain of length";
      id v11 = v9;
      uint32_t v12 = 2;
LABEL_7:
      _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v13, v12);
    }
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSEngineStoreHSM_block_invoke_790(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, void *a6)
{
  id v10 = a3;
  id v11 = a5;
  id v12 = a6;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a5);
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  if (v12)
  {
    int v13 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      ___PCSMigrationRecoverPPasswordFromStashedKey_block_invoke_546_cold_1();
    }

    if (*(void *)(a1 + 48)) {
      **(void **)(a1 + 4_Block_object_dispose(&a9, 8) = v12;
    }
  }
}

uint64_t __GetDroppedServiceArray_block_invoke()
{
  v1[1] = *MEMORY[0x1E4F143B8];
  v1[0] = kPCSServiceFDE;
  uint64_t result = [MEMORY[0x1E4F1C978] arrayWithObjects:v1 count:1];
  GetDroppedServiceArray_array = result;
  return result;
}

void __CreateKeyRegistry_block_invoke(uint64_t a1, const void *a2)
{
  PCSMigrationLog([*(id *)(a1 + 32) log], @"  Removing Manatee service from registry: %@", a2);
  uint64_t v4 = *(__CFDictionary **)(a1 + 40);
  CFDictionaryRemoveValue(v4, a2);
}

void __CreateKeyRegistry_block_invoke_2(uint64_t a1, void *a2)
{
  CFDictionaryRef v16 = 0;
  if (PCSEngineIgnoreService(a2))
  {
    uint64_t v4 = *(__CFDictionary **)(a1 + 48);
    CFDictionaryRemoveValue(v4, a2);
  }
  else if ((PCSServiceItemTypeIsManatee(a2) & 1) == 0 {
         && ([*(id *)(a1 + 32) containsObject:a2] & 1) == 0)
  }
  {
    CFDictionaryRef v5 = PCSIdentitySetCopyPublishableIdentities([*(id *)(a1 + 40) set], (CFDictionaryRef)a2, &v16);
    if (v5)
    {
      PCSMigrationLog([*(id *)(a1 + 40) log], @"  Updating service %@ registry", a2);
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v5, kPCSSecureBackupCFKeyRegistryPublicIdentities[0]);
      if (Value)
      {
        CFArrayRef v7 = Value;
        CFTypeID v8 = CFGetTypeID(Value);
        if (v8 == CFArrayGetTypeID())
        {
          v14[0] = 0;
          v14[1] = v14;
          void v14[2] = 0x2020000000;
          int v15 = 0;
          v11[0] = MEMORY[0x1E4F143A8];
          v11[1] = 3221225472;
          v11[2] = __CreateKeyRegistry_block_invoke_3;
          _OWORD v11[3] = &unk_1E5E6E980;
          id v12 = *(id *)(a1 + 40);
          int v13 = v14;
          id v9 = v11;
          v18.CFIndex length = CFArrayGetCount(v7);
          v18.CFIndex location = 0;
          CFArrayApplyFunction(v7, v18, (CFArrayApplierFunction)apply_block_1_2, v9);

          _Block_object_dispose(v14, 8);
        }
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), a2, v5);
    }
    id v10 = v16;
    if (v16)
    {
      CFDictionaryRef v16 = 0;
      CFRelease(v10);
    }
    if (v5) {
      CFRelease(v5);
    }
  }
}

void sub_1ACFD3508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CreateKeyRegistry_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = [*(id *)(a1 + 32) log];
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v6 = *(unsigned int *)(v5 + 24);
  *(_DWORD *)(v5 + 24) = v6 + 1;
  PCSMigrationLog(v4, @"     %d: %@", v6, a2);
}

void __PCSEngineStoreRTHSM_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  if (v7 && *(void *)(a1 + 40))
  {
    CFTypeID v8 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      __PCSEngineStoreRTHSM_block_invoke_cold_1();
    }

    **(void **)(a1 + 40) = v7;
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
}

intptr_t __PCSEngineStoreRTHSM_block_invoke_817(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a2)
  {
    +[PCSAnalyticsReporterRTC sendMetricWithEvent:v3 success:0 error:a2];
    PCSMigrationLog([*(id *)(a1 + 40) log], @"_PCSSecureBackupEnableWithInfo (Guitarfish recovery token): %@", a2);
  }
  else
  {
    +[PCSAnalyticsReporterRTC sendMetricWithEvent:v3 success:1 error:0];
  }
  uint64_t v5 = *(NSObject **)(a1 + 48);
  return dispatch_semaphore_signal(v5);
}

void __PCSEngineStoreLocal_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t PublicKey = PCSIdentityGetPublicKey(a2);
  if (![*(id *)(a1 + 32) limitLocalStoring]
    || (uint64_t ServiceName = (const void *)PCSIdentityGetServiceName(a2)) != 0
    && IsLocalStoringService(*(void **)(a1 + 32), ServiceName))
  {
    BOOL IsManatee = _PCSIdentityIsManatee(a2);
    id v7 = (const void *)PCSIdentitySetCopyIdentity(*(void *)(a1 + 40), PublicKey);
    if (v7)
    {
      CFRelease(v7);
      if (IsManatee) {
        return;
      }
    }
    else
    {
      PCSMigrationLog([*(id *)(a1 + 32) log], @"adding service to localStore: %@", a2);
      PCSIdentitySetAddIdentity(*(void *)(a1 + 40), a2);
      [*(id *)(a1 + 32) setModified:1];
      if (IsManatee) {
        return;
      }
    }
    if (_PCSIdentitySetIsCurrentIdentity([*(id *)(a1 + 32) set], a2)
      && (_PCSIdentitySetIsCurrentIdentity(*(void *)(a1 + 40), a2) & 1) == 0)
    {
      PCSMigrationLog([*(id *)(a1 + 32) log], @"marking identity current: %@", a2);
      PCSIdentitySetSetCurrentIdentity(*(void *)(a1 + 40), a2);
      CFTypeID v8 = *(void **)(a1 + 32);
      [v8 setModified:1];
    }
  }
}

BOOL StoreLocalKeyfile(void *a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6, const void **a7)
{
  id v13 = a3;
  id v14 = a4;
  CFArrayRef v15 = a5;
  uint64_t ExternalForm = (void *)PCSIdentitySetCreateExternalForm(0, [a1 set], 0, v15, a7);

  if (ExternalForm)
  {
    CFDataRef v17 = [MEMORY[0x1E4F28CB8] defaultManager];
    [v17 createDirectoryAtPath:v13 withIntermediateDirectories:1 attributes:0 error:0];

    CFRange v18 = LocalStorageCreatePath(a2, v13, v14);
    BOOL v19 = v18 != 0;
    if (v18) {
      [ExternalForm writeToFile:v18 options:a6 error:0];
    }
  }
  else
  {
    BOOL v19 = 0;
  }

  return v19;
}

uint64_t _PCSEngineStoreiCDPStatus(void *a1, char a2, const void **a3)
{
  id v5 = a1;
  CFTypeRef cf = 0;
  CFTypeRef v29 = 0;
  CFTypeRef v6 = PCSIdentitySetCreate((const __CFDictionary *)[v5 options], 0, a3);
  if (!v6)
  {
    uint64_t v13 = 0;
    goto LABEL_28;
  }
  id v7 = v6;
  int v8 = [v5 iCDPArmed];
  if (v8 != PCSIdentitySetIsICDP((uint64_t)v7, 0))
  {
    PCSMigrationLog([v5 log], @"Updating iCDP");
    if (!PCSIdentitySetEnableICDP((uint64_t)v7, [v5 iCDPArmed], a3)) {
      goto LABEL_10;
    }
  }
  int v9 = PCSIdentitySetIsWalrusWithForceFetch((uint64_t)v7, 1, &cf);
  CFTypeRef v10 = cf;
  if (cf)
  {
    if ((a2 & 1) != 0
      || ((CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)cf),
           CFIndex Code = CFErrorGetCode((CFErrorRef)cf),
           !CFEqual(Domain, kPCSErrorDomain))
       || Code != 90)
      && (!CFEqual(Domain, (CFTypeRef)*MEMORY[0x1E4F3B468]) || Code != 29))
    {
      if (a3) {
        *a3 = CFRetain(cf);
      }
      uint64_t v11 = [v5 log];
      PCSMigrationLog(v11, @"Failed getting Walrus state: %@", cf);
      CFTypeRef v12 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v12);
      }
      goto LABEL_10;
    }
    uint64_t v16 = [v5 log];
    PCSMigrationLog(v16, @"Will not update W: %@", cf);
    CFTypeRef v17 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v17);
    }
  }
  else if (v9 != [v5 iCDPHSMWalrus])
  {
    PCSMigrationLog([v5 log], @"Updating Walrus");
    if (!PCSIdentitySetSetWalrus((uint64_t)v7, [v5 iCDPHSMWalrus], a3)) {
      goto LABEL_10;
    }
  }
  int v18 = [v5 iCDPPlesio];
  if (v18 == PCSIdentitySetIsPlesio((uint64_t)v7, 0)
    || (PCSMigrationLog([v5 log], @"Updating Plesio"),
        PCSIdentitySetSetPlesio((uint64_t)v7, [v5 iCDPPlesio], a3)))
  {
    unsigned int IsICDP = PCSIdentitySetIsICDP((uint64_t)v7, &v29);
    if (!v29)
    {
      unsigned int v20 = IsICDP;
      if (v10)
      {
        unsigned int v21 = 0;
      }
      else
      {
        unsigned int v21 = PCSIdentitySetIsWalrusWithForceFetch((uint64_t)v7, 0, &cf);
        if (cf)
        {
          uint64_t v25 = [v5 log];
          PCSMigrationLog(v25, @"Failed getting Walrus state after set: %@", cf);
          CFTypeRef v26 = cf;
          if (cf)
          {
            CFTypeRef cf = 0;
            CFRelease(v26);
          }
        }
      }
      unsigned int IsPlesio = PCSIdentitySetIsPlesio((uint64_t)v7, a3);
      PCSMigrationLog([v5 log], @"Just stored status: %d (iCDPArmed), checked afterward, it was: %d", objc_msgSend(v5, "iCDPArmed"), v20);
      PCSMigrationLog([v5 log], @"Just stored status: %d (Walrus), checked afterward, it was: %d", objc_msgSend(v5, "iCDPHSMWalrus"), v21);
      PCSMigrationLog([v5 log], @"Just stored status: %d (Plesio), checked afterward, it was: %d", objc_msgSend(v5, "iCDPPlesio"), IsPlesio);
      uint64_t v13 = 1;
      goto LABEL_26;
    }
    uint64_t v27 = [v5 log];
    PCSMigrationLog(v27, @"Failed getting iCDPState: %@", v29);
  }
LABEL_10:
  uint64_t v13 = 0;
LABEL_26:
  CFRelease(v7);
  CFTypeRef v23 = v29;
  if (v29)
  {
    CFTypeRef v29 = 0;
    CFRelease(v23);
  }
LABEL_28:

  return v13;
}

void __PCSEngineAddMissingCurrentPointers_block_invoke(uint64_t a1, void *a2)
{
  v53[9] = *MEMORY[0x1E4F143B8];
  if ((PCSServiceItemTypeIsManatee(a2) & 1) == 0)
  {
    dispatch_semaphore_t v4 = dispatch_semaphore_create(0);
    uint64_t v44 = 0;
    uint64_t v45 = &v44;
    uint64_t v46 = 0x2020000000;
    char v47 = 0;
    uint64_t v40 = 0;
    char v41 = &v40;
    uint64_t v42 = 0x2020000000;
    uint64_t v43 = 0;
    if (PCSServiceItemGetCKKSViewByName(a2))
    {
      PCSServiceItemGetAccessGroupByName(a2);
      cf[1] = (CFTypeRef)MEMORY[0x1E4F143A8];
      cf[2] = (CFTypeRef)3221225472;
      cf[3] = __PCSEngineAddMissingCurrentPointers_block_invoke_862;
      cf[4] = &unk_1E5E6EA20;
      BOOL v36 = &v44;
      char v37 = &v40;
      uint64_t v5 = *(void *)(a1 + 40);
      id v38 = a2;
      uint64_t v39 = v5;
      CFTypeRef v6 = v4;
      id v35 = v6;
      SecItemFetchCurrentItemAcrossAllDevices();
      dispatch_semaphore_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
      if (*((unsigned char *)v45 + 24))
      {
        id v7 = pcsLogObjForScope("ckks");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v49 = a2;
          _os_log_impl(&dword_1ACF98000, v7, OS_LOG_TYPE_DEFAULT, "Found current item pointer for service %@", buf, 0xCu);
        }

        if (v41[3])
        {
          uint64_t v8 = [*(id *)(a1 + 32) set];
          if ((_PCSIdentitySetIsCurrentIdentity(v8, v41[3]) & 1) == 0)
          {
            int v9 = pcsLogObjForScope("ckks");
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              CFTypeRef v49 = a2;
              _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "Current item for %@ does not have current bit set, attempting to fix", buf, 0xCu);
            }

            cf[0] = 0;
            uint64_t v10 = [*(id *)(a1 + 32) set];
            if ((PCSIdentitySetSetCurrentIdentityWithError(v10, v41[3], cf) & 1) == 0)
            {
              uint64_t v11 = pcsLogObjForScope("ckks");
              if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138412290;
                CFTypeRef v49 = cf[0];
                _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, "Failed to set current bit: %@", buf, 0xCu);
              }
            }
            CFTypeRef v12 = cf[0];
            if (cf[0])
            {
              cf[0] = 0;
              CFRelease(v12);
            }
          }
        }
        uint64_t v13 = (const void *)v41[3];
        if (v13)
        {
          void v41[3] = 0;
          CFRelease(v13);
        }
      }
      else
      {
        unsigned int IndexByName = PCSServiceItemGetIndexByName(a2);
        if (IndexByName)
        {
          uint64_t v16 = *MEMORY[0x1E4F3B978];
          v53[0] = *MEMORY[0x1E4F3B998];
          uint64_t v17 = *MEMORY[0x1E4F3B8C0];
          v52[0] = v16;
          v52[1] = v17;
          int v18 = [NSNumber numberWithUnsignedInt:IndexByName | 0x10000];
          uint64_t v19 = *MEMORY[0x1E4F3BC68];
          v53[1] = v18;
          v53[2] = MEMORY[0x1E4F1CC38];
          uint64_t v20 = *MEMORY[0x1E4F3BC70];
          v52[2] = v19;
          v52[3] = v20;
          uint64_t v21 = *MEMORY[0x1E4F3BC78];
          v53[3] = MEMORY[0x1E4F1CC38];
          v53[4] = MEMORY[0x1E4F1CC38];
          uint64_t v22 = *MEMORY[0x1E4F3B878];
          v52[4] = v21;
          v52[5] = v22;
          uint64_t v23 = *MEMORY[0x1E4F3B838];
          v53[5] = MEMORY[0x1E4F1CC38];
          v53[6] = kPCSServiceName[0];
          uint64_t v24 = *MEMORY[0x1E4F3B848];
          v52[6] = v23;
          v52[7] = v24;
          v53[7] = *(void *)(a1 + 40);
          v52[8] = *MEMORY[0x1E4F3B870];
          v53[8] = PCSServiceItemGetViewHintByName(a2);
          CFDictionaryRef v25 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v53 forKeys:v52 count:9];

          cf[0] = 0;
          OSStatus v26 = SecItemCopyMatching(v25, cf);
          if (v26)
          {
            uint64_t v27 = pcsLogObjForScope("ckks");
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412546;
              CFTypeRef v49 = a2;
              __int16 v50 = 1024;
              OSStatus v51 = v26;
              _os_log_impl(&dword_1ACF98000, v27, OS_LOG_TYPE_DEFAULT, "Failed to get current in local keychain for service %@: %d", buf, 0x12u);
            }
          }
          else
          {
            CFRange v28 = (void *)cf[0];
            if (cf[0])
            {
              CFTypeRef v29 = [(id)cf[0] objectForKeyedSubscript:*MEMORY[0x1E4F3BD40]];

              uint64_t v30 = [v28 objectForKeyedSubscript:*MEMORY[0x1E4F3B830]];

              if (v29 && v30)
              {
                PCSServiceItemGetAccessGroupByName(a2);
                id v32 = v28;
                id v33 = v6;
                SecItemSetCurrentItemAcrossAllDevices();
                dispatch_semaphore_wait(v33, 0xFFFFFFFFFFFFFFFFLL);
              }
              else
              {
                id v31 = pcsLogObjForScope("ckks");
                if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138412290;
                  CFTypeRef v49 = a2;
                  _os_log_impl(&dword_1ACF98000, v31, OS_LOG_TYPE_DEFAULT, "Failed to get CKKS pref and digest %@", buf, 0xCu);
                }
              }
            }
          }
        }
        else
        {
          pcsLogObjForScope("ckks");
          CFDictionaryRef v25 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled((os_log_t)v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            CFTypeRef v49 = a2;
            _os_log_impl(&dword_1ACF98000, (os_log_t)v25, OS_LOG_TYPE_DEFAULT, "Failed to get service ID for %@", buf, 0xCu);
          }
        }
      }
      id v14 = v35;
    }
    else
    {
      id v14 = pcsLogObjForScope("ckks");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v49 = a2;
        _os_log_impl(&dword_1ACF98000, v14, OS_LOG_TYPE_DEFAULT, "Failed to get CKKS view for service %@", buf, 0xCu);
      }
    }

    _Block_object_dispose(&v40, 8);
    _Block_object_dispose(&v44, 8);
  }
}

void sub_1ACFD4310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

intptr_t __PCSEngineAddMissingCurrentPointers_block_invoke_862(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2 && !a3) {
    goto LABEL_6;
  }
  CFTypeRef v6 = pcsLogObjForScope("ckks");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 56);
    int v9 = 138412546;
    uint64_t v10 = v7;
    __int16 v11 = 2112;
    uint64_t v12 = a3;
    _os_log_impl(&dword_1ACF98000, v6, OS_LOG_TYPE_DEFAULT, "Failed to get CKKS current item pointer for service %@: %@", (uint8_t *)&v9, 0x16u);
  }

  if (a2)
  {
LABEL_6:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = PCSIdentityCreateFromPersistentReference(a2, *(void **)(a1 + 64));
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

intptr_t __PCSEngineAddMissingCurrentPointers_block_invoke_865(uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  dispatch_semaphore_t v4 = pcsLogObjForScope("ckks");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 48);
      int v10 = 138412546;
      uint64_t v11 = v6;
      __int16 v12 = 2112;
      uint64_t v13 = a2;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "Failed to setting CKKS current for service %@: %@", (uint8_t *)&v10, 0x16u);
    }
  }
  else if (v5)
  {
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = [*(id *)(a1 + 32) objectForKeyedSubscript:*MEMORY[0x1E4F3B5C0]];
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v8;
    _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "Set CKKS current for service %@ to the identity: %@", (uint8_t *)&v10, 0x16u);
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

uint64_t PCSEnginePreCheckHSMWrite(void *a1, const void **a2)
{
  id v3 = a1;
  CFDictionaryRef v4 = (const __CFDictionary *)[v3 options];
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSSetupStingray[0]);
  if (Value)
  {
    CFBooleanRef v6 = Value;
    CFTypeID v7 = CFGetTypeID(Value);
    if (v7 == CFBooleanGetTypeID() && !CFBooleanGetValue(v6)) {
      goto LABEL_8;
    }
  }
  CFDictionaryRef v8 = (const __CFDictionary *)[v3 options];
  int v9 = CFDictionaryGetValue(v8, kPCSSetupUsername[0]);
  CFDictionaryRef v10 = (const __CFDictionary *)[v3 options];
  uint64_t v11 = CFDictionaryGetValue(v10, kPCSSetupPassword[0]);
  if (!v9 || (__int16 v12 = v11, v13 = CFGetTypeID(v9), v13 != CFStringGetTypeID()))
  {
    _PCSErrorContext([v3 log], a2, 122, @"Missing parameter: username");
LABEL_12:
    uint64_t v15 = 0;
    goto LABEL_9;
  }
  if (!v12 || (CFTypeID v14 = CFGetTypeID(v12), v14 != CFStringGetTypeID()))
  {
    _PCSErrorContext([v3 log], a2, 123, @"Missing parameter: password");
    goto LABEL_12;
  }
LABEL_8:
  uint64_t v15 = 1;
LABEL_9:

  return v15;
}

uint64_t PCSEngineEvaluateOctagon(void *a1, void *a2)
{
  id v3 = a1;
  if (!CaptureMetadata(v3, (const __CFDictionary *)[v3 metadata])) {
    goto LABEL_46;
  }
  CFDictionaryRef v4 = GetiCDPMetadata((const __CFDictionary *)[v3 metadata]);
  if (!v4) {
    goto LABEL_46;
  }
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSMetadataiCDPWalrus[0]);
  v8 = Value && (v6 = Value, CFTypeID v7 = CFGetTypeID(Value), v7 == CFBooleanGetTypeID()) && CFBooleanGetValue(v6) != 0;
  id v9 = v3;
  uint64_t v54 = 0;
  uint64_t v55 = &v54;
  uint64_t v56 = 0x2050000000;
  CFDictionaryRef v10 = (void *)getAKAccountManagerClass_softClass_0;
  uint64_t v57 = getAKAccountManagerClass_softClass_0;
  if (!getAKAccountManagerClass_softClass_0)
  {
    v53[0] = MEMORY[0x1E4F143A8];
    v53[1] = 3221225472;
    v53[2] = __getAKAccountManagerClass_block_invoke_0;
    v53[3] = &unk_1E5E6DDF8;
    v53[4] = &v54;
    __getAKAccountManagerClass_block_invoke_0((uint64_t)v53);
    CFDictionaryRef v10 = (void *)v55[3];
  }
  id v11 = v10;
  _Block_object_dispose(&v54, 8);
  CFDictionaryRef v12 = (const __CFDictionary *)[v9 options];
  CFTypeID v13 = CFDictionaryGetValue(v12, kPCSSetupDSID[0]);
  CFDictionaryRef v14 = (const __CFDictionary *)[v9 options];
  uint64_t v15 = CFDictionaryGetValue(v14, kPCSSetupAltDSID[0]);
  if (v15
    || (+[PCSAccountsModel altDSIDForDSID:v13],
        (uint64_t v15 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    CFTypeRef v49 = v13;
    uint64_t v16 = [v11 sharedInstance];
    id v52 = 0;
    uint64_t v17 = [v16 authKitAccountWithAltDSID:v15 error:&v52];
    id v18 = v52;
    CFArrayRef v48 = v18;
    if (!v17)
    {
      id v31 = 0;
      id v32 = 0;
      uint64_t v23 = 0;
      int v33 = 0;
      if (a2) {
        *a2 = v18;
      }
LABEL_40:

      if (v33)
      {
        PCSMigrationLog([v9 log], @"Evaluated and equalized account state");
        goto LABEL_46;
      }
      goto LABEL_42;
    }
    if ([v16 securityLevelForAccount:v17] != 4)
    {
      id v31 = 0;
      id v32 = 0;
      uint64_t v23 = 0;
      int v33 = 1;
      goto LABEL_40;
    }
    BOOL v44 = v8;
    uint64_t v46 = a2;
    id v19 = objc_alloc_init(MEMORY[0x1E4F3B438]);
    [v19 setAltDSID:v15];
    [v19 setContext:*MEMORY[0x1E4F3B458]];
    uint64_t v20 = (void *)[objc_alloc(MEMORY[0x1E4F3B430]) initWithContextData:v19];
    id v21 = objc_alloc_init(MEMORY[0x1E4F3B448]);
    [v21 setUseCachedAccountStatus:1];
    id v51 = 0;
    uint64_t v22 = [v20 fetchCliqueStatus:v21 error:&v51];
    id v45 = v51;
    char v47 = 0;
    uint64_t v23 = 0;
    if (v22) {
      goto LABEL_38;
    }
    id v50 = 0;
    id v43 = v19;
    uint64_t v23 = [MEMORY[0x1E4F3B430] fetchAccountWideSettings:v19 error:&v50];
    id v24 = v50;
    char v47 = v24;
    if (v23)
    {
      id v41 = v9;
      CFDictionaryRef v25 = v20;
      id v40 = v20;
      id v26 = v23;
      if ([v26 hasWalrus])
      {
        uint64_t v27 = [v26 walrus];
        int v28 = [v27 enabled];

        if (!v44)
        {
          CFDictionaryRef v25 = v20;
          if (v28)
          {
            [v41 setICDPHSMWalrus:1];
            [v41 setModified:1];
          }
          goto LABEL_37;
        }
        CFDictionaryRef v25 = v20;
        if (v28)
        {
LABEL_37:

          uint64_t v20 = v25;
          id v19 = v43;
LABEL_38:

          int v33 = 1;
LABEL_39:
          id v32 = v45;
          a2 = v46;
          id v31 = v47;
          goto LABEL_40;
        }
        uint64_t v30 = v40;
        CFTypeRef v29 = v41;
LABEL_34:
        PCSEngineFixOctagonW(v29, v30, 1);
        goto LABEL_37;
      }
      if (!v44 || ([v26 hasWalrus] & 1) != 0) {
        goto LABEL_37;
      }
    }
    else
    {
      if ([v24 code] == 53)
      {
        id v34 = [v47 domain];
        int v42 = [v34 isEqualToString:*MEMORY[0x1E4F3B468]];

        if ((v44 | v42 ^ 1) != 1)
        {

          uint64_t v23 = 0;
          int v33 = 0;
          goto LABEL_39;
        }
      }
      if (v46 && v45) {
        *uint64_t v46 = v45;
      }
      id v35 = v9;
      CFDictionaryRef v25 = v20;
      id v36 = v20;
      if (!v44) {
        goto LABEL_37;
      }
    }
    CFTypeRef v29 = v9;
    uint64_t v30 = v25;
    goto LABEL_34;
  }

LABEL_42:
  uint64_t v37 = [v9 log];
  if (a2) {
    uint64_t v38 = *a2;
  }
  else {
    uint64_t v38 = 0;
  }
  PCSMigrationLog(v37, @"Unable to evaluate and equalize account state: %@", v38);
LABEL_46:

  return 1;
}

void sub_1ACFD4BE4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t PCSEngineFailOnDroppedKeys(void *a1, const void **a2)
{
  id v3 = a1;
  if ((_PCSIsiCDPIsWalrus((const __CFDictionary *)[v3 metadata]) & 1) != 0
    || _PCSIsiCDPIsPlesio((const __CFDictionary *)[v3 metadata]))
  {
    _PCSError(a2, 159, @"Keys dropped from HSM");
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 1;
  }

  return v4;
}

uint64_t PCSEngineStepEnableiCDP(void *a1)
{
  id v1 = a1;
  [v1 setModified:1];
  objc_msgSend(v1, "setICDP:", objc_msgSend(v1, "iCDPHSM"));
  [v1 setICDPArmed:1];
  [v1 setICDPHSMWalrus:0];
  [v1 setICDPHSMPlesio:0];

  return 1;
}

uint64_t PCSEngineNotifyKeyChanges(void *a1)
{
  id v1 = a1;
  if (([v1 modified] & 1) != 0 || objc_msgSend(v1, "newIdentity"))
  {
    notify_post("com.apple.ProtectedCloudStorage.updatedKeys");
    _PCSPostHaveCredentials();
  }

  return 1;
}

Class __getAKAccountManagerClass_block_invoke_0(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!AuthKitLibraryCore_frameworkLibrary_0)
  {
    v3[1] = (void *)MEMORY[0x1E4F143A8];
    void v3[2] = (void *)3221225472;
    v3[3] = __AuthKitLibraryCore_block_invoke_0;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5E6EA90;
    uint64_t v5 = 0;
    AuthKitLibraryCore_frameworkLibrary_0 = _sl_dlopen();
    if (!AuthKitLibraryCore_frameworkLibrary_0)
    {
      abort_report_np();
LABEL_8:
      __getAKAccountManagerClass_block_invoke_cold_1();
    }
    if (v3[0]) {
      free(v3[0]);
    }
  }
  Class result = objc_getClass("AKAccountManager");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    goto LABEL_8;
  }
  getAKAccountManagerClass_softClass_0 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __AuthKitLibraryCore_block_invoke_0()
{
  uint64_t result = _sl_dlopen();
  AuthKitLibraryCore_frameworkLibrary_0 = result;
  return result;
}

void PCSEngineFixOctagonW(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v6 = (objc_class *)MEMORY[0x1E4F83A48];
  id v7 = a2;
  id v8 = objc_alloc_init(v6);
  id v9 = objc_alloc_init(MEMORY[0x1E4F83A50]);
  [v9 setEnabled:a3];
  [v8 setWalrus:v9];
  id v14 = 0;
  int v10 = [v7 setAccountSetting:v8 error:&v14];

  id v11 = v14;
  CFDictionaryRef v12 = v11;
  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 0;
  }
  if (!v13) {
    PCSMigrationLog([v5 log], @"Failed to set account setting :%@", v11);
  }
}

uint64_t PCSEngineStepEnableiCDPIfArmed(void *a1, const void **a2)
{
  id v3 = a1;
  int v4 = [v3 newIdentity];
  if (v4)
  {
    _PCSError(a2, 62, @"can't close door with new identity");
  }
  else
  {
    [v3 setModified:1];
    if ([v3 iCDPHSMArmed])
    {
      objc_msgSend(v3, "setICDPArmed:", objc_msgSend(v3, "iCDPHSMArmed"));
      uint64_t v5 = [v3 iCDPHSMArmed];
    }
    else
    {
      objc_msgSend(v3, "setICDPArmed:", objc_msgSend(v3, "iCDPHSM"));
      uint64_t v5 = [v3 iCDPHSM];
    }
    [v3 setICDP:v5];
    [v3 setICDPHSMWalrus:0];
    [v3 setICDPHSMPlesio:0];
  }

  return v4 ^ 1u;
}

uint64_t PCSEngineStepDropStingray(void *a1)
{
  id v1 = a1;
  [v1 setModified:1];
  [v1 setDropHSM:1];
  [v1 setICDP:1];
  [v1 setICDPArmed:1];
  [v1 setICDPPlesio:1];
  [v1 setICDPHSMPlesio:1];

  return 1;
}

uint64_t PCSEngineFailOnNotDroppedKeys(void *a1, const void **a2)
{
  id v3 = a1;
  if ([v3 iCDPHSMWalrus] & 1) != 0 || (objc_msgSend(v3, "iCDPHSMPlesio"))
  {
    uint64_t v4 = 1;
  }
  else
  {
    _PCSError(a2, 160, @"Keys was NOT dropped from HSM");
    uint64_t v4 = 0;
  }

  return v4;
}

BOOL PCSEngineIgnoreKeysInHSM(void *a1, const void **a2)
{
  id v3 = a1;
  [v3 clearSet];
  [v3 setSet:PCSIdentitySetCreateMutable(a2)];
  if ([v3 set])
  {
    CFTypeRef Keychain = PCSIdentitySetCreateKeychain((const __CFDictionary *)[v3 options], 0, a2);
    BOOL v5 = Keychain != 0;
    if (Keychain)
    {
      CFRelease(Keychain);
      BOOL v5 = 1;
    }
  }
  else
  {
    BOOL v5 = 0;
  }

  return v5;
}

uint64_t PCSEngineStepUndropStingray(void *a1)
{
  id v1 = a1;
  [v1 setModified:1];
  [v1 setRestoreHSM:1];
  [v1 setICDP:1];
  [v1 setICDPArmed:1];
  [v1 setICDPHSMPlesio:0];

  return 1;
}

uint64_t PCSEngineUnsetCurrentItems(void *a1, const void **a2)
{
  id v3 = a1;
  if (_os_feature_enabled_impl())
  {
    uint64_t v4 = (uint64_t)PCSIdentitySetCreate((const __CFDictionary *)[v3 options], 0, a2);
    if (v4)
    {
      uint64_t v27 = 0;
      int v28 = &v27;
      uint64_t v29 = 0x2020000000;
      char v30 = 0;
      uint64_t v23 = 0;
      id v24 = &v23;
      uint64_t v25 = 0x2020000000;
      char v26 = 0;
      BOOL v5 = _PCSServiceItemsGetNoRollStingrayServiceTypes();
      id v6 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 3221225472;
      _DWORD v17[2] = __PCSEngineUnsetCurrentItems_block_invoke;
      v17[3] = &unk_1E5E6EAB0;
      id v7 = v5;
      id v18 = v7;
      id v19 = v3;
      id v21 = &v27;
      uint64_t v22 = v4;
      id v8 = v6;
      id v20 = v8;
      PCSServiceItemsGetEachName(v17);
      if (*((unsigned char *)v28 + 24))
      {
        _PCSError(a2, 4, @"Failed to make one or more current identities non-current");
      }
      else if (_PCSRunningInUnitTests())
      {
        *((unsigned char *)v24 + 24) = 1;
      }
      else
      {
        dispatch_semaphore_t v9 = dispatch_semaphore_create(0);
        int v10 = (void (*)(__CFString *, id, __CFString *, void *))off_1EB3B39E8;
        v13[0] = MEMORY[0x1E4F143A8];
        v13[1] = 3221225472;
        void v13[2] = __PCSEngineUnsetCurrentItems_block_invoke_2;
        v13[3] = &unk_1E5E6DED0;
        uint64_t v15 = &v23;
        uint64_t v16 = a2;
        id v11 = v9;
        id v14 = v11;
        v10(@"com.apple.ProtectedCloudStorage", v8, @"ProtectedCloudStorage", v13);
        dispatch_semaphore_wait(v11, 0xFFFFFFFFFFFFFFFFLL);
      }
      CFRelease((CFTypeRef)v4);
      uint64_t v4 = *((unsigned char *)v24 + 24) != 0;

      _Block_object_dispose(&v23, 8);
      _Block_object_dispose(&v27, 8);
    }
  }
  else
  {
    uint64_t v4 = 1;
  }

  return v4;
}

void sub_1ACFD54C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t PCSEngineStepEnableWalrus(void *a1)
{
  id v1 = a1;
  [v1 setModified:1];
  [v1 setDropHSM:1];
  [v1 setICDP:1];
  [v1 setICDPArmed:1];
  [v1 setICDPHSMWalrus:1];

  return 1;
}

uint64_t PCSEngineStoreiCDPStatusRequireW(void *a1, const void **a2)
{
  return _PCSEngineStoreiCDPStatus(a1, 1, a2);
}

uint64_t PCSEngineAddMissingCurrentPointersWithFFCheck(void *a1, const void **a2)
{
  id v3 = a1;
  if (_os_feature_enabled_impl()) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = PCSEngineAddMissingCurrentPointers(v3, a2);
  }

  return v4;
}

uint64_t PCSEngineStepInitiateKeyRolling(void *a1, const void **a2)
{
  v52[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!_os_feature_enabled_impl())
  {
    BOOL v5 = +[PCSAnalytics logger];
    [v5 logSuccessForEvent:@"PCSEventInitiateKeyRolling"];
    [v3 setModified:1];
    CFDictionaryRef v6 = (const __CFDictionary *)[v3 options];
    CFBooleanRef Value = (void *)CFDictionaryGetValue(v6, kPCSSetupDSID[0]);
    if (Value && (id v8 = Value, v9 = CFGetTypeID(Value), v9 == CFStringGetTypeID()))
    {
      BOOL v10 = PCSCurrentPersonaMatchesDSID(v8);
      if (!a2 || v10)
      {
        uint64_t v15 = _PCSServiceItemsGetNoRollStingrayServiceTypes();
        uint64_t v45 = 0;
        uint64_t v46 = &v45;
        uint64_t v47 = 0x2020000000;
        int v48 = 0;
        uint64_t v41 = 0;
        int v42 = &v41;
        uint64_t v43 = 0x2020000000;
        int v44 = 0;
        uint64_t v37 = 0;
        uint64_t v38 = &v37;
        uint64_t v39 = 0x2020000000;
        int v40 = 0;
        uint64_t v27 = MEMORY[0x1E4F143A8];
        uint64_t v28 = 3221225472;
        uint64_t v29 = __PCSEngineStepInitiateKeyRolling_block_invoke;
        char v30 = &unk_1E5E6EAD8;
        id v16 = v15;
        id v31 = v16;
        id v17 = v3;
        id v35 = &v41;
        id v36 = v8;
        id v32 = v17;
        int v33 = &v45;
        id v34 = &v37;
        PCSServiceItemsGetEachName(&v27);
        id v18 = [NSString stringWithFormat:@"%@-%u", @"PCSEventMarkForKeyRolling", *((unsigned int *)v46 + 6)];
        if (*((_DWORD *)v42 + 6) || *((_DWORD *)v38 + 6))
        {
          uint64_t v19 = [v17 log];
          PCSMigrationLog(v19, @"While marking identities for rolling: %u marked, %u failed to find, %u failed to mark", *((unsigned int *)v46 + 6), *((unsigned int *)v42 + 6), *((unsigned int *)v38 + 6), v27, v28, v29, v30, v31);
          id v20 = [MEMORY[0x1E4F28C58] errorWithDomain:kPCSErrorDomain code:158 userInfo:0];
          v49[0] = @"markedToRoll";
          id v21 = [NSNumber numberWithUnsignedInt:*((unsigned int *)v46 + 6)];
          v50[0] = v21;
          v49[1] = @"failedToMark";
          uint64_t v22 = [NSNumber numberWithUnsignedInt:*((unsigned int *)v42 + 6)];
          v50[1] = v22;
          v49[2] = @"notFoundToMark";
          uint64_t v23 = [NSNumber numberWithUnsignedInt:*((unsigned int *)v38 + 6)];
          v50[2] = v23;
          id v24 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v50 forKeys:v49 count:3];
          [v5 logRecoverableError:v20 forEvent:v18 withAttributes:v24];
        }
        else
        {
          [v5 logSuccessForEvent:v18];
        }
        id v25 = objc_alloc_init(MEMORY[0x1E4F1CB18]);
        char v26 = [MEMORY[0x1E4F1C9C8] distantPast];
        [v25 setObject:v26 forKey:kPCSSettingStingrayRoll];

        _Block_object_dispose(&v37, 8);
        _Block_object_dispose(&v41, 8);
        _Block_object_dispose(&v45, 8);

        uint64_t v4 = 1;
        goto LABEL_10;
      }
      id v11 = (void *)MEMORY[0x1E4F28C58];
      CFDictionaryRef v12 = kPCSErrorDomain;
      uint64_t v51 = *MEMORY[0x1E4F28568];
      v52[0] = @"Current persona does not match chosen dsid";
      BOOL v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v52 forKeys:&v51 count:1];
      *a2 = [v11 errorWithDomain:v12 code:152 userInfo:v13];
    }
    else
    {
      _PCSErrorContext([v3 log], a2, 121, @"Missing parameter: dsid");
    }
    uint64_t v4 = 0;
LABEL_10:

    goto LABEL_11;
  }
  PCSMigrationLog([v3 log], @"Feature enabled, skipping");
  uint64_t v4 = 1;
LABEL_11:

  return v4;
}

void sub_1ACFD5A30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void __PCSEngineUnsetCurrentItems_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)MEMORY[0x1AD11CE50]();
  if ((PCSServiceItemTypeIsManatee(a2) & 1) == 0 && ([*(id *)(a1 + 32) containsObject:a2] & 1) == 0)
  {
    int AccessGroupByName = PCSServiceItemGetAccessGroupByName(a2);
    if (CFEqual(@"com.apple.ProtectedCloudStorage", AccessGroupByName))
    {
      CKKSViewByName = PCSServiceItemGetCKKSViewByName(a2);
      if (CFEqual(@"ProtectedCloudStorage", CKKSViewByName))
      {
        id v11 = 0;
        char v7 = PCSIdentitySetUnsetCurrentIdentity(*(void *)(a1 + 64), (uint64_t)a2, &v11);
        id v8 = *(void **)(a1 + 40);
        if (v7)
        {
          if (PCSIdentitySetUnsetCurrentIdentity([v8 set], (uint64_t)a2, &v11))
          {
            [*(id *)(a1 + 48) addObject:a2];
            goto LABEL_13;
          }
          uint64_t v10 = [*(id *)(a1 + 40) log];
          PCSMigrationLog(v10, @"Failed to unset current identity in set: %@", v11);
        }
        else
        {
          uint64_t v9 = [v8 log];
          PCSMigrationLog(v9, @"Failed to unset current identity: %@", v11);
        }
      }
      else
      {
        PCSMigrationLog([*(id *)(a1 + 40) log], @"Incorrect view for %@", a2);
      }
    }
    else
    {
      PCSMigrationLog([*(id *)(a1 + 40) log], @"Incorrect access group for %@", a2);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
  }
LABEL_13:
}

intptr_t __PCSEngineUnsetCurrentItems_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  if (cf)
  {
    *(unsigned char *)(v3 + 24) = 0;
    if (*(void *)(a1 + 48)) {
      **(void **)(a1 + 4_Block_object_dispose(&a9, 8) = CFRetain(cf);
    }
  }
  else
  {
    *(unsigned char *)(v3 + 24) = 1;
  }
  uint64_t v4 = *(NSObject **)(a1 + 32);
  return dispatch_semaphore_signal(v4);
}

void __PCSEngineStepInitiateKeyRolling_block_invoke(uint64_t a1, void *a2)
{
  v22[5] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)MEMORY[0x1AD11CE50]();
  if ((PCSServiceItemTypeIsManatee(a2) & 1) == 0 && ([*(id *)(a1 + 32) containsObject:a2] & 1) == 0)
  {
    CFNumberRef IndexByName = PCSServiceItemGetIndexByName(a2);
    if (IndexByName)
    {
      CFNumberRef v6 = IndexByName;
      uint64_t v7 = *MEMORY[0x1E4F3B998];
      uint64_t v8 = *MEMORY[0x1E4F3B878];
      uint64_t v9 = MEMORY[0x1E4F1CC38];
      v21[0] = *MEMORY[0x1E4F3B978];
      v21[1] = v8;
      v22[0] = v7;
      v22[1] = MEMORY[0x1E4F1CC38];
      uint64_t v10 = *MEMORY[0x1E4F3B848];
      v21[2] = *MEMORY[0x1E4F3B838];
      v21[3] = v10;
      uint64_t v11 = *(void *)(a1 + 72);
      void v22[2] = kPCSServiceName[0];
      v22[3] = v11;
      int v21[4] = *MEMORY[0x1E4F3B8C0];
      CFDictionaryRef v12 = [NSNumber numberWithUnsignedInt:IndexByName | 0x10000];
      v22[4] = v12;
      BOOL v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v22 forKeys:v21 count:5];

      uint64_t v19 = *MEMORY[0x1E4F3B6A8];
      uint64_t v20 = v9;
      id v14 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v20 forKeys:&v19 count:1];
      uint64_t v15 = qword_1EB3B39C0(v13, v14);
      if (v15 == -25300)
      {
        ++*(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
        PCSMigrationLog([*(id *)(a1 + 40) log], @"Failed to find identity for service %@ to mark for rolling", a2);
      }
      else if (v15)
      {
        ++*(_DWORD *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
        PCSMigrationLog([*(id *)(a1 + 40) log], @"Failed to mark identities for service %@ for rolling: %d", a2, v15);
      }
      else
      {
        ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
        CFDictionaryRef v16 = (const __CFDictionary *)[*(id *)(a1 + 40) options];
        uint64_t v17 = CFDictionaryGetValue(v16, kPCSSetupCallbackMarkNegative[0]);
        id v18 = (void *)v17;
        if (v17) {
          (*(void (**)(uint64_t, void, const __CFNumber *))(v17 + 16))(v17, *(void *)(a1 + 72), v6);
        }
      }
    }
    else
    {
      PCSMigrationLog([*(id *)(a1 + 40) log], @"Failed to get service ID for %@", a2);
    }
  }
}

uint64_t PCSEngineStepDisableWalrus(void *a1)
{
  id v1 = a1;
  [v1 setModified:1];
  [v1 setRestoreHSM:1];
  [v1 setICDP:1];
  [v1 setICDPArmed:1];
  [v1 setICDPHSMWalrus:0];

  return 1;
}

uint64_t PCSEngineValidateiCDP(void *a1, const void **a2)
{
  id v3 = a1;
  if ([v3 metadata])
  {
    if (_PCSIsiCDPEnabled((const __CFDictionary *)[v3 metadata], 1))
    {
      [v3 setICDP:1];
      [v3 setICDPArmed:1];
      objc_msgSend(v3, "setICDPPlesio:", _PCSIsiCDPIsPlesio((const __CFDictionary *)objc_msgSend(v3, "metadata")));
      if (!_PCSEngineStoreiCDPStatus(v3, 0, a2))
      {
        uint64_t v6 = 0;
        goto LABEL_14;
      }
    }
    if (([v3 triggerUpdate] & 1) == 0)
    {
      PCSMigrationLog([v3 log], @"Checking for ValidateiCDP migration");
      if (_PCSIsiCDPIsWalrus((const __CFDictionary *)[v3 metadata]))
      {
        PCSMigrationLog([v3 log], @"Using Walrus account");
      }
      else
      {
        if (!_PCSIsiCDPIsPlesio((const __CFDictionary *)[v3 metadata]))
        {
          unsigned int v4 = _PCSIsiCDPEnabled((const __CFDictionary *)[v3 metadata], 0);
          uint64_t v5 = [v3 log];
          if (v4) {
            PCSMigrationLog(v5, @"Using iCDP account");
          }
          else {
            PCSMigrationLog(v5, @"Using SA account");
          }
          goto LABEL_13;
        }
        PCSMigrationLog([v3 log], @"Using Plesio account");
      }
      PCSEngineDifferentOnDroppedKeys(v3);
    }
  }
LABEL_13:
  uint64_t v6 = 1;
LABEL_14:

  return v6;
}

BOOL PCSEngineExitOnDroppedKeys(void *a1, const void **a2)
{
  id v3 = a1;
  if (([v3 iCDPHSMWalrus] & 1) != 0 || objc_msgSend(v3, "iCDPHSMPlesio"))
  {
    id v4 = v3;
    BOOL v5 = 1;
    [v4 setDone:1];
    if (![v4 set])
    {
      objc_msgSend(v4, "setSet:", PCSIdentitySetCreate((const __CFDictionary *)objc_msgSend(v4, "options"), 0, a2));
      BOOL v5 = [v4 set] != 0;
    }
  }
  else
  {
    BOOL v5 = 1;
  }

  return v5;
}

uint64_t __GetLegacyServiceArray_block_invoke()
{
  v1[11] = *MEMORY[0x1E4F143B8];
  v1[0] = kPCSServiceMaster;
  v1[1] = kPCSServiceBladerunner;
  void v1[2] = kPCSServiceHyperion;
  v1[3] = kPCSServiceLiverpool;
  v1[4] = kPCSServiceEscrow;
  v1[5] = kPCSServiceFDE;
  void v1[6] = kPCSServicePianoMover;
  v1[7] = kPCSServiceBackup;
  void v1[8] = kPCSServiceSharing;
  v1[9] = kPCSServiceGaming;
  v1[10] = kPCSServiceBTPairing;
  uint64_t result = [MEMORY[0x1E4F1C978] arrayWithObjects:v1 count:11];
  GetLegacyServiceArray_array = result;
  return result;
}

uint64_t PCSEngineDifferentOniCDP(void *a1)
{
  id v1 = a1;
  CFTypeRef cf = 0;
  if ([v1 iCDPHSM] && (objc_msgSend(v1, "triggerUpdate") & 1) == 0)
  {
    if (PCSEngineHaveSyncEnoughToCreateIdentities(v1, &cf))
    {
      [v1 setCurrentStep:&validationInNoTouchHSMContent];
    }
    else
    {
      uint64_t v7 = [v1 log];
      PCSMigrationLog(v7, @"DifferentOniCDP: not enough in sync: %@", cf);
      [v1 setDone:1];
    }
  }
  else
  {
    uint64_t v2 = [v1 log];
    id v3 = _PCSYESNO([v1 iCDPHSM]);
    id v4 = _PCSYESNO([v1 triggerUpdate]);
    PCSMigrationLog(v2, @"DifferentOniCDP: %@ triggerUpdate: %@", v3, v4);
  }
  CFTypeRef v5 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v5);
  }

  return 1;
}

BOOL PCSEngineCreateEmptyKeyset(void *a1, const void **a2)
{
  id v3 = a1;
  [v3 clearSet];
  [v3 setSet:PCSIdentitySetCreateMutable(a2)];
  uint64_t v4 = [v3 set];

  return v4 != 0;
}

uint64_t PCSEnginePreCheckHSMRead(void *a1, const void **a2)
{
  id v3 = a1;
  CFDictionaryRef v4 = (const __CFDictionary *)[v3 options];
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v4, kPCSSetupStingray[0]);
  if (Value && (v6 = Value, CFTypeID v7 = CFGetTypeID(Value), v7 == CFBooleanGetTypeID()) && !CFBooleanGetValue(v6)
    || (CFDictionaryRef v8 = (const __CFDictionary *)[v3 options],
        (uint64_t v9 = CFDictionaryGetValue(v8, kPCSSetupUsername[0])) != 0)
    && (CFTypeID v10 = CFGetTypeID(v9), v10 == CFStringGetTypeID()))
  {
    uint64_t v11 = 1;
  }
  else
  {
    _PCSErrorContext([v3 log], a2, 122, @"Missing parameter: username");
    uint64_t v11 = 0;
  }

  return v11;
}

BOOL PCSEngineForceRecover(void *a1, const void **a2)
{
  id v3 = a1;
  if (fail_and_cfu_if_no_password(0, 1, v3, (const __CFDictionary *)[v3 options], (uint64_t *)a2))
  {
    objc_msgSend(v3, "setClassicContent:", __PCSCopyHSMData(objc_msgSend(v3, "log"), objc_msgSend(v3, "options"), a2));
    BOOL v4 = [v3 classicContent] != 0;
  }
  else
  {
    BOOL v4 = 0;
  }

  return v4;
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void PCSCacheCurrentIdentitiesForServices(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v18 = a3;
  uint64_t v31 = 0;
  id v32 = &v31;
  uint64_t v33 = 0x2020000000;
  uint64_t v34 = 0;
  uint64_t v25 = 0;
  char v26 = &v25;
  uint64_t v27 = 0x3032000000;
  uint64_t v28 = __Block_byref_object_copy__2;
  uint64_t v29 = __Block_byref_object_dispose__2;
  id v30 = 0;
  if (_os_feature_enabled_impl())
  {
    BOOL v4 = +[PCSCKKSOutOfBandFetchCache cache];
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    void v24[2] = __PCSCacheCurrentIdentitiesForServices_block_invoke;
    v24[3] = &unk_1E5E6EBF0;
    v24[4] = &v31;
    v24[5] = &v25;
    [v4 getCurrentIdentities:a1 result:v24];

    if ([(id)v26[5] count])
    {
      id v5 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      id v6 = (id)v26[5];
      uint64_t v7 = [v6 countByEnumeratingWithState:&v20 objects:v36 count:16];
      if (v7)
      {
        uint64_t v8 = *(void *)v21;
        uint64_t v9 = MEMORY[0x1E4F14500];
        do
        {
          for (uint64_t i = 0; i != v7; ++i)
          {
            if (*(void *)v21 != v8) {
              objc_enumerationMutation(v6);
            }
            uint64_t v11 = *(void **)(*((void *)&v20 + 1) + 8 * i);
            int AccessGroupByName = PCSServiceItemGetAccessGroupByName(v11);
            CKKSViewByName = PCSServiceItemGetCKKSViewByName(v11);
            if (AccessGroupByName) {
              BOOL v14 = CKKSViewByName == 0;
            }
            else {
              BOOL v14 = 1;
            }
            if (v14)
            {
              if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
                PCSCacheCurrentIdentitiesForServices_cold_1(buf, (uint64_t)v11, &buf[4]);
              }
            }
            else
            {
              uint64_t v15 = (void *)[objc_alloc(MEMORY[0x1E4F3B400]) initWithIdentifier:v11 accessGroup:AccessGroupByName zoneID:CKKSViewByName];
              [v5 addObject:v15];
            }
          }
          uint64_t v7 = [v6 countByEnumeratingWithState:&v20 objects:v36 count:16];
        }
        while (v7);
      }

      if (!v32[3]) {
        void v32[3] = (uint64_t)PCSIdentitySetCreateMutable(0);
      }
      id v19 = v18;
      SecItemFetchCurrentItemOutOfBand();
    }
    else
    {
      (*((void (**)(id, uint64_t, void))v18 + 2))(v18, v32[3], 0);
      uint64_t v17 = (const void *)v32[3];
      if (v17)
      {
        void v32[3] = 0;
        CFRelease(v17);
      }
    }
  }
  else
  {
    *(void *)long long buf = 0;
    _PCSError((const void **)buf, 164, @"feature disabled");
    (*((void (**)(id, void, void))v18 + 2))(v18, 0, *(void *)buf);
    CFDictionaryRef v16 = *(const void **)buf;
    if (*(void *)buf)
    {
      *(void *)long long buf = 0;
      CFRelease(v16);
    }
  }
  _Block_object_dispose(&v25, 8);

  _Block_object_dispose(&v31, 8);
}

void sub_1ACFD765C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void __PCSCacheCurrentIdentitiesForServices_block_invoke(uint64_t a1, const void *a2, void *a3)
{
  id v8 = a3;
  if (a2) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFRetain(a2);
  }
  uint64_t v5 = [objc_alloc(MEMORY[0x1E4F1CA80]) initWithSet:v8];
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;
}

void __PCSCacheCurrentIdentitiesForServices_block_invoke_51(void *a1, void *a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  uint64_t v6 = v5;
  if (!v5 || a3)
  {
    (*(void (**)(void))(a1[4] + 16))();
  }
  else
  {
    CFTypeRef cf = 0;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    id v7 = v5;
    uint64_t v8 = [v7 countByEnumeratingWithState:&v25 objects:v30 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)v26;
      while (2)
      {
        for (uint64_t i = 0; i != v9; ++i)
        {
          if (*(void *)v26 != v10) {
            objc_enumerationMutation(v7);
          }
          CFDictionaryRef v12 = *(void **)(*((void *)&v25 + 1) + 8 * i);
          BOOL v13 = *(void **)(*(void *)(a1[5] + 8) + 40);
          BOOL v14 = objc_msgSend(v12, "identifier", (void)v25);
          [v13 removeObject:v14];

          CFDictionaryRef v15 = [v12 decryptedRecord];
          CFDictionaryRef v16 = PCSIdentityCreateWithKeychainAttributes(v15, &cf);

          uint64_t v17 = *(void *)(a1[6] + 8);
          id v18 = *(const void **)(v17 + 24);
          if (v16) {
            BOOL v19 = cf == 0;
          }
          else {
            BOOL v19 = 0;
          }
          if (!v19)
          {
            if (v18)
            {
              *(void *)(v17 + 24) = 0;
              CFRelease(v18);
            }
            if (v16) {
              CFRelease(v16);
            }
            goto LABEL_21;
          }
          PCSIdentitySetAddIdentity((uint64_t)v18, (uint64_t)v16);
          PCSIdentitySetSetCurrentIdentity(*(void *)(*(void *)(a1[6] + 8) + 24), (uint64_t)v16);
          CFRelease(v16);
        }
        uint64_t v9 = [v7 countByEnumeratingWithState:&v25 objects:v30 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }
LABEL_21:

    if (*(void *)(*(void *)(a1[6] + 8) + 24)) {
      BOOL v20 = cf == 0;
    }
    else {
      BOOL v20 = 0;
    }
    if (v20)
    {
      long long v21 = +[PCSCKKSOutOfBandFetchCache cache];
      [v21 cacheCurrentIdentityFetchResult:*(void *)(*(void *)(a1[6] + 8) + 24) notFound:*(void *)(*(void *)(a1[5] + 8) + 40)];
    }
    (*(void (**)(void))(a1[4] + 16))();
    uint64_t v22 = *(void *)(a1[6] + 8);
    long long v23 = *(const void **)(v22 + 24);
    if (v23)
    {
      *(void *)(v22 + 24) = 0;
      CFRelease(v23);
    }
    CFTypeRef v24 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v24);
    }
  }
}

void PCSCacheCurrentIdentitiesForDefaultServices(void *a1)
{
}

void PCSCacheCurrentIdentitiesForDefaultServicesForceFetch(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
  CFSetAddValue(Mutable, @"com.apple.homekit");
  CFSetAddValue(Mutable, @"com.apple.siri.data");
  PCSCacheCurrentIdentitiesForServices((uint64_t)Mutable, a1, v3);

  if (Mutable)
  {
    CFRelease(Mutable);
  }
}

void _PCSCKKSOutOfBandFetchIdentities(void *a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v22 = a1;
  id v6 = a2;
  long long v21 = a4;
  unsigned int IndexByName = PCSServiceItemGetIndexByName(v6);
  uint64_t v37 = 0;
  uint64_t v38 = &v37;
  uint64_t v39 = 0x2020000000;
  uint64_t v40 = 0;
  uint64_t v31 = 0;
  id v32 = &v31;
  uint64_t v33 = 0x3032000000;
  uint64_t v34 = __Block_byref_object_copy__2;
  id v35 = __Block_byref_object_dispose__2;
  id v36 = 0;
  id v7 = +[PCSCKKSOutOfBandFetchCache cache];
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = ___PCSCKKSOutOfBandFetchIdentities_block_invoke;
  v30[3] = &unk_1E5E6EBF0;
  v30[4] = &v37;
  void v30[5] = &v31;
  [v7 getPCSIdentities:v22 forServiceID:IndexByName result:v30];

  uint64_t v8 = v38[3];
  if (v8)
  {
    v21[2](v21, v8, 0);
    uint64_t v9 = (const void *)v38[3];
    if (v9)
    {
      v38[3] = 0;
      CFRelease(v9);
    }
  }
  else if ([(id)v32[5] count])
  {
    id v23 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id v10 = (id)v32[5];
    uint64_t v11 = [v10 countByEnumeratingWithState:&v26 objects:v43 count:16];
    if (v11)
    {
      uint64_t v12 = *(void *)v27;
      do
      {
        for (uint64_t i = 0; i != v11; ++i)
        {
          if (*(void *)v27 != v12) {
            objc_enumerationMutation(v10);
          }
          uint64_t v14 = *(void *)(*((void *)&v26 + 1) + 8 * i);
          int AccessGroupByName = PCSServiceItemGetAccessGroupByName(v6);
          CKKSViewByName = PCSServiceItemGetCKKSViewByName(v6);
          if (AccessGroupByName && (uint64_t v17 = CKKSViewByName) != 0)
          {
            id v18 = objc_alloc(MEMORY[0x1E4F3B408]);
            BOOL v19 = [NSNumber numberWithUnsignedInt:IndexByName];
            BOOL v20 = (void *)[v18 initWithServiceNumber:v19 accessGroup:AccessGroupByName publicKey:v14 zoneID:v17];

            [v23 addObject:v20];
          }
          else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
          {
            PCSCacheCurrentIdentitiesForServices_cold_1(buf, (uint64_t)v6, &v42);
          }
        }
        uint64_t v11 = [v10 countByEnumeratingWithState:&v26 objects:v43 count:16];
      }
      while (v11);
    }

    long long v25 = v21;
    SecItemFetchPCSIdentityOutOfBand();
  }
  else
  {
    v21[2](v21, 0, 0);
  }
  _Block_object_dispose(&v31, 8);

  _Block_object_dispose(&v37, 8);
}

void sub_1ACFD7E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
}

void PCSServiceItemDestroy(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[2];
    if (v2)
    {
      a1[2] = 0;
      CFRelease(v2);
    }
    id v3 = (const void *)a1[5];
    if (v3)
    {
      a1[5] = 0;
      CFRelease(v3);
    }
    BOOL v4 = (const void *)a1[6];
    if (v4)
    {
      a1[6] = 0;
      CFRelease(v4);
    }
    id v5 = (const void *)a1[4];
    if (v5)
    {
      a1[4] = 0;
      CFRelease(v5);
    }
    id v6 = (const void *)a1[7];
    if (v6)
    {
      a1[7] = 0;
      CFRelease(v6);
    }
    id v7 = (const void *)a1[8];
    if (v7)
    {
      a1[8] = 0;
      CFRelease(v7);
    }
    uint64_t v8 = (const void *)a1[11];
    if (v8)
    {
      a1[11] = 0;
      CFRelease(v8);
    }
  }
}

uint64_t PCSServiceItemCompare(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    id v5 = *(const void **)(a1 + 16);
    id v6 = *(const void **)(a2 + 16);
    if (v5) {
      BOOL v7 = v6 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7)
    {
      if (v5 != v6) {
        return 0;
      }
    }
    else
    {
      uint64_t result = CFEqual(v5, v6);
      if (!result) {
        return result;
      }
    }
    uint64_t v8 = *(const void **)(a1 + 40);
    uint64_t v9 = *(const void **)(a2 + 40);
    if (v8 && v9) {
      return CFEqual(v8, v9) != 0;
    }
    else {
      return v8 == v9;
    }
  }
  return result;
}

CFHashCode PCSServiceItemHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

CFStringRef PCSServiceItemCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"SI@%p", a1);
  BOOL v4 = @"NA";
  id v5 = *(__CFString **)(a1 + 40);
  if (!v5) {
    id v5 = @"NA";
  }
  id v6 = *(__CFString **)(a1 + 48);
  BOOL v7 = *(__CFString **)(a1 + 56);
  if (!v6) {
    id v6 = @"NA";
  }
  if (!v7) {
    BOOL v7 = @"NA";
  }
  if (*(void *)(a1 + 64)) {
    BOOL v4 = *(__CFString **)(a1 + 64);
  }
  uint64_t v8 = 89;
  if (!*(unsigned char *)(a1 + 79)) {
    uint64_t v8 = 121;
  }
  if (*(unsigned char *)(a1 + 78)) {
    uint64_t v9 = 75;
  }
  else {
    uint64_t v9 = 107;
  }
  uint64_t v10 = 69;
  if (!*(unsigned char *)(a1 + 77)) {
    uint64_t v10 = 101;
  }
  uint64_t v11 = 65;
  if (!*(unsigned char *)(a1 + 76)) {
    uint64_t v11 = 97;
  }
  uint64_t v12 = 77;
  if (!*(unsigned char *)(a1 + 74)) {
    uint64_t v12 = 109;
  }
  uint64_t v13 = 82;
  if (!*(unsigned char *)(a1 + 73)) {
    uint64_t v13 = 114;
  }
  uint64_t v14 = 55;
  if (!*(unsigned char *)(a1 + 72)) {
    uint64_t v14 = 45;
  }
  CFStringRef v15 = CFStringCreateWithFormat(v2, 0, @"<%@: [name/oldName: %@/%@] [viewHint: %@] [class: %@] [keyDescription: %@] [number: %@] [%c%c%c%c%c%c%c] %08d %08x [accessGroup: %@]", v3, *(void *)(a1 + 16), v5, v6, v7, v4, *(void *)(a1 + 32), v14, v13, v12, v11, v10, v9, v8, *(unsigned int *)(a1 + 28), *(unsigned int *)(a1 + 80),
          *(void *)(a1 + 88));
  if (v3) {
    CFRelease(v3);
  }
  return v15;
}

CFIndex PCSServiceItemsCount()
{
  if (PCSServiceItemsInit_once != -1) {
    dispatch_once(&PCSServiceItemsInit_once, &__block_literal_global_91);
  }
  CFDictionaryRef v0 = (const __CFDictionary *)PCSServiceItemsInit_localServiceItems;
  return CFDictionaryGetCount(v0);
}

void PCSServiceItemsInfoIteration(void *a1)
{
  id v1 = a1;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemsInfoIteration_block_invoke;
  v3[3] = &unk_1E5E6EC68;
  id v4 = v1;
  id v2 = v1;
  PCSServiceItemsIterate(v3);
}

void PCSServiceItemsIterate(void *a1)
{
  id v1 = a1;
  if (PCSServiceItemsInit_once != -1) {
    dispatch_once(&PCSServiceItemsInit_once, &__block_literal_global_91);
  }
  CFDictionaryRef v2 = (const __CFDictionary *)PCSServiceItemsInit_localServiceItems;
  context[0] = MEMORY[0x1E4F143A8];
  context[1] = 3221225472;
  context[2] = __PCSServiceItemsIterate_block_invoke;
  context[3] = &unk_1E5E6E298;
  id v5 = v1;
  id v3 = v1;
  CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)apply_block_2_4, context);
}

uint64_t __PCSServiceItemsInfoIteration_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSServiceItemsGetEachName(void *a1)
{
  id v1 = a1;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemsGetEachName_block_invoke;
  v3[3] = &unk_1E5E6EC68;
  id v4 = v1;
  id v2 = v1;
  PCSServiceItemsIterate(v3);
}

uint64_t __PCSServiceItemsGetEachName_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t PCSServiceItemsGetCFArrayOfNames()
{
  if (PCSServiceItemsGetCFArrayOfNames_once != -1) {
    dispatch_once(&PCSServiceItemsGetCFArrayOfNames_once, &__block_literal_global_12);
  }
  return PCSServiceItemsGetCFArrayOfNames_array;
}

void __PCSServiceItemsGetCFArrayOfNames_block_invoke()
{
  PCSServiceItemsGetCFArrayOfNames_array = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  PCSServiceItemsIterate(&__block_literal_global_59);
}

void __PCSServiceItemsGetCFArrayOfNames_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!CFEqual(kPCSServiceRaw, *(CFTypeRef *)(a3 + 16)))
  {
    id v4 = (__CFArray *)PCSServiceItemsGetCFArrayOfNames_array;
    id v5 = *(const void **)(a3 + 16);
    CFArrayAppendValue(v4, v5);
  }
}

uint64_t PCSServiceItemsGetCFArraySortedByIndex()
{
  if (PCSServiceItemsGetCFArraySortedByIndex_once != -1) {
    dispatch_once(&PCSServiceItemsGetCFArraySortedByIndex_once, &__block_literal_global_61);
  }
  return PCSServiceItemsGetCFArraySortedByIndex_array;
}

void __PCSServiceItemsGetCFArraySortedByIndex_block_invoke()
{
  PCSServiceItemsGetCFArraySortedByIndex_array = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  PCSServiceItemsIterate(&__block_literal_global_63);
  CFDictionaryRef v0 = (__CFArray *)PCSServiceItemsGetCFArraySortedByIndex_array;
  v1.CFIndex length = CFArrayGetCount((CFArrayRef)PCSServiceItemsGetCFArraySortedByIndex_array);
  v1.CFIndex location = 0;
  CFArraySortValues(v0, v1, (CFComparatorFunction)compareServiceItemIndex, 0);
}

void __PCSServiceItemsGetCFArraySortedByIndex_block_invoke_2(int a1, int a2, void *value)
{
}

uint64_t compareServiceItemIndex(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 24);
  int v3 = *(_DWORD *)(a2 + 24);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return -1;
  }
  else {
    return v5;
  }
}

void PCSServiceItemsGetInfoSortedByIndex(void *a1)
{
  id v6 = a1;
  if (PCSServiceItemsGetCFArraySortedByIndex_once != -1) {
    dispatch_once(&PCSServiceItemsGetCFArraySortedByIndex_once, &__block_literal_global_61);
  }
  CFArrayRef v1 = (const __CFArray *)PCSServiceItemsGetCFArraySortedByIndex_array;
  CFIndex Count = CFArrayGetCount((CFArrayRef)PCSServiceItemsGetCFArraySortedByIndex_array);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v1, i);
      (*((void (**)(id, void, void, void, void, void, void, void))v6 + 2))(v6, *((unsigned int *)ValueAtIndex + 6), ValueAtIndex[2], *((unsigned __int8 *)ValueAtIndex + 74), *((unsigned __int8 *)ValueAtIndex + 73), *((unsigned int *)ValueAtIndex + 7), ValueAtIndex[7], ValueAtIndex[6]);
    }
  }
}

uint64_t PCSServiceItemTypeIsShareableManatee(void *a1)
{
  uint64_t v2 = PCSServiceItemGetByName(a1);
  uint64_t v3 = v2;
  if (v2 && CFEqual(*(CFTypeRef *)(v2 + 16), @"Raw")) {
    return 0;
  }
  uint64_t result = PCSServiceItemTypeIsManatee(a1);
  if (result) {
    return *(unsigned char *)(v3 + 75) != 0;
  }
  return result;
}

uint64_t PCSServiceItemCanRoll(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result)
  {
    uint64_t v2 = result;
    return !CFEqual(*(CFTypeRef *)(result + 16), @"Raw") && *(unsigned char *)(v2 + 73) != 0;
  }
  return result;
}

uint64_t PCSServiceItemRequireAuthorship(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result) {
    return *(unsigned char *)(result + 76) != 0;
  }
  return result;
}

uint64_t PCSServiceItemGetFlagsByName(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result) {
    return *(unsigned int *)(result + 80);
  }
  return result;
}

uint64_t PCSServiceItemGetNumberByName(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

CFNumberRef PCSServiceItemGetIndexByName(void *a1)
{
  CFNumberRef result = (const __CFNumber *)PCSServiceItemGetByName(a1);
  if (result)
  {
    CFNumberRef result = (const __CFNumber *)*((void *)result + 4);
    if (result)
    {
      unsigned int valuePtr = 0;
      CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
  }
  return result;
}

uint64_t PCSServiceItemGetRollIntervalByName(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result) {
    return *(unsigned int *)(result + 28);
  }
  return result;
}

uint64_t PCSServiceItemGetViewHintByName(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

uint64_t PCSServiceItemGetAccessClassByName(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

uint64_t PCSServiceItemEscrowManateeIdentityByName(void *a1)
{
  uint64_t result = PCSServiceItemGetByName(a1);
  if (result) {
    return *(unsigned char *)(result + 77) != 0;
  }
  return result;
}

BOOL PCSServiceItemAllowKeyExportByIndex(int a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemGetByIndex_block_invoke;
  v3[3] = &unk_1E5E6ECB0;
  int v4 = a1;
  void v3[4] = &v5;
  PCSServiceItemsIterate(v3);
  uint64_t v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v1 && !*(unsigned char *)(v1 + 74) && *(unsigned char *)(v1 + 78) != 0;
}

void sub_1ACFD8BCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL PCSServiceItemAnonymousSharingByIndex(int a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemGetByIndex_block_invoke;
  v3[3] = &unk_1E5E6ECB0;
  int v4 = a1;
  void v3[4] = &v5;
  PCSServiceItemsIterate(v3);
  uint64_t v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v1 && *(unsigned char *)(v1 + 79) != 0;
}

void sub_1ACFD8CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t PCSServiceItemGetNameByIndex(int a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemGetByIndex_block_invoke;
  v3[3] = &unk_1E5E6ECB0;
  int v4 = a1;
  void v3[4] = &v5;
  PCSServiceItemsIterate(v3);
  uint64_t v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  if (v1) {
    return *(void *)(v1 + 16);
  }
  else {
    return 0;
  }
}

void sub_1ACFD8D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t PCSServiceItemGetViewHintByIndex(int a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemGetByIndex_block_invoke;
  v3[3] = &unk_1E5E6ECB0;
  int v4 = a1;
  void v3[4] = &v5;
  PCSServiceItemsIterate(v3);
  uint64_t v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  if (v1) {
    return *(void *)(v1 + 48);
  }
  else {
    return 0;
  }
}

void sub_1ACFD8E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFString *PCSServiceItemGetAccessGroupByIndex(int a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemGetByIndex_block_invoke;
  v3[3] = &unk_1E5E6ECB0;
  int v4 = a1;
  void v3[4] = &v5;
  PCSServiceItemsIterate(v3);
  uint64_t v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  if (!v1) {
    return 0;
  }
  if (*(void *)(v1 + 88)) {
    return *(__CFString **)(v1 + 88);
  }
  return kPCSDefaultKeychainGroup[0];
}

void sub_1ACFD8F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t PCSServiceItemGetNumberByIndex(int a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemGetByIndex_block_invoke;
  v3[3] = &unk_1E5E6ECB0;
  int v4 = a1;
  void v3[4] = &v5;
  PCSServiceItemsIterate(v3);
  uint64_t v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  if (v1) {
    return *(void *)(v1 + 32);
  }
  else {
    return 0;
  }
}

void sub_1ACFD8FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFString *PCSServiceItemGetAccessGroupByName(void *a1)
{
  uint64_t result = (__CFString *)PCSServiceItemGetByName(a1);
  if (result)
  {
    if (result[2].length) {
      return (__CFString *)result[2].length;
    }
    else {
      return kPCSDefaultKeychainGroup[0];
    }
  }
  return result;
}

CFIndex PCSServiceItemsCountByFlags(int a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  if (a1)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    void v3[2] = __PCSServiceItemsCountByFlags_block_invoke;
    v3[3] = &unk_1E5E6ECB0;
    int v4 = a1;
    void v3[4] = &v5;
    PCSServiceItemsIterate(v3);
    CFIndex v1 = v6[3];
  }
  else
  {
    CFIndex v1 = PCSServiceItemsCount() - 1;
  }
  _Block_object_dispose(&v5, 8);
  return v1;
}

void sub_1ACFD90E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __PCSServiceItemsCountByFlags_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  if ((*(_DWORD *)(a3 + 80) & *(_DWORD *)(result + 40)) != 0) {
    ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24);
  }
  return result;
}

id _PCSServiceItemsGetTooRolledServiceTypes()
{
  if (_PCSServiceItemsGetTooRolledServiceTypes_onceToken != -1) {
    dispatch_once(&_PCSServiceItemsGetTooRolledServiceTypes_onceToken, &__block_literal_global_74);
  }
  CFDictionaryRef v0 = (void *)_PCSServiceItemsGetTooRolledServiceTypes_tooRolled;
  return v0;
}

id _PCSServiceItemsGetNoRollStingrayServiceTypes()
{
  if (_PCSServiceItemsGetNoRollStingrayServiceTypes_once != -1) {
    dispatch_once(&_PCSServiceItemsGetNoRollStingrayServiceTypes_once, &__block_literal_global_80);
  }
  CFDictionaryRef v0 = (void *)_PCSServiceItemsGetNoRollStingrayServiceTypes_noRoll;
  return v0;
}

BOOL PCSServiceItemAllowSyntheticManateeSharing(int a1)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  void v3[2] = __PCSServiceItemGetByIndex_block_invoke;
  v3[3] = &unk_1E5E6ECB0;
  int v4 = a1;
  void v3[4] = &v5;
  PCSServiceItemsIterate(v3);
  uint64_t v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v1 && *(unsigned char *)(v1 + 74) && *(unsigned char *)(v1 + 75) == 0;
}

void sub_1ACFD94C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __PCSServiceItemsIterate_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t apply_block_2_4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

const void *__PCSServiceItemGetByName_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(const void **)(a3 + 40);
  id v6 = *(const void **)(a1 + 40);
  if (result) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    if (result != v6) {
      return result;
    }
    goto LABEL_9;
  }
  uint64_t result = (const void *)CFEqual(result, v6);
  if (result) {
LABEL_9:
  }
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a3;
  return result;
}

id _PCSGuitarfishDeriveRecoveryTokenWrap(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  uint64_t v7 = [v5 length];
  if (v7 == [v6 length])
  {
    uint64_t v8 = [v6 length];
    uint64_t v9 = [MEMORY[0x1E4F1CA58] dataWithLength:v8];
    uint64_t v10 = (char *)[v5 bytes];
    uint64_t v11 = (char *)[v6 bytes];
    id v12 = v9;
    for (CFIndex i = (unsigned char *)[v12 mutableBytes]; v8; --v8)
    {
      char v15 = *v10++;
      char v14 = v15;
      char v16 = *v11++;
      *i++ = v16 ^ v14;
    }
  }
  else if (a3)
  {
    uint64_t v17 = [v5 length];
    [v6 length];
    PCSErrorCreate(20, @"Mismatched lengths of input keys: %lu, %lu", v18, v19, v20, v21, v22, v23, v17);
    id v12 = 0;
    *a3 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v12 = 0;
  }

  return v12;
}

id _PCSGuitarfishDerivePTokenFromPRecoveryAndMnemonic(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x3032000000;
  uint64_t v20 = __Block_byref_object_copy__3;
  uint64_t v21 = __Block_byref_object_dispose__3;
  id v22 = 0;
  uint64_t v11 = 0;
  id v12 = &v11;
  uint64_t v13 = 0x3032000000;
  char v14 = __Block_byref_object_copy__3;
  char v15 = __Block_byref_object_dispose__3;
  id v16 = 0;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___PCSGuitarfishDerivePTokenFromPRecoveryAndMnemonic_block_invoke;
  v10[3] = &unk_1E5E6ED90;
  v10[4] = &v17;
  void v10[5] = &v11;
  PCSGuitarfishDeriveRecoveryKeyFromMnemonic((uint64_t)v6, v10);
  uint64_t v7 = (void *)v12[5];
  if (v7)
  {
    uint64_t v8 = 0;
    if (a3) {
      *a3 = v7;
    }
  }
  else
  {
    uint64_t v8 = _PCSGuitarfishDeriveRecoveryTokenWrap(v5, (void *)v18[5], a3);
  }
  _Block_object_dispose(&v11, 8);

  _Block_object_dispose(&v17, 8);
  return v8;
}

void sub_1ACFD9894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void PCSGuitarfishDeriveRecoveryKeyFromMnemonic(uint64_t a1, void *a2)
{
  v27[1] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  int v4 = +[MnemonicRepresentation seedFromMnemonic:a1];
  if (v4)
  {
    id v19 = v3;
    id v5 = [@"GuitarfishSalt" dataUsingEncoding:4];
    ccsha512_di();
    [v4 length];
    id v6 = v4;
    [v6 bytes];
    [v5 length];
    id v7 = v5;
    [v7 bytes];
    [@"key" lengthOfBytesUsingEncoding:4];
    [@"key" UTF8String];
    uint64_t v20 = v7;
    if (cchkdf())
    {
      uint64_t v8 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v9 = kPCSErrorDomain;
      uint64_t v23 = *MEMORY[0x1E4F28568];
      CFTypeRef v24 = @"Unable to derive key from input entropy";
      uint64_t v10 = objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", &v24, &v23, 1, v25);
      uint64_t v11 = [v8 errorWithDomain:v9 code:147 userInfo:v10];
      id v3 = v19;
      (*((void (**)(id, void, void, void *))v19 + 2))(v19, 0, 0, v11);
    }
    else
    {
      uint64_t v10 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9B8]), "initWithBytes:length:", v25, 32, v25);
      ccsha512_di();
      [v6 length];
      [v6 bytes];
      [v7 length];
      [v7 bytes];
      [@"pid" lengthOfBytesUsingEncoding:4];
      [@"pid" UTF8String];
      if (cchkdf())
      {
        id v16 = (void *)MEMORY[0x1E4F28C58];
        uint64_t v17 = kPCSErrorDomain;
        uint64_t v21 = *MEMORY[0x1E4F28568];
        id v22 = @"Unable to derive pid from input entropy";
        uint64_t v11 = objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", &v22, &v21, 1, v25);
        uint64_t v18 = [v16 errorWithDomain:v17 code:147 userInfo:v11];
        id v3 = v19;
        (*((void (**)(id, void *, void, void *))v19 + 2))(v19, v10, 0, v18);
      }
      else
      {
        uint64_t v11 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1C9B8]), "initWithBytes:length:", v25, 32, v25);
        id v3 = v19;
        (*((void (**)(id, void *, void *, void))v19 + 2))(v19, v10, v11, 0);
      }
    }
  }
  else
  {
    id v12 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v13 = kPCSErrorDomain;
    uint64_t v26 = *MEMORY[0x1E4F28568];
    v27[0] = @"unable to derive seed from stored mnemonic";
    char v14 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v27 forKeys:&v26 count:1];
    char v15 = [v12 errorWithDomain:v13 code:18 userInfo:v14];
    (*((void (**)(id, void, void, void *))v3 + 2))(v3, 0, 0, v15);
  }
}

__CFData *_PCSGuitarfishWrapDataWithAESKey(void *a1, void *a2, id *a3)
{
  CFDataRef v5 = a1;
  CFDataRef v6 = a2;
  if ([(__CFData *)v6 length] == 16
    || [(__CFData *)v6 length] == 24
    || [(__CFData *)v6 length] == 32)
  {
    uint64_t v17 = _PCSStingrayCopyEncryptedData(v6, v5);
    if (!v17) {
      _PCSNSError(a3, 12, @"unable to encrypt data with AES key", v12, v13, v14, v15, v16, v19);
    }
  }
  else
  {
    _PCSNSError(a3, 165, @"bad key length", v7, v8, v9, v10, v11, v19);
    uint64_t v17 = 0;
  }

  return v17;
}

__CFData *_PCSGuitarfishUnwrapDataWithAESKey(void *a1, void *a2, id *a3)
{
  CFDataRef v5 = a1;
  CFDataRef v6 = a2;
  if ([(__CFData *)v6 length] == 16
    || [(__CFData *)v6 length] == 24
    || [(__CFData *)v6 length] == 32)
  {
    uint64_t v17 = _PCSStingrayCopyDecryptedData(v6, v5);
    if (!v17) {
      _PCSNSError(a3, 13, @"unable to decrypt data with AES key", v12, v13, v14, v15, v16, v19);
    }
  }
  else
  {
    _PCSNSError(a3, 165, @"bad key length", v7, v8, v9, v10, v11, v19);
    uint64_t v17 = 0;
  }

  return v17;
}

id _PCSGuitarfishWrapKeyWithAESKey(void *a1, void *a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a1;
  size_t wrappedKeyLen = CCSymmetricWrappedSize(1u, [v6 length]);
  id v7 = (id) [objc_alloc(MEMORY[0x1E4F1CA58]) initWithLength:wrappedKeyLen];
  uint64_t v8 = (uint8_t *)[v7 mutableBytes];
  uint64_t v9 = (const uint8_t *)*MEMORY[0x1E4F14040];
  size_t v10 = *MEMORY[0x1E4F14048];
  id v11 = v5;
  uint64_t v12 = (const uint8_t *)[v11 bytes];
  size_t v13 = [v11 length];

  id v14 = v6;
  uint64_t v15 = (const uint8_t *)[v14 bytes];
  size_t v16 = [v14 length];

  uint64_t v17 = CCSymmetricKeyWrap(1u, v9, v10, v12, v13, v15, v16, v8, &wrappedKeyLen);
  if (v17)
  {
    uint64_t v18 = v17;
    uint64_t v19 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v30 = v18;
      _os_log_impl(&dword_1ACF98000, v19, OS_LOG_TYPE_DEFAULT, "Unable to wrap data: %d", buf, 8u);
    }

    if (a3)
    {
      PCSErrorCreate(12, @"Unable to wrap data: %d", v20, v21, v22, v23, v24, v25, v18);
      id v26 = 0;
      *a3 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v26 = 0;
    }
  }
  else
  {
    id v26 = v7;
  }

  return v26;
}

id _PCSGuitarfishUnwrapKeyWithAESKey(void *a1, void *a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a1;
  size_t rawKeyLen = CCSymmetricUnwrappedSize(1u, [v6 length]);
  id v7 = (id) [objc_alloc(MEMORY[0x1E4F1CA58]) initWithLength:rawKeyLen];
  uint64_t v8 = (uint8_t *)[v7 mutableBytes];
  uint64_t v9 = (const uint8_t *)*MEMORY[0x1E4F14040];
  size_t v10 = *MEMORY[0x1E4F14048];
  id v11 = v5;
  uint64_t v12 = (const uint8_t *)[v11 bytes];
  size_t v13 = [v11 length];

  id v14 = v6;
  uint64_t v15 = (const uint8_t *)[v14 bytes];
  size_t v16 = [v14 length];

  uint64_t v17 = CCSymmetricKeyUnwrap(1u, v9, v10, v12, v13, v15, v16, v8, &rawKeyLen);
  if (v17)
  {
    uint64_t v18 = v17;
    uint64_t v19 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v30 = v18;
      _os_log_impl(&dword_1ACF98000, v19, OS_LOG_TYPE_DEFAULT, "Unable to unwrap data: %d", buf, 8u);
    }

    if (a3)
    {
      PCSErrorCreate(13, @"Unable to unwrap data: %d", v20, v21, v22, v23, v24, v25, v18);
      id v26 = 0;
      *a3 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v26 = 0;
    }
  }
  else
  {
    id v26 = v7;
  }

  return v26;
}

void PCSGuitarfishGetRecoveryTokenInfo(void *a1, void *a2)
{
  v152[2] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v10 = a2;
  uint64_t v133 = 0;
  id v134 = &v133;
  uint64_t v135 = 0x3032000000;
  uint64_t v136 = __Block_byref_object_copy__3;
  int v137 = __Block_byref_object_dispose__3;
  id v138 = 0;
  uint64_t v129 = 0;
  id v130 = &v129;
  uint64_t v131 = 0x2020000000;
  uint64_t v132 = 0;
  if (!v3)
  {
    uint64_t v18 = 0;
LABEL_9:
    uint64_t v15 = PCSErrorCreate(121, @"Missing DSID in parameters", v4, v5, v6, v7, v8, v9, v86);
    (*((void (**)(id, uint64_t, uint64_t, void, void, void *))v10 + 2))(v10, 2, v18, 0, 0, v15);
    goto LABEL_17;
  }
  id v11 = [v3 objectForKey:@"forcedMnemonicForTesting"];
  BOOL v12 = v11 == 0;

  if (!v12)
  {
    size_t v13 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1ACF98000, v13, OS_LOG_TYPE_DEFAULT, "PCSGetRecoveryTokenInfo using provided mnemonic", buf, 2u);
    }

    uint64_t v14 = [v3 objectForKey:@"forcedMnemonicForTesting"];
    uint64_t v15 = 0;
    size_t v16 = v134[5];
    v134[5] = v14;
    goto LABEL_6;
  }
  uint64_t v19 = [v3 objectForKeyedSubscript:kPCSSetupDSID[0]];
  uint64_t v15 = v19;
  if (!v19)
  {
    uint64_t v18 = v130[3];
    goto LABEL_9;
  }
  if (!PCSCurrentPersonaMatchesDSID(v19))
  {
    uint64_t v32 = v130[3];
    uint64_t v33 = PCSErrorCreate(152, @"Current persona does not match chosen dsid", v20, v21, v22, v23, v24, v25, v86);
    (*((void (**)(id, uint64_t, uint64_t, void, void, void *))v10 + 2))(v10, 2, v32, 0, 0, v33);

    goto LABEL_17;
  }
  dispatch_semaphore_t v26 = dispatch_semaphore_create(0);
  v125[0] = MEMORY[0x1E4F143A8];
  v125[1] = 3221225472;
  v125[2] = __PCSGuitarfishGetRecoveryTokenInfo_block_invoke;
  v125[3] = &unk_1E5E6EDB8;
  CFDataRef v127 = &v133;
  long long v128 = &v129;
  long long v27 = v26;
  uint64_t v126 = v27;
  _PCSGuitarfishGetKeychainItem(@"RecoveryToken", v15, v125);
  dispatch_semaphore_wait(v27, 0xFFFFFFFFFFFFFFFFLL);
  *(void *)long long buf = 0;
  dispatch_semaphore_t v120 = buf;
  uint64_t v121 = 0x3032000000;
  uint64_t v122 = __Block_byref_object_copy__3;
  CFDataRef v123 = __Block_byref_object_dispose__3;
  id v124 = 0;
  dispatch_semaphore_t v28 = dispatch_semaphore_create(0);

  v115[0] = MEMORY[0x1E4F143A8];
  v115[1] = 3221225472;
  v115[2] = __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_120;
  v115[3] = &unk_1E5E6EDB8;
  uint64_t v117 = buf;
  CFDictionaryRef v118 = &v129;
  size_t v16 = v28;
  unint64_t v116 = v16;
  _PCSGuitarfishGetKeychainItem(@"WrappingKey", v15, v115);
  dispatch_semaphore_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
  if (*((void *)v120 + 5) && v134[5]) {
    goto LABEL_14;
  }
  CFDataRef v114 = 0;
  v151[0] = kPCSSetupDSID[0];
  v151[1] = kPCSSetupGuitarfish[0];
  v152[0] = v15;
  v152[1] = MEMORY[0x1E4F1CC38];
  uint64_t v34 = (void *)__PCSCopyStingrayInfo(0, (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v152 forKeys:v151 count:2], &v114);
  id v35 = v34;
  id v36 = v114;
  if (v114 || !v34)
  {
    v130[3] |= 2uLL;
    (*((void (**)(id, uint64_t))v10 + 2))(v10, 2);
LABEL_32:

LABEL_63:
    _Block_object_dispose(buf, 8);

    goto LABEL_17;
  }
  uint64_t v37 = *MEMORY[0x1E4F59B88];
  uint64_t v38 = [v34 objectForKeyedSubscript:*MEMORY[0x1E4F59B88]];
  BOOL v39 = v38 == 0;

  if (v39)
  {
    v130[3] |= 2uLL;
    CFErrorRef v53 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v144) = 0;
      _os_log_impl(&dword_1ACF98000, v53, OS_LOG_TYPE_DEFAULT, "No Guitarfish Primary Record to decode", (uint8_t *)&v144, 2u);
    }

    uint64_t v54 = v130[3];
    id v36 = PCSErrorCreate(238, @"No Primary Guitarfish Record. Account needs PCSGuitarfishSetupIdentities or migration.", v55, v56, v57, v58, v59, v60, v86);
    (*((void (**)(id, uint64_t, uint64_t, void, void, void *))v10 + 2))(v10, 2, v54, 0, 0, v36);
    goto LABEL_32;
  }
  uint64_t v40 = [v35 objectForKeyedSubscript:v37];
  uint64_t v41 = [v40 objectForKeyedSubscript:kPCSSecureBackupCFClientMetadataKey[0]];
  uint64_t v42 = [v41 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
  uint64_t v43 = [v42 objectForKeyedSubscript:@"SecureBackupWrappedKeys"];

  uint64_t v44 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v45 = [v43 base64EncodedStringWithOptions:0];
    LODWORD(v144) = 138412290;
    *(void *)((char *)&v144 + 4) = v45;
    _os_log_impl(&dword_1ACF98000, v44, OS_LOG_TYPE_DEFAULT, "OuterBlob: %@", (uint8_t *)&v144, 0xCu);
  }
  if (!v43)
  {
    uint64_t v61 = v130[3] | 2;
    v130[3] = v61;
    uint64_t v62 = PCSErrorCreate(200, @"Failed to decode Outer blob, potential missing guitarfish record", v46, v47, v48, v49, v50, v51, v86);
    (*((void (**)(id, uint64_t, uint64_t, void, void, void *))v10 + 2))(v10, 1, v61, 0, 0, v62);
LABEL_61:

LABEL_62:
    goto LABEL_63;
  }
  if (*((void *)v120 + 5))
  {
    id v52 = v134;
LABEL_51:
    if (!v52[5])
    {
      *(void *)&long long v144 = 0;
      *((void *)&v144 + 1) = &v144;
      uint64_t v145 = 0x3032000000;
      CFTypeRef v146 = __Block_byref_object_copy__3;
      int v147 = __Block_byref_object_dispose__3;
      id v148 = 0;
      dispatch_semaphore_t v81 = dispatch_semaphore_create(0);

      uint64_t v82 = (void *)*((void *)v120 + 5);
      v94[0] = MEMORY[0x1E4F143A8];
      v94[1] = 3221225472;
      v94[2] = __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_134;
      v94[3] = &unk_1E5E6EE30;
      uint64_t v96 = &v133;
      dispatch_semaphore_t v97 = &v129;
      CFDictionaryRef v98 = &v144;
      size_t v16 = v81;
      CFAllocatorRef v95 = v16;
      _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(v82, v43, v94);
      dispatch_semaphore_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
      uint64_t v83 = *(void *)(*((void *)&v144 + 1) + 40);
      if (v83)
      {
        (*((void (**)(id, uint64_t, uint64_t, void, void, void))v10 + 2))(v10, 1, v130[3], 0, 0, *(void *)(*((void *)&v144 + 1) + 40));
      }
      else if (*((void *)v120 + 5) && (v130[3] & 0x20) != 0)
      {
        dispatch_semaphore_t v84 = dispatch_semaphore_create(0);

        __int16 v85 = (void *)*((void *)v120 + 5);
        v91[0] = MEMORY[0x1E4F143A8];
        v91[1] = 3221225472;
        v91[2] = __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_136;
        v91[3] = &unk_1E5E6EE58;
        uint64_t v93 = &v129;
        size_t v16 = v84;
        CFBooleanRef v92 = v16;
        _PCSGuitarfishSetKeychainItem(@"WrappingKey", v15, v85, v91);
        dispatch_semaphore_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
      }
      _Block_object_dispose(&v144, 8);

      if (v83) {
        goto LABEL_62;
      }
      id v52 = v134;
    }
    goto LABEL_52;
  }
  unint64_t v149 = kPCSSetupDSID[0];
  uint64_t v150 = v15;
  uint64_t v62 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v150 forKeys:&v149 count:1];
  CFTypeRef v113 = 0;
  CFTypeRef v63 = PCSIdentitySetCreate((const __CFDictionary *)v62, 0, &v113);
  if (v113 || !v63)
  {
    uint64_t v73 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v144) = 138412290;
      *(void *)((char *)&v144 + 4) = v113;
      _os_log_impl(&dword_1ACF98000, v73, OS_LOG_TYPE_DEFAULT, "no identity set available, unable to attempt silent repair: %@", (uint8_t *)&v144, 0xCu);
    }

    v130[3] |= 0x200uLL;
  }
  else
  {
    uint64_t v86 = (uint64_t)v63;
    *(void *)&long long v144 = 0;
    *((void *)&v144 + 1) = &v144;
    uint64_t v145 = 0x3032000000;
    CFTypeRef v146 = __Block_byref_object_copy__3;
    int v147 = __Block_byref_object_dispose__3;
    id v148 = 0;
    uint64_t v107 = 0;
    int v108 = &v107;
    uint64_t v109 = 0x3032000000;
    CFDataRef v110 = __Block_byref_object_copy__3;
    CFMutableDictionaryRef v111 = __Block_byref_object_dispose__3;
    id v112 = 0;
    v106[0] = MEMORY[0x1E4F143A8];
    v106[1] = 3221225472;
    v106[2] = __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_127;
    v106[3] = &unk_1E5E6EDE0;
    v106[4] = &v144;
    v106[5] = &v107;
    _PCSBackupGuitarfishDecodeOuterRecord(v43, v106);
    uint64_t v64 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v65 = objc_msgSend(*(id *)(*((void *)&v144 + 1) + 40), "base64EncodedStringWithOptions:", 0, v86);
      LODWORD(v141) = 138412290;
      *(void *)((char *)&v141 + 4) = v65;
      _os_log_impl(&dword_1ACF98000, v64, OS_LOG_TYPE_DEFAULT, "wrappedKey: %@", (uint8_t *)&v141, 0xCu);
    }
    id v71 = (id *)(v108 + 5);
    uint64_t v72 = v108[5];
    if (v72)
    {
      obuint64_t j = (id)v108[5];
      _PCSNSError(&obj, 200, @"Failed to decode Outer blob", v66, v67, v68, v69, v70, v86);
      objc_storeStrong(v71, obj);
      v130[3] |= 2uLL;
      (*((void (**)(id, uint64_t))v10 + 2))(v10, 1);
    }
    else if (*(void *)(*((void *)&v144 + 1) + 40))
    {
      *(void *)&long long v141 = 0;
      *((void *)&v141 + 1) = &v141;
      uint64_t v142 = 0x2020000000;
      uint64_t v143 = 0;
      uint64_t v101 = 0;
      v102 = &v101;
      uint64_t v103 = 0x2020000000;
      uint64_t v104 = 0;
      id v139 = kPCSSetupService[0];
      uint64_t v140 = kPCSServiceEscrow;
      uint64_t v74 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v140 forKeys:&v139 count:1];
      v100[0] = MEMORY[0x1E4F143A8];
      v100[1] = 3221225472;
      v100[2] = __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_132;
      v100[3] = &unk_1E5E6EE08;
      v100[4] = &v101;
      v100[5] = &v144;
      v100[6] = &v141;
      PCSIdentitySetEnumerateIdentities(v86, v74, v100);
      uint64_t v75 = v102[3];
      if (v75)
      {
        CFDictionaryRef v76 = *((void *)v120 + 5);
        *((void *)v120 + 5) = v75;
      }
      else
      {
        v130[3] |= 2uLL;
        CFDictionaryRef v76 = pcsLogObjForScope("Guitarfish");
        if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)CFDataRef v99 = 0;
          _os_log_impl(&dword_1ACF98000, v76, OS_LOG_TYPE_DEFAULT, "unable to unwrap wrapping key with escrow identities", v99, 2u);
        }
      }

      _Block_object_dispose(&v101, 8);
      _Block_object_dispose(&v141, 8);
    }
    _Block_object_dispose(&v107, 8);

    _Block_object_dispose(&v144, 8);
    if (v72) {
      goto LABEL_61;
    }
  }

  id v52 = v134;
  if (*((void *)v120 + 5)) {
    goto LABEL_51;
  }
LABEL_52:
  uint64_t v77 = v130[3];
  if (!v52[5])
  {
    uint64_t v62 = PCSErrorCreate(39, @"no stored mnemonic available, silent recovery failed, needs repair", v46, v47, v48, v49, v50, v51, v86);
    (*((void (**)(id, uint64_t, uint64_t, void, void, void *))v10 + 2))(v10, 1, v77, 0, 0, v62);
    goto LABEL_61;
  }
  if ((v77 & 0x10) != 0)
  {
    dispatch_semaphore_t v78 = dispatch_semaphore_create(0);

    CFDictionaryRef v79 = [(id)v134[5] componentsJoinedByString:@" "];
    uint64_t v80 = [v79 dataUsingEncoding:4];
    v88[0] = MEMORY[0x1E4F143A8];
    v88[1] = 3221225472;
    v88[2] = __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_141;
    v88[3] = &unk_1E5E6EE58;
    CFTypeID v90 = &v129;
    size_t v16 = v78;
    CFIndex v89 = v16;
    _PCSGuitarfishSetKeychainItem(@"RecoveryToken", v15, v80, v88);

    dispatch_semaphore_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
  }

LABEL_14:
  _Block_object_dispose(buf, 8);

LABEL_6:
  *(void *)long long buf = 0;
  dispatch_semaphore_t v120 = buf;
  uint64_t v121 = 0x3032000000;
  uint64_t v122 = __Block_byref_object_copy__3;
  CFDataRef v123 = __Block_byref_object_dispose__3;
  id v124 = 0;
  *(void *)&long long v144 = 0;
  *((void *)&v144 + 1) = &v144;
  uint64_t v145 = 0x3032000000;
  CFTypeRef v146 = __Block_byref_object_copy__3;
  int v147 = __Block_byref_object_dispose__3;
  id v148 = 0;
  uint64_t v17 = v134[5];
  v87[0] = MEMORY[0x1E4F143A8];
  v87[1] = 3221225472;
  v87[2] = __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_142;
  v87[3] = &unk_1E5E6EE80;
  v87[4] = &v144;
  v87[5] = &v129;
  v87[6] = buf;
  PCSGuitarfishDeriveRecoveryKeyFromMnemonic(v17, v87);
  if (*((void *)v120 + 5))
  {
    (*((void (**)(id, uint64_t, uint64_t, void, void))v10 + 2))(v10, 1, v130[3], 0, 0);
  }
  else
  {
    uint64_t v29 = v130[3];
    uint64_t v30 = v134[5];
    uint64_t v31 = [*(id *)(*((void *)&v144 + 1) + 40) base64EncodedStringWithOptions:0];
    (*((void (**)(id, void, uint64_t, uint64_t, void *, void))v10 + 2))(v10, 0, v29, v30, v31, 0);
  }
  _Block_object_dispose(&v144, 8);

  _Block_object_dispose(buf, 8);
LABEL_17:

  _Block_object_dispose(&v129, 8);
  _Block_object_dispose(&v133, 8);
}

void sub_1ACFDB220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a45, 8);
  _Block_object_dispose(&STACK[0x2C0], 8);
  _Block_object_dispose(&a56, 8);
  _Block_object_dispose((const void *)(v71 - 240), 8);
  _Block_object_dispose(&a71, 8);
  _Block_object_dispose(&STACK[0x260], 8);
  _Block_object_dispose(&STACK[0x280], 8);
  _Unwind_Resume(a1);
}

void _PCSGuitarfishGetKeychainItem(void *a1, void *a2, void *a3)
{
  v28[9] = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  uint64_t v7 = *MEMORY[0x1E4F3B998];
  uint64_t v8 = *MEMORY[0x1E4F3BD08];
  v27[0] = *MEMORY[0x1E4F3B978];
  v27[1] = v8;
  v28[0] = v7;
  v28[1] = MEMORY[0x1E4F1CC38];
  uint64_t v9 = *MEMORY[0x1E4F3B838];
  void v27[2] = *MEMORY[0x1E4F3B550];
  v27[3] = v9;
  v28[2] = kPCSDefaultKeychainGroup[0];
  v28[3] = kPCSGuitarfishKeychainSecurityDomain;
  uint64_t v10 = *MEMORY[0x1E4F3B848];
  v27[4] = *MEMORY[0x1E4F3B5C0];
  v27[5] = v10;
  v28[4] = v6;
  v28[5] = v5;
  uint64_t v11 = *MEMORY[0x1E4F3BB90];
  uint64_t v12 = *MEMORY[0x1E4F3BC68];
  v27[6] = *MEMORY[0x1E4F3BB80];
  v27[7] = v12;
  v28[6] = v11;
  v28[7] = MEMORY[0x1E4F1CC38];
  v27[8] = *MEMORY[0x1E4F3BC70];
  v28[8] = MEMORY[0x1E4F1CC38];
  size_t v13 = (void *)MEMORY[0x1E4F1C9E8];
  uint64_t v14 = a3;
  CFDictionaryRef v15 = [v13 dictionaryWithObjects:v28 forKeys:v27 count:9];
  CFTypeRef result = 0;
  uint64_t v16 = SecItemCopyMatching(v15, &result);
  uint64_t v17 = (void *)result;
  if (v16)
  {
    uint64_t v18 = v16;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      _PCSGuitarfishGetKeychainItem_cold_1();
    }
    uint64_t v25 = PCSErrorCreate(39, @"Missing keychain item: %d", v19, v20, v21, v22, v23, v24, v18);
    v14[2](v14, 0, v25);
  }
  else
  {
    uint64_t v25 = [(id)result objectForKeyedSubscript:*MEMORY[0x1E4F3BD38]];
    ((void (**)(id, void *, void *))v14)[2](v14, v25, 0);
  }
}

void __PCSGuitarfishGetRecoveryTokenInfo_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = v6;
  if (!v5 || v6)
  {
    uint64_t v14 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 138412290;
      uint64_t v16 = (uint64_t)v7;
      _os_log_impl(&dword_1ACF98000, v14, OS_LOG_TYPE_DEFAULT, "unable to recover token from keychain: %@", (uint8_t *)&v15, 0xCu);
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) |= 0x10uLL;
  }
  else
  {
    uint64_t v8 = (void *)[[NSString alloc] initWithData:v5 encoding:4];
    uint64_t v9 = [v8 componentsSeparatedByString:@" "];
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    uint64_t v12 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) count];
      int v15 = 134217984;
      uint64_t v16 = v13;
      _os_log_impl(&dword_1ACF98000, v12, OS_LOG_TYPE_DEFAULT, "recovered token from keychain of length: %lu", (uint8_t *)&v15, 0xCu);
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_120(uint64_t a1, void *a2, void *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = v7;
  if (!v6 || v7)
  {
    uint64_t v10 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      uint64_t v12 = v8;
      _os_log_impl(&dword_1ACF98000, v10, OS_LOG_TYPE_DEFAULT, "unable to recover wrapping key from keychain: %@", (uint8_t *)&v11, 0xCu);
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) |= 0x20uLL;
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    uint64_t v9 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "recovered wrapping key from keychain of length", (uint8_t *)&v11, 2u);
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_127(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6)
{
  id v10 = a4;
  id v9 = a6;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a4);
  if (v9) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a6);
  }
}

void __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_132(void *a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    uint64_t v4 = PCSIdentityGetPublicKey(a2);
    *(void *)(*(void *)(a1[4] + 8) + 24) = PCSServiceIdentityCopyUnwrappedKey(a2, *(const __CFData **)(*(void *)(a1[5] + 8) + 40), (const void **)(*(void *)(a1[6] + 8) + 24));
    if (*(void *)(*(void *)(a1[6] + 8) + 24))
    {
      id v5 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v6 = *(void *)(*(void *)(a1[6] + 8) + 24);
        int v10 = 138412546;
        int v11 = v4;
        __int16 v12 = 2112;
        uint64_t v13 = v6;
        _os_log_impl(&dword_1ACF98000, v5, OS_LOG_TYPE_DEFAULT, "encountered unwrapping error with possible identity %@: %@", (uint8_t *)&v10, 0x16u);
      }

      uint64_t v7 = *(void *)(a1[6] + 8);
      uint64_t v8 = *(const void **)(v7 + 24);
      if (v8)
      {
        *(void *)(v7 + 24) = 0;
        CFRelease(v8);
      }
    }
    else if (*(void *)(*(void *)(a1[4] + 8) + 24))
    {
      id v9 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = 138412290;
        int v11 = v4;
        _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "successfully unwrapped data with identity %@", (uint8_t *)&v10, 0xCu);
      }
    }
  }
}

void __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_134(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v9 = a3;
  id v10 = a6;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  if (v10)
  {
    int v11 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v12 = 0;
      _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, "Unable to recover recovery token from inner blob", v12, 2u);
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) |= 2uLL;
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), a6);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void _PCSGuitarfishSetKeychainItem(void *a1, void *a2, void *a3, void *a4)
{
  v56[9] = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v52 = a4;
  uint64_t v10 = *MEMORY[0x1E4F3B978];
  uint64_t v11 = *MEMORY[0x1E4F3B998];
  uint64_t v12 = *MEMORY[0x1E4F3BD08];
  v55[0] = *MEMORY[0x1E4F3B978];
  v55[1] = v12;
  v56[0] = v11;
  v56[1] = MEMORY[0x1E4F1CC38];
  uint64_t v13 = *MEMORY[0x1E4F3B878];
  uint64_t v14 = *MEMORY[0x1E4F3B558];
  v55[2] = *MEMORY[0x1E4F3B878];
  v55[3] = v14;
  uint64_t v15 = *MEMORY[0x1E4F3B570];
  void v56[2] = MEMORY[0x1E4F1CC28];
  v56[3] = v15;
  uint64_t v16 = *MEMORY[0x1E4F3B550];
  void v55[4] = *MEMORY[0x1E4F3BD38];
  v55[5] = v16;
  id v53 = v9;
  v56[4] = v9;
  v56[5] = kPCSDefaultKeychainGroup[0];
  uint64_t v17 = *MEMORY[0x1E4F3B5C0];
  uint64_t v18 = *MEMORY[0x1E4F3B848];
  v55[6] = *MEMORY[0x1E4F3B5C0];
  v55[7] = v18;
  id v54 = v8;
  v56[6] = v8;
  v56[7] = v7;
  uint64_t v19 = *MEMORY[0x1E4F3B838];
  v55[8] = *MEMORY[0x1E4F3B838];
  v56[8] = kPCSGuitarfishKeychainSecurityDomain;
  CFDictionaryRef v20 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v56 forKeys:v55 count:9];
  uint64_t v21 = SecItemAdd(v20, 0);
  if (v21 == -25299)
  {
    id v51 = v7;
    id v26 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    long long v27 = [(__CFDictionary *)v20 objectForKeyedSubscript:v10];
    [v26 setObject:v27 forKeyedSubscript:v10];

    dispatch_semaphore_t v28 = [(__CFDictionary *)v20 objectForKeyedSubscript:v13];
    [v26 setObject:v28 forKeyedSubscript:v13];

    uint64_t v29 = [(__CFDictionary *)v20 objectForKeyedSubscript:v16];
    [v26 setObject:v29 forKeyedSubscript:v16];

    uint64_t v30 = [(__CFDictionary *)v20 objectForKeyedSubscript:v17];
    [v26 setObject:v30 forKeyedSubscript:v17];

    uint64_t v31 = [(__CFDictionary *)v20 objectForKeyedSubscript:v18];
    [v26 setObject:v31 forKeyedSubscript:v18];

    uint64_t v32 = [(__CFDictionary *)v20 objectForKeyedSubscript:v12];
    [v26 setObject:v32 forKeyedSubscript:v12];

    uint64_t v33 = [(__CFDictionary *)v20 objectForKeyedSubscript:v19];
    [v26 setObject:v33 forKeyedSubscript:v19];

    uint64_t v34 = (void *)[(__CFDictionary *)v20 mutableCopy];
    [v34 setObject:0 forKeyedSubscript:v10];
    uint64_t v35 = SecItemUpdate((CFDictionaryRef)v26, (CFDictionaryRef)v34);
    if (v35)
    {
      uint64_t v36 = v35;
      id v7 = v51;
      uint64_t v23 = v52;
      uint64_t v25 = v53;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        _PCSGuitarfishSetKeychainItem_cold_2();
      }
      uint64_t v43 = PCSErrorCreate(39, @"Missing keychain item: %d", v37, v38, v39, v40, v41, v42, v36);
      (*((void (**)(id, void *))v52 + 2))(v52, v43);
    }
    else
    {
      uint64_t v23 = v52;
      (*((void (**)(id, void))v52 + 2))(v52, 0);
      id v7 = v51;
      uint64_t v25 = v53;
    }

    uint64_t v24 = v54;
  }
  else
  {
    uint64_t v22 = v21;
    if (v21)
    {
      uint64_t v25 = v53;
      uint64_t v24 = v54;
      uint64_t v23 = v52;
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
        _PCSGuitarfishSetKeychainItem_cold_1();
      }
      uint64_t v50 = PCSErrorCreate(4, @"failed to store in keychain: %d", v44, v45, v46, v47, v48, v49, v22);
      (*((void (**)(id, void *))v52 + 2))(v52, v50);
    }
    else
    {
      uint64_t v23 = v52;
      (*((void (**)(id, void))v52 + 2))(v52, 0);
      uint64_t v25 = v53;
      uint64_t v24 = v54;
    }
  }
}

void __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_136(uint64_t a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = pcsLogObjForScope("Guitarfish");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v7 = 138412290;
      id v8 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "unable to save wrapping key to keychain: %@", (uint8_t *)&v7, 0xCu);
    }

    uint64_t v6 = 32;
  }
  else
  {
    if (v5)
    {
      LOWORD(v7) = 0;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "saved wrapping key to keychain successfully", (uint8_t *)&v7, 2u);
    }

    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) &= ~0x20uLL;
    uint64_t v6 = 1024;
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) |= v6;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_141(uint64_t a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = pcsLogObjForScope("Guitarfish");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v7 = 138412290;
      id v8 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "unable to save recovery token to keychain: %@", (uint8_t *)&v7, 0xCu);
    }

    uint64_t v6 = 16;
  }
  else
  {
    if (v5)
    {
      LOWORD(v7) = 0;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "saved recovery token to keychain successfully", (uint8_t *)&v7, 2u);
    }

    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) &= ~0x10uLL;
    uint64_t v6 = 2048;
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) |= v6;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishGetRecoveryTokenInfo_block_invoke_142(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v8 = a3;
  id v7 = a4;
  objc_storeStrong((id *)(*(void *)(a1[4] + 8) + 40), a3);
  if (v7)
  {
    *(void *)(*(void *)(a1[5] + 8) + 24) |= 0x10uLL;
    objc_storeStrong((id *)(*(void *)(a1[6] + 8) + 40), a4);
  }
}

uint64_t (**_PCSUpdateStingrayForwardTableForTesting(uint64_t (**result)()))()
{
  savedPCSStingrayForwardTable = (uint64_t)_PCSStingrayForwardTable;
  _PCSStingrayForwardTable = *result;
  return result;
}

uint64_t (**_PCSUpdateMigrateToiCDPForwardTableForTesting(uint64_t (**result)()))()
{
  savedPCSMigrateToiCDPForwardTable = (uint64_t)_PCSMigrateToiCDPForwardTable;
  _PCSMigrateToiCDPForwardTable = *result;
  return result;
}

void PCSGuitarfishResetProtectedData(void *a1, void *a2)
{
  uint64_t v248 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = a2;
  BOOL v5 = [AAFAnalyticsEventPCS alloc];
  uint64_t v6 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
  id v7 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
  id v8 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
  LOBYTE(v18_Block_object_dispose(&a9, 8) = 1;
  uint64_t v9 = -[AAFAnalyticsEventPCS initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:](v5, "initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:", 0, v6, v7, v8, @"com.apple.pcs.resetProtectedData", 0);

  unint64_t v241 = 0;
  uint64_t v242 = 0;
  id v16 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  if (v3)
  {
    uint64_t v17 = [v3 objectForKeyedSubscript:kPCSSetupDSID[0]];
    if (v17)
    {
      uint64_t v18 = v17;
      if (PCSCurrentPersonaMatchesDSID(v17))
      {
        uint64_t v25 = [v3 objectForKeyedSubscript:kPCSAuthenticateAppleID[0]];

        if (v25)
        {
          id v26 = [v3 objectForKeyedSubscript:kPCSSetupPassword[0]];

          if (v26)
          {
            long long v27 = [v3 objectForKeyedSubscript:kPCSSetupRawPassword[0]];

            if (v27)
            {
              dispatch_semaphore_t v28 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];

              if (v28)
              {
                uint64_t v29 = [v3 objectForKeyedSubscript:kPCSSetupPasswordGeneration[0]];

                if (v29)
                {
                  uint64_t v30 = [v3 objectForKeyedSubscript:kPCSSetupVerifierIterationCount[0]];

                  if (v30)
                  {
                    uint64_t v31 = [v3 objectForKeyedSubscript:kPCSSetupVerifierProtocol[0]];

                    if (v31)
                    {
                      uint64_t v32 = [v3 objectForKeyedSubscript:kPCSSetupVerifierSalt[0]];

                      if (v32)
                      {
                        uint64_t v33 = [v3 objectForKeyedSubscript:kPCSShouldJoinCDP[0]];
                        int v34 = [v33 isEqualToNumber:MEMORY[0x1E4F1CC38]];

                        if (v34)
                        {
                          uint64_t v35 = pcsLogObjForScope("guitarfish-reset-protected-data");
                          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl(&dword_1ACF98000, v35, OS_LOG_TYPE_DEFAULT, "Will join CDP", buf, 2u);
                          }
                        }
                        id v240 = 0;
                        BOOL v36 = performStingrayRecovery(v18, &v240);
                        id v37 = v240;
                        uint64_t v38 = pcsLogObjForScope("guitarfish-reset-protected-data");
                        uint64_t v224 = (uint64_t)v37;
                        if (!v36 || v37)
                        {
                          uint64_t v39 = v38;
                          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
                            PCSGuitarfishResetProtectedData_cold_14(v224, v39, v57, v58, v59, v60, v61, v62);
                          }
                        }
                        else
                        {
                          uint64_t v39 = v38;
                          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl(&dword_1ACF98000, v39, OS_LOG_TYPE_DEFAULT, "Successfully recovered Stingray data", buf, 2u);
                          }
                        }

                        v225 = [AAFAnalyticsEventPCS alloc];
                        v227 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
                        CFTypeRef v63 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
                        uint64_t v64 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
                        LOBYTE(v18_Block_object_dispose(&a9, 8) = 1;
                        uint64_t v226 = -[AAFAnalyticsEventPCS initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:](v225, "initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:", 0, v227, v63, v64, @"com.apple.pcs.deleteGuitarfishRecord", 0);

                        v239 = 0;
                        LODWORD(v63) = deleteRecord(v18, kPCSSetupGuitarfish[0], &v239);
                        uint64_t v65 = v239;
                        uint64_t v66 = pcsLogObjForScope("guitarfish-reset-protected-data");
                        if (!v63 || v65)
                        {
                          uint64_t v87 = v66;
                          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)) {
                            PCSGuitarfishResetProtectedData_cold_13();
                          }

                          v241 |= 0x2000uLL;
                          uint64_t v242 = 2;
                          CFDictionaryRef v88 = objc_msgSend(NSNumber, "numberWithLong:");
                          [v16 setObject:v88 forKeyedSubscript:@"flags"];

                          CFIndex v89 = [NSNumber numberWithLong:v242];
                          [v16 setObject:v89 forKeyedSubscript:@"status"];

                          uint64_t v96 = v239;
                          if (!v239)
                          {
                            uint64_t v96 = PCSErrorCreate(219, @"Failed to delete Guitarfish record", v90, v91, v92, v93, v94, v95, v188);
                          }
                          dispatch_semaphore_t v97 = (void *)v226;
                          +[PCSAnalyticsReporterRTC sendMetricWithEvent:v226 success:0 error:v96];
                          v4[2](v4, 2, 0x2000, v16, v96);
                          uint64_t v49 = (void *)v224;
                          goto LABEL_151;
                        }
                        uint64_t v67 = v66;
                        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_1ACF98000, v67, OS_LOG_TYPE_DEFAULT, "successfully deleted guitarfish record", buf, 2u);
                        }

                        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v226 success:1 error:0];
                        v222 = [AAFAnalyticsEventPCS alloc];
                        v228 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
                        uint64_t v68 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
                        uint64_t v69 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
                        LOBYTE(v18_Block_object_dispose(&a9, 8) = 1;
                        uint64_t v223 = -[AAFAnalyticsEventPCS initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:](v222, "initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:", 0, v228, v68, v69, @"com.apple.pcs.deleteTokenRecord", 0);

                        v238 = 0;
                        LODWORD(v6_Block_object_dispose(&a9, 8) = deleteRecord(v18, kPCSSetupGuitarfishToken[0], &v238);
                        uint64_t v70 = v238;
                        uint64_t v71 = pcsLogObjForScope("guitarfish-reset-protected-data");
                        if (!v68 || v70)
                        {
                          CFDictionaryRef v98 = v71;
                          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR)) {
                            PCSGuitarfishResetProtectedData_cold_12();
                          }

                          v241 |= 0x10000uLL;
                          uint64_t v242 = 2;
                          CFDataRef v99 = objc_msgSend(NSNumber, "numberWithLong:");
                          [v16 setObject:v99 forKeyedSubscript:@"flags"];

                          unint64_t v100 = [NSNumber numberWithLong:v242];
                          [v16 setObject:v100 forKeyedSubscript:@"status"];

                          uint64_t v107 = v238;
                          uint64_t v96 = (void *)v223;
                          if (!v238)
                          {
                            uint64_t v107 = PCSErrorCreate(225, @"Failed to delete Recovery Token record", v101, v102, v103, v104, v105, v106, v188);
                          }
                          +[PCSAnalyticsReporterRTC sendMetricWithEvent:v223 success:0 error:v107];
                          v4[2](v4, 2, 0x10000, v16, v107);
                          uint64_t v49 = (void *)v224;
                          dispatch_semaphore_t v97 = (void *)v226;
                          goto LABEL_150;
                        }
                        uint64_t v72 = v71;
                        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_1ACF98000, v72, OS_LOG_TYPE_DEFAULT, "successfully deleted token record", buf, 2u);
                        }

                        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v223 success:1 error:0];
                        v229 = [AAFAnalyticsEventPCS alloc];
                        CFMutableDictionaryRef v218 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
                        uint64_t v73 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
                        uint64_t v74 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
                        LOBYTE(v18_Block_object_dispose(&a9, 8) = 1;
                        uint64_t v230 = [(AAFAnalyticsEventPCS *)v229 initWithPCSMetrics:0 altDSID:v218 flowID:v73 deviceSessionID:v74 eventName:@"com.apple.pcs.rpdDeleteFromKeychain" testsAreEnabled:0 canSendMetrics:v188 category:0x1F03F7498];

                        CFErrorRef v237 = 0;
                        BOOL v219 = __PCSDeleteFromKeychain(1, &v237, v75, v76, v77, v78, v79, v80);
                        CFErrorRef v81 = v237;
                        uint64_t v82 = pcsLogObjForScope("guitarfish-reset-protected-data");
                        BOOL v83 = os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT);
                        CFErrorRef v211 = v81;
                        if (v81 || !v219)
                        {
                          if (v83)
                          {
                            *(_DWORD *)long long buf = 138412290;
                            *(void *)&uint8_t buf[4] = v81;
                            _os_log_impl(&dword_1ACF98000, v82, OS_LOG_TYPE_DEFAULT, "failed to delete keychain items, error: %@", buf, 0xCu);
                          }

                          uint64_t v84 = v230;
                          uint64_t v85 = 0;
                          CFErrorRef v86 = v81;
                        }
                        else
                        {
                          if (v83)
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl(&dword_1ACF98000, v82, OS_LOG_TYPE_DEFAULT, "successfully deleted keychain items", buf, 2u);
                          }

                          uint64_t v84 = v230;
                          uint64_t v85 = 1;
                          CFErrorRef v86 = 0;
                        }
                        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v84 success:v85 error:v86];
                        CFRange v220 = [AAFAnalyticsEventPCS alloc];
                        v214 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
                        int v108 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
                        uint64_t v109 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
                        LOBYTE(v189) = 1;
                        v221 = [(AAFAnalyticsEventPCS *)v220 initWithPCSMetrics:0 altDSID:v214 flowID:v108 deviceSessionID:v109 eventName:@"com.apple.pcs.rpdDeleteICDPFromKeychain" testsAreEnabled:0 canSendMetrics:v189 category:0x1F03F7498];

                        CFErrorRef v236 = 0;
                        LODWORD(v10_Block_object_dispose(&a9, 8) = __PCSDeleteFromKeychainICDPForRPD(v18, &v236, v110, v111, v112, v113, v114, v115);
                        CFErrorRef v215 = v236;
                        unint64_t v116 = pcsLogObjForScope("guitarfish-reset-protected-data");
                        BOOL v117 = os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT);
                        if (!v108 || v215)
                        {
                          if (v117)
                          {
                            *(_DWORD *)long long buf = 138412290;
                            *(void *)&uint8_t buf[4] = v236;
                            _os_log_impl(&dword_1ACF98000, v116, OS_LOG_TYPE_DEFAULT, "failed to delete cdp keychain items, error: %@", buf, 0xCu);
                          }

                          CFErrorRef v120 = v236;
                          CFDictionaryRef v118 = v221;
                          uint64_t v119 = 0;
                        }
                        else
                        {
                          if (v117)
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl(&dword_1ACF98000, v116, OS_LOG_TYPE_DEFAULT, "successfully deleted keychain items", buf, 2u);
                          }

                          CFDictionaryRef v118 = v221;
                          uint64_t v119 = 1;
                          CFErrorRef v120 = 0;
                        }
                        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v118 success:v119 error:v120];
                        v216 = [AAFAnalyticsEventPCS alloc];
                        CFMutableDictionaryRef v212 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
                        uint64_t v121 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
                        uint64_t v122 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
                        LOBYTE(v190) = 1;
                        v217 = [(AAFAnalyticsEventPCS *)v216 initWithPCSMetrics:0 altDSID:v212 flowID:v121 deviceSessionID:v122 eventName:@"com.apple.pcs.rpdDeleteGFStashFromKeychain" testsAreEnabled:0 canSendMetrics:v190 category:0x1F03F7498];

                        uint64_t v123 = _PCSGuitarfishDeleteKeychainState(v18);
                        if ((v123 & 1) == 0)
                        {
                          id v124 = pcsLogObjForScope("guitarfish-reset-protected-data");
                          if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl(&dword_1ACF98000, v124, OS_LOG_TYPE_DEFAULT, "failed to delete guitarfish stash keychain items", buf, 2u);
                          }
                        }
                        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v217 success:v123 error:0];
                        v245 = kPCSSetupDSID[0];
                        v246 = v18;
                        [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v246 forKeys:&v245 count:1];
                        v235 = 0;
                        CFDictionaryRef v213 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
                        CFTypeRef v125 = PCSIdentitySetCreate(v213, 0, &v235);
                        uint64_t v126 = v125;
                        if (!v125 || v235)
                        {
                          id v134 = pcsLogObjForScope("guitarfish-reset-protected-data");
                          if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR)) {
                            PCSGuitarfishResetProtectedData_cold_9();
                          }

                          uint64_t v107 = (void *)v230;
                          if (!v16) {
                            id v16 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
                          }
                          v241 |= 0x800000uLL;
                          uint64_t v242 = 2;
                          uint64_t v135 = objc_msgSend(NSNumber, "numberWithLong:");
                          [v16 setObject:v135 forKeyedSubscript:@"flags"];

                          uint64_t v136 = [NSNumber numberWithLong:v242];
                          [v16 setObject:v136 forKeyedSubscript:@"status"];

                          int v137 = _PCSGuitarfishPopulateFlagNamesToTelemetryArray(v241, 0);
                          [v16 setObject:v137 forKeyedSubscript:@"flags_dict"];

                          if (v126) {
                            CFRelease(v126);
                          }
                          id v138 = v235;
                          uint64_t v96 = (void *)v223;
                          if (v235)
                          {
                            v235 = 0;
                            CFRelease(v138);
                            id v139 = (void *)v235;
                          }
                          else
                          {
                            id v139 = 0;
                          }
                          dispatch_semaphore_t v97 = (void *)v226;
                          v4[2](v4, v242, v241, v16, v139);

                          uint64_t v49 = (void *)v224;
                          goto LABEL_149;
                        }
                        v234 = 0;
                        char v127 = PCSIdentitySetIsWalrusWithForceFetch((uint64_t)v125, 1, &v234);
                        if (v234)
                        {
                          long long v128 = pcsLogObjForScope("guitarfish-reset-protected-data");
                          if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)long long buf = 138412290;
                            *(void *)&uint8_t buf[4] = v234;
                            _os_log_impl(&dword_1ACF98000, v128, OS_LOG_TYPE_DEFAULT, "Failed to fetch w status: %@", buf, 0xCu);
                          }

                          uint64_t v107 = (void *)v230;
                          if (!v16) {
                            id v16 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
                          }
                          v241 |= 0x1000000uLL;
                          uint64_t v242 = 2;
                          uint64_t v129 = objc_msgSend(NSNumber, "numberWithLong:");
                          [v16 setObject:v129 forKeyedSubscript:@"flags"];

                          id v130 = [NSNumber numberWithLong:v242];
                          [v16 setObject:v130 forKeyedSubscript:@"status"];

                          uint64_t v131 = _PCSGuitarfishPopulateFlagNamesToTelemetryArray(v241, 0);
                          [v16 setObject:v131 forKeyedSubscript:@"flags_dict"];

                          CFRelease(v126);
                          uint64_t v132 = v234;
                          if (v234)
                          {
                            v234 = 0;
                            CFRelease(v132);
                            uint64_t v133 = (void *)v234;
                          }
                          else
                          {
                            uint64_t v133 = 0;
                          }
                          uint64_t v49 = (void *)v224;
                          dispatch_semaphore_t v97 = (void *)v226;
                          uint64_t v96 = (void *)v223;
                          v4[2](v4, v242, v241, v16, v133);
                          goto LABEL_148;
                        }
                        char v198 = v127;
                        CFRelease(v126);
                        uint64_t v207 = [AAFAnalyticsEventPCS alloc];
                        v209 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
                        uint64_t v140 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
                        long long v141 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
                        LOBYTE(v191) = 1;
                        uint64_t v199 = [(AAFAnalyticsEventPCS *)v207 initWithPCSMetrics:0 altDSID:v209 flowID:v140 deviceSessionID:v141 eventName:@"com.apple.pcs.rpdSetupIdentities" testsAreEnabled:0 canSendMetrics:v191 category:0x1F03F7498];

                        uint64_t v204 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
                        v203 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
                        uint64_t v202 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
                        v201 = [v3 objectForKeyedSubscript:kPCSAuthenticateAppleID[0]];
                        v200 = [v3 objectForKeyedSubscript:kPCSSetupRawPassword[0]];
                        v197 = [v3 objectForKeyedSubscript:kPCSSetupPassword[0]];
                        v196 = [v3 objectForKeyedSubscript:kPCSSetupVerifierIterationCount[0]];
                        uint64_t v195 = [v3 objectForKeyedSubscript:kPCSSetupVerifierProtocol[0]];
                        v194 = [v3 objectForKeyedSubscript:kPCSSetupPasswordGeneration[0]];
                        v193 = [v3 objectForKeyedSubscript:kPCSSetupVerifierSalt[0]];
                        id v233 = 0;
                        uint64_t v208 = PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken(v18, v204, v203, v202, v201, v200, v197, v196, v195, v194, v193, &v241, &v242, &v233);
                        id v210 = v233;

                        uint64_t v142 = v242;
                        if (v208) {
                          char v143 = 1;
                        }
                        else {
                          char v143 = v198;
                        }
                        long long v144 = pcsLogObjForScope("guitarfish-reset-protected-data");
                        if (v142 || v210 || (v143 & 1) == 0)
                        {
                          uint64_t v150 = v144;
                          if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR)) {
                            PCSGuitarfishResetProtectedData_cold_11((uint64_t)v210, v150, v151, v152, v153, v154, v155, v156);
                          }

                          dispatch_semaphore_t v157 = [NSNumber numberWithLong:v241];
                          [v16 setObject:v157 forKeyedSubscript:@"flags"];

                          CFIndex v158 = [NSNumber numberWithLong:v242];
                          [v16 setObject:v158 forKeyedSubscript:@"status"];

                          uint64_t v133 = (void *)v199;
                          +[PCSAnalyticsReporterRTC sendMetricWithEvent:v199 success:0 error:v210];
                          v4[2](v4, v242, v241, v16, v210);
                          uint64_t v96 = (void *)v223;
                          uint64_t v107 = (void *)v230;
                          goto LABEL_147;
                        }
                        uint64_t v145 = v144;
                        if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)long long buf = 0;
                          _os_log_impl(&dword_1ACF98000, v145, OS_LOG_TYPE_DEFAULT, "successfully enrolled Guitarfish and Recovery Token Records", buf, 2u);
                        }

                        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v199 success:1 error:0];
                        char v205 = [AAFAnalyticsEventPCS alloc];
                        CFTypeRef v146 = [v3 objectForKeyedSubscript:kPCSAltDSID[0]];
                        int v147 = [v3 objectForKeyedSubscript:kPCSFlowID[0]];
                        id v148 = [v3 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
                        LOBYTE(v192) = 1;
                        v206 = [(AAFAnalyticsEventPCS *)v205 initWithPCSMetrics:0 altDSID:v146 flowID:v147 deviceSessionID:v148 eventName:@"com.apple.pcs.migrateToiCDP" testsAreEnabled:0 canSendMetrics:v192 category:0x1F03F7498];

                        unint64_t v149 = [v3 objectForKeyedSubscript:kPCSRPDDBROnly[0]];
                        if ([v149 isEqualToNumber:MEMORY[0x1E4F1CC38]])
                        {
                        }
                        else
                        {
                          v159 = [v3 objectForKeyedSubscript:kPCSShouldJoinCDP[0]];
                          int v160 = [v159 isEqualToNumber:MEMORY[0x1E4F1CC38]];

                          if (!v160) {
                            goto LABEL_131;
                          }
                        }
                        v161 = (void *)[v3 mutableCopy];
                        [v161 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:kPCSSetupGuitarfish[0]];
                        *(void *)long long buf = 0;
                        v162 = v161;
                        int v163 = _PCSMigrateToiCDPForwardTable(v161, buf);
                        CFAllocatorRef v164 = *(void **)buf;
                        id v165 = pcsLogObjForScope("guitarfish-reset-protected-data");
                        id v166 = v165;
                        if (!v163 || v164)
                        {
                          if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR)) {
                            PCSGuitarfishResetProtectedData_cold_10((uint64_t)v164, v166, v174, v175, v176, v177, v178, v179);
                          }

                          if (!v16) {
                            id v16 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
                          }
                          v241 |= 0x2000000uLL;
                          uint64_t v242 = 2;
                          long long v180 = objc_msgSend(NSNumber, "numberWithLong:");
                          [v16 setObject:v180 forKeyedSubscript:@"flags"];

                          uint64_t v181 = [NSNumber numberWithLong:v242];
                          [v16 setObject:v181 forKeyedSubscript:@"status"];

                          long long v182 = _PCSGuitarfishPopulateFlagNamesToTelemetryArray(v241, 0);
                          [v16 setObject:v182 forKeyedSubscript:@"flags_dict"];

                          if (!v164)
                          {
                            uint64_t v183 = (void *)MEMORY[0x1E4F28C58];
                            long long v184 = kPCSErrorDomain;
                            uint64_t v243 = *MEMORY[0x1E4F28568];
                            v244 = @"Failed to enable iCDP";
                            long long v185 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v244 forKeys:&v243 count:1];
                            CFAllocatorRef v164 = [v183 errorWithDomain:v184 code:240 userInfo:v185];
                          }
                          +[PCSAnalyticsReporterRTC sendMetricWithEvent:v206 success:0 error:v164];
                          v4[2](v4, v242, v241, v16, v164);

                          uint64_t v169 = v162;
                          goto LABEL_146;
                        }
                        if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)v232 = 0;
                          _os_log_impl(&dword_1ACF98000, v166, OS_LOG_TYPE_DEFAULT, "successfully enabled iCDP", v232, 2u);
                        }

                        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v206 success:1 error:0];
LABEL_131:
                        id v231 = 0;
                        int v167 = PCSGuitarfishResetOnOTClique(v3, &v241, &v231);
                        id v168 = v231;
                        uint64_t v169 = v168;
                        if (!v167 || v168)
                        {
                          uint64_t v242 = 2;
                          id v186 = [NSNumber numberWithLong:v241];
                          [v16 setObject:v186 forKeyedSubscript:@"flags"];

                          uint64_t v187 = [NSNumber numberWithLong:v242];
                          [v16 setObject:v187 forKeyedSubscript:@"status"];

                          v4[2](v4, 2, v241, v16, v169);
                        }
                        else
                        {
                          uint64_t v170 = pcsLogObjForScope("guitarfish-reset-protected-data");
                          if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl(&dword_1ACF98000, v170, OS_LOG_TYPE_DEFAULT, "successfully reset otclique", buf, 2u);
                          }

                          uint64_t v171 = pcsLogObjForScope("guitarfish-reset-protected-data");
                          if (os_log_type_enabled(v171, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)long long buf = 0;
                            _os_log_impl(&dword_1ACF98000, v171, OS_LOG_TYPE_DEFAULT, "successfully reset protected data", buf, 2u);
                          }

                          +[PCSAnalyticsReporterRTC sendMetricWithEvent:v9 success:1 error:0];
                          id v172 = [NSNumber numberWithLong:v241];
                          [v16 setObject:v172 forKeyedSubscript:@"flags"];

                          id v173 = [NSNumber numberWithLong:v242];
                          [v16 setObject:v173 forKeyedSubscript:@"status"];

                          v4[2](v4, v242, v241, v16, 0);
                        }
LABEL_146:

                        uint64_t v96 = (void *)v223;
                        uint64_t v107 = (void *)v230;
                        uint64_t v133 = (void *)v199;
LABEL_147:

                        uint64_t v49 = (void *)v224;
                        dispatch_semaphore_t v97 = (void *)v226;
LABEL_148:

LABEL_149:
LABEL_150:

LABEL_151:
                        goto LABEL_46;
                      }
                      uint64_t v50 = pcsLogObjForScope("guitarfish-reset-protected-data");
                      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
                        PCSGuitarfishResetProtectedData_cold_8();
                      }

                      uint64_t v49 = PCSErrorCreate(218, @"kPCSSetupVerifierSalt is missing and is a required fields", v51, v52, v53, v54, v55, v56, v188);
LABEL_45:
                      v4[2](v4, 2, 1, v16, v49);
LABEL_46:

                      goto LABEL_47;
                    }
                    uint64_t v48 = pcsLogObjForScope("guitarfish-reset-protected-data");
                    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
                      PCSGuitarfishResetProtectedData_cold_7();
                    }

                    uint64_t v40 = @"kPCSSetupVerifierProtocol is missing and is a required fields";
                  }
                  else
                  {
                    uint64_t v47 = pcsLogObjForScope("guitarfish-reset-protected-data");
                    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR)) {
                      PCSGuitarfishResetProtectedData_cold_6();
                    }

                    uint64_t v40 = @"kPCSSetupVerifierIterationCount is missing and is a required field";
                  }
                }
                else
                {
                  uint64_t v46 = pcsLogObjForScope("guitarfish-reset-protected-data");
                  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR)) {
                    PCSGuitarfishResetProtectedData_cold_5();
                  }

                  uint64_t v40 = @"kPCSSetupPasswordGeneration is missing and is a required field";
                }
              }
              else
              {
                uint64_t v45 = pcsLogObjForScope("guitarfish-reset-protected-data");
                if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR)) {
                  PCSGuitarfishResetProtectedData_cold_4();
                }

                uint64_t v40 = @"kPCSAltDSID is missing and is a required field";
              }
            }
            else
            {
              uint64_t v44 = pcsLogObjForScope("guitarfish-reset-protected-data");
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
                PCSGuitarfishResetProtectedData_cold_3();
              }

              uint64_t v40 = @"kPCSSetupRawPassword is missing and is a required field";
            }
          }
          else
          {
            uint64_t v43 = pcsLogObjForScope("guitarfish-reset-protected-data");
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
              PCSGuitarfishResetProtectedData_cold_2();
            }

            uint64_t v40 = @"kPCSSetupPassword is missing and is a required field";
          }
        }
        else
        {
          uint64_t v42 = pcsLogObjForScope("guitarfish-reset-protected-data");
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
            PCSGuitarfishResetProtectedData_cold_1();
          }

          uint64_t v40 = @"kPCSAuthenticateAppleID is missing and is a required field";
        }
        uint64_t v41 = 218;
      }
      else
      {
        uint64_t v40 = @"Current persona does not match chosen dsid";
        uint64_t v41 = 152;
      }
      uint64_t v49 = PCSErrorCreate(v41, v40, v19, v20, v21, v22, v23, v24, v188);
      +[PCSAnalyticsReporterRTC sendMetricWithEvent:v9 success:0 error:v49];
      goto LABEL_45;
    }
  }
  uint64_t v18 = PCSErrorCreate(121, @"Missing DSID in parameters", v10, v11, v12, v13, v14, v15, v188);
  +[PCSAnalyticsReporterRTC sendMetricWithEvent:v9 success:0 error:v18];
  v4[2](v4, 2, 1, v16, v18);
LABEL_47:
}

BOOL performStingrayRecovery(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v4 = [MEMORY[0x1E4F1CA60] dictionary];
  [v4 setObject:v3 forKeyedSubscript:kPCSSetupDSID[0]];
  id v25 = 0;
  CFDataRef v5 = __PCSCopyHSMData(0, v4, (const void **)&v25);
  if (!v5)
  {
    uint64_t v14 = pcsLogObjForScope("guitarfish-reset-protected-data");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR)) {
      performStingrayRecovery_cold_1();
    }

    if (!a2) {
      goto LABEL_24;
    }
    uint64_t v13 = v25;
LABEL_15:
    id v15 = v13;
    BOOL v16 = 0;
LABEL_16:
    *a2 = v15;
    goto LABEL_25;
  }
  int v10 = (int)v5;
  CFTypeRef cf = 0;
  if (__PCSStoreInKeychain(0, (uint64_t)v5, (uint64_t)v3, &cf, v6, v7, v8, v9)) {
    BOOL v11 = cf == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (!v11)
  {
    uint64_t v12 = pcsLogObjForScope("guitarfish-reset-protected-data");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      performStingrayRecovery_cold_3();
    }

    uint64_t v13 = (void *)cf;
    if (!a2)
    {
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v13);
      }
LABEL_24:
      BOOL v16 = 0;
      goto LABEL_25;
    }
    goto LABEL_15;
  }
  id v23 = 0;
  BOOL v17 = __PCSStoreIniCloudKeychain(v10, (int)v3, 0, (const void **)&v23);
  if (v23) {
    BOOL v16 = 0;
  }
  else {
    BOOL v16 = v17;
  }
  uint64_t v18 = pcsLogObjForScope("guitarfish-reset-protected-data");
  uint64_t v19 = v18;
  if (v16)
  {
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v22 = 0;
      _os_log_impl(&dword_1ACF98000, v19, OS_LOG_TYPE_DEFAULT, "successfully recovered stingray data", (uint8_t *)&v22, 2u);
    }
  }
  else
  {
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      performStingrayRecovery_cold_2();
    }

    id v21 = v23;
    if (a2)
    {
      id v15 = v23;
      goto LABEL_16;
    }
    if (v23)
    {
      id v23 = 0;
      CFRelease(v21);
    }
  }
LABEL_25:

  return v16;
}

BOOL deleteRecord(void *a1, void *a2, void *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a1;
  uint64_t v7 = pcsLogObjForScope("guitarfish-reset-protected-data");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, v7, OS_LOG_TYPE_DEFAULT, "deleteRecord", buf, 2u);
  }

  uint64_t v8 = [MEMORY[0x1E4F1CA60] dictionary];
  [v8 setObject:v6 forKeyedSubscript:kPCSSetupDSID[0]];

  char v9 = [v5 isEqualToString:kPCSSetupGuitarfish[0]];
  int v10 = kPCSSetupGuitarfish;
  if ((v9 & 1) == 0)
  {
    if (![v5 isEqualToString:kPCSSetupGuitarfishToken[0]]) {
      goto LABEL_7;
    }
    [v8 setObject:0 forKeyedSubscript:kPCSSetupGuitarfish[0]];
    int v10 = kPCSSetupGuitarfishToken;
  }
  [v8 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*v10];
LABEL_7:
  id v24 = 0;
  BOOL v11 = __PCSDisableStingrayIdentity(0, (const __CFDictionary *)v8, &v24);
  uint64_t v12 = pcsLogObjForScope("guitarfish-reset-protected-data");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = @"failed";
    if (v11) {
      uint64_t v13 = @"succeeded";
    }
    *(_DWORD *)long long buf = 138412546;
    id v26 = v13;
    __int16 v27 = 2112;
    id v28 = v24;
    _os_log_impl(&dword_1ACF98000, v12, OS_LOG_TYPE_DEFAULT, "__PCSDisableStingrayIdentity result: %@, error: %@", buf, 0x16u);
  }

  if (v24)
  {
    id v14 = v24;
    id v15 = [v14 userInfo];
    BOOL v16 = [v15 objectForKeyedSubscript:*MEMORY[0x1E4F28A50]];

    BOOL v17 = [v16 domain];
    if ([v17 isEqualToString:@"EscrowServiceErrorDomain"])
    {
      uint64_t v18 = [v16 code];
      uint64_t v19 = kPCSEscrowServiceEscrowRecordNotFound;

      if (v18 == v19)
      {
        uint64_t v20 = pcsLogObjForScope("guitarfish-reset-protected-data");
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          int v21 = [v5 isEqualToString:kPCSSetupGuitarfish[0]];
          __int16 v22 = @"Recovery Token";
          if (v21) {
            __int16 v22 = @"Guitarfish";
          }
          *(_DWORD *)long long buf = 138412290;
          id v26 = v22;
          _os_log_impl(&dword_1ACF98000, v20, OS_LOG_TYPE_DEFAULT, "%@ record does not exist", buf, 0xCu);
        }

        BOOL v11 = 1;
LABEL_22:

        goto LABEL_23;
      }
    }
    else
    {
    }
    if (a3)
    {
      BOOL v11 = 0;
      *a3 = v24;
    }
    goto LABEL_22;
  }
LABEL_23:

  return v11;
}

uint64_t _PCSGuitarfishDeleteKeychainState(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 1;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___PCSGuitarfishDeleteKeychainState_block_invoke;
  v4[3] = &unk_1E5E6EEA8;
  v4[4] = &v5;
  _PCSGuitarfishDeleteKeychainItem(0, v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1ACFDE334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id _PCSGuitarfishPopulateFlagNamesToTelemetryArray(unint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3) {
    id v5 = v3;
  }
  else {
    id v5 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  }
  id v6 = v5;
  if ([&unk_1F03F7510 count])
  {
    unint64_t v14 = 0;
    do
    {
      if ((a1 >> v14))
      {
        id v15 = [&unk_1F03F7510 objectAtIndexedSubscript:v14];
        [v6 setObject:&unk_1F03F7468 forKeyedSubscript:v15];

        a1 &= ~(1 << v14);
      }
      ++v14;
    }
    while ([&unk_1F03F7510 count] > v14);
  }
  if (a1) {
    PCSAbort("_PCSGuitarfishPopulateFlagNamesToTelemetryArray is missing a flag definition", v7, v8, v9, v10, v11, v12, v13, v17);
  }

  return v6;
}

id PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  v88[1] = *MEMORY[0x1E4F143B8];
  id v21 = a1;
  id v51 = a2;
  id v52 = a3;
  id v53 = a4;
  id v54 = a5;
  id v55 = a6;
  id v56 = a7;
  id v57 = a8;
  id v58 = a9;
  id v22 = a10;
  id v23 = a11;
  id v24 = [MEMORY[0x1E4F1CA60] dictionary];
  [v24 setObject:v51 forKeyedSubscript:kPCSAltDSID[0]];
  [v24 setObject:v52 forKeyedSubscript:kPCSFlowID[0]];
  [v24 setObject:v53 forKeyedSubscript:kPCSDeviceSessionID[0]];
  [v24 setObject:v21 forKeyedSubscript:kPCSSetupDSID[0]];
  [v24 setObject:v54 forKeyedSubscript:kPCSSetupUsername[0]];
  [v24 setObject:v55 forKeyedSubscript:kPCSSetupRawPassword[0]];
  [v24 setObject:v56 forKeyedSubscript:kPCSSetupPassword[0]];
  [v24 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:kPCSSetupGuitarfish[0]];
  [v24 setObject:v58 forKeyedSubscript:kPCSSetupVerifierProtocol[0]];
  [v24 setObject:v57 forKeyedSubscript:kPCSSetupVerifierIterationCount[0]];
  [v24 setObject:v22 forKeyedSubscript:kPCSSetupPasswordGeneration[0]];
  [v24 setObject:v23 forKeyedSubscript:kPCSSetupVerifierSalt[0]];
  uint64_t v81 = 0;
  uint64_t v82 = &v81;
  uint64_t v83 = 0x3032000000;
  uint64_t v84 = __Block_byref_object_copy__3;
  uint64_t v85 = __Block_byref_object_dispose__3;
  id v86 = 0;
  uint64_t v75 = 0;
  int v76 = &v75;
  uint64_t v77 = 0x3032000000;
  int v78 = __Block_byref_object_copy__3;
  int v79 = __Block_byref_object_dispose__3;
  id v80 = 0;
  uint64_t v71 = 0;
  uint64_t v72 = &v71;
  uint64_t v73 = 0x2020000000;
  uint64_t v74 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = &v67;
  uint64_t v69 = 0x2020000000;
  uint64_t v70 = 0;
  dispatch_semaphore_t v25 = dispatch_semaphore_create(0);
  id v26 = _PCSStingrayForwardTable;
  v61[0] = MEMORY[0x1E4F143A8];
  v61[1] = 3221225472;
  v61[2] = __PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken_block_invoke;
  v61[3] = &unk_1E5E6EF20;
  CFTypeRef v63 = &v81;
  uint64_t v64 = &v75;
  uint64_t v65 = &v71;
  uint64_t v66 = &v67;
  __int16 v27 = v25;
  uint64_t v62 = v27;
  ((void (*)(void *, void *))v26)(v24, v61);
  dispatch_semaphore_wait(v27, 0xFFFFFFFFFFFFFFFFLL);
  if (a12) {
    *a12 = v72[3];
  }
  if (a13) {
    *a13 = v68[3];
  }
  if (!a14 || !v82[5])
  {
    uint64_t v87 = kPCSSetupDSID[0];
    v88[0] = v21;
    CFDictionaryRef v30 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v88 forKeys:&v87 count:1];
    id v60 = 0;
    CFTypeRef v31 = PCSIdentitySetCreate(v30, 0, (const void **)&v60);
    id v29 = (id)v31;
    if (!v31 || v60)
    {
      uint64_t v35 = pcsLogObjForScope("guitarfish-reset-protected-data");
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        PCSGuitarfishResetProtectedData_cold_9();
      }

      id v36 = v60;
      if (a14)
      {
        *a14 = v60;
      }
      else if (v60)
      {
        id v60 = 0;
        CFRelease(v36);
      }
      if (!v29) {
        goto LABEL_37;
      }
      CFRelease(v29);
    }
    else
    {
      id v59 = 0;
      char v32 = PCSIdentitySetIsWalrusWithForceFetch((uint64_t)v31, 1, (const void **)&v59);
      if (v59)
      {
        uint64_t v33 = pcsLogObjForScope("guitarfish-reset-protected-data");
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
          PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken_cold_3();
        }

        id v34 = v59;
        if (a14)
        {
          *a14 = v59;
        }
        else if (v59)
        {
          id v59 = 0;
          CFRelease(v34);
        }
        CFRelease(v29);
      }
      else
      {
        char v37 = v32;
        CFRelease(v29);
        uint64_t v38 = (void *)v76[5];
        if (v38) {
          char v39 = 1;
        }
        else {
          char v39 = v37;
        }
        if (v39)
        {
          id v29 = v38;
LABEL_37:

          goto LABEL_38;
        }
        uint64_t v40 = pcsLogObjForScope("guitarfish-reset-protected-data");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken_cold_2();
        }

        uint64_t v47 = PCSErrorCreate(224, @"PCSGuitarfishSetupIdentities failed to return a recovery token", v41, v42, v43, v44, v45, v46, v50);
        uint64_t v48 = (void *)v82[5];
        v82[5] = v47;
      }
    }
    id v29 = 0;
    goto LABEL_37;
  }
  id v28 = pcsLogObjForScope("guitarfish-reset-protected-data");
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
    PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken_cold_4();
  }

  id v29 = 0;
  *a14 = (id) v82[5];
LABEL_38:

  _Block_object_dispose(&v67, 8);
  _Block_object_dispose(&v71, 8);
  _Block_object_dispose(&v75, 8);

  _Block_object_dispose(&v81, 8);
  return v29;
}

void sub_1ACFDEAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 208), 8);
  _Block_object_dispose((const void *)(v37 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t PCSGuitarfishResetOnOTClique(void *a1, void *a2, void *a3)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = objc_alloc_init(MEMORY[0x1E4F3B438]);
  id v6 = [v4 objectForKeyedSubscript:kPCSAuthenticateAppleID[0]];
  [v5 setAuthenticationAppleID:v6];

  uint64_t v7 = [v4 objectForKeyedSubscript:kPCSSetupPassword[0]];
  [v5 setPasswordEquivalentToken:v7];

  uint64_t v8 = [v4 objectForKeyedSubscript:kPCSFlowID[0]];
  [v5 setFlowID:v8];

  uint64_t v9 = [v4 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
  [v5 setDeviceSessionID:v9];

  uint64_t v10 = [v4 objectForKeyedSubscript:kPCSAltDSID[0]];
  [v5 setAltDSID:v10];

  [v5 setIsGuitarfish:1];
  uint64_t v11 = [v4 objectForKeyedSubscript:kPCSRPDDBROnly[0]];
  int v12 = [v11 isEqualToNumber:MEMORY[0x1E4F1CC38]];

  if (!v12)
  {
    CFDictionaryRef v30 = [v4 objectForKeyedSubscript:kPCSShouldJoinCDP[0]];
    int v31 = [v30 isEqualToNumber:MEMORY[0x1E4F1CC38]];

    if (v31)
    {
      id v80 = [v4 objectForKeyedSubscript:kPCSIDMSTargetContext[0]];
      char v32 = [v4 objectForKeyedSubscript:kPCSIDMSCuttlefishPassword[0]];
      uint64_t v33 = [v4 objectForKeyedSubscript:kPCSNotifyIDMS[0]];
      id v34 = pcsLogObjForScope("guitarfish-reset-protected-data");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1ACF98000, v34, OS_LOG_TYPE_DEFAULT, "Invoking resetProtectedData on OTClique", buf, 2u);
      }

      uint64_t v35 = [AAFAnalyticsEventPCS alloc];
      id v36 = [v4 objectForKeyedSubscript:kPCSAltDSID[0]];
      uint64_t v37 = [v4 objectForKeyedSubscript:kPCSFlowID[0]];
      uint64_t v38 = [v4 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
      LOBYTE(v79) = 1;
      char v39 = -[AAFAnalyticsEventPCS initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:](v35, "initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:", 0, v36, v37, v38, @"com.apple.pcs.resetProtectedDataOnOTClique", 0);

      id v83 = 0;
      uint64_t v40 = [MEMORY[0x1E4F3B430] resetProtectedData:v5 idmsTargetContext:v80 idmsCuttlefishPassword:v32 notifyIdMS:v33 != 0 error:&v83];
      id v41 = v83;
      uint64_t v42 = pcsLogObjForScope("guitarfish-reset-protected-data");
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        if (v41) {
          BOOL v43 = 1;
        }
        else {
          BOOL v43 = v40 == 0;
        }
        uint64_t v44 = @"failed";
        if (!v43) {
          uint64_t v44 = @"succeeded";
        }
        *(_DWORD *)long long buf = 138412546;
        id v86 = v44;
        __int16 v87 = 2112;
        id v88 = v41;
        _os_log_impl(&dword_1ACF98000, v42, OS_LOG_TYPE_DEFAULT, "resetProtectedData result: %@, error: %@", buf, 0x16u);
      }

      if (v40) {
        BOOL v51 = v41 == 0;
      }
      else {
        BOOL v51 = 0;
      }
      char v52 = v51;
      if (v51)
      {
        id v53 = pcsLogObjForScope("guitarfish-reset-protected-data");
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1ACF98000, v53, OS_LOG_TYPE_DEFAULT, "successfully reset protected data on otclique", buf, 2u);
        }

        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v39 success:1 error:0];
      }
      else
      {
        if (v41)
        {
          id v73 = v41;
        }
        else
        {
          PCSErrorCreate(220, @"Failed to reset protected data on otclique", v45, v46, v47, v48, v49, v50, v79);
          id v73 = (id)objc_claimAutoreleasedReturnValue();
        }
        int v76 = v73;
        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v39 success:0 error:v73];
        if (a3) {
          *a3 = v76;
        }
        if (a2) {
          *a2 |= 0x4000uLL;
        }
      }
      if (v52)
      {
LABEL_69:
        uint64_t v19 = 1;
        goto LABEL_77;
      }
    }
    else
    {
      id v55 = pcsLogObjForScope("guitarfish-reset-protected-data");
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1ACF98000, v55, OS_LOG_TYPE_DEFAULT, "Invoking clearCliqueFromAccount on OTClique", buf, 2u);
      }

      id v56 = [AAFAnalyticsEventPCS alloc];
      id v57 = [v4 objectForKeyedSubscript:kPCSAltDSID[0]];
      id v58 = [v4 objectForKeyedSubscript:kPCSFlowID[0]];
      id v59 = [v4 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
      LOBYTE(v79) = 1;
      id v60 = -[AAFAnalyticsEventPCS initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:](v56, "initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:", 0, v57, v58, v59, @"com.apple.pcs.clearCliqueFromAccount", 0);

      id v82 = 0;
      unsigned __int8 v61 = [MEMORY[0x1E4F3B430] clearCliqueFromAccount:v5 error:&v82];
      id v62 = v82;
      CFTypeRef v63 = pcsLogObjForScope("guitarfish-reset-protected-data");
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v64 = @"failed";
        if ((v61 & (v62 == 0)) != 0) {
          uint64_t v64 = @"succeeded";
        }
        *(_DWORD *)long long buf = 138412546;
        id v86 = v64;
        __int16 v87 = 2112;
        id v88 = v62;
        _os_log_impl(&dword_1ACF98000, v63, OS_LOG_TYPE_DEFAULT, "clearCliqueFromAccount result: %@, error: %@", buf, 0x16u);
      }

      if (v62) {
        unsigned __int8 v71 = 0;
      }
      else {
        unsigned __int8 v71 = v61;
      }
      if (v71)
      {
        uint64_t v72 = pcsLogObjForScope("guitarfish-reset-protected-data");
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1ACF98000, v72, OS_LOG_TYPE_DEFAULT, "successfully reset protected data on otclique", buf, 2u);
        }

        +[PCSAnalyticsReporterRTC sendMetricWithEvent:v60 success:1 error:0];
        goto LABEL_69;
      }
      if (v62)
      {
        id v74 = v62;
      }
      else
      {
        PCSErrorCreate(0x8000, @"Failed to clear clique from account on otclique", v65, v66, v67, v68, v69, v70, v79);
        id v74 = (id)objc_claimAutoreleasedReturnValue();
      }
      uint64_t v77 = v74;
      +[PCSAnalyticsReporterRTC sendMetricWithEvent:v60 success:0 error:v74];
      if (a3) {
        *a3 = v77;
      }
      if (a2) {
        *a2 |= 0x8000uLL;
      }
    }
    uint64_t v19 = 0;
    goto LABEL_77;
  }
  uint64_t v13 = [AAFAnalyticsEventPCS alloc];
  unint64_t v14 = [v4 objectForKeyedSubscript:kPCSAltDSID[0]];
  id v15 = [v4 objectForKeyedSubscript:kPCSFlowID[0]];
  BOOL v16 = [v4 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
  LOBYTE(v79) = 1;
  char v17 = -[AAFAnalyticsEventPCS initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:](v13, "initWithPCSMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:", 0, v14, v15, v16, @"com.apple.pcspPerformCKServerUnreadableDataRemoval", 0);

  uint64_t v18 = pcsLogObjForScope("guitarfish-reset-protected-data");
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, v18, OS_LOG_TYPE_DEFAULT, "Performing performCKServerUnreadableDataRemoval on OTClique", buf, 2u);
  }

  id v84 = 0;
  LODWORD(v19) = [MEMORY[0x1E4F3B430] performCKServerUnreadableDataRemoval:v5 error:&v84];
  id v20 = v84;
  id v21 = pcsLogObjForScope("guitarfish-reset-protected-data");
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    id v22 = @"failed";
    if ((v19 & (v20 == 0)) != 0) {
      id v22 = @"succeeded";
    }
    *(_DWORD *)long long buf = 138412546;
    id v86 = v22;
    __int16 v87 = 2112;
    id v88 = v20;
    _os_log_impl(&dword_1ACF98000, v21, OS_LOG_TYPE_DEFAULT, "performCKServerUnreadableDataRemoval result: %@, error: %@", buf, 0x16u);
  }

  if (v20) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = v19;
  }
  if (v19)
  {
    id v29 = pcsLogObjForScope("guitarfish-reset-protected-data");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1ACF98000, v29, OS_LOG_TYPE_DEFAULT, "successfully removed unreadable data from CKServer on otclique", buf, 2u);
    }

    +[PCSAnalyticsReporterRTC sendMetricWithEvent:v17 success:1 error:0];
  }
  else
  {
    if (v20)
    {
      id v54 = v20;
    }
    else
    {
      PCSErrorCreate(226, @"Failed to remove unreadable CKServer data on otclique", v23, v24, v25, v26, v27, v28, v79);
      id v54 = (id)objc_claimAutoreleasedReturnValue();
    }
    uint64_t v75 = v54;
    if (a3) {
      *a3 = v54;
    }
    if (a2) {
      *a2 |= 0x200000uLL;
    }
    +[PCSAnalyticsReporterRTC sendMetricWithEvent:v17 success:0 error:v75];
  }
LABEL_77:

  return v19;
}

void _PCSGuitarfishDeleteKeychainItem(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  uint64_t v7 = (objc_class *)MEMORY[0x1E4F1CA60];
  id v8 = a2;
  id v9 = objc_alloc_init(v7);
  [v9 setObject:*MEMORY[0x1E4F3B998] forKeyedSubscript:*MEMORY[0x1E4F3B978]];
  [v9 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:*MEMORY[0x1E4F3BD08]];
  [v9 setObject:kPCSDefaultKeychainGroup[0] forKeyedSubscript:*MEMORY[0x1E4F3B550]];
  [v9 setObject:v8 forKeyedSubscript:*MEMORY[0x1E4F3B5C0]];

  [v9 setObject:v5 forKeyedSubscript:*MEMORY[0x1E4F3B848]];
  [v9 setObject:kPCSGuitarfishKeychainSecurityDomain forKeyedSubscript:*MEMORY[0x1E4F3B838]];
  uint64_t v10 = off_1EB3B39C8(v9);
  if (v10 == -25300 || v10 == 0)
  {
    v6[2](v6, 0);
  }
  else
  {
    uint64_t v12 = v10;
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR)) {
      _PCSGuitarfishDeleteKeychainItem_cold_1();
    }
    id v20 = PCSErrorCreate(26, @"Unable to delete item from keychain %d", v14, v15, v16, v17, v18, v19, v12);
    ((void (**)(id, void *))v6)[2](v6, v20);
  }
}

id PCSGuitarfishUnwrapKeysUsingWrappingKey(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  uint64_t v28 = 0;
  id v29 = &v28;
  uint64_t v30 = 0x3032000000;
  int v31 = __Block_byref_object_copy__3;
  char v32 = __Block_byref_object_dispose__3;
  id v33 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x3032000000;
  uint64_t v25 = __Block_byref_object_copy__3;
  uint64_t v26 = __Block_byref_object_dispose__3;
  id v27 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x3032000000;
  uint64_t v19 = __Block_byref_object_copy__3;
  id v20 = __Block_byref_object_dispose__3;
  id v21 = 0;
  uint64_t v7 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, v7, OS_LOG_TYPE_DEFAULT, "Unwrapping Inner from Outer with Key", buf, 2u);
  }

  dispatch_semaphore_t v8 = dispatch_semaphore_create(0);
  id v9 = (void *)v17[5];
  v17[5] = (uint64_t)v8;

  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3221225472;
  void v14[2] = __PCSGuitarfishUnwrapKeysUsingWrappingKey_block_invoke;
  void v14[3] = &unk_1E5E6EED0;
  void v14[4] = &v28;
  v14[5] = &v22;
  void v14[6] = &v16;
  _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(v5, v6, v14);
  dispatch_semaphore_wait((dispatch_semaphore_t)v17[5], 0xFFFFFFFFFFFFFFFFLL);
  if (v23[5])
  {
    uint64_t v10 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1ACF98000, v10, OS_LOG_TYPE_DEFAULT, "Unwrapped PCS keys successfully", buf, 2u);
    }
  }
  if (a3)
  {
    uint64_t v11 = (void *)v29[5];
    if (v11) {
      *a3 = v11;
    }
  }
  id v12 = (id)v23[5];
  _Block_object_dispose(&v16, 8);

  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v28, 8);

  return v12;
}

void sub_1ACFDFA10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void __PCSGuitarfishUnwrapKeysUsingWrappingKey_block_invoke(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v8 = a2;
  id v12 = a6;
  if (v12) {
    objc_storeStrong((id *)(*(void *)(a1[4] + 8) + 40), a6);
  }
  uint64_t v9 = *(void *)(a1[5] + 8);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
  id v11 = v8;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1[6] + 8) + 40));
}

id PCSGuitarfishUnwrapKeys(void *a1, void *a2, void *a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  uint64_t v41 = 0;
  uint64_t v42 = &v41;
  uint64_t v43 = 0x3032000000;
  uint64_t v44 = __Block_byref_object_copy__3;
  uint64_t v45 = __Block_byref_object_dispose__3;
  id v46 = 0;
  uint64_t v35 = 0;
  id v36 = &v35;
  uint64_t v37 = 0x3032000000;
  uint64_t v38 = __Block_byref_object_copy__3;
  char v39 = __Block_byref_object_dispose__3;
  id v40 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x3032000000;
  char v32 = __Block_byref_object_copy__3;
  id v33 = __Block_byref_object_dispose__3;
  id v34 = 0;
  if (!v5)
  {
    uint64_t v7 = +[PCSAccountsModel accountForCurrentPersona];
    objc_msgSend(v7, "aa_personID");
    id v5 = (id)objc_claimAutoreleasedReturnValue();

    id v8 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v48 = v5;
      _os_log_impl(&dword_1ACF98000, v8, OS_LOG_TYPE_DEFAULT, "DSID not provided to PCSGuitarfishUnwrapKeys, using derived: %@", buf, 0xCu);
    }
  }
  uint64_t v9 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "Fetching Wrapping Key from Keychain", buf, 2u);
  }

  dispatch_semaphore_t v10 = dispatch_semaphore_create(0);
  id v11 = (void *)v30[5];
  void v30[5] = (uint64_t)v10;

  v28[0] = MEMORY[0x1E4F143A8];
  v28[1] = 3221225472;
  v28[2] = __PCSGuitarfishUnwrapKeys_block_invoke;
  v28[3] = &unk_1E5E6EEF8;
  v28[4] = &v35;
  v28[5] = &v41;
  v28[6] = &v29;
  _PCSGuitarfishGetKeychainItem(@"WrappingKey", v5, v28);
  dispatch_semaphore_wait((dispatch_semaphore_t)v30[5], 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v17 = (void *)v42[5];
  uint64_t v18 = v36;
  if (!v17 || v36[5])
  {
    id v27 = (id)v36[5];
    _PCSNSError(&v27, 213, @"unable to fetch wrappingKey, needs repair", v12, v13, v14, v15, v16, v25);
    uint64_t v19 = 0;
    id v20 = v27;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v19 = PCSGuitarfishUnwrapKeysUsingWrappingKey(v17, v6, &v26);
    id v20 = v26;
  }
  id v21 = v20;
  uint64_t v22 = (void *)v18[5];
  void v18[5] = (uint64_t)v21;

  if (a3)
  {
    uint64_t v23 = (void *)v36[5];
    if (v23) {
      *a3 = v23;
    }
  }
  _Block_object_dispose(&v29, 8);

  _Block_object_dispose(&v35, 8);
  _Block_object_dispose(&v41, 8);

  return v19;
}

void sub_1ACFDFE3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Unwind_Resume(a1);
}

void __PCSGuitarfishUnwrapKeys_block_invoke(void *a1, void *a2, void *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  id v7 = a3;
  if (v7)
  {
    id v8 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v7;
      _os_log_impl(&dword_1ACF98000, v8, OS_LOG_TYPE_DEFAULT, "error retrieving wrapping key from keychain: %@", (uint8_t *)&v11, 0xCu);
    }

    uint64_t v9 = (id *)(*(void *)(a1[4] + 8) + 40);
    dispatch_semaphore_t v10 = a3;
    goto LABEL_7;
  }
  if (v6)
  {
    uint64_t v9 = (id *)(*(void *)(a1[5] + 8) + 40);
    dispatch_semaphore_t v10 = a2;
LABEL_7:
    objc_storeStrong(v9, v10);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1[6] + 8) + 40));
}

void __PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v9 = a4;
  id v10 = a5;
  int v11 = pcsLogObjForScope("guitarfish-reset-protected-data");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = 134218498;
    uint64_t v19 = a2;
    __int16 v20 = 2048;
    uint64_t v21 = a3;
    __int16 v22 = 2112;
    id v23 = v10;
    _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, "PCSGuitarfishSetupIdentities returned with status: %ld, flags: %ld, error: %@", (uint8_t *)&v18, 0x20u);
  }

  uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v10;
  id v14 = v10;

  uint64_t v15 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = v9;
  id v17 = v9;

  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = a3;
  *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void OUTLINED_FUNCTION_5(uint64_t a1@<X8>)
{
  *(void *)(v1 - _Block_object_dispose(&a9, 8) = a1;
}

void OUTLINED_FUNCTION_6(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

__CFData *PCSBackupCreateEscrowedKeyWithIdentity(uint64_t a1, uint64_t a2, const void **a3)
{
  memset(v26, 0, sizeof(v26));
  CFDictionaryRef v6 = PCSIdentityCopyExportedPrivateKey(a2, a3);
  if (!v6) {
    goto LABEL_18;
  }
  CFDictionaryRef v7 = v6;
  id v8 = PCSIdentityCopyExportedPublicKey(a2);
  if (!v8)
  {
    _PCSErrorOOM(a3);
    CFRelease(v7);
    goto LABEL_18;
  }
  uint64_t v9 = v8;
  CFDataRef EscrowedCommon = (const __CFData *)BackupCreateEscrowedCommon(v7, v8, (uint64_t)v26, a3);
  CFRelease(v7);
  CFRelease(v9);
  if (!EscrowedCommon)
  {
LABEL_18:
    free_PCSBackupEscrow((uint64_t)v26);
    return 0;
  }
  int v11 = PCSIdentityCopyWrappedKey(a1, EscrowedCommon, a3);
  if (!v11)
  {
    free_PCSBackupEscrow((uint64_t)v26);
    CFRelease(EscrowedCommon);
    return 0;
  }
  uint64_t v12 = v11;
  _PCSFillOctetString((CFIndex *)v26, v11);
  LODWORD(v26[3]) = 2;
  uint64_t v13 = PCSIdentityCopyExportedPublicKey(a1);
  if (!_PCSFillOctetString((CFIndex *)&v26[3] + 1, v13))
  {
    _PCSErrorOOM(a3);
    goto LABEL_11;
  }
  uint64_t v25 = 0;
  CFIndex v14 = length_PCSBackupEscrow((uint64_t)v26);
  CFMutableSetRef Mutable = CFDataCreateMutable(0, v14);
  if (!Mutable)
  {
    uint64_t v19 = 12;
    goto LABEL_10;
  }
  uint64_t v16 = Mutable;
  CFDataSetLength(Mutable, v14);
  int MutableBytePtr = CFDataGetMutableBytePtr(v16);
  uint64_t v18 = encode_PCSBackupEscrow((uint64_t)&MutableBytePtr[v14 - 1], v14, (uint64_t)v26, (uint64_t)&v25);
  if (v18)
  {
    uint64_t v19 = v18;
    CFRelease(v16);
LABEL_10:
    _PCSErrorASN1(a3, (uint64_t)"encode PCSBackupEscrow", v19);
LABEL_11:
    uint64_t v16 = 0;
LABEL_13:
    free_PCSBackupEscrow((uint64_t)v26);
    if (v13) {
      CFRelease(v13);
    }
    CFRelease(EscrowedCommon);
    CFRelease(v12);
    return v16;
  }
  if (v14 == v25) {
    goto LABEL_13;
  }
  uint64_t v21 = asn1_abort();
  return (__CFData *)PCSBackupCopyRecoveredKeyWithIdentitySet(v21, v22, v23, v24);
}

CFTypeRef PCSBackupCopyRecoveredKeyWithIdentitySet(uint64_t a1, uint64_t a2, CFDataRef theData, const void **a4)
{
  uint64_t v27 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v10 = decode_PCSBackupEscrow((uint64_t)BytePtr, Length, (uint64_t)&v28, (uint64_t)&v27);
  if (v10)
  {
    uint64_t v24 = v10;
    uint64_t v25 = "decode PCSBackupEscrow";
    uint64_t v26 = a4;
LABEL_27:
    _PCSErrorASN1(v26, (uint64_t)v25, v24);
LABEL_30:
    free_PCSBackupEscrow((uint64_t)&v28);
    return 0;
  }
  uint64_t v11 = v27;
  if (v11 != CFDataGetLength(theData))
  {
    uint64_t v25 = "size PCSBackupEscrow";
    uint64_t v26 = a4;
    uint64_t v24 = 1859794442;
    goto LABEL_27;
  }
  if (v31 != 2)
  {
    _PCSError(a4, 57, @"wrong type: %d", v31);
    goto LABEL_30;
  }
  CFStringRef v12 = _PCSCreateBase64(v32, *((unint64_t *)&v31 + 1), 0);
  if (!v12)
  {
    _PCSErrorOOM(a4);
    goto LABEL_30;
  }
  CFStringRef v13 = v12;
  if (a2)
  {
    CFIndex v14 = (const void *)PCSIdentitySetCopyIdentity(a2, (uint64_t)v12);
    if (v14) {
      goto LABEL_10;
    }
    uint64_t v15 = PCSIdentitySetCopyIdentity(a1, (uint64_t)v13);
    if (v15)
    {
      CFIndex v14 = (const void *)v15;
      PCSIdentitySetAddIdentity(a2, v15);
      goto LABEL_10;
    }
  }
  else
  {
    CFIndex v14 = (const void *)PCSIdentitySetCopyIdentity(a1, (uint64_t)v12);
    if (v14)
    {
LABEL_10:
      CFDataRef v16 = CFDataCreate(0, *((const UInt8 **)&v28 + 1), v28);
      if (v16)
      {
        id v17 = PCSServiceIdentityCopyUnwrappedKey((uint64_t)v14, v16, a4);
        if (v17)
        {
          CFDataRef v18 = v17;
          CFDataRef v19 = CFDataCreateWithBytesNoCopy(0, *((const UInt8 **)&v29 + 1), v29, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
          if (v19)
          {
            __int16 v20 = _PCSStingrayCopyDecryptedData(v18, v19);
            uint64_t v21 = v20;
            if (v20)
            {
              CFTypeRef v22 = PCSIdentityCreateWithExportedPrivateKey(v20, a4);
LABEL_15:
              free_PCSBackupEscrow((uint64_t)&v28);
              CFRelease(v18);
              if (v21) {
                CFRelease(v21);
              }
              CFRelease(v13);
              CFRelease(v16);
              if (v19) {
                CFRelease(v19);
              }
LABEL_19:
              CFRelease(v14);
              return v22;
            }
            _PCSErrorOOM(a4);
          }
          else
          {
            _PCSErrorOOM(a4);
            uint64_t v21 = 0;
          }
          CFTypeRef v22 = 0;
          goto LABEL_15;
        }
      }
      else
      {
        _PCSErrorOOM(a4);
      }
      goto LABEL_21;
    }
  }
  _PCSError(a4, 70, @"Escrow identity missing: %@", v13);
  CFIndex v14 = 0;
  CFDataRef v16 = 0;
LABEL_21:
  free_PCSBackupEscrow((uint64_t)&v28);
  CFRelease(v13);
  if (v16) {
    CFRelease(v16);
  }
  CFTypeRef v22 = 0;
  CFTypeRef result = 0;
  if (v14) {
    goto LABEL_19;
  }
  return result;
}

__CFData *PCSBackupCreateEscrowedKeysetWithIdentity(uint64_t a1, const __CFData *a2, int a3, const void **a4)
{
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  CFDataRef EscrowedCommon = (const __CFData *)BackupCreateEscrowedCommon(a2, 0, (uint64_t)&v29, a4);
  if (!EscrowedCommon)
  {
    free_PCSBackupEscrow((uint64_t)&v29);
    return 0;
  }
  CFDataRef v8 = EscrowedCommon;
  uint64_t v9 = PCSIdentityCopyWrappedKey(a1, EscrowedCommon, a4);
  if (!v9)
  {
    free_PCSBackupEscrow((uint64_t)&v29);
    CFRelease(v8);
    return 0;
  }
  uint64_t v10 = v9;
  if (!_PCSFillOctetString((CFIndex *)&v29, v9)) {
    goto LABEL_26;
  }
  if (!a3) {
    goto LABEL_9;
  }
  CFDataRef v11 = CFDataCreateWithBytesNoCopy(0, *((const UInt8 **)&v30 + 1), v30, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (!v11) {
    goto LABEL_26;
  }
  CFDataRef v12 = v11;
  CFDataRef Signature = (const void *)PCSIdentityCreateSignature(a1, 0, v11, a4);
  CFRelease(v12);
  if (!Signature)
  {
LABEL_27:
    free_PCSBackupEscrow((uint64_t)&v29);
    CFDataRef v19 = 0;
LABEL_19:
    CFRelease(v8);
    CFRelease(v10);
    return v19;
  }
  CFIndex v14 = (CFIndex *)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  *((void *)&v33 + 1) = v14;
  if (!v14)
  {
    CFRelease(Signature);
    goto LABEL_26;
  }
  BOOL v15 = _PCSFillOctetString(v14, (CFDataRef)Signature);
  CFRelease(Signature);
  if (!v15)
  {
LABEL_26:
    _PCSErrorOOM(a4);
    goto LABEL_27;
  }
LABEL_9:
  LODWORD(v32) = 3;
  CFDataRef v16 = PCSIdentityCopyExportedPublicKey(a1);
  if (!_PCSFillOctetString((CFIndex *)&v32 + 1, v16))
  {
    _PCSErrorOOM(a4);
    goto LABEL_15;
  }
  uint64_t v28 = 0;
  CFIndex v17 = length_PCSBackupEscrow((uint64_t)&v29);
  CFMutableSetRef Mutable = CFDataCreateMutable(0, v17);
  if (!Mutable)
  {
    uint64_t v22 = 12;
    goto LABEL_14;
  }
  CFDataRef v19 = Mutable;
  CFDataSetLength(Mutable, v17);
  int MutableBytePtr = CFDataGetMutableBytePtr(v19);
  uint64_t v21 = encode_PCSBackupEscrow((uint64_t)&MutableBytePtr[v17 - 1], v17, (uint64_t)&v29, (uint64_t)&v28);
  if (v21)
  {
    uint64_t v22 = v21;
    CFRelease(v19);
LABEL_14:
    _PCSErrorASN1(a4, (uint64_t)"encode PCSBackupEscrow", v22);
LABEL_15:
    CFDataRef v19 = 0;
    goto LABEL_17;
  }
  if (v17 == v28)
  {
LABEL_17:
    free_PCSBackupEscrow((uint64_t)&v29);
    if (v16) {
      CFRelease(v16);
    }
    goto LABEL_19;
  }
  CFDataRef v24 = (const __CFData *)asn1_abort();
  return (__CFData *)BackupCreateEscrowedCommon(v24, v25, v26, v27);
}

CFTypeRef BackupCreateEscrowedCommon(const __CFData *a1, const __CFData *a2, uint64_t a3, const void **a4)
{
  Randomint Key = _PCSStingrayCreateRandomKey(a4);
  if (!RandomKey) {
    return 0;
  }
  uint64_t v9 = RandomKey;
  uint64_t v10 = _PCSStingrayCopyEncryptedData(RandomKey, a1);
  if (v10)
  {
    CFDataRef v11 = v10;
    if (_PCSFillOctetString((CFIndex *)(a3 + 16), v10) && (!a2 || _PCSFillOctetString((CFIndex *)(a3 + 32), a2)))
    {
      CFTypeRef v12 = CFRetain(v9);
    }
    else
    {
      _PCSErrorOOM(a4);
      CFTypeRef v12 = 0;
    }
    CFRelease(v11);
  }
  else
  {
    _PCSErrorOOM(a4);
    CFTypeRef v12 = 0;
  }
  CFRelease(v9);
  return v12;
}

__CFData *PCSBackupCopyRecoveredKeysetWithIdentity(uint64_t a1, CFDataRef theData, const void **a3)
{
  uint64_t v20 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v8 = decode_PCSBackupEscrow((uint64_t)BytePtr, Length, (uint64_t)&v21, (uint64_t)&v20);
  if (v8)
  {
    uint64_t v17 = v8;
    CFDataRef v18 = "decode PCSBackupEscrow";
    CFDataRef v19 = a3;
LABEL_14:
    _PCSErrorASN1(v19, (uint64_t)v18, v17);
LABEL_17:
    free_PCSBackupEscrow((uint64_t)&v21);
    return 0;
  }
  uint64_t v9 = v20;
  if (v9 != CFDataGetLength(theData))
  {
    CFDataRef v18 = "size PCSBackupEscrow";
    CFDataRef v19 = a3;
    uint64_t v17 = 1859794442;
    goto LABEL_14;
  }
  if (v24 != 3)
  {
    _PCSError(a3, 57, @"wrong type: %d", v24);
    goto LABEL_17;
  }
  CFDataRef v10 = CFDataCreate(0, *((const UInt8 **)&v21 + 1), v21);
  if (!v10)
  {
    _PCSErrorOOM(a3);
    goto LABEL_17;
  }
  CFDataRef v11 = v10;
  CFTypeRef v12 = PCSServiceIdentityCopyUnwrappedKey(a1, v10, a3);
  if (!v12)
  {
    free_PCSBackupEscrow((uint64_t)&v21);
    CFRelease(v11);
    return 0;
  }
  CFDataRef v13 = v12;
  CFDataRef v14 = CFDataCreateWithBytesNoCopy(0, *((const UInt8 **)&v22 + 1), v22, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (!v14 || (BOOL v15 = _PCSStingrayCopyDecryptedData(v13, v14)) == 0)
  {
    _PCSErrorOOM(a3);
    BOOL v15 = 0;
  }
  free_PCSBackupEscrow((uint64_t)&v21);
  CFRelease(v13);
  CFRelease(v11);
  if (v14) {
    CFRelease(v14);
  }
  return v15;
}

void _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v62 = 0;
  CFTypeRef v63 = &v62;
  uint64_t v64 = 0x3032000000;
  uint64_t v65 = __Block_byref_object_copy__4;
  uint64_t v66 = __Block_byref_object_dispose__4;
  id v67 = 0;
  uint64_t v56 = 0;
  id v57 = &v56;
  uint64_t v58 = 0x3032000000;
  id v59 = __Block_byref_object_copy__4;
  id v60 = __Block_byref_object_dispose__4;
  id v61 = 0;
  uint64_t v50 = 0;
  BOOL v51 = &v50;
  uint64_t v52 = 0x3032000000;
  id v53 = __Block_byref_object_copy__4;
  id v54 = __Block_byref_object_dispose__4;
  id v55 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = &v44;
  uint64_t v46 = 0x3032000000;
  uint64_t v47 = __Block_byref_object_copy__4;
  id v48 = __Block_byref_object_dispose__4;
  id v49 = 0;
  uint64_t v38 = 0;
  char v39 = &v38;
  uint64_t v40 = 0x3032000000;
  uint64_t v41 = __Block_byref_object_copy__4;
  uint64_t v42 = __Block_byref_object_dispose__4;
  id v43 = 0;
  uint64_t v32 = 0;
  long long v33 = &v32;
  uint64_t v34 = 0x3032000000;
  uint64_t v35 = __Block_byref_object_copy__4;
  id v36 = __Block_byref_object_dispose__4;
  id v37 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x3032000000;
  long long v29 = __Block_byref_object_copy__4;
  long long v30 = __Block_byref_object_dispose__4;
  id v31 = 0;
  dispatch_semaphore_t v8 = dispatch_semaphore_create(0);
  uint64_t v9 = (void *)v27[5];
  v27[5] = (uint64_t)v8;

  v25[0] = MEMORY[0x1E4F143A8];
  v25[1] = 3221225472;
  void v25[2] = ___PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey_block_invoke;
  v25[3] = &unk_1E5E6EFD0;
  void v25[4] = &v56;
  void v25[5] = &v62;
  v25[6] = &v26;
  _PCSBackupGuitarfishDecodeOuterRecord(v6, v25);
  dispatch_semaphore_wait((dispatch_semaphore_t)v27[5], 0xFFFFFFFFFFFFFFFFLL);
  CFDataRef v10 = (id *)(v57 + 5);
  if (v57[5] || (CFDataRef v11 = (void *)v63[5]) == 0)
  {
    CFTypeRef v12 = 0;
  }
  else
  {
    obuint64_t j = 0;
    CFTypeRef v12 = _PCSGuitarfishUnwrapDataWithAESKey(v11, v5, &obj);
    objc_storeStrong(v10, obj);
    CFDataRef v18 = (id *)(v57 + 5);
    if (v57[5] || !v12)
    {
      id v23 = (id)v57[5];
      _PCSNSError(&v23, 209, @"Unable to unwrap inner asn blob", v13, v14, v15, v16, v17, v21);
      objc_storeStrong(v18, v23);
    }
    else
    {
      dispatch_semaphore_t v19 = dispatch_semaphore_create(0);
      uint64_t v20 = (void *)v27[5];
      v27[5] = (uint64_t)v19;

      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      void v22[2] = ___PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey_block_invoke_2;
      v22[3] = &unk_1E5E6EFF8;
      v22[4] = &v56;
      v22[5] = &v50;
      void v22[6] = &v44;
      v22[7] = &v38;
      v22[8] = &v32;
      v22[9] = &v26;
      _PCSBackupGuitarfishDecodeInnerRecord(v12, v22);
      dispatch_semaphore_wait((dispatch_semaphore_t)v27[5], 0xFFFFFFFFFFFFFFFFLL);
    }
  }
  if (v57[5]) {
    (*((void (**)(id, void, void, void, void))v7 + 2))(v7, 0, 0, 0, 0);
  }
  else {
    (*((void (**)(id, uint64_t, uint64_t, uint64_t, uint64_t))v7 + 2))(v7, v51[5], v45[5], v39[5], v33[5]);
  }
  _Block_object_dispose(&v26, 8);

  _Block_object_dispose(&v32, 8);
  _Block_object_dispose(&v38, 8);

  _Block_object_dispose(&v44, 8);
  _Block_object_dispose(&v50, 8);

  _Block_object_dispose(&v56, 8);
  _Block_object_dispose(&v62, 8);
}

void sub_1ACFE0EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose((const void *)(v47 - 224), 8);
  _Block_object_dispose((const void *)(v47 - 176), 8);
  _Block_object_dispose((const void *)(v47 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
}

void _PCSBackupGuitarfishDecodeOuterRecord(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  id v5 = v3;
  uint64_t v6 = decode_PCSBackupGuitarfishEscrow([v5 bytes], objc_msgSend(v5, "length"), (uint64_t)&v28, (uint64_t)&v27);
  if (v6)
  {
    uint64_t v23 = v6;
    long long v24 = "decode PCSBackupGuitarfishEscrow";
  }
  else
  {
    uint64_t v7 = v27;
    if (v7 == [v5 length]) {
      goto LABEL_3;
    }
    long long v24 = "size PCSBackupGuitarfishEscrow";
    uint64_t v23 = 1859794442;
  }
  _PCSErrorASN1((const void **)&v26, (uint64_t)v24, v23);
LABEL_3:
  dispatch_semaphore_t v8 = v26;
  if (v26)
  {
    id v25 = v26;
    uint64_t v9 = [v5 length];
    _PCSNSError(&v25, 200, @"Unable to decode outer ASN; potentially missing. length: %lu",
      v10,
      v11,
      v12,
      v13,
      v14,
      v9);
    id v15 = v25;

    (*((void (**)(id, void, void, void, void, id))v4 + 2))(v4, 0, 0, 0, 0, v15);
  }
  else
  {
    id v16 = objc_alloc(MEMORY[0x1E4F1C9B8]);
    id v15 = (id)[v16 initWithBytes:*((void *)&v28 + 1) length:(void)v28];
    id v17 = objc_alloc(MEMORY[0x1E4F1C9B8]);
    CFDataRef v18 = (void *)[v17 initWithBytes:*((void *)&v29 + 1) length:(void)v29];
    id v19 = objc_alloc(MEMORY[0x1E4F1C9B8]);
    uint64_t v20 = (void *)[v19 initWithBytes:*((void *)&v30 + 1) length:(void)v30];
    id v21 = objc_alloc(MEMORY[0x1E4F1C9B8]);
    long long v22 = (void *)[v21 initWithBytes:*((void *)&v31 + 1) length:(void)v31];
    (*((void (**)(id, id, void *, void *, void *, void))v4 + 2))(v4, v15, v18, v20, v22, 0);
  }
  free_PCSBackupGuitarfishEscrow((uint64_t)&v28);
}

void _PCSBackupGuitarfishDecodeInnerRecord(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v37 = 0;
  uint64_t v38 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  id v5 = v3;
  uint64_t v6 = decode_PCSBackupGuitarfishEscrowContents([v5 bytes], objc_msgSend(v5, "length"), (uint64_t)&v39, (uint64_t)&v38);
  if (v6)
  {
    uint64_t v31 = v6;
    uint64_t v32 = "decode PCSBackupGuitarfishEscrowContents";
  }
  else
  {
    uint64_t v7 = v38;
    if (v7 == [v5 length]) {
      goto LABEL_3;
    }
    uint64_t v32 = "size PCSBackupGuitarfishEscrowContents";
    uint64_t v31 = 1859794442;
  }
  _PCSErrorASN1((const void **)&v37, (uint64_t)v32, v31);
LABEL_3:
  uint64_t v13 = v37;
  if (!v37)
  {
    if ((void)v40)
    {
      id v15 = objc_alloc(MEMORY[0x1E4F1C9B8]);
      id v16 = (void *)[v15 initWithBytes:*((void *)&v40 + 1) length:(void)v40];
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Decoded inner record with empty mnemonic data", buf, 2u);
      }
      id v16 = 0;
    }
    if ((void)v42)
    {
      id v17 = objc_alloc(MEMORY[0x1E4F1C9B8]);
      CFDataRef v18 = (void *)[v17 initWithBytes:*((void *)&v42 + 1) length:(void)v42];
      if (v16)
      {
LABEL_12:
        id v19 = (__CFString *)[objc_alloc(MEMORY[0x1E4F28E78]) initWithData:v16 encoding:4];
        CFStringTrimWhitespace(v19);
        uint64_t v20 = [(__CFString *)v19 componentsSeparatedByString:@" "];
        if (0xAAAAAAAAAAAAAAABLL * [v20 count] <= 0x5555555555555555
          && (unint64_t)[v20 count] >= 9
          && (unint64_t)[v20 count] < 0x19)
        {
          id v14 = 0;
        }
        else
        {
          id v34 = 0;
          uint64_t v21 = [v16 length];
          [v20 count];
          _PCSNSError(&v34, 201, @"Unable to decode mnemonic properly (length=%lu, count=%lu)", v22, v23, v24, v25, v26, v21);
          id v14 = v34;
        }

        goto LABEL_21;
      }
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Decoded inner record with empty recovery token key", buf, 2u);
      }
      CFDataRef v18 = 0;
      if (v16) {
        goto LABEL_12;
      }
    }
    id v14 = 0;
    uint64_t v20 = 0;
LABEL_21:
    id v27 = objc_alloc(MEMORY[0x1E4F1C9B8]);
    long long v28 = (void *)[v27 initWithBytes:*((void *)&v39 + 1) length:(void)v39];
    id v29 = objc_alloc(MEMORY[0x1E4F1C9B8]);
    long long v30 = (void *)[v29 initWithBytes:*((void *)&v41 + 1) length:(void)v41];
    v4[2](v4, v28, v20, v30, v18, v14);

    goto LABEL_22;
  }
  id v36 = v37;
  _PCSNSError(&v36, 201, @"Unable to decode inner ASN", v8, v9, v10, v11, v12, v33);
  id v14 = v36;

  v4[2](v4, 0, 0, 0, 0, v14);
LABEL_22:
  free_PCSBackupGuitarfishEscrowContents((uint64_t)&v39);
}

__CFData *_PCSBackupGuitarfishEncodeOuterRecord(void *a1, __CFData *a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  uint64_t v76 = a7;
  CFDataRef v80 = a1;
  unint64_t v82 = a3;
  id v12 = a4;
  id v81 = a5;
  id v18 = a6;
  id v129 = 0;
  id v130 = 0;
  uint64_t v124 = 0;
  CFTypeRef v125 = (id *)&v124;
  uint64_t v126 = 0x3032000000;
  char v127 = __Block_byref_object_copy__4;
  long long v128 = __Block_byref_object_dispose__4;
  uint64_t v118 = 0;
  uint64_t v119 = &v118;
  uint64_t v120 = 0x3032000000;
  uint64_t v121 = __Block_byref_object_copy__4;
  uint64_t v122 = __Block_byref_object_dispose__4;
  id v123 = 0;
  long long v131 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  uint64_t v79 = v12;
  if (!v18)
  {
    CFDataRef v29 = 0;
    CFDataRef i = 0;
    unint64_t v28 = 0;
    id v26 = 0;
    goto LABEL_17;
  }
  *(void *)long long buf = 0;
  int v113 = buf;
  uint64_t v114 = 0x3032000000;
  int v115 = __Block_byref_object_copy__4;
  unint64_t v116 = __Block_byref_object_dispose__4;
  id v117 = 0;
  uint64_t v106 = 0;
  uint64_t v107 = &v106;
  uint64_t v108 = 0x3032000000;
  uint64_t v109 = __Block_byref_object_copy__4;
  int v110 = __Block_byref_object_dispose__4;
  id v111 = 0;
  uint64_t v100 = 0;
  uint64_t v101 = &v100;
  uint64_t v102 = 0x3032000000;
  uint64_t v103 = __Block_byref_object_copy__4;
  uint64_t v104 = __Block_byref_object_dispose__4;
  id v105 = 0;
  uint64_t v94 = 0;
  uint64_t v95 = &v94;
  uint64_t v96 = 0x3032000000;
  dispatch_semaphore_t v97 = __Block_byref_object_copy__4;
  CFDictionaryRef v98 = __Block_byref_object_dispose__4;
  id v99 = 0;
  dispatch_semaphore_t v19 = dispatch_semaphore_create(0);
  uint64_t v20 = (void *)v119[5];
  v119[5] = (uint64_t)v19;

  v93[0] = MEMORY[0x1E4F143A8];
  v93[1] = 3221225472;
  v93[2] = ___PCSBackupGuitarfishEncodeOuterRecord_block_invoke;
  v93[3] = &unk_1E5E6F020;
  v93[4] = &v124;
  v93[5] = buf;
  v93[6] = &v106;
  v93[7] = &v100;
  v93[8] = &v94;
  v93[9] = &v118;
  _PCSBackupGuitarfishDecodeOuterRecord(v18, v93);
  dispatch_semaphore_wait((dispatch_semaphore_t)v119[5], 0xFFFFFFFFFFFFFFFFLL);
  id v26 = v125 + 5;
  id v27 = v125[5];
  if (v27) {
    goto LABEL_78;
  }
  if (!v82)
  {
    unint64_t v28 = (unint64_t)*((id *)v113 + 5);
    if (v12) {
      goto LABEL_5;
    }
LABEL_8:
    id v26 = (id)v107[5];
    goto LABEL_9;
  }
  unint64_t v28 = 0;
  if (!v12) {
    goto LABEL_8;
  }
LABEL_5:
  id v26 = 0;
LABEL_9:
  if (v81)
  {
    CFDataRef v29 = 0;
    if (a2)
    {
LABEL_11:
      CFDataRef i = 0;
      goto LABEL_14;
    }
  }
  else
  {
    CFDataRef v29 = (const __CFData *)(id)v95[5];
    if (a2) {
      goto LABEL_11;
    }
  }
  for (CFDataRef i = (const __CFData *)(id)v101[5]; ; CFDataRef i = 0)
  {
LABEL_14:
    _Block_object_dispose(&v94, 8);

    _Block_object_dispose(&v100, 8);
    _Block_object_dispose(&v106, 8);

    _Block_object_dispose(buf, 8);
    if (v27) {
      goto LABEL_15;
    }
LABEL_17:
    if (!(v82 | v28))
    {
      uint64_t v75 = v125;
      id v91 = v125[5];
      _PCSNSError(&v91, 204, @"missing primary HSM Record Secret parameter", v13, v14, v15, v16, v17, v76);
      objc_storeStrong(v75 + 5, v91);
      id v31 = 0;
      unint64_t v28 = 0;
LABEL_16:
      uint64_t v32 = 0;
      int v78 = 0;
      goto LABEL_68;
    }
    if (!v81)
    {
      id v73 = v125;
      id v90 = v125[5];
      _PCSNSError(&v90, 207, @"Missing Encrypted Contents parameter", v13, v14, v15, v16, v17, v76);
      objc_storeStrong(v73 + 5, v90);
LABEL_15:
      id v31 = 0;
      goto LABEL_16;
    }
    if (i)
    {
      uint64_t v33 = 0;
      goto LABEL_30;
    }
    if (!a2) {
      break;
    }
    id v34 = PCSIdentityCopyWrappedKey((uint64_t)a2, v80, (const void **)&v130);
    if (v130)
    {
      id v35 = v125[5];
      v125[5] = v130;
    }
    uint64_t v33 = v34;
    id v31 = 0;
    if (v125[5] || (CFDataRef i = v33) == 0)
    {
      int v78 = v33;
      CFDataRef i = v33;
      uint64_t v32 = 0;
      a2 = 0;
      goto LABEL_69;
    }
LABEL_30:
    int v78 = v33;
    if (!_PCSFillOctetString((CFIndex *)&v133, i))
    {
      _PCSErrorOOM((const void **)&v130);
LABEL_82:
      id v31 = 0;
      uint64_t v32 = 0;
      goto LABEL_68;
    }
    if (v130)
    {
      id v37 = v125[5];
      v125[5] = v130;
    }
    uint64_t v38 = v125 + 5;
    if (v125[5]) {
      goto LABEL_82;
    }
    if (v28)
    {
      uint64_t v32 = 0;
    }
    else
    {
      obuint64_t j = 0;
      uint64_t v32 = _PCSGuitarfishWrapKeyWithAESKey(v80, (void *)v82, &obj);
      objc_storeStrong(v38, obj);
      uint64_t v44 = v125 + 5;
      if (v125[5] || !v32)
      {
        id v88 = v125[5];
        _PCSNSError(&v88, 12, @"unable to wrap data to key for primary hsm secret", v39, v40, v41, v42, v43, v76);
        objc_storeStrong(v44, v88);
        id v31 = 0;
        unint64_t v28 = 0;
        goto LABEL_68;
      }
      unint64_t v28 = v32;
      uint64_t v32 = (void *)v28;
    }
    if (!_PCSFillOctetString((CFIndex *)&v131, (CFDataRef)v28))
    {
      _PCSErrorOOM((const void **)&v130);
LABEL_84:
      id v31 = 0;
      goto LABEL_68;
    }
    if (v130)
    {
      id v45 = v125[5];
      v125[5] = v130;
    }
    uint64_t v46 = v125 + 5;
    if (v125[5]) {
      goto LABEL_84;
    }
    if (v79)
    {
      id v87 = 0;
      _PCSGuitarfishWrapKeyWithAESKey(v80, v79, &v87);
      id v31 = (id)objc_claimAutoreleasedReturnValue();
      objc_storeStrong(v46, v87);
      uint64_t v52 = v125 + 5;
      if (v125[5] || !v31)
      {
        id v86 = v125[5];
        _PCSNSError(&v86, 19, @"Unable to wrap recoveryTokenSecret record to wrapping key", v47, v48, v49, v50, v51, v76);
        id v74 = v86;
        goto LABEL_91;
      }
      id v31 = v31;

      id v26 = v31;
    }
    else
    {
      if (!v26)
      {
        id v53 = pcsLogObjForScope("Guitarfish");
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1ACF98000, v53, OS_LOG_TYPE_DEFAULT, "using empty resolvedRecoverTokenHSMWrap for encoding outer record", buf, 2u);
        }

        id v26 = objc_alloc_init(MEMORY[0x1E4F1C9B8]);
      }
      id v31 = 0;
    }
    if (!_PCSFillOctetString((CFIndex *)&v132, (CFDataRef)v26)) {
      goto LABEL_85;
    }
    if (v130)
    {
      id v54 = v125[5];
      v125[5] = v130;
    }
    id v55 = v125 + 5;
    if (v125[5]) {
      goto LABEL_68;
    }
    if (!v29)
    {
      id v85 = 0;
      _PCSGuitarfishWrapDataWithAESKey(v81, v80, &v85);
      CFDataRef v29 = (const __CFData *)objc_claimAutoreleasedReturnValue();
      objc_storeStrong(v55, v85);
      uint64_t v52 = v125 + 5;
      if (v125[5] || !v29)
      {
        id v84 = v125[5];
        _PCSNSError(&v84, 19, @"Unable to wrap encryptedcontents record to wrapping key", v56, v57, v58, v59, v60, v76);
        id v74 = v84;
LABEL_91:
        objc_storeStrong(v52, v74);
        goto LABEL_68;
      }
    }
    if (!_PCSFillOctetString((CFIndex *)&v134, v29))
    {
LABEL_85:
      _PCSErrorOOM((const void **)&v130);
      goto LABEL_68;
    }
    if (v130)
    {
      id v61 = v125[5];
      v125[5] = v130;
    }
    if (v125[5]) {
      goto LABEL_68;
    }
    *(void *)long long buf = 0;
    id v27 = (id)length_PCSBackupGuitarfishEscrow((uint64_t)&v131);
    CFMutableSetRef Mutable = CFDataCreateMutable(0, (CFIndex)v27);
    a2 = Mutable;
    if (!Mutable)
    {
      uint64_t v64 = 12;
LABEL_67:
      _PCSErrorASN1((const void **)&v130, (uint64_t)"encode PCSBackupGuitarfishEscrow", v64);
LABEL_68:
      a2 = 0;
      goto LABEL_69;
    }
    CFDataSetLength(Mutable, (CFIndex)v27);
    int MutableBytePtr = CFDataGetMutableBytePtr(a2);
    uint64_t v64 = encode_PCSBackupGuitarfishEscrow((uint64_t)v27 + (void)MutableBytePtr - 1, (uint64_t)v27, (uint64_t)&v131, (uint64_t)buf);
    if (v64)
    {
      CFRelease(a2);
      goto LABEL_67;
    }
    if (v27 == *(id *)buf) {
      goto LABEL_69;
    }
    asn1_abort();
    __break(1u);
LABEL_78:
    id v92 = v27;
    _PCSNSError(&v92, 200, @"unable to decode existing blob", v21, v22, v23, v24, v25, v76);
    objc_storeStrong((id *)v26, v92);
    CFDataRef v29 = 0;
    unint64_t v28 = 0;
    id v26 = 0;
  }
  id v36 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, v36, OS_LOG_TYPE_DEFAULT, "using empty resolvedWrapToEscrow for encoding outer record", buf, 2u);
  }

  CFDataRef i = (const __CFData *)objc_alloc_init(MEMORY[0x1E4F1C9B8]);
  uint64_t v33 = 0;
  if (i) {
    goto LABEL_30;
  }
  id v31 = 0;
  CFDataRef i = 0;
  uint64_t v32 = 0;
  int v78 = 0;
  a2 = 0;
LABEL_69:
  free_PCSBackupGuitarfishEscrow((uint64_t)&v131);
  uint64_t v70 = v125 + 5;
  if (v125[5])
  {
    id v83 = v125[5];
    _PCSNSError(&v83, 202, @"Unable to encode outer record", v65, v66, v67, v68, v69, v76);
    objc_storeStrong(v70, v83);
    if (v77)
    {
      id v71 = v125[5];
      if (v71) {
        *uint64_t v77 = v71;
      }
    }
  }
  _Block_object_dispose(&v118, 8);

  _Block_object_dispose(&v124, 8);
  return a2;
}

void sub_1ACFE1F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
  _Block_object_dispose(&a60, 8);
  _Block_object_dispose((const void *)(v60 - 216), 8);
  _Unwind_Resume(a1);
}

__CFData *_PCSBackupGuitarfishEncodeInnerRecord(void *a1, void *a2, void *a3, void *a4)
{
  CFDataRef v7 = a1;
  id v8 = a2;
  CFDataRef v9 = a3;
  CFDataRef v10 = a4;
  uint64_t v23 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  if (!v7) {
    CFDataRef v7 = (const __CFData *)objc_alloc_init(MEMORY[0x1E4F1C9B8]);
  }
  if (!_PCSFillOctetString((CFIndex *)&v24, v7)
    || v8
    && ([v8 componentsJoinedByString:@" "],
        uint64_t v11 = objc_claimAutoreleasedReturnValue(),
        BOOL v12 = _PCSFillOctetString((CFIndex *)&v25, (CFDataRef)[v11 dataUsingEncoding:4]),
        v11,
        !v12)
    || !_PCSFillOctetString((CFIndex *)&v26, v9)
    || v10 && !_PCSFillOctetString((CFIndex *)&v27, v10))
  {
    _PCSErrorOOM(&v23);
    goto LABEL_14;
  }
  uint64_t v22 = 0;
  CFIndex v13 = length_PCSBackupGuitarfishEscrowContents((uint64_t)&v24);
  CFMutableSetRef Mutable = CFDataCreateMutable(0, v13);
  if (!Mutable)
  {
    uint64_t v18 = 12;
    goto LABEL_13;
  }
  uint64_t v15 = Mutable;
  CFDataSetLength(Mutable, v13);
  int MutableBytePtr = CFDataGetMutableBytePtr(v15);
  uint64_t v17 = encode_PCSBackupGuitarfishEscrowContents((uint64_t)&MutableBytePtr[v13 - 1], v13, (uint64_t)&v24, (uint64_t)&v22);
  if (v17)
  {
    uint64_t v18 = v17;
    CFRelease(v15);
LABEL_13:
    _PCSErrorASN1(&v23, (uint64_t)"encode PCSBackupGuitarfishEscrowContents", v18);
LABEL_14:
    uint64_t v15 = 0;
    goto LABEL_16;
  }
  if (v13 != v22)
  {
    uint64_t v20 = (void *)asn1_abort();
    return (__CFData *)+[PCSKeybagKey supportsSecureCoding];
  }
LABEL_16:
  free_PCSBackupGuitarfishEscrowContents((uint64_t)&v24);

  return v15;
}

void _PCSSyncingSetupInterface(void *a1)
{
  uint64_t v1 = _PCSSyncingSetupInterface_onceToken;
  id v2 = a1;
  id v5 = v2;
  if (v1 != -1)
  {
    dispatch_once(&_PCSSyncingSetupInterface_onceToken, &__block_literal_global_13);
    id v2 = v5;
  }
  [v2 setClasses:_PCSSyncingSetupInterface_errClasses forSelector:sel_getAllClients_ argumentIndex:1 ofReply:1];
  [v5 setClasses:_PCSSyncingSetupInterface_errClasses forSelector:sel_syncKeys_withReply_ argumentIndex:1 ofReply:1];
  [v5 setClasses:_PCSSyncingSetupInterface_errClasses forSelector:sel_triggerDaily_withReply_ argumentIndex:1 ofReply:1];
  id v3 = objc_msgSend(MEMORY[0x1E4F1CAD0], "setWithObjects:", objc_opt_class(), 0);
  [v5 setClasses:v3 forSelector:sel_triggerSyncingWithEscrowProxy_dsid_publicKeys_accountIdentifier_settingsKeyExpirationDate_settingsKeyIdentifier_complete_ argumentIndex:1 ofReply:1];

  [v5 setClasses:_PCSSyncingSetupInterface_errClasses forSelector:sel_triggerSyncingWithEscrowProxy_dsid_publicKeys_accountIdentifier_settingsKeyExpirationDate_settingsKeyIdentifier_complete_ argumentIndex:2 ofReply:1];
  id v4 = objc_msgSend(MEMORY[0x1E4F1CAD0], "setWithObjects:", objc_opt_class(), 0);
  [v5 setClasses:v4 forSelector:sel_createIdentity_dsid_roll_sync_forceSync_complete_ argumentIndex:1 ofReply:1];

  [v5 setClasses:_PCSSyncingSetupInterface_errClasses forSelector:sel_createIdentity_dsid_roll_sync_forceSync_complete_ argumentIndex:2 ofReply:1];
  [v5 setClasses:_PCSSyncingSetupInterface_statsClasses forSelector:sel_fetchStats_ argumentIndex:0 ofReply:1];
  [v5 setClasses:_PCSSyncingSetupInterface_errClasses forSelector:sel_setupIdentitiesWithParameters_complete_ argumentIndex:2 ofReply:1];
}

void PCSKeySyncingGetAllClients(void *a1)
{
  id v1 = a1;
  id v2 = connectionPCSKeySyncing();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __PCSKeySyncingGetAllClients_block_invoke;
  v5[3] = &unk_1E5E6F070;
  id v6 = v1;
  id v3 = v1;
  id v4 = [v2 remoteObjectProxyWithErrorHandler:v5];
  [v4 getAllClients:v3];
}

id connectionPCSKeySyncing()
{
  if (connectionPCSKeySyncing_onceToken != -1) {
    dispatch_once(&connectionPCSKeySyncing_onceToken, &__block_literal_global_306);
  }
  CFDictionaryRef v0 = (void *)connectionPCSKeySyncing_connection;
  return v0;
}

uint64_t __PCSKeySyncingGetAllClients_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSKeySyncingSyncKeys(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = connectionPCSKeySyncing();
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = __PCSKeySyncingSyncKeys_block_invoke;
  void v8[3] = &unk_1E5E6F070;
  id v9 = v3;
  id v6 = v3;
  CFDataRef v7 = [v5 remoteObjectProxyWithErrorHandler:v8];
  [v7 syncKeys:v4 withReply:v6];
}

uint64_t __PCSKeySyncingSyncKeys_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSKeySyncingTriggerDaily()
{
  CFDictionaryRef v0 = connectionPCSKeySyncing();
  dispatch_semaphore_t v1 = dispatch_semaphore_create(0);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  v8[2] = __PCSKeySyncingTriggerDaily_block_invoke;
  void v8[3] = &unk_1E5E6F098;
  id v2 = v1;
  id v9 = v2;
  id v3 = [v0 remoteObjectProxyWithErrorHandler:v8];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __PCSKeySyncingTriggerDaily_block_invoke_2;
  v6[3] = &unk_1E5E6F0C0;
  CFDataRef v7 = v2;
  id v4 = v2;
  [v3 triggerDaily:MEMORY[0x1E4F1CC08] withReply:v6];

  dispatch_time_t v5 = dispatch_time(0, 5000000000);
  dispatch_semaphore_wait(v4, v5);
}

intptr_t __PCSKeySyncingTriggerDaily_block_invoke(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

intptr_t __PCSKeySyncingTriggerDaily_block_invoke_2(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void PCSSyncKeyRegistryWithServiceName(void *a1, void *a2)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  CFDataRef v7 = kPCSSetupService[0];
  v8[0] = a1;
  id v3 = (void *)MEMORY[0x1E4F1C9E8];
  id v4 = a2;
  id v5 = a1;
  id v6 = [v3 dictionaryWithObjects:v8 forKeys:&v7 count:1];

  PCSSyncKeyRegistryWithOptions(v6, v4);
}

void PCSSyncKeyRegistryWithOptions(void *a1, void *a2)
{
  v49[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = connectionPCSKeySyncing();
  if (v3)
  {
    id v6 = [v3 objectForKeyedSubscript:kPCSSetupService[0]];
    CFDataRef v7 = [v3 objectForKeyedSubscript:kPCSSetupDSID[0]];
    if (!PCSCurrentPersonaMatchesDSID(v7))
    {
      long long v26 = (void *)MEMORY[0x1E4F28C58];
      long long v27 = kPCSErrorDomain;
      uint64_t v48 = *MEMORY[0x1E4F28568];
      v49[0] = @"Current persona does not match chosen dsid";
      id v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v49 forKeys:&v48 count:1];
      long long v25 = [v26 errorWithDomain:v27 code:152 userInfo:v8];
      v4[2](v4, 0, v25);
      goto LABEL_18;
    }
    id v8 = [v3 objectForKeyedSubscript:kPCSSetupPublicKeys[0]];
    id v9 = [v3 objectForKeyedSubscript:kPCSSetupMTTCallback[0]];
  }
  else
  {
    id v9 = 0;
    id v8 = 0;
    CFDataRef v7 = 0;
    id v6 = 0;
  }
  CFDataRef v10 = +[PCSAccountsModel accountForCurrentPersona];
  uint64_t v11 = v10;
  id v36 = v9;
  if (v7 || (objc_msgSend(v10, "aa_personID"), (CFDataRef v7 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    id v34 = v11;
    id v35 = v3;
    uint64_t v33 = [v11 identifier];
    id v43 = 0;
    uint64_t v12 = +[PCSAccountsModel settingsKeyForKey:@"nextRegistrySync" error:&v43];
    id v13 = v43;
    id v14 = v13;
    uint64_t v32 = (void *)v12;
    if ((!v12 || v13) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v45 = v14;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to get key: %@", buf, 0xCu);
    }
    id v31 = v14;
    id v42 = 0;
    uint64_t v15 = +[PCSAccountsModel settingsKeyForKey:@"registrySyncIdentifier" error:&v42];
    id v16 = v42;
    uint64_t v17 = v16;
    uint64_t v18 = (void *)v15;
    if ((!v15 || v16) && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v45 = v17;
      _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Failed to get key: %@", buf, 0xCu);
    }
    v39[0] = MEMORY[0x1E4F143A8];
    v39[1] = 3221225472;
    v39[2] = __PCSSyncKeyRegistryWithOptions_block_invoke;
    v39[3] = &unk_1E5E6F0E8;
    id v40 = v9;
    uint64_t v41 = v4;
    dispatch_semaphore_t v19 = (void *)MEMORY[0x1AD11D080](v39);
    v37[0] = MEMORY[0x1E4F143A8];
    v37[1] = 3221225472;
    v37[2] = __PCSSyncKeyRegistryWithOptions_block_invoke_2;
    v37[3] = &unk_1E5E6F070;
    id v38 = v19;
    id v20 = v19;
    [v5 remoteObjectProxyWithErrorHandler:v37];
    SEL v21 = v5;
    uint64_t v23 = v22 = v4;
    long long v24 = (void *)v33;
    [v23 triggerSyncingWithEscrowProxy:v6 dsid:v7 publicKeys:v8 accountIdentifier:v33 settingsKeyExpirationDate:v32 settingsKeyIdentifier:v18 complete:v20];

    id v4 = v22;
    id v5 = v21;

    uint64_t v11 = v34;
    id v3 = v35;
  }
  else
  {
    unint64_t v28 = (void *)MEMORY[0x1E4F28C58];
    CFDataRef v29 = kPCSErrorDomain;
    uint64_t v46 = *MEMORY[0x1E4F28568];
    uint64_t v47 = @"unable to determine DSID";
    long long v30 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v47 forKeys:&v46 count:1];
    long long v24 = [v28 errorWithDomain:v29 code:66 userInfo:v30];

    v4[2](v4, 0, v24);
    CFDataRef v7 = 0;
  }

  long long v25 = v36;
LABEL_18:
}

void __PCSSyncKeyRegistryWithOptions_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(v6 + 16))(v6, a3);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t __PCSSyncKeyRegistryWithOptions_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSAccountOldSetupIdentities(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = a1;
  connectionPCSKeySyncing();
  id v8 = (id)objc_claimAutoreleasedReturnValue();
  id v7 = [v8 remoteObjectProxyWithErrorHandler:&__block_literal_global_174];
  [v7 setupIdentitiesForAccount:v6 withParameters:v5 optional:a3];
}

uint64_t PCSAccountMigrateToiCDP(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = connectionPCSKeySyncing();
  uint64_t v20 = 0;
  SEL v21 = &v20;
  uint64_t v22 = 0x2020000000;
  char v23 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x3032000000;
  uint64_t v17 = __Block_byref_object_copy__4;
  uint64_t v18 = __Block_byref_object_dispose__4;
  id v19 = 0;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  void v13[2] = __PCSAccountMigrateToiCDP_block_invoke;
  v13[3] = &unk_1E5E6EEA8;
  void v13[4] = &v14;
  id v8 = [v7 synchronousRemoteObjectProxyWithErrorHandler:v13];
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 3221225472;
  v12[2] = __PCSAccountMigrateToiCDP_block_invoke_2;
  void v12[3] = &unk_1E5E6F130;
  void v12[4] = &v20;
  v12[5] = &v14;
  [v8 migrateToiCDPForAccount:v5 withParameters:v6 complete:v12];

  if (a3)
  {
    id v9 = (void *)v15[5];
    if (v9) {
      *a3 = v9;
    }
  }
  uint64_t v10 = *((unsigned __int8 *)v21 + 24);
  _Block_object_dispose(&v14, 8);

  _Block_object_dispose(&v20, 8);
  return v10;
}

void sub_1ACFE356C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

void __PCSAccountMigrateToiCDP_block_invoke(uint64_t a1, void *a2)
{
}

void __PCSAccountMigrateToiCDP_block_invoke_2(uint64_t a1, char a2, id obj)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), obj);
}

BOOL PCSAccountEnableWalrus(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = connectionPCSKeySyncing();
  uint64_t v24 = 0;
  long long v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 0;
  uint64_t v18 = 0;
  id v19 = &v18;
  uint64_t v20 = 0x3032000000;
  SEL v21 = __Block_byref_object_copy__4;
  uint64_t v22 = __Block_byref_object_dispose__4;
  id v23 = 0;
  id v8 = [v6 objectForKeyedSubscript:kPCSSetupGuitarfish[0]];
  if ([v8 BOOLValue])
  {
    id v17 = 0;
    id v9 = PCSGuitarfishCreateSetupParameters(v6, 1, 0, &v17);
    id v10 = v17;

    if (!v9 || v10)
    {
      if (a3) {
        *a3 = v10;
      }

      BOOL v11 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    id v9 = v6;
  }
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  v16[2] = __PCSAccountEnableWalrus_block_invoke;
  v16[3] = &unk_1E5E6EEA8;
  _OWORD v16[4] = &v18;
  uint64_t v12 = [v7 synchronousRemoteObjectProxyWithErrorHandler:v16];
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  _OWORD v15[2] = __PCSAccountEnableWalrus_block_invoke_2;
  void v15[3] = &unk_1E5E6F130;
  void v15[4] = &v24;
  v15[5] = &v18;
  [v12 enableWalrusForAccount:v5 withParameters:v9 complete:v15];

  if (*((unsigned char *)v25 + 24))
  {
    BOOL v11 = 1;
  }
  else
  {
    BOOL v11 = 0;
    if (a3)
    {
      uint64_t v13 = (void *)v19[5];
      if (v13)
      {
        *a3 = v13;
        BOOL v11 = *((unsigned char *)v25 + 24) != 0;
      }
    }
  }
LABEL_13:

  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v24, 8);

  return v11;
}

void sub_1ACFE3824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

id PCSGuitarfishCreateSetupParameters(void *a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  uint64_t v14 = v7;
  v118[0] = 0;
  v118[1] = v118;
  v118[2] = 0x2020000000;
  v118[3] = 0;
  if (!v7
    || ([v7 objectForKeyedSubscript:kPCSSetupDSID[0]],
        (uint64_t v15 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    PCSErrorCreate(121, @"Missing DSID in parameters", v8, v9, v10, v11, v12, v13, v86);
    id v48 = 0;
    *a4 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_25;
  }
  uint64_t v22 = [v14 objectForKeyedSubscript:kPCSSetupRawPassword[0]];
  if (!v22)
  {
    PCSErrorCreate(123, @"Missing raw password in parameters", v16, v17, v18, v19, v20, v21, v86);
    *a4 = (id)objc_claimAutoreleasedReturnValue();

LABEL_24:
    id v48 = 0;
    goto LABEL_25;
  }
  CFDataRef v29 = [v14 objectForKeyedSubscript:kPCSSetupPassword[0]];
  if (!v29)
  {
    PCSErrorCreate(123, @"Missing password in parameters", v23, v24, v25, v26, v27, v28, v86);
    *a4 = (id)objc_claimAutoreleasedReturnValue();

    goto LABEL_24;
  }
  if (!PCSCurrentPersonaMatchesDSID(v15))
  {
    PCSErrorCreate(152, @"Current persona does not match chosen dsid", v30, v31, v32, v33, v34, v35, v86);
    *a4 = (id)objc_claimAutoreleasedReturnValue();

    goto LABEL_24;
  }
  uint64_t v94 = 0;
  uint64_t v96 = 0;
  id v117 = 0;
  if (!a2) {
    goto LABEL_46;
  }
  Random = _PCSStingrayCreateRandom(0x20uLL, (const void **)&v117);
  if (v117 || !Random)
  {
    uint64_t v94 = 0;
    uint64_t v96 = 0;
    id v48 = 0;
    *a4 = v117;
LABEL_68:

    goto LABEL_69;
  }
  id v36 = _PCSStingrayCreateRandom(0x20uLL, (const void **)&v117);
  if (v117 || !v36)
  {
    *a4 = v117;

    uint64_t v94 = 0;
    uint64_t v96 = 0;
    id v48 = 0;
    goto LABEL_68;
  }
  p_long long buf = (id *)&buf;
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v120 = 0x3032000000;
  uint64_t v121 = __Block_byref_object_copy__4;
  uint64_t v122 = __Block_byref_object_dispose__4;
  id v123 = 0;
  if (!a3)
  {
    uint64_t v50 = 0;
    id v90 = 0;
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    goto LABEL_31;
  }
  id v38 = _PCSStingrayCreateRandom(0x20uLL, (const void **)&v117);
  id v90 = v38;
  if (v117 || !v38)
  {
    id v92 = 0;
    uint64_t v94 = 0;
    uint64_t v96 = 0;
    *a4 = v117;
    goto LABEL_43;
  }
  uint64_t v95 = _PCSStingrayCreateRandom(0x10uLL, (const void **)&v117);
  uint64_t v96 = 0;
  uint64_t v39 = v117;
  if (v117 || !v95)
  {
LABEL_42:
    *a4 = v39;

    id v92 = 0;
    uint64_t v94 = 0;
    goto LABEL_43;
  }
  uint64_t v96 = +[MnemonicRepresentation mnemonicFrom:v95];
  if (v117 || !v96)
  {
    uint64_t v39 = PCSErrorCreate(214, @"unable to create mnemonic from input entropy", v40, v41, v42, v43, v44, v45, v86);
    goto LABEL_42;
  }
  v115[0] = 0;
  v115[1] = v115;
  v115[2] = 0x3032000000;
  v115[3] = __Block_byref_object_copy__4;
  void v115[4] = __Block_byref_object_dispose__4;
  id v116 = 0;
  uint64_t v109 = 0;
  int v110 = &v109;
  uint64_t v111 = 0x3032000000;
  int v112 = __Block_byref_object_copy__4;
  int v113 = __Block_byref_object_dispose__4;
  id v114 = 0;
  v108[0] = MEMORY[0x1E4F143A8];
  v108[1] = 3221225472;
  v108[2] = __PCSGuitarfishCreateSetupParameters_block_invoke;
  v108[3] = &unk_1E5E6EE80;
  v108[4] = v115;
  v108[5] = &v109;
  v108[6] = &buf;
  PCSGuitarfishDeriveRecoveryKeyFromMnemonic((uint64_t)v96, v108);
  uint64_t v47 = (id *)(*((void *)&buf + 1) + 40);
  uint64_t v46 = *(void **)(*((void *)&buf + 1) + 40);
  if (v46)
  {
    id v92 = 0;
  }
  else
  {
    id v84 = (void *)v110[5];
    id v107 = 0;
    id v92 = _PCSGuitarfishDeriveRecoveryTokenWrap(v84, v90, &v107);
    objc_storeStrong(v47, v107);
    uint64_t v46 = *(void **)(*((void *)&buf + 1) + 40);
    if (!v46)
    {
      int v85 = 1;
      goto LABEL_73;
    }
  }
  int v85 = 0;
  *a4 = v46;
LABEL_73:
  _Block_object_dispose(&v109, 8);

  _Block_object_dispose(v115, 8);
  if (v85)
  {
    p_long long buf = (id *)*((void *)&buf + 1);
    uint64_t v50 = *(void **)(*((void *)&buf + 1) + 40);
    uint64_t v52 = v96;
    uint64_t v51 = v92;
LABEL_31:
    obuint64_t j = v50;
    uint64_t v96 = v52;
    id v92 = v51;
    uint64_t v89 = _PCSBackupGuitarfishEncodeInnerRecord(0, v52, Random, v51);
    objc_storeStrong(p_buf + 5, obj);
    id v54 = (id *)(*((void *)&buf + 1) + 40);
    id v53 = *(void **)(*((void *)&buf + 1) + 40);
    if (v53)
    {
      id v55 = v53;
      uint64_t v94 = 0;
    }
    else
    {
      id v105 = 0;
      uint64_t v94 = _PCSBackupGuitarfishEncodeOuterRecord(v36, 0, Random, v92, v89, 0, (uint64_t)&v105);
      objc_storeStrong(v54, v105);
      uint64_t v56 = *(void **)(*((void *)&buf + 1) + 40);
      if (!v56)
      {
        dispatch_semaphore_t v58 = dispatch_semaphore_create(0);
        v102[0] = MEMORY[0x1E4F143A8];
        v102[1] = 3221225472;
        v102[2] = __PCSGuitarfishCreateSetupParameters_block_invoke_2;
        v102[3] = &unk_1E5E6EE58;
        uint64_t v104 = v118;
        uint64_t v59 = v58;
        uint64_t v103 = v59;
        _PCSGuitarfishSetKeychainItem(@"WrappingKey", v15, v36, v102);
        dispatch_semaphore_wait(v59, 0xFFFFFFFFFFFFFFFFLL);
        if (a3)
        {
          dispatch_semaphore_t v87 = dispatch_semaphore_create(0);

          id v88 = [v96 componentsJoinedByString:@" "];
          uint64_t v60 = [v88 dataUsingEncoding:4];
          v99[0] = MEMORY[0x1E4F143A8];
          v99[1] = 3221225472;
          v99[2] = __PCSGuitarfishCreateSetupParameters_block_invoke_244;
          v99[3] = &unk_1E5E6EE58;
          uint64_t v101 = v118;
          uint64_t v59 = v87;
          uint64_t v100 = v59;
          _PCSGuitarfishSetKeychainItem(@"RecoveryToken", v15, v60, v99);

          dispatch_semaphore_wait(v59, 0xFFFFFFFFFFFFFFFFLL);
        }

        int v57 = 0;
        goto LABEL_37;
      }
      id v55 = v56;
    }
    *a4 = v55;
    int v57 = 1;
LABEL_37:

    goto LABEL_44;
  }
  uint64_t v94 = 0;
LABEL_43:
  int v57 = 1;
LABEL_44:
  _Block_object_dispose(&buf, 8);

  if (!v57)
  {
LABEL_46:
    id v61 = [MEMORY[0x1E4F179C8] defaultStore];
    Random = objc_msgSend(v61, "aa_appleAccountWithPersonID:", v15);

    uint64_t v62 = (void *)[v14 mutableCopy];
    CFTypeRef v63 = [NSNumber numberWithBool:a2];
    [v62 setObject:v63 forKeyedSubscript:kPCSSetupGuitarfishReEnroll[0]];

    [v62 setObject:v94 forKeyedSubscript:kPCSSetupOuterGuitarfishEncodedTemplate[0]];
    [v62 setObject:v96 forKeyedSubscript:kPCSSetupRecoveryToken[0]];
    uint64_t v64 = [v14 objectForKeyedSubscript:kPCSSetupUsername[0]];
    uint64_t v65 = v64;
    if (!v64)
    {
      uint64_t v65 = [Random username];
    }
    [v62 setObject:v65 forKeyedSubscript:kPCSSetupUsername[0]];
    if (!v64) {

    }
    [v62 setObject:v22 forKeyedSubscript:kPCSSetupRawPassword[0]];
    [v62 setObject:v29 forKeyedSubscript:kPCSSetupPassword[0]];
    [v62 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:kPCSSetupGuitarfish[0]];
    uint64_t v66 = [v62 objectForKeyedSubscript:kPCSSetupPasswordGeneration[0]];
    BOOL v67 = v66 == 0;

    if (v67)
    {
      id AKAccountManagerClass = getAKAccountManagerClass();
      if (Random)
      {
        uint64_t v93 = [AKAccountManagerClass sharedInstance];
        uint64_t v69 = objc_msgSend(Random, "aa_altDSID");
        id v98 = 0;
        uint64_t v70 = [v93 authKitAccountWithAltDSID:v69 error:&v98];
        id v91 = v98;

        if (!v70 || v91)
        {
          uint64_t v72 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v91;
            _os_log_impl(&dword_1ACF98000, v72, OS_LOG_TYPE_DEFAULT, "Unable to get AKAccount: %@", (uint8_t *)&buf, 0xCu);
          }
        }
        else
        {
          id v71 = [v93 passwordVersionForAccount:v70];
          [v62 setObject:v71 forKeyedSubscript:kPCSSetupPasswordGeneration[0]];

          uint64_t v72 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
          {
            id v73 = [v62 objectForKeyedSubscript:kPCSSetupPasswordGeneration[0]];
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v73;
            _os_log_impl(&dword_1ACF98000, v72, OS_LOG_TYPE_DEFAULT, "Got passwordVersionForAccount: %@", (uint8_t *)&buf, 0xCu);
          }
        }
      }
    }
    id v74 = [v62 objectForKeyedSubscript:kPCSSetupVerifierIterationCount[0]];
    BOOL v75 = v74 == 0;

    if (v75) {
      [v62 setObject:&unk_1F03F74F8 forKeyedSubscript:kPCSSetupVerifierIterationCount[0]];
    }
    uint64_t v76 = [v62 objectForKeyedSubscript:kPCSSetupVerifierSalt[0]];
    BOOL v77 = v76 == 0;

    if (v77)
    {
      id v83 = _PCSStingrayCreateRandom(0x20uLL, (const void **)&v117);
      if (v117)
      {
        *a4 = v117;

        id v48 = 0;
LABEL_67:

        goto LABEL_68;
      }
      [v62 setObject:v83 forKeyedSubscript:kPCSSetupVerifierSalt[0]];
    }
    int v78 = [v62 objectForKeyedSubscript:kPCSSetupVerifierProtocol[0]];
    BOOL v79 = v78 == 0;

    if (v79) {
      [v62 setObject:@"s2k" forKeyedSubscript:kPCSSetupVerifierProtocol[0]];
    }
    CFDataRef v80 = [v14 objectForKeyedSubscript:kPCSAltDSID[0]];
    [v62 setObject:v80 forKeyedSubscript:kPCSAltDSID[0]];

    id v81 = [v14 objectForKeyedSubscript:kPCSDeviceSessionID[0]];
    [v62 setObject:v81 forKeyedSubscript:kPCSDeviceSessionID[0]];

    unint64_t v82 = [v14 objectForKeyedSubscript:kPCSFlowID[0]];
    [v62 setObject:v82 forKeyedSubscript:kPCSFlowID[0]];

    id v48 = v62;
    goto LABEL_67;
  }
  id v48 = 0;
LABEL_69:

LABEL_25:
  _Block_object_dispose(v118, 8);

  return v48;
}

void sub_1ACFE43C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  _Block_object_dispose(&a42, 8);
  _Block_object_dispose(&a48, 8);
  _Block_object_dispose((const void *)(v48 - 176), 8);
  _Block_object_dispose((const void *)(v48 - 208), 8);
  _Unwind_Resume(a1);
}

void __PCSAccountEnableWalrus_block_invoke(uint64_t a1, void *a2)
{
}

void __PCSAccountEnableWalrus_block_invoke_2(uint64_t a1, char a2, id obj)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), obj);
}

BOOL PCSAccountDisableWalrus(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = connectionPCSKeySyncing();
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x3032000000;
  uint64_t v21 = __Block_byref_object_copy__4;
  uint64_t v22 = __Block_byref_object_dispose__4;
  id v23 = 0;
  uint64_t v8 = [v6 objectForKeyedSubscript:kPCSSetupGuitarfish[0]];
  if ([v8 BOOLValue])
  {
    id v17 = 0;
    uint64_t v9 = PCSGuitarfishCreateSetupParameters(v6, 1, 1, &v17);
    id v10 = v17;

    if (!v9 || v10)
    {
      if (a3) {
        *a3 = v10;
      }

      BOOL v11 = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v9 = v6;
  }
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  v16[2] = __PCSAccountDisableWalrus_block_invoke;
  v16[3] = &unk_1E5E6EEA8;
  _OWORD v16[4] = &v18;
  uint64_t v12 = [v7 synchronousRemoteObjectProxyWithErrorHandler:v16];
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3221225472;
  _OWORD v15[2] = __PCSAccountDisableWalrus_block_invoke_2;
  void v15[3] = &unk_1E5E6F130;
  void v15[4] = &v24;
  v15[5] = &v18;
  [v12 disableWalrusForAccount:v5 withParameters:v9 complete:v15];

  if (*((unsigned char *)v25 + 24))
  {
    BOOL v11 = 1;
  }
  else
  {
    BOOL v11 = 0;
    if (a3)
    {
      uint64_t v13 = (void *)v19[5];
      if (v13)
      {
        *a3 = v13;
        BOOL v11 = *((unsigned char *)v25 + 24) != 0;
      }
    }
  }
LABEL_13:

  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v24, 8);

  return v11;
}

void sub_1ACFE46E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

void __PCSAccountDisableWalrus_block_invoke(uint64_t a1, void *a2)
{
}

void __PCSAccountDisableWalrus_block_invoke_2(uint64_t a1, char a2, id obj)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), obj);
}

void PCSTriggerWatchSyncing(void *a1)
{
  id v1 = a1;
  id v2 = connectionPCSKeySyncing();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __PCSTriggerWatchSyncing_block_invoke;
  v5[3] = &unk_1E5E6F070;
  id v6 = v1;
  id v3 = v1;
  id v4 = [v2 remoteObjectProxyWithErrorHandler:v5];
  [v4 triggerWatchSyncing:v3];
}

uint64_t __PCSTriggerWatchSyncing_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSBackupCheckUserRegistry(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = connectionPCSKeySyncing();
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = __PCSBackupCheckUserRegistry_block_invoke;
  void v8[3] = &unk_1E5E6F070;
  id v9 = v3;
  id v6 = v3;
  id v7 = [v5 remoteObjectProxyWithErrorHandler:v8];
  [v7 triggerUserRegistryCheck:v4 withReply:v6];
}

uint64_t __PCSBackupCheckUserRegistry_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSBackupRestoreMobileBackup(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[PCSAccountsModel accountForCurrentPersona];
  id v5 = objc_msgSend(v4, "aa_personID");

  if (v5)
  {
    id v6 = connectionPCSKeySyncing();
    uint64_t v10 = MEMORY[0x1E4F143A8];
    uint64_t v11 = 3221225472;
    uint64_t v12 = __PCSBackupRestoreMobileBackup_block_invoke;
    uint64_t v13 = &unk_1E5E6F070;
    id v7 = v3;
    id v14 = v7;
    uint64_t v8 = [v6 remoteObjectProxyWithErrorHandler:&v10];
    objc_msgSend(v8, "restoreMobileBackup:dsid:withReply:", a1, v5, v7, v10, v11, v12, v13);
  }
  else
  {
    CFTypeRef cf = 0;
    _PCSError(&cf, 66, @"unable to determine DSID");
    (*((void (**)(id, void, void, void, CFTypeRef))v3 + 2))(v3, 0, 0, 0, cf);
    CFTypeRef v9 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v9);
    }
  }
}

uint64_t __PCSBackupRestoreMobileBackup_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSMobileBackupStatusXPC(void *a1)
{
  id v1 = a1;
  id v2 = connectionPCSKeySyncing();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __PCSMobileBackupStatusXPC_block_invoke;
  v5[3] = &unk_1E5E6F070;
  id v6 = v1;
  id v3 = v1;
  id v4 = [v2 remoteObjectProxyWithErrorHandler:v5];
  [v4 mobileBackupStatus:v3];
}

void __PCSMobileBackupStatusXPC_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = v3;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSMobileBackupStatusXPC failed:%@", (uint8_t *)&v4, 0xCu);
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSBackupRegistryMobileBackupRecords(void *a1)
{
  id v1 = a1;
  id v2 = connectionPCSKeySyncing();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __PCSBackupRegistryMobileBackupRecords_block_invoke;
  v5[3] = &unk_1E5E6F070;
  id v6 = v1;
  id v3 = v1;
  int v4 = [v2 remoteObjectProxyWithErrorHandler:v5];
  [v4 mobileBackupRecordIDsWithReply:v3];
}

uint64_t __PCSBackupRegistryMobileBackupRecords_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSBackupLocalDBMobileBackupRecords(void *a1)
{
  id v1 = a1;
  id v2 = connectionPCSKeySyncing();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __PCSBackupLocalDBMobileBackupRecords_block_invoke;
  v5[3] = &unk_1E5E6F070;
  id v6 = v1;
  id v3 = v1;
  int v4 = [v2 remoteObjectProxyWithErrorHandler:v5];
  [v4 userDBBackupRecordIDsWithReply:v3];
}

uint64_t __PCSBackupLocalDBMobileBackupRecords_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSIdentitySetCreateManatee(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = _os_activity_create(&dword_1ACF98000, "PCSIdentitySetCreateManatee", MEMORY[0x1E4F144F0], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v8, &state);
  uint64_t v9 = connectionPCSKeySyncing();
  uint64_t v10 = (void *)v9;
  if (a2)
  {
    uint64_t v31 = (void *)v9;
    if (v6)
    {
      uint64_t v11 = [v6 objectForKeyedSubscript:kPCSSetupLogContext[0]];

      uint64_t v12 = PCSCopyPIIClearedOptions((CFDictionaryRef)v6);
      uint64_t v13 = PCSLogGetOSLog((uint64_t)v11);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138543618;
        *(void *)&uint8_t buf[4] = a2;
        __int16 v42 = 2114;
        uint64_t v43 = v12;
        _os_log_impl(&dword_1ACF98000, v13, OS_LOG_TYPE_DEFAULT, "PCSIdentitySetCreateManatee: %{public}@ %{public}@", buf, 0x16u);
      }

      if (v12) {
        CFRelease(v12);
      }
      id v14 = [v6 objectForKeyedSubscript:kPCSSetupDSID[0]];
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        id v15 = v14;
      }
      else {
        id v15 = 0;
      }
      if (!PCSCurrentPersonaMatchesDSID(v15))
      {
        uint64_t v21 = (void *)MEMORY[0x1E4F28C58];
        uint64_t v22 = kPCSErrorDomain;
        uint64_t v39 = *MEMORY[0x1E4F28568];
        uint64_t v40 = @"Current persona does not match chosen dsid";
        id v23 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v40 forKeys:&v39 count:1];
        uint64_t v24 = [v21 errorWithDomain:v22 code:152 userInfo:v23];
        v7[2](v7, 0, v24);

LABEL_23:
        uint64_t v10 = v31;
        goto LABEL_24;
      }
      uint64_t v20 = [v6 objectForKeyedSubscript:kPCSSetupRollIdentity[0]];

      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        uint64_t v19 = [v20 BOOLValue];
      }
      else {
        uint64_t v19 = 0;
      }
      uint64_t v25 = [v6 objectForKeyedSubscript:kPCSSetupSyncIdentity[0]];

      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        uint64_t v18 = [v25 BOOLValue];
      }
      else {
        uint64_t v18 = 0;
      }
      id v17 = [v6 objectForKeyedSubscript:kPCSSetupMTTCallback[0]];
    }
    else
    {
      id v15 = 0;
      id v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
    }
    v34[0] = MEMORY[0x1E4F143A8];
    v34[1] = 3221225472;
    v34[2] = __PCSIdentitySetCreateManatee_block_invoke;
    v34[3] = &unk_1E5E6F158;
    id v26 = v15;
    id v35 = v26;
    id v27 = v17;
    id v36 = v27;
    id v37 = v7;
    uint64_t v28 = (void *)MEMORY[0x1AD11D080](v34);
    v32[0] = MEMORY[0x1E4F143A8];
    v32[1] = 3221225472;
    v32[2] = __PCSIdentitySetCreateManatee_block_invoke_2;
    void v32[3] = &unk_1E5E6F070;
    id v29 = v28;
    id v33 = v29;
    uint64_t v30 = [v31 remoteObjectProxyWithErrorHandler:v32];
    [v30 createIdentity:a2 dsid:v26 roll:v19 sync:v18 forceSync:0 complete:v29];

    goto LABEL_23;
  }
  *(void *)long long buf = 0;
  _PCSError((const void **)buf, 124, @"No ServiceName Specified");
  v7[2](v7, 0, *(void **)buf);
  uint64_t v16 = *(const void **)buf;
  if (*(void *)buf)
  {
    *(void *)long long buf = 0;
    CFRelease(v16);
  }
LABEL_24:

  os_activity_scope_leave(&state);
}

void sub_1ACFE5230(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,os_activity_scope_state_s state)
{
}

void __PCSIdentitySetCreateManatee_block_invoke(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v11 = a2;
  id v7 = a3;
  id v8 = a4;
  if (v11) {
    uint64_t v9 = (const void *)PCSIdentityCreateFromPersistentReference(v11, *(void **)(a1 + 32));
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void *)(a1 + 40);
  if (v10) {
    (*(void (**)(uint64_t, id))(v10 + 16))(v10, v7);
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  if (v9) {
    CFRelease(v9);
  }
}

uint64_t __PCSIdentitySetCreateManatee_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t PCSReportManateeStatus(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v10 = 0;
  id v11 = &v10;
  uint64_t v12 = 0x2020000000;
  int v13 = 11;
  id v2 = connectionPCSKeySyncing();
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = __PCSReportManateeStatus_block_invoke;
  v9[3] = &unk_1E5E6EEA8;
  void v9[4] = &v10;
  id v3 = [v2 synchronousRemoteObjectProxyWithErrorHandler:v9];
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = __PCSReportManateeStatus_block_invoke_2;
  void v8[3] = &unk_1E5E6F180;
  void v8[4] = &v10;
  [v3 manateeStatus:v1 complete:v8];

  int v4 = pcsLogObjForScope("ManateeStatus");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *((_DWORD *)v11 + 6);
    *(_DWORD *)long long buf = 67109120;
    int v15 = v5;
    _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "PCSReportManateeStatus: %d", buf, 8u);
  }

  uint64_t v6 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);

  return v6;
}

void sub_1ACFE5500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __PCSReportManateeStatus_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 12;
  return result;
}

uint64_t __PCSReportManateeStatus_block_invoke_2(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  return result;
}

uint64_t PCSReportKeyRollPending(void *a1)
{
  id v1 = a1;
  uint64_t v7 = 0;
  id v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 0;
  id v2 = connectionPCSKeySyncing();
  id v3 = [v2 synchronousRemoteObjectProxyWithErrorHandler:&__block_literal_global_185];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __PCSReportKeyRollPending_block_invoke_2;
  v6[3] = &unk_1E5E6F1A8;
  void v6[4] = &v7;
  [v3 keyRollPending:v1 complete:v6];

  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_1ACFE562C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __PCSReportKeyRollPending_block_invoke_2(uint64_t a1, int a2, void *a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  uint64_t v6 = pcsLogObjForScope("ManateeStatus");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109378;
    v7[1] = a2;
    __int16 v8 = 2112;
    id v9 = v5;
    _os_log_impl(&dword_1ACF98000, v6, OS_LOG_TYPE_DEFAULT, "PCSReportKeyRollPending: %d: %@", (uint8_t *)v7, 0x12u);
  }

  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
}

void PCSGetHealthSummary(void *a1)
{
  id v1 = a1;
  id v2 = connectionPCSKeySyncing();
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __PCSGetHealthSummary_block_invoke;
  v5[3] = &unk_1E5E6F070;
  id v6 = v1;
  id v3 = v1;
  uint64_t v4 = [v2 synchronousRemoteObjectProxyWithErrorHandler:v5];
  [v4 getHealthSummary:v3];
}

uint64_t __PCSGetHealthSummary_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void PCSGuitarfishChangePassword(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl(&dword_1ACF98000, v5, OS_LOG_TYPE_DEFAULT, "PCSGuitarfishChangePassword entered", v6, 2u);
  }

  PCSGuitarfishRepairIdentities(v4, v3);
}

void PCSGuitarfishRepairIdentities(void *a1, void *a2)
{
  v346[1] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v243 = a2;
  id v4 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "PCSGuitarfishRepairIdentities entered", buf, 2u);
  }

  uint64_t v321 = 0;
  v322 = &v321;
  uint64_t v323 = 0x2020000000;
  uint64_t v324 = 0;
  if (v3)
  {
    id v11 = [v3 objectForKeyedSubscript:kPCSSetupDSID[0]];
    uint64_t v12 = v11;
    if (v11)
    {
      if (!PCSCurrentPersonaMatchesDSID(v11))
      {
        uint64_t v56 = PCSErrorCreate(152, @"Current persona does not match chosen dsid", v13, v14, v15, v16, v17, v18, v229);
        completeRepairIdentities(v243, 2, 1uLL, v56);
LABEL_165:

        goto LABEL_166;
      }
      uint64_t v19 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl(&dword_1ACF98000, v19, OS_LOG_TYPE_DEFAULT, "Repair: Entered", buf, 2u);
      }

      uint64_t v317 = 0;
      v318 = &v317;
      uint64_t v319 = 0x2020000000;
      uint64_t v320 = 2;
      dispatch_semaphore_t v20 = dispatch_semaphore_create(0);
      uint64_t v313 = 0;
      v314 = &v313;
      uint64_t v315 = 0x2020000000;
      uint64_t v316 = 0;
      v345 = kPCSSetupDSID[0];
      v346[0] = v12;
      uint64_t v21 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v346 forKeys:&v345 count:1];
      v308[0] = MEMORY[0x1E4F143A8];
      v308[1] = 3221225472;
      v308[2] = __PCSGuitarfishRepairIdentities_block_invoke;
      v308[3] = &unk_1E5E6F1D0;
      v310 = &v317;
      v311 = &v313;
      v312 = &v321;
      dispatch_semaphore_t dsema = v20;
      dispatch_semaphore_t v309 = dsema;
      PCSGuitarfishValidateIdentities(v21, v308);

      dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
      if (!v318[3])
      {
        int v57 = pcsLogObjForScope("Guitarfish");
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl(&dword_1ACF98000, v57, OS_LOG_TYPE_DEFAULT, "skipping repair because we are already in a good state", buf, 2u);
        }

        if ((*((unsigned char *)v314 + 25) & 0xC) != 0)
        {
          DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
          CFNotificationCenterPostNotification(DarwinNotifyCenter, kPCSNotificationGuitarfishRepairCompleted, 0, 0, 0);
        }
        completeRepairIdentities(v243, v318[3], v322[3], 0);
        goto LABEL_164;
      }
      uint64_t v22 = [MEMORY[0x1E4F179C8] defaultStore];
      id v240 = objc_msgSend(v22, "aa_appleAccountWithPersonID:", v12);

      id v23 = [v3 objectForKeyedSubscript:kPCSSetupPassword[0]];
      BOOL v24 = v23 == 0;

      if (v24)
      {
        uint64_t v59 = PCSErrorCreate(123, @"must provide kPCSSetupPassword", v25, v26, v27, v28, v29, v30, v229);
        completeRepairIdentities(v243, 2, 1uLL, v59);
      }
      else
      {
        uint64_t v31 = [v3 objectForKeyedSubscript:kPCSSetupRawPassword[0]];
        BOOL v32 = v31 == 0;

        if (!v32)
        {
          uint64_t v39 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1ACF98000, v39, OS_LOG_TYPE_DEFAULT, "Repair: Fetching Primary Record", buf, 2u);
          }

          v307 = 0;
          v343[0] = kPCSSetupDSID[0];
          v343[1] = kPCSSetupGuitarfish[0];
          v344[0] = v12;
          v344[1] = MEMORY[0x1E4F1CC38];
          v239 = (void *)__PCSCopyStingrayInfo(0, (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v344 forKeys:v343 count:2], &v307);
          uint64_t v45 = v307;
          if (v307 || !v239)
          {
            v322[3] |= 2uLL;
            id v306 = v45;
            _PCSNSError(&v306, 200, @"Unable to retrieve primary record, nothing to repair from!", v40, v41, v42, v43, v44, v229);
            id v61 = v306;

            uint64_t v62 = v61;
            completeRepairIdentities(v243, 2, v322[3], v61);
LABEL_162:

            goto LABEL_163;
          }
          uint64_t v238 = *MEMORY[0x1E4F59B88];
          uint64_t v46 = objc_msgSend(v239, "objectForKeyedSubscript:");
          BOOL v47 = v46 == 0;

          if (v47)
          {
            v322[3] |= 2uLL;
            CFTypeRef v63 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl(&dword_1ACF98000, v63, OS_LOG_TYPE_DEFAULT, "No Guitarfish Primary Record to decode", buf, 2u);
            }

            unint64_t v64 = v322[3];
            uint64_t v62 = PCSErrorCreate(238, @"No Primary Guitarfish Record. Account needs PCSGuitarfishSetupIdentities or migration.", v65, v66, v67, v68, v69, v70, v229);
            completeRepairIdentities(v243, 2, v64, v62);
            goto LABEL_162;
          }
          uint64_t v48 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl(&dword_1ACF98000, v48, OS_LOG_TYPE_DEFAULT, "Repair: Decoding Outer Record", buf, 2u);
          }

          uint64_t v49 = [v239 objectForKeyedSubscript:v238];
          CFErrorRef v236 = [v49 objectForKeyedSubscript:kPCSSecureBackupCFClientMetadataKey[0]];

          uint64_t v50 = [v236 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
          CFErrorRef v237 = [v50 objectForKeyedSubscript:@"SecureBackupWrappedKeys"];
          uint64_t v51 = [v236 objectForKeyedSubscript:@"IdMSPasswordGeneration"];
          uint64_t v52 = [v50 objectForKeyedSubscript:@"DerivedDBRSeedAESPID"];
          id v53 = pcsLogObjForScope("Guitarfish");
          id v233 = v50;
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412546;
            *(void *)&uint8_t buf[4] = v51;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v52;
            _os_log_impl(&dword_1ACF98000, v53, OS_LOG_TYPE_DEFAULT, "Repair: Primary Record PWGeneration: %@, PID: %@", buf, 0x16u);
          }
          v234 = (void *)v51;
          v235 = (void *)v52;

          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = buf;
          *(void *)&uint8_t buf[16] = 0x3032000000;
          v340 = __Block_byref_object_copy__4;
          v341 = __Block_byref_object_dispose__4;
          id v342 = 0;
          uint64_t v300 = 0;
          v301 = &v300;
          uint64_t v302 = 0x3032000000;
          v303 = __Block_byref_object_copy__4;
          v304 = __Block_byref_object_dispose__4;
          id v305 = 0;
          v298[0] = 0;
          v298[1] = v298;
          v298[2] = 0x3032000000;
          v298[3] = __Block_byref_object_copy__4;
          v298[4] = __Block_byref_object_dispose__4;
          id v299 = 0;
          v296[0] = 0;
          v296[1] = v296;
          v296[2] = 0x3032000000;
          v296[3] = __Block_byref_object_copy__4;
          v296[4] = __Block_byref_object_dispose__4;
          id v297 = 0;
          uint64_t v290 = 0;
          v291 = &v290;
          uint64_t v292 = 0x3032000000;
          v293 = __Block_byref_object_copy__4;
          v294 = __Block_byref_object_dispose__4;
          id v295 = 0;
          dispatch_semaphore_t v54 = dispatch_semaphore_create(0);

          v282[0] = MEMORY[0x1E4F143A8];
          v282[1] = 3221225472;
          v282[2] = __PCSGuitarfishRepairIdentities_block_invoke_203;
          v282[3] = &unk_1E5E6F1F8;
          v284 = &v321;
          v285 = &v290;
          v286 = buf;
          v287 = &v300;
          v288 = v298;
          v289 = v296;
          dispatch_semaphore_t dsema = v54;
          dispatch_semaphore_t v283 = dsema;
          _PCSBackupGuitarfishDecodeOuterRecord(v237, v282);
          dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
          id v55 = (void *)v291[5];
          if (v55)
          {
            completeRepairIdentities(v243, 3, v322[3], v55);
LABEL_161:

            _Block_object_dispose(&v290, 8);
            _Block_object_dispose(v296, 8);

            _Block_object_dispose(v298, 8);
            _Block_object_dispose(&v300, 8);

            _Block_object_dispose(buf, 8);
            uint64_t v62 = v236;
            goto LABEL_162;
          }
          id v71 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v276 = 0;
            _os_log_impl(&dword_1ACF98000, v71, OS_LOG_TYPE_DEFAULT, "Repair: Primary Record obtained and decoded", v276, 2u);
          }

          *(void *)v276 = 0;
          v277 = v276;
          uint64_t v278 = 0x3032000000;
          v279 = __Block_byref_object_copy__4;
          v280 = __Block_byref_object_dispose__4;
          id v281 = 0;
          dispatch_semaphore_t v72 = dispatch_semaphore_create(0);

          v272[0] = MEMORY[0x1E4F143A8];
          v272[1] = 3221225472;
          v272[2] = __PCSGuitarfishRepairIdentities_block_invoke_204;
          v272[3] = &unk_1E5E6EDB8;
          v274 = v276;
          v275 = &v321;
          id v73 = v72;
          v273 = v73;
          _PCSGuitarfishGetKeychainItem(@"WrappingKey", v12, v272);
          dispatch_semaphore_t dsema = v73;
          dispatch_semaphore_wait(v73, 0xFFFFFFFFFFFFFFFFLL);
          if (*((void *)v277 + 5))
          {
            *(void *)&long long v334 = 0;
            *((void *)&v334 + 1) = &v334;
            uint64_t v335 = 0x3032000000;
            v336 = __Block_byref_object_copy__4;
            v337 = __Block_byref_object_dispose__4;
            id v338 = 0;
            id v74 = (void *)*((void *)v277 + 5);
            v271[0] = MEMORY[0x1E4F143A8];
            v271[1] = 3221225472;
            v271[2] = __PCSGuitarfishRepairIdentities_block_invoke_206;
            v271[3] = &unk_1E5E6E700;
            v271[4] = &v334;
            _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(v74, v237, v271);
            if (*(void *)(*((void *)&v334 + 1) + 40))
            {
              BOOL v75 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR)) {
                PCSGuitarfishRepairIdentities_cold_1((uint64_t)&v334 + 8, v75);
              }

              uint64_t v76 = *((void *)v277 + 5);
              *((void *)v277 + 5) = 0;
            }
            else
            {
              uint64_t v76 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v265 = 0;
                _os_log_impl(&dword_1ACF98000, v76, OS_LOG_TYPE_DEFAULT, "Existing stashed wrappingKey is valid for the current record. No need to recover via p_password or p_token", v265, 2u);
              }
            }

            _Block_object_dispose(&v334, 8);
          }
          id cf = objc_alloc_init(MEMORY[0x1E4F1CA60]);
          [cf setObject:v12 forKeyedSubscript:kPCSSetupDSID[0]];
          BOOL v77 = [v240 username];
          [cf setObject:v77 forKeyedSubscript:kPCSSetupUsername[0]];

          int v78 = [v3 objectForKeyedSubscript:kPCSSetupPassword[0]];
          [cf setObject:v78 forKeyedSubscript:kPCSSetupPassword[0]];

          BOOL v79 = [v3 objectForKeyedSubscript:kPCSSetupRawPassword[0]];
          [cf setObject:v79 forKeyedSubscript:kPCSSetupRawPassword[0]];

          [cf setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:kPCSSetupGuitarfish[0]];
          CFDataRef v80 = [v3 objectForKeyedSubscript:kPCSSetupVerifierProtocol[0]];
          [cf setObject:v80 forKeyedSubscript:kPCSSetupVerifierProtocol[0]];

          id v81 = [v3 objectForKeyedSubscript:kPCSSetupVerifierIterationCount[0]];
          [cf setObject:v81 forKeyedSubscript:kPCSSetupVerifierIterationCount[0]];

          unint64_t v82 = [v3 objectForKeyedSubscript:kPCSSetupVerifierSalt[0]];
          [cf setObject:v82 forKeyedSubscript:kPCSSetupVerifierSalt[0]];

          id v83 = [v3 objectForKeyedSubscript:kPCSSetupPasswordGeneration[0]];
          [cf setObject:v83 forKeyedSubscript:kPCSSetupPasswordGeneration[0]];

          id v84 = [v236 objectForKeyedSubscript:@"IdMSPasswordGeneration"];
          [cf setObject:v84 forKeyedSubscript:kPCSPasswordGenerationFromExistingMetadata[0]];

          if (*((void *)v277 + 5)) {
            goto LABEL_46;
          }
          dispatch_semaphore_t v87 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v334) = 0;
            _os_log_impl(&dword_1ACF98000, v87, OS_LOG_TYPE_DEFAULT, "wrappingKey is not already available locally, performing recovery", (uint8_t *)&v334, 2u);
          }

          id v88 = [v3 objectForKeyedSubscript:kPCSSetupRecoveryToken[0]];
          BOOL v89 = v88 == 0;

          if (v89)
          {
            int v110 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v334) = 0;
              _os_log_impl(&dword_1ACF98000, v110, OS_LOG_TYPE_DEFAULT, "Repair: Attempting p_password recovery", (uint8_t *)&v334, 2u);
            }

            uint64_t v111 = [v3 objectForKeyedSubscript:kPCSSetupPreviousiCloudPassword[0]];

            if (v111)
            {
              int v112 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v334) = 0;
                _os_log_impl(&dword_1ACF98000, v112, OS_LOG_TYPE_DEFAULT, "Repair: Provided a previous iCloud Password, using that for p_password recovery", (uint8_t *)&v334, 2u);
              }

              int v113 = [v3 objectForKeyedSubscript:kPCSSetupPreviousiCloudPassword[0]];
              [cf setObject:v113 forKeyedSubscript:kPCSSetupRawPassword[0]];

              id v114 = [v3 objectForKeyedSubscript:kPCSSetupPreviousiCloudPasswordGeneration[0]];
              [cf setObject:v114 forKeyedSubscript:kPCSSetupPasswordGeneration[0]];
            }
            v307 = 0;
            int v115 = __PCSCopyHSMData(0, cf, (const void **)&v307);
            id v116 = v307;
            if (v307)
            {
              id v117 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(v334) = 138412290;
                *(void *)((char *)&v334 + 4) = v116;
                _os_log_impl(&dword_1ACF98000, v117, OS_LOG_TYPE_DEFAULT, "Repair: FAILED to recover p_password from HSM: %@", (uint8_t *)&v334, 0xCu);
              }

              id v257 = v116;
              _PCSNSError(&v257, 221, @"Unable to recover wrappingKey with p_password", v118, v119, v120, v121, v122, v229);
              id v123 = v257;

              completeRepairIdentities(v243, 2, v322[3], v123);
            }
            else
            {
              uint64_t v140 = [v3 objectForKeyedSubscript:kPCSSetupRawPassword[0]];
              [cf setObject:v140 forKeyedSubscript:kPCSSetupRawPassword[0]];

              long long v141 = [v3 objectForKeyedSubscript:kPCSSetupPasswordGeneration[0]];
              [cf setObject:v141 forKeyedSubscript:kPCSSetupPasswordGeneration[0]];

              uint64_t v142 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v143 = [v115 length];
                LODWORD(v334) = 134217984;
                *(void *)((char *)&v334 + 4) = v143;
                _os_log_impl(&dword_1ACF98000, v142, OS_LOG_TYPE_DEFAULT, "Repair: Obtained ClassicContent with length of: %lu", (uint8_t *)&v334, 0xCu);
              }

              long long v144 = *(void **)(*(void *)&buf[8] + 40);
              uint64_t v145 = (id *)(v291 + 5);
              obuint64_t j = (id)v291[5];
              uint64_t v146 = _PCSGuitarfishUnwrapKeyWithAESKey(v144, v115, &obj);
              objc_storeStrong(v145, obj);
              int v147 = (void *)*((void *)v277 + 5);
              *((void *)v277 + 5) = v146;

              if (v291[5])
              {
                uint64_t v154 = pcsLogObjForScope("Guitarfish");
                if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v155 = v291[5];
                  LODWORD(v334) = 138412290;
                  *(void *)((char *)&v334 + 4) = v155;
                  _os_log_impl(&dword_1ACF98000, v154, OS_LOG_TYPE_DEFAULT, "Unable to unwrap wrappingKey with p_password: %@", (uint8_t *)&v334, 0xCu);
                }
              }
              unint64_t v156 = v322[3];
              if (*((void *)v277 + 5))
              {
                v322[3] = v156 & 0xFFFFFFFFFFF9FFFDLL | 0x60000;
                dispatch_semaphore_t v157 = pcsLogObjForScope("Guitarfish");
                if (os_log_type_enabled(v157, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v334) = 0;
                  _os_log_impl(&dword_1ACF98000, v157, OS_LOG_TYPE_DEFAULT, "Repair: wrappingKey recovered with p_password", (uint8_t *)&v334, 2u);
                }

                goto LABEL_46;
              }
              PCSErrorCreate(221, @"Unable to recover wrappingKey with p_password", v148, v149, v150, v151, v152, v153, v229);
              id v123 = (id)objc_claimAutoreleasedReturnValue();
              completeRepairIdentities(v243, 2, v156, v123);
            }

LABEL_160:
            _Block_object_dispose(v276, 8);

            goto LABEL_161;
          }
          id v90 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v334) = 0;
            _os_log_impl(&dword_1ACF98000, v90, OS_LOG_TYPE_DEFAULT, "Repair: Attempting recovery token repair", (uint8_t *)&v334, 2u);
          }

          *(void *)&long long v334 = 0;
          *((void *)&v334 + 1) = &v334;
          uint64_t v335 = 0x3032000000;
          v336 = __Block_byref_object_copy__4;
          v337 = __Block_byref_object_dispose__4;
          id v338 = 0;
          *(void *)v265 = 0;
          v266 = v265;
          uint64_t v267 = 0x3032000000;
          v268 = __Block_byref_object_copy__4;
          v269 = __Block_byref_object_dispose__4;
          id v270 = 0;
          id v91 = [v3 objectForKeyedSubscript:kPCSSetupRecoveryToken[0]];
          dispatch_semaphore_t v92 = dispatch_semaphore_create(0);

          v260[0] = MEMORY[0x1E4F143A8];
          v260[1] = 3221225472;
          v260[2] = __PCSGuitarfishRepairIdentities_block_invoke_208;
          v260[3] = &unk_1E5E6F220;
          v262 = &v290;
          v263 = &v334;
          v264 = v265;
          dispatch_semaphore_t dsema = v92;
          dispatch_semaphore_t v261 = dsema;
          PCSGuitarfishDeriveRecoveryKeyFromMnemonic((uint64_t)v91, v260);
          dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
          if (v291[5])
          {
            uint64_t v93 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v94 = v291[5];
              *(_DWORD *)v330 = 138412290;
              *(void *)&v330[4] = v94;
              _os_log_impl(&dword_1ACF98000, v93, OS_LOG_TYPE_DEFAULT, "unable to derive PID from provided mnemonic: %@", v330, 0xCu);
            }

            completeRepairIdentities(v243, 2, v322[3], (void *)v291[5]);
            int v95 = 1;
LABEL_177:

            _Block_object_dispose(v265, 8);
            _Block_object_dispose(&v334, 8);

            if (v95) {
              goto LABEL_160;
            }
LABEL_46:
            *(void *)&long long v334 = 0;
            *((void *)&v334 + 1) = &v334;
            uint64_t v335 = 0x3032000000;
            v336 = __Block_byref_object_copy__4;
            v337 = __Block_byref_object_dispose__4;
            id v338 = 0;
            *(void *)v265 = 0;
            v266 = v265;
            uint64_t v267 = 0x3032000000;
            v268 = __Block_byref_object_copy__4;
            v269 = __Block_byref_object_dispose__4;
            id v270 = 0;
            *(void *)v330 = 0;
            *(void *)&v330[8] = v330;
            *(void *)&v330[16] = 0x3032000000;
            v331 = __Block_byref_object_copy__4;
            v332 = __Block_byref_object_dispose__4;
            id v333 = 0;
            int v85 = (void *)*((void *)v277 + 5);
            if (!v85)
            {
              uint64_t v96 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v326 = 0;
                _os_log_impl(&dword_1ACF98000, v96, OS_LOG_TYPE_DEFAULT, "Unable to recover wrapping key from recovery mechanism, unable to repair", v326, 2u);
              }

              unint64_t v97 = v322[3];
              uint64_t v104 = PCSErrorCreate(223, @"Unable to recover wrappingKey from provided recovery mechanism", v98, v99, v100, v101, v102, v103, v229);
              completeRepairIdentities(v243, 3, v97, v104);
              goto LABEL_158;
            }
            v255[0] = MEMORY[0x1E4F143A8];
            v255[1] = 3221225472;
            v255[2] = __PCSGuitarfishRepairIdentities_block_invoke_219;
            v255[3] = &unk_1E5E6F248;
            v255[4] = &v290;
            v255[5] = &v334;
            v255[6] = v265;
            v255[7] = v330;
            _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(v85, v237, v255);
            uint64_t v86 = (void *)v291[5];
            if (v86)
            {
              completeRepairIdentities(v243, 3, v322[3], v86);
LABEL_159:
              _Block_object_dispose(v330, 8);

              _Block_object_dispose(v265, 8);
              _Block_object_dispose(&v334, 8);

              goto LABEL_160;
            }
            dispatch_semaphore_t v105 = dispatch_semaphore_create(0);

            uint64_t v106 = (void *)*((void *)v277 + 5);
            v252[0] = MEMORY[0x1E4F143A8];
            v252[1] = 3221225472;
            v252[2] = __PCSGuitarfishRepairIdentities_block_invoke_220;
            v252[3] = &unk_1E5E6EE58;
            v254 = &v321;
            dispatch_semaphore_t dsema = v105;
            dispatch_semaphore_t v253 = dsema;
            _PCSGuitarfishSetKeychainItem(@"WrappingKey", v12, v106, v252);
            dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
            if (*(void *)(*((void *)&v334 + 1) + 40))
            {
              dispatch_semaphore_t v107 = dispatch_semaphore_create(0);

              uint64_t v108 = [*(id *)(*((void *)&v334 + 1) + 40) componentsJoinedByString:@" "];
              uint64_t v109 = [v108 dataUsingEncoding:4];
              v249[0] = MEMORY[0x1E4F143A8];
              v249[1] = 3221225472;
              v249[2] = __PCSGuitarfishRepairIdentities_block_invoke_221;
              v249[3] = &unk_1E5E6EE58;
              v251 = &v321;
              dispatch_semaphore_t dsema = v107;
              dispatch_semaphore_t v250 = dsema;
              _PCSGuitarfishSetKeychainItem(@"RecoveryToken", v12, v109, v249);

              dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
            }
            else
            {
              v322[3] &= ~0x40000uLL;
              _PCSGuitarfishDeleteKeychainItem(@"RecoveryToken", v12, &__block_literal_global_224);
            }

            id AKAccountManagerClass = getAKAccountManagerClass();
            if (v240)
            {
              long long v132 = [AKAccountManagerClass sharedInstance];
              long long v133 = objc_msgSend(v240, "aa_altDSID");
              id v248 = 0;
              long long v134 = [v132 authKitAccountWithAltDSID:v133 error:&v248];
              id v135 = v248;

              if (!v134 || v135)
              {
                int v137 = pcsLogObjForScope("Guitarfish");
                if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v326 = 138412290;
                  uint64_t v327 = (uint64_t)v135;
                  _os_log_impl(&dword_1ACF98000, v137, OS_LOG_TYPE_DEFAULT, "Unable to get AKAccount: %@", v326, 0xCu);
                }
                id v138 = 0;
              }
              else
              {
                uint64_t v136 = [v132 passwordVersionForAccount:v134];
                int v137 = pcsLogObjForScope("Guitarfish");
                if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v326 = 138412290;
                  id v138 = (void *)v136;
                  uint64_t v327 = v136;
                  _os_log_impl(&dword_1ACF98000, v137, OS_LOG_TYPE_DEFAULT, "Got passwordVersionForAccount: %@", v326, 0xCu);
                }
                else
                {
                  id v138 = (void *)v136;
                }
              }

              if (v138)
              {
                int v167 = v138;
                if (v234 && (objc_msgSend(v138, "isEqualToNumber:") & 1) == 0)
                {
                  id v168 = pcsLogObjForScope("Guitarfish");
                  if (os_log_type_enabled(v168, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)v326 = 138412546;
                    uint64_t v327 = (uint64_t)v138;
                    __int16 v328 = 2112;
                    v329 = v234;
                    _os_log_impl(&dword_1ACF98000, v168, OS_LOG_TYPE_DEFAULT, "expected password version %@ and got %@ from the record", v326, 0x16u);
                  }

                  int v167 = v138;
                  [cf setObject:v138 forKeyedSubscript:kPCSSetupPasswordGeneration[0]];
                  v322[3] |= 8uLL;
                }
                goto LABEL_116;
              }
            }
            else
            {
              id v139 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v326 = 0;
                _os_log_impl(&dword_1ACF98000, v139, OS_LOG_TYPE_DEFAULT, "Unable to get ACAccount", v326, 2u);
              }
            }
            v322[3] |= 0x1000uLL;
            uint64_t v169 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v326 = 0;
              _os_log_impl(&dword_1ACF98000, v169, OS_LOG_TYPE_DEFAULT, "Unable to resolve password version from AKAccount", v326, 2u);
            }

            int v167 = 0;
LABEL_116:
            uint64_t v170 = [v239 objectForKeyedSubscript:v238];
            uint64_t v171 = *MEMORY[0x1E4F59B48];
            id v172 = [v170 objectForKeyedSubscript:*MEMORY[0x1E4F59B48]];
            uint64_t v230 = v167;
            if (v172)
            {
              id v173 = [v239 objectForKeyedSubscript:v238];
              uint64_t v174 = *MEMORY[0x1E4F59B40];
              uint64_t v175 = [v173 objectForKeyedSubscript:*MEMORY[0x1E4F59B40]];
              BOOL v176 = v175 == 0;

              if (v176) {
                goto LABEL_124;
              }
              uint64_t v177 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v177, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v178 = [v239 objectForKeyedSubscript:v238];
                uint64_t v179 = [v178 objectForKeyedSubscript:v171];
                long long v180 = [v239 objectForKeyedSubscript:v238];
                uint64_t v181 = [v180 objectForKeyedSubscript:v174];
                *(_DWORD *)v326 = 138412546;
                uint64_t v327 = (uint64_t)v179;
                __int16 v328 = 2112;
                v329 = v181;
                _os_log_impl(&dword_1ACF98000, v177, OS_LOG_TYPE_DEFAULT, "Existing Federation: %@, Expected Federation: %@", v326, 0x16u);
              }
              long long v182 = [v239 objectForKeyedSubscript:v238];
              uint64_t v183 = [v182 objectForKeyedSubscript:v171];
              long long v184 = [v239 objectForKeyedSubscript:v238];
              long long v185 = [v184 objectForKeyedSubscript:v174];
              char v186 = [v183 isEqual:v185];

              if (v186) {
                goto LABEL_124;
              }
              v322[3] |= 0x80uLL;
              uint64_t v170 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v326 = 0;
                _os_log_impl(&dword_1ACF98000, v170, OS_LOG_TYPE_DEFAULT, "Federation Migration Needed", v326, 2u);
              }
            }

LABEL_124:
            uint64_t v187 = [v239 objectForKeyedSubscript:v238];
            id v231 = [v187 objectForKeyedSubscript:*MEMORY[0x1E4F59B78]];

            uint64_t v188 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v188, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v326 = 138412290;
              uint64_t v327 = (uint64_t)v231;
              _os_log_impl(&dword_1ACF98000, v188, OS_LOG_TYPE_DEFAULT, "Primary record has %@ attempts remaining", v326, 0xCu);
            }

            if (v231 && [v231 isEqualToNumber:&unk_1F03F74B0])
            {
              uint64_t v189 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v326 = 0;
                _os_log_impl(&dword_1ACF98000, v189, OS_LOG_TYPE_DEFAULT, "Primary record is terminal, re-enroll is required", v326, 2u);
              }

              [cf setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:kPCSSetupForceEnroll[0]];
            }
            long long v246 = 0u;
            long long v247 = 0u;
            long long v244 = 0u;
            long long v245 = 0u;
            uint64_t v190 = [&unk_1F03F7528 countByEnumeratingWithState:&v244 objects:v325 count:16];
            if (v190)
            {
              uint64_t v191 = *(void *)v245;
              uint64_t v192 = MEMORY[0x1E4F1CC38];
              do
              {
                for (uint64_t i = 0; i != v190; ++i)
                {
                  if (*(void *)v245 != v191) {
                    objc_enumerationMutation(&unk_1F03F7528);
                  }
                  v194 = *(void **)(*((void *)&v244 + 1) + 8 * i);
                  uint64_t v195 = v322[3];
                  int v196 = [v194 intValue];
                  if ((v195 & v196) == (int)[v194 intValue])
                  {
                    v197 = pcsLogObjForScope("Guitarfish");
                    if (os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
                    {
                      _PCSGuitarfishPopulateFlagNamesToTelemetryArray((int)[v194 intValue], 0);
                      id v198 = (id)objc_claimAutoreleasedReturnValue();
                      *(_DWORD *)v326 = 138412290;
                      uint64_t v327 = (uint64_t)v198;
                      _os_log_impl(&dword_1ACF98000, v197, OS_LOG_TYPE_DEFAULT, "Flag %@ was set, forcing re-enrollment and unsetting flag", v326, 0xCu);
                    }
                    [cf setObject:v192 forKeyedSubscript:kPCSSetupForceEnroll[0]];
                    int v199 = [v194 intValue];
                    v322[3] &= ~v199;
                  }
                }
                uint64_t v190 = [&unk_1F03F7528 countByEnumeratingWithState:&v244 objects:v325 count:16];
              }
              while (v190);
            }
            v200 = [cf objectForKeyedSubscript:kPCSSetupForceEnroll[0]];

            if (v200)
            {
              v201 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v201, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v326 = 0;
                _os_log_impl(&dword_1ACF98000, v201, OS_LOG_TYPE_DEFAULT, "Forcing enroll of Primary record", v326, 2u);
              }
            }
            v307 = 0;
            uint64_t v202 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v202, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v326 = 0;
              _os_log_impl(&dword_1ACF98000, v202, OS_LOG_TYPE_DEFAULT, "Repair: Calling Synchronize", v326, 2u);
            }

            int v203 = PCSIdentitySynchronizeKeys(cf, (const void **)&v307);
            uint64_t v204 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v326 = 67109120;
              LODWORD(v327) = v203;
              _os_log_impl(&dword_1ACF98000, v204, OS_LOG_TYPE_DEFAULT, "Repair: Synchronize status: %d", v326, 8u);
            }

            char v205 = v307;
            if (v307)
            {
              v206 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v326 = 138412290;
                uint64_t v327 = (uint64_t)v205;
                _os_log_impl(&dword_1ACF98000, v206, OS_LOG_TYPE_DEFAULT, "Repair: Synchronize error: %@", v326, 0xCu);
              }

              completeRepairIdentities(v243, 2, v322[3], v205);
            }
            else
            {
              uint64_t v207 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v207, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v326 = 0;
                _os_log_impl(&dword_1ACF98000, v207, OS_LOG_TYPE_DEFAULT, "Repair: Finished", v326, 2u);
              }

              uint64_t v208 = CFNotificationCenterGetDarwinNotifyCenter();
              CFNotificationCenterPostNotification(v208, kPCSNotificationGuitarfishRepairCompleted, 0, 0, 0);
              completeRepairIdentities(v243, 0, v322[3], 0);
            }

            uint64_t v104 = v230;
LABEL_158:

            goto LABEL_159;
          }
          if (([*(id *)(*((void *)&v334 + 1) + 40) isEqualToData:v52] & 1) == 0)
          {
            CFIndex v158 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v159 = *(void *)(*((void *)&v334 + 1) + 40);
              *(_DWORD *)v330 = 138412546;
              *(void *)&v330[4] = v159;
              *(_WORD *)&v330[12] = 2112;
              *(void *)&v330[14] = v52;
              _os_log_impl(&dword_1ACF98000, v158, OS_LOG_TYPE_DEFAULT, "derived PID isn't equal to record PID: %@, %@", v330, 0x16u);
            }

            unint64_t v160 = v322[3];
            PCSErrorCreate(235, @"Recovery token record has a different PID, not attempting recovery", v161, v162, v163, v164, v165, v166, v229);
            id v125 = (id)objc_claimAutoreleasedReturnValue();
            completeRepairIdentities(v243, 2, v160, v125);
            int v95 = 1;
            goto LABEL_176;
          }
          uint64_t v124 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v330 = 0;
            _os_log_impl(&dword_1ACF98000, v124, OS_LOG_TYPE_DEFAULT, "Repair: Recovering RT Record hsm contents", v330, 2u);
          }

          id v125 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
          [v125 setObject:MEMORY[0x1E4F1CC38] forKeyedSubscript:kPCSSetupGuitarfishToken[0]];
          uint64_t v126 = [v3 objectForKeyedSubscript:kPCSSetupDSID[0]];
          [v125 setObject:v126 forKeyedSubscript:kPCSSetupDSID[0]];

          v307 = 0;
          char v127 = __PCSCopyGuitarfishTokenData(0, (const __CFDictionary *)v125, (const void **)&v307);
          if (v307)
          {
            long long v128 = (void *)v291[5];
            v291[5] = (uint64_t)v307;

            id v129 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v130 = v291[5];
              *(_DWORD *)v330 = 138412290;
              *(void *)&v330[4] = v130;
              _os_log_impl(&dword_1ACF98000, v129, OS_LOG_TYPE_DEFAULT, "unable to obtain p_token from hsm: %@", v330, 0xCu);
            }

            completeRepairIdentities(v243, 2, v322[3], (void *)v291[5]);
            int v95 = 1;
            goto LABEL_175;
          }
          v209 = (void *)*((void *)v266 + 5);
          id v210 = (id *)(v291 + 5);
          id v259 = (id)v291[5];
          v232 = _PCSGuitarfishDeriveRecoveryTokenWrap(v209, v127, &v259);
          objc_storeStrong(v210, v259);
          if (v232 && !v291[5])
          {
            CFDictionaryRef v213 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v330 = 0;
              _os_log_impl(&dword_1ACF98000, v213, OS_LOG_TYPE_DEFAULT, "Repair: Unwrapping wrappingKey with p_recovery", v330, 2u);
            }

            v214 = (void *)v301[5];
            CFErrorRef v215 = (id *)(v291 + 5);
            id v258 = (id)v291[5];
            uint64_t v216 = _PCSGuitarfishUnwrapKeyWithAESKey(v214, v232, &v258);
            objc_storeStrong(v215, v258);
            v217 = (void *)*((void *)v277 + 5);
            *((void *)v277 + 5) = v216;

            if (v291[5])
            {
              uint64_t v224 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v224, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v225 = v291[5];
                *(_DWORD *)v330 = 138412290;
                *(void *)&v330[4] = v225;
                _os_log_impl(&dword_1ACF98000, v224, OS_LOG_TYPE_DEFAULT, "Unable to unwrap wrappingKey with p_recovery: %@", v330, 0xCu);
              }
            }
            if (*((void *)v277 + 5))
            {
              uint64_t v226 = pcsLogObjForScope("Guitarfish");
              if (os_log_type_enabled(v226, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v330 = 0;
                _os_log_impl(&dword_1ACF98000, v226, OS_LOG_TYPE_DEFAULT, "Repair: wrappingKey recovered with p_recovery", v330, 2u);
              }

              int v95 = 0;
              v322[3] |= 0x180000uLL;
              goto LABEL_174;
            }
            unint64_t v227 = v322[3];
            v228 = PCSErrorCreate(222, @"Unable to recover wrappingKey with p_recovery", v218, v219, v220, v221, v222, v223, v229);
            completeRepairIdentities(v243, 2, v227, v228);
          }
          else
          {
            CFErrorRef v211 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v211, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v212 = v291[5];
              *(_DWORD *)v330 = 138412290;
              *(void *)&v330[4] = v212;
              _os_log_impl(&dword_1ACF98000, v211, OS_LOG_TYPE_DEFAULT, "unable to derive token wrap: %@", v330, 0xCu);
            }

            completeRepairIdentities(v243, 2, v322[3], (void *)v291[5]);
          }
          int v95 = 1;
LABEL_174:

LABEL_175:
LABEL_176:

          goto LABEL_177;
        }
        uint64_t v60 = PCSErrorCreate(123, @"must provide kPCSSetupRawPassword", v33, v34, v35, v36, v37, v38, v229);
        completeRepairIdentities(v243, 2, 1uLL, v60);
      }
LABEL_163:

LABEL_164:
      _Block_object_dispose(&v313, 8);
      _Block_object_dispose(&v317, 8);
      uint64_t v56 = dsema;
      goto LABEL_165;
    }
  }
  uint64_t v12 = PCSErrorCreate(121, @"Missing DSID in parameters", v5, v6, v7, v8, v9, v10, v229);
  completeRepairIdentities(v243, 2, 1uLL, v12);
LABEL_166:

  _Block_object_dispose(&v321, 8);
}

void sub_1ACFE7F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&STACK[0x530], 8);
  _Block_object_dispose(&STACK[0x260], 8);
  _Block_object_dispose(&STACK[0x2F0], 8);
  _Block_object_dispose(&STACK[0x320], 8);
  _Block_object_dispose(&STACK[0x350], 8);
  _Block_object_dispose(&STACK[0x380], 8);
  _Block_object_dispose((const void *)(v67 - 224), 8);
  _Block_object_dispose(&STACK[0x400], 8);
  _Block_object_dispose(&STACK[0x420], 8);
  _Block_object_dispose(&STACK[0x440], 8);
  _Unwind_Resume(a1);
}

void completeRepairIdentities(void *a1, uint64_t a2, unint64_t a3, void *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v7 = a4;
  uint64_t v8 = a1;
  uint64_t v9 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = _PCSGuitarfishPopulateFlagNamesToTelemetryArray(a3, 0);
    int v11 = 134218754;
    uint64_t v12 = a2;
    __int16 v13 = 2112;
    id v14 = v7;
    __int16 v15 = 2048;
    unint64_t v16 = a3;
    __int16 v17 = 2112;
    uint64_t v18 = v10;
    _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "PCSGuitarfishRepairIdentities Complete: Status: %lu, error: %@, flags: %lu, flags_dict: %@", (uint8_t *)&v11, 0x2Au);
  }
  v8[2](v8, a2, a3, v7);
}

void PCSGuitarfishValidateIdentities(void *a1, void *a2)
{
  v284[1] = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v3 = a1;
  id v4 = a2;
  uint64_t v5 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, v5, OS_LOG_TYPE_DEFAULT, "PCSGuitarfishValidateIdentities entered", buf, 2u);
  }

  uint64_t v262 = 0;
  v263 = &v262;
  uint64_t v264 = 0x2020000000;
  uint64_t v265 = 0;
  uint64_t v258 = 0;
  id v259 = &v258;
  uint64_t v260 = 0x2020000000;
  uint64_t v261 = 0;
  id v12 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  if (v3
    && ([(__CFDictionary *)v3 objectForKeyedSubscript:kPCSSetupDSID[0]],
        __int16 v13 = objc_claimAutoreleasedReturnValue(),
        (id v14 = v13) != 0))
  {
    if (PCSCurrentPersonaMatchesDSID(v13))
    {
      CFTypeRef cf = 0;
      CFTypeRef v21 = PCSIdentitySetCreate(v3, 0, &cf);
      uint64_t v22 = (void *)cf;
      if (v21)
      {
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v22);
        }
        v256 = 0;
        char v23 = PCSIdentitySetIsWalrusWithForceFetch((uint64_t)v21, 0, (const void **)&v256);
        BOOL v24 = v256;
        if (v256)
        {
          completeValidateIdentities(v4, 2, 1uLL, v12, v256);

LABEL_107:
          CFRelease(v21);
          goto LABEL_108;
        }
        char v26 = v23;
        dispatch_semaphore_t dsema = 0;
        *(void *)long long buf = 0;
        v251 = buf;
        uint64_t v252 = 0x3032000000;
        dispatch_semaphore_t v253 = __Block_byref_object_copy__4;
        v254 = __Block_byref_object_dispose__4;
        id v255 = 0;
        v248[0] = 0;
        v248[1] = v248;
        v248[2] = 0x3032000000;
        v248[3] = __Block_byref_object_copy__4;
        v248[4] = __Block_byref_object_dispose__4;
        id v249 = 0;
        uint64_t v242 = 0;
        id v243 = &v242;
        uint64_t v244 = 0x3032000000;
        long long v245 = __Block_byref_object_copy__4;
        long long v246 = __Block_byref_object_dispose__4;
        id v247 = 0;
        if ((v23 & 1) == 0)
        {
          dispatch_semaphore_t v27 = dispatch_semaphore_create(0);
          dispatch_semaphore_t v283 = kPCSSetupDSID[0];
          v284[0] = v14;
          uint64_t v28 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v284 forKeys:&v283 count:1];
          v236[0] = MEMORY[0x1E4F143A8];
          v236[1] = 3221225472;
          v236[2] = __PCSGuitarfishValidateIdentities_block_invoke;
          v236[3] = &unk_1E5E6F298;
          uint64_t v238 = &v258;
          v239 = &v262;
          id v240 = v248;
          unint64_t v241 = buf;
          dispatch_semaphore_t dsema = v27;
          dispatch_semaphore_t v237 = dsema;
          PCSGuitarfishGetRecoveryTokenInfo(v28, v236);

          dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
        }
        v235 = 0;
        v281[0] = kPCSSetupDSID[0];
        v281[1] = kPCSSetupGuitarfish[0];
        v282[0] = v14;
        v282[1] = MEMORY[0x1E4F1CC38];
        uint64_t v29 = (void *)__PCSCopyStingrayInfo(0, (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v282 forKeys:v281 count:2], &v235);
        uint64_t v30 = v235;
        v193 = v29;
        if (v235 || !v29)
        {
          unint64_t v60 = v259[3] | 2;
          v259[3] = v60;
          completeValidateIdentities(v4, 2, v60, v12, v30);
        }
        else
        {
          uint64_t v190 = *MEMORY[0x1E4F59B88];
          uint64_t v31 = objc_msgSend(v29, "objectForKeyedSubscript:");
          BOOL v32 = v31 == 0;

          if (!v32)
          {
            uint64_t v33 = [v193 objectForKeyedSubscript:v190];
            uint64_t v192 = [v33 objectForKeyedSubscript:kPCSSecureBackupCFClientMetadataKey[0]];

            uint64_t v191 = [v192 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
            v194 = [v191 objectForKeyedSubscript:@"SecureBackupWrappedKeys"];
            uint64_t v189 = objc_msgSend(v191, "objectForKeyedSubscript:");
            uint64_t v188 = [v192 objectForKeyedSubscript:@"IdMSPasswordGeneration"];
            uint64_t v34 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v35 = [v194 base64EncodedStringWithOptions:0];
              LODWORD(v276) = 138412290;
              *(void *)((char *)&v276 + 4) = v35;
              _os_log_impl(&dword_1ACF98000, v34, OS_LOG_TYPE_DEFAULT, "OuterBlob: %@", (uint8_t *)&v276, 0xCu);
            }
            uint64_t v36 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v37 = [v189 base64EncodedStringWithOptions:0];
              LODWORD(v276) = 138412290;
              *(void *)((char *)&v276 + 4) = v37;
              _os_log_impl(&dword_1ACF98000, v36, OS_LOG_TYPE_DEFAULT, "PID: %@", (uint8_t *)&v276, 0xCu);
            }
            if (!v194)
            {
              unint64_t v69 = v259[3] | 2;
              v259[3] = v69;
              uint64_t v70 = PCSErrorCreate(200, @"Failed to decode Outer blob, potential missing guitarfish record", v38, v39, v40, v41, v42, v43, v173);
              completeValidateIdentities(v4, 1, v69, v12, v70);

LABEL_105:
              uint64_t v30 = v189;
              goto LABEL_106;
            }
            if ((v26 & 1) == 0)
            {
              dispatch_semaphore_t v44 = dispatch_semaphore_create(0);

              v231[0] = MEMORY[0x1E4F143A8];
              v231[1] = 3221225472;
              v231[2] = __PCSGuitarfishValidateIdentities_block_invoke_267;
              v231[3] = &unk_1E5E6EDB8;
              id v233 = &v242;
              v234 = &v258;
              dispatch_semaphore_t dsema = v44;
              dispatch_semaphore_t v232 = dsema;
              _PCSGuitarfishGetKeychainItem(@"RecoveryToken", v14, v231);
              dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
            }
            *(void *)&long long v276 = 0;
            *((void *)&v276 + 1) = &v276;
            uint64_t v277 = 0x3032000000;
            uint64_t v278 = __Block_byref_object_copy__4;
            v279 = __Block_byref_object_dispose__4;
            id v280 = 0;
            dispatch_semaphore_t v45 = dispatch_semaphore_create(0);

            v227[0] = MEMORY[0x1E4F143A8];
            v227[1] = 3221225472;
            v227[2] = __PCSGuitarfishValidateIdentities_block_invoke_268;
            v227[3] = &unk_1E5E6EDB8;
            uint64_t v229 = &v276;
            uint64_t v230 = &v258;
            dispatch_semaphore_t dsema = v45;
            dispatch_semaphore_t v228 = dsema;
            _PCSGuitarfishGetKeychainItem(@"WrappingKey", v14, v227);
            dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
            if (*(void *)(*((void *)&v276 + 1) + 40))
            {
              if ((v26 & 1) != 0 || v243[5])
              {
                uint64_t v221 = 0;
                uint64_t v222 = &v221;
                uint64_t v223 = 0x3032000000;
                uint64_t v224 = __Block_byref_object_copy__4;
                uint64_t v225 = __Block_byref_object_dispose__4;
                id v226 = 0;
                dispatch_semaphore_t v52 = dispatch_semaphore_create(0);

                v218[0] = MEMORY[0x1E4F143A8];
                v218[1] = 3221225472;
                v218[2] = __PCSGuitarfishValidateIdentities_block_invoke_275;
                v218[3] = &unk_1E5E6F2C0;
                uint64_t v220 = &v221;
                dispatch_semaphore_t dsema = v52;
                dispatch_semaphore_t v219 = dsema;
                _PCSBackupGuitarfishDecodeOuterRecord(v194, v218);
                dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
                dispatch_semaphore_t v58 = (id *)(v222 + 5);
                if (v222[5])
                {
                  obuint64_t j = (id)v222[5];
                  _PCSNSError(&obj, 200, @"Failed to decode Outer blob", v53, v54, v55, v56, v57, v173);
                  objc_storeStrong(v58, obj);
                  unint64_t v59 = v259[3] | 2;
                  v259[3] = v59;
                  completeValidateIdentities(v4, 1, v59, 0, (void *)v222[5]);
LABEL_103:

                  _Block_object_dispose(&v221, 8);
                  goto LABEL_104;
                }
                uint64_t v211 = 0;
                uint64_t v212 = &v211;
                uint64_t v213 = 0x3032000000;
                v214 = __Block_byref_object_copy__4;
                CFErrorRef v215 = __Block_byref_object_dispose__4;
                id v216 = 0;
                id v73 = *(void **)(*((void *)&v276 + 1) + 40);
                v210[0] = MEMORY[0x1E4F143A8];
                v210[1] = 3221225472;
                v210[2] = __PCSGuitarfishValidateIdentities_block_invoke_2;
                v210[3] = &unk_1E5E6E700;
                v210[4] = &v211;
                _PCSBackupGuitarfishGetRecoveredInnerBlobFromOuterBlobWithWrappingKey(v73, v194, v210);
                if (v212[5])
                {
                  id v74 = pcsLogObjForScope("Guitarfish");
                  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)v272 = 0;
                    _os_log_impl(&dword_1ACF98000, v74, OS_LOG_TYPE_DEFAULT, "wrappingKey is not valid for the inner record, needs repair", v272, 2u);
                  }

                  v259[3] |= 0x30uLL;
                  v205[0] = MEMORY[0x1E4F143A8];
                  v205[1] = 3221225472;
                  v205[2] = __PCSGuitarfishValidateIdentities_block_invoke_279;
                  v205[3] = &unk_1E5E6F310;
                  id v206 = v14;
                  id v207 = v4;
                  uint64_t v208 = &v258;
                  v209 = &v211;
                  _PCSGuitarfishDeleteKeychainItem(@"WrappingKey", v206, v205);

                  BOOL v75 = v206;
                  goto LABEL_102;
                }
                int v78 = pcsLogObjForScope("Guitarfish");
                if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)v272 = 0;
                  _os_log_impl(&dword_1ACF98000, v78, OS_LOG_TYPE_DEFAULT, "wrappingKey is valid for the inner record", v272, 2u);
                }

                id AKAccountManagerClass = getAKAccountManagerClass();
                CFDataRef v80 = +[PCSAccountsModel defaultAccountsModel];
                id v81 = [v80 store];
                uint64_t v187 = objc_msgSend(v81, "aa_appleAccountWithPersonID:", v14);

                if (v187)
                {
                  uint64_t v181 = [AKAccountManagerClass sharedInstance];
                  unint64_t v82 = objc_msgSend(v187, "aa_altDSID");
                  id v204 = 0;
                  uint64_t v178 = [v181 authKitAccountWithAltDSID:v82 error:&v204];
                  id v176 = v204;

                  if (!v178 || v176)
                  {
                    id v84 = pcsLogObjForScope("Guitarfish");
                    if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)v272 = 138412290;
                      *(void *)&void v272[4] = v176;
                      _os_log_impl(&dword_1ACF98000, v84, OS_LOG_TYPE_DEFAULT, "Unable to get AKAccount: %@", v272, 0xCu);
                    }
                    char v186 = 0;
                  }
                  else
                  {
                    uint64_t v83 = [v181 passwordVersionForAccount:v178];
                    id v84 = pcsLogObjForScope("Guitarfish");
                    char v186 = (void *)v83;
                    if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)v272 = 138412290;
                      *(void *)&void v272[4] = v83;
                      _os_log_impl(&dword_1ACF98000, v84, OS_LOG_TYPE_DEFAULT, "Got passwordVersionForAccount: %@", v272, 0xCu);
                    }
                  }

                  if (v186)
                  {
                    [v12 setObject:v186 forKeyedSubscript:@"localPasswordVersion"];
                    uint64_t v86 = v193;
                    if (v188 && (objc_msgSend(v186, "isEqualToNumber:") & 1) == 0)
                    {
                      dispatch_semaphore_t v87 = pcsLogObjForScope("Guitarfish");
                      if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)v272 = 138412546;
                        *(void *)&void v272[4] = v186;
                        *(_WORD *)&v272[12] = 2112;
                        *(void *)&v272[14] = v188;
                        _os_log_impl(&dword_1ACF98000, v87, OS_LOG_TYPE_DEFAULT, "expected password version %@ and got %@ from the record", v272, 0x16u);
                      }

                      unint64_t v88 = v259[3] | 0xA;
                      v259[3] = v88;
                      int v95 = PCSErrorCreate(217, @"expected password version %@ and got %@ from the record", v89, v90, v91, v92, v93, v94, (uint64_t)v186);
                      completeValidateIdentities(v4, 1, v88, 0, v95);

                      goto LABEL_101;
                    }
LABEL_65:
                    [v12 setObject:v188 forKeyedSubscript:@"recordPasswordVersion"];
                    long long v182 = [v86 objectForKeyedSubscript:v190];
                    uint64_t v97 = *MEMORY[0x1E4F59B48];
                    uint64_t v98 = [v182 objectForKeyedSubscript:*MEMORY[0x1E4F59B48]];
                    if (v98)
                    {
                      uint64_t v99 = [v86 objectForKeyedSubscript:v190];
                      uint64_t v177 = *MEMORY[0x1E4F59B40];
                      uint64_t v100 = objc_msgSend(v99, "objectForKeyedSubscript:");
                      uint64_t v179 = v97;
                      BOOL v101 = v100 == 0;

                      if (!v101)
                      {
                        uint64_t v102 = pcsLogObjForScope("Guitarfish");
                        if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v174 = v102;
                          uint64_t v183 = [v193 objectForKeyedSubscript:v190];
                          uint64_t v175 = [v183 objectForKeyedSubscript:v179];
                          uint64_t v103 = [v193 objectForKeyedSubscript:v190];
                          uint64_t v104 = [v103 objectForKeyedSubscript:v177];
                          *(_DWORD *)v272 = 138412546;
                          *(void *)&void v272[4] = v175;
                          *(_WORD *)&v272[12] = 2112;
                          *(void *)&v272[14] = v104;
                          _os_log_impl(&dword_1ACF98000, v174, OS_LOG_TYPE_DEFAULT, "Existing Federation: %@, Expected Federation: %@", v272, 0x16u);

                          uint64_t v102 = v174;
                        }

                        long long v184 = [v193 objectForKeyedSubscript:v190];
                        long long v180 = [v184 objectForKeyedSubscript:v179];
                        dispatch_semaphore_t v105 = [v193 objectForKeyedSubscript:v190];
                        uint64_t v106 = [v105 objectForKeyedSubscript:v177];
                        char v107 = [v180 isEqual:v106];

                        if ((v107 & 1) == 0)
                        {
                          v259[3] |= 0x80uLL;
                          uint64_t v108 = pcsLogObjForScope("Guitarfish");
                          if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_WORD *)v272 = 0;
                            _os_log_impl(&dword_1ACF98000, v108, OS_LOG_TYPE_DEFAULT, "Federation Migration Needed", v272, 2u);
                          }

                          unint64_t v109 = v259[3];
                          id v116 = PCSErrorCreate(229, @"Federation Migration Needed", v110, v111, v112, v113, v114, v115, v173);
                          completeValidateIdentities(v4, 1, v109, 0, v116);

                          goto LABEL_101;
                        }
                      }
                    }
                    else
                    {
                    }
                    *(void *)v272 = 0;
                    *(void *)&v272[8] = v272;
                    *(void *)&v272[16] = 0x3032000000;
                    v273 = __Block_byref_object_copy__4;
                    v274 = __Block_byref_object_dispose__4;
                    id v275 = 0;
                    if (v26)
                    {
                      dispatch_semaphore_t v117 = 0;
                    }
                    else
                    {
                      dispatch_semaphore_t v131 = dispatch_semaphore_create(0);

                      uint64_t v132 = v243[5];
                      v200[0] = MEMORY[0x1E4F143A8];
                      v200[1] = 3221225472;
                      v200[2] = __PCSGuitarfishValidateIdentities_block_invoke_287;
                      v200[3] = &unk_1E5E6F338;
                      uint64_t v202 = &v221;
                      int v203 = v272;
                      dispatch_semaphore_t dsema = v131;
                      dispatch_semaphore_t v201 = dsema;
                      PCSGuitarfishDeriveRecoveryKeyFromMnemonic(v132, v200);
                      dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
                      long long v133 = v189;
                      if (v222[5])
                      {
                        long long v134 = pcsLogObjForScope("Guitarfish");
                        if (os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v135 = v222[5];
                          *(_DWORD *)v268 = 138412290;
                          uint64_t v269 = v135;
                          _os_log_impl(&dword_1ACF98000, v134, OS_LOG_TYPE_DEFAULT, "unable to derive PID from stashed mnemonic: %@", v268, 0xCu);
                        }

                        long long v133 = v189;
                        if (v222[5]) {
                          goto LABEL_95;
                        }
                      }
                      char v136 = [*(id *)(*(void *)&v272[8] + 40) isEqualToData:v133];
                      long long v133 = v189;
                      if ((v136 & 1) == 0)
                      {
LABEL_95:
                        uint64_t v154 = pcsLogObjForScope("Guitarfish");
                        if (os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v155 = *(void *)(*(void *)&v272[8] + 40);
                          *(_DWORD *)v268 = 138412546;
                          uint64_t v269 = v155;
                          __int16 v270 = 2112;
                          v271 = v133;
                          _os_log_impl(&dword_1ACF98000, v154, OS_LOG_TYPE_DEFAULT, "derived PID isn't equal to record PID: %@, %@", v268, 0x16u);
                        }

                        v259[3] |= 0x10uLL;
                        v196[0] = MEMORY[0x1E4F143A8];
                        v196[1] = 3221225472;
                        v196[2] = __PCSGuitarfishValidateIdentities_block_invoke_288;
                        v196[3] = &unk_1E5E6F2E8;
                        id v197 = v4;
                        id v198 = &v258;
                        int v199 = &v221;
                        _PCSGuitarfishDeleteKeychainItem(@"RecoveryToken", v14, v196);

                        dispatch_semaphore_t v117 = v201;
                        goto LABEL_100;
                      }

                      v235 = 0;
                      v266[0] = kPCSSetupDSID[0];
                      v266[1] = kPCSSetupGuitarfishToken[0];
                      v267[0] = v14;
                      v267[1] = MEMORY[0x1E4F1CC38];
                      int v137 = __PCSCopyStingrayInfo(0, (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v267 forKeys:v266 count:2], &v235);
                      dispatch_semaphore_t v117 = v137;
                      long long v144 = v235;
                      if (v235)
                      {
                        unint64_t v145 = v259[3] | 4;
                        v259[3] = v145;
                        completeValidateIdentities(v4, 2, v145, v12, v144);

LABEL_100:
                        _Block_object_dispose(v272, 8);

LABEL_101:
                        BOOL v75 = v186;
LABEL_102:

                        _Block_object_dispose(&v211, 8);
                        goto LABEL_103;
                      }
                      if (!v137
                        || (uint64_t v156 = *MEMORY[0x1E4F59B58],
                            [v137 objectForKeyedSubscript:*MEMORY[0x1E4F59B58]],
                            dispatch_semaphore_t v157 = objc_claimAutoreleasedReturnValue(),
                            BOOL v158 = v157 == 0,
                            v157,
                            v158))
                      {
                        unint64_t v162 = v259[3] | 4;
                        v259[3] = v162;
                        uint64_t v163 = PCSErrorCreate(234, @"Recovery Token record is missing, needs repair", v138, v139, v140, v141, v142, v143, v173);
                        completeValidateIdentities(v4, 1, v162, v12, v163);

                        goto LABEL_100;
                      }
                      long long v185 = [v117 objectForKeyedSubscript:v156];
                      uint64_t v159 = [v185 objectForKeyedSubscript:*MEMORY[0x1E4F59B38]];
                      unint64_t v160 = [v159 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
                      uint64_t v161 = [v160 objectForKeyedSubscript:@"DerivedDBRSeedAESPID"];

                      if (!v161 || ([v161 isEqualToData:v189] & 1) == 0)
                      {
                        uint64_t v164 = pcsLogObjForScope("Guitarfish");
                        if (os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)v268 = 0;
                          _os_log_impl(&dword_1ACF98000, v164, OS_LOG_TYPE_DEFAULT, "healthcheck: PID mismatch, needs repair", v268, 2u);
                        }

                        unint64_t v165 = v259[3] | 4;
                        v259[3] = v165;
                        id v172 = PCSErrorCreate(235, @"Recovery Token PID is unexpected, needs repair", v166, v167, v168, v169, v170, v171, v173);
                        completeValidateIdentities(v4, 1, v165, v12, v172);

                        goto LABEL_100;
                      }
                    }
                    uint64_t v118 = [v193 objectForKeyedSubscript:v190];
                    uint64_t v119 = *MEMORY[0x1E4F59B78];
                    uint64_t v120 = [v118 objectForKeyedSubscript:*MEMORY[0x1E4F59B78]];

                    uint64_t v121 = [v117 objectForKeyedSubscript:*MEMORY[0x1E4F59B58]];
                    uint64_t v122 = [v121 objectForKeyedSubscript:v119];

                    [v12 setObject:v120 forKeyedSubscript:@"primaryRecordAttemptsRemaining"];
                    if ((v26 & 1) == 0) {
                      [v12 setObject:v122 forKeyedSubscript:@"recoveryTokenRecordAttemptsRemaining"];
                    }
                    if (v120 && [v120 isEqualToNumber:&unk_1F03F74B0])
                    {
                      unint64_t v129 = v259[3] | 2;
                      v259[3] = v129;
                      uint64_t v130 = PCSErrorCreate(236, @"Primary Record is terminal, needs repair", v123, v124, v125, v126, v127, v128, v173);
                      completeValidateIdentities(v4, 1, v129, v12, v130);
                    }
                    else
                    {
                      if (v122) {
                        char v146 = v26;
                      }
                      else {
                        char v146 = 1;
                      }
                      if ((v146 & 1) != 0 || ![v122 isEqualToNumber:&unk_1F03F74B0])
                      {
                        completeValidateIdentities(v4, v263[3], v259[3], v12, 0);
                        goto LABEL_99;
                      }
                      unint64_t v153 = v259[3] | 4;
                      v259[3] = v153;
                      uint64_t v130 = PCSErrorCreate(237, @"Recovery Token Record is terminal, needs repair", v147, v148, v149, v150, v151, v152, v173);
                      completeValidateIdentities(v4, 1, v153, v12, v130);
                    }

LABEL_99:
                    goto LABEL_100;
                  }
                }
                else
                {
                  int v85 = pcsLogObjForScope("Guitarfish");
                  if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)v272 = 0;
                    _os_log_impl(&dword_1ACF98000, v85, OS_LOG_TYPE_DEFAULT, "Unable to get ACAccount", v272, 2u);
                  }
                }
                v259[3] |= 0x1000uLL;
                uint64_t v96 = pcsLogObjForScope("Guitarfish");
                if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)v272 = 0;
                  _os_log_impl(&dword_1ACF98000, v96, OS_LOG_TYPE_DEFAULT, "Unable to resolve password version from AKAccount", v272, 2u);
                }

                char v186 = 0;
                uint64_t v86 = v193;
                goto LABEL_65;
              }
              unint64_t v76 = v259[3];
              BOOL v77 = PCSErrorCreate(216, @"Missing Recovery Token in Keychain, needs repair", v46, v47, v48, v49, v50, v51, v173);
              completeValidateIdentities(v4, 1, v76, v12, v77);
            }
            else
            {
              unint64_t v71 = v259[3];
              dispatch_semaphore_t v72 = PCSErrorCreate(215, @"Missing Wrapping Key in Keychain, needs repair", v46, v47, v48, v49, v50, v51, v173);
              completeValidateIdentities(v4, 1, v71, v12, v72);
            }
LABEL_104:

            _Block_object_dispose(&v276, 8);
            goto LABEL_105;
          }
          v259[3] |= 2uLL;
          id v61 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v276) = 0;
            _os_log_impl(&dword_1ACF98000, v61, OS_LOG_TYPE_DEFAULT, "No Guitarfish Primary Record to decode", (uint8_t *)&v276, 2u);
          }

          unint64_t v62 = v259[3];
          uint64_t v30 = PCSErrorCreate(238, @"No Primary Guitarfish Record. Account needs PCSGuitarfishSetupIdentities or migration.", v63, v64, v65, v66, v67, v68, v173);
          completeValidateIdentities(v4, 2, v62, v12, v30);
        }
        v194 = 0;
LABEL_106:

        _Block_object_dispose(&v242, 8);
        _Block_object_dispose(v248, 8);

        _Block_object_dispose(buf, 8);
        goto LABEL_107;
      }
      completeValidateIdentities(v4, 2, 1uLL, v12, (void *)cf);
    }
    else
    {
      uint64_t v25 = PCSErrorCreate(152, @"Current persona does not match chosen dsid", v15, v16, v17, v18, v19, v20, v173);
      completeValidateIdentities(v4, 2, 1uLL, v12, v25);
    }
  }
  else
  {
    id v14 = PCSErrorCreate(121, @"Missing DSID in parameters", v6, v7, v8, v9, v10, v11, v173);
    completeValidateIdentities(v4, 2, 1uLL, v12, v14);
  }
LABEL_108:

  _Block_object_dispose(&v258, 8);
  _Block_object_dispose(&v262, 8);
}

void sub_1ACFE9B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&STACK[0x3F0], 8);
  _Block_object_dispose(&a56, 8);
  _Block_object_dispose(&a69, 8);
  _Block_object_dispose((const void *)(v70 - 224), 8);
  _Block_object_dispose(&STACK[0x2D0], 8);
  _Block_object_dispose(&STACK[0x300], 8);
  _Block_object_dispose(&STACK[0x330], 8);
  CFRelease(v69);
  _Block_object_dispose(&STACK[0x370], 8);
  _Block_object_dispose(&STACK[0x390], 8);
  _Unwind_Resume(a1);
}

void __PCSGuitarfishRepairIdentities_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v8 = a5;
  uint64_t v9 = v8;
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = a3;
  uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  if ((v10 & 0x400) == 0)
  {
    if ((v10 & 0x800) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) |= 0x800uLL;
    if (!v8) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) |= 0x400uLL;
  if ((*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) & 0x800) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if (!v8) {
    goto LABEL_10;
  }
LABEL_7:
  uint64_t v11 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 138412290;
    __int16 v13 = v9;
    _os_log_impl(&dword_1ACF98000, v11, OS_LOG_TYPE_DEFAULT, "Encountered error retrieving existing health status: %@", (uint8_t *)&v12, 0xCu);
  }

LABEL_10:
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishRepairIdentities_block_invoke_203(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  if (v15)
  {
    uint64_t v16 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v29 = 0;
      _os_log_impl(&dword_1ACF98000, v16, OS_LOG_TYPE_DEFAULT, "unable to decode primary record, needs rpd", v29, 2u);
    }

    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) |= 2uLL;
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a6);
  }
  uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v18 = *(void **)(v17 + 40);
  *(void *)(v17 + 40) = v11;
  id v19 = v11;

  uint64_t v20 = *(void *)(*(void *)(a1 + 64) + 8);
  CFTypeRef v21 = *(void **)(v20 + 40);
  *(void *)(v20 + 40) = v12;
  id v22 = v12;

  uint64_t v23 = *(void *)(*(void *)(a1 + 72) + 8);
  BOOL v24 = *(void **)(v23 + 40);
  *(void *)(v23 + 40) = v13;
  id v25 = v13;

  uint64_t v26 = *(void *)(*(void *)(a1 + 80) + 8);
  dispatch_semaphore_t v27 = *(void **)(v26 + 40);
  *(void *)(v26 + 40) = v14;
  id v28 = v14;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishRepairIdentities_block_invoke_204(uint64_t a1, void *a2, void *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  id v7 = a3;
  id v8 = v7;
  if (!v6 || v7)
  {
    uint64_t v10 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      uint64_t v12 = (uint64_t)v8;
      _os_log_impl(&dword_1ACF98000, v10, OS_LOG_TYPE_DEFAULT, "unable to recover wrapping key from keychain: %@", (uint8_t *)&v11, 0xCu);
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) |= 0x20uLL;
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    uint64_t v9 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 134217984;
      uint64_t v12 = [v6 length];
      _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "recovered wrapping key from keychain of length: %lu", (uint8_t *)&v11, 0xCu);
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishRepairIdentities_block_invoke_206(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v8 = a6;
  if (v8)
  {
    id v9 = v8;
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a6);
    id v8 = v9;
  }
}

void __PCSGuitarfishRepairIdentities_block_invoke_208(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v15 = a4;
  if (v15) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a4);
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
  id v11 = v8;

  uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v7;
  id v14 = v7;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishRepairIdentities_block_invoke_219(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  if (v13)
  {
    objc_storeStrong((id *)(*(void *)(a1[4] + 8) + 40), a6);
    id v14 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = 138412290;
      id v24 = v13;
      _os_log_impl(&dword_1ACF98000, v14, OS_LOG_TYPE_DEFAULT, "Error decoding inner record: %@", (uint8_t *)&v23, 0xCu);
    }
  }
  uint64_t v15 = *(void *)(a1[5] + 8);
  uint64_t v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = v10;
  id v17 = v10;

  uint64_t v18 = *(void *)(a1[6] + 8);
  id v19 = *(void **)(v18 + 40);
  *(void *)(v18 + 40) = v11;
  id v20 = v11;

  uint64_t v21 = *(void *)(a1[7] + 8);
  id v22 = *(void **)(v21 + 40);
  *(void *)(v21 + 40) = v12;
}

void __PCSGuitarfishRepairIdentities_block_invoke_220(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = pcsLogObjForScope("Guitarfish");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v8 = 138412290;
      id v9 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "unable to save wrapping key to keychain: %@", (uint8_t *)&v8, 0xCu);
    }

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v7 = *(void *)(v6 + 24) | 0x20;
  }
  else
  {
    if (v5)
    {
      LOWORD(v_Block_object_dispose(&a9, 8) = 0;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "saved wrapping key to keychain successfully", (uint8_t *)&v8, 2u);
    }

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v7 = *(void *)(v6 + 24) & 0xFFFFFFFFFFFFFFDFLL;
  }
  *(void *)(v6 + 24) = v7;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishRepairIdentities_block_invoke_221(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = pcsLogObjForScope("Guitarfish");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v8 = 138412290;
      id v9 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "unable to save recoveryToken key to keychain: %@", (uint8_t *)&v8, 0xCu);
    }

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v7 = *(void *)(v6 + 24) | 0x20;
  }
  else
  {
    if (v5)
    {
      LOWORD(v_Block_object_dispose(&a9, 8) = 0;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "saved recoveryToken key to keychain successfully", (uint8_t *)&v8, 2u);
    }

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v7 = *(void *)(v6 + 24) & 0xFFFFFFFFFFFFFFDFLL;
  }
  *(void *)(v6 + 24) = v7;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishRepairIdentities_block_invoke_222(uint64_t a1, void *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  if (v2)
  {
    id v3 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 138412290;
      id v5 = v2;
      _os_log_impl(&dword_1ACF98000, v3, OS_LOG_TYPE_DEFAULT, "Failed to delete recovery token from keychain: %@", (uint8_t *)&v4, 0xCu);
    }
  }
}

id getAKAccountManagerClass()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2050000000;
  CFDictionaryRef v0 = (void *)getAKAccountManagerClass_softClass_1;
  uint64_t v7 = getAKAccountManagerClass_softClass_1;
  if (!getAKAccountManagerClass_softClass_1)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    void v3[2] = __getAKAccountManagerClass_block_invoke_1;
    v3[3] = &unk_1E5E6DDF8;
    void v3[4] = &v4;
    __getAKAccountManagerClass_block_invoke_1((uint64_t)v3);
    CFDictionaryRef v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1ACFEA708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __PCSGuitarfishCreateSetupParameters_block_invoke(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(void *)(a1[4] + 8);
  id v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v8;
  id v17 = v8;

  uint64_t v12 = *(void *)(a1[5] + 8);
  id v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v7;
  id v14 = v7;

  uint64_t v15 = *(void *)(a1[6] + 8);
  uint64_t v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = v9;
}

void __PCSGuitarfishCreateSetupParameters_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = pcsLogObjForScope("Guitarfish");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v8 = 138412290;
      id v9 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "unable to save wrapping key to keychain: %@", (uint8_t *)&v8, 0xCu);
    }

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v7 = *(void *)(v6 + 24) | 0x20;
  }
  else
  {
    if (v5)
    {
      LOWORD(v_Block_object_dispose(&a9, 8) = 0;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "saved wrapping key to keychain successfully", (uint8_t *)&v8, 2u);
    }

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v7 = *(void *)(v6 + 24) & 0xFFFFFFFFFFFFFFDFLL;
  }
  *(void *)(v6 + 24) = v7;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishCreateSetupParameters_block_invoke_244(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = pcsLogObjForScope("Guitarfish");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v8 = 138412290;
      id v9 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "unable to save wrapping key to keychain: %@", (uint8_t *)&v8, 0xCu);
    }

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v7 = *(void *)(v6 + 24) | 0x20;
  }
  else
  {
    if (v5)
    {
      LOWORD(v_Block_object_dispose(&a9, 8) = 0;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "saved wrapping key to keychain successfully", (uint8_t *)&v8, 2u);
    }

    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    unint64_t v7 = *(void *)(v6 + 24) & 0xFFFFFFFFFFFFFFDFLL;
  }
  *(void *)(v6 + 24) = v7;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void PCSGuitarfishSetupIdentities(void *a1, void *a2)
{
  v100[2] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = a2;
  BOOL v5 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_1ACF98000, v5, OS_LOG_TYPE_DEFAULT, "PCSGuitarfishSetupIdentities entered", (uint8_t *)&buf, 2u);
  }

  if (v3)
  {
    uint64_t v12 = [v3 objectForKeyedSubscript:kPCSSetupDSID[0]];
    id v13 = (void *)v12;
    if (v12)
    {
      uint64_t v93 = 0;
      v99[0] = kPCSSetupDSID[0];
      v99[1] = kPCSSetupGuitarfish[0];
      v100[0] = v12;
      v100[1] = MEMORY[0x1E4F1CC38];
      id v14 = (void *)__PCSCopyStingrayInfo(0, (const __CFDictionary *)[MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v100 forKeys:v99 count:2], &v93);
      uint64_t v15 = v14;
      if (v93)
      {
        _PCSError((const void **)&v93, 231, @"Unable to get the current primary record state, can't setupIdentities!");
        uint64_t v16 = v93;
        v4[2](v4, 2, 1, 0, v93);
LABEL_60:

        goto LABEL_61;
      }
      uint64_t v17 = *MEMORY[0x1E4F59B88];
      uint64_t v18 = [v14 objectForKeyedSubscript:*MEMORY[0x1E4F59B88]];

      if (!v18)
      {
LABEL_28:
        uint64_t v40 = pcsLogObjForScope("Guitarfish");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109120;
          DWORD1(buf) = v18 == 0;
          _os_log_impl(&dword_1ACF98000, v40, OS_LOG_TYPE_DEFAULT, "Create Identities from scratch: %d", (uint8_t *)&buf, 8u);
        }

        if (!v18)
        {
          uint64_t v41 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&dword_1ACF98000, v41, OS_LOG_TYPE_DEFAULT, "No existing Guitarfish state detected, ok to enroll", (uint8_t *)&buf, 2u);
          }

          CFErrorRef v83 = 0;
          unsigned __int8 v48 = __PCSDeleteFromKeychainICDPForRPD(v13, &v83, v42, v43, v44, v45, v46, v47);
          if (v83) {
            unsigned __int8 v55 = 0;
          }
          else {
            unsigned __int8 v55 = v48;
          }
          if ((v55 & 1) == 0)
          {
            uint64_t v56 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              CFErrorRef v57 = v83;
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v83;
              _os_log_impl(&dword_1ACF98000, v56, OS_LOG_TYPE_DEFAULT, "Error deleting previous icloud keychain stash: %@", (uint8_t *)&buf, 0xCu);
            }
          }
          CFErrorRef v89 = 0;
          BOOL v58 = __PCSDeleteFromKeychain(1, &v89, v49, v50, v51, v52, v53, v54);
          if (v89) {
            BOOL v59 = 0;
          }
          else {
            BOOL v59 = v58;
          }
          if (!v59)
          {
            unint64_t v60 = pcsLogObjForScope("Guitarfish");
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              CFErrorRef v61 = v89;
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v89;
              _os_log_impl(&dword_1ACF98000, v60, OS_LOG_TYPE_DEFAULT, "Error deleting previous keychain stash: %@", (uint8_t *)&buf, 0xCu);
            }
          }
        }
        id v77 = 0;
        BOOL v62 = +[PCSAccountsModel adpEnabledForDSID:v13 error:&v77];
        id v63 = v77;
        uint64_t v16 = v63;
        if (v62)
        {
          uint64_t v64 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf) = 0;
            uint64_t v65 = "OTAccountSettings indicate that ADP is enabled, setting up without recovery token";
            uint64_t v66 = v64;
            uint32_t v67 = 2;
LABEL_53:
            _os_log_impl(&dword_1ACF98000, v66, OS_LOG_TYPE_DEFAULT, v65, (uint8_t *)&buf, v67);
          }
        }
        else
        {
          if (!v63) {
            goto LABEL_55;
          }
          uint64_t v64 = pcsLogObjForScope("Guitarfish");
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v16;
            uint64_t v65 = "Unable to determine ADP state: %@";
            uint64_t v66 = v64;
            uint32_t v67 = 12;
            goto LABEL_53;
          }
        }

LABEL_55:
        id v76 = 0;
        uint64_t v68 = PCSGuitarfishCreateSetupParameters(v3, v18 == 0, !v62, &v76);
        id v69 = v76;
        uint64_t v70 = v69;
        if (!v68 || v69)
        {
          v4[2](v4, 2, 1, 0, v69);
        }
        else
        {
          unint64_t v71 = connectionPCSKeySyncing();
          dispatch_semaphore_t v72 = [v71 remoteObjectProxyWithErrorHandler:&__block_literal_global_262];
          [v72 setupIdentitiesWithParameters:v68 complete:v4];
        }
        goto LABEL_60;
      }
      id v19 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1ACF98000, v19, OS_LOG_TYPE_DEFAULT, "Previous record exists, don't create new identities", (uint8_t *)&buf, 2u);
      }

      id v20 = [v15 objectForKeyedSubscript:v17];
      uint64_t v16 = [v20 objectForKeyedSubscript:kPCSSecureBackupCFClientMetadataKey[0]];

      uint64_t v21 = [v16 objectForKeyedSubscript:kPCSSecureBackupCFiCloudDataProtectionKey[0]];
      id v22 = [v21 objectForKeyedSubscript:@"SecureBackupWrappedKeys"];

      if (!v22)
      {
LABEL_27:

        goto LABEL_28;
      }
      int v23 = [v21 objectForKeyedSubscript:@"DerivedDBRSeedAESPID"];
      id v24 = v23;
      if (v23)
      {
        id v25 = v23;
      }
      else
      {
        id v25 = [@"invalid_record" dataUsingEncoding:4];
      }
      id v26 = v25;

      dispatch_semaphore_t v27 = pcsLogObjForScope("Guitarfish");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v26;
        _os_log_impl(&dword_1ACF98000, v27, OS_LOG_TYPE_DEFAULT, "Attempting recovery first since Guitarfish record already exists with pid: %@", (uint8_t *)&buf, 0xCu);
      }

      BOOL v75 = v26;
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v95 = 0x3032000000;
      uint64_t v96 = __Block_byref_object_copy__4;
      uint64_t v97 = __Block_byref_object_dispose__4;
      dispatch_semaphore_t v98 = dispatch_semaphore_create(0);
      CFErrorRef v89 = 0;
      uint64_t v90 = &v89;
      uint64_t v91 = 0x2020000000;
      uint64_t v92 = 2;
      CFErrorRef v83 = 0;
      id v84 = &v83;
      uint64_t v85 = 0x3032000000;
      uint64_t v86 = __Block_byref_object_copy__4;
      dispatch_semaphore_t v87 = __Block_byref_object_dispose__4;
      id v88 = 0;
      uint64_t v79 = 0;
      CFDataRef v80 = &v79;
      uint64_t v81 = 0x2020000000;
      uint64_t v82 = 0;
      v78[0] = MEMORY[0x1E4F143A8];
      v78[1] = 3221225472;
      v78[2] = __PCSGuitarfishSetupIdentities_block_invoke;
      v78[3] = &unk_1E5E6F270;
      v78[4] = &v89;
      v78[5] = &v83;
      v78[6] = &v79;
      v78[7] = &buf;
      PCSGuitarfishRepairIdentities(v3, v78);
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(*((void *)&buf + 1) + 40), 0xFFFFFFFFFFFFFFFFLL);
      id v28 = v84;
      if (v90[3] || v84[5])
      {
        uint64_t v29 = v80[3] | 0x400000;
        v80[3] = v29;
        CFErrorRef v30 = v28[5];
        uint64_t v31 = v30;
        if (!v30)
        {
          id v74 = [v75 base64EncodedStringWithOptions:0];
          uint64_t v31 = PCSErrorCreate(231, @"primary record already exists in EP (PID:%@), and was unrecoverable, account may need another repair or RPD before SetupIdentities will continue", v32, v33, v34, v35, v36, v37, (uint64_t)v74);
        }
        v4[2](v4, 2, v29, 0, v31);
        if (!v30)
        {

          uint64_t v39 = v75;
          int v38 = 0;
          goto LABEL_26;
        }
        int v38 = 0;
      }
      else
      {
        int v38 = 1;
      }
      uint64_t v39 = v75;
LABEL_26:
      _Block_object_dispose(&v79, 8);
      _Block_object_dispose(&v83, 8);

      _Block_object_dispose(&v89, 8);
      _Block_object_dispose(&buf, 8);

      if (!v38)
      {

        goto LABEL_60;
      }
      goto LABEL_27;
    }
  }
  id v13 = PCSErrorCreate(121, @"Missing DSID in parameters", v6, v7, v8, v9, v10, v11, v73);
  v4[2](v4, 2, 1, 0, v13);
LABEL_61:
}

void sub_1ACFEB2D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose((const void *)(v32 - 208), 8);
  _Unwind_Resume(a1);
}

void __PCSGuitarfishSetupIdentities_block_invoke(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v8 = a4;
  *(void *)(*(void *)(a1[4] + 8) + 24) = a2;
  objc_storeStrong((id *)(*(void *)(a1[5] + 8) + 40), a4);
  *(void *)(*(void *)(a1[6] + 8) + 24) = a3;
  uint64_t v9 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 134218498;
    uint64_t v11 = a2;
    __int16 v12 = 2048;
    uint64_t v13 = a3;
    __int16 v14 = 2112;
    id v15 = v8;
    _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "Attempted repair during SetupIdentities with status: %lu, flags: %lu, and error: %@", (uint8_t *)&v10, 0x20u);
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(a1[7] + 8) + 40));
}

void completeValidateIdentities(void *a1, uint64_t a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1;
  id v10 = a4;
  id v11 = a5;
  if (!v10) {
    id v10 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  }
  __int16 v12 = [NSNumber numberWithLong:a3];
  [v10 setObject:v12 forKeyedSubscript:@"flags"];

  uint64_t v13 = [NSNumber numberWithLong:a2];
  [v10 setObject:v13 forKeyedSubscript:@"status"];

  __int16 v14 = _PCSGuitarfishPopulateFlagNamesToTelemetryArray(a3, 0);
  [v10 setObject:v14 forKeyedSubscript:@"flags_dict"];

  id v15 = pcsLogObjForScope("Guitarfish");
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = 138412290;
    id v17 = v10;
    _os_log_impl(&dword_1ACF98000, v15, OS_LOG_TYPE_DEFAULT, "PCSGuitarfishValidateIdentities Complete: Status: %@", (uint8_t *)&v16, 0xCu);
  }

  v9[2](v9, a2, a3, v10, v11);
}

void __PCSGuitarfishValidateIdentities_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) |= a3;
  if (v13)
  {
    __int16 v14 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 138412290;
      id v22 = v13;
      _os_log_impl(&dword_1ACF98000, v14, OS_LOG_TYPE_DEFAULT, "error while attempting to fetch recovery token info: %@", (uint8_t *)&v21, 0xCu);
    }
  }
  if (a2 == 1) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
  uint64_t v15 = *(void *)(*(void *)(a1 + 56) + 8);
  int v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = v12;
  id v17 = v12;

  uint64_t v18 = *(void *)(*(void *)(a1 + 64) + 8);
  id v19 = *(void **)(v18 + 40);
  *(void *)(v18 + 40) = v11;
  id v20 = v11;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishValidateIdentities_block_invoke_267(uint64_t a1, void *a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = v6;
  if (!v5 || v6)
  {
    __int16 v14 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 138412290;
      uint64_t v16 = (uint64_t)v7;
      _os_log_impl(&dword_1ACF98000, v14, OS_LOG_TYPE_DEFAULT, "unable to recover token from keychain: %@", (uint8_t *)&v15, 0xCu);
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) |= 0x10uLL;
  }
  else
  {
    id v8 = (void *)[[NSString alloc] initWithData:v5 encoding:4];
    uint64_t v9 = [v8 componentsSeparatedByString:@" "];
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
    id v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    id v12 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) count];
      int v15 = 134217984;
      uint64_t v16 = v13;
      _os_log_impl(&dword_1ACF98000, v12, OS_LOG_TYPE_DEFAULT, "recovered token from keychain of length: %lu", (uint8_t *)&v15, 0xCu);
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishValidateIdentities_block_invoke_268(uint64_t a1, void *a2, void *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  id v7 = a3;
  id v8 = v7;
  if (!v6 || v7)
  {
    uint64_t v10 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      uint64_t v12 = (uint64_t)v8;
      _os_log_impl(&dword_1ACF98000, v10, OS_LOG_TYPE_DEFAULT, "unable to recover wrapping key from keychain: %@", (uint8_t *)&v11, 0xCu);
    }

    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) |= 0x20uLL;
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    uint64_t v9 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 134217984;
      uint64_t v12 = [v6 length];
      _os_log_impl(&dword_1ACF98000, v9, OS_LOG_TYPE_DEFAULT, "recovered wrapping key from keychain of length: %lu", (uint8_t *)&v11, 0xCu);
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishValidateIdentities_block_invoke_275(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v8 = a6;
  if (v8) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a6);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishValidateIdentities_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v8 = a6;
  if (v8)
  {
    id v9 = v8;
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a6);
    id v8 = v9;
  }
}

void __PCSGuitarfishValidateIdentities_block_invoke_279(uint64_t a1, void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v10 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "Failed to delete wrapping key from keychain: %@", buf, 0xCu);
    }
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __PCSGuitarfishValidateIdentities_block_invoke_280;
  v6[3] = &unk_1E5E6F2E8;
  id v5 = *(void **)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  long long v8 = *(_OWORD *)(a1 + 48);
  _PCSGuitarfishDeleteKeychainItem(@"RecoveryToken", v5, v6);
}

void __PCSGuitarfishValidateIdentities_block_invoke_280(uint64_t a1, void *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "Failed to delete recovery token from keychain: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  completeValidateIdentities(*(void **)(a1 + 32), 1, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0, *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
}

void __PCSGuitarfishValidateIdentities_block_invoke_287(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v10 = a4;
  if (v10) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a4);
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
  long long v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;
  id v9 = v6;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSGuitarfishValidateIdentities_block_invoke_288(uint64_t a1, void *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = pcsLogObjForScope("Guitarfish");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl(&dword_1ACF98000, v4, OS_LOG_TYPE_DEFAULT, "Failed to delete recovery token from keychain: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  completeValidateIdentities(*(void **)(a1 + 32), 1, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0, *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
}

void *__initCloudKit_block_invoke()
{
  CFTypeRef result = dlopen("/System/Library/Frameworks/CloudKit.framework/CloudKit", 1);
  cloudKit = (uint64_t)result;
  return result;
}

void __connectionPCSKeySyncing_block_invoke()
{
  CFDictionaryRef v0 = [MEMORY[0x1E4F29280] interfaceWithProtocol:&unk_1F03FF0F8];
  _PCSSyncingSetupInterface(v0);
  uint64_t v1 = [objc_alloc(MEMORY[0x1E4F29268]) initWithMachServiceName:@"com.apple.protectedcloudstorage.protectedcloudkeysyncing" options:4096];
  id v2 = (void *)connectionPCSKeySyncing_connection;
  connectionPCSKeySyncing_connection = v1;

  if (connectionPCSKeySyncing_connection)
  {
    [(id)connectionPCSKeySyncing_connection setRemoteObjectInterface:v0];
    [(id)connectionPCSKeySyncing_connection setInvalidationHandler:&__block_literal_global_355];
    [(id)connectionPCSKeySyncing_connection resume];
    [(id)connectionPCSKeySyncing_connection setInterruptionHandler:&__block_literal_global_358];
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "no server connection", v3, 2u);
  }
}

void __connectionPCSKeySyncing_block_invoke_353()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFDictionaryRef v0 = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "pcs xpc connection handle invalid", v0, 2u);
  }
}

void __connectionPCSKeySyncing_block_invoke_356()
{
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFDictionaryRef v0 = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "server connection rejected us", v0, 2u);
  }
}

Class __getAKAccountManagerClass_block_invoke_1(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!AuthKitLibraryCore_frameworkLibrary_1)
  {
    v3[1] = (void *)MEMORY[0x1E4F143A8];
    void v3[2] = (void *)3221225472;
    v3[3] = __AuthKitLibraryCore_block_invoke_1;
    void v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E5E6F358;
    uint64_t v5 = 0;
    AuthKitLibraryCore_frameworkLibrary_1 = _sl_dlopen();
    if (!AuthKitLibraryCore_frameworkLibrary_1)
    {
      abort_report_np();
LABEL_8:
      __getAKAccountManagerClass_block_invoke_cold_1();
    }
    if (v3[0]) {
      free(v3[0]);
    }
  }
  Class result = objc_getClass("AKAccountManager");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    goto LABEL_8;
  }
  getAKAccountManagerClass_softClass_1 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __AuthKitLibraryCore_block_invoke_1()
{
  uint64_t result = _sl_dlopen();
  AuthKitLibraryCore_frameworkLibrary_1 = result;
  return result;
}

uint64_t PCSSupportGetClientInfo()
{
  if (PCSSupportGetClientInfo_onceToken != -1) {
    dispatch_once(&PCSSupportGetClientInfo_onceToken, &__block_literal_global_14);
  }
  return PCSSupportGetClientInfo_clientInfo;
}

void __PCSSupportGetClientInfo_block_invoke()
{
  CFDictionaryRef v0 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
  if (v0)
  {
    CFDictionaryRef v1 = v0;
    CFBooleanRef Value = CFDictionaryGetValue(v0, (const void *)*MEMORY[0x1E4F1CD10]);
    id v3 = CFDictionaryGetValue(v1, (const void *)*MEMORY[0x1E4F1CD18]);
    if (Value) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4) {
      CFStringRef v5 = 0;
    }
    else {
      CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"%@;%@", v3, Value);
    }
    CFRelease(v1);
  }
  else
  {
    CFStringRef v5 = 0;
  }
  PCSSupportGetClientInfo_clientInfo = (uint64_t)v5;
}

void sub_1ACFEC594(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFEE238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
}

uint64_t __operationQueueForService_block_invoke()
{
  CFDictionaryRef v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("PCSCKKS.operationQueueForService", v0);
  id v2 = (void *)operationQueueForService_queue;
  operationQueueForService_queue = (uint64_t)v1;

  operationQueueForService_serviceQueueMap = [objc_alloc(MEMORY[0x1E4F28E10]) initWithKeyOptions:0 valueOptions:5 capacity:0];
  return MEMORY[0x1F41817F8]();
}

void __operationQueueForService_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = [(id)operationQueueForService_serviceQueueMap objectForKey:*(void *)(a1 + 32)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
  {
    id v5 = objc_alloc_init(MEMORY[0x1E4F28F08]);
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setMaxConcurrentOperationCount:1];
    long long v8 = (void *)operationQueueForService_serviceQueueMap;
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    [v8 setObject:v10 forKey:v9];
  }
}

void PCSGetBoundaryKey(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = dispatch_get_global_queue(21, 0);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  void v8[2] = __PCSGetBoundaryKey_block_invoke;
  void v8[3] = &unk_1E5E6F410;
  id v9 = v3;
  id v10 = v4;
  id v6 = v4;
  id v7 = v3;
  dispatch_async(v5, v8);
}

void __PCSGetBoundaryKey_block_invoke(uint64_t a1)
{
  uint64_t v1 = a1;
  v118[1] = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  uint64_t v2 = [*(id *)(a1 + 32) objectForKeyedSubscript:kPCSSetupDSID[0]];
  id v3 = v2;
  if (!v2)
  {
    uint64_t v34 = *(void *)(v1 + 40);
    uint64_t v35 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v36 = kPCSErrorDomain;
    uint64_t v117 = *MEMORY[0x1E4F1D140];
    v118[0] = @"dsid not available";
    uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v118 forKeys:&v117 count:1];
    uint64_t v37 = v35;
    int v38 = v36;
    uint64_t v39 = 121;
LABEL_29:
    int v42 = [v37 errorWithDomain:v38 code:v39 userInfo:v11];
    (*(void (**)(uint64_t, void, void *))(v34 + 16))(v34, 0, v42);
    goto LABEL_30;
  }
  if (!PCSCurrentPersonaMatchesDSID(v2))
  {
    uint64_t v34 = *(void *)(v1 + 40);
    uint64_t v40 = (void *)MEMORY[0x1E4F28C58];
    uint64_t v41 = kPCSErrorDomain;
    uint64_t v115 = *MEMORY[0x1E4F28568];
    id v116 = @"Current persona does not match chosen dsid";
    uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v116 forKeys:&v115 count:1];
    uint64_t v37 = v40;
    int v38 = v41;
    uint64_t v39 = 152;
    goto LABEL_29;
  }
  uint64_t v4 = *MEMORY[0x1E4F3B998];
  uint64_t v5 = *MEMORY[0x1E4F3B5C0];
  uint64_t v82 = *MEMORY[0x1E4F3B978];
  v113[0] = *MEMORY[0x1E4F3B978];
  v113[1] = v5;
  uint64_t v84 = v5;
  uint64_t v83 = v4;
  v114[0] = v4;
  v114[1] = kPCSAccountBoundaryKey[0];
  uint64_t v6 = *MEMORY[0x1E4F1CFD0];
  uint64_t v7 = *MEMORY[0x1E4F3B848];
  uint64_t v85 = *MEMORY[0x1E4F3B878];
  v113[2] = *MEMORY[0x1E4F3B878];
  v113[3] = v7;
  v114[2] = v6;
  v114[3] = v3;
  uint64_t v8 = *MEMORY[0x1E4F3BC70];
  uint64_t v86 = *MEMORY[0x1E4F3B550];
  v113[4] = *MEMORY[0x1E4F3B550];
  v113[5] = v8;
  v114[4] = kPCSDefaultKeychainGroup[0];
  v114[5] = v6;
  uint64_t v9 = *MEMORY[0x1E4F3BB80];
  v113[6] = *MEMORY[0x1E4F3BC68];
  v113[7] = v9;
  uint64_t v10 = *MEMORY[0x1E4F3BB88];
  v114[6] = v6;
  v114[7] = v10;
  uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v114 forKeys:v113 count:8];
  uint64_t v12 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  uint64_t v13 = _PCSKeychainForwardTable(v11, &cf);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v12;
  if (v13 != -25300)
  {
    if (!v13)
    {
      long long v92 = 0u;
      long long v93 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      obuint64_t j = (id)cf;
      uint64_t v14 = [obj countByEnumeratingWithState:&v92 objects:v112 count:16];
      if (v14)
      {
        uint64_t v15 = v14;
        uint64_t v78 = v7;
        uint64_t v79 = v6;
        uint64_t v80 = v1;
        uint64_t v81 = v11;
        id v16 = 0;
        CFErrorRef v89 = 0;
        uint64_t v90 = 0;
        char v88 = 0;
        uint64_t v17 = *(void *)v93;
        uint64_t v18 = *MEMORY[0x1E4F3B558];
        uint64_t v19 = *MEMORY[0x1E4F3B5B0];
        uint64_t v20 = *MEMORY[0x1E4F3B870];
        uint64_t v87 = *MEMORY[0x1E4F3B8E0];
        do
        {
          uint64_t v21 = 0;
          id v22 = v16;
          do
          {
            if (*(void *)v93 != v17) {
              objc_enumerationMutation(obj);
            }
            id v16 = *(id *)(*((void *)&v92 + 1) + 8 * v21);

            uint64_t v23 = [v16 objectForKeyedSubscript:v18];
            int v24 = [v23 isEqualToString:v19];

            if (v24)
            {
              id v25 = MEMORY[0x1E4F14500];
              if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl(&dword_1ACF98000, v25, OS_LOG_TYPE_DEFAULT, "Item needs upgrading", buf, 2u);
              }
              char v88 = 1;
            }
            id v26 = [v16 objectForKeyedSubscript:v20];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              if ([v26 isEqualToString:v87])
              {
                dispatch_semaphore_t v27 = v89;
                CFErrorRef v89 = AssignedPreferred(v89, v16);
              }
              else
              {
                dispatch_semaphore_t v27 = v90;
                uint64_t v90 = AssignedPreferred(v90, v16);
              }
            }
            ++v21;
            id v22 = v16;
          }
          while (v15 != v21);
          uint64_t v15 = [obj countByEnumeratingWithState:&v92 objects:v112 count:16];
        }
        while (v15);

        if (v88)
        {
          v110[0] = v82;
          v110[1] = v84;
          v111[0] = v83;
          v111[1] = kPCSAccountBoundaryKey[0];
          v110[2] = v85;
          v110[3] = v18;
          v111[2] = v79;
          v111[3] = v19;
          v110[4] = v78;
          v110[5] = v86;
          v111[4] = v3;
          v111[5] = kPCSDefaultKeychainGroup[0];
          id v28 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v111 forKeys:v110 count:6];
          uint64_t v108 = v18;
          uint64_t v109 = *MEMORY[0x1E4F3B570];
          uint64_t v29 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v109 forKeys:&v108 count:1];
          int v30 = qword_1EB3B39C0(v28, v29);
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            int v105 = v30;
            _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Item upgrade resulted in: %d", buf, 8u);
          }
        }
        if (v89)
        {
          id v31 = v89;
          uint64_t v32 = v31;
          uint64_t v1 = v80;
          uint64_t v11 = v81;
          id v33 = v90;
          goto LABEL_39;
        }
        uint64_t v1 = v80;
        uint64_t v11 = v81;
        unsigned __int8 v55 = v90;
        uint64_t v56 = v87;
      }
      else
      {
        unsigned __int8 v55 = 0;
        uint64_t v56 = *MEMORY[0x1E4F3B8E0];
        uint64_t v20 = *MEMORY[0x1E4F3B870];
      }
      id v31 = v55;
      CFErrorRef v57 = (void *)[v31 mutableCopy];
      [v57 setObject:v56 forKeyedSubscript:v20];
      (*(&_PCSKeychainForwardTable + 1))(v57, 0);

      uint64_t v32 = 0;
      BOOL v58 = 0;
      BOOL v59 = 0;
      unint64_t v60 = 0;
      id v33 = v31;
      if (!v31)
      {
LABEL_42:
        (*(void (**)(void))(*(void *)(v1 + 40) + 16))();
        CFRelease(cf);

        goto LABEL_31;
      }
LABEL_39:
      unint64_t v60 = [v31 objectForKeyedSubscript:*MEMORY[0x1E4F3BD38]];
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {

        unint64_t v60 = 0;
      }
      BOOL v58 = v31;
      BOOL v59 = v33;
      goto LABEL_42;
    }
    goto LABEL_33;
  }
  int v43 = [*(id *)(v1 + 32) objectForKeyedSubscript:kPCSSetupBoundaryNoCreate[0]];
  int v44 = [v43 BOOLValue];

  if (v44)
  {
LABEL_33:
    uint64_t v45 = *(void *)(v1 + 40);
    int v46 = (void *)MEMORY[0x1E4F28C58];
    int v47 = kPCSErrorDomain;
    uint64_t v106 = *MEMORY[0x1E4F28568];
    unsigned __int8 v48 = objc_msgSend(NSString, "stringWithFormat:", @"Boundary key not available: %d", v13);
    char v107 = v48;
    int v49 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v107 forKeys:&v106 count:1];
    int v50 = [v46 errorWithDomain:v47 code:91 userInfo:v49];
    (*(void (**)(uint64_t, void, void *))(v45 + 16))(v45, 0, v50);

    goto LABEL_31;
  }
  if (SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E4F3BC60], 0x20uLL, buf))
  {
    uint64_t v51 = *(void *)(v1 + 40);
    int v52 = (void *)MEMORY[0x1E4F28C58];
    int v53 = kPCSErrorDomain;
    uint64_t v101 = *MEMORY[0x1E4F28568];
    uint64_t v102 = @"out of random";
    int v42 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v102 forKeys:&v101 count:1];
    int v54 = [v52 errorWithDomain:v53 code:92 userInfo:v42];
    (*(void (**)(uint64_t, void, void *))(v51 + 16))(v51, 0, v54);
  }
  else
  {
    ccsha256_di();
    ccdigest();
    int v42 = [MEMORY[0x1E4F1C9B8] dataWithBytes:buf length:32];
    CFErrorRef v61 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v103 length:32];
    int v54 = [v61 base64EncodedStringWithOptions:0];

    uint64_t v62 = *MEMORY[0x1E4F3B838];
    v99[0] = v82;
    v99[1] = v62;
    v100[0] = v83;
    v100[1] = v54;
    uint64_t v63 = v7;
    uint64_t v64 = *MEMORY[0x1E4F3B870];
    void v99[2] = v84;
    v99[3] = v64;
    uint64_t v65 = *MEMORY[0x1E4F3B8E0];
    v100[2] = kPCSAccountBoundaryKey[0];
    v100[3] = v65;
    uint64_t v66 = *MEMORY[0x1E4F3B558];
    void v99[4] = v85;
    v99[5] = v66;
    uint64_t v67 = *MEMORY[0x1E4F3B570];
    v100[4] = v6;
    void v100[5] = v67;
    v99[6] = v63;
    v99[7] = v86;
    v100[6] = v3;
    void v100[7] = kPCSDefaultKeychainGroup[0];
    uint8_t v99[8] = *MEMORY[0x1E4F3BD38];
    v100[8] = v42;
    uint64_t v68 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v100 forKeys:v99 count:9];
    id v69 = (void *)[v68 mutableCopy];

    uint64_t v70 = (*(&_PCSKeychainForwardTable + 1))(v69, 0);
    if (v70)
    {
      uint64_t v71 = *(void *)(v1 + 40);
      dispatch_semaphore_t v72 = (void *)MEMORY[0x1E4F28C58];
      uint64_t v73 = kPCSErrorDomain;
      uint64_t v97 = *MEMORY[0x1E4F28568];
      id v74 = objc_msgSend(NSString, "stringWithFormat:", @"Failed to write into keychain: %d", v70);
      dispatch_semaphore_t v98 = v74;
      [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v98 forKeys:&v97 count:1];
      v76 = BOOL v75 = v3;
      id v77 = [v72 errorWithDomain:v73 code:4 userInfo:v76];
      (*(void (**)(uint64_t, void, void *))(v71 + 16))(v71, 0, v77);

      id v3 = v75;
    }
    else
    {
      [v69 setObject:*MEMORY[0x1E4F3B8F8] forKeyedSubscript:v64];
      (*(&_PCSKeychainForwardTable + 1))(v69, 0);
      (*(void (**)(void))(*(void *)(v1 + 40) + 16))();
    }
  }
LABEL_30:

LABEL_31:
}

id AssignedPreferred(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = *MEMORY[0x1E4F3B668];
  uint64_t v6 = [v3 objectForKeyedSubscript:*MEMORY[0x1E4F3B668]];
  uint64_t v7 = [v4 objectForKeyedSubscript:v5];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v9 = v4;
  if (isKindOfClass)
  {
    objc_opt_class();
    char v10 = objc_opt_isKindOfClass();
    uint64_t v9 = v3;
    if (v10)
    {
      uint64_t v11 = [v6 earlierDate:v7];

      if (v11) {
        uint64_t v9 = v4;
      }
      else {
        uint64_t v9 = v3;
      }
    }
  }
  id v12 = v9;

  return v12;
}

uint64_t _PCSAppSpecificAccount(uint64_t a1)
{
  return [NSString stringWithFormat:@"%@-%@", kPCSAccountBoundaryKey[0], a1];
}

void PCSGetAppBoundaryKey(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = dispatch_get_global_queue(21, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __PCSGetAppBoundaryKey_block_invoke;
  block[3] = &unk_1E5E6F438;
  id v14 = v5;
  id v15 = v7;
  id v13 = v6;
  id v9 = v5;
  id v10 = v7;
  id v11 = v6;
  dispatch_async(v8, block);
}

void __PCSGetAppBoundaryKey_block_invoke(uint64_t a1)
{
  uint64_t v1 = a1;
  v114[1] = *MEMORY[0x1E4F143B8];
  CFTypeRef cf = 0;
  uint64_t v2 = [*(id *)(a1 + 32) objectForKeyedSubscript:kPCSSetupDSID[0]];
  id v3 = v2;
  if (!v2)
  {
    uint64_t v36 = *(void *)(v1 + 48);
    uint64_t v37 = (void *)MEMORY[0x1E4F28C58];
    int v38 = kPCSErrorDomain;
    uint64_t v113 = *MEMORY[0x1E4F1D140];
    v114[0] = @"dsid not available";
    id v4 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v114 forKeys:&v113 count:1];
    uint64_t v39 = v37;
    uint64_t v40 = v38;
    uint64_t v41 = 121;
LABEL_27:
    id v11 = [v39 errorWithDomain:v40 code:v41 userInfo:v4];
    (*(void (**)(uint64_t, void, void *))(v36 + 16))(v36, 0, v11);
    goto LABEL_28;
  }
  if (!PCSCurrentPersonaMatchesDSID(v2))
  {
    uint64_t v36 = *(void *)(v1 + 48);
    int v42 = (void *)MEMORY[0x1E4F28C58];
    int v43 = kPCSErrorDomain;
    uint64_t v111 = *MEMORY[0x1E4F28568];
    uint64_t v112 = @"Current persona does not match chosen dsid";
    id v4 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v112 forKeys:&v111 count:1];
    uint64_t v39 = v42;
    uint64_t v40 = v43;
    uint64_t v41 = 152;
    goto LABEL_27;
  }
  id v4 = (id)[NSString stringWithFormat:@"%@-%@", kPCSAccountBoundaryKey[0], *(void *)(v1 + 40)];
  uint64_t v5 = *MEMORY[0x1E4F3B998];
  uint64_t v79 = *MEMORY[0x1E4F3B978];
  uint64_t v80 = *MEMORY[0x1E4F3B5C0];
  v109[0] = *MEMORY[0x1E4F3B978];
  v109[1] = v80;
  uint64_t v81 = v5;
  v110[0] = v5;
  v110[1] = v4;
  uint64_t v6 = *MEMORY[0x1E4F1CFD0];
  uint64_t v83 = *MEMORY[0x1E4F3B878];
  uint64_t v84 = *MEMORY[0x1E4F3B848];
  v109[2] = *MEMORY[0x1E4F3B878];
  v109[3] = v84;
  v110[2] = v6;
  v110[3] = v3;
  uint64_t v7 = *(void *)(v1 + 40);
  uint64_t v8 = *MEMORY[0x1E4F3BC70];
  uint64_t v82 = *MEMORY[0x1E4F3B550];
  v109[4] = *MEMORY[0x1E4F3B550];
  v109[5] = v8;
  v110[4] = v7;
  v110[5] = v6;
  uint64_t v9 = *MEMORY[0x1E4F3BB80];
  void v109[6] = *MEMORY[0x1E4F3BC68];
  v109[7] = v9;
  uint64_t v10 = *MEMORY[0x1E4F3BB88];
  void v110[6] = v6;
  v110[7] = v10;
  id v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v110 forKeys:v109 count:8];
  uint64_t v12 = PCSMeasureRelativeNanoTime();
  ++qword_1EB3B49E8;
  uint64_t v13 = _PCSKeychainForwardTable(v11, &cf);
  qword_1EB3B49F0 += PCSMeasureRelativeNanoTime() - v12;
  if (v13 != -25300)
  {
    if (!v13)
    {
      uint64_t v76 = v6;
      long long v88 = 0u;
      long long v89 = 0u;
      long long v90 = 0u;
      long long v91 = 0u;
      obuint64_t j = (id)cf;
      uint64_t v14 = [obj countByEnumeratingWithState:&v88 objects:v108 count:16];
      if (v14)
      {
        uint64_t v15 = v14;
        uint64_t v73 = v1;
        id v74 = v11;
        id v77 = v4;
        BOOL v75 = v3;
        id v16 = 0;
        uint64_t v17 = 0;
        char v85 = 0;
        uint64_t v18 = *(void *)v89;
        uint64_t v19 = *MEMORY[0x1E4F3B558];
        uint64_t v20 = *MEMORY[0x1E4F3B5B0];
        uint64_t v21 = *MEMORY[0x1E4F3B870];
        do
        {
          uint64_t v22 = 0;
          uint64_t v23 = v16;
          do
          {
            if (*(void *)v89 != v18) {
              objc_enumerationMutation(obj);
            }
            id v16 = *(id *)(*((void *)&v88 + 1) + 8 * v22);

            int v24 = [v16 objectForKeyedSubscript:v19];
            int v25 = [v24 isEqualToString:v20];

            if (v25)
            {
              id v26 = MEMORY[0x1E4F14500];
              if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl(&dword_1ACF98000, v26, OS_LOG_TYPE_DEFAULT, "Item needs upgrading", buf, 2u);
              }
              char v85 = 1;
            }
            dispatch_semaphore_t v27 = [v16 objectForKeyedSubscript:v21];
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              uint64_t v28 = AssignedPreferred(v17, v16);

              uint64_t v17 = (void *)v28;
            }

            ++v22;
            uint64_t v23 = v16;
          }
          while (v15 != v22);
          uint64_t v15 = [obj countByEnumeratingWithState:&v88 objects:v108 count:16];
        }
        while (v15);

        id v3 = v75;
        uint64_t v1 = v73;
        if (v85)
        {
          v106[0] = v79;
          v106[1] = v80;
          v107[0] = v81;
          v107[1] = v77;
          v106[2] = v83;
          v106[3] = v19;
          v107[2] = v76;
          v107[3] = v20;
          v106[4] = v84;
          v106[5] = v82;
          uint64_t v29 = *(void *)(v73 + 40);
          v107[4] = v75;
          v107[5] = v29;
          int v30 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v107 forKeys:v106 count:6];
          uint64_t v104 = v19;
          uint64_t v105 = *MEMORY[0x1E4F3B570];
          uint64_t v31 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v105 forKeys:&v104 count:1];
          int v32 = qword_1EB3B39C0(v30, v31);
          if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            int v101 = v32;
            _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Item upgrade resulted in: %d", buf, 8u);
          }
        }
        id v33 = v17;
        uint64_t v34 = v33;
        if (!v33)
        {
          uint64_t v35 = 0;
          id v4 = v77;
          id v11 = v74;
          goto LABEL_36;
        }
        uint64_t v35 = [v33 objectForKeyedSubscript:*MEMORY[0x1E4F3BD38]];
        objc_opt_class();
        id v4 = v77;
        id v11 = v74;
        if (objc_opt_isKindOfClass())
        {
LABEL_36:
          (*(void (**)(void))(*(void *)(v1 + 48) + 16))();
          CFRelease(cf);

          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v34 = 0;
      }
      uint64_t v35 = 0;
      goto LABEL_36;
    }
    goto LABEL_30;
  }
  int v44 = [*(id *)(v1 + 32) objectForKeyedSubscript:kPCSSetupBoundaryNoCreate[0]];
  int v45 = [v44 BOOLValue];

  if (v45)
  {
LABEL_30:
    uint64_t v46 = *(void *)(v1 + 48);
    int v47 = (void *)MEMORY[0x1E4F28C58];
    unsigned __int8 v48 = kPCSErrorDomain;
    uint64_t v102 = *MEMORY[0x1E4F28568];
    int v49 = objc_msgSend(NSString, "stringWithFormat:", @"Boundary key not available: %d", v13);
    uint64_t v103 = v49;
    int v50 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v103 forKeys:&v102 count:1];
    uint64_t v51 = [v47 errorWithDomain:v48 code:91 userInfo:v50];
    (*(void (**)(uint64_t, void, void *))(v46 + 16))(v46, 0, v51);

    goto LABEL_28;
  }
  if (SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E4F3BC60], 0x20uLL, buf))
  {
    uint64_t v52 = *(void *)(v1 + 48);
    int v53 = (void *)MEMORY[0x1E4F28C58];
    int v54 = kPCSErrorDomain;
    uint64_t v97 = *MEMORY[0x1E4F28568];
    dispatch_semaphore_t v98 = @"out of random";
    unsigned __int8 v55 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v98 forKeys:&v97 count:1];
    uint64_t v56 = [v53 errorWithDomain:v54 code:92 userInfo:v55];
    (*(void (**)(uint64_t, void, void *))(v52 + 16))(v52, 0, v56);
  }
  else
  {
    ccsha256_di();
    ccdigest();
    unsigned __int8 v55 = [MEMORY[0x1E4F1C9B8] dataWithBytes:buf length:32];
    CFErrorRef v57 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v99 length:32];
    uint64_t v56 = [v57 base64EncodedStringWithOptions:0];

    uint64_t v58 = *MEMORY[0x1E4F3B838];
    v95[0] = v79;
    v95[1] = v58;
    v96[0] = v81;
    v96[1] = v56;
    uint64_t v59 = *MEMORY[0x1E4F3B870];
    v95[2] = v80;
    v95[3] = v59;
    uint64_t v60 = *MEMORY[0x1E4F3B8E0];
    v96[2] = v4;
    v96[3] = v60;
    uint64_t v61 = *MEMORY[0x1E4F3B558];
    v95[4] = v83;
    v95[5] = v61;
    uint64_t v62 = *MEMORY[0x1E4F3B570];
    v96[4] = v6;
    v96[5] = v62;
    v95[6] = v84;
    v95[7] = v82;
    uint64_t v63 = *(void *)(v1 + 40);
    v96[6] = v3;
    v96[7] = v63;
    v95[8] = *MEMORY[0x1E4F3BD38];
    v96[8] = v55;
    uint64_t v64 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v96 forKeys:v95 count:9];
    uint64_t v65 = (void *)[v64 mutableCopy];

    uint64_t v66 = (*(&_PCSKeychainForwardTable + 1))(v65, 0);
    uint64_t v67 = *(void *)(v1 + 48);
    if (v66)
    {
      id obja = (id)MEMORY[0x1E4F28C58];
      uint64_t v68 = kPCSErrorDomain;
      uint64_t v93 = *MEMORY[0x1E4F28568];
      objc_msgSend(NSString, "stringWithFormat:", @"Failed to write into keychain: %d", v66);
      v69 = id v78 = v4;
      long long v94 = v69;
      [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v94 forKeys:&v93 count:1];
      v71 = uint64_t v70 = v11;
      dispatch_semaphore_t v72 = [obja errorWithDomain:v68 code:4 userInfo:v71];
      (*(void (**)(uint64_t, void, void *))(v67 + 16))(v67, 0, v72);

      id v11 = v70;
      id v4 = v78;
    }
    else
    {
      (*(void (**)(void, void *, void))(v67 + 16))(*(void *)(v1 + 48), v55, 0);
    }
  }
LABEL_28:
}

void PCSDeleteBoundaryKey(void *a1)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = [a1 objectForKeyedSubscript:kPCSSetupDSID[0]];
  if (PCSCurrentPersonaMatchesDSID(v1))
  {
    uint64_t v2 = (void *)MEMORY[0x1E4F1CA60];
    uint64_t v3 = *MEMORY[0x1E4F3B998];
    uint64_t v4 = *MEMORY[0x1E4F3B5C0];
    v8[0] = *MEMORY[0x1E4F3B978];
    v8[1] = v4;
    v9[0] = v3;
    v9[1] = kPCSAccountBoundaryKey[0];
    uint64_t v5 = *MEMORY[0x1E4F3B550];
    void v8[2] = *MEMORY[0x1E4F3B878];
    void v8[3] = v5;
    v9[2] = *MEMORY[0x1E4F1CFD0];
    v9[3] = kPCSDefaultKeychainGroup[0];
    uint64_t v6 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v9 forKeys:v8 count:4];
    uint64_t v7 = [v2 dictionaryWithDictionary:v6];

    if (v1) {
      [v7 setObject:v1 forKeyedSubscript:*MEMORY[0x1E4F3B848]];
    }
    off_1EB3B39C8(v7);
  }
}

void PCSDeleteAppBoundaryKey(void *a1, void *a2)
{
  void v15[4] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = [a2 objectForKeyedSubscript:kPCSSetupDSID[0]];
  if (PCSCurrentPersonaMatchesDSID(v4))
  {
    uint64_t v5 = (void *)[NSString stringWithFormat:@"%@-%@", kPCSAccountBoundaryKey[0], v3];
    uint64_t v6 = (void *)MEMORY[0x1E4F1CA60];
    uint64_t v7 = *MEMORY[0x1E4F3B998];
    uint64_t v8 = *MEMORY[0x1E4F3B5C0];
    v14[0] = *MEMORY[0x1E4F3B978];
    v14[1] = v8;
    uint64_t v9 = *MEMORY[0x1E4F3B550];
    void v14[2] = *MEMORY[0x1E4F3B878];
    void v14[3] = v9;
    v15[0] = v7;
    v15[1] = v5;
    _OWORD v15[2] = *MEMORY[0x1E4F1CFD0];
    void v15[3] = v3;
    uint64_t v10 = (void *)MEMORY[0x1E4F1C9E8];
    id v11 = v5;
    uint64_t v12 = [v10 dictionaryWithObjects:v15 forKeys:v14 count:4];
    uint64_t v13 = [v6 dictionaryWithDictionary:v12];

    if (v4) {
      [v13 setObject:v4 forKeyedSubscript:*MEMORY[0x1E4F3B848]];
    }
    off_1EB3B39C8(v13);
  }
}

CFIndex _PCSError(const void **a1, CFIndex a2, CFStringRef format, ...)
{
  va_start(va, format);
  _PCSErrorVA(0, a1, a2, 0, format, va);
  return a2;
}

CFIndex _PCSErrorVA(uint64_t a1, const void **a2, CFIndex a3, const __CFDictionary *a4, CFStringRef format, va_list arguments)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFStringRef v10 = CFStringCreateWithFormatAndArguments(0, 0, format, arguments);
  if (a3 == 21 || a3 == 73) {
    os_log_type_t v12 = OS_LOG_TYPE_DEBUG;
  }
  else {
    os_log_type_t v12 = OS_LOG_TYPE_DEFAULT;
  }
  if (do_error_as_log)
  {
    uint64_t v13 = PCSLogGetOSLog(a1);
    if (os_log_type_enabled(v13, v12))
    {
      v18[0] = 67109378;
      v18[1] = a3;
      __int16 v19 = 2114;
      CFStringRef v20 = v10;
      _os_log_impl(&dword_1ACF98000, v13, v12, "PCSError: %d : %{public}@", (uint8_t *)v18, 0x12u);
    }
  }
  if (a2)
  {
    if (a4) {
      MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0, 0, a4);
    }
    else {
      MutableCFArrayRef Copy = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    uint64_t v15 = MutableCopy;
    CFDictionaryAddValue(MutableCopy, (const void *)*MEMORY[0x1E4F1D140], v10);
    id v16 = *a2;
    if (*a2)
    {
      CFDictionaryAddValue(v15, (const void *)*MEMORY[0x1E4F1D190], *a2);
      CFRelease(v16);
    }
    *a2 = CFErrorCreate(0, kPCSErrorDomain, a3, v15);
    if (v15) {
      CFRelease(v15);
    }
  }
  if (v10) {
    CFRelease(v10);
  }
  return a3;
}

CFIndex _PCSErrorContext(uint64_t a1, const void **a2, CFIndex a3, CFStringRef format, ...)
{
  va_start(va, format);
  _PCSErrorVA(a1, a2, a3, 0, format, va);
  return a3;
}

CFIndex _PCSErrorUserInfo(uint64_t a1, const void **a2, CFIndex a3, const __CFDictionary *a4, const __CFString *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return a3;
}

uint64_t _PCSErrorASN1(const void **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = (int)a3;
  _PCSError(a1, (int)a3, @"Failed to %s: %d", a2, a3);
  return v3;
}

CFIndex _PCSErrorOOM(const void **a1)
{
  return _PCSError(a1, 14, @"out of memory");
}

id PCSErrorCreate(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFStringRef v10 = (objc_class *)NSString;
  id v11 = a2;
  os_log_type_t v12 = (void *)[[v10 alloc] initWithFormat:v11 arguments:&a9];

  if (do_error_as_log && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v20 = v12;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSErrorCreate: %@", buf, 0xCu);
  }
  uint64_t v17 = *MEMORY[0x1E4F28568];
  uint64_t v18 = v12;
  uint64_t v13 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v18 forKeys:&v17 count:1];
  id v14 = objc_alloc(MEMORY[0x1E4F28C58]);
  uint64_t v15 = (void *)[v14 initWithDomain:kPCSErrorDomain code:a1 userInfo:v13];

  return v15;
}

uint64_t _PCSNSError(id *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return a2;
}

uint64_t _PCSNSErrorVA(uint64_t a1, id *a2, uint64_t a3, void *a4, void *a5, uint64_t a6)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v11 = a4;
  os_log_type_t v12 = (objc_class *)NSString;
  id v13 = a5;
  id v14 = (void *)[[v12 alloc] initWithFormat:v13 arguments:a6];

  if (a3 == 21 || a3 == 73) {
    os_log_type_t v16 = OS_LOG_TYPE_DEBUG;
  }
  else {
    os_log_type_t v16 = OS_LOG_TYPE_DEFAULT;
  }
  if (do_error_as_log)
  {
    uint64_t v17 = PCSLogGetOSLog(a1);
    if (os_log_type_enabled(v17, v16))
    {
      v23[0] = 67109378;
      v23[1] = a3;
      __int16 v24 = 2114;
      int v25 = v14;
      _os_log_impl(&dword_1ACF98000, v17, v16, "PCSError: %d : %{public}@", (uint8_t *)v23, 0x12u);
    }
  }
  if (a2)
  {
    id v18 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    __int16 v19 = v18;
    uint64_t v20 = *MEMORY[0x1E4F1D140];
    if (v11) {
      [v18 setObject:v11 forKeyedSubscript:*MEMORY[0x1E4F1D140]];
    }
    [v19 setObject:v14 forKeyedSubscript:v20];
    id v21 = *a2;
    if (v21) {
      [v19 setObject:v21 forKeyedSubscript:*MEMORY[0x1E4F1D190]];
    }
    *a2 = [MEMORY[0x1E4F28C58] errorWithDomain:kPCSErrorDomain code:a3 userInfo:v19];
  }
  return a3;
}

void sub_1ACFF1920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getAAFAnalyticsTransportRTCClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("AAFAnalyticsTransportRTC");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getAAFAnalyticsTransportRTCClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    __getAAFAnalyticsTransportRTCClass_block_invoke_cold_1();
    AAAFoundationLibrary();
  }
}

void AAAFoundationLibrary()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v1[0] = 0;
  if (!AAAFoundationLibraryCore_frameworkLibrary)
  {
    v1[1] = MEMORY[0x1E4F143A8];
    void v1[2] = 3221225472;
    v1[3] = __AAAFoundationLibraryCore_block_invoke;
    v1[4] = &__block_descriptor_40_e5_v8__0l;
    v1[5] = v1;
    long long v2 = xmmword_1E5E6F480;
    uint64_t v3 = 0;
    AAAFoundationLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  CFDictionaryRef v0 = (void *)v1[0];
  if (!AAAFoundationLibraryCore_frameworkLibrary)
  {
    CFDictionaryRef v0 = (void *)abort_report_np();
    goto LABEL_7;
  }
  if (v1[0]) {
LABEL_7:
  }
    free(v0);
}

uint64_t __AAAFoundationLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  AAAFoundationLibraryCore_frameworkLibrary = result;
  return result;
}

Class __getAAFAnalyticsReporterClass_block_invoke(uint64_t a1)
{
  AAAFoundationLibrary();
  Class result = objc_getClass("AAFAnalyticsReporter");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getAAFAnalyticsReporterClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    int v3 = __getAAFAnalyticsReporterClass_block_invoke_cold_1();
    return (Class)PCSSecError(v3, v4, v5);
  }
  return result;
}

BOOL PCSSecError(int a1, CFErrorRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1 && a2)
  {
    CFErrorRef v5 = *a2;
    *a2 = 0;
    PCSSecCFCreateErrorWithFormatAndArguments(a1, (const __CFString *)*MEMORY[0x1E4F1D158], (const __CFString *)v5, a2, 0, format, va);
  }
  return a1 == 0;
}

uint64_t PCSSecCFCreateErrorWithFormatAndArguments(CFIndex a1, const __CFString *a2, const __CFString *a3, CFErrorRef *a4, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  userInfoKeys[2] = *(void **)MEMORY[0x1E4F143B8];
  if (a4)
  {
    if (*a4)
    {
      if (a3 && *a4 != (CFErrorRef)a3)
      {
        CFStringRef v9 = a3;
LABEL_11:
        CFRelease(v9);
      }
    }
    else
    {
      CFStringRef v12 = CFStringCreateWithFormatAndArguments(0, formatOptions, format, arguments);
      id v13 = (void *)*MEMORY[0x1E4F1D190];
      userInfoKeys[0] = *(void **)MEMORY[0x1E4F1D140];
      userInfoKeys[1] = v13;
      userInfoValues[0] = (void *)v12;
      userInfoValues[1] = (void *)a3;
      if (a3) {
        CFIndex v14 = 2;
      }
      else {
        CFIndex v14 = 1;
      }
      *a4 = CFErrorCreateWithUserInfoKeysAndValues((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a1, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, v14);
      if (v12)
      {
        CFStringRef v9 = v12;
        goto LABEL_11;
      }
    }
  }
  return 0;
}

void PCSRestoreCKBackup()
{
  dispatch_semaphore_t v0 = dispatch_semaphore_create(0);
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = __PCSRestoreCKBackup_block_invoke;
  v2[3] = &unk_1E5E6F4A0;
  dispatch_semaphore_t v3 = v0;
  uint64_t v1 = v0;
  PCSRestoreCKBackupWithCompletion(0, v2);
  dispatch_semaphore_wait(v1, 0xFFFFFFFFFFFFFFFFLL);
}

uint64_t PCSRestoreCKBackupWithCompletion(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSRestoreCKBackupWithCompletion", buf, 2u);
  }
  *(void *)long long buf = 0;
  CFStringRef v12 = buf;
  uint64_t v13 = 0x2020000000;
  char v14 = 0;
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  _DWORD v7[2] = __PCSRestoreCKBackupWithCompletion_block_invoke;
  v7[3] = &unk_1E5E6F4C8;
  char v10 = a1;
  CFStringRef v9 = buf;
  id v4 = v3;
  id v8 = v4;
  PCSBackupRestoreMobileBackup(a1, v7);
  uint64_t v5 = v12[24];

  _Block_object_dispose(buf, 8);
  return v5;
}

void sub_1ACFF200C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void __PCSRestoreCKBackup_block_invoke(uint64_t a1, int a2, int a3, int a4, void *a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v9 = a5;
  if (v9 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    v10[0] = 67109890;
    v10[1] = a2;
    __int16 v11 = 1024;
    int v12 = a3;
    __int16 v13 = 1024;
    int v14 = a4;
    __int16 v15 = 2112;
    id v16 = v9;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSRestoreCKBackupWithCompletion returned recoverIssue %u missing %u present %u error: %@", (uint8_t *)v10, 0x1Eu);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void __PCSRestoreCKBackupWithCompletion_block_invoke(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v17 = a2;
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  int v12 = *(unsigned __int8 *)(a1 + 48);
  int v13 = [v17 unsignedIntValue];
  if (v12) {
    BOOL v14 = v13 == 0;
  }
  else {
    BOOL v14 = 0;
  }
  BOOL v15 = v14;
  if (!v12 && !v13)
  {
    if ([v9 unsignedIntValue]) {
      BOOL v15 = 1;
    }
    else {
      BOOL v15 = [v10 unsignedIntValue] != 0;
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v15;
  uint64_t v16 = *(void *)(a1 + 32);
  if (v16) {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, id))(v16 + 16))(v16, [v17 unsignedIntValue], objc_msgSend(v9, "unsignedIntValue"), objc_msgSend(v10, "unsignedIntValue"), v11);
  }
}

uint64_t PCSMobileBackupStatus(uint64_t a1)
{
  dispatch_semaphore_t v2 = dispatch_semaphore_create(0);
  uint64_t v11 = 0;
  int v12 = &v11;
  uint64_t v13 = 0x2020000000;
  char v14 = 0;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSMobileBackupStatus", buf, 2u);
  }
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = __PCSMobileBackupStatus_block_invoke;
  v6[3] = &unk_1E5E6F4F0;
  id v8 = &v11;
  uint64_t v9 = a1;
  id v3 = v2;
  uint64_t v7 = v3;
  PCSMobileBackupStatusXPC(v6);
  dispatch_semaphore_wait(v3, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v4 = *((unsigned __int8 *)v12 + 24);

  _Block_object_dispose(&v11, 8);
  return v4;
}

void sub_1ACFF2354(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void __PCSMobileBackupStatus_block_invoke(uint64_t a1, int a2, void *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = @"OFF";
    if (a2) {
      uint64_t v6 = @"ON";
    }
    int v7 = 138412546;
    id v8 = v6;
    __int16 v9 = 2112;
    id v10 = v5;
    _os_log_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "PCSMobileBackupStatus %@ error %@", (uint8_t *)&v7, 0x16u);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  if (v5 && *(void *)(a1 + 48)) {
    **(void **)(a1 + 4_Block_object_dispose(&a9, 8) = v5;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1ACFF32A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1ACFF374C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

id getkAAFDeviceSessionId()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000;
  dispatch_semaphore_t v0 = (void **)getkAAFDeviceSessionIdSymbolLoc_ptr;
  uint64_t v7 = getkAAFDeviceSessionIdSymbolLoc_ptr;
  if (!getkAAFDeviceSessionIdSymbolLoc_ptr)
  {
    uint64_t v1 = (void *)AAAFoundationLibrary_0();
    v5[3] = (uint64_t)dlsym(v1, "kAAFDeviceSessionId");
    getkAAFDeviceSessionIdSymbolLoc_ptr = v5[3];
    dispatch_semaphore_t v0 = (void **)v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (!v0) {
    -[PCSAccountsModel init]();
  }
  dispatch_semaphore_t v2 = *v0;
  return v2;
}

void sub_1ACFF3860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t AAAFoundationLibraryCore()
{
  if (!AAAFoundationLibraryCore_frameworkLibrary_0) {
    AAAFoundationLibraryCore_frameworkLibrary_0 = _sl_dlopen();
  }
  return AAAFoundationLibraryCore_frameworkLibrary_0;
}

uint64_t __AAAFoundationLibraryCore_block_invoke_0()
{
  uint64_t result = _sl_dlopen();
  AAAFoundationLibraryCore_frameworkLibrary_0 = result;
  return result;
}

uint64_t AuthKitLibraryCore()
{
  if (!AuthKitLibraryCore_frameworkLibrary_2) {
    AuthKitLibraryCore_frameworkLibrary_2 = _sl_dlopen();
  }
  return AuthKitLibraryCore_frameworkLibrary_2;
}

uint64_t __AuthKitLibraryCore_block_invoke_2()
{
  uint64_t result = _sl_dlopen();
  AuthKitLibraryCore_frameworkLibrary_2 = result;
  return result;
}

Class __getAKAccountManagerClass_block_invoke_2(uint64_t a1)
{
  if (!AuthKitLibraryCore())
  {
    id v3 = (void *)abort_report_np();
    free(v3);
  }
  Class result = objc_getClass("AKAccountManager");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    __getAKAccountManagerClass_block_invoke_cold_1();
  }
  getAKAccountManagerClass_softClass_2 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class __getAAFAnalyticsEventClass_block_invoke(uint64_t a1)
{
  AAAFoundationLibrary_0();
  Class result = objc_getClass("AAFAnalyticsEvent");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    __getAAFAnalyticsEventClass_block_invoke_cold_1();
  }
  getAAFAnalyticsEventClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t AAAFoundationLibrary_0()
{
  uint64_t v0 = AAAFoundationLibraryCore();
  if (!v0)
  {
    dispatch_semaphore_t v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

void *__getkAAFFlowIdSymbolLoc_block_invoke(uint64_t a1)
{
  dispatch_semaphore_t v2 = (void *)AAAFoundationLibrary_0();
  Class result = dlsym(v2, "kAAFFlowId");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkAAFFlowIdSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getkAAFDeviceSessionIdSymbolLoc_block_invoke(uint64_t a1)
{
  dispatch_semaphore_t v2 = (void *)AAAFoundationLibrary_0();
  Class result = dlsym(v2, "kAAFDeviceSessionId");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getkAAFDeviceSessionIdSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

__CFData *PCSCopyWrappedKey(const __CFData *a1, const __CFData *a2)
{
  ccaes_ecb_encrypt_mode();
  uint64_t v4 = ccecb_context_size();
  MEMORY[0x1F4188790](v4);
  CFIndex Length = CFDataGetLength(a1);
  if (Length != 32 && Length != 16) {
    goto LABEL_7;
  }
  CFDataGetBytePtr(a1);
  ccecb_init();
  CFDataGetLength(a2);
  CFIndex v6 = ccwrap_wrapped_size();
  CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v6);
  if (a1)
  {
    CFDataGetBytePtr(a2);
    CFDataGetMutableBytePtr(Mutable);
    if (ccwrap_auth_encrypt())
    {
      if (Mutable)
      {
        CFRelease(Mutable);
LABEL_7:
        CFMutableSetRef Mutable = 0;
      }
    }
    else if (CFDataGetLength(Mutable))
    {
      PCSCopyWrappedKey_cold_1();
    }
  }
  ccecb_context_size();
  cc_clear();
  return Mutable;
}

__CFData *PCSCopyUnwrappedKey(const __CFData *a1, const __CFData *a2)
{
  ccaes_ecb_decrypt_mode();
  uint64_t v4 = ccecb_context_size();
  MEMORY[0x1F4188790](v4);
  CFIndex Length = CFDataGetLength(a1);
  if (CFDataGetLength(a2) < 8 || Length != 32 && Length != 16) {
    goto LABEL_7;
  }
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccecb_init();
  CFDataGetLength(a2);
  CFIndex v6 = ccwrap_unwrapped_size();
  CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v6);
  if (Mutable)
  {
    CFDataGetLength(a2);
    CFDataGetBytePtr(a2);
    CFDataGetMutableBytePtr(Mutable);
    if (ccwrap_auth_decrypt())
    {
      CFRelease(Mutable);
LABEL_7:
      CFMutableSetRef Mutable = 0;
      goto LABEL_9;
    }
    if (CFDataGetLength(Mutable)) {
      PCSCopyUnwrappedKey_cold_1();
    }
  }
LABEL_9:
  ccecb_context_size();
  cc_clear();
  return Mutable;
}

CFTypeRef PCSMMCSCopyEncryptedData(const __CFData *a1, const __CFData *a2, const __CFData *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = ccaes_siv_encrypt_mode();
  UInt8 v13 = 0;
  MEMORY[0x1F4188790](v6);
  if (PCSMMCSGetDerivedSIVKey(a1, (char *)&v13)
    && (ccsiv_init(), CFDataGetLength(a3),
                      uint64_t v7 = ccsiv_ciphertext_size(),
                      (CFMutableSetRef Mutable = CFDataCreateMutable(0, 0)) != 0))
  {
    __int16 v9 = Mutable;
    CFDataSetLength(Mutable, v7 + 17);
    int MutableBytePtr = CFDataGetMutableBytePtr(v9);
    UInt8 *MutableBytePtr = v13;
    if (SecRandomCopyBytes((SecRandomRef)*MEMORY[0x1E4F3BC60], 0x10uLL, MutableBytePtr + 1)
      || (ccsiv_set_nonce(), CFDataGetMutableBytePtr(v9), ccsiv_aad())
      || a2 && (CFDataGetLength(a2), CFDataGetBytePtr(a2), ccsiv_aad())
      || (CFDataGetLength(a3), CFDataGetBytePtr(a3), ccsiv_crypt()))
    {
      CFTypeRef v11 = 0;
    }
    else
    {
      CFTypeRef v11 = CFRetain(v9);
    }
    CFRelease(v9);
  }
  else
  {
    CFTypeRef v11 = 0;
  }
  cc_clear();
  return v11;
}

BOOL PCSMMCSGetDerivedSIVKey(const __CFData *a1, char *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  if (Length == 16)
  {
    char v5 = 3;
    goto LABEL_5;
  }
  if (Length == 32)
  {
    char v5 = 4;
LABEL_5:
    *a2 = v5;
    ccsha256_di();
    CFDataGetLength(a1);
    CFDataGetBytePtr(a1);
    return cchkdf() == 0;
  }
  return 0;
}

CFTypeRef PCSMMCSCopyDecryptedData(const __CFData *a1, const __CFData *a2, const __CFData *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = ccaes_siv_decrypt_mode();
  unsigned __int8 v13 = 0;
  MEMORY[0x1F4188790](v6);
  if (CFDataGetLength(a3) >= 18
    && PCSMMCSGetDerivedSIVKey(a1, (char *)&v13)
    && (ccsiv_init(), CFDataGetLength(a3), CFIndex v7 = ccsiv_plaintext_size(), (Mutable = CFDataCreateMutable(0, 0)) != 0))
  {
    __int16 v9 = Mutable;
    CFDataSetLength(Mutable, v7);
    BytePtr = CFDataGetBytePtr(a3);
    if (*BytePtr != v13
      || (ccsiv_set_nonce(), ccsiv_aad())
      || a2 && (CFDataGetLength(a2), CFDataGetBytePtr(a2), ccsiv_aad())
      || (CFDataGetMutableBytePtr(v9), ccsiv_crypt()))
    {
      CFTypeRef v11 = 0;
    }
    else
    {
      CFTypeRef v11 = CFRetain(v9);
    }
    CFRelease(v9);
  }
  else
  {
    CFTypeRef v11 = 0;
  }
  cc_clear();
  return v11;
}

uint64_t PCSKeyEnvelopeGetTypeID()
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __PCSKeyEnvelopeGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = &PCSKeyEnvelopeGetTypeID_sPCSKeyEnvelopeGetTypeIDSingleton;
  if (PCSKeyEnvelopeGetTypeID_sPCSKeyEnvelopeGetTypeIDOnce != -1) {
    dispatch_once(&PCSKeyEnvelopeGetTypeID_sPCSKeyEnvelopeGetTypeIDOnce, block);
  }
  return PCSKeyEnvelopeGetTypeID_sPCSKeyEnvelopeGetTypeIDSingleton;
}

uint64_t __PCSKeyEnvelopeGetTypeID_block_invoke(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

void PCSKeyEnvelopeDestroy(uint64_t a1)
{
  if (a1)
  {
    dispatch_semaphore_t v2 = *(const void **)(a1 + 16);
    if (v2)
    {
      *(void *)(a1 + 16) = 0;
      CFRelease(v2);
    }
    id v3 = *(const void **)(a1 + 24);
    if (v3)
    {
      *(void *)(a1 + 24) = 0;
      CFRelease(v3);
    }
  }
}

CFStringRef PCSKeyEnvelopeCopyDescription(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"KE@%p", a1);
  CFStringRef v4 = CFStringCreateWithFormat(v2, 0, @"<%@: [envelope: %@] [associatedData: %@]", v3, *(void *)(a1 + 16), *(void *)(a1 + 24));
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

uint64_t PCSKeyEnvelopeGetEnvelope(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void *PCSKeyEnvelopeCreateWithValues(uint64_t a1, const __CFData *a2, const __CFData *a3, const void **a4)
{
  PCSKeyEnvelopeGetTypeID();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  Instance[3] = CFDataCreateCopy(0, a2);
  CFDataRef Copy = CFDataCreateCopy(0, a3);
  Instance[2] = Copy;
  if (Instance[3]) {
    BOOL v15 = Copy == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15)
  {
    _PCSError(a4, 150, @"%s: could not create the key envelope", "PCSKeyEnvelopeRef  _Nonnull PCSKeyEnvelopeCreateWithValues(PCSShareProtectionRef _Nonnull, CFDataRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    CFRelease(Instance);
    uint64_t v22 = _PCSKEExtractSeed(a1, 0, a4, v16, v17, v18, v19, v20);
    uint64_t Instance = 0;
    id v21 = 0;
    if (!v22) {
      return v21;
    }
  }
  else
  {
    uint64_t v22 = _PCSKEExtractSeed(a1, (uint64_t)Instance, a4, v10, v11, v12, v13, v14);
    if (!v22)
    {
      id v21 = 0;
      goto LABEL_11;
    }
  }
  id v21 = Instance;
  uint64_t Instance = (void *)v22;
LABEL_11:
  CFRelease(Instance);
  return v21;
}

uint64_t _PCSKEExtractSeed(uint64_t a1, uint64_t a2, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v42 = 0;
  int v43 = &v42;
  uint64_t v44 = 0x2020000000;
  uint64_t v45 = 0;
  if (!a1)
  {
    _PCSError(a3, 128, @"%s: sp argument NULL", "CFDataRef _PCSKEExtractSeed(PCSShareProtectionRef, PCSKeyEnvelopeRef, CFErrorRef *)");
LABEL_34:
    id v21 = 0;
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v35);
  }
  if (!*(void *)(a1 + 72))
  {
    _PCSError(a3, 25, @"%s: cannot decrypt envelope without master key", "CFDataRef _PCSKEExtractSeed(PCSShareProtectionRef, PCSKeyEnvelopeRef, CFErrorRef *)");
    goto LABEL_34;
  }
  uint64_t v11 = *(const void **)(a2 + 24);
  if (!v11 || (CFTypeID v12 = CFGetTypeID(v11), v12 != CFDataGetTypeID()))
  {
    CFStringRef v34 = @"%s: keyEnvelope->context argument not CFData";
LABEL_33:
    _PCSError(a3, 126, v34, "CFDataRef _PCSKEExtractSeed(PCSShareProtectionRef, PCSKeyEnvelopeRef, CFErrorRef *)");
    goto LABEL_34;
  }
  uint64_t v13 = *(const void **)(a2 + 16);
  if (!v13 || (CFTypeID v14 = CFGetTypeID(v13), v14 != CFDataGetTypeID()))
  {
    CFStringRef v34 = @"%s: keyEnvelope->envelope argument not CFData";
    goto LABEL_33;
  }
  uint64_t v15 = *(void *)(a2 + 16);
  uint64_t v16 = [PCSEnvelopedKeyMaterial alloc];
  uint64_t v17 = [MEMORY[0x1E4F1C9B8] dataWithData:v15];
  uint64_t v18 = [(PCSEnvelopedKeyMaterial *)v16 initWithData:v17];

  if (v18)
  {
    if ([(PCSEnvelopedKeyMaterial *)v18 version] == 1)
    {
      uint64_t v19 = [(PCSEnvelopedKeyMaterial *)v18 encryptedSeed];
      uint64_t v20 = [v19 length];

      if (v20 == 48)
      {
        id v21 = v18;
        goto LABEL_16;
      }
      _PCSError(a3, 13, @"%s: invalid ciphertext length", "PCSEnvelopedKeyMaterial *_PCSKEDeserializeEnvelope(CFDataRef, CFErrorRef *)");
    }
    else
    {
      _PCSError(a3, 13, @"%s: invalid version", "PCSEnvelopedKeyMaterial *_PCSKEDeserializeEnvelope(CFDataRef, CFErrorRef *)");
    }
  }
  else
  {
    _PCSError(a3, 13, @"%s: could not initWithData", "PCSEnvelopedKeyMaterial *_PCSKEDeserializeEnvelope(CFDataRef, CFErrorRef *)");
  }
  id v21 = 0;
LABEL_16:

  if (v21)
  {
    id v22 = [(PCSEnvelopedKeyMaterial *)v21 encryptedSeed];
    uint64_t v23 = (const UInt8 *)[v22 bytes];
    __int16 v24 = [(PCSEnvelopedKeyMaterial *)v21 encryptedSeed];
    CFIndex v25 = [v24 length];
    CFDataRef v26 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v23, v25, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);

    if (v26)
    {
      CFDataRef v27 = *(const __CFData **)(a1 + 72);
      uint64_t v28 = [(PCSEnvelopedKeyMaterial *)v21 version];
      if (v28)
      {
        if (v28 == 1)
        {
          uint64_t v29 = @"HKDF_SIV_GCM_HMAC_256";
        }
        else
        {
          objc_msgSend(NSString, "stringWithFormat:", @"(unknown: %i)", v28);
          uint64_t v29 = (__CFString *)objc_claimAutoreleasedReturnValue();
        }
      }
      else
      {
        uint64_t v29 = @"UNKNOWN";
      }
      int v30 = _PCSKEExtractSeedWithMasterKey(v27, v26, v29, *(const __CFData **)(a2 + 24), a3);
      void v43[3] = (uint64_t)v30;

      if (!v43[3] && [(PCSEnvelopedKeyMaterial *)v21 hasMasterKeyId])
      {
        CFDictionaryRef v31 = *(const __CFDictionary **)(a1 + 112);
        context[0] = MEMORY[0x1E4F143A8];
        context[1] = 3221225472;
        context[2] = ___PCSKEExtractSeed_block_invoke;
        context[3] = &unk_1E5E6F598;
        int v38 = &v42;
        uint64_t v37 = v21;
        uint64_t v39 = a3;
        CFDataRef v40 = v26;
        uint64_t v41 = a2;
        CFDictionaryApplyFunction(v31, (CFDictionaryApplierFunction)apply_block_2_5, context);
      }
      CFRelease(v26);
    }
    else
    {
      _PCSError(a3, 150, @"%s: could not allocate the encrypted seed", "CFDataRef _PCSKEExtractSeed(PCSShareProtectionRef, PCSKeyEnvelopeRef, CFErrorRef *)");
    }
  }
LABEL_27:
  uint64_t v32 = v43[3];

  _Block_object_dispose(&v42, 8);
  return v32;
}

void sub_1ACFF50D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *PCSKeyEnvelopeCreate(uint64_t a1, CFTypeRef cf, const void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    _PCSError(a3, 128, @"%s: sp argument NULL", "PCSKeyEnvelopeRef  _Nullable PCSKeyEnvelopeCreate(PCSShareProtectionRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    return 0;
  }
  if (*(_DWORD *)(a1 + 216) != 1192348414) {
    PCSAbort("PCSShareProtectionObject no longer alive (overrelease):(sp)->alive == pcsfpTruelyAlive", (uint64_t)cf, (uint64_t)a3, a4, a5, a6, a7, a8, v25);
  }
  if (!*(void *)(a1 + 72))
  {
    _PCSError(a3, 25, @"%s: cannot generate envelope without master key", "PCSKeyEnvelopeRef  _Nullable PCSKeyEnvelopeCreate(PCSShareProtectionRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    return 0;
  }
  if (!cf || (CFTypeID v11 = CFGetTypeID(cf), v11 != CFDataGetTypeID()))
  {
    _PCSError(a3, 126, @"%s: keykeyEnvelopeAssociatedData argument not CFData", "PCSKeyEnvelopeRef  _Nullable PCSKeyEnvelopeCreate(PCSShareProtectionRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    return 0;
  }
  CFTypeID v12 = _PCSKEAesSivKeyFromMasterKey(*(const __CFData **)(a1 + 72), @"HKDF_SIV_GCM_HMAC_256", (const __CFData *)cf, a3);
  if (!v12) {
    return 0;
  }
  CFDataRef v13 = v12;
  CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 32);
  if (Mutable)
  {
    size_t Length = CFDataGetLength(Mutable);
    int MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    _PCSRandomData(Length, MutableBytePtr);
    ccaes_siv_encrypt_mode();
    CFDataGetLength(Mutable);
    CFIndex v17 = ccsiv_ciphertext_size();
    uint64_t v18 = CFDataCreateMutable(0, 0);
    CFDataSetLength(v18, v17);
    if (v18)
    {
      uint64_t v29 = a3;
      CFDataGetLength(v13);
      CFDataRef v28 = v13;
      CFDataGetBytePtr(v13);
      CFDataGetLength((CFDataRef)cf);
      CFDataGetBytePtr((CFDataRef)cf);
      CFDataGetLength(Mutable);
      BytePtr = CFDataGetBytePtr(Mutable);
      CFDataRef v27 = CFDataGetMutableBytePtr(v18);
      if (ccsiv_one_shot())
      {
        CFRelease(v18);
        _PCSError(a3, 12, @"%s: Wrapping with AES-SIV failed", "PCSKeyEnvelopeRef  _Nullable PCSKeyEnvelopeCreate(PCSShareProtectionRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)", v27);
        uint64_t v23 = 0;
      }
      else
      {
        uint64_t v19 = objc_opt_new();
        if (objc_msgSend(@"HKDF_SIV_GCM_HMAC_256", "isEqualToString:", @"UNKNOWN", BytePtr, v27)) {
          uint64_t v20 = 0;
        }
        else {
          uint64_t v20 = [@"HKDF_SIV_GCM_HMAC_256" isEqualToString:@"HKDF_SIV_GCM_HMAC_256"];
        }
        [v19 setVersion:v20];
        id v21 = (void *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytes:CFDataGetBytePtr(*(CFDataRef *)(a1 + 80)) length:4];
        [v19 setMasterKeyId:v21];

        [v19 setEncryptedSeed:v18];
        CFDataRef v22 = [v19 data];
        uint64_t v23 = PCSKeyEnvelopeCreateWithValues(a1, (const __CFData *)cf, v22, v29);
      }
      CFDataRef v13 = v28;
    }
    else
    {
      _PCSError(a3, 150, @"%s: could not allocate the encrypted seed", "PCSKeyEnvelopeRef  _Nullable PCSKeyEnvelopeCreate(PCSShareProtectionRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
      uint64_t v23 = 0;
    }
    CFRelease(Mutable);
  }
  else
  {
    _PCSError(a3, 150, @"%s: could not allocate the seed", "PCSKeyEnvelopeRef  _Nullable PCSKeyEnvelopeCreate(PCSShareProtectionRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    uint64_t v23 = 0;
  }
  CFRelease(v13);
  return v23;
}

__CFData *_PCSKEAesSivKeyFromMasterKey(const __CFData *a1, void *a2, const __CFData *a3, const void **a4)
{
  CFIndex v7 = [a2 dataUsingEncoding:4];
  uint64_t v8 = [v7 length];
  CFIndex v9 = v8 + CFDataGetLength(a3) + 69;
  CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v9);
  if (Mutable)
  {
    qmemcpy(CFDataGetMutableBytePtr(Mutable), "com.apple.ProtectedCloudStorage.PCSKeyEnvelope.AesSivKeyFromMasterKey", 69);
    CFTypeID v11 = CFDataGetMutableBytePtr(Mutable) + 69;
    id v12 = v7;
    memcpy(v11, (const void *)[v12 bytes], objc_msgSend(v12, "length"));
    int MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    CFTypeID v14 = &MutableBytePtr[[v12 length] + 69];
    BytePtr = CFDataGetBytePtr(a3);
    size_t Length = CFDataGetLength(a3);
    memcpy(v14, BytePtr, Length);
    CFIndex v17 = CFDataCreateMutable(0, 0);
    CFDataSetLength(v17, 64);
    if (v17)
    {
      ccsha256_di();
      CFDataGetLength(a1);
      CFDataGetBytePtr(a1);
      CFDataGetLength(Mutable);
      CFDataGetBytePtr(Mutable);
      CFDataGetLength(v17);
      CFDataGetMutableBytePtr(v17);
      if (cchkdf())
      {
        CFRelease(v17);
        _PCSError(a4, 147, @"%s: HKDF failed", "CFMutableDataRef _PCSKEAesSivKeyFromMasterKey(CFDataRef, const NSString *__strong, CFDataRef, CFErrorRef *)");
        CFIndex v17 = 0;
      }
    }
    else
    {
      _PCSError(a4, 150, @"%s: could not allocate the key", "CFMutableDataRef _PCSKEAesSivKeyFromMasterKey(CFDataRef, const NSString *__strong, CFDataRef, CFErrorRef *)");
    }
    CFRelease(Mutable);
  }
  else
  {
    _PCSError(a4, 150, @"%s: could not allocate the context", "CFMutableDataRef _PCSKEAesSivKeyFromMasterKey(CFDataRef, const NSString *__strong, CFDataRef, CFErrorRef *)");
    CFIndex v17 = 0;
  }

  return v17;
}

__CFData *PCSKeyEnvelopeEncrypt(uint64_t a1, uint64_t a2, const __CFData *a3, CFTypeRef cf, const void **a5)
{
  if (!cf || (CFTypeID v10 = CFGetTypeID(cf), v10 != CFDataGetTypeID()))
  {
    _PCSError(a5, 126, @"%s: associatedData argument not CFData", "CFDataRef  _Nullable PCSKeyEnvelopeEncrypt(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    return 0;
  }
  CFDataRef v16 = (const __CFData *)_PCSKEExtractSeed(a1, a2, a5, v11, v12, v13, v14, v15);
  if (!v16) {
    return 0;
  }
  CFDataRef v17 = v16;
  uint64_t v18 = _PCSKEKeyFromSeed(v16, 68, (int)"com.apple.ProtectedCloudStorage.PCSKeyEnvelope.EncryptionKeyFromSeed", a5);
  if (!v18)
  {
    CFRelease(v17);
    return 0;
  }
  CFDataRef v19 = v18;
  CFIndex v20 = CFDataGetLength(a3) + 28;
  CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v20);
  if (Mutable)
  {
    int MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    __int16 v24 = MutableBytePtr + 12;
    char v25 = MutableBytePtr + 28;
    _PCSRandomData(0xCuLL, MutableBytePtr);
    ccaes_gcm_encrypt_mode();
    CFDataGetLength(v19);
    CFDataGetBytePtr(v19);
    CFDataGetLength((CFDataRef)cf);
    CFDataGetBytePtr((CFDataRef)cf);
    CFDataGetLength(a3);
    CFDataGetBytePtr(a3);
    if (ccgcm_one_shot())
    {
      CFRelease(Mutable);
      _PCSError(a5, 92, @"%s: AES-GCM failed", "CFDataRef  _Nullable PCSKeyEnvelopeEncrypt(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)", v25, 16, v24);
      CFMutableSetRef Mutable = 0;
    }
  }
  else
  {
    _PCSError(a5, 150, @"%s: could not allocate the ciphertext", "CFDataRef  _Nullable PCSKeyEnvelopeEncrypt(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
  }
  CFRelease(v17);
  CFRelease(v19);
  return Mutable;
}

__CFData *_PCSKEKeyFromSeed(const __CFData *a1, int a2, int a3, const void **a4)
{
  CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 32);
  if (Mutable)
  {
    CFIndex Length = CFDataGetLength(Mutable);
    int MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    if (!_PCSCreateDerivedKey(a1, a2, a3, Length, MutableBytePtr, a4))
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  else
  {
    _PCSError(a4, 150, @"%s: could not allocate the key", "CFDataRef _PCSKEKeyFromSeed(CFDataRef, CFIndex, size_t, const char *const, CFErrorRef *)");
  }
  return Mutable;
}

__CFData *PCSKeyEnvelopeDecrypt(uint64_t a1, uint64_t a2, const __CFData *a3, CFTypeRef cf, const void **a5)
{
  if (!cf || (CFTypeID v10 = CFGetTypeID(cf), v10 != CFDataGetTypeID()))
  {
    _PCSError(a5, 126, @"%s: associatedData argument not CFData", "CFDataRef  _Nullable PCSKeyEnvelopeDecrypt(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    return 0;
  }
  if ((unint64_t)CFDataGetLength(a3) <= 0x1B)
  {
    CFIndex Length = CFDataGetLength(a3);
    _PCSError(a5, 20, @"%s: encryptedData too short (length %u)", "CFDataRef  _Nullable PCSKeyEnvelopeDecrypt(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)", Length);
    return 0;
  }
  CFDataRef v17 = (const __CFData *)_PCSKEExtractSeed(a1, a2, a5, v11, v12, v13, v14, v15);
  if (!v17) {
    return 0;
  }
  CFDataRef v18 = v17;
  CFDataRef v19 = _PCSKEKeyFromSeed(v17, 68, (int)"com.apple.ProtectedCloudStorage.PCSKeyEnvelope.EncryptionKeyFromSeed", a5);
  if (v19)
  {
    CFDataRef v20 = v19;
    CFIndex v21 = CFDataGetLength(a3) - 28;
    CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, v21);
    if (Mutable)
    {
      CFDataRef v26 = a5;
      CFDataRef v22 = CFDataGetBytePtr(a3) + 12;
      ccaes_gcm_decrypt_mode();
      CFDataGetLength(v20);
      CFDataGetBytePtr(v20);
      CFDataGetLength((CFDataRef)cf);
      CFDataGetBytePtr((CFDataRef)cf);
      int MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      if (ccgcm_one_shot())
      {
        CFRelease(Mutable);
        _PCSError(v26, 149, @"%s: AES-GCM failed", "CFDataRef  _Nullable PCSKeyEnvelopeDecrypt(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)", MutableBytePtr, 16, v22);
        CFMutableSetRef Mutable = 0;
      }
    }
    else
    {
      _PCSError(a5, 150, @"%s: could not allocate data", "CFDataRef  _Nullable PCSKeyEnvelopeDecrypt(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    }
    CFRelease(v20);
  }
  else
  {
    CFMutableSetRef Mutable = 0;
  }
  CFRelease(v18);
  return Mutable;
}

__CFData *PCSKeyEnvelopeAuthenticate(uint64_t a1, uint64_t a2, CFTypeRef cf, const void **a4)
{
  if (!cf || (CFTypeID v8 = CFGetTypeID(cf), v8 != CFDataGetTypeID()))
  {
    _PCSError(a4, 126, @"%s: data argument not CFData", "CFDataRef  _Nonnull PCSKeyEnvelopeAuthenticate(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    return 0;
  }
  CFDataRef v14 = (const __CFData *)_PCSKEExtractSeed(a1, a2, a4, v9, v10, v11, v12, v13);
  if (!v14) {
    return 0;
  }
  CFDataRef v15 = v14;
  CFDataRef v16 = _PCSKEKeyFromSeed(v14, 72, (int)"com.apple.ProtectedCloudStorage.PCSKeyEnvelope.AuthenticationKeyFromSeed", a4);
  if (v16)
  {
    CFDataRef v17 = v16;
    CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, 32);
    if (Mutable)
    {
      ccsha256_di();
      CFDataGetLength(v17);
      CFDataGetBytePtr(v17);
      CFDataGetLength((CFDataRef)cf);
      CFDataGetBytePtr((CFDataRef)cf);
      CFDataGetMutableBytePtr(Mutable);
      cchmac();
    }
    else
    {
      _PCSError(a4, 150, @"%s: could not allocate the tag", "CFDataRef  _Nonnull PCSKeyEnvelopeAuthenticate(PCSShareProtectionRef _Nonnull, PCSKeyEnvelopeRef _Nonnull, CFDataRef _Nonnull, CFErrorRef * _Nullable)");
    }
    CFRelease(v17);
  }
  else
  {
    CFMutableSetRef Mutable = 0;
  }
  CFRelease(v15);
  return Mutable;
}

uint64_t PCSKeyEnvelopeVerify(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef cf, const void **a5)
{
  uint64_t v6 = PCSKeyEnvelopeAuthenticate(a1, a2, cf, a5);
  if (!v6) {
    return 0;
  }
  CFIndex v7 = v6;
  int v8 = CFEqual(v6, a3);
  uint64_t v9 = (uint64_t *)MEMORY[0x1E4F1CFC8];
  if (v8) {
    uint64_t v9 = (uint64_t *)MEMORY[0x1E4F1CFD0];
  }
  uint64_t v10 = *v9;
  CFRelease(v7);
  return v10;
}

__CFData *_PCSKEExtractSeedWithMasterKey(const __CFData *a1, const __CFData *a2, void *a3, const __CFData *a4, const void **a5)
{
  id v9 = a3;
  ccaes_siv_decrypt_mode();
  uint64_t v10 = _PCSKEAesSivKeyFromMasterKey(a1, v9, a4, a5);

  if (!v10)
  {
    _PCSError(a5, 150, @"%s: could not allocate the decryption key", "CFDataRef _PCSKEExtractSeedWithMasterKey(CFDataRef, CFDataRef, const NSString *__strong, CFDataRef, CFErrorRef *)");
    return 0;
  }
  CFDataGetLength(a2);
  if (ccsiv_plaintext_size() != 32)
  {
    _PCSError(a5, 20, @"%s: ciphertext is too short to recover the key material", "CFDataRef _PCSKEExtractSeedWithMasterKey(CFDataRef, CFDataRef, const NSString *__strong, CFDataRef, CFErrorRef *)");
LABEL_11:
    CFMutableSetRef Mutable = 0;
    goto LABEL_5;
  }
  CFMutableSetRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 32);
  if (!Mutable)
  {
    _PCSError(a5, 150, @"%s: could not allocate the seed", "CFDataRef _PCSKEExtractSeedWithMasterKey(CFDataRef, CFDataRef, const NSString *__strong, CFDataRef, CFErrorRef *)");
    goto LABEL_5;
  }
  CFDataGetLength(v10);
  CFDataGetBytePtr(v10);
  CFDataGetLength(a4);
  CFDataGetBytePtr(a4);
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  int MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (ccsiv_one_shot())
  {
    CFRelease(Mutable);
    _PCSError(a5, 13, @"%s: Unwrapping with AES-SIV failed", "CFDataRef _PCSKEExtractSeedWithMasterKey(CFDataRef, CFDataRef, const NSString *__strong, CFDataRef, CFErrorRef *)", MutableBytePtr);
    goto LABEL_11;
  }
LABEL_5:
  CFRelease(v10);
  return Mutable;
}

uint64_t apply_block_2_5(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

BOOL PCSManateeShareInvitationReadFrom(uint64_t a1, uint64_t a2)
{
  CFStringRef v3 = (int *)MEMORY[0x1E4F940E8];
  CFStringRef v4 = (int *)MEMORY[0x1E4F940E0];
  char v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    CFIndex v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 8;
LABEL_22:
        CFDataRef v19 = *(void **)(a1 + v18);
        *(void *)(a1 + v1_Block_object_dispose(&a9, 8) = v17;

        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_24:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v17 = PBReaderReadData();
    uint64_t v18 = 16;
    goto LABEL_22;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1ACFF7244(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF7418(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF7584(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF766C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF77CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF789C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF7A24(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF7AAC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF7C70(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF7DA8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF7E84(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF7FC4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF8298(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF83D0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF849C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1ACFF85F8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL PCSManateePrivateKeyReadFrom(uint64_t a1, uint64_t a2)
{
  CFStringRef v3 = (int *)MEMORY[0x1E4F940E8];
  CFStringRef v4 = (int *)MEMORY[0x1E4F940E0];
  char v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    CFIndex v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadData();
        uint64_t v18 = 8;
LABEL_22:
        CFDataRef v19 = *(void **)(a1 + v18);
        *(void *)(a1 + v1_Block_object_dispose(&a9, 8) = v17;

        goto LABEL_24;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_24:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v17 = PBReaderReadData();
    uint64_t v18 = 16;
    goto LABEL_22;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t free_PCSTypeValue(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSTypeValue, a1);
}

uint64_t decode_PCSAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSAttributes, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSAttributes, a1, a2, a3, a4);
}

uint64_t length_PCSAttributes(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSAttributes, a1);
}

uint64_t free_PCSAttributes(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSAttributes, a1);
}

uint64_t copy_PCSAttributes()
{
  return _asn1_copy_top();
}

uint64_t add_PCSAttributes(unsigned int *a1)
{
  CFAllocatorRef v2 = malloc_type_realloc(*((void **)a1 + 1), 24 * *a1 + 24, 0x1FFCFC4FuLL);
  if (!v2) {
    return 12;
  }
  *((void *)a1 + 1) = v2;
  uint64_t result = _asn1_copy_top();
  if (!result) {
    ++*a1;
  }
  return result;
}

uint64_t decode_PCSSignature(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSSignature, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSSignature(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSSignature, a1, a2, a3, a4);
}

uint64_t length_PCSSignature(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSSignature, a1);
}

uint64_t free_PCSSignature(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSSignature, a1);
}

uint64_t copy_PCSSignature()
{
  return _asn1_copy_top();
}

uint64_t decode_PCSBuildAndTime(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSBuildAndTime, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSBuildAndTime(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSBuildAndTime, a1, a2, a3, a4);
}

uint64_t length_PCSBuildAndTime(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSBuildAndTime, a1);
}

uint64_t free_PCSBuildAndTime(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSBuildAndTime, a1);
}

uint64_t decode_PCSMasterKeyIDs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSMasterKeyIDs, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSMasterKeyIDs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSMasterKeyIDs, a1, a2, a3, a4);
}

uint64_t length_PCSMasterKeyIDs(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSMasterKeyIDs, a1);
}

uint64_t free_PCSMasterKeyIDs(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSMasterKeyIDs, a1);
}

uint64_t decode_PCSManateeCircleFingerPrint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSManateeCircleFingerPrint, 0, a1, a2, a3, a4);
}

uint64_t free_PCSManateeCircleFingerPrint(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSManateeCircleFingerPrint, a1);
}

uint64_t decode_PCSManateeFlags(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSManateeFlags, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSManateeFlags(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSManateeFlags, a1, a2, a3, a4);
}

uint64_t length_PCSManateeFlags(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSManateeFlags, a1);
}

uint64_t free_PCSManateeFlags(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSManateeFlags, a1);
}

uint64_t encode_SignedAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_SignedAttributes, a1, a2, a3, a4);
}

uint64_t length_SignedAttributes(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_SignedAttributes, a1);
}

uint64_t decode_PCSPublicKeyInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSPublicKeyInfo, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSPublicKeyInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSPublicKeyInfo, a1, a2, a3, a4);
}

uint64_t length_PCSPublicKeyInfo(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSPublicKeyInfo, a1);
}

uint64_t free_PCSPublicKeyInfo(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSPublicKeyInfo, a1);
}

uint64_t copy_PCSPublicKeyInfo()
{
  return _asn1_copy_top();
}

uint64_t decode_PCSUserPublicKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSUserPublicKeys, 0, a1, a2, a3, a4);
}

uint64_t free_PCSUserPublicKeys(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSUserPublicKeys, a1);
}

uint64_t decode_PCSPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSPrivateKey, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSPrivateKey, a1, a2, a3, a4);
}

uint64_t length_PCSPrivateKey(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSPrivateKey, a1);
}

uint64_t free_PCSPrivateKey(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSPrivateKey, a1);
}

uint64_t add_PCSPrivateKeys(unsigned int *a1)
{
  CFAllocatorRef v2 = malloc_type_realloc(*((void **)a1 + 1), 24 * *a1 + 24, 0xA6356485uLL);
  if (!v2) {
    return 12;
  }
  *((void *)a1 + 1) = v2;
  uint64_t result = _asn1_copy_top();
  if (!result) {
    ++*a1;
  }
  return result;
}

uint64_t encode_PCSPrivateKeyProtoBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSPrivateKeyProtoBuf, a1, a2, a3, a4);
}

uint64_t length_PCSPrivateKeyProtoBuf(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSPrivateKeyProtoBuf, a1);
}

uint64_t decode_PCSPrivateKeyV2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSPrivateKeyV2, 0, a1, a2, a3, a4);
}

uint64_t free_PCSPrivateKeyV2(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSPrivateKeyV2, a1);
}

uint64_t decode_PCSKeySet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSKeySet, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSKeySet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSKeySet, a1, a2, a3, a4);
}

uint64_t length_PCSKeySet(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSKeySet, a1);
}

uint64_t free_PCSKeySet(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSKeySet, a1);
}

uint64_t decode_PCSBackupEscrow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSBackupEscrow, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSBackupEscrow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSBackupEscrow, a1, a2, a3, a4);
}

uint64_t length_PCSBackupEscrow(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSBackupEscrow, a1);
}

uint64_t free_PCSBackupEscrow(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSBackupEscrow, a1);
}

uint64_t decode_PCSBackupGuitarfishEscrow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSBackupGuitarfishEscrow, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSBackupGuitarfishEscrow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSBackupGuitarfishEscrow, a1, a2, a3, a4);
}

uint64_t length_PCSBackupGuitarfishEscrow(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSBackupGuitarfishEscrow, a1);
}

uint64_t free_PCSBackupGuitarfishEscrow(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSBackupGuitarfishEscrow, a1);
}

uint64_t decode_PCSBackupGuitarfishEscrowContents(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSBackupGuitarfishEscrowContents, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSBackupGuitarfishEscrowContents(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSBackupGuitarfishEscrowContents, a1, a2, a3, a4);
}

uint64_t length_PCSBackupGuitarfishEscrowContents(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSBackupGuitarfishEscrowContents, a1);
}

uint64_t free_PCSBackupGuitarfishEscrowContents(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSBackupGuitarfishEscrowContents, a1);
}

uint64_t decode_PCSSPKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSSPKey, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSSPKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSSPKey, a1, a2, a3, a4);
}

uint64_t length_PCSSPKey(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSSPKey, a1);
}

uint64_t free_PCSSPKey(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSSPKey, a1);
}

uint64_t decode_PCSSPKeyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSSPKeyList, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSSPKeyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSSPKeyList, a1, a2, a3, a4);
}

uint64_t length_PCSSPKeyList(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSSPKeyList, a1);
}

uint64_t free_PCSSPKeyList(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSSPKeyList, a1);
}

uint64_t copy_PCSSPKeyList()
{
  return _asn1_copy_top();
}

uint64_t add_PCSSPKeyList(unsigned int *a1)
{
  CFAllocatorRef v2 = malloc_type_realloc(*((void **)a1 + 1), 32 * *a1 + 32, 0xB8F3E3C4uLL);
  if (!v2) {
    return 12;
  }
  *((void *)a1 + 1) = v2;
  uint64_t result = _asn1_copy_top();
  if (!result) {
    ++*a1;
  }
  return result;
}

uint64_t decode_PCSEncryptedKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSEncryptedKeys, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSEncryptedKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSEncryptedKeys, a1, a2, a3, a4);
}

uint64_t length_PCSEncryptedKeys(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSEncryptedKeys, a1);
}

uint64_t free_PCSEncryptedKeys(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSEncryptedKeys, a1);
}

uint64_t encode_PCSSignedShareProtection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSSignedShareProtection, a1, a2, a3, a4);
}

uint64_t length_PCSSignedShareProtection(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSSignedShareProtection, a1);
}

uint64_t decode_PCSObjectSignature(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSObjectSignature, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSObjectSignature(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSObjectSignature, a1, a2, a3, a4);
}

uint64_t length_PCSObjectSignature(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSObjectSignature, a1);
}

uint64_t free_PCSObjectSignature(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSObjectSignature, a1);
}

uint64_t decode_PCSShareProtection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSShareProtection, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSShareProtection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSShareProtection, a1, a2, a3, a4);
}

uint64_t length_PCSShareProtection(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSShareProtection, a1);
}

uint64_t free_PCSShareProtection(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSShareProtection, a1);
}

uint64_t decode_PCSObjectChaining(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F688](&asn1_PCSObjectChaining, 0, a1, a2, a3, a4);
}

uint64_t encode_PCSObjectChaining(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F417F690](&asn1_PCSObjectChaining, a1, a2, a3, a4);
}

uint64_t length_PCSObjectChaining(uint64_t a1)
{
  return MEMORY[0x1F417F6A0](&asn1_PCSObjectChaining, a1);
}

uint64_t free_PCSObjectChaining(uint64_t a1)
{
  return MEMORY[0x1F417F698](&asn1_PCSObjectChaining, a1);
}

uint64_t get_aks_client_connection()
{
  if (get_aks_client_dispatch_queue_onceToken != -1) {
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_173);
  }
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_152);
  uint64_t result = get_aks_client_connection_connection;
  if (!get_aks_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return get_aks_client_connection_connection;
  }
  return result;
}

void __get_aks_client_connection_block_invoke()
{
  if (!get_aks_client_connection_connection) {
    get_aks_client_connection_connection = _copy_aks_client_connection("IOService:/IOResources/AppleKeyStore", "AppleKeyStore");
  }
}

dispatch_queue_t __get_aks_client_dispatch_queue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("aks-client-queue", 0);
  get_aks_client_dispatch_queue_connection_queue = (uint64_t)result;
  return result;
}

uint64_t _copy_aks_client_connection(char *path, const char *a2)
{
  kern_return_t v7;
  CFDictionaryRef v8;
  io_service_t MatchingService;
  io_object_t v10;
  uint64_t result;
  kern_return_t v12;
  io_connect_t connect;

  connect = 0;
  mach_port_t v3 = *MEMORY[0x1E4F2EF00];
  io_service_t v4 = IORegistryEntryFromPath(*MEMORY[0x1E4F2EF00], path);
  char v5 = (task_port_t *)MEMORY[0x1E4F14960];
  if (!v4 || (v6 = v4, CFIndex v7 = IOServiceOpen(v4, *MEMORY[0x1E4F14960], 0, &connect), IOObjectRelease(v6), v7))
  {
    char v8 = IOServiceMatching(a2);
    MatchingService = IOServiceGetMatchingService(v3, v8);
    if (MatchingService)
    {
      unint64_t v10 = MatchingService;
      IOServiceOpen(MatchingService, *v5, 0, &connect);
      IOObjectRelease(v10);
    }
  }
  dispatch_queue_t result = connect;
  if (connect)
  {
    unint64_t v12 = IOConnectCallMethod(connect, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    dispatch_queue_t result = connect;
    if (v12)
    {
      IOServiceClose(connect);
      return 0;
    }
  }
  return result;
}

uint64_t aks_assert_hold(int a1, unsigned int a2, uint64_t a3)
{
  input[3] = *MEMORY[0x1E4F143B8];
  input[0] = a2;
  input[1] = a3;
  input[2] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x1Au, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x1E4F143D8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_hold", ":", 1654, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_assert_drop(int a1, unsigned int a2)
{
  input[2] = *MEMORY[0x1E4F143B8];
  input[0] = a2;
  input[1] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x1Bu, input, 2u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x1E4F143D8], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_drop", ":", 1672, "", 0, "", "");
  return 3758097084;
}

void PEMStateInData_cold_1(const void *a1)
{
  if (a1) {
    CFRelease(a1);
  }
  abort();
}

void __getLSApplicationWorkspaceClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  PCSFPCopyUnwrappedKey_cold_1(v0);
}

void PCSFPCopyUnwrappedKey_cold_1()
{
  __assert_rtn("PCSFPCopyUnwrappedKey", "PCSEncryption.c", 85, "obytes == (size_t)CFDataGetLength(unwrappedKey)");
}

void PCSFPCopyWrappedKey_cold_1()
{
  __assert_rtn("PCSFPCopyWrappedKey", "PCSEncryption.c", 120, "obytes == (size_t)CFDataGetLength(wrappedKey)");
}

void __PCSCreateSecureBackupContext_cold_1(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_1ACF98000, log, OS_LOG_TYPE_ERROR, "incomplete password metatadata", v1, 2u);
}

void __PCSCopyHSMData_cold_1(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v3 = 138412546;
  uint64_t v4 = a1;
  __int16 v5 = 2112;
  uint64_t v6 = a2;
  _os_log_error_impl(&dword_1ACF98000, log, OS_LOG_TYPE_ERROR, "Not attempting recovery because input (%@) password generation does not match the record (%@) password generation", (uint8_t *)&v3, 0x16u);
}

void _PCSKeyAllocateDiversizedKey_cold_1()
{
}

void SetKeyID_cold_1()
{
  __assert_rtn("SetKeyID", "CloudIdentity.m", 1144, "key->keyid == NULL");
}

void __PCSIdentityCopyExternalForm_block_invoke_cold_1()
{
}

void PCSPublicIdentityGetService_cold_1()
{
  __assert_rtn("PCSPublicIdentityGetService", "CloudIdentity.m", 3452, "PCSPublicIdentityGetTypeID() == CFGetTypeID(si)");
}

void addNameService_cold_1()
{
}

void addNameService_cold_2()
{
}

void addPublicNameService_cold_1()
{
}

void addPublicNameService_cold_2()
{
}

void __getACAccountStoreClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  __getUMUserManagerClass_block_invoke_cold_1(v0);
}

void __getUMUserManagerClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  __getAKAccountManagerClass_block_invoke_cold_1(v0);
}

void __getAKAccountManagerClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  _CreateLightPCSObject_cold_1(v0);
}

void _CreateLightPCSObject_cold_1()
{
  __assert_rtn("_CreateLightPCSObject", "PCSShareProtection.m", 1568, "obytes == wrappedKeySize");
}

void __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_3_cold_1()
{
  *(_WORD *)uint64_t v0 = 0;
  _os_log_error_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CKKS initial sync has completed, rejecting OOB fetch", v0, 2u);
}

void __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_3_cold_2(uint64_t a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  int v1 = 138412290;
  uint64_t v2 = a1;
  _os_log_error_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "OOB fetch failed: %@", (uint8_t *)&v1, 0xCu);
}

void __PCSObjectCreateFromExportedWithIdentitiesAndOptionsAsync_block_invoke_3_cold_3(uint64_t *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *a1;
  int v2 = 138412290;
  uint64_t v3 = v1;
  _os_log_error_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Creating PCS object with OOB identities failed: %@", (uint8_t *)&v2, 0xCu);
}

void deriveHKDF_cold_1(int a1)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v1[0] = 67109120;
  v1[1] = a1;
  _os_log_error_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CCDeriveKey failed: %d", (uint8_t *)v1, 8u);
}

void deriveHKDF_cold_2(int a1)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  v1[0] = 67109120;
  v1[1] = a1;
  _os_log_error_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "CCKDFParametersCreateHkdf failed: %d", (uint8_t *)v1, 8u);
}

void KeychainCopyCurrentIdentity_cold_1(uint64_t *a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *a1;
  int v2 = 138412290;
  uint64_t v3 = v1;
  _os_log_error_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Failed to get W state: %@", (uint8_t *)&v2, 0xCu);
}

uint64_t __getCDPFollowUpContextClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  return __getCDPFollowUpControllerClass_block_invoke_cold_1(v0);
}

uint64_t __getCDPFollowUpControllerClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  return PCSEngineExtractKeys_cold_1(v0);
}

void PCSEngineExtractKeys_cold_1()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "Error unwrapping keys: %@", v2, v3, v4, v5, v6);
}

void PCSEngineStoreRTHSM_cold_1()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "error deriving p_token from p_recovery and mnemonic: %@", v2, v3, v4, v5, v6);
}

void PCSEngineStoreRTHSM_cold_2()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "RT Record PID does not match primary! deleting it so it can be recreated", v2, v3, v4, v5, v6);
}

void IsLocalStoringService_cold_1()
{
}

void fail_and_cfu_if_no_password_cold_1()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "could not perform operation due to insufficient information, failed to post CFU: %@", v2, v3, v4, v5, v6);
}

void applyOptions_cold_1()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "incomplete password metatadata", v2, v3, v4, v5, v6);
}

void __PCSEngineStoreRTHSM_block_invoke_cold_1()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "unable to derive pid", v2, v3, v4, v5, v6);
}

void PCSCacheCurrentIdentitiesForServices_cold_1(uint8_t *buf, uint64_t a2, void *a3)
{
  *(_DWORD *)long long buf = 138412290;
  *a3 = a2;
  _os_log_error_impl(&dword_1ACF98000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Unable to determine accessgroup and/or viewhint for service %@", buf, 0xCu);
}

void _PCSGuitarfishGetKeychainItem_cold_1()
{
  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_6(&dword_1ACF98000, MEMORY[0x1E4F14500], v0, "Get: Missing Keychain Item for %@: %d", v1, v2, v3, v4, v5);
}

void _PCSGuitarfishSetKeychainItem_cold_1()
{
  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_6(&dword_1ACF98000, MEMORY[0x1E4F14500], v0, "Set: Failed to store in keychain %@: %d", v1, v2, v3, v4, v5);
}

void _PCSGuitarfishSetKeychainItem_cold_2()
{
  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_6(&dword_1ACF98000, MEMORY[0x1E4F14500], v0, "Set: Missing Keychain Item for %@: %d", v1, v2, v3, v4, v5);
}

void PCSGuitarfishResetProtectedData_cold_1()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "Missing kPCSAuthenticateAppleID, returning", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_2()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "Missing kPCSSetupPassword, returning", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_3()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "Missing kPCSSetupRawPassword, returning", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_4()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "Missing kPCSAltDSID, returning", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_5()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "Missing kPCSSetupPasswordGeneration, returning", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_6()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "Missing kPCSSetupVerifierIterationCount, returning", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_7()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "Missing kPCSSetupVerifierProtocol, returning", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_8()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "Missing kPCSSetupVerifierSalt, returning", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_9()
{
  OUTLINED_FUNCTION_5(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "Failed to create identity set: %@", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_10(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void PCSGuitarfishResetProtectedData_cold_11(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void PCSGuitarfishResetProtectedData_cold_12()
{
  OUTLINED_FUNCTION_5(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "Failed to delete Recovery Token record: %@", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_13()
{
  OUTLINED_FUNCTION_5(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "Failed to delete Guitarfish record: %@", v2, v3, v4, v5, v6);
}

void PCSGuitarfishResetProtectedData_cold_14(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void performStingrayRecovery_cold_1()
{
  OUTLINED_FUNCTION_5(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "Failed to perform stingray recovery: %@", v2, v3, v4, v5, v6);
}

void performStingrayRecovery_cold_2()
{
  OUTLINED_FUNCTION_5(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "Failed to store classic content in iCloud Keychain: %@", v2, v3, v4, v5, v6);
}

void performStingrayRecovery_cold_3()
{
  OUTLINED_FUNCTION_5(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "Failed to store classic content in the keychain: %@", v2, v3, v4, v5, v6);
}

void PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken_cold_2()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_2(&dword_1ACF98000, v0, v1, "PCSGuitarfishSetupIdentities failed to return a recovery token", v2, v3, v4, v5, v6);
}

void PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken_cold_3()
{
  OUTLINED_FUNCTION_5(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "Failed to fetch w status: %@", v2, v3, v4, v5, v6);
}

void PCSGuitarfishSetupIdentitiesAndReturnRecoveryToken_cold_4()
{
  OUTLINED_FUNCTION_5(*MEMORY[0x1E4F143B8]);
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_0(&dword_1ACF98000, v0, v1, "PCSGuitarfishSetupIdentities failed with error: %@", v2, v3, v4, v5, v6);
}

void _PCSGuitarfishDeleteKeychainItem_cold_1()
{
  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_6(&dword_1ACF98000, MEMORY[0x1E4F14500], v0, "Delete: Unable to delete item from keychain %@: %d", v1, v2, v3, v4, v5);
}

void PCSGuitarfishRepairIdentities_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(*(void *)a1 + 40);
  int v3 = 138412290;
  uint64_t v4 = v2;
  _os_log_error_impl(&dword_1ACF98000, a2, OS_LOG_TYPE_ERROR, "Existing stashed wrappingKey is not valid for the current record. p_password or p_token recover is needed: %@", (uint8_t *)&v3, 0xCu);
}

uint64_t __getAAFAnalyticsTransportRTCClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  return __getAAFAnalyticsReporterClass_block_invoke_cold_1(v0);
}

uint64_t __getAAFAnalyticsReporterClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  return __48__AAFAnalyticsEventPCS_isAAAFoundationAvailable__block_invoke_cold_1(v0);
}

void __getAAFAnalyticsEventClass_block_invoke_cold_1()
{
  uint64_t v0 = abort_report_np();
  PCSCopyWrappedKey_cold_1(v0);
}

void PCSCopyWrappedKey_cold_1()
{
  __assert_rtn("PCSCopyWrappedKey", "KeyWrapper.c", 43, "obytes == (size_t)CFDataGetLength(wrappedKey)");
}

void PCSCopyUnwrappedKey_cold_1()
{
  __assert_rtn("PCSCopyUnwrappedKey", "KeyWrapper.c", 74, "obytes == (size_t)CFDataGetLength(unwrappedKey)");
}

uint64_t CCDeriveKey()
{
  return MEMORY[0x1F40C9540]();
}

uint64_t CCKDFParametersCreateHkdf()
{
  return MEMORY[0x1F40C9630]();
}

uint64_t CCKDFParametersDestroy()
{
  return MEMORY[0x1F40C9638]();
}

int CCKeyDerivationPBKDF(CCPBKDFAlgorithm algorithm, const char *password, size_t passwordLen, const uint8_t *salt, size_t saltLen, CCPseudoRandomAlgorithm prf, unsigned int rounds, uint8_t *derivedKey, size_t derivedKeyLen)
{
  return MEMORY[0x1F40C9648](*(void *)&algorithm, password, passwordLen, salt, saltLen, *(void *)&prf, *(void *)&rounds, derivedKey);
}

int CCSymmetricKeyUnwrap(CCWrappingAlgorithm algorithm, const uint8_t *iv, const size_t ivLen, const uint8_t *kek, size_t kekLen, const uint8_t *wrappedKey, size_t wrappedKeyLen, uint8_t *rawKey, size_t *rawKeyLen)
{
  return MEMORY[0x1F40C96D0](*(void *)&algorithm, iv, ivLen, kek, kekLen, wrappedKey, wrappedKeyLen, rawKey);
}

int CCSymmetricKeyWrap(CCWrappingAlgorithm algorithm, const uint8_t *iv, const size_t ivLen, const uint8_t *kek, size_t kekLen, const uint8_t *rawKey, size_t rawKeyLen, uint8_t *wrappedKey, size_t *wrappedKeyLen)
{
  return MEMORY[0x1F40C96D8](*(void *)&algorithm, iv, ivLen, kek, kekLen, rawKey, rawKeyLen, wrappedKey);
}

size_t CCSymmetricUnwrappedSize(CCWrappingAlgorithm algorithm, size_t wrappedKeyLen)
{
  return MEMORY[0x1F40C96E0](*(void *)&algorithm, wrappedKeyLen);
}

size_t CCSymmetricWrappedSize(CCWrappingAlgorithm algorithm, size_t rawKeyLen)
{
  return MEMORY[0x1F40C96E8](*(void *)&algorithm, rawKeyLen);
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1F40C9770](data, *(void *)&len, md);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D7160](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1F40D7178](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1F40D71C8](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

uint64_t CFCopyHomeDirectoryURLForUser()
{
  return MEMORY[0x1F40D77B8]();
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1F40D77F8](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7808](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x1F40D7810](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

CFRange CFDataFind(CFDataRef theData, CFDataRef dataToFind, CFRange searchRange, CFDataSearchFlags compareOptions)
{
  CFIndex v4 = MEMORY[0x1F40D7828](theData, dataToFind, searchRange.location, searchRange.length, compareOptions);
  result.CFIndex length = v5;
  result.CFIndex location = v4;
  return result;
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1F40D7858](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return MEMORY[0x1F40D7888](theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1F40D7898](allocator, at);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x1F40D78B0](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return (CFStringRef)MEMORY[0x1F40D78E0](allocator, formatter, date);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1F40D7938]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1F40D7A98](allocator, domain, code, userInfo);
}

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  return (CFErrorRef)MEMORY[0x1F40D7AA0](allocator, domain, code, userInfoKeys, userInfoValues, numUserInfoValues);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1F40D7AA8](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1F40D7AB8](err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BB8]();
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D08]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1F40D7E90](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F58](allocator, stream, streamLength, options, format, error);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FC0](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1F40D8000](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B0]();
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

void CFStringAppendFormatAndArguments(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1F40D83E0](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1F40D83F8](alloc, theString, *(void *)&encoding, lossByte);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8400](alloc, data, *(void *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8458](alloc, cStr, *(void *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1F40D8498](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.CFIndex length = v4;
  result.CFIndex location = v3;
  return result;
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8798](url);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D87F8](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLEnumeratorRef CFURLEnumeratorCreateForDirectoryURL(CFAllocatorRef alloc, CFURLRef directoryURL, CFURLEnumeratorOptions option, CFArrayRef propertyKeys)
{
  return (CFURLEnumeratorRef)MEMORY[0x1F40D88C8](alloc, directoryURL, option, propertyKeys);
}

CFURLEnumeratorResult CFURLEnumeratorGetNextURL(CFURLEnumeratorRef enumerator, CFURLRef *url, CFErrorRef *error)
{
  return MEMORY[0x1F40D88E0](enumerator, url, error);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x1F40D8A28](allocator, flags, error, dictionary, timeout);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x1F40D8A40](allocator, userNotification, callout, order);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x1F40E86C8](*(void *)&connection, *(void *)&selector, input, *(void *)&inputCnt, inputStruct, inputStructCnt, output, outputCnt);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1F40E8F60](*(void *)&object);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return MEMORY[0x1F40E9188](*(void *)&mainPort, path);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x1F40E9240](*(void *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x1F40E9250](*(void *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40E9268](name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return MEMORY[0x1F40E9280](*(void *)&service, *(void *)&owningTask, *(void *)&type, connect);
}

uint64_t MKBUserTypeDeviceMode()
{
  return MEMORY[0x1F412FA18]();
}

void NSLog(NSString *format, ...)
{
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x1F40E7248](directory, domainMask, expandTilde);
}

uint64_t PBDataWriterWriteDataField()
{
  return MEMORY[0x1F41471B0]();
}

uint64_t PBDataWriterWriteInt32Field()
{
  return MEMORY[0x1F41471E0]();
}

uint64_t PBDataWriterWriteSubmessage()
{
  return MEMORY[0x1F4147230]();
}

uint64_t PBReaderPlaceMark()
{
  return MEMORY[0x1F4147268]();
}

uint64_t PBReaderReadData()
{
  return MEMORY[0x1F4147278]();
}

uint64_t PBReaderRecallMark()
{
  return MEMORY[0x1F41472A0]();
}

uint64_t PBReaderSkipValueWithTag()
{
  return MEMORY[0x1F41472A8]();
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return MEMORY[0x1F40F6DD8](attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return MEMORY[0x1F40F6DE0](query, result);
}

uint64_t SecItemFetchCurrentItemAcrossAllDevices()
{
  return MEMORY[0x1F40F6DF8]();
}

uint64_t SecItemFetchCurrentItemOutOfBand()
{
  return MEMORY[0x1F40F6E00]();
}

uint64_t SecItemFetchPCSIdentityOutOfBand()
{
  return MEMORY[0x1F40F6E08]();
}

uint64_t SecItemSetCurrentItemAcrossAllDevices()
{
  return MEMORY[0x1F40F6E10]();
}

OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate)
{
  return MEMORY[0x1F40F6E20](query, attributesToUpdate);
}

CFDataRef SecKeyCopyExternalRepresentation(SecKeyRef key, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40F6E40](key, error);
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return MEMORY[0x1F40F70F0](rnd, count, bytes);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1F40F7138](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1F40F7160](allocator);
}

SecKeyRef SecTrustCopyKey(SecTrustRef trust)
{
  return (SecKeyRef)MEMORY[0x1F40F71B8](trust);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFCopySystemVersionDictionary()
{
  return MEMORY[0x1F40D8D10]();
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1F40C9CD8]();
}

uint64_t _asn1_copy_top()
{
  return MEMORY[0x1F417F680]();
}

os_activity_t _os_activity_create(void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1F40C9F70](dso, description, activity, *(void *)&flags);
}

uint64_t _os_assert_log()
{
  return MEMORY[0x1F40C9F90]();
}

uint64_t _os_crash()
{
  return MEMORY[0x1F40C9FA0]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

void abort(void)
{
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1F40CA3C0](*(void *)&__upper_bound);
}

uint64_t asn1_abort()
{
  return MEMORY[0x1F417F6A8]();
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1F40CA440](a1, a2);
}

void bzero(void *a1, size_t a2)
{
}

uint64_t ccDRBGGetRngState()
{
  return MEMORY[0x1F40CA698]();
}

uint64_t cc_clear()
{
  return MEMORY[0x1F40CA6A0]();
}

uint64_t cc_cmp_safe()
{
  return MEMORY[0x1F40CA6A8]();
}

uint64_t ccaes_ecb_decrypt_mode()
{
  return MEMORY[0x1F40CA6D8]();
}

uint64_t ccaes_ecb_encrypt_mode()
{
  return MEMORY[0x1F40CA6E0]();
}

uint64_t ccaes_gcm_decrypt_mode()
{
  return MEMORY[0x1F40CA6E8]();
}

uint64_t ccaes_gcm_encrypt_mode()
{
  return MEMORY[0x1F40CA6F0]();
}

uint64_t ccaes_siv_decrypt_mode()
{
  return MEMORY[0x1F40CA6F8]();
}

uint64_t ccaes_siv_encrypt_mode()
{
  return MEMORY[0x1F40CA700]();
}

uint64_t ccder_decode_constructed_tl()
{
  return MEMORY[0x1F40CA888]();
}

uint64_t ccder_decode_tl()
{
  return MEMORY[0x1F40CA8C8]();
}

uint64_t ccder_encode_eckey()
{
  return MEMORY[0x1F40CA8F0]();
}

uint64_t ccder_encode_eckey_size()
{
  return MEMORY[0x1F40CA8F8]();
}

uint64_t ccdigest()
{
  return MEMORY[0x1F40CA9B0]();
}

uint64_t ccdigest_init()
{
  return MEMORY[0x1F40CA9B8]();
}

uint64_t ccdigest_update()
{
  return MEMORY[0x1F40CA9C0]();
}

uint64_t ccec_compact_export()
{
  return MEMORY[0x1F40CA9D0]();
}

uint64_t ccec_compact_generate_key()
{
  return MEMORY[0x1F40CA9E0]();
}

uint64_t ccec_compact_import_priv()
{
  return MEMORY[0x1F40CA9E8]();
}

uint64_t ccec_compact_import_priv_size()
{
  return MEMORY[0x1F40CA9F0]();
}

uint64_t ccec_compact_import_pub()
{
  return MEMORY[0x1F40CA9F8]();
}

uint64_t ccec_compact_import_pub_size()
{
  return MEMORY[0x1F40CAA00]();
}

uint64_t ccec_compact_transform_key()
{
  return MEMORY[0x1F40CAA08]();
}

uint64_t ccec_cp_192()
{
  return MEMORY[0x1F40CAA30]();
}

uint64_t ccec_cp_224()
{
  return MEMORY[0x1F40CAA38]();
}

uint64_t ccec_cp_256()
{
  return MEMORY[0x1F40CAA40]();
}

uint64_t ccec_cp_384()
{
  return MEMORY[0x1F40CAA48]();
}

uint64_t ccec_cp_521()
{
  return MEMORY[0x1F40CAA50]();
}

uint64_t ccec_curve_for_length_lookup()
{
  return MEMORY[0x1F40CAA58]();
}

uint64_t ccec_der_export_diversified_pub()
{
  return MEMORY[0x1F40CAA60]();
}

uint64_t ccec_der_export_diversified_pub_size()
{
  return MEMORY[0x1F40CAA68]();
}

uint64_t ccec_der_export_priv()
{
  return MEMORY[0x1F40CAA70]();
}

uint64_t ccec_der_export_priv_size()
{
  return MEMORY[0x1F40CAA78]();
}

uint64_t ccec_der_import_diversified_pub()
{
  return MEMORY[0x1F40CAA80]();
}

uint64_t ccec_der_import_priv()
{
  return MEMORY[0x1F40CAA88]();
}

uint64_t ccec_der_import_priv_keytype()
{
  return MEMORY[0x1F40CAA90]();
}

uint64_t ccec_diversify_min_entropy_len()
{
  return MEMORY[0x1F40CAA98]();
}

uint64_t ccec_diversify_pub()
{
  return MEMORY[0x1F40CAAA8]();
}

uint64_t ccec_export_pub()
{
  return MEMORY[0x1F40CAAB8]();
}

uint64_t ccec_generate_key_deterministic()
{
  return MEMORY[0x1F40CAAD8]();
}

uint64_t ccec_generate_key_fips()
{
  return MEMORY[0x1F40CAAE0]();
}

uint64_t ccec_generate_key_legacy()
{
  return MEMORY[0x1F40CAAE8]();
}

uint64_t ccec_get_cp()
{
  return MEMORY[0x1F40CAAF8]();
}

uint64_t ccec_import_pub()
{
  return MEMORY[0x1F40CAB00]();
}

uint64_t ccec_keysize_is_supported()
{
  return MEMORY[0x1F40CAB08]();
}

uint64_t ccec_pairwise_consistency_check()
{
  return MEMORY[0x1F40CAB18]();
}

uint64_t ccec_rfc6637_unwrap_key()
{
  return MEMORY[0x1F40CAB38]();
}

uint64_t ccec_rfc6637_wrap_key()
{
  return MEMORY[0x1F40CAB40]();
}

uint64_t ccec_rfc6637_wrap_key_diversified()
{
  return MEMORY[0x1F40CAB48]();
}

uint64_t ccec_rfc6637_wrap_key_size()
{
  return MEMORY[0x1F40CAB50]();
}

uint64_t ccec_sign()
{
  return MEMORY[0x1F40CAB58]();
}

uint64_t ccec_verify()
{
  return MEMORY[0x1F40CAB78]();
}

uint64_t ccec_x963_import_pub_size()
{
  return MEMORY[0x1F40CABB0]();
}

uint64_t ccecb_context_size()
{
  return MEMORY[0x1F40CABB8]();
}

uint64_t ccecb_init()
{
  return MEMORY[0x1F40CABC0]();
}

uint64_t ccecdh_compute_shared_secret()
{
  return MEMORY[0x1F40CABD0]();
}

uint64_t ccgcm_aad()
{
  return MEMORY[0x1F40CAC78]();
}

uint64_t ccgcm_context_size()
{
  return MEMORY[0x1F40CAC80]();
}

uint64_t ccgcm_finalize()
{
  return MEMORY[0x1F40CAC88]();
}

uint64_t ccgcm_init()
{
  return MEMORY[0x1F40CAC98]();
}

uint64_t ccgcm_one_shot()
{
  return MEMORY[0x1F40CACA8]();
}

uint64_t ccgcm_set_iv()
{
  return MEMORY[0x1F40CACB8]();
}

uint64_t ccgcm_update()
{
  return MEMORY[0x1F40CACC0]();
}

uint64_t cchkdf()
{
  return MEMORY[0x1F40CAE28]();
}

uint64_t cchmac()
{
  return MEMORY[0x1F40CAE40]();
}

uint64_t cchmac_final()
{
  return MEMORY[0x1F40CAE48]();
}

uint64_t cchmac_init()
{
  return MEMORY[0x1F40CAE50]();
}

uint64_t cchmac_update()
{
  return MEMORY[0x1F40CAE58]();
}

uint64_t ccn_cmp()
{
  return MEMORY[0x1F40CAFA0]();
}

uint64_t ccn_read_uint()
{
  return MEMORY[0x1F40CAFB0]();
}

uint64_t ccn_write_uint_padded()
{
  return MEMORY[0x1F40CAFE0]();
}

uint64_t ccnistkdf_ctr_hmac()
{
  return MEMORY[0x1F40CB000]();
}

uint64_t ccrng_pbkdf2_prng_init()
{
  return MEMORY[0x1F40CB040]();
}

uint64_t ccsha1_di()
{
  return MEMORY[0x1F40CB138]();
}

uint64_t ccsha256_di()
{
  return MEMORY[0x1F40CB148]();
}

uint64_t ccsha512_di()
{
  return MEMORY[0x1F40CB158]();
}

uint64_t ccsiv_aad()
{
  return MEMORY[0x1F40CB168]();
}

uint64_t ccsiv_ciphertext_size()
{
  return MEMORY[0x1F40CB170]();
}

uint64_t ccsiv_crypt()
{
  return MEMORY[0x1F40CB178]();
}

uint64_t ccsiv_init()
{
  return MEMORY[0x1F40CB180]();
}

uint64_t ccsiv_one_shot()
{
  return MEMORY[0x1F40CB188]();
}

uint64_t ccsiv_plaintext_size()
{
  return MEMORY[0x1F40CB190]();
}

uint64_t ccsiv_set_nonce()
{
  return MEMORY[0x1F40CB198]();
}

uint64_t ccwrap_auth_decrypt()
{
  return MEMORY[0x1F40CB308]();
}

uint64_t ccwrap_auth_encrypt()
{
  return MEMORY[0x1F40CB310]();
}

uint64_t ccwrap_unwrapped_size()
{
  return MEMORY[0x1F40CB318]();
}

uint64_t ccwrap_wrapped_size()
{
  return MEMORY[0x1F40CB320]();
}

uint64_t cczp_bitlen()
{
  return MEMORY[0x1F40CB330]();
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C0](flags, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA8](attr, frequency);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1F40CC1E8](*(void *)&a1, a2);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1F40CC2F0](*(void *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1F40CC338](__ptr, __size, __nitems, __stream);
}

int glob(const char *a1, int a2, int (__cdecl *a3)(const char *, int), glob_t *a4)
{
  return MEMORY[0x1F40CC598](a1, *(void *)&a2, a3, a4);
}

void globfree(glob_t *a1)
{
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1F40CC5B0](a1, a2);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1F40CC870](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x1F40CCD40](__s, __smax, *(void *)&__c, __n);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1F40CD050](name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1F4181680](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1F4181758](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C0](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1F41818D0](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1F4181A28](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1F4181A30](obj);
}

void objc_terminate(void)
{
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

void os_release(void *object)
{
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1F40CD5A0]();
}

uint64_t os_transaction_needs_more_time()
{
  return MEMORY[0x1F40CD5B0]();
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1F40CD5E8]();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_allows_internal_security_policies()
{
  return MEMORY[0x1F40CD630]();
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1F40CD838](a1);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int removefile(const char *path, removefile_state_t state, removefile_flags_t flags)
{
  return MEMORY[0x1F40CDD18](path, state, *(void *)&flags);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1F40CE078](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181F90](a1, *(void *)&a2, a3, *(void *)&n, a5);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return MEMORY[0x1F4181FB0](a1, *(void *)&a2, *(void *)&a3);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181FE8](a1, *(void *)&a2, a3, *(void *)&a4, a5);
}

int sqlite3_close(sqlite3 *a1)
{
  return MEMORY[0x1F4182060](a1);
}

const void *__cdecl sqlite3_column_blob(sqlite3_stmt *a1, int iCol)
{
  return (const void *)MEMORY[0x1F4182070](a1, *(void *)&iCol);
}

int sqlite3_column_bytes(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1F4182078](a1, *(void *)&iCol);
}

const unsigned __int8 *__cdecl sqlite3_column_text(sqlite3_stmt *a1, int iCol)
{
  return (const unsigned __int8 *)MEMORY[0x1F41820C8](a1, *(void *)&iCol);
}

const char *__cdecl sqlite3_errmsg(sqlite3 *a1)
{
  return (const char *)MEMORY[0x1F4182198](a1);
}

int sqlite3_exec(sqlite3 *a1, const char *sql, int (__cdecl *callback)(void *, int, char **, char **), void *a4, char **errmsg)
{
  return MEMORY[0x1F41821A8](a1, sql, callback, a4, errmsg);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1F41821D8](pStmt);
}

void sqlite3_free(void *a1)
{
}

int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs)
{
  return MEMORY[0x1F4182280](filename, ppDb, *(void *)&flags, zVfs);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return MEMORY[0x1F4182290](db, zSql, *(void *)&nByte, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1F41822C0](pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return MEMORY[0x1F41823B0](a1);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1F40CE178](__s1);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x1F40CE198](a1, a2, a3, a4);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

void syslog(int a1, const char *a2, ...)
{
}

time_t time(time_t *a1)
{
  return MEMORY[0x1F40CE588](a1);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x1F40CE680](a1, a2, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}