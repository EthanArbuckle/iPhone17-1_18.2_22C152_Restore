void *__copy_helper_block_ea8_32c43_ZTSKNSt3__18weak_ptrIN2as12WorkloopPoolEEE48c60_ZTSNSt3__110shared_ptrIN2as12WorkloopPool13WorkloopStateEEE(void *result, void *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

BOOL FormatNSErrorForReturn(int a1, void *a2)
{
  return FormatNSErrorForReturn(a1, 0, a2);
}

uint64_t as::IsStandardMXNotificationName(as *this, NSString *a2)
{
  v2 = this;
  MXNotificationNames = as::GetMXNotificationNames(v2);
  v4 = v2;
  uint64_t v5 = *((void *)MXNotificationNames + 1);
  if (*(void *)MXNotificationNames == v5)
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v6 = *(void *)MXNotificationNames + 8;
    do
    {
      uint64_t v7 = [(as *)v4 isEqualToString:*(void *)(v6 - 8)];
      uint64_t v8 = v7;
      if (v6 == v5) {
        char v9 = 1;
      }
      else {
        char v9 = v7;
      }
      v6 += 8;
    }
    while ((v9 & 1) == 0);
  }

  return v8;
}

void sub_210AAFF98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

long long *as::GetMXNotificationNames(as *this)
{
  {
    as::GetMXNotificationNames(void)::mxNotificationNames = v2;
    qword_26ABE8B00 = v3;
    uint64_t v3 = 0;
    long long v2 = 0uLL;
    v4 = (void **)&v2;
    std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
  return &as::GetMXNotificationNames(void)::mxNotificationNames;
}

void sub_210AB0048(_Unwind_Exception *a1)
{
}

void std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  v1 = *a1;
  long long v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 1);
        v4 -= 8;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void anonymous namespace'::BuildMXNotificationsForPlatform(char **a1@<X8>)
{
  v27[31] = *MEMORY[0x263EF8340];
  v27[0] = (id)*MEMORY[0x263F54570];
  v27[1] = (id)*MEMORY[0x263F545B0];
  v27[2] = (id)*MEMORY[0x263F545C8];
  v27[3] = (id)*MEMORY[0x263F54578];
  v27[4] = (id)*MEMORY[0x263F54568];
  v27[5] = (id)*MEMORY[0x263F545C0];
  v27[6] = (id)*MEMORY[0x263F545B8];
  v27[7] = (id)*MEMORY[0x263F544F8];
  v27[8] = (id)*MEMORY[0x263F54598];
  v27[9] = (id)*MEMORY[0x263F54590];
  v27[10] = (id)*MEMORY[0x263F54638];
  v27[11] = (id)*MEMORY[0x263F545F0];
  v27[12] = (id)*MEMORY[0x263F545E0];
  v27[13] = (id)*MEMORY[0x263F545E8];
  v27[14] = (id)*MEMORY[0x263F546A8];
  v27[15] = (id)*MEMORY[0x263F54618];
  v27[16] = (id)*MEMORY[0x263F545F8];
  v27[17] = (id)*MEMORY[0x263F545A0];
  v27[18] = (id)*MEMORY[0x263F54610];
  v27[19] = (id)*MEMORY[0x263F546A0];
  v27[20] = @"CurrentInputDeviceBufferSizeDidChange";
  v27[21] = @"CurrentOutputDeviceBufferSizeDidChange";
  v27[22] = @"CurrentInputSampleRateDidChange";
  v27[23] = @"CurrentOutputSampleRateDidChange";
  v27[24] = (id)*MEMORY[0x263F54588];
  v27[25] = (id)*MEMORY[0x263F54580];
  v27[26] = (id)*MEMORY[0x263F54630];
  v27[27] = (id)*MEMORY[0x263F54608];
  v27[28] = (id)*MEMORY[0x263F545A8];
  v27[29] = (id)*MEMORY[0x263F54628];
  v27[30] = @"RouteControlFeaturesDidChange";
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v23 = a1;
  v24.i8[0] = 0;
  uint64_t v3 = (char *)operator new(0xF8uLL);
  uint64_t v4 = 0;
  *a1 = v3;
  a1[1] = v3;
  a1[2] = v3 + 248;
  do
  {
    *(void *)&v3[v4 * 8] = (id)v27[v4];
    ++v4;
  }
  while (v4 != 31);
  a1[1] = v3 + 248;
  for (uint64_t i = 30; i != -1; --i)

  {
    as::AudioSessionMuteEnabled(void)::enabled = _os_feature_enabled_impl();
  }
  if (as::AudioSessionMuteEnabled(void)::enabled)
  {
    id v6 = (id)*MEMORY[0x263F545D0];
    id v7 = v6;
    char v9 = a1[1];
    unint64_t v8 = (unint64_t)a1[2];
    if ((unint64_t)v9 >= v8)
    {
      uint64_t v11 = (v9 - *a1) >> 3;
      if ((unint64_t)(v11 + 1) >> 61) {
        std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v12 = v8 - (void)*a1;
      uint64_t v13 = v12 >> 2;
      if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
        uint64_t v13 = v11 + 1;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v13;
      }
      v26 = a1 + 2;
      if (v14) {
        v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(a1 + 2), v14);
      }
      else {
        v15 = 0;
      }
      v16 = &v15[8 * v11];
      v17 = &v15[8 * v14];
      v25 = v17;
      *(void *)v16 = v7;
      v10 = v16 + 8;
      v24.i64[1] = (uint64_t)(v16 + 8);
      v19 = *a1;
      v18 = a1[1];
      if (v18 == *a1)
      {
        int64x2_t v21 = vdupq_n_s64((unint64_t)v18);
      }
      else
      {
        do
        {
          uint64_t v20 = *((void *)v18 - 1);
          v18 -= 8;
          *(void *)v18 = 0;
          *((void *)v16 - 1) = v20;
          v16 -= 8;
        }
        while (v18 != v19);
        int64x2_t v21 = *(int64x2_t *)a1;
        v10 = (char *)v24.i64[1];
        v17 = v25;
      }
      *a1 = v16;
      a1[1] = v10;
      int64x2_t v24 = v21;
      v22 = a1[2];
      a1[2] = v17;
      v25 = v22;
      v23 = (char **)v21.i64[0];
      std::__split_buffer<NSString * {__strong}>::~__split_buffer((uint64_t)&v23);
    }
    else
    {
      *(void *)char v9 = v6;
      v10 = v9 + 8;
    }
    a1[1] = v10;
  }
}

void sub_210AB0530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

BOOL FormatNSErrorForReturn(int a1, void *a2, void *a3)
{
  v12[1] = *MEMORY[0x263EF8340];
  uint64_t v5 = a2;
  id v6 = v5;
  if (!a1) {
    goto LABEL_35;
  }
  if (a1 <= 1768386161)
  {
    if (a1 > 561145202)
    {
      if (a1 != 561145203)
      {
        if (a1 != 561211770 && a1 != 1063477620)
        {
LABEL_36:
          uint64_t v7 = a1;
          if (!a3) {
            goto LABEL_35;
          }
LABEL_31:
          if (!v6)
          {
            char v9 = (void *)MEMORY[0x263EFFA78];
            goto LABEL_34;
          }
LABEL_32:
          uint64_t v11 = *MEMORY[0x263F08320];
          v12[0] = v6;
          char v9 = [NSDictionary dictionaryWithObjects:v12 forKeys:&v11 count:1];
LABEL_34:
          *a3 = [MEMORY[0x263F087E8] errorWithDomain:*MEMORY[0x263F08410] code:v7 userInfo:v9];

          goto LABEL_35;
        }
        goto LABEL_13;
      }
      goto LABEL_23;
    }
    if (a1 != 560030580)
    {
      int v8 = 560557673;
      goto LABEL_19;
    }
LABEL_26:
    uint64_t v7 = 560030580;
    if (!v5 && a3)
    {
      id v6 = @"Operation not permitted while session has running audio I/Os";
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  if (a1 <= 1852794998)
  {
    if (a1 == 1768386162)
    {
      uint64_t v7 = 0;
      goto LABEL_30;
    }
    int v8 = 1768843583;
LABEL_19:
    if (a1 != v8) {
      goto LABEL_36;
    }
    uint64_t v7 = 1836282486;
    if (!v5 && a3)
    {
      id v6 = @"Session initialization error. Recent media server termination?";
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  if (a1 != 1852794999)
  {
    if (a1 == 1886681407)
    {
LABEL_13:
      uint64_t v7 = 2003329396;
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_FAULT)) {
        FormatNSErrorForReturn(a1);
      }
      goto LABEL_30;
    }
    if (a1 != 1919839847) {
      goto LABEL_36;
    }
    goto LABEL_26;
  }
LABEL_23:
  uint64_t v7 = 561145203;
  if (!v5 && a3)
  {
    id v6 = @"Resource not available";
    goto LABEL_32;
  }
LABEL_30:
  if (a3) {
    goto LABEL_31;
  }
LABEL_35:

  return a1 == 0;
}

void sub_210AB07EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id sessionManagerXPCCallbackInterface()
{
  {
    sessionManagerXPCCallbackInterface::intf = [MEMORY[0x263F08D80] interfaceWithProtocol:&unk_26C315628];
  }
  v0 = (void *)sessionManagerXPCCallbackInterface::intf;
  return v0;
}

void sub_210AB0890(_Unwind_Exception *a1)
{
}

id sessionManagerXPCInterface()
{
  {
    sessionManagerXPCInterface::intf = sessionManagerXPCInterface::$_0::operator()();
  }
  v0 = (void *)sessionManagerXPCInterface::intf;
  return v0;
}

void sub_210AB0918(_Unwind_Exception *a1)
{
}

id sessionManagerXPCInterface::$_0::operator()()
{
  v0 = [MEMORY[0x263F08D80] interfaceWithProtocol:&unk_26C315A10];
  v1 = (void *)MEMORY[0x263EFFA08];
  uint64_t v16 = objc_opt_class();
  uint64_t v15 = objc_opt_class();
  uint64_t v14 = objc_opt_class();
  uint64_t v13 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  v10 = objc_msgSend(v1, "setWithObjects:", v16, v15, v14, v13, v2, v3, v4, v5, v6, v7, v8, v9, objc_opt_class(), 0);
  [v0 setXPCType:MEMORY[0x263EF8790] forSelector:sel_createSession_sourceAuditToken_sourceSessionID_nameOrDeviceUID_clientProcessName_useCaseIdentifier_reply_ argumentIndex:2 ofReply:1];
  [v0 setClasses:v10 forSelector:sel_getProperty_propertyName_MXProperty_reply_ argumentIndex:1 ofReply:1];
  [v0 setClasses:v10 forSelector:sel_setApplicationProperty_clientID_propertyID_propertyValue_reply_ argumentIndex:3 ofReply:0];
  [v0 setClasses:v10 forSelector:sel_updateApplicationProperty_clientID_propertyID_propertyValue_context_reply_ argumentIndex:3 ofReply:0];
  [v0 setClasses:v10 forSelector:sel_getApplicationProperty_clientID_propertyID_isMXProperty_reply_ argumentIndex:1 ofReply:1];
  [v0 setClasses:v10 forSelector:sel_setMXPropertyOnAllSessions_clientID_MXProperty_values_reply_ argumentIndex:3 ofReply:0];
  [v0 setClasses:v10 forSelector:sel_getMXPropertyGenericPipe_propertyName_reply_ argumentIndex:1 ofReply:1];
  uint64_t v11 = [MEMORY[0x263EFFA08] setWithObject:objc_opt_class()];
  [v0 setClasses:v11 forSelector:sel_getEnhanceDialogueLevelWithReply_ argumentIndex:1 ofReply:1];

  return v0;
}

void sub_210AB0BC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CreateRootDispatchQueue()
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  pthread_attr_init(&v3);
  sched_param v2 = 0;
  pthread_attr_getschedparam(&v3, &v2);
  v2.sched_priority = 47;
  pthread_attr_setschedparam(&v3, &v2);
  pthread_attr_setschedpolicy(&v3, 4);
  v0 = (void *)dispatch_pthread_root_queue_create();
  pthread_attr_destroy(&v3);
  return v0;
}

void sub_210AB0CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, pthread_attr_t *a10)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  __clang_call_terminate(exception_object);
}

void CreateDispatchQueueWithTarget(uint64_t a1@<X0>, void *a2@<X1>, id *a3@<X8>)
{
  target = a2;
  uint64_t v5 = dispatch_queue_attr_make_initially_inactive(0);
  uint64_t v6 = dispatch_queue_attr_make_with_autorelease_frequency(v5, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);

  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v7 = (const char *)a1;
  }
  else {
    uint64_t v7 = *(const char **)a1;
  }
  *a3 = dispatch_queue_create_with_target_V2(v7, v6, target);
  uint64_t v8 = applesauce::dispatch::v1::queue::operator*(a3);

  if (!v8)
  {
    uint64_t v10 = _os_crash();
    as::WorkloopPool::WorkloopPool(v10);
  }
  uint64_t v9 = applesauce::dispatch::v1::queue::operator*(a3);
  dispatch_activate(v9);
}

void sub_210AB0DC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  applesauce::dispatch::v1::queue::~queue(v10);

  _Unwind_Resume(a1);
}

id applesauce::dispatch::v1::queue::operator*(id *a1)
{
  return *a1;
}

void __destroy_helper_block_ea8_32c43_ZTSKNSt3__18weak_ptrIN2as12WorkloopPoolEEE48c60_ZTSNSt3__110shared_ptrIN2as12WorkloopPool13WorkloopStateEEE(uint64_t a1)
{
  sched_param v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  pthread_attr_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void ___ZN2as12WorkloopPool13dispatchAsyncEU13block_pointerFvvE_block_invoke(void *a1)
{
  sched_param v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    pthread_attr_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = a1[4];
      if (v5)
      {
        uint64_t v6 = a1[6];
        uint64_t v7 = (std::__shared_weak_count *)a1[7];
        v8[0] = v6;
        v8[1] = v7;
        if (v7) {
          atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        as::WorkloopPool::handleBlocks(v5, (uint64_t)v8);
        if (v7) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v7);
        }
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
}

void sub_210AB0EDC(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void as::WorkloopPool::dispatchAsync(os_unfair_lock_s *a1, void *a2)
{
  id v15 = a2;
  os_unfair_lock_lock(a1 + 4);
  std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::push_back(&a1[12]._os_unfair_lock_opaque, &v15);
  pthread_attr_t v3 = *(void **)&a1[6]._os_unfair_lock_opaque;
  uint64_t v4 = *(void **)&a1[8]._os_unfair_lock_opaque;
  if (v3 != v4)
  {
    while (*(unsigned char *)(*v3 + 8))
    {
      v3 += 2;
      if (v3 == v4) {
        goto LABEL_23;
      }
    }
  }
  if (v3 == v4)
  {
LABEL_23:
    os_unfair_lock_unlock(a1 + 4);
  }
  else
  {
    uint64_t v6 = *v3;
    uint64_t v5 = (std::__shared_weak_count *)v3[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*(unsigned char *)(v6 + 8))
    {
      uint64_t v10 = _os_crash();
      as::WorkloopPool::WorkloopPool(v10);
    }
    *(unsigned char *)(v6 + 8) = 1;
    os_unfair_lock_unlock(a1 + 4);
    uint64_t v7 = *(void *)&a1->_os_unfair_lock_opaque;
    uint64_t v8 = *(std::__shared_weak_count **)&a1[2]._os_unfair_lock_opaque;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = *(NSObject **)v6;
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3321888768;
    block[2] = ___ZN2as12WorkloopPool13dispatchAsyncEU13block_pointerFvvE_block_invoke;
    block[3] = &__block_descriptor_64_ea8_32c43_ZTSKNSt3__18weak_ptrIN2as12WorkloopPoolEEE48c60_ZTSNSt3__110shared_ptrIN2as12WorkloopPool13WorkloopStateEEE_e5_v8__0l;
    block[4] = v7;
    uint64_t v12 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v13 = v6;
    uint64_t v14 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    dispatch_async(v9, block);
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
    if (v12) {
      std::__shared_weak_count::__release_weak(v12);
    }
    if (v8) {
      std::__shared_weak_count::__release_weak(v8);
    }
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
}

void sub_210AB1088(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);

  _Unwind_Resume(a1);
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

uint64_t std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = ((v5 - v4) << 6) - 1;
  if (v5 == v4) {
    uint64_t v6 = 0;
  }
  if (v6 == a1[5] + a1[4])
  {
    std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::__add_back_capacity(a1);
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
  }
  if (v5 == v4)
  {
    uint64_t v8 = 0;
  }
  else
  {
    unint64_t v7 = a1[5] + a1[4];
    uint64_t v8 = (uint64_t *)(*(void *)(v4 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7 & 0x1FF));
  }
  uint64_t result = MEMORY[0x21667A5C0](*a2);
  *uint64_t v8 = result;
  ++a1[5];
  return result;
}

void as::WorkloopPool::handleBlocks(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  while (*(void *)(a1 + 88))
  {
    uint64_t v5 = (void (**)(void))MEMORY[0x21667A5C0](*(void *)(*(void *)(*(void *)(a1 + 56)
                                                                                 + ((*(void *)(a1 + 80) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                                     + 8 * (*(void *)(a1 + 80) & 0x1FFLL)));
    std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::pop_front((int64x2_t *)(a1 + 48));
    os_unfair_lock_unlock(v4);
    if (v5) {
      v5[2](v5);
    }

    os_unfair_lock_lock(v4);
  }
  if (!*(unsigned char *)(*(void *)a2 + 8))
  {
    uint64_t v6 = _os_crash();
    as::WorkloopPool::WorkloopPool(v6);
  }
  *(unsigned char *)(*(void *)a2 + 8) = 0;
  os_unfair_lock_unlock(v4);
}

void sub_210AB12B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::pop_front(int64x2_t *a1)
{
  objc_release(*(id *)(*(void *)(a1->i64[1] + (((unint64_t)a1[2].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                     + 8 * (a1[2].i64[0] & 0x1FF)));
  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_210AF2020);
  return std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

uint64_t std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x200) {
    a2 = 1;
  }
  if (v2 < 0x400) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
  return v4 ^ 1u;
}

id as::GetServerXPCListenerEndpoint(as *this)
{
}

long long *as::GetSpecialMXNotificationNames(as *this)
{
  {
    as::GetSpecialMXNotificationNames(void)::mxNotificationNames = v2;
    qword_26776EEE0 = v3;
    uint64_t v3 = 0;
    long long v2 = 0uLL;
    int v4 = (void **)&v2;
    std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100](&v4);
  }
  return &as::GetSpecialMXNotificationNames(void)::mxNotificationNames;
}

void sub_210AB144C(_Unwind_Exception *a1)
{
}

void virtual thunk to'CAException::~CAException(CAException *this)
{
}

{
  uint64_t vars8;

  std::exception::~exception((std::exception *)((char *)this + *(void *)(*(void *)this - 24)));
  JUMPOUT(0x21667A2D0);
}

void CAException::~CAException(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x21667A2D0);
}

void CAXException::~CAXException(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x21667A2D0);
}

const char *CAException::what(CAException *this)
{
  return "CAException";
}

uint64_t CAXException::what(CAXException *this)
{
  return (uint64_t)this + 8;
}

id NSErrorWithString(NSString *a1, int a2)
{
  v9[1] = *MEMORY[0x263EF8340];
  uint64_t v3 = a1;
  int v4 = v3;
  if (v3)
  {
    uint64_t v8 = *MEMORY[0x263F08320];
    v9[0] = v3;
    uint64_t v5 = [NSDictionary dictionaryWithObjects:v9 forKeys:&v8 count:1];
  }
  else
  {
    uint64_t v5 = (void *)MEMORY[0x263EFFA78];
  }
  uint64_t v6 = [MEMORY[0x263F087E8] errorWithDomain:@"AVAudioSessionErrorDomain" code:a2 userInfo:v5];

  return v6;
}

void sub_210AB1648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id NSErrorUnimplemented(void)
{
  return NSErrorWithString(&cfstr_NotYetImplemen.isa, -4);
}

BOOL FormatNSErrorForReturn(id a1, void *a2)
{
  if (a1 && a2) {
    *a2 = a1;
  }
  return a1 == 0;
}

void anonymous namespace'::BuildSpecialMXNotificationNames(void *a1@<X8>)
{
  v6[3] = *MEMORY[0x263EF8340];
  v6[0] = (id)*MEMORY[0x263F545D8];
  v6[1] = (id)*MEMORY[0x263F54600];
  v6[2] = (id)*MEMORY[0x263F54620];
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  uint64_t v3 = (char *)operator new(0x18uLL);
  uint64_t v4 = 0;
  *a1 = v3;
  a1[1] = v3;
  a1[2] = v3 + 24;
  do
  {
    *(void *)&v3[v4 * 8] = (id)v6[v4];
    ++v4;
  }
  while (v4 != 3);
  a1[1] = v3 + 24;
  for (uint64_t i = 2; i != -1; --i)
}

void sub_210AB17C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, char a11)
{
  std::vector<NSString * {__strong}>::__destroy_vector::operator()[abi:ne180100](&a9);
  for (uint64_t i = 16; i != -8; i -= 8)

  _Unwind_Resume(a1);
}

void std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_210AB1890(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

uint64_t std::__split_buffer<NSString * {__strong}>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_210AB1A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_210AB1B50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t as::client::SessionState::default_instance(as::client::SessionState *this)
{
  {
    operator new();
  }
  return as::client::SessionState::default_instance(void)::gInstance;
}

void sub_210AB1CF4(_Unwind_Exception *a1)
{
}

double as::client::SessionState::SessionState(as::client::SessionState *this)
{
  *(void *)this = &unk_26C3127C0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(void *)((char *)this + 309) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C3127C0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(void *)((char *)this + 309) = 0;
  return result;
}

void __clang_call_terminate(void *a1)
{
}

as::client::SessionState *as::client::SessionState::SessionState(as::client::SessionState *this, const as::client::SessionState *a2)
{
  *(void *)this = &unk_26C3127C0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  as::client::SessionState::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3127C0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  as::client::SessionState::copy_from(this, a2);
  return this;
}

__n128 as::client::SessionState::copy_from(as::client::SessionState *this, const as::client::SessionState *a2)
{
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 64), (const as::client::SessionState *)((char *)a2 + 64));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 80), (const as::client::SessionState *)((char *)a2 + 80));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 96), (const as::client::SessionState *)((char *)a2 + 96));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 112), (const as::client::SessionState *)((char *)a2 + 112));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 128), (const as::client::SessionState *)((char *)a2 + 128));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 144), (const as::client::SessionState *)((char *)a2 + 144));
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 160), (const as::client::SessionState *)((char *)a2 + 160));
  uint64_t v4 = (const as::ActivationContext *)*((void *)a2 + 26);
  if (v4)
  {
    uint64_t v5 = (as::ActivationContext *)as::client::SessionState::mutableActivationContext(this);
    as::ActivationContext::operator=(v5, v4);
  }
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 176), (const as::client::SessionState *)((char *)a2 + 176));
  uint64_t v6 = (const as::client::TurnByTurnPref *)*((void *)a2 + 27);
  if (v6)
  {
    unint64_t v7 = (as::client::TurnByTurnPref *)as::client::SessionState::mutableTurnByTurnPref(this);
    as::client::TurnByTurnPref::copy_from(v7, v6);
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    operator new();
  }
  caulk::xstring::assign((as::client::SessionState *)((char *)this + 192), (const as::client::SessionState *)((char *)a2 + 192));
  *((void *)this + 1) = *((void *)a2 + 1);
  long long v8 = *((_OWORD *)a2 + 15);
  *((_OWORD *)this + 14) = *((_OWORD *)a2 + 14);
  *((_OWORD *)this + 15) = v8;
  __n128 result = *((__n128 *)a2 + 16);
  long long v10 = *((_OWORD *)a2 + 17);
  long long v11 = *((_OWORD *)a2 + 18);
  *(_OWORD *)((char *)this + 301) = *(_OWORD *)((char *)a2 + 301);
  *((_OWORD *)this + 17) = v10;
  *((_OWORD *)this + 18) = v11;
  *((__n128 *)this + 16) = result;
  return result;
}

void sub_210AB21BC(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::client::SessionState *as::client::SessionState::operator=(as::client::SessionState *a1, const as::client::SessionState *a2)
{
  return a1;
}

uint64_t as::client::SessionState::activationContext(as::client::SessionState *this)
{
  uint64_t result = *((void *)this + 26);
  if (!result) {
    return as::ActivationContext::default_instance(0);
  }
  return result;
}

uint64_t as::client::SessionState::mutableActivationContext(as::client::SessionState *this)
{
  if (!*((void *)this + 26)) {
    operator new();
  }
  return *((void *)this + 26);
}

uint64_t as::client::SessionState::turnByTurnPref(as::client::SessionState *this)
{
  uint64_t result = *((void *)this + 27);
  if (!result) {
    return as::client::TurnByTurnPref::default_instance(0);
  }
  return result;
}

uint64_t as::client::SessionState::mutableTurnByTurnPref(as::client::SessionState *this)
{
  if (!*((void *)this + 27)) {
    operator new();
  }
  return *((void *)this + 27);
}

as::client::TurnByTurnPref *as::client::TurnByTurnPref::operator=(as::client::TurnByTurnPref *a1, const as::client::TurnByTurnPref *a2)
{
  return a1;
}

as::client::PortPrefs *as::client::PortPrefs::PortPrefs(as::client::PortPrefs *this, const as::client::PortPrefs *a2)
{
  *(void *)this = &unk_26C3128A0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 6) = 0;
  as::client::PortPrefs::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3128A0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 6) = 0;
  as::client::PortPrefs::copy_from(this, a2);
  return this;
}

as::client::IOControllerPrefs *as::client::IOControllerPrefs::IOControllerPrefs(as::client::IOControllerPrefs *this, __n128 *a2)
{
  *(void *)this = &unk_26C312868;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  as::client::IOControllerPrefs::copy_from((__n128 *)this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312868;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  as::client::IOControllerPrefs::copy_from((__n128 *)this, a2);
  return this;
}

uint64_t as::client::SessionState::SessionState(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C3127C0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  as::client::SessionState::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C3127C0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  as::client::SessionState::move_from(a1, a2);
  return a1;
}

__n128 as::client::SessionState::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v4 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(void *)(a2 + 208) = v4;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v5 = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  *(void *)(a2 + 216) = v5;
  uint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v6;
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v7;
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v8;
  uint64_t v9 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v9;
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v10;
  uint64_t v11 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v11;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  long long v12 = *(_OWORD *)(a2 + 240);
  *(_OWORD *)(a1 + 224) = *(_OWORD *)(a2 + 224);
  *(_OWORD *)(a1 + 240) = v12;
  __n128 result = *(__n128 *)(a2 + 256);
  long long v14 = *(_OWORD *)(a2 + 272);
  long long v15 = *(_OWORD *)(a2 + 288);
  *(_OWORD *)(a1 + 301) = *(_OWORD *)(a2 + 301);
  *(_OWORD *)(a1 + 272) = v14;
  *(_OWORD *)(a1 + 288) = v15;
  *(__n128 *)(a1 + 256) = result;
  return result;
}

uint64_t as::client::SessionState::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

double as::client::SessionState::clear(as::client::SessionState *this)
{
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 64));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 80));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 96));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 112));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 128));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 144));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 160));
  uint64_t v2 = *((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 176));
  uint64_t v3 = *((void *)this + 27);
  *((void *)this + 27) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 192));
  double result = 0.0;
  *((_OWORD *)this + 14) = 0u;
  uint64_t v5 = (_OWORD *)((char *)this + 224);
  *((void *)v5 - 27) = 0;
  v5[1] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  *(_OWORD *)((char *)v5 + 77) = 0u;
  return result;
}

BOOL as::client::SessionState::isInitialized(as::client::SessionState *this)
{
  for (uint64_t i = *((void *)this + 2); i != *((void *)this + 3); i += 8)
  {
    for (uint64_t j = *(void *)(*(void *)i + 16); j != *(void *)(*(void *)i + 24); j += 8)
    {
      if ((*(unsigned char *)(*(void *)j + 8) & 1) == 0) {
        return 0;
      }
    }
    if ((*(unsigned char *)(*(void *)i + 8) & 1) == 0) {
      return 0;
    }
  }
  uint64_t v4 = (as::client::IOControllerPrefs **)*((void *)this + 5);
  uint64_t v5 = (as::client::IOControllerPrefs **)*((void *)this + 6);
  while (v4 != v5)
  {
    if (!as::client::IOControllerPrefs::isInitialized(*v4)) {
      return 0;
    }
    ++v4;
  }
  if ((~*((_DWORD *)this + 2) & 0x1EF) == 0) {
    return (~*((_DWORD *)this + 3) & 0x38) == 0;
  }
  return 0;
}

uint64_t as::client::PortPrefs::isInitialized(as::client::PortPrefs *this)
{
  for (uint64_t i = *((void *)this + 2); ; i += 8)
  {
    if (i == *((void *)this + 3)) {
      return *((unsigned char *)this + 8) & 1;
    }
    if ((*(unsigned char *)(*(void *)i + 8) & 1) == 0) {
      break;
    }
  }
  return 0;
}

BOOL as::client::IOControllerPrefs::isInitialized(as::client::IOControllerPrefs *this)
{
  for (uint64_t i = *((void *)this + 2); i != *((void *)this + 3); i += 8)
  {
    if ((*(unsigned char *)(*(void *)i + 8) & 1) == 0) {
      return 0;
    }
  }
  for (uint64_t j = *((void *)this + 5); j != *((void *)this + 6); j += 8)
  {
    if ((*(unsigned char *)(*(void *)j + 8) & 1) == 0) {
      return 0;
    }
  }
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::client::SessionState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *a2;
    if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
      break;
    }
    char v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = v3 + 1;
      a2[1] = v3 + 1;
      char v13 = *(unsigned char *)(v8 + v3);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0) {
        break;
      }
      v9 += 7;
      unint64_t v3 = v12;
      BOOL v14 = v10++ > 8;
      if (v14)
      {
        unint64_t v11 = 0;
        break;
      }
    }
LABEL_22:
    if ((v11 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v21 = v11 >> 3;
    if ((int)(v11 >> 3) <= 99)
    {
      switch((int)v21)
      {
        case 1:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v22 = 0;
            unsigned int v23 = 0;
            uint64_t v24 = 0;
            do
            {
              unint64_t v25 = v12 + 1;
              a2[1] = v12 + 1;
              char v26 = *(unsigned char *)(v8 + v12);
              v24 |= (unint64_t)(v26 & 0x7F) << v22;
              if ((v26 & 0x80) == 0) {
                goto LABEL_328;
              }
              v22 += 7;
              unint64_t v12 = v25;
              BOOL v14 = v23++ > 8;
            }
            while (!v14);
LABEL_267:
            LODWORD(v24) = 0;
            goto LABEL_328;
          }
          char v160 = 0;
          unsigned int v161 = 0;
          uint64_t v24 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v162 = v12 + 1;
            char v163 = *(unsigned char *)(v8 + v12);
            a2[1] = v162;
            v24 |= (unint64_t)(v163 & 0x7F) << v160;
            if ((v163 & 0x80) == 0) {
              goto LABEL_328;
            }
            v160 += 7;
            unint64_t v12 = v162;
            BOOL v20 = v161++ >= 9;
            if (v20) {
              goto LABEL_267;
            }
          }
          LODWORD(v24) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_328:
          *(_DWORD *)(a1 + 256) = v24;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_331;
        case 2:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v79 = 0;
            unsigned int v80 = 0;
            uint64_t v81 = 0;
            do
            {
              unint64_t v82 = v12 + 1;
              a2[1] = v12 + 1;
              char v83 = *(unsigned char *)(v8 + v12);
              v81 |= (unint64_t)(v83 & 0x7F) << v79;
              if ((v83 & 0x80) == 0) {
                goto LABEL_322;
              }
              v79 += 7;
              unint64_t v12 = v82;
              BOOL v14 = v80++ > 8;
            }
            while (!v14);
LABEL_244:
            LODWORD(v81) = 0;
            goto LABEL_322;
          }
          char v148 = 0;
          unsigned int v149 = 0;
          uint64_t v81 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v150 = v12 + 1;
            char v151 = *(unsigned char *)(v8 + v12);
            a2[1] = v150;
            v81 |= (unint64_t)(v151 & 0x7F) << v148;
            if ((v151 & 0x80) == 0) {
              goto LABEL_322;
            }
            v148 += 7;
            unint64_t v12 = v150;
            BOOL v20 = v149++ >= 9;
            if (v20) {
              goto LABEL_244;
            }
          }
          LODWORD(v81) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_322:
          *(_DWORD *)(a1 + 260) = v81;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 2;
          goto LABEL_331;
        case 3:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v74 = 0;
            unsigned int v75 = 0;
            uint64_t v76 = 0;
            do
            {
              unint64_t v77 = v12 + 1;
              a2[1] = v12 + 1;
              char v78 = *(unsigned char *)(v8 + v12);
              v76 |= (unint64_t)(v78 & 0x7F) << v74;
              if ((v78 & 0x80) == 0) {
                goto LABEL_320;
              }
              v74 += 7;
              unint64_t v12 = v77;
              BOOL v14 = v75++ > 8;
            }
            while (!v14);
LABEL_237:
            LODWORD(v76) = 0;
            goto LABEL_320;
          }
          char v144 = 0;
          unsigned int v145 = 0;
          uint64_t v76 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v146 = v12 + 1;
            char v147 = *(unsigned char *)(v8 + v12);
            a2[1] = v146;
            v76 |= (unint64_t)(v147 & 0x7F) << v144;
            if ((v147 & 0x80) == 0) {
              goto LABEL_320;
            }
            v144 += 7;
            unint64_t v12 = v146;
            BOOL v20 = v145++ >= 9;
            if (v20) {
              goto LABEL_237;
            }
          }
          LODWORD(v76) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_320:
          *(_DWORD *)(a1 + 264) = v76;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 4;
          goto LABEL_331;
        case 4:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v64 = 0;
            unsigned int v65 = 0;
            uint64_t v66 = 0;
            do
            {
              unint64_t v67 = v12 + 1;
              a2[1] = v12 + 1;
              char v68 = *(unsigned char *)(v8 + v12);
              v66 |= (unint64_t)(v68 & 0x7F) << v64;
              if ((v68 & 0x80) == 0) {
                goto LABEL_316;
              }
              v64 += 7;
              unint64_t v12 = v67;
              BOOL v14 = v65++ > 8;
            }
            while (!v14);
LABEL_223:
            LODWORD(v66) = 0;
            goto LABEL_316;
          }
          char v136 = 0;
          unsigned int v137 = 0;
          uint64_t v66 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v138 = v12 + 1;
            char v139 = *(unsigned char *)(v8 + v12);
            a2[1] = v138;
            v66 |= (unint64_t)(v139 & 0x7F) << v136;
            if ((v139 & 0x80) == 0) {
              goto LABEL_316;
            }
            v136 += 7;
            unint64_t v12 = v138;
            BOOL v20 = v137++ >= 9;
            if (v20) {
              goto LABEL_223;
            }
          }
          LODWORD(v66) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_316:
          *(_DWORD *)(a1 + 268) = v66;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 8;
          goto LABEL_331;
        case 10:
          PB::Reader::read();
          caulk::xstring::assign();
          int v34 = *(_DWORD *)(a1 + 8) | 0x10;
          goto LABEL_149;
        case 11:
          PB::Reader::read();
          caulk::xstring::assign();
          int v34 = *(_DWORD *)(a1 + 8) | 0x20;
          goto LABEL_149;
        case 12:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v91 = 0;
            unsigned int v92 = 0;
            uint64_t v93 = 0;
            do
            {
              unint64_t v94 = v12 + 1;
              a2[1] = v12 + 1;
              char v95 = *(unsigned char *)(v8 + v12);
              v93 |= (unint64_t)(v95 & 0x7F) << v91;
              if ((v95 & 0x80) == 0) {
                goto LABEL_326;
              }
              v91 += 7;
              unint64_t v12 = v94;
              BOOL v14 = v92++ > 8;
            }
            while (!v14);
LABEL_258:
            uint64_t v93 = 0;
            goto LABEL_326;
          }
          char v156 = 0;
          unsigned int v157 = 0;
          uint64_t v93 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v158 = v12 + 1;
            char v159 = *(unsigned char *)(v8 + v12);
            a2[1] = v158;
            v93 |= (unint64_t)(v159 & 0x7F) << v156;
            if ((v159 & 0x80) == 0) {
              goto LABEL_326;
            }
            v156 += 7;
            unint64_t v12 = v158;
            BOOL v20 = v157++ >= 9;
            if (v20) {
              goto LABEL_258;
            }
          }
          uint64_t v93 = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_326:
          *(void *)(a1 + 240) = v93;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x40;
          goto LABEL_331;
        case 13:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v69 = 0;
            unsigned int v70 = 0;
            uint64_t v71 = 0;
            do
            {
              unint64_t v72 = v12 + 1;
              a2[1] = v12 + 1;
              char v73 = *(unsigned char *)(v8 + v12);
              v71 |= (unint64_t)(v73 & 0x7F) << v69;
              if ((v73 & 0x80) == 0) {
                goto LABEL_318;
              }
              v69 += 7;
              unint64_t v12 = v72;
              BOOL v14 = v70++ > 8;
            }
            while (!v14);
LABEL_230:
            LODWORD(v71) = 0;
            goto LABEL_318;
          }
          char v140 = 0;
          unsigned int v141 = 0;
          uint64_t v71 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v142 = v12 + 1;
            char v143 = *(unsigned char *)(v8 + v12);
            a2[1] = v142;
            v71 |= (unint64_t)(v143 & 0x7F) << v140;
            if ((v143 & 0x80) == 0) {
              goto LABEL_318;
            }
            v140 += 7;
            unint64_t v12 = v142;
            BOOL v20 = v141++ >= 9;
            if (v20) {
              goto LABEL_230;
            }
          }
          LODWORD(v71) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_318:
          *(_DWORD *)(a1 + 272) = v71;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x80;
          goto LABEL_331;
        case 14:
          PB::Reader::read();
          caulk::xstring::assign();
          int v34 = *(_DWORD *)(a1 + 8) | 0x100;
          goto LABEL_149;
        case 15:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v54 = 0;
            unsigned int v55 = 0;
            uint64_t v56 = 0;
            do
            {
              unint64_t v57 = v12 + 1;
              a2[1] = v12 + 1;
              char v58 = *(unsigned char *)(v8 + v12);
              v56 |= (unint64_t)(v58 & 0x7F) << v54;
              if ((v58 & 0x80) == 0) {
                goto LABEL_312;
              }
              v54 += 7;
              unint64_t v12 = v57;
              BOOL v14 = v55++ > 8;
            }
            while (!v14);
LABEL_209:
            LODWORD(v56) = 0;
            goto LABEL_312;
          }
          char v128 = 0;
          unsigned int v129 = 0;
          uint64_t v56 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v130 = v12 + 1;
            char v131 = *(unsigned char *)(v8 + v12);
            a2[1] = v130;
            v56 |= (unint64_t)(v131 & 0x7F) << v128;
            if ((v131 & 0x80) == 0) {
              goto LABEL_312;
            }
            v128 += 7;
            unint64_t v12 = v130;
            BOOL v20 = v129++ >= 9;
            if (v20) {
              goto LABEL_209;
            }
          }
          LODWORD(v56) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_312:
          *(_DWORD *)(a1 + 276) = v56;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x200;
          goto LABEL_331;
        case 16:
          PB::Reader::read();
          caulk::xstring::assign();
          int v34 = *(_DWORD *)(a1 + 8) | 0x400;
          goto LABEL_149;
        case 17:
          PB::Reader::read();
          caulk::xstring::assign();
          int v34 = *(_DWORD *)(a1 + 8) | 0x800;
          goto LABEL_149;
        case 18:
          PB::Reader::read();
          caulk::xstring::assign();
          int v34 = *(_DWORD *)(a1 + 8) | 0x1000;
          goto LABEL_149;
        case 19:
          if (v12 >= v2)
          {
            BOOL v51 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v50 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v51 = v50 != 0;
          }
          *(unsigned char *)(a1 + 300) = v51;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x2000;
          goto LABEL_331;
        case 20:
          if (v12 >= v2)
          {
            BOOL v99 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v98 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v99 = v98 != 0;
          }
          *(unsigned char *)(a1 + 301) = v99;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x4000;
          goto LABEL_331;
        case 24:
          if (v12 >= v2)
          {
            BOOL v49 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v48 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v49 = v48 != 0;
          }
          *(unsigned char *)(a1 + 302) = v49;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x8000;
          goto LABEL_331;
        case 25:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v37 = 0;
            unsigned int v38 = 0;
            uint64_t v39 = 0;
            do
            {
              unint64_t v40 = v12 + 1;
              a2[1] = v12 + 1;
              char v41 = *(unsigned char *)(v8 + v12);
              v39 |= (unint64_t)(v41 & 0x7F) << v37;
              if ((v41 & 0x80) == 0) {
                goto LABEL_310;
              }
              v37 += 7;
              unint64_t v12 = v40;
              BOOL v14 = v38++ > 8;
            }
            while (!v14);
LABEL_190:
            LODWORD(v39) = 0;
            goto LABEL_310;
          }
          char v123 = 0;
          unsigned int v124 = 0;
          uint64_t v39 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v125 = v12 + 1;
            char v126 = *(unsigned char *)(v8 + v12);
            a2[1] = v125;
            v39 |= (unint64_t)(v126 & 0x7F) << v123;
            if ((v126 & 0x80) == 0) {
              goto LABEL_310;
            }
            v123 += 7;
            unint64_t v12 = v125;
            BOOL v20 = v124++ >= 9;
            if (v20) {
              goto LABEL_190;
            }
          }
          LODWORD(v39) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_310:
          *(_DWORD *)(a1 + 280) = v39;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x10000;
          goto LABEL_331;
        case 30:
          if (v12 >= v2)
          {
            BOOL v47 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v46 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v47 = v46 != 0;
          }
          *(unsigned char *)(a1 + 303) = v47;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x20000;
          goto LABEL_331;
        case 31:
          if (v12 >= v2)
          {
            BOOL v45 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v44 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v45 = v44 != 0;
          }
          *(unsigned char *)(a1 + 304) = v45;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x40000;
          goto LABEL_331;
        case 32:
          if (v12 >= v2)
          {
            BOOL v101 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v100 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v101 = v100 != 0;
          }
          *(unsigned char *)(a1 + 305) = v101;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x80000;
          goto LABEL_331;
        case 33:
          if (v12 >= v2)
          {
            BOOL v105 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v104 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v105 = v104 != 0;
          }
          *(unsigned char *)(a1 + 306) = v105;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x100000;
          goto LABEL_331;
        case 34:
          if (v12 >= v2)
          {
            BOOL v107 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v106 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v107 = v106 != 0;
          }
          *(unsigned char *)(a1 + 307) = v107;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x200000;
          goto LABEL_331;
        case 35:
          PB::Reader::read();
          caulk::xstring::assign();
          int v34 = *(_DWORD *)(a1 + 8) | 0x400000;
          goto LABEL_149;
        case 36:
          operator new();
        case 37:
          PB::Reader::read();
          caulk::xstring::assign();
          int v34 = *(_DWORD *)(a1 + 8) | 0x800000;
LABEL_149:
          *(_DWORD *)(a1 + 8) = v34;
          goto LABEL_337;
        case 38:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v59 = 0;
            unsigned int v60 = 0;
            uint64_t v61 = 0;
            do
            {
              unint64_t v62 = v12 + 1;
              a2[1] = v12 + 1;
              char v63 = *(unsigned char *)(v8 + v12);
              v61 |= (unint64_t)(v63 & 0x7F) << v59;
              if ((v63 & 0x80) == 0) {
                goto LABEL_314;
              }
              v59 += 7;
              unint64_t v12 = v62;
              BOOL v14 = v60++ > 8;
            }
            while (!v14);
LABEL_216:
            LODWORD(v61) = 0;
            goto LABEL_314;
          }
          char v132 = 0;
          unsigned int v133 = 0;
          uint64_t v61 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v134 = v12 + 1;
            char v135 = *(unsigned char *)(v8 + v12);
            a2[1] = v134;
            v61 |= (unint64_t)(v135 & 0x7F) << v132;
            if ((v135 & 0x80) == 0) {
              goto LABEL_314;
            }
            v132 += 7;
            unint64_t v12 = v134;
            BOOL v20 = v133++ >= 9;
            if (v20) {
              goto LABEL_216;
            }
          }
          LODWORD(v61) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_314:
          *(_DWORD *)(a1 + 284) = v61;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x1000000;
          goto LABEL_331;
        case 39:
          if (v12 >= v2)
          {
            BOOL v85 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v84 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v85 = v84 != 0;
          }
          *(unsigned char *)(a1 + 308) = v85;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x2000000;
          goto LABEL_331;
        case 40:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v86 = 0;
            unsigned int v87 = 0;
            uint64_t v88 = 0;
            do
            {
              unint64_t v89 = v12 + 1;
              a2[1] = v12 + 1;
              char v90 = *(unsigned char *)(v8 + v12);
              v88 |= (unint64_t)(v90 & 0x7F) << v86;
              if ((v90 & 0x80) == 0) {
                goto LABEL_324;
              }
              v86 += 7;
              unint64_t v12 = v89;
              BOOL v14 = v87++ > 8;
            }
            while (!v14);
LABEL_251:
            uint64_t v88 = 0;
            goto LABEL_324;
          }
          char v152 = 0;
          unsigned int v153 = 0;
          uint64_t v88 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v154 = v12 + 1;
            char v155 = *(unsigned char *)(v8 + v12);
            a2[1] = v154;
            v88 |= (unint64_t)(v155 & 0x7F) << v152;
            if ((v155 & 0x80) == 0) {
              goto LABEL_324;
            }
            v152 += 7;
            unint64_t v12 = v154;
            BOOL v20 = v153++ >= 9;
            if (v20) {
              goto LABEL_251;
            }
          }
          uint64_t v88 = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_324:
          *(void *)(a1 + 248) = v88;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x4000000;
          goto LABEL_331;
        case 50:
          if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
          {
            char v110 = 0;
            unsigned int v111 = 0;
            uint64_t v112 = 0;
            do
            {
              unint64_t v113 = v12 + 1;
              a2[1] = v12 + 1;
              char v114 = *(unsigned char *)(v8 + v12);
              v112 |= (unint64_t)(v114 & 0x7F) << v110;
              if ((v114 & 0x80) == 0) {
                goto LABEL_330;
              }
              v110 += 7;
              unint64_t v12 = v113;
              BOOL v14 = v111++ > 8;
            }
            while (!v14);
LABEL_286:
            LODWORD(v112) = 0;
            goto LABEL_330;
          }
          char v164 = 0;
          unsigned int v165 = 0;
          uint64_t v112 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v166 = v12 + 1;
            char v167 = *(unsigned char *)(v8 + v12);
            a2[1] = v166;
            v112 |= (unint64_t)(v167 & 0x7F) << v164;
            if ((v167 & 0x80) == 0) {
              goto LABEL_330;
            }
            v164 += 7;
            unint64_t v12 = v166;
            BOOL v20 = v165++ >= 9;
            if (v20) {
              goto LABEL_286;
            }
          }
          LODWORD(v112) = 0;
          *((unsigned char *)a2 + 24) = 1;
LABEL_330:
          *(_DWORD *)(a1 + 288) = v112;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x8000000;
LABEL_331:
          *(_DWORD *)(a1 + 8) = v122;
          break;
        case 51:
          if (v12 >= v2)
          {
            BOOL v109 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v108 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v109 = v108 != 0;
          }
          *(unsigned char *)(a1 + 309) = v109;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x10000000;
          goto LABEL_331;
        case 52:
          operator new();
        case 53:
          if (v12 >= v2)
          {
            BOOL v43 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v42 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v43 = v42 != 0;
          }
          *(unsigned char *)(a1 + 310) = v43;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x20000000;
          goto LABEL_331;
        case 54:
          if (v12 >= v2)
          {
            BOOL v36 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v35 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v36 = v35 != 0;
          }
          *(unsigned char *)(a1 + 311) = v36;
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x40000000;
          goto LABEL_331;
        case 55:
          if (v12 > 0xFFFFFFFFFFFFFFFBLL || v12 + 4 > v2)
          {
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            *(_DWORD *)(a1 + 232) = *(_DWORD *)(v8 + v12);
            a2[1] += 4;
          }
          unsigned int v122 = *(_DWORD *)(a1 + 8) | 0x80000000;
          goto LABEL_331;
        case 56:
          if (v12 >= v2)
          {
            BOOL v53 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v52 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v53 = v52 != 0;
          }
          *(unsigned char *)(a1 + 312) = v53;
          int v127 = *(_DWORD *)(a1 + 12) | 1;
          goto LABEL_336;
        case 57:
          if (v12 >= v2)
          {
            BOOL v97 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v96 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v97 = v96 != 0;
          }
          *(unsigned char *)(a1 + 313) = v97;
          int v127 = *(_DWORD *)(a1 + 12) | 2;
          goto LABEL_336;
        case 58:
          if (v12 >= v2)
          {
            BOOL v103 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v102 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v103 = v102 != 0;
          }
          *(unsigned char *)(a1 + 314) = v103;
          int v127 = *(_DWORD *)(a1 + 12) | 4;
          goto LABEL_336;
        default:
          goto LABEL_337;
      }
      goto LABEL_337;
    }
    if ((int)v21 > 111)
    {
      if ((int)v21 > 150)
      {
        if (v21 == 151)
        {
          if (v12 > 0xFFFFFFFFFFFFFFF5 || v12 + 10 > v2)
          {
            char v168 = 0;
            unsigned int v169 = 0;
            uint64_t v119 = 0;
            if (v2 <= v12) {
              unint64_t v2 = v12;
            }
            while (v2 != v12)
            {
              unint64_t v170 = v12 + 1;
              char v171 = *(unsigned char *)(v8 + v12);
              a2[1] = v170;
              v119 |= (unint64_t)(v171 & 0x7F) << v168;
              if ((v171 & 0x80) == 0) {
                goto LABEL_333;
              }
              v168 += 7;
              unint64_t v12 = v170;
              BOOL v20 = v169++ >= 9;
              if (v20)
              {
LABEL_295:
                LODWORD(v119) = 0;
                goto LABEL_333;
              }
            }
            LODWORD(v119) = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            char v117 = 0;
            unsigned int v118 = 0;
            uint64_t v119 = 0;
            while (1)
            {
              unint64_t v120 = v12 + 1;
              a2[1] = v12 + 1;
              char v121 = *(unsigned char *)(v8 + v12);
              v119 |= (unint64_t)(v121 & 0x7F) << v117;
              if ((v121 & 0x80) == 0) {
                break;
              }
              v117 += 7;
              unint64_t v12 = v120;
              BOOL v14 = v118++ > 8;
              if (v14) {
                goto LABEL_295;
              }
            }
          }
LABEL_333:
          *(_DWORD *)(a1 + 292) = v119;
          int v127 = *(_DWORD *)(a1 + 12) | 0x80;
          goto LABEL_336;
        }
        if (v21 == 152)
        {
          if (v12 > 0xFFFFFFFFFFFFFFF5 || v12 + 10 > v2)
          {
            char v172 = 0;
            unsigned int v173 = 0;
            uint64_t v31 = 0;
            if (v2 <= v12) {
              unint64_t v2 = v12;
            }
            while (v2 != v12)
            {
              unint64_t v174 = v12 + 1;
              char v175 = *(unsigned char *)(v8 + v12);
              a2[1] = v174;
              v31 |= (unint64_t)(v175 & 0x7F) << v172;
              if ((v175 & 0x80) == 0) {
                goto LABEL_335;
              }
              v172 += 7;
              unint64_t v12 = v174;
              BOOL v20 = v173++ >= 9;
              if (v20)
              {
LABEL_304:
                LODWORD(v31) = 0;
                goto LABEL_335;
              }
            }
            LODWORD(v31) = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            char v29 = 0;
            unsigned int v30 = 0;
            uint64_t v31 = 0;
            while (1)
            {
              unint64_t v32 = v12 + 1;
              a2[1] = v12 + 1;
              char v33 = *(unsigned char *)(v8 + v12);
              v31 |= (unint64_t)(v33 & 0x7F) << v29;
              if ((v33 & 0x80) == 0) {
                break;
              }
              v29 += 7;
              unint64_t v12 = v32;
              BOOL v14 = v30++ > 8;
              if (v14) {
                goto LABEL_304;
              }
            }
          }
LABEL_335:
          *(_DWORD *)(a1 + 296) = v31;
          int v127 = *(_DWORD *)(a1 + 12) | 0x100;
          goto LABEL_336;
        }
      }
      else
      {
        if (v21 == 112)
        {
          if (v12 >= v2)
          {
            BOOL v116 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v115 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v116 = v115 != 0;
          }
          *(unsigned char *)(a1 + 316) = v116;
          int v127 = *(_DWORD *)(a1 + 12) | 0x20;
          goto LABEL_336;
        }
        if (v21 == 150)
        {
          if (v12 > 0xFFFFFFFFFFFFFFF7 || v12 + 8 > v2)
          {
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            *(void *)(a1 + 224) = *(void *)(v8 + v12);
            a2[1] += 8;
          }
          int v127 = *(_DWORD *)(a1 + 12) | 0x40;
          goto LABEL_336;
        }
      }
    }
    else
    {
      if ((int)v21 <= 109)
      {
        if (v21 == 100) {
          operator new();
        }
        if (v21 == 101) {
          operator new();
        }
        goto LABEL_337;
      }
      if (v21 != 110)
      {
        if (v12 >= v2)
        {
          BOOL v28 = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          int v27 = *(unsigned __int8 *)(v8 + v12);
          a2[1] = v12 + 1;
          BOOL v28 = v27 != 0;
        }
        *(unsigned char *)(a1 + 315) = v28;
        int v127 = *(_DWORD *)(a1 + 12) | 0x10;
LABEL_336:
        *(_DWORD *)(a1 + 12) = v127;
        goto LABEL_337;
      }
      PB::Reader::read();
      caulk::xstring::assign();
      *(_DWORD *)(a1 + 12) |= 8u;
    }
LABEL_337:
    unint64_t v3 = a2[1];
    unint64_t v2 = a2[2];
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v15 = 0;
  unsigned int v16 = 0;
  unint64_t v11 = 0;
  if (v3 <= v2) {
    unint64_t v17 = v2;
  }
  else {
    unint64_t v17 = v3;
  }
  while (v17 != v3)
  {
    unint64_t v18 = v3++;
    char v19 = *(unsigned char *)(v8 + v18);
    a2[1] = v3;
    v11 |= (unint64_t)(v19 & 0x7F) << v15;
    if ((v19 & 0x80) == 0) {
      goto LABEL_21;
    }
    v15 += 7;
    BOOL v20 = v16++ >= 9;
    if (v20)
    {
      unint64_t v11 = 0;
LABEL_21:
      unint64_t v12 = v18 + 1;
      goto LABEL_22;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_210AB4200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  _Unwind_Resume(a1);
}

void as::client::SessionState::writeTo(as::client::SessionState *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_37;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_38;
  }
LABEL_37:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_39;
  }
LABEL_38:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_42;
  }
LABEL_39:
  uint64_t v8 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 64));
  std::string::basic_string[abi:ne180100]<0>(__p, v8);
  PB::Writer::write();
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_45;
  }
LABEL_42:
  char v9 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 80));
  std::string::basic_string[abi:ne180100]<0>(__p, v9);
  PB::Writer::write();
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x40) == 0)
  {
LABEL_8:
    if ((v4 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_46;
  }
LABEL_45:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x80) == 0)
  {
LABEL_9:
    if ((v4 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_47;
  }
LABEL_46:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x100) == 0)
  {
LABEL_10:
    if ((v4 & 0x200) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_47:
  unsigned int v10 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 96));
  std::string::basic_string[abi:ne180100]<0>(__p, v10);
  PB::Writer::write();
  if (v27 < 0) {
    operator delete(__p[0]);
  }
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x200) != 0)
  {
LABEL_11:
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
LABEL_12:
  if ((v4 & 0x400) != 0)
  {
    uint64_t v5 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 112));
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 0x800) != 0)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 128));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::Writer::write();
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 0x1000) != 0)
  {
    uint64_t v7 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 144));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::Writer::write();
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 0x2000) != 0)
  {
    PB::Writer::write(a2);
    int v4 = *((_DWORD *)this + 2);
    if ((v4 & 0x4000) == 0)
    {
LABEL_26:
      if ((v4 & 0x8000) == 0) {
        goto LABEL_27;
      }
      goto LABEL_53;
    }
  }
  else if ((v4 & 0x4000) == 0)
  {
    goto LABEL_26;
  }
  PB::Writer::write(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x8000) == 0)
  {
LABEL_27:
    if ((v4 & 0x10000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_54;
  }
LABEL_53:
  PB::Writer::write(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x10000) == 0)
  {
LABEL_28:
    if ((v4 & 0x20000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_55;
  }
LABEL_54:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x20000) == 0)
  {
LABEL_29:
    if ((v4 & 0x40000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_56;
  }
LABEL_55:
  PB::Writer::write(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x40000) == 0)
  {
LABEL_30:
    if ((v4 & 0x80000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_57;
  }
LABEL_56:
  PB::Writer::write(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x80000) == 0)
  {
LABEL_31:
    if ((v4 & 0x100000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_58;
  }
LABEL_57:
  PB::Writer::write(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x100000) == 0)
  {
LABEL_32:
    if ((v4 & 0x200000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_59;
  }
LABEL_58:
  PB::Writer::write(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x200000) == 0)
  {
LABEL_33:
    if ((v4 & 0x400000) == 0) {
      goto LABEL_62;
    }
    goto LABEL_60;
  }
LABEL_59:
  PB::Writer::write(a2);
  if ((*((_DWORD *)this + 2) & 0x400000) == 0) {
    goto LABEL_62;
  }
LABEL_60:
  unint64_t v11 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 160));
  std::string::basic_string[abi:ne180100]<0>(__p, v11);
  PB::Writer::write();
  if (v27 < 0) {
    operator delete(__p[0]);
  }
LABEL_62:
  unint64_t v12 = (const PB::Base *)*((void *)this + 26);
  if (v12) {
    PB::Writer::writeSubmessage(a2, v12);
  }
  int v13 = *((_DWORD *)this + 2);
  if ((v13 & 0x800000) != 0)
  {
    BOOL v14 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 176));
    std::string::basic_string[abi:ne180100]<0>(__p, v14);
    PB::Writer::write();
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    int v13 = *((_DWORD *)this + 2);
  }
  if ((v13 & 0x1000000) != 0)
  {
    PB::Writer::writeVarInt(a2);
    int v13 = *((_DWORD *)this + 2);
    if ((v13 & 0x2000000) == 0)
    {
LABEL_70:
      if ((v13 & 0x4000000) == 0) {
        goto LABEL_71;
      }
      goto LABEL_102;
    }
  }
  else if ((v13 & 0x2000000) == 0)
  {
    goto LABEL_70;
  }
  PB::Writer::write(a2);
  int v13 = *((_DWORD *)this + 2);
  if ((v13 & 0x4000000) == 0)
  {
LABEL_71:
    if ((v13 & 0x8000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_103;
  }
LABEL_102:
  PB::Writer::writeVarInt(a2);
  int v13 = *((_DWORD *)this + 2);
  if ((v13 & 0x8000000) == 0)
  {
LABEL_72:
    if ((v13 & 0x10000000) == 0) {
      goto LABEL_74;
    }
    goto LABEL_73;
  }
LABEL_103:
  PB::Writer::writeVarInt(a2);
  if ((*((_DWORD *)this + 2) & 0x10000000) != 0) {
LABEL_73:
  }
    PB::Writer::write(a2);
LABEL_74:
  char v15 = (const PB::Base *)*((void *)this + 27);
  if (v15) {
    PB::Writer::writeSubmessage(a2, v15);
  }
  int v16 = *((_DWORD *)this + 2);
  if ((v16 & 0x20000000) == 0)
  {
    if ((v16 & 0x40000000) == 0) {
      goto LABEL_78;
    }
LABEL_106:
    PB::Writer::write(a2);
    if ((*((_DWORD *)this + 2) & 0x80000000) == 0) {
      goto LABEL_79;
    }
    goto LABEL_107;
  }
  PB::Writer::write(a2);
  int v16 = *((_DWORD *)this + 2);
  if ((v16 & 0x40000000) != 0) {
    goto LABEL_106;
  }
LABEL_78:
  if ((v16 & 0x80000000) == 0) {
    goto LABEL_79;
  }
LABEL_107:
  PB::Writer::write(a2, *((float *)this + 58));
LABEL_79:
  int v17 = *((_DWORD *)this + 3);
  if ((v17 & 1) == 0)
  {
    if ((v17 & 2) == 0) {
      goto LABEL_81;
    }
LABEL_109:
    PB::Writer::write(a2);
    if ((*((_DWORD *)this + 3) & 4) == 0) {
      goto LABEL_83;
    }
    goto LABEL_82;
  }
  PB::Writer::write(a2);
  int v17 = *((_DWORD *)this + 3);
  if ((v17 & 2) != 0) {
    goto LABEL_109;
  }
LABEL_81:
  if ((v17 & 4) != 0) {
LABEL_82:
  }
    PB::Writer::write(a2);
LABEL_83:
  unint64_t v18 = (const PB::Base **)*((void *)this + 2);
  char v19 = (const PB::Base **)*((void *)this + 3);
  while (v18 != v19)
  {
    BOOL v20 = *v18++;
    PB::Writer::writeSubmessage(a2, v20);
  }
  unint64_t v21 = (const PB::Base **)*((void *)this + 5);
  char v22 = (const PB::Base **)*((void *)this + 6);
  while (v21 != v22)
  {
    unsigned int v23 = *v21++;
    PB::Writer::writeSubmessage(a2, v23);
  }
  int v24 = *((_DWORD *)this + 3);
  if ((v24 & 8) != 0)
  {
    unint64_t v25 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 192));
    std::string::basic_string[abi:ne180100]<0>(__p, v25);
    PB::Writer::write();
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    int v24 = *((_DWORD *)this + 3);
  }
  if ((v24 & 0x10) != 0)
  {
    PB::Writer::write(a2);
    int v24 = *((_DWORD *)this + 3);
    if ((v24 & 0x20) == 0)
    {
LABEL_95:
      if ((v24 & 0x40) == 0) {
        goto LABEL_96;
      }
      goto LABEL_113;
    }
  }
  else if ((v24 & 0x20) == 0)
  {
    goto LABEL_95;
  }
  PB::Writer::write(a2);
  int v24 = *((_DWORD *)this + 3);
  if ((v24 & 0x40) == 0)
  {
LABEL_96:
    if ((v24 & 0x80) == 0) {
      goto LABEL_97;
    }
    goto LABEL_114;
  }
LABEL_113:
  PB::Writer::write(a2, *((double *)this + 28));
  int v24 = *((_DWORD *)this + 3);
  if ((v24 & 0x80) == 0)
  {
LABEL_97:
    if ((v24 & 0x100) == 0) {
      return;
    }
    goto LABEL_98;
  }
LABEL_114:
  PB::Writer::writeVarInt(a2);
  if ((*((_DWORD *)this + 3) & 0x100) == 0) {
    return;
  }
LABEL_98:
  PB::Writer::writeVarInt(a2);
}

void sub_210AB49C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::client::SessionState::formatText(as::client::SessionState *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "sessionToken");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_37;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "generationCount");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_38;
  }
LABEL_37:
  PB::TextFormatter::format(a2, "originatingProcessToken");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_39;
  }
LABEL_38:
  PB::TextFormatter::format(a2, "processOwningIOResources");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_42;
  }
LABEL_39:
  char v9 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 64));
  std::string::basic_string[abi:ne180100]<0>(__p, v9);
  PB::TextFormatter::format();
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_45;
  }
LABEL_42:
  unsigned int v10 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 80));
  std::string::basic_string[abi:ne180100]<0>(__p, v10);
  PB::TextFormatter::format();
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x40) == 0)
  {
LABEL_8:
    if ((v5 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_46;
  }
LABEL_45:
  PB::TextFormatter::format(a2, "categoryOptions");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x80) == 0)
  {
LABEL_9:
    if ((v5 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_47;
  }
LABEL_46:
  PB::TextFormatter::format(a2, "routeSharingPolicy");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x100) == 0)
  {
LABEL_10:
    if ((v5 & 0x200) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_47:
  unint64_t v11 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 96));
  std::string::basic_string[abi:ne180100]<0>(__p, v11);
  PB::TextFormatter::format();
  if (v29 < 0) {
    operator delete(__p[0]);
  }
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x200) != 0)
  {
LABEL_11:
    PB::TextFormatter::format(a2, "outputPortOverride");
    int v5 = *((_DWORD *)this + 2);
  }
LABEL_12:
  if ((v5 & 0x400) != 0)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 112));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::TextFormatter::format();
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 0x800) != 0)
  {
    uint64_t v7 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 128));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 0x1000) != 0)
  {
    uint64_t v8 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 144));
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::TextFormatter::format();
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 0x2000) != 0)
  {
    PB::TextFormatter::format(a2, "allowHapticsAndSystemSoundsDuringRecording");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 0x4000) == 0)
    {
LABEL_26:
      if ((v5 & 0x8000) == 0) {
        goto LABEL_27;
      }
      goto LABEL_53;
    }
  }
  else if ((v5 & 0x4000) == 0)
  {
    goto LABEL_26;
  }
  PB::TextFormatter::format(a2, "prefersNoInterruptionsFromSystemAlerts");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x8000) == 0)
  {
LABEL_27:
    if ((v5 & 0x10000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_54;
  }
LABEL_53:
  PB::TextFormatter::format(a2, "microphoneFollowsCamera");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10000) == 0)
  {
LABEL_28:
    if ((v5 & 0x20000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_55;
  }
LABEL_54:
  PB::TextFormatter::format(a2, "aggregatedIOPreference");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20000) == 0)
  {
LABEL_29:
    if ((v5 & 0x40000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_56;
  }
LABEL_55:
  PB::TextFormatter::format(a2, "forceSoundCheck");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x40000) == 0)
  {
LABEL_30:
    if ((v5 & 0x80000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_57;
  }
LABEL_56:
  PB::TextFormatter::format(a2, "usingLongFormAudio");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x80000) == 0)
  {
LABEL_31:
    if ((v5 & 0x100000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_58;
  }
LABEL_57:
  PB::TextFormatter::format(a2, "allowAllBuiltInDataSources");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x100000) == 0)
  {
LABEL_32:
    if ((v5 & 0x200000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_59;
  }
LABEL_58:
  PB::TextFormatter::format(a2, "fixHardwareFormatToMultiChannel");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x200000) == 0)
  {
LABEL_33:
    if ((v5 & 0x400000) == 0) {
      goto LABEL_62;
    }
    goto LABEL_60;
  }
LABEL_59:
  PB::TextFormatter::format(a2, "iAmTheAssistant");
  if ((*((_DWORD *)this + 2) & 0x400000) == 0) {
    goto LABEL_62;
  }
LABEL_60:
  unint64_t v12 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 160));
  std::string::basic_string[abi:ne180100]<0>(__p, v12);
  PB::TextFormatter::format();
  if (v29 < 0) {
    operator delete(__p[0]);
  }
LABEL_62:
  uint64_t v13 = *((void *)this + 26);
  if (v13) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v13 + 32))(v13, a2, "activationContext");
  }
  int v14 = *((_DWORD *)this + 2);
  if ((v14 & 0x800000) != 0)
  {
    char v15 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 176));
    std::string::basic_string[abi:ne180100]<0>(__p, v15);
    PB::TextFormatter::format();
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    int v14 = *((_DWORD *)this + 2);
  }
  if ((v14 & 0x1000000) != 0)
  {
    PB::TextFormatter::format(a2, "interruptionPriority");
    int v14 = *((_DWORD *)this + 2);
    if ((v14 & 0x2000000) == 0)
    {
LABEL_70:
      if ((v14 & 0x4000000) == 0) {
        goto LABEL_71;
      }
      goto LABEL_100;
    }
  }
  else if ((v14 & 0x2000000) == 0)
  {
    goto LABEL_70;
  }
  PB::TextFormatter::format(a2, "bypassRingerSwitchPolicy");
  int v14 = *((_DWORD *)this + 2);
  if ((v14 & 0x4000000) == 0)
  {
LABEL_71:
    if ((v14 & 0x8000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_101;
  }
LABEL_100:
  PB::TextFormatter::format(a2, "hardwareControlFlags");
  int v14 = *((_DWORD *)this + 2);
  if ((v14 & 0x8000000) == 0)
  {
LABEL_72:
    if ((v14 & 0x10000000) == 0) {
      goto LABEL_74;
    }
    goto LABEL_73;
  }
LABEL_101:
  PB::TextFormatter::format(a2, "reporterID");
  if ((*((_DWORD *)this + 2) & 0x10000000) != 0) {
LABEL_73:
  }
    PB::TextFormatter::format(a2, "selectIndependentRoutingContext");
LABEL_74:
  uint64_t v16 = *((void *)this + 27);
  if (v16) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v16 + 32))(v16, a2, "turnByTurnPref");
  }
  int v17 = *((_DWORD *)this + 2);
  if ((v17 & 0x20000000) == 0)
  {
    if ((v17 & 0x40000000) == 0) {
      goto LABEL_78;
    }
LABEL_104:
    PB::TextFormatter::format(a2, "requiresNoAudioResources");
    if ((*((_DWORD *)this + 2) & 0x80000000) == 0) {
      goto LABEL_79;
    }
    goto LABEL_105;
  }
  PB::TextFormatter::format(a2, "voiceProcessingRoutingEnabled");
  int v17 = *((_DWORD *)this + 2);
  if ((v17 & 0x40000000) != 0) {
    goto LABEL_104;
  }
LABEL_78:
  if ((v17 & 0x80000000) == 0) {
    goto LABEL_79;
  }
LABEL_105:
  PB::TextFormatter::format(a2, "interruptionFadeDuration", *((float *)this + 58));
LABEL_79:
  int v18 = *((_DWORD *)this + 3);
  if (v18)
  {
    PB::TextFormatter::format(a2, "allowMixableAudioWhileRecording");
    int v18 = *((_DWORD *)this + 3);
    if ((v18 & 2) == 0)
    {
LABEL_81:
      if ((v18 & 4) == 0) {
        goto LABEL_83;
      }
      goto LABEL_82;
    }
  }
  else if ((v18 & 2) == 0)
  {
    goto LABEL_81;
  }
  PB::TextFormatter::format(a2, "recordingFromRemoteInput");
  if ((*((_DWORD *)this + 3) & 4) != 0) {
LABEL_82:
  }
    PB::TextFormatter::format(a2, "prefersNoDucking");
LABEL_83:
  char v19 = (uint64_t *)*((void *)this + 2);
  BOOL v20 = (uint64_t *)*((void *)this + 3);
  while (v19 != v20)
  {
    uint64_t v21 = *v19++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v21 + 32))(v21, a2, "portPrefs");
  }
  char v22 = (uint64_t *)*((void *)this + 5);
  unsigned int v23 = (uint64_t *)*((void *)this + 6);
  while (v22 != v23)
  {
    uint64_t v24 = *v22++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v24 + 32))(v24, a2, "ioControllerPrefs");
  }
  int v25 = *((_DWORD *)this + 3);
  if ((v25 & 8) != 0)
  {
    char v26 = (char *)caulk::xstring::c_str((as::client::SessionState *)((char *)this + 192));
    std::string::basic_string[abi:ne180100]<0>(__p, v26);
    PB::TextFormatter::format();
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    int v25 = *((_DWORD *)this + 3);
  }
  if ((v25 & 0x10) != 0)
  {
    PB::TextFormatter::format(a2, "wantsBackgroundAudio");
    int v25 = *((_DWORD *)this + 3);
    if ((v25 & 0x20) == 0)
    {
LABEL_93:
      if ((v25 & 0x40) == 0) {
        goto LABEL_94;
      }
      goto LABEL_111;
    }
  }
  else if ((v25 & 0x20) == 0)
  {
    goto LABEL_93;
  }
  PB::TextFormatter::format(a2, "wantsMicrophonePermission");
  int v25 = *((_DWORD *)this + 3);
  if ((v25 & 0x40) == 0)
  {
LABEL_94:
    if ((v25 & 0x80) == 0) {
      goto LABEL_95;
    }
LABEL_112:
    PB::TextFormatter::format(a2, "preferredInputNumberOfChannels");
    if ((*((_DWORD *)this + 3) & 0x100) == 0) {
      return PB::TextFormatter::endObject(a2);
    }
    goto LABEL_96;
  }
LABEL_111:
  PB::TextFormatter::format(a2, "preferredSampleRate", *((double *)this + 28));
  int v25 = *((_DWORD *)this + 3);
  if ((v25 & 0x80) != 0) {
    goto LABEL_112;
  }
LABEL_95:
  if ((v25 & 0x100) != 0) {
LABEL_96:
  }
    PB::TextFormatter::format(a2, "preferredOutputNumberOfChannels");
  return PB::TextFormatter::endObject(a2);
}

void sub_210AB51AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::client::SessionState::operator==(void *a1, void *a2)
{
  if (a1[1] != a2[1]
    || memcmp(a1 + 28, a2 + 28, 0x5DuLL)
    || caulk::xstring::compare((caulk::xstring *)(a1 + 8), (const caulk::xstring *)(a2 + 8))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 10), (const caulk::xstring *)(a2 + 10))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 12), (const caulk::xstring *)(a2 + 12))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 14), (const caulk::xstring *)(a2 + 14))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 18), (const caulk::xstring *)(a2 + 18))
    || caulk::xstring::compare((caulk::xstring *)(a1 + 20), (const caulk::xstring *)(a2 + 20)))
  {
    return 0;
  }
  uint64_t v5 = a1[26];
  uint64_t v6 = a2[26];
  if (v5 && v6)
  {
    if (!as::ActivationContext::operator==(v5, v6)) {
      return 0;
    }
  }
  else if (v5 | v6)
  {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 22), (const caulk::xstring *)(a2 + 22))) {
    return 0;
  }
  uint64_t v7 = a1[27];
  uint64_t v8 = a2[27];
  if (v7 && v8)
  {
    if (as::client::TurnByTurnPref::operator==(v7, v8)) {
      goto LABEL_22;
    }
    return 0;
  }
  if (v7 | v8) {
    return 0;
  }
LABEL_22:
  uint64_t v10 = a1[2];
  uint64_t v9 = a1[3];
  unint64_t v11 = (v9 - v10) >> 3;
  if (v11 != (uint64_t)(a2[3] - a2[2]) >> 3) {
    return 0;
  }
  if (v9 != v10)
  {
    uint64_t v12 = 0;
    if (v11 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v11;
    }
    do
    {
      uint64_t v14 = *(void *)(a1[2] + 8 * v12);
      uint64_t v15 = v12;
      uint64_t v16 = *(void *)(a2[2] + 8 * v12);
      if (v14) {
        BOOL v17 = v16 == 0;
      }
      else {
        BOOL v17 = 1;
      }
      if (v17)
      {
        if (v14 | v16) {
          return 0;
        }
      }
      else if (!as::client::PortPrefs::operator==(v14, v16))
      {
        return 0;
      }
      uint64_t v12 = v15 + 1;
    }
    while (v13 != v15 + 1);
  }
  uint64_t v19 = a1[5];
  uint64_t v18 = a1[6];
  unint64_t v20 = (v18 - v19) >> 3;
  if (v20 != (uint64_t)(a2[6] - a2[5]) >> 3) {
    return 0;
  }
  if (v18 != v19)
  {
    uint64_t v21 = 0;
    if (v20 <= 1) {
      uint64_t v22 = 1;
    }
    else {
      uint64_t v22 = (v18 - v19) >> 3;
    }
    do
    {
      uint64_t v23 = *(void *)(a1[5] + 8 * v21);
      uint64_t v24 = *(void *)(a2[5] + 8 * v21);
      if (v23) {
        BOOL v25 = v24 == 0;
      }
      else {
        BOOL v25 = 1;
      }
      if (v25)
      {
        if (v23 | v24) {
          return 0;
        }
      }
      else if (!as::client::IOControllerPrefs::operator==(v23, v24))
      {
        return 0;
      }
      ++v21;
    }
    while (v22 != v21);
  }
  return caulk::xstring::compare((caulk::xstring *)(a1 + 24), (const caulk::xstring *)(a2 + 24)) == 0;
}

uint64_t as::client::SessionState::clearActivationContext(as::client::SessionState *this)
{
  uint64_t result = *((void *)this + 26);
  *((void *)this + 26) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::client::TurnByTurnPref::default_instance(as::client::TurnByTurnPref *this)
{
  {
    operator new();
  }
  return as::client::TurnByTurnPref::default_instance(void)::gInstance;
}

void sub_210AB54CC(_Unwind_Exception *a1)
{
}

uint64_t as::client::TurnByTurnPref::TurnByTurnPref(uint64_t this)
{
  *(void *)this = &unk_26C3127F8;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(unsigned char *)(this + 32) = 0;
  return this;
}

{
  *(void *)this = &unk_26C3127F8;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(unsigned char *)(this + 32) = 0;
  return this;
}

uint64_t as::client::SessionState::clearTurnByTurnPref(as::client::SessionState *this)
{
  uint64_t result = *((void *)this + 27);
  *((void *)this + 27) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::client::SessionState::addPortPrefs(as::client::SessionState *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::client::PortPrefs>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210AB569C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::client::SessionState::addIoControllerPrefs(as::client::SessionState *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210AB5808(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::client::PortPrefs::default_instance(as::client::PortPrefs *this)
{
  {
    operator new();
  }
  return as::client::PortPrefs::default_instance(void)::gInstance;
}

void sub_210AB58B8(_Unwind_Exception *a1)
{
}

double as::client::PortPrefs::PortPrefs(as::client::PortPrefs *this)
{
  *(void *)this = &unk_26C3128A0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C3128A0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  return result;
}

void *as::client::PortPrefs::copy_from(as::client::PortPrefs *this, const as::client::PortPrefs *a2)
{
  caulk::xstring::assign((as::client::PortPrefs *)((char *)this + 40), (const as::client::PortPrefs *)((char *)a2 + 40));
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  return result;
}

void sub_210AB5B00(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::client::PortPrefs *as::client::PortPrefs::operator=(as::client::PortPrefs *a1, const as::client::PortPrefs *a2)
{
  return a1;
}

uint64_t as::client::PolarPatternPref::PolarPatternPref(uint64_t result, uint64_t a2)
{
  *(void *)double result = &unk_26C312830;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 12) = *(void *)(a2 + 12);
  return result;
}

{
  *(void *)double result = &unk_26C312830;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 12) = *(void *)(a2 + 12);
  return result;
}

{
  *(void *)double result = &unk_26C312830;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 12) = *(void *)(a2 + 12);
  return result;
}

uint64_t as::client::PortPrefs::PortPrefs(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C3128A0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 48) = 0;
  as::client::PortPrefs::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C3128A0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 48) = 0;
  as::client::PortPrefs::move_from(a1, a2);
  return a1;
}

uint64_t as::client::PortPrefs::move_from(uint64_t a1, uint64_t a2)
{
  v8[0] = 0;
  v8[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)v8);
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v5;
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v6;
  uint64_t v7 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v7;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  return result;
}

uint64_t as::client::PortPrefs::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

void *as::client::PortPrefs::clear(as::client::PortPrefs *this)
{
  caulk::xstring::clear((as::client::PortPrefs *)((char *)this + 40));
  uint64_t result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 14) = 0;
  return result;
}

uint64_t as::client::PolarPatternPref::isInitialized(as::client::PolarPatternPref *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::client::PortPrefs::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v3 + 1;
        a2[1] = v3 + 1;
        char v13 = *(unsigned char *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v3 = v12;
        BOOL v14 = v10++ > 8;
        if (v14)
        {
          unint64_t v11 = 0;
          break;
        }
      }
LABEL_22:
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v21 = v11 >> 3;
      if ((v11 >> 3) == 3) {
        operator new();
      }
      if (v21 == 2)
      {
        if (v12 > 0xFFFFFFFFFFFFFFF5 || v12 + 10 > v2)
        {
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v24 = 0;
          if (v2 <= v12) {
            unint64_t v2 = v12;
          }
          while (v2 != v12)
          {
            unint64_t v29 = v12 + 1;
            char v30 = *(unsigned char *)(v8 + v12);
            a2[1] = v29;
            v24 |= (unint64_t)(v30 & 0x7F) << v27;
            if ((v30 & 0x80) == 0) {
              goto LABEL_43;
            }
            v27 += 7;
            unint64_t v12 = v29;
            BOOL v20 = v28++ >= 9;
            if (v20)
            {
LABEL_41:
              LODWORD(v24) = 0;
              goto LABEL_43;
            }
          }
          LODWORD(v24) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v22 = 0;
          unsigned int v23 = 0;
          uint64_t v24 = 0;
          while (1)
          {
            unint64_t v25 = v12 + 1;
            a2[1] = v12 + 1;
            char v26 = *(unsigned char *)(v8 + v12);
            v24 |= (unint64_t)(v26 & 0x7F) << v22;
            if ((v26 & 0x80) == 0) {
              break;
            }
            v22 += 7;
            unint64_t v12 = v25;
            BOOL v14 = v23++ > 8;
            if (v14) {
              goto LABEL_41;
            }
          }
        }
LABEL_43:
        *(_DWORD *)(a1 + 56) = v24;
        *(_DWORD *)(a1 + 8) |= 2u;
      }
      else if (v21 == 1)
      {
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 1u;
      }
      unint64_t v3 = a2[1];
      unint64_t v2 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v3 <= v2) {
      unint64_t v17 = v2;
    }
    else {
      unint64_t v17 = v3;
    }
    while (v17 != v3)
    {
      unint64_t v18 = v3++;
      char v19 = *(unsigned char *)(v8 + v18);
      a2[1] = v3;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0) {
        goto LABEL_21;
      }
      v15 += 7;
      BOOL v20 = v16++ >= 9;
      if (v20)
      {
        unint64_t v11 = 0;
LABEL_21:
        unint64_t v12 = v18 + 1;
        goto LABEL_22;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210AB6110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::client::PortPrefs::writeTo(as::client::PortPrefs *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    uint64_t v5 = (char *)caulk::xstring::c_str((as::client::PortPrefs *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v10 < 0) {
      operator delete(__p);
    }
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  uint64_t v7 = (const PB::Base **)*((void *)this + 2);
  uint64_t v6 = (const PB::Base **)*((void *)this + 3);
  while (v7 != v6)
  {
    uint64_t v8 = *v7++;
    PB::Writer::writeSubmessage(a2, v8);
  }
}

void sub_210AB6218(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::client::PortPrefs::formatText(as::client::PortPrefs *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::client::PortPrefs *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v12 < 0) {
      operator delete(__p);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "dataSourceID");
  }
  uint64_t v7 = (uint64_t *)*((void *)this + 2);
  uint64_t v8 = (uint64_t *)*((void *)this + 3);
  while (v7 != v8)
  {
    uint64_t v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, a2, "polarPatterns");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AB6324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::client::PortPrefs::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a2 + 56)
    && !caulk::xstring::compare((caulk::xstring *)(a1 + 40), (const caulk::xstring *)(a2 + 40))
    && (uint64_t v6 = a1 + 16,
        uint64_t v5 = *(void *)(a1 + 16),
        uint64_t v4 = *(void *)(v6 + 8),
        unint64_t v7 = (v4 - v5) >> 3,
        uint64_t v8 = *(void *)(a2 + 16),
        v7 == (*(void *)(a2 + 24) - v8) >> 3))
  {
    if (v4 == v5)
    {
      return 1;
    }
    else
    {
      BOOL v9 = 0;
      uint64_t v10 = 0;
      if (v7 <= 1) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = (v4 - v5) >> 3;
      }
      do
      {
        uint64_t v12 = *(void *)(v5 + 8 * v10);
        uint64_t v13 = *(void *)(v8 + 8 * v10);
        if (v12) {
          BOOL v14 = v13 == 0;
        }
        else {
          BOOL v14 = 1;
        }
        if (v14)
        {
          if (v12 | v13) {
            return v9;
          }
        }
        else if (!as::client::PolarPatternPref::operator==(v12, v13))
        {
          return v9;
        }
        BOOL v9 = ++v10 >= v7;
      }
      while (v11 != v10);
    }
  }
  else
  {
    return 0;
  }
  return v9;
}

void as::client::PortPrefs::addPolarPatterns(as::client::PortPrefs *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    v15[3] = &v13[8 * v12];
    *(void *)BOOL v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::client::PolarPatternPref>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210AB6574(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::client::PolarPatternPref::default_instance(as::client::PolarPatternPref *this)
{
  {
    operator new();
  }
  return as::client::PolarPatternPref::default_instance(void)::gInstance;
}

void sub_210AB661C(_Unwind_Exception *a1)
{
}

uint64_t as::client::PolarPatternPref::PolarPatternPref(uint64_t this)
{
  *(void *)this = &unk_26C312830;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 12) = 0;
  return this;
}

{
  *(void *)this = &unk_26C312830;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 12) = 0;
  return this;
}

uint64_t as::client::PolarPatternPref::PolarPatternPref(uint64_t this, const as::client::PolarPatternPref *a2)
{
  *(void *)this = &unk_26C312830;
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  *(void *)(this + 12) = *(void *)((char *)a2 + 12);
  return this;
}

uint64_t as::client::PolarPatternPref::copy_from(uint64_t this, const as::client::PolarPatternPref *a2)
{
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  *(void *)(this + 12) = *(void *)((char *)a2 + 12);
  return this;
}

uint64_t as::client::PolarPatternPref::operator=(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 12) = *(void *)(a2 + 12);
  return result;
}

{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 12) = *(void *)(a2 + 12);
  return result;
}

uint64_t as::client::PolarPatternPref::move_from(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 12) = *(void *)(a2 + 12);
  return result;
}

uint64_t as::client::PolarPatternPref::clear(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 12) = 0;
  return this;
}

BOOL as::client::PolarPatternPref::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0) {
    return v4 == 0;
  }
  uint64_t v6 = *a2;
  while (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
  {
    char v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v10 = v3 + 1;
      a2[1] = v3 + 1;
      char v11 = *(unsigned char *)(v6 + v3);
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0) {
        break;
      }
      v7 += 7;
      unint64_t v3 = v10;
      BOOL v12 = v8++ > 8;
      if (v12)
      {
        unint64_t v9 = 0;
        break;
      }
    }
    unint64_t v3 = v10;
LABEL_24:
    if ((v9 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v20 = v9 >> 3;
    if ((v9 >> 3) == 2)
    {
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        char v27 = 0;
        unsigned int v28 = 0;
        uint64_t v23 = 0;
        while (1)
        {
          unint64_t v24 = v3 + 1;
          a2[1] = v3 + 1;
          char v29 = *(unsigned char *)(v6 + v3);
          v23 |= (unint64_t)(v29 & 0x7F) << v27;
          if ((v29 & 0x80) == 0) {
            break;
          }
          v27 += 7;
          unint64_t v3 = v24;
          BOOL v12 = v28++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
            break;
          }
        }
        LODWORD(v20) = 2;
        char v26 = a1 + 4;
LABEL_64:
        unint64_t v3 = v24;
LABEL_65:
        _DWORD *v26 = v23;
        a1[2] |= v20;
        goto LABEL_66;
      }
      char v35 = 0;
      unsigned int v36 = 0;
      uint64_t v23 = 0;
      uint64_t v37 = *a2;
      if (v3 <= v2) {
        unint64_t v24 = v2;
      }
      else {
        unint64_t v24 = v3;
      }
      while (v24 != v3)
      {
        unint64_t v38 = v3++;
        char v39 = *(unsigned char *)(v37 + v38);
        a2[1] = v3;
        v23 |= (unint64_t)(v39 & 0x7F) << v35;
        if ((v39 & 0x80) == 0) {
          goto LABEL_60;
        }
        v35 += 7;
        BOOL v12 = v36++ > 8;
        if (v12)
        {
          LODWORD(v23) = 0;
LABEL_60:
          unint64_t v3 = v38 + 1;
          LODWORD(v20) = 2;
          char v26 = a1 + 4;
          goto LABEL_65;
        }
      }
      char v26 = a1 + 4;
LABEL_63:
      LODWORD(v23) = 0;
      *((unsigned char *)a2 + 24) = 1;
      goto LABEL_64;
    }
    if (v20 == 1)
    {
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0;
        while (1)
        {
          unint64_t v24 = v3 + 1;
          a2[1] = v3 + 1;
          char v25 = *(unsigned char *)(v6 + v3);
          v23 |= (unint64_t)(v25 & 0x7F) << v21;
          if ((v25 & 0x80) == 0) {
            break;
          }
          v21 += 7;
          unint64_t v3 = v24;
          BOOL v12 = v22++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
            break;
          }
        }
        LODWORD(v20) = 1;
        char v26 = a1 + 3;
        goto LABEL_64;
      }
      char v30 = 0;
      unsigned int v31 = 0;
      uint64_t v23 = 0;
      uint64_t v32 = *a2;
      if (v3 <= v2) {
        unint64_t v24 = v2;
      }
      else {
        unint64_t v24 = v3;
      }
      while (v24 != v3)
      {
        unint64_t v33 = v3++;
        char v34 = *(unsigned char *)(v32 + v33);
        a2[1] = v3;
        v23 |= (unint64_t)(v34 & 0x7F) << v30;
        if ((v34 & 0x80) == 0) {
          goto LABEL_51;
        }
        v30 += 7;
        BOOL v12 = v31++ > 8;
        if (v12)
        {
          LODWORD(v23) = 0;
LABEL_51:
          unint64_t v3 = v33 + 1;
          LODWORD(v20) = 1;
          char v26 = a1 + 3;
          goto LABEL_65;
        }
      }
      char v26 = a1 + 3;
      goto LABEL_63;
    }
LABEL_66:
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
      return v4 == 0;
    }
  }
  char v13 = 0;
  unsigned int v14 = 0;
  unint64_t v9 = 0;
  uint64_t v15 = *a2;
  if (v3 <= v2) {
    unint64_t v16 = v2;
  }
  else {
    unint64_t v16 = v3;
  }
  while (v16 != v3)
  {
    unint64_t v17 = v3++;
    char v18 = *(unsigned char *)(v15 + v17);
    a2[1] = v3;
    v9 |= (unint64_t)(v18 & 0x7F) << v13;
    if ((v18 & 0x80) == 0) {
      goto LABEL_23;
    }
    v13 += 7;
    if (v14++ >= 9)
    {
      unint64_t v9 = 0;
LABEL_23:
      unint64_t v3 = v17 + 1;
      goto LABEL_24;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

uint64_t as::client::PolarPatternPref::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::writeVarInt(a2);
    int v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0)
  {
    return PB::Writer::writeVarInt(a2);
  }
  return this;
}

uint64_t as::client::PolarPatternPref::formatText(as::client::PolarPatternPref *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "dataSourceID");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "polarPattern");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::client::PolarPatternPref::operator==(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8) && *(void *)(a1 + 12) == *(void *)(a2 + 12);
}

uint64_t as::client::IOControllerPrefs::default_instance(as::client::IOControllerPrefs *this)
{
  {
    operator new();
  }
  return as::client::IOControllerPrefs::default_instance(void)::gInstance;
}

void sub_210AB6C14(_Unwind_Exception *a1)
{
}

double as::client::IOControllerPrefs::IOControllerPrefs(as::client::IOControllerPrefs *this)
{
  *(void *)this = &unk_26C312868;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312868;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  return result;
}

__n128 as::client::IOControllerPrefs::copy_from(__n128 *this, __n128 *a2)
{
  caulk::xstring::assign((caulk::xstring *)&this[4], (const caulk::xstring *)&a2[4]);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((__n128 *)this[1].n128_u64);
  if (a2[1].n128_u64[0] != a2[1].n128_u64[1]) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100](&this[2].n128_u64[1]);
  if (a2[2].n128_u64[1] != a2[3].n128_u64[0]) {
    operator new();
  }
  this->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[5];
  __n128 v5 = a2[6];
  this[5] = result;
  this[6] = v5;
  return result;
}

void sub_210AB6F68(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

__n128 *as::client::IOControllerPrefs::operator=(__n128 *a1, __n128 *a2)
{
  return a1;
}

as::client::StreamPrefs *as::client::StreamPrefs::StreamPrefs(as::client::StreamPrefs *this, const as::client::StreamPrefs *a2)
{
  *(void *)this = &unk_26C312788;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::client::StreamPrefs::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312788;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::client::StreamPrefs::copy_from(this, a2);
  return this;
}

uint64_t as::client::IOControllerPrefs::IOControllerPrefs(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312868;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  as::client::IOControllerPrefs::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312868;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  as::client::IOControllerPrefs::move_from(a1, a2);
  return a1;
}

__n128 as::client::IOControllerPrefs::move_from(uint64_t a1, uint64_t a2)
{
  v12[0] = 0;
  v12[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)v12);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  uint64_t v7 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v7;
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v8;
  uint64_t v9 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v9;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 80);
  long long v11 = *(_OWORD *)(a2 + 96);
  *(__n128 *)(a1 + 80) = result;
  *(_OWORD *)(a1 + 96) = v11;
  return result;
}

uint64_t as::client::IOControllerPrefs::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

double as::client::IOControllerPrefs::clear(as::client::IOControllerPrefs *this)
{
  caulk::xstring::clear((as::client::IOControllerPrefs *)((char *)this + 64));
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  return result;
}

uint64_t as::client::StreamPrefs::isInitialized(as::client::StreamPrefs *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::client::IOControllerPrefs::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v15 = 0;
        unsigned int v16 = 0;
        unint64_t v11 = 0;
        if (v3 <= v2) {
          unint64_t v17 = v2;
        }
        else {
          unint64_t v17 = v3;
        }
        while (v17 != v3)
        {
          unint64_t v18 = v3++;
          char v19 = *(unsigned char *)(v8 + v18);
          a2[1] = v3;
          v11 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0) {
            goto LABEL_21;
          }
          v15 += 7;
          BOOL v20 = v16++ >= 9;
          if (v20)
          {
            unint64_t v11 = 0;
LABEL_21:
            unint64_t v12 = v18 + 1;
            goto LABEL_22;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v9 = 0;
        unsigned int v10 = 0;
        unint64_t v11 = 0;
        while (1)
        {
          unint64_t v12 = v3 + 1;
          a2[1] = v3 + 1;
          char v13 = *(unsigned char *)(v8 + v3);
          v11 |= (unint64_t)(v13 & 0x7F) << v9;
          if ((v13 & 0x80) == 0) {
            break;
          }
          v9 += 7;
          unint64_t v3 = v12;
          BOOL v14 = v10++ > 8;
          if (v14)
          {
            unint64_t v11 = 0;
            break;
          }
        }
LABEL_22:
        if ((v11 & 7) != 4)
        {
          switch((v11 >> 3))
          {
            case 1u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v21 = 0;
                unsigned int v22 = 0;
                uint64_t v23 = 0;
                do
                {
                  unint64_t v24 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v25 = *(unsigned char *)(v8 + v12);
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if ((v25 & 0x80) == 0) {
                    goto LABEL_87;
                  }
                  v21 += 7;
                  unint64_t v12 = v24;
                  BOOL v14 = v22++ > 8;
                }
                while (!v14);
LABEL_70:
                LODWORD(v23) = 0;
                goto LABEL_87;
              }
              char v40 = 0;
              unsigned int v41 = 0;
              uint64_t v23 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v42 = v12 + 1;
                char v43 = *(unsigned char *)(v8 + v12);
                a2[1] = v42;
                v23 |= (unint64_t)(v43 & 0x7F) << v40;
                if ((v43 & 0x80) == 0) {
                  goto LABEL_87;
                }
                v40 += 7;
                unint64_t v12 = v42;
                BOOL v20 = v41++ >= 9;
                if (v20) {
                  goto LABEL_70;
                }
              }
              LODWORD(v23) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_87:
              *(_DWORD *)(a1 + 100) = v23;
              int v48 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_90;
            case 2u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v31 = 0;
                unsigned int v32 = 0;
                uint64_t v33 = 0;
                do
                {
                  unint64_t v34 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v35 = *(unsigned char *)(v8 + v12);
                  v33 |= (unint64_t)(v35 & 0x7F) << v31;
                  if ((v35 & 0x80) == 0) {
                    goto LABEL_89;
                  }
                  v31 += 7;
                  unint64_t v12 = v34;
                  BOOL v14 = v32++ > 8;
                }
                while (!v14);
LABEL_77:
                LODWORD(v33) = 0;
                goto LABEL_89;
              }
              char v44 = 0;
              unsigned int v45 = 0;
              uint64_t v33 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v46 = v12 + 1;
                char v47 = *(unsigned char *)(v8 + v12);
                a2[1] = v46;
                v33 |= (unint64_t)(v47 & 0x7F) << v44;
                if ((v47 & 0x80) == 0) {
                  goto LABEL_89;
                }
                v44 += 7;
                unint64_t v12 = v46;
                BOOL v20 = v45++ >= 9;
                if (v20) {
                  goto LABEL_77;
                }
              }
              LODWORD(v33) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_89:
              *(_DWORD *)(a1 + 108) = v33;
              int v48 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_90;
            case 4u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v26 = 0;
                unsigned int v27 = 0;
                uint64_t v28 = 0;
                do
                {
                  unint64_t v29 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v30 = *(unsigned char *)(v8 + v12);
                  v28 |= (unint64_t)(v30 & 0x7F) << v26;
                  if ((v30 & 0x80) == 0) {
                    goto LABEL_85;
                  }
                  v26 += 7;
                  unint64_t v12 = v29;
                  BOOL v14 = v27++ > 8;
                }
                while (!v14);
LABEL_63:
                LODWORD(v28) = 0;
                goto LABEL_85;
              }
              char v36 = 0;
              unsigned int v37 = 0;
              uint64_t v28 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v38 = v12 + 1;
                char v39 = *(unsigned char *)(v8 + v12);
                a2[1] = v38;
                v28 |= (unint64_t)(v39 & 0x7F) << v36;
                if ((v39 & 0x80) == 0) {
                  goto LABEL_85;
                }
                v36 += 7;
                unint64_t v12 = v38;
                BOOL v20 = v37++ >= 9;
                if (v20) {
                  goto LABEL_63;
                }
              }
              LODWORD(v28) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_85:
              *(_DWORD *)(a1 + 104) = v28;
              int v48 = *(_DWORD *)(a1 + 8) | 4;
LABEL_90:
              *(_DWORD *)(a1 + 8) = v48;
LABEL_91:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 5u:
              PB::Reader::read();
              caulk::xstring::assign();
              *(_DWORD *)(a1 + 8) |= 0x40u;
              goto LABEL_91;
            case 6u:
              operator new();
            case 7u:
              operator new();
            case 8u:
              if (v12 > 0xFFFFFFFFFFFFFFF7 || v12 + 8 > v2)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(void *)(a1 + 80) = *(void *)(v8 + v12);
                a2[1] += 8;
              }
              int v48 = *(_DWORD *)(a1 + 8) | 8;
              goto LABEL_90;
            case 9u:
              if (v12 > 0xFFFFFFFFFFFFFFF7 || v12 + 8 > v2)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(void *)(a1 + 88) = *(void *)(v8 + v12);
                a2[1] += 8;
              }
              int v48 = *(_DWORD *)(a1 + 8) | 0x10;
              goto LABEL_90;
            case 0xAu:
              if (v12 > 0xFFFFFFFFFFFFFFFBLL || v12 + 4 > v2)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(_DWORD *)(a1 + 96) = *(_DWORD *)(v8 + v12);
                a2[1] += 4;
              }
              int v48 = *(_DWORD *)(a1 + 8) | 0x20;
              goto LABEL_90;
            default:
              goto LABEL_91;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AB793C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::client::IOControllerPrefs::writeTo(as::client::IOControllerPrefs *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  PB::Writer::write(a2, *((double *)this + 10));
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0) {
      goto LABEL_7;
    }
LABEL_14:
    PB::Writer::write(a2, *((float *)this + 24));
    if ((*((_DWORD *)this + 2) & 0x40) == 0) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
LABEL_13:
  PB::Writer::write(a2, *((double *)this + 11));
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x20) != 0) {
    goto LABEL_14;
  }
LABEL_7:
  if ((v4 & 0x40) == 0) {
    goto LABEL_17;
  }
LABEL_15:
  uint64_t v5 = (char *)caulk::xstring::c_str((as::client::IOControllerPrefs *)((char *)this + 64));
  std::string::basic_string[abi:ne180100]<0>(&__p, v5);
  PB::Writer::write();
  if (v13 < 0) {
    operator delete(__p);
  }
LABEL_17:
  uint64_t v6 = (const PB::Base **)*((void *)this + 2);
  uint64_t v7 = (const PB::Base **)*((void *)this + 3);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    PB::Writer::writeSubmessage(a2, v8);
  }
  unsigned int v10 = (const PB::Base **)*((void *)this + 5);
  char v9 = (const PB::Base **)*((void *)this + 6);
  while (v10 != v9)
  {
    unint64_t v11 = *v10++;
    PB::Writer::writeSubmessage(a2, v11);
  }
}

void sub_210AB7B2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::client::IOControllerPrefs::formatText(as::client::IOControllerPrefs *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "sessionToken");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "controllerType");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  PB::TextFormatter::format(a2, "IOBufferFrameSize");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  PB::TextFormatter::format(a2, "frameSizeSampleRate", *((double *)this + 10));
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_14;
  }
LABEL_13:
  PB::TextFormatter::format(a2, "IOBufferDuration", *((double *)this + 11));
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0) {
      goto LABEL_17;
    }
    goto LABEL_15;
  }
LABEL_14:
  PB::TextFormatter::format(a2, "IOUtilization", *((float *)this + 24));
  if ((*((_DWORD *)this + 2) & 0x40) == 0) {
    goto LABEL_17;
  }
LABEL_15:
  uint64_t v6 = (char *)caulk::xstring::c_str((as::client::IOControllerPrefs *)((char *)this + 64));
  std::string::basic_string[abi:ne180100]<0>(&__p, v6);
  PB::TextFormatter::format();
  if (v15 < 0) {
    operator delete(__p);
  }
LABEL_17:
  uint64_t v7 = (uint64_t *)*((void *)this + 2);
  uint64_t v8 = (uint64_t *)*((void *)this + 3);
  while (v7 != v8)
  {
    uint64_t v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, a2, "inputStreamPrefs");
  }
  unsigned int v10 = (uint64_t *)*((void *)this + 5);
  unint64_t v11 = (uint64_t *)*((void *)this + 6);
  while (v10 != v11)
  {
    uint64_t v12 = *v10++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v12 + 32))(v12, a2, "outputStreamPrefs");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AB7D34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::client::IOControllerPrefs::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  BOOL v4 = *(void *)(a1 + 80) == *(void *)(a2 + 80) && *(void *)(a1 + 88) == *(void *)(a2 + 88);
  BOOL v5 = v4 && *(void *)(a1 + 96) == *(void *)(a2 + 96);
  if (!v5 || *(void *)(a1 + 104) != *(void *)(a2 + 104)) {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 64), (const caulk::xstring *)(a2 + 64))) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  unint64_t v9 = (v7 - v8) >> 3;
  if (v9 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3) {
    return 0;
  }
  if (v7 != v8)
  {
    uint64_t v10 = 0;
    if (v9 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = (v7 - v8) >> 3;
    }
    do
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 16) + 8 * v10);
      uint64_t v13 = *(void *)(*(void *)(a2 + 16) + 8 * v10);
      if (v12) {
        BOOL v14 = v13 == 0;
      }
      else {
        BOOL v14 = 1;
      }
      if (v14)
      {
        if (v12 | v13) {
          return 0;
        }
      }
      else if (!as::client::StreamPrefs::operator==(v12, v13))
      {
        return 0;
      }
      ++v10;
    }
    while (v11 != v10);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v15 = *(void *)(a1 + 48);
  unint64_t v17 = (v15 - v16) >> 3;
  if (v17 == (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3)
  {
    if (v15 == v16)
    {
      return 1;
    }
    else
    {
      BOOL v18 = 0;
      uint64_t v19 = 0;
      if (v17 <= 1) {
        uint64_t v20 = 1;
      }
      else {
        uint64_t v20 = (v15 - v16) >> 3;
      }
      do
      {
        uint64_t v21 = *(void *)(*(void *)(a1 + 40) + 8 * v19);
        uint64_t v22 = *(void *)(*(void *)(a2 + 40) + 8 * v19);
        if (v21) {
          BOOL v23 = v22 == 0;
        }
        else {
          BOOL v23 = 1;
        }
        if (v23)
        {
          if (v21 | v22) {
            return v18;
          }
        }
        else if (!as::client::StreamPrefs::operator==(v21, v22))
        {
          return v18;
        }
        BOOL v18 = ++v19 >= v17;
      }
      while (v20 != v19);
    }
  }
  else
  {
    return 0;
  }
  return v18;
}

void as::client::IOControllerPrefs::addInputStreamPrefs(as::client::IOControllerPrefs *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  BOOL v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    v15[3] = &v13[8 * v12];
    *(void *)BOOL v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::client::StreamPrefs>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *BOOL v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210AB8018(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::client::IOControllerPrefs::addOutputStreamPrefs(as::client::IOControllerPrefs *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  BOOL v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    v15[3] = &v13[8 * v12];
    *(void *)BOOL v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::client::StreamPrefs>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *BOOL v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210AB8184(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::client::StreamPrefs::default_instance(as::client::StreamPrefs *this)
{
  {
    operator new();
  }
  return as::client::StreamPrefs::default_instance(void)::gInstance;
}

void sub_210AB8238(_Unwind_Exception *a1)
{
}

double as::client::StreamPrefs::StreamPrefs(as::client::StreamPrefs *this)
{
  *(void *)this = &unk_26C312788;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312788;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 0;
  return result;
}

__n128 as::client::StreamPrefs::copy_from(as::client::StreamPrefs *this, const as::client::StreamPrefs *a2)
{
  unint64_t v4 = (const as::StreamFormat *)*((void *)a2 + 5);
  if (v4)
  {
    BOOL v5 = (as::StreamFormat *)as::client::StreamPrefs::mutableStreamFormat(this);
    as::StreamFormat::operator=(v5, v4);
  }
  if (this != a2) {
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 16, *((caulk::xstring **)a2 + 2), *((caulk::xstring **)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 4);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *((__n128 *)a2 + 3);
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((__n128 *)this + 3) = result;
  return result;
}

as::client::StreamPrefs *as::client::StreamPrefs::operator=(as::client::StreamPrefs *a1, const as::client::StreamPrefs *a2)
{
  return a1;
}

uint64_t as::client::StreamPrefs::streamFormat(as::client::StreamPrefs *this)
{
  uint64_t result = *((void *)this + 5);
  if (!result) {
    return as::StreamFormat::default_instance(0);
  }
  return result;
}

uint64_t as::client::StreamPrefs::mutableStreamFormat(as::client::StreamPrefs *this)
{
  if (!*((void *)this + 5)) {
    operator new();
  }
  return *((void *)this + 5);
}

__n128 as::client::StreamPrefs::StreamPrefs(__n128 *a1, __n128 *a2)
{
  a1->n128_u64[0] = (unint64_t)&unk_26C312788;
  a1[1] = 0u;
  a1[2] = 0u;
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = 0;
  unint64_t v2 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v2;
  unint64_t v3 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v3;
  unint64_t v4 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v4;
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&unk_26C312788;
  a1[1] = 0u;
  a1[2] = 0u;
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = 0;
  unint64_t v2 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v2;
  unint64_t v3 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v3;
  unint64_t v4 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v4;
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

__n128 as::client::StreamPrefs::move_from(__n128 *a1, __n128 *a2)
{
  unint64_t v2 = a1[2].n128_u64[1];
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = v2;
  unint64_t v3 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v3;
  unint64_t v4 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v4;
  unint64_t v5 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v5;
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

__n128 as::client::StreamPrefs::operator=(__n128 *a1, __n128 *a2)
{
  unint64_t v2 = a1[2].n128_u64[1];
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = v2;
  unint64_t v3 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v3;
  unint64_t v4 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v4;
  unint64_t v5 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v5;
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[3];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a1[3] = result;
  return result;
}

uint64_t as::client::StreamPrefs::clear(as::client::StreamPrefs *this)
{
  uint64_t v2 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v4 = (caulk::xstring *)*((void *)this + 2);
  unint64_t v3 = (char *)this + 16;
  uint64_t result = std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v3, v4);
  *((_DWORD *)v3 - 2) = 0;
  *((void *)v3 + 4) = 0;
  *((void *)v3 + 5) = 0;
  *((_DWORD *)v3 + 12) = 0;
  return result;
}

BOOL as::client::StreamPrefs::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    uint64_t v8 = (uint64_t *)(a1 + 16);
    uint64_t v9 = a1 + 32;
    while (2)
    {
      uint64_t v10 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        unint64_t v13 = 0;
        if (v3 <= v2) {
          unint64_t v19 = v2;
        }
        else {
          unint64_t v19 = v3;
        }
        while (v19 != v3)
        {
          unint64_t v20 = v3++;
          char v21 = *(unsigned char *)(v10 + v20);
          a2[1] = v3;
          v13 |= (unint64_t)(v21 & 0x7F) << v17;
          if ((v21 & 0x80) == 0) {
            goto LABEL_22;
          }
          v17 += 7;
          BOOL v22 = v18++ >= 9;
          if (v22)
          {
            unint64_t v13 = 0;
LABEL_22:
            unint64_t v14 = v20 + 1;
            goto LABEL_23;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v11 = 0;
        unsigned int v12 = 0;
        unint64_t v13 = 0;
        while (1)
        {
          unint64_t v14 = v3 + 1;
          a2[1] = v3 + 1;
          char v15 = *(unsigned char *)(v10 + v3);
          v13 |= (unint64_t)(v15 & 0x7F) << v11;
          if ((v15 & 0x80) == 0) {
            break;
          }
          v11 += 7;
          unint64_t v3 = v14;
          BOOL v16 = v12++ > 8;
          if (v16)
          {
            unint64_t v13 = 0;
            break;
          }
        }
LABEL_23:
        if ((v13 & 7) != 4)
        {
          switch((v13 >> 3))
          {
            case 1u:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v23 = 0;
                unsigned int v24 = 0;
                uint64_t v25 = 0;
                do
                {
                  unint64_t v26 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v27 = *(unsigned char *)(v10 + v14);
                  v25 |= (unint64_t)(v27 & 0x7F) << v23;
                  if ((v27 & 0x80) == 0) {
                    goto LABEL_88;
                  }
                  v23 += 7;
                  unint64_t v14 = v26;
                  BOOL v16 = v24++ > 8;
                }
                while (!v16);
LABEL_58:
                LODWORD(v25) = 0;
                goto LABEL_88;
              }
              char v41 = 0;
              unsigned int v42 = 0;
              uint64_t v25 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v43 = v14 + 1;
                char v44 = *(unsigned char *)(v10 + v14);
                a2[1] = v43;
                v25 |= (unint64_t)(v44 & 0x7F) << v41;
                if ((v44 & 0x80) == 0) {
                  goto LABEL_88;
                }
                v41 += 7;
                unint64_t v14 = v43;
                BOOL v22 = v42++ >= 9;
                if (v22) {
                  goto LABEL_58;
                }
              }
              LODWORD(v25) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_88:
              *(_DWORD *)(a1 + 56) = v25;
              int v49 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_93;
            case 3u:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v28 = 0;
                unsigned int v29 = 0;
                uint64_t v30 = 0;
                do
                {
                  unint64_t v31 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v32 = *(unsigned char *)(v10 + v14);
                  v30 |= (unint64_t)(v32 & 0x7F) << v28;
                  if ((v32 & 0x80) == 0) {
                    goto LABEL_90;
                  }
                  v28 += 7;
                  unint64_t v14 = v31;
                  BOOL v16 = v29++ > 8;
                }
                while (!v16);
LABEL_65:
                LODWORD(v30) = 0;
                goto LABEL_90;
              }
              char v45 = 0;
              unsigned int v46 = 0;
              uint64_t v30 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v47 = v14 + 1;
                char v48 = *(unsigned char *)(v10 + v14);
                a2[1] = v47;
                v30 |= (unint64_t)(v48 & 0x7F) << v45;
                if ((v48 & 0x80) == 0) {
                  goto LABEL_90;
                }
                v45 += 7;
                unint64_t v14 = v47;
                BOOL v22 = v46++ >= 9;
                if (v22) {
                  goto LABEL_65;
                }
              }
              LODWORD(v30) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_90:
              *(_DWORD *)(a1 + 60) = v30;
              int v49 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_93;
            case 5u:
              operator new();
            case 6u:
              if (v14 > 0xFFFFFFFFFFFFFFF7 || v14 + 8 > v2)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(void *)(a1 + 48) = *(void *)(v10 + v14);
                a2[1] += 8;
              }
              int v49 = *(_DWORD *)(a1 + 8) | 4;
              goto LABEL_93;
            case 7u:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v33 = 0;
                unsigned int v34 = 0;
                uint64_t v35 = 0;
                do
                {
                  unint64_t v36 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v37 = *(unsigned char *)(v10 + v14);
                  v35 |= (unint64_t)(v37 & 0x7F) << v33;
                  if ((v37 & 0x80) == 0) {
                    goto LABEL_92;
                  }
                  v33 += 7;
                  unint64_t v14 = v36;
                  BOOL v16 = v34++ > 8;
                }
                while (!v16);
LABEL_74:
                LODWORD(v35) = 0;
                goto LABEL_92;
              }
              char v50 = 0;
              unsigned int v51 = 0;
              uint64_t v35 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v52 = v14 + 1;
                char v53 = *(unsigned char *)(v10 + v14);
                a2[1] = v52;
                v35 |= (unint64_t)(v53 & 0x7F) << v50;
                if ((v53 & 0x80) == 0) {
                  goto LABEL_92;
                }
                v50 += 7;
                unint64_t v14 = v52;
                BOOL v22 = v51++ >= 9;
                if (v22) {
                  goto LABEL_74;
                }
              }
              LODWORD(v35) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_92:
              *(_DWORD *)(a1 + 64) = v35;
              int v49 = *(_DWORD *)(a1 + 8) | 8;
LABEL_93:
              *(_DWORD *)(a1 + 8) = v49;
LABEL_94:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 9u:
              char v39 = *(void **)(a1 + 24);
              unint64_t v38 = *(void *)(a1 + 32);
              if ((unint64_t)v39 >= v38)
              {
                uint64_t v54 = ((uint64_t)v39 - *v8) >> 4;
                unint64_t v55 = v54 + 1;
                if ((unint64_t)(v54 + 1) >> 60) {
                  std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v56 = v38 - *v8;
                if (v56 >> 3 > v55) {
                  unint64_t v55 = v56 >> 3;
                }
                if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v57 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v57 = v55;
                }
                uint64_t v66 = v9;
                if (v57) {
                  char v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v57);
                }
                else {
                  char v58 = 0;
                }
                char v59 = &v58[16 * v54];
                __p = v58;
                char v63 = v59;
                unsigned int v65 = &v58[16 * v57];
                *(void *)char v59 = 0;
                *((void *)v59 + 1) = 0;
                char v64 = v59 + 16;
                std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
                char v40 = *(void **)(a1 + 24);
                std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
              }
              else
              {
                *char v39 = 0;
                v39[1] = 0;
                char v40 = v39 + 2;
                *(void *)(a1 + 24) = v39 + 2;
              }
              *(void *)(a1 + 24) = v40;
              __p = 0;
              char v63 = 0;
              char v64 = 0;
              PB::Reader::read();
              caulk::xstring::assign();
              if (SHIBYTE(v64) < 0) {
                operator delete(__p);
              }
              goto LABEL_94;
            default:
              goto LABEL_94;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AB8BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void as::client::StreamPrefs::writeTo(as::client::StreamPrefs *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  unint64_t v5 = (const PB::Base *)*((void *)this + 5);
  if (v5) {
    PB::Writer::writeSubmessage(a2, v5);
  }
  int v6 = *((_DWORD *)this + 2);
  if ((v6 & 4) != 0)
  {
    PB::Writer::write(a2, *((double *)this + 6));
    int v6 = *((_DWORD *)this + 2);
  }
  if ((v6 & 8) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  uint64_t v8 = (caulk::xstring *)*((void *)this + 2);
  uint64_t v7 = (caulk::xstring *)*((void *)this + 3);
  while (v8 != v7)
  {
    uint64_t v9 = (char *)caulk::xstring::c_str(v8);
    std::string::basic_string[abi:ne180100]<0>(&__p, v9);
    PB::Writer::write();
    if (v11 < 0) {
      operator delete(__p);
    }
    uint64_t v8 = (caulk::xstring *)((char *)v8 + 16);
  }
}

void sub_210AB8D30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::client::StreamPrefs::formatText(as::client::StreamPrefs *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "streamToken");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "DSPFlavor");
  }
  uint64_t v6 = *((void *)this + 5);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, a2, "streamFormat");
  }
  int v7 = *((_DWORD *)this + 2);
  if ((v7 & 4) != 0)
  {
    PB::TextFormatter::format(a2, "scalarVolume", *((double *)this + 6));
    int v7 = *((_DWORD *)this + 2);
  }
  if ((v7 & 8) != 0) {
    PB::TextFormatter::format(a2, "muteState");
  }
  uint64_t v8 = (caulk::xstring *)*((void *)this + 2);
  for (i = (caulk::xstring *)*((void *)this + 3); v8 != i; uint64_t v8 = (caulk::xstring *)((char *)v8 + 16))
  {
    uint64_t v10 = (char *)caulk::xstring::c_str(v8);
    std::string::basic_string[abi:ne180100]<0>(&__p, v10);
    PB::TextFormatter::format();
    if (v13 < 0) {
      operator delete(__p);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AB8E90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::client::StreamPrefs::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  BOOL v4 = *(void *)(a1 + 48) == *(void *)(a2 + 48) && *(void *)(a1 + 56) == *(void *)(a2 + 56);
  if (!v4 || *(_DWORD *)(a1 + 64) != (unint64_t)*(unsigned int *)(a2 + 64)) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(a2 + 40);
  if (v7 && v8)
  {
    if (!as::StreamFormat::operator==(v7, v8)) {
      return 0;
    }
  }
  else if (v7 | v8)
  {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(a1 + 24);
  unint64_t v11 = (v9 - v10) >> 4;
  if (v11 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 4) {
    return 0;
  }
  if (v9 == v10) {
    return 1;
  }
  uint64_t v12 = v11 <= 1 ? 1 : (v9 - v10) >> 4;
  if (caulk::xstring::compare(*(caulk::xstring **)(a1 + 16), *(const caulk::xstring **)(a2 + 16))) {
    return 0;
  }
  uint64_t v13 = 1;
  uint64_t v14 = 16;
  do
  {
    unint64_t v15 = v13;
    if (v12 == v13) {
      break;
    }
    int v16 = caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 16) + v14), (const caulk::xstring *)(*(void *)(a2 + 16) + v14));
    uint64_t v13 = v15 + 1;
    v14 += 16;
  }
  while (!v16);
  return v15 >= v11;
}

uint64_t as::client::StreamPrefs::clearStreamFormat(as::client::StreamPrefs *this)
{
  uint64_t result = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

as::client::TurnByTurnPref *as::client::TurnByTurnPref::TurnByTurnPref(as::client::TurnByTurnPref *this, const as::client::TurnByTurnPref *a2)
{
  *(void *)this = &unk_26C3127F8;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::client::TurnByTurnPref::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3127F8;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::client::TurnByTurnPref::copy_from(this, a2);
  return this;
}

uint64_t as::client::TurnByTurnPref::copy_from(as::client::TurnByTurnPref *this, const as::client::TurnByTurnPref *a2)
{
  uint64_t result = caulk::xstring::assign((as::client::TurnByTurnPref *)((char *)this + 16), (const as::client::TurnByTurnPref *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((unsigned char *)this + 32) = *((unsigned char *)a2 + 32);
  return result;
}

void *as::client::TurnByTurnPref::TurnByTurnPref(void *a1, uint64_t a2)
{
  *a1 = &unk_26C3127F8;
  a1[2] = 0;
  a1[3] = 0;
  as::client::TurnByTurnPref::move_from((uint64_t)a1, a2);
  return a1;
}

{
  *a1 = &unk_26C3127F8;
  a1[2] = 0;
  a1[3] = 0;
  as::client::TurnByTurnPref::move_from((uint64_t)a1, a2);
  return a1;
}

uint64_t as::client::TurnByTurnPref::move_from(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)v5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  return result;
}

uint64_t as::client::TurnByTurnPref::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::client::TurnByTurnPref::clear(as::client::TurnByTurnPref *this)
{
  uint64_t result = caulk::xstring::clear((as::client::TurnByTurnPref *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 32) = 0;
  return result;
}

BOOL as::client::TurnByTurnPref::isInitialized(as::client::TurnByTurnPref *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::client::TurnByTurnPref::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v3 + 1;
        a2[1] = v3 + 1;
        char v13 = *(unsigned char *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v3 = v12;
        if (v10++ > 8)
        {
          unint64_t v11 = 0;
          break;
        }
      }
      unint64_t v3 = v12;
LABEL_23:
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v21 = v11 >> 3;
      if (v21 == 2)
      {
        if (v3 >= v2)
        {
          BOOL v23 = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          int v22 = *(unsigned __int8 *)(v8 + v3++);
          a2[1] = v3;
          BOOL v23 = v22 != 0;
        }
        *(unsigned char *)(a1 + 32) = v23;
        *(_DWORD *)(a1 + 8) |= 2u;
      }
      else if (v21 == 1)
      {
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 1u;
        unint64_t v3 = a2[1];
        unint64_t v2 = a2[2];
      }
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v3 <= v2) {
      unint64_t v17 = v2;
    }
    else {
      unint64_t v17 = v3;
    }
    while (v17 != v3)
    {
      unint64_t v18 = v3++;
      char v19 = *(unsigned char *)(v8 + v18);
      a2[1] = v3;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      if (v16++ >= 9)
      {
        unint64_t v11 = 0;
LABEL_22:
        unint64_t v3 = v18 + 1;
        goto LABEL_23;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210AB9454(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::client::TurnByTurnPref::writeTo(as::client::TurnByTurnPref *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    int v5 = (char *)caulk::xstring::c_str((as::client::TurnByTurnPref *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v7 < 0) {
      operator delete(__p);
    }
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0) {
    PB::Writer::write(a2);
  }
}

void sub_210AB94F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::client::TurnByTurnPref::formatText(as::client::TurnByTurnPref *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::client::TurnByTurnPref *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v9 < 0) {
      operator delete(__p);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "allowed");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AB95A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::client::TurnByTurnPref::operator==(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a2 + 32)
      && caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
}

void as::client::SessionState::~SessionState(as::client::SessionState *this)
{
  as::client::SessionState::~SessionState(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  void **v4;

  *(void *)this = &unk_26C3127C0;
  unint64_t v2 = *((void *)this + 27);
  *((void *)this + 27) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 192));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 176));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 160));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 144));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 128));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 112));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 96));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 80));
  caulk::xstring::clear((as::client::SessionState *)((char *)this + 64));
  int v4 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v4);
  int v4 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v4);
  PB::Base::~Base(this);
}

void as::client::PortPrefs::~PortPrefs(as::client::PortPrefs *this)
{
  as::client::PortPrefs::~PortPrefs(this);
  JUMPOUT(0x21667A2D0);
}

{
  void **v2;

  *(void *)this = &unk_26C3128A0;
  caulk::xstring::clear((as::client::PortPrefs *)((char *)this + 40));
  unint64_t v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

void as::client::PolarPatternPref::~PolarPatternPref(as::client::PolarPatternPref *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x21667A2D0);
}

void as::client::IOControllerPrefs::~IOControllerPrefs(as::client::IOControllerPrefs *this)
{
  as::client::IOControllerPrefs::~IOControllerPrefs(this);
  JUMPOUT(0x21667A2D0);
}

{
  void **v2;

  *(void *)this = &unk_26C312868;
  caulk::xstring::clear((as::client::IOControllerPrefs *)((char *)this + 64));
  unint64_t v2 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  unint64_t v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

void as::client::StreamPrefs::~StreamPrefs(as::client::StreamPrefs *this)
{
  as::client::StreamPrefs::~StreamPrefs(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_26C312788;
  unint64_t v2 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::client::TurnByTurnPref::~TurnByTurnPref(as::client::TurnByTurnPref *this)
{
  as::client::TurnByTurnPref::~TurnByTurnPref(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26C3127F8;
  caulk::xstring::clear((as::client::TurnByTurnPref *)((char *)this + 16));
  PB::Base::~Base(this);
}

uint64_t std::vector<std::unique_ptr<as::client::PortPrefs>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

void *std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100](void *result)
{
  v1 = *(void ***)(result[2] + 8);
  unint64_t v2 = *(void ***)(result[1] + 8);
  while (v1 != v2)
  {
    uint64_t result = *v1;
    void *v1 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
    ++v1;
  }
  return result;
}

void **std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::__destruct_at_end[abi:ne180100](void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    int v4 = result;
    do
    {
      v4[2] = v2 - 8;
      uint64_t result = *(void **)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::client::IOControllerPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::IOControllerPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::IOControllerPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::IOControllerPrefs>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::client::IOControllerPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::IOControllerPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::IOControllerPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::IOControllerPrefs>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::IOControllerPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::IOControllerPrefs>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::IOControllerPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::IOControllerPrefs>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

void *std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100](void *result)
{
  v1 = result;
  uint64_t v2 = (void *)*result;
  unint64_t v3 = (void *)result[1];
  while (v3 != v2)
  {
    int v4 = (void *)*--v3;
    uint64_t result = v4;
    *unint64_t v3 = 0;
    if (v4) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  v1[1] = v2;
  return result;
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

uint64_t std::vector<std::unique_ptr<as::client::PolarPatternPref>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::client::PolarPatternPref>>,std::reverse_iterator<std::unique_ptr<as::client::PolarPatternPref>*>,std::reverse_iterator<std::unique_ptr<as::client::PolarPatternPref>*>,std::reverse_iterator<std::unique_ptr<as::client::PolarPatternPref>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::client::PolarPatternPref>>,std::reverse_iterator<std::unique_ptr<as::client::PolarPatternPref>*>,std::reverse_iterator<std::unique_ptr<as::client::PolarPatternPref>*>,std::reverse_iterator<std::unique_ptr<as::client::PolarPatternPref>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PolarPatternPref>>,std::reverse_iterator<std::unique_ptr<as::client::PolarPatternPref>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PolarPatternPref>>,std::reverse_iterator<std::unique_ptr<as::client::PolarPatternPref>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::client::StreamPrefs>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::client::StreamPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::StreamPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::StreamPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::StreamPrefs>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::client::StreamPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::StreamPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::StreamPrefs>*>,std::reverse_iterator<std::unique_ptr<as::client::StreamPrefs>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    char v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::StreamPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::StreamPrefs>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::StreamPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::StreamPrefs>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

caulk::xstring *std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>(uint64_t a1, caulk::xstring *a2, caulk::xstring *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1 + 16;
  char v9 = *(caulk::xstring **)a1;
  if (a4 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4)
  {
    std::vector<caulk::xstring>::__vdeallocate(a1);
    if (a4 >> 60) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = *(void *)(a1 + 16) - *(void *)a1;
    uint64_t v11 = v10 >> 3;
    if (v10 >> 3 <= a4) {
      uint64_t v11 = a4;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    std::vector<caulk::xstring>::__vallocate[abi:ne180100]((void *)a1, v12);
    uint64_t result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<caulk::xstring>,caulk::xstring*,caulk::xstring*,caulk::xstring*>(v8, v6, a3, *(caulk::xstring **)(a1 + 8));
LABEL_15:
    *(void *)(a1 + 8) = result;
    return result;
  }
  char v14 = *(caulk::xstring **)(a1 + 8);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 < a4)
  {
    long long v16 = (caulk::xstring *)((char *)a2 + 16 * v15);
    if (v14 != v9)
    {
      uint64_t v17 = 16 * v15;
      do
      {
        caulk::xstring::assign(v9, v6);
        uint64_t v6 = (caulk::xstring *)((char *)v6 + 16);
        char v9 = (caulk::xstring *)((char *)v9 + 16);
        v17 -= 16;
      }
      while (v17);
      char v9 = *(caulk::xstring **)(a1 + 8);
    }
    uint64_t result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<caulk::xstring>,caulk::xstring*,caulk::xstring*,caulk::xstring*>(v8, v16, a3, v9);
    goto LABEL_15;
  }
  if (a2 == a3)
  {
    unint64_t v18 = *(caulk::xstring **)a1;
  }
  else
  {
    unint64_t v18 = *(caulk::xstring **)a1;
    do
    {
      caulk::xstring::assign(v9, v6);
      uint64_t v6 = (caulk::xstring *)((char *)v6 + 16);
      char v9 = (caulk::xstring *)((char *)v9 + 16);
      unint64_t v18 = (caulk::xstring *)((char *)v18 + 16);
    }
    while (v6 != a3);
  }
  return (caulk::xstring *)std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100](a1, v18);
}

void sub_210ABA068(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<caulk::xstring>::__vdeallocate(uint64_t a1)
{
  if (*(void *)a1)
  {
    std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100](a1, *(caulk::xstring **)a1);
    operator delete(*(void **)a1);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

char *std::vector<caulk::xstring>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

caulk::xstring *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<caulk::xstring>,caulk::xstring*,caulk::xstring*,caulk::xstring*>(uint64_t a1, caulk::xstring *a2, caulk::xstring *a3, caulk::xstring *this)
{
  uint64_t v4 = this;
  uint64_t v10 = this;
  uint64_t v11 = this;
  v8[0] = a1;
  v8[1] = &v10;
  void v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)uint64_t v4 = 0;
      *((void *)v4 + 1) = 0;
      caulk::xstring::assign(v4, v6);
      uint64_t v6 = (const caulk::xstring *)((char *)v6 + 16);
      uint64_t v4 = (caulk::xstring *)((char *)v11 + 16);
      uint64_t v11 = (caulk::xstring *)((char *)v11 + 16);
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_210ABA188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

uint64_t std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,caulk::xstring*>::operator()[abi:ne180100](uint64_t result)
{
  uint64_t v1 = **(caulk::xstring ***)(result + 16);
  uint64_t v2 = **(caulk::xstring ***)(result + 8);
  while (v1 != v2)
  {
    uint64_t v1 = (caulk::xstring *)((char *)v1 - 16);
    uint64_t result = caulk::xstring::clear(v1);
  }
  return result;
}

uint64_t std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100](uint64_t result, caulk::xstring *a2)
{
  uint64_t v3 = result;
  for (uint64_t i = *(caulk::xstring **)(result + 8); i != a2; result = caulk::xstring::clear(i))
    uint64_t i = (caulk::xstring *)((char *)i - 16);
  *(void *)(v3 + 8) = a2;
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

uint64_t std::vector<caulk::xstring>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>,std::reverse_iterator<caulk::xstring*>,std::reverse_iterator<caulk::xstring*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>,std::reverse_iterator<caulk::xstring*>,std::reverse_iterator<caulk::xstring*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  char v13 = 0;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 16;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      caulk::xstring::move();
      uint64_t v7 = *((void *)&v15 + 1) - 16;
      *((void *)&v15 + 1) -= 16;
    }
    while (v9 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

caulk::xstring *std::_AllocatorDestroyRangeReverse<std::allocator<caulk::xstring>,std::reverse_iterator<caulk::xstring*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v15 = v3;
  uint64_t v16 = v2;
  uint64_t v17 = v3;
  uint64_t v18 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v10 = v7;
  uint64_t v11 = v6;
  uint64_t v12 = v7;
  uint64_t v13 = v6;
  return std::__allocator_destroy[abi:ne180100]<std::allocator<caulk::xstring>,std::reverse_iterator<std::reverse_iterator<caulk::xstring*>>,std::reverse_iterator<std::reverse_iterator<caulk::xstring*>>>(v4, (uint64_t)v14, (uint64_t)v9);
}

caulk::xstring *std::__allocator_destroy[abi:ne180100]<std::allocator<caulk::xstring>,std::reverse_iterator<std::reverse_iterator<caulk::xstring*>>,std::reverse_iterator<std::reverse_iterator<caulk::xstring*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t result = *(caulk::xstring **)(a2 + 32); result != *(caulk::xstring **)(a3 + 32); *(void *)(a2 + 32) = result)
  {
    caulk::xstring::clear(result);
    uint64_t result = (caulk::xstring *)(*(void *)(a2 + 32) + 16);
  }
  return result;
}

uint64_t std::__split_buffer<caulk::xstring>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<caulk::xstring>::__destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  while (1)
  {
    uint64_t v4 = *(void *)(v3 + 16);
    if (v4 == a2) {
      break;
    }
    *(void *)(v3 + 16) = v4 - 16;
    uint64_t result = caulk::xstring::clear((caulk::xstring *)(v4 - 16));
  }
  return result;
}

void std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100](v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = (caulk::xstring **)*a1;
  if (*v2)
  {
    std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void (***as::mxsession_error_category::instance(as::mxsession_error_category *this))(as::mxsession_error_category *__hidden this)
{
  return &as::mxsession_error_category::instance(void)::gInstance;
}

void *as::mxsession_error_category::message@<X0>(int a1@<W1>, void *a2@<X8>)
{
  if ((a1 + 15685) > 5) {
    uint64_t v3 = "unknown MXSessionError";
  }
  else {
    uint64_t v3 = off_264189F48[a1 + 15685];
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v3);
}

void as::mxsession_error_category::~mxsession_error_category(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x21667A2D0);
}

const char *as::mxsession_error_category::name(as::mxsession_error_category *this)
{
  return "MXSession Error";
}

uint64_t as::WorkloopPool::WorkloopPool(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  *(_OWORD *)(a1 + 24) = 0u;
  uint64_t v3 = (uint64_t *)(a1 + 24);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  if (!a3)
  {
    uint64_t v11 = _os_crash();
    as::WorkloopPool::WorkloopPool(v11);
  }
  for (unint64_t i = 0; i != a3; ++i)
  {
    uint64_t v17 = 7;
    v15[2] = 7;
    long long v16 = i;
    __p[1] = 0;
    uint64_t v14 = 0;
    __p[0] = 0;
    v15[0] = 1;
    v15[1] = (uint64_t)&v16;
    std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((uint64_t)__p, "AudioSession (WL{})", 19, v15);
    if (v14 >= 0) {
      uint64_t v6 = __p;
    }
    else {
      uint64_t v6 = (void **)__p[0];
    }
    inactive = dispatch_workloop_create_inactive((const char *)v6);
    dispatch_workloop_set_scheduler_priority();
    dispatch_workloop_set_autorelease_frequency(inactive, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    dispatch_activate(inactive);
    uint64_t v8 = operator new(0x28uLL);
    v8[1] = 0;
    void v8[2] = 0;
    *uint64_t v8 = &unk_26C312FB8;
    uint64_t v9 = inactive;
    void v8[3] = v9;
    *((unsigned char *)v8 + 32) = 0;
    *(void *)&long long v16 = v8 + 3;
    *((void *)&v16 + 1) = v8;
    std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::push_back[abi:ne180100](v3, &v16);
    if (*((void *)&v16 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v16 + 1));
    }

    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
  }
  return a1;
}

void sub_210ABAB1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::~deque[abi:ne180100]((void *)(a10 + 48));
  std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  int v22 = *(std::__shared_weak_count **)(a10 + 8);
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::shared_ptr<as::WorkloopPool::WorkloopState>>::~__split_buffer(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_210ABAC94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<as::WorkloopPool::WorkloopState>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::WorkloopPool::Create(as::WorkloopPool *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = this;
  std::allocate_shared[abi:ne180100]<as::WorkloopPool,std::allocator<as::WorkloopPool>,as::WorkloopPool::ConstructionTag,unsigned long &,void>((uint64_t)&v2, (uint64_t *)&v3, a2);
}

uint64_t std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<as::WorkloopPool::WorkloopState>>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<as::WorkloopPool::WorkloopState>>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<as::WorkloopPool::WorkloopState>>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<as::WorkloopPool::WorkloopState>>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<as::WorkloopPool::WorkloopState>>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<as::WorkloopPool::WorkloopState>>,std::reverse_iterator<std::shared_ptr<as::WorkloopPool::WorkloopState>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 16;
  }
}

void **std::__split_buffer<std::shared_ptr<as::WorkloopPool::WorkloopState>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::shared_ptr<as::WorkloopPool::WorkloopState>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

void std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

uint64_t std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::~deque[abi:ne180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    uint64_t v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }
  else
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 9];
    uint64_t v7 = (void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v5) & 0x1FF);
    if (v7 != (void **)v8)
    {
      do
      {
        long long v9 = *v7++;

        if ((char *)v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v10 = (void **)v6[1];
          ++v6;
          uint64_t v7 = v10;
        }
      }
      while (v7 != (void **)v8);
      uint64_t v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 256;
  }
  else
  {
    if (v12 != 2) {
      goto LABEL_16;
    }
    uint64_t v13 = 512;
  }
  a1[4] = v13;
LABEL_16:
  while (v2 != v3)
  {
    long long v14 = *v2++;
    operator delete(v14);
  }
  return std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  uint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> std::__vformat_to[abi:ne180100]<std::back_insert_iterator<std::string>,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(uint64_t a1, char *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  long long v17 = v16;
  long long v18 = xmmword_210AF2030;
  uint64_t v19 = std::__format::__output_buffer<char>::__output_buffer[abi:ne180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke;
  unint64_t v20 = v16;
  uint64_t v4 = *a4;
  v12[0] = a2;
  v12[1] = &a2[a3];
  int v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = v4;
  long long v8 = *(_OWORD *)a4;
  uint64_t v9 = a4[2];
  char v5 = 0;
  char v6 = 0;
  uint64_t v7 = &v17;
  LOBYTE(v10.__locale_) = 0;
  char v11 = 0;
  std::__format::__vformat_to[abi:ne180100]<std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v12, (uint64_t **)&v7);
  if (v11) {
    std::locale::~locale(&v10);
  }
  v19(v17, *((void *)&v18 + 1), (uint64_t)v20);
}

void sub_210ABB214(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

uint64_t *std::__format::__vformat_to[abi:ne180100]<std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char **a1, uint64_t **a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  char v5 = *a2;
  if (*a1 != v4)
  {
    while (1)
    {
      int v7 = *v3;
      if (v7 == 125) {
        break;
      }
      if (v7 != 123) {
        goto LABEL_10;
      }
      if (++v3 == v4) {
        std::__throw_format_error[abi:ne180100]("The format string terminates at a '{'");
      }
      if (*v3 == 123)
      {
LABEL_10:
        long long v8 = v3 + 1;
        std::locale v10 = v5;
        std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v10, v3);
        uint64_t v3 = v8;
        if (v8 == v4) {
          return v5;
        }
      }
      else
      {
        *a2 = v5;
        uint64_t v3 = std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v3, v4, a1, a2);
        char v5 = *a2;
        if (v3 == v4) {
          return v5;
        }
      }
    }
    if (++v3 == v4 || *v3 != 125) {
      std::__throw_format_error[abi:ne180100]("The format string contains an invalid escape sequence");
    }
    goto LABEL_10;
  }
  return v5;
}

uint64_t std::__format::__output_buffer<char>::__output_buffer[abi:ne180100]<std::__format::__format_buffer<std::back_insert_iterator<std::string>,char>>(char *,unsigned long,std::__format::__format_buffer<std::back_insert_iterator<std::string>,char> *)::{lambda(char *,unsigned long,void *)#1}::__invoke(std::string::value_type *a1, std::string::size_type __n_add, uint64_t a3)
{
  uint64_t v4 = *(std::string **)(a3 + 296);
  if (SHIBYTE(v4->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type v6 = v4->__r_.__value_.__r.__words[0];
    std::string::size_type size = v4->__r_.__value_.__l.__size_;
  }
  else
  {
    std::string::size_type size = HIBYTE(v4->__r_.__value_.__r.__words[2]);
    std::string::size_type v6 = *(void *)(a3 + 296);
  }
  return std::string::__insert_with_size<char *,char *>(v4, v6 + size, a1, &a1[__n_add], __n_add);
}

uint64_t std::string::__insert_with_size<char *,char *>(std::string *this, uint64_t a2, std::string::value_type *a3, std::string::value_type *a4, std::string::size_type __n_add)
{
  std::string::size_type v6 = this;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v9 = (std::string *)this->__r_.__value_.__r.__words[0];
    std::string::size_type v7 = a2 - this->__r_.__value_.__r.__words[0];
    if (__n_add)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    std::string::size_type v6 = (std::string *)this->__r_.__value_.__r.__words[0];
    return (uint64_t)v6 + v7;
  }
  std::string::size_type v7 = a2 - (void)this;
  if (!__n_add) {
    return (uint64_t)v6 + v7;
  }
  std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  uint64_t v9 = this;
LABEL_6:
  if (v9 <= (std::string *)a3 && (char *)&v9->__r_.__value_.__l.__data_ + size + 1 > a3)
  {
    std::string::__init_with_sentinel[abi:ne180100]<char *,char *>(&__p, a3, a4);
    std::string::size_type v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v10 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v12 = std::string::__insert_from_safe_copy[abi:ne180100]<char *,char *>(v6, __n_add, v7, (char *)p_p, (char *)p_p + v10);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    return v12;
  }
  return std::string::__insert_from_safe_copy[abi:ne180100]<char *,char *>(this, __n_add, v7, a3, a4);
}

void sub_210ABB484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::string::__insert_from_safe_copy[abi:ne180100]<char *,char *>(std::string *this, std::string::size_type __n_add, std::string::size_type __n_copy, char *a4, char *a5)
{
  uint64_t v9 = this;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = this->__r_.__value_.__l.__size_;
    std::string::size_type v11 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v11 - size >= __n_add)
    {
      uint64_t v12 = (std::string *)this->__r_.__value_.__r.__words[0];
      goto LABEL_7;
    }
  }
  else
  {
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    std::string::size_type v11 = 22;
    uint64_t v12 = this;
    if (22 - size >= __n_add)
    {
LABEL_7:
      size_t v13 = size - __n_copy;
      if (size == __n_copy) {
        std::string::size_type size = __n_copy;
      }
      else {
        memmove((char *)v12 + __n_copy + __n_add, (char *)v12 + __n_copy, v13);
      }
      goto LABEL_10;
    }
  }
  std::string::__grow_by(this, v11, size + __n_add - v11, size, __n_copy, 0, __n_add);
  v9->__r_.__value_.__l.__size_ = size + __n_add;
  uint64_t v12 = (std::string *)v9->__r_.__value_.__r.__words[0];
LABEL_10:
  std::string::size_type v14 = size + __n_add;
  if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0) {
    v9->__r_.__value_.__l.__size_ = v14;
  }
  else {
    *((unsigned char *)&v9->__r_.__value_.__s + 23) = v14 & 0x7F;
  }
  v12->__r_.__value_.__s.__data_[v14] = 0;
  if (a4 != a5)
  {
    uint64_t v15 = (char *)v12 + __n_copy;
    do
    {
      char v16 = *a4++;
      *v15++ = v16;
    }
    while (a4 != a5);
  }
  if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0) {
    uint64_t v9 = (std::string *)v9->__r_.__value_.__r.__words[0];
  }
  return (uint64_t)v9 + __n_copy;
}

void std::string::__init_with_sentinel[abi:ne180100]<char *,char *>(std::string *this, std::string::value_type *a2, std::string::value_type *a3)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    do
      std::string::push_back(this, *v4++);
    while (v4 != a3);
  }
}

void sub_210ABB614(void *a1)
{
  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  __cxa_rethrow();
}

void sub_210ABB630(_Unwind_Exception *a1)
{
}

void std::__throw_format_error[abi:ne180100](const char *a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::format_error::format_error[abi:ne180100](exception, a1);
}

void sub_210ABB68C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, char *a2, char **a3, void *a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  std::string::size_type v7 = std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(a1, a2, (uint64_t)a3);
  if (v7 == a2) {
    goto LABEL_14;
  }
  int v9 = *v7;
  BOOL v20 = v9 == 58;
  if (v9 == 125) {
    goto LABEL_5;
  }
  if (v9 != 58) {
LABEL_14:
  }
    std::__throw_format_error[abi:ne180100]("The argument index should end with a ':' or a '}'");
  ++v7;
LABEL_5:
  *a3 = v7;
  v19[0] = (uint64_t)a3;
  v19[1] = (uint64_t)a4;
  v19[2] = (uint64_t)&v20;
  unint64_t v10 = a4[1];
  if (v10 <= v8)
  {
    LOBYTE(v22) = 0;
  }
  else if (v10 > 0xC)
  {
    uint64_t v15 = (long long *)(a4[2] + 32 * v8);
    long long v16 = v15[1];
    long long v21 = *v15;
    long long v22 = v16;
  }
  else
  {
    std::string::size_type v11 = (uint64_t *)(a4[2] + 16 * v8);
    uint64_t v13 = *v11;
    uint64_t v12 = v11[1];
    uint64_t v14 = (a4[3] >> (5 * v8)) & 0x1FLL;
    *(void *)&long long v21 = v13;
    *((void *)&v21 + 1) = v12;
    LOBYTE(v22) = v14;
  }
  std::__visit_format_arg[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v19, (uint64_t)&v21);
  long long v17 = *a3;
  if (*a3 == a2 || *v17 != 125) {
    std::__throw_format_error[abi:ne180100]("The replacement field misses a terminating '}'");
  }
  return v17 + 1;
}

uint64_t **std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](uint64_t **a1, char *a2)
{
  uint64_t v3 = *a1;
  char v4 = *a2;
  uint64_t v5 = **a1;
  uint64_t v6 = (*a1)[2];
  v3[2] = v6 + 1;
  *(unsigned char *)(v5 + v6) = v4;
  if (v3[2] == v3[1])
  {
    ((void (*)(uint64_t))v3[3])(*v3);
    v3[2] = 0;
  }
  return a1;
}

std::runtime_error *std::format_error::format_error[abi:ne180100](std::runtime_error *a1, const char *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_26C312F90;
  return result;
}

void std::format_error::~format_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x21667A2D0);
}

char *std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(char *a1, char *a2, uint64_t a3)
{
  uint64_t v3 = a1;
  int v4 = *a1;
  if (v4 == 125 || v4 == 58)
  {
    std::basic_format_parse_context<char>::next_arg_id[abi:ne180100](a3);
    return v3;
  }
  if (v4 == 48)
  {
    int v5 = *(_DWORD *)(a3 + 16);
    if (v5)
    {
      if (v5 == 2) {
        std::__throw_format_error[abi:ne180100]("Using manual argument numbering in automatic argument numbering mode");
      }
    }
    else
    {
      *(_DWORD *)(a3 + 16) = 1;
    }
    return a1 + 1;
  }
  if ((v4 - 58) <= 0xF5u) {
    std::__throw_format_error[abi:ne180100]("The argument index starts with an invalid character");
  }
  return std::__format::__detail::__parse_manual[abi:ne180100]<char const*,std::basic_format_parse_context<char>>((unint64_t)a1, a2, a3);
}

void *std::__visit_format_arg[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t *a1, uint64_t a2)
{
  switch(*(unsigned char *)(a2 + 16))
  {
    case 1:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},BOOL &>((uint64_t)a1, (unsigned __int8 *)a2);
      break;
    case 2:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},char &>((uint64_t)a1, (unsigned __int8 *)a2);
      break;
    case 3:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},int &>((uint64_t)a1, (int *)a2);
      break;
    case 4:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long long &>((uint64_t)a1, (uint64_t *)a2);
      break;
    case 5:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long long &>((uint64_t)a1, (unint64_t *)a2);
      break;
    case 6:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned int &>((uint64_t)a1, (unsigned int *)a2);
      break;
    case 7:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned long long &>((uint64_t)a1, (unint64_t *)a2);
      break;
    case 8:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned long long &>((uint64_t)a1, (unint64_t *)a2);
      break;
    case 9:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},float &>((uint64_t)a1, (float *)a2);
      break;
    case 0xA:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},double &>((uint64_t)a1, (double *)a2);
      break;
    case 0xB:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long double &>((uint64_t)a1, (double *)a2);
      break;
    case 0xC:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},char const*&>((uint64_t)a1, (char **)a2);
      break;
    case 0xD:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},std::string_view &>((uint64_t)a1, a2);
      break;
    case 0xE:
      uint64_t result = std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},void const*&>((uint64_t)a1, (unint64_t *)a2);
      break;
    case 0xF:
      uint64_t v3 = a1[1];
      uint64_t v4 = *(void *)a2;
      int v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 8);
      uint64_t v6 = *a1;
      uint64_t result = (void *)v5(v6, v3, v4);
      break;
    default:
      std::__throw_format_error[abi:ne180100]("The argument index value is too large for the number of arguments supplied");
  }
  return result;
}

char *std::__format::__detail::__parse_manual[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(unint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result = std::__format::__parse_number[abi:ne180100]<char const*>(a1, a2);
  int v5 = *(_DWORD *)(a3 + 16);
  if (v5)
  {
    if (v5 == 2) {
      std::__throw_format_error[abi:ne180100]("Using manual argument numbering in automatic argument numbering mode");
    }
  }
  else
  {
    *(_DWORD *)(a3 + 16) = 1;
  }
  return result;
}

uint64_t std::basic_format_parse_context<char>::next_arg_id[abi:ne180100](uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    if (v1 == 1) {
      std::__throw_format_error[abi:ne180100]("Using automatic argument numbering in manual argument numbering mode");
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 2;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v2 + 1;
  return v2;
}

char *std::__format::__parse_number[abi:ne180100]<char const*>(unint64_t a1, char *a2)
{
  if ((uint64_t)&a2[-a1] <= 9) {
    uint64_t v2 = (unsigned __int8 *)a2;
  }
  else {
    uint64_t v2 = (unsigned __int8 *)(a1 + 9);
  }
  uint64_t v3 = (unsigned __int8 *)(a1 + 1);
  unsigned int v4 = *(char *)a1 - 48;
  if ((unsigned __int8 *)(a1 + 1) == v2)
  {
LABEL_8:
    if (v2 == (unsigned __int8 *)a2)
    {
      return a2;
    }
    else
    {
      uint64_t v6 = *v2;
      if ((v6 - 48) > 9)
      {
        return (char *)v2;
      }
      else if ((v6 + 10 * (unint64_t)v4 - 48) >> 31 {
             || (uint64_t v3 = (unsigned __int8 *)(a1 + 2), (char *)(a1 + 2) != a2) && *v3 - 48 <= 9)
      }
      {
        std::__throw_format_error[abi:ne180100]("The numeric value of the format specifier is too large");
      }
    }
  }
  else
  {
    a1 += (unint64_t)&v2[~a1];
    while (1)
    {
      int v5 = *v3;
      if ((v5 - 58) < 0xFFFFFFF6) {
        break;
      }
      unsigned int v4 = v5 + 10 * v4 - 48;
      if (++v3 == v2) {
        goto LABEL_8;
      }
    }
  }
  return (char *)v3;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},BOOL &>(uint64_t a1, unsigned __int8 *a2)
{
  int v3 = *a2;
  uint64_t v8 = 0;
  int v9 = -1;
  char v10 = 32;
  __int16 v11 = 0;
  char v12 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unsigned int v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_BOOL[abi:ne180100]<char>((uint64_t)&v8, "a BOOL");
    std::string::value_type *v4 = v5;
  }
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t result = std::formatter<BOOL,char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v8, v3 != 0, v6);
  *uint64_t v6 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},char &>(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 v3 = *a2;
  uint64_t v8 = 0;
  int v9 = -1;
  char v10 = 32;
  __int16 v11 = 0;
  char v12 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unsigned int v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_char[abi:ne180100]<char>((uint64_t)&v8, "a character");
    std::string::value_type *v4 = v5;
  }
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t result = std::__formatter_char<char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v8, v3, v6);
  *uint64_t v6 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},int &>(uint64_t a1, int *a2)
{
  int v3 = *a2;
  uint64_t v8 = 0;
  int v9 = -1;
  char v10 = 32;
  __int16 v11 = 0;
  char v12 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unsigned int v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v8, "an integer");
    std::string::value_type *v4 = v5;
  }
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t result = std::__formatter_integer<char>::format[abi:ne180100]<int,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v8, v3, v6);
  *uint64_t v6 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long long &>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v8 = 0;
  int v9 = -1;
  char v10 = 32;
  __int16 v11 = 0;
  char v12 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unsigned int v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v8, "an integer");
    std::string::value_type *v4 = v5;
  }
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t result = std::__formatter_integer<char>::format[abi:ne180100]<long long,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v8, v3, v6);
  *uint64_t v6 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long long &>(uint64_t a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v9 = 0;
  int v10 = -1;
  char v11 = 32;
  __int16 v12 = 0;
  char v13 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    int v5 = *(unsigned __int8 ***)a1;
    uint64_t v6 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v9, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v9, "an integer");
    *int v5 = v6;
  }
  std::string::size_type v7 = *(void **)(a1 + 8);
  uint64_t result = std::__formatter_integer<char>::format[abi:ne180100]<__int128,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v9, v4, v3, v7);
  *std::string::size_type v7 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned int &>(uint64_t a1, unsigned int *a2)
{
  unsigned int v3 = *a2;
  uint64_t v8 = 0;
  int v9 = -1;
  char v10 = 32;
  __int16 v11 = 0;
  char v12 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unint64_t v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v8, "an integer");
    std::string::value_type *v4 = v5;
  }
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t result = std::__formatter_integer<char>::format[abi:ne180100]<unsigned int,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v8, v3, v6);
  *uint64_t v6 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned long long &>(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v8 = 0;
  int v9 = -1;
  char v10 = 32;
  __int16 v11 = 0;
  char v12 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unint64_t v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v8, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v8, "an integer");
    std::string::value_type *v4 = v5;
  }
  uint64_t v6 = *(void **)(a1 + 8);
  uint64_t result = std::__formatter_integer<char>::format[abi:ne180100]<unsigned long long,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v8, v3, v6);
  *uint64_t v6 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},unsigned long long &>(uint64_t a1, unint64_t *a2)
{
  unint64_t v4 = *a2;
  unint64_t v3 = a2[1];
  uint64_t v9 = 0;
  int v10 = -1;
  char v11 = 32;
  __int16 v12 = 0;
  char v13 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    int v5 = *(unsigned __int8 ***)a1;
    uint64_t v6 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v9, *(unsigned __int8 ***)a1, 0x137u);
    std::__format_spec::__process_parsed_integer[abi:ne180100]<char>((uint64_t)&v9, "an integer");
    *int v5 = v6;
  }
  std::string::size_type v7 = *(void **)(a1 + 8);
  uint64_t result = std::__formatter_integer<char>::format[abi:ne180100]<unsigned __int128,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v9, v4, v3, v7);
  *std::string::size_type v7 = result;
  return result;
}

uint64_t *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},float &>(uint64_t a1, float *a2)
{
  float v3 = *a2;
  uint64_t v11 = 0;
  int v12 = -1;
  char v13 = 32;
  __int16 v14 = 0;
  char v15 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unint64_t v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v11, *(unsigned __int8 ***)a1, 0x13Fu);
    if (BYTE1(v11) - 13 >= 6)
    {
      if (BYTE1(v11) > 0xCu || ((1 << SBYTE1(v11)) & 0x1801) == 0) {
        std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a floating-point");
      }
    }
    else if ((SWORD1(v11) & 0x80000000) == 0 && v12 == -1)
    {
      int v12 = 6;
    }
    std::string::value_type *v4 = v5;
  }
  std::string::size_type v7 = *(uint64_t ***)(a1 + 8);
  unint64_t v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v11, v7);
  uint64_t result = std::__formatter::__format_floating_point[abi:ne180100]<float,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v7, v8, v9, v3);
  *std::string::size_type v7 = result;
  return result;
}

uint64_t *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},double &>(uint64_t a1, double *a2)
{
  double v3 = *a2;
  uint64_t v11 = 0;
  int v12 = -1;
  char v13 = 32;
  __int16 v14 = 0;
  char v15 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unint64_t v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v11, *(unsigned __int8 ***)a1, 0x13Fu);
    if (BYTE1(v11) - 13 >= 6)
    {
      if (BYTE1(v11) > 0xCu || ((1 << SBYTE1(v11)) & 0x1801) == 0) {
        std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a floating-point");
      }
    }
    else if ((SWORD1(v11) & 0x80000000) == 0 && v12 == -1)
    {
      int v12 = 6;
    }
    std::string::value_type *v4 = v5;
  }
  std::string::size_type v7 = *(uint64_t ***)(a1 + 8);
  unint64_t v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v11, v7);
  uint64_t result = std::__formatter::__format_floating_point[abi:ne180100]<double,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v7, v8, v9, v3);
  *std::string::size_type v7 = result;
  return result;
}

uint64_t *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},long double &>(uint64_t a1, double *a2)
{
  double v3 = *a2;
  uint64_t v11 = 0;
  int v12 = -1;
  char v13 = 32;
  __int16 v14 = 0;
  char v15 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unint64_t v4 = *(unsigned __int8 ***)a1;
    int v5 = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v11, *(unsigned __int8 ***)a1, 0x13Fu);
    if (BYTE1(v11) - 13 >= 6)
    {
      if (BYTE1(v11) > 0xCu || ((1 << SBYTE1(v11)) & 0x1801) == 0) {
        std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a floating-point");
      }
    }
    else if ((SWORD1(v11) & 0x80000000) == 0 && v12 == -1)
    {
      int v12 = 6;
    }
    std::string::value_type *v4 = v5;
  }
  std::string::size_type v7 = *(uint64_t ***)(a1 + 8);
  unint64_t v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v11, v7);
  uint64_t result = std::__formatter::__format_floating_point[abi:ne180100]<long double,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v7, v8, v9, v3);
  *std::string::size_type v7 = result;
  return result;
}

uint64_t *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},char const*&>(uint64_t a1, char **a2)
{
  double v3 = *a2;
  int v7 = 1;
  unint64_t v8 = 0xFFFFFFFF00000000;
  char v9 = 32;
  __int16 v10 = 0;
  char v11 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    unint64_t v4 = *(unsigned __int8 ***)a1;
    std::string::value_type *v4 = std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v7, *(unsigned __int8 ***)a1);
  }
  int v5 = *(uint64_t ***)(a1 + 8);
  uint64_t result = std::formatter<char const*,char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v7, v3, v5);
  *int v5 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},std::string_view &>(uint64_t a1, uint64_t a2)
{
  double v3 = *(char **)a2;
  size_t v4 = *(void *)(a2 + 8);
  int v11 = 1;
  unint64_t v12 = 0xFFFFFFFF00000000;
  char v13 = 32;
  __int16 v14 = 0;
  char v15 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    int v5 = *(unsigned __int8 ***)a1;
    *int v5 = std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v11, *(unsigned __int8 ***)a1);
  }
  uint64_t v6 = *(void **)(a1 + 8);
  int v7 = (void *)*v6;
  unint64_t v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v11, v6);
  uint64_t result = std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v3, v4, v7, v8, v9);
  *uint64_t v6 = result;
  return result;
}

void *std::invoke[abi:ne180100]<char const* std::__format::__handle_replacement_field[abi:ne180100]<char const*,std::basic_format_parse_context<char>,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char const*,char const*,std::basic_format_parse_context<char> &,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char> &)::{lambda(char const*)#1},void const*&>(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  uint64_t v7 = 0;
  int v8 = -1;
  char v9 = 32;
  __int16 v10 = 0;
  char v11 = 0;
  if (**(unsigned char **)(a1 + 16))
  {
    size_t v4 = *(unsigned __int8 ***)a1;
    std::string::value_type *v4 = std::__formatter_pointer<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(&v7, *(unsigned __int8 ***)a1);
  }
  int v5 = *(void **)(a1 + 8);
  uint64_t result = std::__formatter_pointer<char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)&v7, v3, v5);
  *int v5 = result;
  return result;
}

void *std::formatter<BOOL,char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, unsigned int a2, void *a3)
{
  if (*(unsigned __int8 *)(a1 + 1) > 1u)
  {
    unint64_t v9 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)a1, a3);
    return std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (void **)a3, v9, v8, 0);
  }
  else
  {
    unint64_t v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)a1, a3);
    return std::__formatter::__format_BOOL[abi:ne180100]<char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (void **)a3, v6, v5);
  }
}

unsigned __int8 *std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(unsigned char *a1, unsigned __int8 **a2, unsigned __int16 a3)
{
  unint64_t v3 = *a2;
  size_t v4 = a2[1];
  long long v17 = (char *)v3;
  if (v3 == v4) {
    return v3;
  }
  int v8 = std::__format_spec::__parser<char>::__parse_fill_align[abi:ne180100]<char const*>(a1, (unsigned __int8 **)&v17, v4, (a3 >> 6) & 1);
  unint64_t v9 = (unsigned __int8 *)v17;
  if (v8) {
    BOOL v10 = v17 == (char *)v4;
  }
  else {
    BOOL v10 = 0;
  }
  if (!v10)
  {
    if ((a3 & 1) == 0) {
      goto LABEL_14;
    }
    int v11 = *v17;
    switch(v11)
    {
      case ' ':
        char v12 = *a1 | 0x18;
        break;
      case '+':
        char v12 = *a1 & 0xE7 | 0x10;
        break;
      case '-':
        char v12 = *a1 & 0xE7 | 8;
        break;
      default:
LABEL_14:
        if ((a3 & 2) == 0 || *v9 != 35 || (*a1 |= 0x20u, ++v9, long long v17 = (char *)v9, v9 != v4))
        {
          if ((a3 & 4) == 0 || *v9 != 48) {
            goto LABEL_22;
          }
          if ((*a1 & 7) == 0) {
            *a1 = *a1 & 0xF8 | 4;
          }
          long long v17 = (char *)(v9 + 1);
          if (v9 + 1 != v4)
          {
LABEL_22:
            int v13 = std::__format_spec::__parser<char>::__parse_width[abi:ne180100]<char const*,std::basic_format_parse_context<char>>((uint64_t)a1, (unint64_t *)&v17, (char *)v4, (uint64_t)a2);
            __int16 v14 = (unsigned __int8 *)v17;
            if (!v13 || v17 != (char *)v4)
            {
              if ((a3 & 8) == 0
                || (v16 = std::__format_spec::__parser<char>::__parse_precision[abi:ne180100]<char const*,std::basic_format_parse_context<char>>((uint64_t)a1, &v17, (char *)v4, (uint64_t)a2), __int16 v14 = (unsigned __int8 *)v17, !v16)|| v17 != (char *)v4)
              {
                if ((a3 & 0x10) == 0 || *v14 != 76 || (*a1 |= 0x40u, ++v14, long long v17 = (char *)v14, v14 != v4))
                {
                  if ((a3 & 0x80) == 0 || *v14 != 110 || (*a1 |= 0x80u, long long v17 = (char *)(v14 + 1), v14 + 1 != v4))
                  {
                    if ((a3 & 0x20) != 0) {
                      std::__format_spec::__parser<char>::__parse_type[abi:ne180100]<char const*>((uint64_t)a1, &v17);
                    }
                    unint64_t v3 = (unsigned __int8 *)v17;
                    if ((a3 & 0x100) == 0) {
                      return v3;
                    }
                    if (v17 != (char *)v4)
                    {
                      size_t v4 = (unsigned __int8 *)v17;
                      if (*v17 != 125) {
                        std::__throw_format_error[abi:ne180100]("The format specifier should consume the input or end with a '}'");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return v4;
    }
    *a1 = v12;
    long long v17 = (char *)++v9;
    if (v9 == v4) {
      return v4;
    }
    goto LABEL_14;
  }
  return v4;
}

uint64_t std::__format_spec::__process_parsed_BOOL[abi:ne180100]<char>(uint64_t result, const char *a2)
{
  unsigned int v2 = *(unsigned __int8 *)(result + 1);
  if (v2 - 2 >= 6)
  {
    if (v2 > 1) {
      std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](a2);
    }
    unint64_t v3 = (unsigned char *)result;
    uint64_t result = std::__format_spec::__parser<char>::__validate[abi:ne180100](result, 48, a2, -1);
    if ((*v3 & 7) == 0) {
      *unint64_t v3 = *v3 & 0xF8 | 1;
    }
  }
  return result;
}

uint64_t std::__format_spec::__parser<char>::__parse_fill_align[abi:ne180100]<char const*>(unsigned char *a1, unsigned __int8 **a2, unsigned __int8 *a3, int a4)
{
  v17[0] = *a2;
  v17[1] = a3;
  if ((std::__unicode::__code_point_view<char>::__consume[abi:ne180100](v17) & 0x80000000) != 0) {
    std::__throw_format_error[abi:ne180100]("The format specifier contains malformed Unicode characters");
  }
  int v8 = v17[0];
  if (v17[0] >= a3) {
    goto LABEL_7;
  }
  int v9 = (char)*v17[0];
  switch(v9)
  {
    case '<':
      char v10 = 1;
      goto LABEL_17;
    case '>':
      char v10 = 3;
LABEL_17:
      *a1 = *a1 & 0xF8 | v10;
      char v15 = *a2;
      size_t v16 = v8 - *a2;
      if (v16 == 1)
      {
        std::__format_spec::__parser<char>::__validate_fill_character[abi:ne180100]((uint64_t)a1, (char)*v15, a4);
        char v15 = *a2;
      }
      else if (v8 == v15)
      {
LABEL_21:
        int v13 = &v8[v16];
        goto LABEL_22;
      }
      memmove(a1 + 12, v15, v16);
      int v8 = *a2;
      goto LABEL_21;
    case '^':
      char v10 = 2;
      goto LABEL_17;
  }
LABEL_7:
  int v11 = (char)**a2;
  switch(v11)
  {
    case '<':
      char v12 = 1;
      break;
    case '>':
      char v12 = 3;
      break;
    case '^':
      char v12 = 2;
      break;
    default:
      return 0;
  }
  *a1 = *a1 & 0xF8 | v12;
  int v13 = *a2;
LABEL_22:
  *a2 = v13 + 1;
  return 1;
}

uint64_t std::__format_spec::__parser<char>::__parse_width[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(uint64_t a1, unint64_t *a2, char *a3, uint64_t a4)
{
  unint64_t v6 = *a2;
  int v7 = *(unsigned __int8 *)*a2;
  if (v7 == 123)
  {
    int v9 = (char *)(v6 + 1);
    *a2 = (unint64_t)v9;
    char v10 = std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(v9, a3, a4);
    *(_WORD *)(a1 + 2) |= 0x4000u;
  }
  else
  {
    if (v7 == 48) {
      std::__throw_format_error[abi:ne180100]("The width option should not have a leading zero");
    }
    if ((v7 - 58) < 0xFFFFFFF6) {
      return 0;
    }
    char v10 = std::__format::__parse_number[abi:ne180100]<char const*>(v6, a3);
  }
  *(_DWORD *)(a1 + 4) = v11;
  *a2 = (unint64_t)v10;
  return 1;
}

BOOL std::__format_spec::__parser<char>::__parse_precision[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(uint64_t a1, char **a2, char *a3, uint64_t a4)
{
  size_t v4 = *a2;
  int v5 = **a2;
  if (v5 == 46)
  {
    int v8 = (unsigned __int8 *)(v4 + 1);
    *a2 = v4 + 1;
    if (v4 + 1 == a3) {
      std::__throw_format_error[abi:ne180100]("End of input while parsing format specifier precision");
    }
    int v9 = *v8;
    if (v9 == 123)
    {
      *a2 = v4 + 2;
      char v10 = std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(v4 + 2, a3, a4);
      *(_WORD *)(a1 + 2) |= 0x8000u;
      *(_DWORD *)(a1 + 8) = v11;
    }
    else
    {
      if ((v9 - 58) <= 0xFFFFFFF5) {
        std::__throw_format_error[abi:ne180100]("The precision option does not contain a value or an argument index");
      }
      char v10 = std::__format::__parse_number[abi:ne180100]<char const*>((unint64_t)v8, a3);
      *(_DWORD *)(a1 + 8) = v12;
      *(_WORD *)(a1 + 2) &= ~0x8000u;
    }
    *a2 = v10;
  }
  return v5 == 46;
}

uint64_t std::__format_spec::__parser<char>::__parse_type[abi:ne180100]<char const*>(uint64_t result, char **a2)
{
  unsigned int v2 = *a2;
  int v3 = **a2;
  if (v3 <= 96)
  {
    int v5 = v3 - 65;
    char v4 = 12;
    switch(v5)
    {
      case 0:
        goto LABEL_19;
      case 1:
        char v4 = 3;
        goto LABEL_19;
      case 4:
        char v4 = 14;
        goto LABEL_19;
      case 5:
        char v4 = 16;
        goto LABEL_19;
      case 6:
        char v4 = 18;
LABEL_19:
        *(unsigned char *)(result + 1) = v4;
        *a2 = v2 + 1;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(**a2)
    {
      case 'a':
        char v4 = 11;
        goto LABEL_19;
      case 'b':
        char v4 = 2;
        goto LABEL_19;
      case 'c':
        char v4 = 10;
        goto LABEL_19;
      case 'd':
        char v4 = 5;
        goto LABEL_19;
      case 'e':
        char v4 = 13;
        goto LABEL_19;
      case 'f':
        char v4 = 15;
        goto LABEL_19;
      case 'g':
        char v4 = 17;
        goto LABEL_19;
      case 'o':
        char v4 = 4;
        goto LABEL_19;
      case 'p':
        char v4 = 8;
        goto LABEL_19;
      case 's':
        char v4 = 1;
        goto LABEL_19;
      case 'x':
        char v4 = 6;
        goto LABEL_19;
      default:
        return result;
    }
  }
  return result;
}

uint64_t std::__unicode::__code_point_view<char>::__consume[abi:ne180100](unsigned __int8 **a1)
{
  int v1 = *a1;
  int v2 = **a1;
  unsigned int v3 = __clz(v2 ^ 0xFF) - 24;
  if (v2 == 255) {
    int v4 = 8;
  }
  else {
    int v4 = v3;
  }
  switch(v4)
  {
    case 0:
      *a1 = v1 + 1;
      uint64_t v5 = *v1;
      break;
    case 2:
      if (a1[1] - v1 < 2 || (v1[1] & 0xC0) != 0x80) {
        goto LABEL_35;
      }
      *a1 = v1 + 1;
      char v6 = *v1;
      *a1 = v1 + 2;
      unsigned int v7 = v1[1] & 0x3F | ((v6 & 0x1F) << 6);
      if (v7 >= 0x80) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = 2147549181;
      }
      break;
    case 3:
      if (a1[1] - v1 < 3) {
        goto LABEL_35;
      }
      uint64_t v8 = 1;
      do
        int v9 = v1[v8] & 0xC0;
      while (v9 == 128 && v8++ != 2);
      if (v9 != 128) {
        goto LABEL_35;
      }
      uint64_t v5 = 2147549181;
      *a1 = v1 + 1;
      int v11 = *v1 & 0xF;
      *a1 = v1 + 2;
      int v12 = (v11 << 12) | ((v1[1] & 0x3F) << 6);
      *a1 = v1 + 3;
      unsigned int v13 = v12 & 0xFFFFFFC0 | v1[2] & 0x3F;
      if (v13 >= 0x800)
      {
        if ((v12 & 0xF800) == 0xD800) {
          uint64_t v5 = 2147549181;
        }
        else {
          uint64_t v5 = v13;
        }
      }
      break;
    case 4:
      if (a1[1] - v1 < 4) {
        goto LABEL_35;
      }
      uint64_t v14 = 1;
      do
        int v15 = v1[v14] & 0xC0;
      while (v15 == 128 && v14++ != 3);
      if (v15 != 128) {
        goto LABEL_35;
      }
      uint64_t v5 = 2147549181;
      *a1 = v1 + 1;
      int v17 = *v1 & 7;
      *a1 = v1 + 2;
      int v18 = (v17 << 12) | ((v1[1] & 0x3F) << 6);
      *a1 = v1 + 3;
      unsigned int v19 = v18 & 0xFFFFFFC0 | v1[2] & 0x3F;
      *a1 = v1 + 4;
      unsigned int v20 = v1[3] & 0x3F | (v19 << 6);
      if (v20 >= 0x10000)
      {
        if (v20 >= 0x110000) {
          uint64_t v5 = 2147549181;
        }
        else {
          uint64_t v5 = v20;
        }
      }
      break;
    default:
LABEL_35:
      uint64_t v5 = 2147549181;
      *a1 = v1 + 1;
      break;
  }
  return v5;
}

void std::__format_spec::__parser<char>::__validate_fill_character[abi:ne180100](uint64_t a1, int a2, int a3)
{
  if (a3 && a2 == 58 || a2 == 125 || a2 == 123) {
    std::__throw_format_error[abi:ne180100]("The fill option contains an invalid value");
  }
}

char *std::__format_spec::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(char *a1, char *a2, uint64_t a3)
{
  if (a1 == a2) {
    std::__throw_format_error[abi:ne180100]("End of input while parsing an argument index");
  }
  int v4 = std::__format::__parse_arg_id[abi:ne180100]<char const*,std::basic_format_parse_context<char>>(a1, a2, a3);
  if (v4 == a2 || *v4 != 125) {
    std::__throw_format_error[abi:ne180100]("The argument index is invalid");
  }
  return v4 + 1;
}

void std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](const char *a1)
{
  std::string::basic_string[abi:ne180100]<0>(&v8, "The type option contains an invalid value for ");
  size_t v2 = strlen(a1);
  unsigned int v3 = std::string::append(&v8, a1, v2);
  long long v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  uint64_t v5 = std::string::append(&v9, " formatting argument", 0x14uLL);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  int64_t v11 = v5->__r_.__value_.__r.__words[2];
  long long v10 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (v11 >= 0) {
    unsigned int v7 = (const char *)&v10;
  }
  else {
    unsigned int v7 = (const char *)v10;
  }
  std::__throw_format_error[abi:ne180100](v7);
}

void sub_210ABD100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 - 25) < 0) {
    operator delete(*(void **)(v21 - 48));
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__format_spec::__parser<char>::__validate[abi:ne180100](uint64_t result, char a2, const char *a3, int a4)
{
  if ((a2 & 1) == 0 && (*(unsigned char *)result & 0x18) != 0)
  {
    long long v6 = "sign";
    goto LABEL_23;
  }
  if ((a2 & 2) == 0 && (*(unsigned char *)result & 0x20) != 0)
  {
    long long v6 = "alternate form";
    goto LABEL_23;
  }
  if ((a2 & 4) == 0 && (*(unsigned char *)result & 7) == 4)
  {
    long long v6 = "zero-padding";
    goto LABEL_23;
  }
  if ((a2 & 8) == 0 && *(_DWORD *)(result + 8) != -1)
  {
    long long v6 = "precision";
    goto LABEL_23;
  }
  if ((a2 & 0x10) == 0 && (*(unsigned char *)result & 0x40) != 0)
  {
    long long v6 = "locale-specific form";
LABEL_23:
    std::__format_spec::__throw_invalid_option_format_error[abi:ne180100](a3, v6);
  }
  unsigned int v4 = *(unsigned __int8 *)(result + 1);
  if (*(unsigned char *)(result + 1))
  {
    if (v4 >= 0x20) {
      std::__throw_format_error[abi:ne180100]("The type does not fit in the mask");
    }
    int v5 = 1 << v4;
  }
  else
  {
    int v5 = 1;
  }
  if ((v5 & a4) == 0) {
    std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](a3);
  }
  return result;
}

void std::__format_spec::__throw_invalid_option_format_error[abi:ne180100](const char *a1, const char *a2)
{
  std::string::basic_string[abi:ne180100]<0>(&v15, "The format specifier for ");
  size_t v4 = strlen(a1);
  int v5 = std::string::append(&v15, a1, v4);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  unsigned int v7 = std::string::append(&v16, " does not allow the ", 0x14uLL);
  long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  size_t v9 = strlen(a2);
  long long v10 = std::string::append(&v17, a2, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v18.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  int v12 = std::string::append(&v18, " option", 7uLL);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  int64_t v20 = v12->__r_.__value_.__r.__words[2];
  long long v19 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (v20 >= 0) {
    uint64_t v14 = (const char *)&v19;
  }
  else {
    uint64_t v14 = (const char *)v19;
  }
  std::__throw_format_error[abi:ne180100](v14);
}

void sub_210ABD32C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (*(char *)(v28 - 25) < 0) {
    operator delete(*(void **)(v28 - 48));
  }
  if (*(char *)(v28 - 57) < 0) {
    operator delete(*(void **)(v28 - 80));
  }
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void *std::__formatter::__format_BOOL[abi:ne180100]<char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(int a1, void **a2, uint64_t a3, unint64_t a4)
{
  if ((a3 & 0x40) != 0)
  {
    std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a2, &v17);
    int v12 = std::locale::use_facet(&v17, MEMORY[0x263F8C150]);
    std::locale::~locale(&v17);
    long long v13 = v12->__vftable;
    if (a1) {
      ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v13[2].~facet)(&v17, v12);
    }
    else {
      ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v13[2].~facet_0)(&v17, v12);
    }
    if ((v19 & 0x80u) == 0) {
      locale = (char *)&v17;
    }
    else {
      locale = (char *)v17.__locale_;
    }
    if ((v19 & 0x80u) == 0) {
      size_t v15 = v19;
    }
    else {
      size_t v15 = v18;
    }
    std::string v16 = std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(locale, v15, *a2, a3, a4);
    if ((char)v19 < 0) {
      operator delete(v17.__locale_);
    }
    return v16;
  }
  else
  {
    if (a1) {
      size_t v8 = 4;
    }
    else {
      size_t v8 = 5;
    }
    size_t v9 = *a2;
    if (a1) {
      long long v10 = "true";
    }
    else {
      long long v10 = "false";
    }
    return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v8, v9, a3, a4, v8);
  }
}

void sub_210ABD514(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, void *a2)
{
  char v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = std::__format_spec::__parser<char>::__get_width[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)a1, a2);
  std::__format_spec::__parser<char>::__get_precision[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)a1, a2);
  return (v5 << 8) | (v6 << 32) | v4 & 0x7F;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unsigned int a1, void **a2, unint64_t a3, unint64_t a4, char a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  switch(BYTE1(a3))
  {
    case 1:
      __break(1u);
      JUMPOUT(0x210ABD6F8);
    case 2:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x200;
      unsigned int v7 = &v13;
      unsigned int v9 = 2;
      size_t v8 = "0b";
      goto LABEL_11;
    case 3:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x300;
      unsigned int v7 = &v13;
      unsigned int v9 = 2;
      size_t v8 = "0B";
      goto LABEL_11;
    case 4:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x400;
      unsigned int v7 = (uint64_t *)v12;
      if (a1) {
        size_t v8 = "0";
      }
      else {
        size_t v8 = 0;
      }
      unsigned int v9 = 8;
      goto LABEL_11;
    case 6:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x600;
      unsigned int v7 = (uint64_t *)v11;
      unsigned int v9 = 16;
      size_t v8 = "0x";
      goto LABEL_11;
    case 7:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x700;
      unsigned int v7 = (uint64_t *)v11;
      unsigned int v9 = 16;
      size_t v8 = "0X";
LABEL_11:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, v6, a4, a5, v10, (uint64_t)v7, v8, v9);
      break;
    default:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, v10, (uint64_t)v11, 0, 0xAu);
      break;
  }
  return result;
}

std::locale *std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]@<X0>(uint64_t a1@<X0>, std::locale *a2@<X8>)
{
  unsigned int v3 = (std::locale *)(a1 + 32);
  if (!*(unsigned char *)(a1 + 40))
  {
    MEMORY[0x21667A1D0](&v5);
    std::optional<std::locale>::operator=[abi:ne180100]<std::locale,void>(v3, &v5);
    std::locale::~locale(&v5);
  }
  return std::locale::locale(a2, v3);
}

void sub_210ABD774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void *std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t __len, void *a3, uint64_t a4, unint64_t a5)
{
  if (a4 <= 0)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, __src, __len);
    return a3;
  }
  else
  {
    uint64_t v10 = std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>((unsigned __int8 *)__src, __len, HIDWORD(a4), 1);
    return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, __len, a3, a4, a5, v10);
  }
}

std::locale *std::optional<std::locale>::operator=[abi:ne180100]<std::locale,void>(std::locale *this, const std::locale *a2)
{
  if (LOBYTE(this[1].__locale_))
  {
    std::locale::operator=(this, a2);
  }
  else
  {
    std::locale::locale(this, a2);
    LOBYTE(this[1].__locale_) = 1;
  }
  return this;
}

uint64_t std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>(unsigned __int8 *a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    if ((char)*a1 < 0)
    {
      size_t v8 = a1;
    }
    else
    {
      uint64_t v7 = 0;
      size_t v8 = &a1[a3 - 1];
      while (1)
      {
        if (a2 - 1 == v7) {
          return a2;
        }
        if (a3 - 1 == v7) {
          break;
        }
        int v9 = (char)a1[++v7];
        if (v9 < 0)
        {
          a3 = a3 - v7 + 1;
          size_t v8 = &a1[v7 - 1];
          return v8
               - a1
               + std::__format_spec::__detail::__estimate_column_width_grapheme_clustering[abi:ne180100]<char const*>(v8, &a1[a2], a3, a4);
        }
      }
      if (((char)a1[a3] & 0x80000000) == 0) {
        return a3;
      }
      a3 = 1;
    }
    return v8
         - a1
         + std::__format_spec::__detail::__estimate_column_width_grapheme_clustering[abi:ne180100]<char const*>(v8, &a1[a2], a3, a4);
  }
  return result;
}

void *std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t __len, void *a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  size_t v9 = (a4 >> 32) - a6;
  if (a4 >> 32 <= a6)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a3, __src, __len);
    return a3;
  }
  else
  {
    unint64_t v10 = HIDWORD(a5);
    size_t v11 = 0;
    switch(a4 & 7)
    {
      case 1:
        break;
      case 2:
        size_t v11 = v9 >> 1;
        v9 -= v9 >> 1;
        break;
      default:
        size_t v11 = (a4 >> 32) - a6;
        size_t v9 = 0;
        break;
    }
    uint64_t v13 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v11, SHIDWORD(a5));
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v13, __src, __len);
    return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v13, v9, v10);
  }
}

void *std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(void *result, char *__src, size_t __len)
{
  size_t v3 = __len;
  std::locale v5 = result;
  size_t v7 = result[1];
  uint64_t v6 = result[2];
  if (v6 + __len >= v7)
  {
    uint64_t result = (void *)((uint64_t (*)(void))result[3])(*result);
    uint64_t v6 = 0;
    void v5[2] = 0;
    size_t v7 = v5[1];
  }
  if (v3 >= v7)
  {
    do
    {
      if (v5[1] >= v3) {
        size_t v8 = v3;
      }
      else {
        size_t v8 = v5[1];
      }
      if (v8) {
        memmove((void *)(*v5 + v6), __src, v8);
      }
      void v5[2] = v8;
      __src += v8;
      v3 -= v8;
      uint64_t result = (void *)((uint64_t (*)(void, size_t, void))v5[3])(*v5, v8, v5[4]);
      uint64_t v6 = 0;
      void v5[2] = 0;
    }
    while (v3);
  }
  else
  {
    if (v3)
    {
      uint64_t result = memmove((void *)(*v5 + v6), __src, v3);
      uint64_t v6 = v5[2];
    }
    void v5[2] = v6 + v3;
  }
  return result;
}

uint64_t std::__format_spec::__detail::__estimate_column_width_grapheme_clustering[abi:ne180100]<char const*>(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, int a4)
{
  uint64_t v14 = a1;
  size_t v15 = a2;
  unsigned int v16 = std::__unicode::__code_point_view<char>::__consume[abi:ne180100](&v14) & 0x7FFFFFFF;
  char v17 = std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](v16);
  if (a1 == a2) {
    return 0;
  }
  uint64_t v8 = 0;
  do
  {
    unsigned int v9 = v16;
    unint64_t v10 = v14;
    if (v14 == v15) {
      char v17 = 15;
    }
    else {
      unint64_t v10 = std::__unicode::__extended_grapheme_cluster_view<char>::__get_break[abi:ne180100]((uint64_t)&v14);
    }
    int v11 = std::__width_estimation_table::__estimated_width[abi:ne180100](v9);
    unint64_t v12 = v8 + v11;
    if (!a4 && v12 > a3) {
      break;
    }
    if (v10 == a2)
    {
      v8 += v11;
      return v8;
    }
    v8 += v11;
  }
  while (v12 <= a3);
  return v8;
}

uint64_t std::__width_estimation_table::__estimated_width[abi:ne180100](unsigned int a1)
{
  if (a1 - 262142 < 0xFFFC1102) {
    return 1;
  }
  unint64_t v2 = 108;
  size_t v3 = (unsigned int *)&std::__width_estimation_table::__entries;
  do
  {
    unint64_t v4 = v2 >> 1;
    std::locale v5 = &v3[v2 >> 1];
    unsigned int v7 = *v5;
    uint64_t v6 = v5 + 1;
    v2 += ~(v2 >> 1);
    if (((a1 << 14) | 0x3FFF) < v7) {
      unint64_t v2 = v4;
    }
    else {
      size_t v3 = v6;
    }
  }
  while (v2);
  uint64_t v1 = 1;
  if (v3 != (unsigned int *)&std::__width_estimation_table::__entries)
  {
    if ((*(v3 - 1) & 0x3FFF) + (*(v3 - 1) >> 14) < a1) {
      return 1;
    }
    else {
      return 2;
    }
  }
  return v1;
}

uint64_t std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](unsigned int a1)
{
  unint64_t v1 = 1496;
  unint64_t v2 = (unsigned int *)&std::__extended_grapheme_custer_property_boundary::__entries;
  do
  {
    unint64_t v3 = v1 >> 1;
    unint64_t v4 = &v2[v1 >> 1];
    unsigned int v6 = *v4;
    std::locale v5 = v4 + 1;
    v1 += ~(v1 >> 1);
    if (((a1 << 11) | 0x7FF) < v6) {
      unint64_t v1 = v3;
    }
    else {
      unint64_t v2 = v5;
    }
  }
  while (v1);
  uint64_t v7 = 16;
  if (v2 != (unsigned int *)&std::__extended_grapheme_custer_property_boundary::__entries)
  {
    unsigned int v8 = *(v2 - 1);
    unsigned int v9 = ((v8 >> 4) & 0x7F) + (v8 >> 11);
    unsigned int v10 = v8 & 0xF;
    if (v9 >= a1) {
      return v10;
    }
    else {
      return 16;
    }
  }
  return v7;
}

unsigned __int8 *std::__unicode::__extended_grapheme_cluster_view<char>::__get_break[abi:ne180100](uint64_t a1)
{
  int v2 = 0;
  char v8 = 1;
  while (1)
  {
    unint64_t v3 = *(unsigned __int8 **)a1;
    if (*(void *)a1 == *(void *)(a1 + 8)) {
      break;
    }
    unsigned int v4 = *(unsigned __int8 *)(a1 + 20);
    unsigned int v5 = std::__unicode::__code_point_view<char>::__consume[abi:ne180100]((unsigned __int8 **)a1) & 0x7FFFFFFF;
    *(_DWORD *)(a1 + 16) = v5;
    unsigned int v6 = std::__extended_grapheme_custer_property_boundary::__get_property[abi:ne180100](v5);
    *(unsigned char *)(a1 + 20) = v6;
    v2 |= v4 == 3;
    if (std::__unicode::__at_extended_grapheme_cluster_break[abi:ne180100](&v8, v2 & 1, v4, v6)) {
      return v3;
    }
  }
  *(unsigned char *)(a1 + 20) = 15;
  return v3;
}

BOOL std::__unicode::__at_extended_grapheme_cluster_break[abi:ne180100](unsigned char *a1, int a2, unsigned int a3, unsigned int a4)
{
  if (!a3 && a4 == 5) {
    return 0;
  }
  if (a3 > 5 || (BOOL v4 = 1, ((1 << a3) & 0x23) == 0))
  {
    if (a4 > 5 || (BOOL v4 = 1, ((1 << a4) & 0x23) == 0))
    {
      if (a3 == 12 || a3 == 6)
      {
        if ((a4 - 11) >= 2u) {
          goto LABEL_16;
        }
      }
      else if (a3 != 4 || a4 - 4 >= 9 || ((0x10Du >> (a4 - 4)) & 1) == 0)
      {
LABEL_16:
        BOOL v6 = a3 == 11 || a3 == 7;
        if (v6 && a4 == 11 || a4 <= 0xD && ((1 << a4) & 0x2404) != 0 || a3 == 8 || a3 == 13 && a2 && a4 == 3) {
          return 0;
        }
        BOOL v4 = 1;
        if (a3 == 9 && a4 == 9)
        {
          BOOL v4 = *a1 == 0;
          *a1 ^= 1u;
        }
        return v4;
      }
      return 0;
    }
  }
  return v4;
}

void *std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(void *a1, size_t __len, int a3)
{
  size_t v3 = __len;
  unsigned int v5 = __clz(~(_BYTE)a3) - 24;
  int __src = a3;
  if ((_BYTE)a3 == 0xFF) {
    size_t v6 = 8;
  }
  else {
    size_t v6 = v5;
  }
  if (v6)
  {
    if (__len)
    {
      do
      {
        std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, (char *)&__src, v6);
        --v3;
      }
      while (v3);
    }
  }
  else
  {
    std::__format::__output_buffer<char>::__fill[abi:ne180100](a1, __len, (char)a3);
  }
  return a1;
}

void *std::__format::__output_buffer<char>::__fill[abi:ne180100](void *result, size_t __len, int __c)
{
  uint64_t v5 = (uint64_t)result;
  size_t v7 = result[1];
  uint64_t v6 = result[2];
  if (v6 + __len >= v7)
  {
    uint64_t result = (void *)((uint64_t (*)(void))result[3])(*result);
    uint64_t v6 = 0;
    *(void *)(v5 + 16) = 0;
    size_t v7 = *(void *)(v5 + 8);
  }
  if (v7 <= __len)
  {
    do
    {
      uint64_t v8 = *(void *)v5;
      if (*(void *)(v5 + 8) >= __len) {
        size_t v9 = __len;
      }
      else {
        size_t v9 = *(void *)(v5 + 8);
      }
      if (v9)
      {
        memset((void *)(v8 + v6), __c, v9);
        uint64_t v8 = *(void *)v5;
      }
      *(void *)(v5 + 16) = v9;
      __len -= v9;
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, size_t, void))(v5 + 24))(v8, v9, *(void *)(v5 + 32));
      uint64_t v6 = 0;
      *(void *)(v5 + 16) = 0;
    }
    while (__len);
  }
  else
  {
    if (__len)
    {
      uint64_t result = memset((void *)(*(void *)v5 + v6), __c, __len);
      uint64_t v6 = *(void *)(v5 + 16);
    }
    *(void *)(v5 + 16) = v6 + __len;
  }
  return result;
}

unint64_t std::__format_spec::__parser<char>::__get_width[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, void *a2)
{
  *(void *)&v14[23] = *MEMORY[0x263EF8340];
  __int16 v3 = *(_WORD *)(a1 + 2);
  unint64_t result = *(unsigned int *)(a1 + 4);
  if ((v3 & 0x4000) != 0)
  {
    unint64_t v5 = (int)result;
    unint64_t v6 = a2[1];
    if (v6 <= (int)result)
    {
      LOBYTE(v8) = 0;
    }
    else if (v6 > 0xC)
    {
      uint64_t v9 = a2[2] + 32 * (int)result;
      unint64_t v2 = *(void *)v9;
      unint64_t v5 = *(void *)(v9 + 8);
      LOBYTE(v8) = *(unsigned char *)(v9 + 16);
      v11[0] = *(void *)(v9 + 17);
      *(void *)((char *)v11 + 7) = *(void *)(v9 + 24);
    }
    else
    {
      uint64_t v7 = a2[2];
      uint64_t v8 = (a2[3] >> (5 * result)) & 0x1FLL;
      unint64_t v2 = *(void *)(v7 + 16 * (int)result);
      unint64_t v5 = *(void *)(v7 + 16 * (int)result + 8);
    }
    v12[0] = v2;
    v12[1] = v5;
    char v13 = v8;
    *(void *)uint64_t v14 = v11[0];
    *(void *)&v14[7] = *(void *)((char *)v11 + 7);
    return std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v10, v12);
  }
  return result;
}

unint64_t std::__format_spec::__parser<char>::__get_precision[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, void *a2)
{
  *(void *)&v14[23] = *MEMORY[0x263EF8340];
  int v3 = *(__int16 *)(a1 + 2);
  unint64_t result = *(unsigned int *)(a1 + 8);
  if (v3 < 0)
  {
    unint64_t v5 = (int)result;
    unint64_t v6 = a2[1];
    if (v6 <= (int)result)
    {
      LOBYTE(v8) = 0;
    }
    else if (v6 > 0xC)
    {
      uint64_t v9 = a2[2] + 32 * (int)result;
      unint64_t v2 = *(void *)v9;
      unint64_t v5 = *(void *)(v9 + 8);
      LOBYTE(v8) = *(unsigned char *)(v9 + 16);
      v11[0] = *(void *)(v9 + 17);
      *(void *)((char *)v11 + 7) = *(void *)(v9 + 24);
    }
    else
    {
      uint64_t v7 = a2[2];
      uint64_t v8 = (a2[3] >> (5 * result)) & 0x1FLL;
      unint64_t v2 = *(void *)(v7 + 16 * (int)result);
      unint64_t v5 = *(void *)(v7 + 16 * (int)result + 8);
    }
    v12[0] = v2;
    v12[1] = v5;
    char v13 = v8;
    *(void *)uint64_t v14 = v11[0];
    *(void *)&v14[7] = *(void *)((char *)v11 + 7);
    return std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((uint64_t)&v10, v12);
  }
  return result;
}

unint64_t std::__visit_format_arg[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, unint64_t *a2)
{
  switch(*((unsigned char *)a2 + 16))
  {
    case 1:
    case 2:
    case 5:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
      std::__throw_format_error[abi:ne180100]("Replacement argument isn't a standard signed or unsigned integer type");
    case 3:
      unint64_t result = *(unsigned int *)a2;
      if ((result & 0x80000000) != 0) {
        std::__throw_format_error[abi:ne180100]("An argument index may not have a negative value");
      }
      return result;
    case 4:
      return std::invoke[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},long long &>(a1, a2);
    case 6:
      unint64_t result = *(unsigned int *)a2;
      if ((result & 0x80000000) != 0) {
        goto LABEL_8;
      }
      return result;
    case 7:
      unint64_t result = *a2;
      if (*a2 >> 31) {
LABEL_8:
      }
        std::__throw_format_error[abi:ne180100]("The value of the argument index exceeds its maximum value");
      return result;
    default:
      std::__throw_format_error[abi:ne180100]("The argument index value is too large for the number of arguments supplied");
  }
}

unint64_t std::invoke[abi:ne180100]<unsigned int std::__format_spec::__substitute_arg_id[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(std::basic_format_arg<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>)::{lambda(std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>)#1},long long &>(uint64_t a1, unint64_t *a2)
{
  unint64_t result = *a2;
  if ((*a2 & 0x8000000000000000) != 0) {
    std::__throw_format_error[abi:ne180100]("An argument index may not have a negative value");
  }
  if (result >> 31) {
    std::__throw_format_error[abi:ne180100]("The value of the argument index exceeds its maximum value");
  }
  return result;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned int,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unsigned int a1, void **a2, unint64_t a3, unint64_t a4, char a5, char *a6, uint64_t a7, unsigned char *a8, unsigned int a9)
{
  uint64_t v9 = a6;
  char v13 = a3;
  if (a5)
  {
    char v14 = 45;
LABEL_7:
    *a6 = v14;
    unsigned int v16 = a6 + 1;
    goto LABEL_8;
  }
  int v15 = (a3 >> 3) & 3;
  if (v15 == 2)
  {
    char v14 = 43;
    goto LABEL_7;
  }
  unsigned int v16 = a6;
  if (v15 == 3)
  {
    char v14 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      char v17 = *a8;
      if (*a8)
      {
        size_t v18 = a8 + 1;
        do
        {
          *(unsigned char *)unsigned int v16 = v17;
          unsigned int v16 = (_WORD *)((char *)v16 + 1);
          int v19 = *v18++;
          char v17 = v19;
        }
        while (v19);
      }
    }
  }
  int64_t v20 = std::__to_chars_integral[abi:ne180100]<unsigned int>(v16, a7, a1, a9);
  if ((v13 & 0x40) == 0) {
    goto LABEL_44;
  }
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a2, &v45);
  uint64_t v21 = std::locale::use_facet(&v45, MEMORY[0x263F8C150]);
  std::locale::~locale(&v45);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v21->__vftable[1].__on_zero_shared)(&v45, v21);
  if ((char)v47 < 0)
  {
    locale = (char *)v45.__locale_;
    if (!v46)
    {
LABEL_43:
      operator delete(locale);
      goto LABEL_44;
    }
  }
  else
  {
    if (!v47) {
      goto LABEL_44;
    }
    locale = (char *)&v45;
  }
  if (v20 - (char *)v16 <= *locale)
  {
    if ((v47 & 0x80) != 0)
    {
      locale = (char *)v45.__locale_;
      goto LABEL_43;
    }
LABEL_44:
    unint64_t v35 = HIDWORD(a3);
    if ((v13 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v9, (char *)v16 - v9);
      unsigned __int8 v36 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v16 - (int)v9) {
        int v37 = v16 - v9;
      }
      else {
        int v37 = HIDWORD(a3);
      }
      unint64_t v35 = (HIDWORD(a3) - v37);
      unsigned __int8 v38 = 48;
      uint64_t v9 = (char *)v16;
    }
    else
    {
      unsigned __int8 v38 = BYTE4(a4);
      unsigned __int8 v36 = a3;
    }
    char v39 = *a2;
    uint64_t v40 = a3 & 0xFFFFFF00 | (v35 << 32) | v36;
    unint64_t v41 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v38 << 32);
    if ((a3 & 0xFF00) == 0x700) {
      return std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20, v39, v40, v41, (uint64_t (*)(void))std::__formatter::__hex_to_upper[abi:ne180100]);
    }
    else {
      return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20 - v9, v39, v40, v41, v20 - v9);
    }
  }
  uint64_t v23 = *a2;
  memset(&__p, 0, sizeof(__p));
  if ((v47 & 0x80u) == 0) {
    unsigned int v24 = (std::string::value_type *)&v45;
  }
  else {
    unsigned int v24 = (std::string::value_type *)v45.__locale_;
  }
  if ((v47 & 0x80u) == 0) {
    uint64_t v25 = (char *)&v45 + v47;
  }
  else {
    uint64_t v25 = (char *)v45.__locale_ + v46;
  }
  std::string::value_type v26 = *v24;
  uint64_t v27 = v20 - (char *)v16 - *v24;
  if (v27 >= 1)
  {
    uint64_t v28 = v25 - 1;
    do
    {
      std::string::push_back(&__p, v26);
      if (v24 == v28)
      {
        std::string::value_type v26 = *v28;
        unsigned int v24 = v28;
      }
      else
      {
        unsigned int v29 = v24 + 1;
        uint64_t v30 = v24 + 1;
        do
        {
          int v31 = *v30++;
          std::string::value_type v26 = v31;
          if (v31) {
            BOOL v32 = 1;
          }
          else {
            BOOL v32 = v29 == v28;
          }
          unsigned int v29 = v30;
        }
        while (!v32);
        unsigned int v24 = v30 - 1;
      }
      v27 -= v26;
    }
    while (v27 > 0);
  }
  std::string::push_back(&__p, v26 + v27);
  char v33 = ((uint64_t (*)(const std::locale::facet *))v21->__vftable[1].~facet_0)(v21);
  unsigned int v34 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v23, v9, (char *)v16, (int)v20, (uint64_t *)&__p, v33, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((char)v47 < 0) {
    operator delete(v45.__locale_);
  }
  return v34;
}

void sub_210ABE5DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15.__locale_);
  }
  _Unwind_Resume(exception_object);
}

void *std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(void *a1, char *__src, char *a3, int a4, uint64_t *a5, char a6, uint64_t a7, unint64_t a8)
{
  unsigned __int16 v8 = a7;
  int v11 = a3;
  char v13 = a1;
  unint64_t v14 = HIDWORD(a7);
  unint64_t v15 = HIDWORD(a8);
  size_t v16 = a3 - __src;
  LODWORD(v17) = *((unsigned __int8 *)a5 + 23);
  if ((v17 & 0x80u) != 0) {
    uint64_t v17 = a5[1];
  }
  int v18 = a4 - __src - 1 + v17;
  if ((a7 & 7) == 4)
  {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(a1, __src, a3 - __src);
    if ((int)v14 > v18) {
      std::__format::__output_buffer<char>::__fill[abi:ne180100](v13, (int)v14 - v18, 48);
    }
    size_t v19 = 0;
  }
  else
  {
    if (SHIDWORD(a7) <= v18)
    {
      size_t v19 = 0;
    }
    else
    {
      size_t v19 = (a7 >> 32) - v18;
      size_t v20 = 0;
      switch(a7 & 7)
      {
        case 1:
          break;
        case 2:
          size_t v20 = v19 >> 1;
          v19 -= v19 >> 1;
          break;
        default:
          size_t v20 = (a7 >> 32) - v18;
          size_t v19 = 0;
          break;
      }
      char v13 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, v20, SHIDWORD(a8));
    }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v13, __src, v16);
  }
  uint64_t v21 = *((unsigned __int8 *)a5 + 23);
  int v22 = (char)v21;
  uint64_t v23 = (char *)a5 + v21;
  if (v22 >= 0) {
    unsigned int v24 = v23;
  }
  else {
    unsigned int v24 = (char *)(*a5 + a5[1]);
  }
  if (v22 >= 0) {
    uint64_t v25 = a5;
  }
  else {
    uint64_t v25 = (uint64_t *)*a5;
  }
  std::string::value_type v26 = (char *)v25 + 1;
  uint64_t v27 = v8 & 0xFF00;
  while (1)
  {
    unsigned int v29 = v24 - 1;
    size_t v28 = *(v24 - 1);
    if (v27 == 1792)
    {
      uint64_t v30 = &v11[v28];
      std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>((uint64_t)v13, v11, &v11[v28], (uint64_t (*)(void))std::__formatter::__hex_to_upper[abi:ne180100]);
      int v11 = v30;
    }
    else
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v13, v11, v28);
      v11 += *v29;
    }
    if (v24 == v26) {
      break;
    }
    uint64_t v31 = *v13;
    uint64_t v32 = v13[2];
    v13[2] = v32 + 1;
    *(unsigned char *)(v31 + v32) = a6;
    --v24;
    if (v13[2] == v13[1])
    {
      ((void (*)(void))v13[3])(*v13);
      v13[2] = 0;
      unsigned int v24 = v29;
    }
  }
  return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v13, v19, v15);
}

void *std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *a1, char *a2, void *a3, uint64_t a4, unint64_t a5, uint64_t (*a6)(void))
{
  size_t v10 = (a4 >> 32) - (a2 - a1);
  if (a4 >> 32 <= a2 - a1)
  {
    std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>((uint64_t)a3, a1, a2, a6);
    return a3;
  }
  else
  {
    unint64_t v11 = HIDWORD(a5);
    size_t v12 = 0;
    switch(a4 & 7)
    {
      case 1:
        break;
      case 2:
        size_t v12 = v10 >> 1;
        v10 -= v10 >> 1;
        break;
      default:
        size_t v12 = v10;
        size_t v10 = 0;
        break;
    }
    unint64_t v14 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v12, SHIDWORD(a5));
    std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>((uint64_t)v14, a1, a2, a6);
    return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v14, v10, v11);
  }
}

uint64_t std::__formatter::__hex_to_upper[abi:ne180100](int a1)
{
  if ((a1 - 97) >= 6) {
    return (char)a1;
  }
  else {
    return (char)(a1 - 32);
  }
}

char *std::__to_chars_integral[abi:ne180100]<unsigned int>(_WORD *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  BOOL v4 = (char *)a2;
  HIDWORD(v6) = a4;
  LODWORD(v6) = a4 - 2;
  int v5 = v6 >> 1;
  if (v5 != 4)
  {
    if (!v5) {
      return (char *)std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)a1, a2, a3);
    }
    if (v5 == 3) {
      return (char *)std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)a1, a2, a3);
    }
    if (v5 != 7)
    {
      uint64_t v10 = a2 - (void)a1;
      int v11 = std::__to_chars_integral_width[abi:ne180100]<unsigned int>(a3, a4);
      if (v10 < v11) {
        return (char *)a2;
      }
      BOOL v4 = (char *)a1 + v11;
      size_t v12 = v4 - 1;
      unsigned int v13 = a3;
      do
      {
        *v12-- = a0123456789abcd[v13 % a4];
        BOOL v14 = v13 >= a4;
        v13 /= a4;
      }
      while (v14);
      return v4;
    }
    return (char *)std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned int>((uint64_t)a1, a2, a3);
  }
  if (a2 - (uint64_t)a1 > 9) {
    return (char *)std::__itoa::__base_10_u32[abi:ne180100](a1, a3);
  }
  unsigned int v7 = (1233 * (32 - __clz(a3 | 1))) >> 12;
  if (a2 - (uint64_t)a1 >= (((__PAIR64__(v7, a3) - std::__itoa::__pow10_32[v7]) >> 32) + 1)) {
    return (char *)std::__itoa::__base_10_u32[abi:ne180100](a1, a3);
  }
  return v4;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned int>(unsigned int a1, unsigned int a2)
{
  if (a1 < a2) {
    return 1;
  }
  unsigned int v3 = a1;
  unsigned int v4 = a2 * a2;
  unsigned int v5 = v4 * v4;
  uint64_t result = 4;
  while (1)
  {
    if (v3 < v4) {
      return (result - 2);
    }
    if (v3 < a2 * a2 * a2) {
      break;
    }
    if (v3 < v5) {
      return result;
    }
    v3 /= v5;
    uint64_t result = (result + 4);
    if (v3 < a2) {
      return (result - 3);
    }
  }
  return (result - 1);
}

_WORD *std::__itoa::__base_10_u32[abi:ne180100](_WORD *a1, unsigned int a2)
{
  if (a2 >= 0xF4240)
  {
    if (a2 >= 0x5F5E100)
    {
      if (a2 > 0x3B9AC9FF)
      {
        return std::__itoa::__append10[abi:ne180100]<unsigned int>(a1, a2);
      }
      else
      {
        *(unsigned char *)a1 = a2 / 0x5F5E100 + 48;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240];
        unsigned int v7 = a2 % 0x5F5E100 % 0xF4240;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v7 / 0x2710uLL];
        v7 %= 0x2710u;
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[(unsigned __int16)v7 / 0x64u];
        *(_WORD *)((char *)a1 + 7) = std::__itoa::__digits_base_10[(unsigned __int16)v7 % 0x64u];
        return (_WORD *)((char *)a1 + 9);
      }
    }
    else
    {
      unsigned int v3 = a2 / 0xF4240;
      if (a2 > 0x98967F)
      {
        *a1 = std::__itoa::__digits_base_10[v3];
        a1[1] = std::__itoa::__digits_base_10[a2 % 0xF4240 / 0x2710uLL];
        unsigned int v9 = a2 % 0xF4240 % 0x2710;
        a1[2] = std::__itoa::__digits_base_10[(unsigned __int16)v9 / 0x64u];
        a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v9 % 0x64u];
        return a1 + 4;
      }
      else
      {
        *(unsigned char *)a1 = v3 + 48;
        unint64_t v4 = (429497 * (unint64_t)(a2 % 0xF4240)) >> 32;
        *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[v4];
        unsigned __int16 v5 = a2 % 0xF4240 - 10000 * v4;
        *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[v5 / 0x64u];
        *(_WORD *)((char *)a1 + 5) = std::__itoa::__digits_base_10[v5 % 0x64u];
        return (_WORD *)((char *)a1 + 7);
      }
    }
  }
  else if (a2 >> 4 > 0x270)
  {
    unsigned int v6 = a2 / 0x2710;
    if (a2 >> 5 > 0xC34)
    {
      *a1 = std::__itoa::__digits_base_10[v6];
      unsigned __int16 v10 = a2 % 0x2710;
      a1[1] = std::__itoa::__digits_base_10[v10 / 0x64u];
      a1[2] = std::__itoa::__digits_base_10[v10 % 0x64u];
      return a1 + 3;
    }
    else
    {
      *(unsigned char *)a1 = v6 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(5243 * (a2 % 0x2710)) >> 19];
      *(_WORD *)((char *)a1 + 3) = std::__itoa::__digits_base_10[(unsigned __int16)(a2 % 0x2710
                                                                                  - 100
                                                                                  * ((unsigned __int16)((5243 * (a2 % 0x2710)) >> 16) >> 3))];
      return (_WORD *)((char *)a1 + 5);
    }
  }
  else if (a2 > 0x63)
  {
    unsigned int v8 = (unsigned __int16)a2 / 0x64u;
    if (a2 > 0x3E7)
    {
      *a1 = std::__itoa::__digits_base_10[v8];
      a1[1] = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      return a1 + 2;
    }
    else
    {
      *(unsigned char *)a1 = v8 + 48;
      *(_WORD *)((char *)a1 + 1) = std::__itoa::__digits_base_10[(unsigned __int16)a2 % 0x64u];
      return (_WORD *)((char *)a1 + 3);
    }
  }
  else if (a2 > 9)
  {
    *a1 = std::__itoa::__digits_base_10[a2];
    return a1 + 1;
  }
  else
  {
    *(unsigned char *)a1 = a2 + 48;
    return (_WORD *)((char *)a1 + 1);
  }
}

_WORD *std::__itoa::__append10[abi:ne180100]<unsigned int>(_WORD *a1, unsigned int a2)
{
  *a1 = std::__itoa::__digits_base_10[a2 / 0x5F5E100uLL];
  a1[1] = std::__itoa::__digits_base_10[a2 % 0x5F5E100 / 0xF4240uLL];
  unsigned int v2 = a2 % 0x5F5E100 % 0xF4240;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  v2 %= 0x2710u;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 32 - __clz(a3 | 1);
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x11)
  {
    unsigned int v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unsigned int v6 = a3 >> 4;
      *(_DWORD *)(v5 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v5 -= 4;
      BOOL v7 = a3 > 0x10F;
      a3 >>= 4;
    }
    while (v7);
  }
  unsigned int v8 = (unsigned char *)(v5 - 1);
  do
  {
    *v8-- = a01[v6 & 1];
    BOOL v7 = v6 > 1;
    v6 >>= 1;
  }
  while (v7);
  return v4;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = (86 * (34 - __clz(a3 | 1))) >> 8;
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x41)
  {
    unsigned int v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unsigned int v6 = a3 >> 6;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x40);
  }
  BOOL v7 = (unsigned char *)(v5 - 1);
  do
  {
    *v7-- = a01234567[v6 & 7];
    BOOL v8 = v6 > 7;
    v6 >>= 3;
  }
  while (v8);
  return v4;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = (35 - __clz(a3 | 1)) >> 2;
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x101)
  {
    unsigned int v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unsigned int v6 = a3 >> 8;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_16_lut[a3];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x100);
  }
  BOOL v7 = (unsigned char *)(v5 - 1);
  do
  {
    *v7-- = a0123456789abcd_0[v6 & 0xF];
    BOOL v8 = v6 > 0xF;
    v6 >>= 4;
  }
  while (v8);
  return v4;
}

uint64_t std::__format::__output_buffer<char>::__transform[abi:ne180100]<char *,char (*)(char),char>(uint64_t result, char *a2, char *a3, uint64_t (*a4)(void))
{
  unsigned int v6 = a2;
  uint64_t v7 = result;
  unint64_t v8 = a3 - a2;
  unint64_t v10 = *(void *)(result + 8);
  uint64_t v9 = *(void *)(result + 16);
  if (v9 + v8 >= v10)
  {
    uint64_t result = (*(uint64_t (**)(void))(result + 24))(*(void *)result);
    uint64_t v9 = 0;
    *(void *)(v7 + 16) = 0;
    unint64_t v10 = *(void *)(v7 + 8);
  }
  if (v8 >= v10)
  {
    do
    {
      uint64_t v13 = *(void *)v7;
      if (*(void *)(v7 + 8) >= v8) {
        unint64_t v14 = v8;
      }
      else {
        unint64_t v14 = *(void *)(v7 + 8);
      }
      if (v14)
      {
        unint64_t v15 = (unsigned char *)(v13 + v9);
        unint64_t v16 = v14;
        uint64_t v17 = v6;
        do
        {
          unsigned int v18 = *v17++;
          *v15++ = a4(v18);
          --v16;
        }
        while (v16);
        uint64_t v13 = *(void *)v7;
      }
      v6 += v14;
      *(void *)(v7 + 16) = v14;
      v8 -= v14;
      uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t, void))(v7 + 24))(v13, v14, *(void *)(v7 + 32));
      uint64_t v9 = 0;
      *(void *)(v7 + 16) = 0;
    }
    while (v8);
  }
  else
  {
    if (v6 != a3)
    {
      int v11 = (unsigned char *)(*(void *)v7 + v9);
      do
      {
        unsigned int v12 = *v6++;
        uint64_t result = a4(v12);
        *v11++ = result;
      }
      while (v6 != a3);
      uint64_t v9 = *(void *)(v7 + 16);
    }
    *(void *)(v7 + 16) = v9 + v8;
  }
  return result;
}

void *std::__formatter_char<char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t a1, unsigned __int8 a2, void *a3)
{
  int v5 = *(unsigned __int8 *)(a1 + 1);
  if (v5 == 10 || v5 == 0)
  {
    uint64_t v7 = (void *)*a3;
    unint64_t v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)a1, a3);
    unsigned __int8 __src = a2;
    return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>((char *)&__src, 1uLL, v7, v8, v9, 1);
  }
  else
  {
    unint64_t v11 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>((char *)a1, a3);
    return std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (void **)a3, v11, v12, 0);
  }
}

uint64_t std::__format_spec::__process_parsed_char[abi:ne180100]<char>(uint64_t result, const char *a2)
{
  unsigned int v2 = *(unsigned __int8 *)(result + 1);
  if (v2 - 2 >= 6)
  {
    BOOL v3 = v2 > 0x13;
    int v4 = (1 << v2) & 0x80401;
    if (v3 || v4 == 0) {
      std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](a2);
    }
    unsigned int v6 = (unsigned char *)result;
    uint64_t result = std::__format_spec::__parser<char>::__validate[abi:ne180100](result, 48, a2, -1);
    if ((*v6 & 7) == 0) {
      *unsigned int v6 = *v6 & 0xF8 | 1;
    }
  }
  return result;
}

void *std::__formatter_integer<char>::format[abi:ne180100]<int,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, int a2, void *a3)
{
  unint64_t v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  unint64_t v7 = v5;
  if ((v6 & 0xFF00) == 0xA00)
  {
    unint64_t v8 = (void *)*a3;
    return std::__formatter::__format_char[abi:ne180100]<char,int,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, v8, v6, v7);
  }
  else
  {
    if (a2 >= 0) {
      unsigned int v10 = a2;
    }
    else {
      unsigned int v10 = -a2;
    }
    return std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v10, (void **)a3, v6, v5, a2 < 0);
  }
}

uint64_t std::__format_spec::__process_parsed_integer[abi:ne180100]<char>(uint64_t result, const char *a2)
{
  int v2 = *(unsigned __int8 *)(result + 1);
  if ((v2 - 2) >= 6 && v2 != 0)
  {
    if (v2 != 10) {
      std::__format_spec::__throw_invalid_type_format_error[abi:ne180100](a2);
    }
    int v4 = (unsigned char *)result;
    uint64_t result = std::__format_spec::__parser<char>::__validate[abi:ne180100](result, 48, a2, -1);
    if ((*v4 & 7) == 0) {
      unsigned char *v4 = *v4 & 0xF8 | 1;
    }
  }
  return result;
}

void *std::__formatter::__format_char[abi:ne180100]<char,int,std::back_insert_iterator<std::__format::__output_buffer<char>>>(int a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (a1 != (char)a1) {
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  }
  char __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a2, a3, a4, 1);
}

void *std::__formatter_integer<char>::format[abi:ne180100]<long long,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, uint64_t a2, void *a3)
{
  unint64_t v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  unint64_t v7 = v5;
  if ((v6 & 0xFF00) == 0xA00)
  {
    unint64_t v8 = (void *)*a3;
    return std::__formatter::__format_char[abi:ne180100]<char,long long,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, v8, v6, v7);
  }
  else
  {
    if (a2 >= 0) {
      unint64_t v10 = a2;
    }
    else {
      unint64_t v10 = -a2;
    }
    return std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v10, (void **)a3, v6, v5, a2 < 0);
  }
}

void *std::__formatter::__format_char[abi:ne180100]<char,long long,std::back_insert_iterator<std::__format::__output_buffer<char>>>(uint64_t a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (a1 != (char)a1) {
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  }
  char __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a2, a3, a4, 1);
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, void **a2, unint64_t a3, unint64_t a4, char a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  switch(BYTE1(a3))
  {
    case 1:
      __break(1u);
      JUMPOUT(0x210ABF630);
    case 2:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x200;
      unint64_t v7 = &v13;
      signed int v9 = 2;
      unint64_t v8 = "0b";
      goto LABEL_11;
    case 3:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x300;
      unint64_t v7 = &v13;
      signed int v9 = 2;
      unint64_t v8 = "0B";
      goto LABEL_11;
    case 4:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x400;
      unint64_t v7 = (uint64_t *)&v12[3];
      if (a1) {
        unint64_t v8 = "0";
      }
      else {
        unint64_t v8 = 0;
      }
      signed int v9 = 8;
      goto LABEL_11;
    case 6:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x600;
      unint64_t v7 = (uint64_t *)v11;
      signed int v9 = 16;
      unint64_t v8 = "0x";
      goto LABEL_11;
    case 7:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x700;
      unint64_t v7 = (uint64_t *)v11;
      signed int v9 = 16;
      unint64_t v8 = "0X";
LABEL_11:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, v6, a4, a5, v10, (uint64_t)v7, v8, v9);
      break;
    default:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, v10, (uint64_t)v12, 0, 10);
      break;
  }
  return result;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, void **a2, unint64_t a3, unint64_t a4, char a5, char *a6, uint64_t a7, unsigned char *a8, signed int a9)
{
  signed int v9 = a6;
  char v13 = a3;
  if (a5)
  {
    char v14 = 45;
LABEL_7:
    *a6 = v14;
    unint64_t v16 = a6 + 1;
    goto LABEL_8;
  }
  int v15 = (a3 >> 3) & 3;
  if (v15 == 2)
  {
    char v14 = 43;
    goto LABEL_7;
  }
  unint64_t v16 = a6;
  if (v15 == 3)
  {
    char v14 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      char v17 = *a8;
      if (*a8)
      {
        unsigned int v18 = a8 + 1;
        do
        {
          *(unsigned char *)unint64_t v16 = v17;
          unint64_t v16 = (_WORD *)((char *)v16 + 1);
          int v19 = *v18++;
          char v17 = v19;
        }
        while (v19);
      }
    }
  }
  size_t v20 = std::__to_chars_integral[abi:ne180100]<unsigned long long>(v16, a7, a1, a9);
  if ((v13 & 0x40) == 0) {
    goto LABEL_44;
  }
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a2, &v45);
  uint64_t v21 = std::locale::use_facet(&v45, MEMORY[0x263F8C150]);
  std::locale::~locale(&v45);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v21->__vftable[1].__on_zero_shared)(&v45, v21);
  if ((char)v47 < 0)
  {
    locale = (char *)v45.__locale_;
    if (!v46)
    {
LABEL_43:
      operator delete(locale);
      goto LABEL_44;
    }
  }
  else
  {
    if (!v47) {
      goto LABEL_44;
    }
    locale = (char *)&v45;
  }
  if (v20 - (char *)v16 <= *locale)
  {
    if ((v47 & 0x80) != 0)
    {
      locale = (char *)v45.__locale_;
      goto LABEL_43;
    }
LABEL_44:
    unint64_t v35 = HIDWORD(a3);
    if ((v13 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v9, (char *)v16 - v9);
      unsigned __int8 v36 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v16 - (int)v9) {
        int v37 = v16 - v9;
      }
      else {
        int v37 = HIDWORD(a3);
      }
      unint64_t v35 = (HIDWORD(a3) - v37);
      unsigned __int8 v38 = 48;
      signed int v9 = (char *)v16;
    }
    else
    {
      unsigned __int8 v38 = BYTE4(a4);
      unsigned __int8 v36 = a3;
    }
    char v39 = *a2;
    uint64_t v40 = a3 & 0xFFFFFF00 | (v35 << 32) | v36;
    unint64_t v41 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v38 << 32);
    if ((a3 & 0xFF00) == 0x700) {
      return std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20, v39, v40, v41, (uint64_t (*)(void))std::__formatter::__hex_to_upper[abi:ne180100]);
    }
    else {
      return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20 - v9, v39, v40, v41, v20 - v9);
    }
  }
  uint64_t v23 = *a2;
  memset(&__p, 0, sizeof(__p));
  if ((v47 & 0x80u) == 0) {
    unsigned int v24 = (std::string::value_type *)&v45;
  }
  else {
    unsigned int v24 = (std::string::value_type *)v45.__locale_;
  }
  if ((v47 & 0x80u) == 0) {
    uint64_t v25 = (char *)&v45 + v47;
  }
  else {
    uint64_t v25 = (char *)v45.__locale_ + v46;
  }
  std::string::value_type v26 = *v24;
  uint64_t v27 = v20 - (char *)v16 - *v24;
  if (v27 >= 1)
  {
    size_t v28 = v25 - 1;
    do
    {
      std::string::push_back(&__p, v26);
      if (v24 == v28)
      {
        std::string::value_type v26 = *v28;
        unsigned int v24 = v28;
      }
      else
      {
        unsigned int v29 = v24 + 1;
        uint64_t v30 = v24 + 1;
        do
        {
          int v31 = *v30++;
          std::string::value_type v26 = v31;
          if (v31) {
            BOOL v32 = 1;
          }
          else {
            BOOL v32 = v29 == v28;
          }
          unsigned int v29 = v30;
        }
        while (!v32);
        unsigned int v24 = v30 - 1;
      }
      v27 -= v26;
    }
    while (v27 > 0);
  }
  std::string::push_back(&__p, v26 + v27);
  char v33 = ((uint64_t (*)(const std::locale::facet *))v21->__vftable[1].~facet_0)(v21);
  unsigned int v34 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v23, v9, (char *)v16, (int)v20, (uint64_t *)&__p, v33, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((char)v47 < 0) {
    operator delete(v45.__locale_);
  }
  return v34;
}

void sub_210ABF970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15.__locale_);
  }
  _Unwind_Resume(exception_object);
}

char *std::__to_chars_integral[abi:ne180100]<unsigned long long>(_WORD *a1, uint64_t a2, unint64_t a3, signed int a4)
{
  int v4 = (char *)a2;
  HIDWORD(v6) = a4;
  LODWORD(v6) = a4 - 2;
  int v5 = v6 >> 1;
  if (v5 != 4)
  {
    if (!v5) {
      return (char *)std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    }
    if (v5 == 3) {
      return (char *)std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
    }
    if (v5 != 7)
    {
      uint64_t v10 = a2 - (void)a1;
      int v11 = std::__to_chars_integral_width[abi:ne180100]<unsigned long long>(a3, a4);
      if (v10 < v11) {
        return (char *)a2;
      }
      int v4 = (char *)a1 + v11;
      unint64_t v12 = v4 - 1;
      unint64_t v13 = a3;
      do
      {
        *v12-- = a0123456789abcd[(v13 % a4)];
        BOOL v14 = v13 >= a4;
        v13 /= (unint64_t)a4;
      }
      while (v14);
      return v4;
    }
    return (char *)std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned long long>((uint64_t)a1, a2, a3);
  }
  if (a2 - (uint64_t)a1 > 19) {
    return (char *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
  }
  unsigned int v7 = (1233 * (64 - __clz(a3 | 1))) >> 12;
  if (a2 - (uint64_t)a1 >= v7 - (std::__itoa::__pow10_64[v7] > a3) + 1) {
    return (char *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
  }
  return v4;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned long long>(unint64_t a1, unsigned int a2)
{
  if (a2 > a1) {
    return 1;
  }
  unint64_t v3 = a1;
  unint64_t v4 = a2 * a2;
  unint64_t v5 = (v4 * v4);
  uint64_t result = 4;
  while (1)
  {
    if (v3 < v4) {
      return (result - 2);
    }
    if (v3 < v4 * a2) {
      break;
    }
    if (v3 < v5) {
      return result;
    }
    v3 /= v5;
    uint64_t result = (result + 4);
    if (v3 < a2) {
      return (result - 3);
    }
  }
  return (result - 1);
}

_WORD *std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](_WORD *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  if (HIDWORD(a2))
  {
    if (a2 > 0x2540BE3FFLL)
    {
      a1 = std::__itoa::__base_10_u32[abi:ne180100](a1, a2 / 0x2540BE400);
      v2 %= 0x2540BE400uLL;
    }
    return std::__itoa::__append10[abi:ne180100]<unsigned long long>(a1, v2);
  }
  else
  {
    return std::__itoa::__base_10_u32[abi:ne180100](a1, a2);
  }
}

_WORD *std::__itoa::__append10[abi:ne180100]<unsigned long long>(_WORD *a1, unint64_t a2)
{
  *a1 = std::__itoa::__digits_base_10[(a2 / 0x5F5E100)];
  unsigned int v2 = a2 % 0x5F5E100;
  a1[1] = std::__itoa::__digits_base_10[v2 / 0xF4240uLL];
  v2 %= 0xF4240u;
  a1[2] = std::__itoa::__digits_base_10[v2 / 0x2710uLL];
  v2 %= 0x2710u;
  a1[3] = std::__itoa::__digits_base_10[(unsigned __int16)v2 / 0x64u];
  a1[4] = std::__itoa::__digits_base_10[(unsigned __int16)v2 % 0x64u];
  return a1 + 5;
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int64_t v3 = 64 - __clz(a3 | 1);
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x11)
  {
    unint64_t v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unint64_t v6 = a3 >> 4;
      *(_DWORD *)(v5 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v5 -= 4;
      BOOL v7 = a3 > 0x10F;
      a3 >>= 4;
    }
    while (v7);
  }
  unint64_t v8 = (unsigned char *)(v5 - 1);
  do
  {
    *v8-- = a01[v6 & 1];
    BOOL v7 = v6 > 1;
    v6 >>= 1;
  }
  while (v7);
  return v4;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = (86 * (66 - __clz(a3 | 1))) >> 8;
  if (a2 - a1 < v3) {
    return a2;
  }
  uint64_t v4 = a1 + v3;
  if (a3 < 0x41)
  {
    unint64_t v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + v3;
    do
    {
      unint64_t v6 = a3 >> 6;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x40);
  }
  BOOL v7 = (unsigned char *)(v5 - 1);
  do
  {
    *v7-- = a01234567[v6 & 7];
    BOOL v8 = v6 > 7;
    v6 >>= 3;
  }
  while (v8);
  return v4;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned long long>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = 67 - __clz(a3 | 1);
  if (a2 - a1 < (uint64_t)(v3 >> 2)) {
    return a2;
  }
  uint64_t v4 = a1 + (v3 >> 2);
  if (a3 < 0x101)
  {
    unint64_t v6 = a3;
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = a1 + (v3 >> 2);
    do
    {
      unint64_t v6 = a3 >> 8;
      *(_WORD *)(v5 - 2) = std::__itoa::__base_16_lut[a3];
      v5 -= 2;
      a3 = v6;
    }
    while (v6 > 0x100);
  }
  BOOL v7 = (unsigned char *)(v5 - 1);
  do
  {
    *v7-- = a0123456789abcd_0[v6 & 0xF];
    BOOL v8 = v6 > 0xF;
    v6 >>= 4;
  }
  while (v8);
  return v4;
}

void *std::__formatter_integer<char>::format[abi:ne180100]<__int128,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, unint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a4);
  if ((v8 & 0xFF00) == 0xA00)
  {
    signed int v9 = (void *)*a4;
    return std::__formatter::__format_char[abi:ne180100]<char,__int128,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, a3, v9, v8, v7);
  }
  else
  {
    unsigned long long v11 = __PAIR128__(a3 ^ (unint64_t)(a3 >> 63), a2 ^ (a3 >> 63)) - __PAIR128__(a3 >> 63, a3 >> 63);
    return std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(v11, *((unint64_t *)&v11 + 1), (void **)a4, v8, v7, a3 < 0);
  }
}

void *std::__formatter::__format_char[abi:ne180100]<char,__int128,std::back_insert_iterator<std::__format::__output_buffer<char>>>(unint64_t a1, uint64_t a2, void *a3, uint64_t a4, unint64_t a5)
{
  if (__PAIR128__(-1, -257) >= __PAIR128__((unint64_t)(a1 >= 0x80) + a2 - 1, a1 - 128)) {
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  }
  char __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a3, a4, a5, 1);
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, unint64_t a2, void **a3, unint64_t a4, unint64_t a5, char a6)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  switch(BYTE1(a4))
  {
    case 1:
      __break(1u);
      JUMPOUT(0x210AC00F4);
    case 2:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x200;
      unint64_t v8 = &v15;
      signed int v10 = 2;
      signed int v9 = "0b";
      goto LABEL_11;
    case 3:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x300;
      unint64_t v8 = &v15;
      signed int v10 = 2;
      signed int v9 = "0B";
      goto LABEL_11;
    case 4:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x400;
      unint64_t v8 = (uint64_t *)v14;
      if (a1 | a2) {
        signed int v9 = "0";
      }
      else {
        signed int v9 = 0;
      }
      signed int v10 = 8;
      goto LABEL_11;
    case 6:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x600;
      unint64_t v8 = (uint64_t *)v12;
      signed int v10 = 16;
      signed int v9 = "0x";
      goto LABEL_11;
    case 7:
      unint64_t v7 = a4 & 0xFFFFFFFFFFFF00FFLL | 0x700;
      unint64_t v8 = (uint64_t *)v12;
      signed int v10 = 16;
      signed int v9 = "0X";
LABEL_11:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, v7, a5, a6, v11, (uint64_t)v8, v9, v10);
      break;
    default:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, a6, v11, (uint64_t)v13, 0, 10);
      break;
  }
  return result;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, unint64_t a2, void **a3, unint64_t a4, unint64_t a5, char a6, char *a7, uint64_t a8, unsigned char *a9, signed int a10)
{
  signed int v10 = a7;
  char v14 = a4;
  if (a6)
  {
    char v15 = 45;
LABEL_7:
    *a7 = v15;
    char v17 = a7 + 1;
    goto LABEL_8;
  }
  int v16 = (a4 >> 3) & 3;
  if (v16 == 2)
  {
    char v15 = 43;
    goto LABEL_7;
  }
  char v17 = a7;
  if (v16 == 3)
  {
    char v15 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a4 & 0x20) != 0)
  {
    if (a9)
    {
      char v18 = *a9;
      if (*a9)
      {
        int v19 = a9 + 1;
        do
        {
          *v17++ = v18;
          int v20 = *v19++;
          char v18 = v20;
        }
        while (v20);
      }
    }
  }
  uint64_t v21 = (char *)std::__to_chars_integral[abi:ne180100]<unsigned __int128>(v17, a8, a1, a2, a10);
  if ((v14 & 0x40) == 0) {
    goto LABEL_44;
  }
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a3, &v46);
  int v22 = std::locale::use_facet(&v46, MEMORY[0x263F8C150]);
  std::locale::~locale(&v46);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v22->__vftable[1].__on_zero_shared)(&v46, v22);
  if ((char)v48 < 0)
  {
    locale = (char *)v46.__locale_;
    if (!v47)
    {
LABEL_43:
      operator delete(locale);
      goto LABEL_44;
    }
  }
  else
  {
    if (!v48) {
      goto LABEL_44;
    }
    locale = (char *)&v46;
  }
  if (v21 - v17 <= *locale)
  {
    if ((v48 & 0x80) != 0)
    {
      locale = (char *)v46.__locale_;
      goto LABEL_43;
    }
LABEL_44:
    unint64_t v36 = HIDWORD(a4);
    if ((v14 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a3, v10, v17 - v10);
      unsigned __int8 v37 = a4 & 0xF8 | 3;
      if (SHIDWORD(a4) >= (int)v17 - (int)v10) {
        int v38 = v17 - v10;
      }
      else {
        int v38 = HIDWORD(a4);
      }
      unint64_t v36 = (HIDWORD(a4) - v38);
      unsigned __int8 v39 = 48;
      signed int v10 = v17;
    }
    else
    {
      unsigned __int8 v39 = BYTE4(a5);
      unsigned __int8 v37 = a4;
    }
    uint64_t v40 = *a3;
    uint64_t v41 = a4 & 0xFFFFFF00 | (v36 << 32) | v37;
    unint64_t v42 = a5 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v39 << 32);
    if ((a4 & 0xFF00) == 0x700) {
      return std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v21, v40, v41, v42, (uint64_t (*)(void))std::__formatter::__hex_to_upper[abi:ne180100]);
    }
    else {
      return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v10, v21 - v10, v40, v41, v42, v21 - v10);
    }
  }
  unsigned int v24 = *a3;
  memset(&__p, 0, sizeof(__p));
  if ((v48 & 0x80u) == 0) {
    uint64_t v25 = (std::string::value_type *)&v46;
  }
  else {
    uint64_t v25 = (std::string::value_type *)v46.__locale_;
  }
  if ((v48 & 0x80u) == 0) {
    std::string::value_type v26 = (char *)&v46 + v48;
  }
  else {
    std::string::value_type v26 = (char *)v46.__locale_ + v47;
  }
  std::string::value_type v27 = *v25;
  uint64_t v28 = v21 - v17 - *v25;
  if (v28 >= 1)
  {
    unsigned int v29 = v26 - 1;
    do
    {
      std::string::push_back(&__p, v27);
      if (v25 == v29)
      {
        std::string::value_type v27 = *v29;
        uint64_t v25 = v29;
      }
      else
      {
        uint64_t v30 = v25 + 1;
        int v31 = v25 + 1;
        do
        {
          int v32 = *v31++;
          std::string::value_type v27 = v32;
          if (v32) {
            BOOL v33 = 1;
          }
          else {
            BOOL v33 = v30 == v29;
          }
          uint64_t v30 = v31;
        }
        while (!v33);
        uint64_t v25 = v31 - 1;
      }
      v28 -= v27;
    }
    while (v28 > 0);
  }
  std::string::push_back(&__p, v27 + v28);
  char v34 = ((uint64_t (*)(const std::locale::facet *))v22->__vftable[1].~facet_0)(v22);
  unint64_t v35 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v24, v10, v17, (int)v21, (uint64_t *)&__p, v34, a4, a5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((char)v48 < 0) {
    operator delete(v46.__locale_);
  }
  return v35;
}

void sub_210AC043C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15.__locale_);
  }
  _Unwind_Resume(exception_object);
}

_WORD *std::__to_chars_integral[abi:ne180100]<unsigned __int128>(unsigned char *a1, uint64_t a2, unint64_t a3, unint64_t a4, signed int a5)
{
  unint64_t v5 = a4;
  unint64_t v6 = a3;
  unint64_t v7 = (unsigned char *)a2;
  HIDWORD(v9) = a5;
  LODWORD(v9) = a5 - 2;
  int v8 = v9 >> 1;
  if (v8 != 4)
  {
    if (!v8) {
      return (_WORD *)std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)a1, a2, a3, a4);
    }
    if (v8 == 3) {
      return (_WORD *)std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)a1, a2, a3, a4);
    }
    if (v8 != 7)
    {
      uint64_t v18 = a2 - (void)a1;
      int v19 = std::__to_chars_integral_width[abi:ne180100]<unsigned __int128>(a3, a4, a5);
      if (v18 >= v19)
      {
        unint64_t v7 = &a1[v19];
        int v20 = v7 - 1;
        do
        {
          uint64_t v21 = __udivti3();
          BOOL v22 = __PAIR128__(v5, v6) >= a5;
          *v20-- = a0123456789abcd[(v6 - v21 * a5)];
          unint64_t v6 = v21;
          unint64_t v5 = v23;
        }
        while (v22);
      }
      return v7;
    }
    return (_WORD *)std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned __int128>((uint64_t)a1, a2, a3, a4);
  }
  uint64_t v10 = a2 - (void)a1;
  if (a4)
  {
    if (v10 > 38) {
      return std::__itoa::__base_10_u128[abi:ne180100](a1, a3, a4);
    }
    unsigned int v11 = (1233 * (128 - __clz(a4))) >> 12;
    if (v10 >= v11 - (__PAIR128__(a4, a3) < std::__itoa::__pow10_128[v11]) + 1) {
      return std::__itoa::__base_10_u128[abi:ne180100](a1, a3, a4);
    }
  }
  else
  {
    if (v10 > 19) {
      return std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
    }
    unsigned int v13 = (1233 * (64 - __clz(a3 | 1))) >> 12;
    if (v10 >= v13 - (std::__itoa::__pow10_64[v13] > a3) + 1) {
      return std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:ne180100](a1, a3);
    }
  }
  return v7;
}

uint64_t std::__to_chars_integral_width[abi:ne180100]<unsigned __int128>(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (__PAIR128__(a2, a1) < a3) {
    return 1;
  }
  unsigned int v5 = a3 * a3;
  unsigned int v6 = a3 * a3 * a3;
  uint64_t v3 = 4;
  while (1)
  {
    if (__PAIR128__(a2, a1) < v5) {
      return (v3 - 2);
    }
    if (__PAIR128__(a2, a1) < v6) {
      break;
    }
    if (__PAIR128__(a2, a1) < v5 * v5) {
      return v3;
    }
    a1 = __udivti3();
    uint64_t v3 = (v3 + 4);
    if (__PAIR128__(a2, a1) < a3) {
      return (v3 - 3);
    }
  }
  return (v3 - 1);
}

_WORD *std::__itoa::__base_10_u128[abi:ne180100](unsigned char *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = a1;
  if (__PAIR128__(a3, a2) >= __PAIR128__(0x4B3B4CA85A86C47ALL, 0x98A224000000000))
  {
    *a1 = __udivti3() | 0x30;
    unsigned int v7 = __udivti3();
    *((unsigned char *)v3 + 1) = v7 / 0x5F5E100 + 48;
    v3[1] = std::__itoa::__digits_base_10[v7 % 0x5F5E100 / 0xF4240];
    unsigned int v8 = v7 % 0x5F5E100 % 0xF4240;
    v3[2] = std::__itoa::__digits_base_10[v8 / 0x2710uLL];
    v8 %= 0x2710u;
    v3[3] = std::__itoa::__digits_base_10[(unsigned __int16)v8 / 0x64u];
    v3[4] = std::__itoa::__digits_base_10[(unsigned __int16)v8 % 0x64u];
    unint64_t v9 = __udivti3();
    uint64_t v10 = v3 + 5;
  }
  else
  {
    unint64_t v4 = __udivti3();
    unint64_t v5 = v4;
    if (!HIDWORD(v4))
    {
      unsigned int v6 = std::__itoa::__base_10_u32[abi:ne180100](v3, v4);
      goto LABEL_9;
    }
    if (v4 > 0x2540BE3FFLL)
    {
      uint64_t v3 = std::__itoa::__base_10_u32[abi:ne180100](v3, v4 / 0x2540BE400);
      v5 %= 0x2540BE400uLL;
    }
    uint64_t v10 = v3;
    unint64_t v9 = v5;
  }
  unsigned int v6 = std::__itoa::__append10[abi:ne180100]<unsigned long long>(v10, v9);
LABEL_9:
  unsigned int v11 = v6;
  unint64_t v12 = __umodti3();
  *(unsigned char *)unsigned int v11 = v12 / 0x2540BE400 / 0x5F5E100 + 48;
  unsigned int v13 = v12 / 0x2540BE400 % 0x5F5E100;
  *(_WORD *)((char *)v11 + 1) = std::__itoa::__digits_base_10[v13 / 0xF4240];
  v13 %= 0xF4240u;
  *(_WORD *)((char *)v11 + 3) = std::__itoa::__digits_base_10[v13 / 0x2710uLL];
  v13 %= 0x2710u;
  *(_WORD *)((char *)v11 + 5) = std::__itoa::__digits_base_10[(unsigned __int16)v13 / 0x64u];
  *(_WORD *)((char *)v11 + 7) = std::__itoa::__digits_base_10[(unsigned __int16)v13 % 0x64u];
  return std::__itoa::__append10[abi:ne180100]<unsigned long long>((_WORD *)((char *)v11 + 9), v12 % 0x2540BE400);
}

uint64_t std::__itoa::__integral<2u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = __clz(a3 | 1) | 0x40;
  unint64_t v5 = __clz(a4);
  if (a4) {
    unint64_t v4 = v5;
  }
  int64_t v6 = 128 - v4;
  if (a2 - a1 < v6) {
    return a2;
  }
  uint64_t v7 = a1 + v6;
  if (__PAIR128__(a4, a3) < 0x11)
  {
    unint64_t v9 = a3;
    unint64_t v12 = a4;
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = a1 + v6;
    do
    {
      *((void *)&v10 + 1) = a4;
      *(void *)&long long v10 = a3;
      unint64_t v9 = v10 >> 4;
      BOOL v11 = a3 <= 0x10F;
      unint64_t v12 = a4 >> 4;
      *(_DWORD *)(v8 - 4) = std::__itoa::__base_2_lut[a3 & 0xF];
      v8 -= 4;
      a3 = v9;
      a4 >>= 4;
    }
    while (!v11);
  }
  unsigned int v13 = (unsigned char *)(v8 - 1);
  do
  {
    unint64_t v14 = v9 & 1;
    BOOL v11 = v9 <= 1;
    *((void *)&v15 + 1) = v12;
    *(void *)&long long v15 = v9;
    unint64_t v9 = v15 >> 1;
    v12 >>= 1;
    *v13-- = a01[v14];
  }
  while (!v11);
  return v7;
}

uint64_t std::__itoa::__integral<8u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  char v4 = __clz(a3 | 1) | 0x40;
  char v5 = __clz(a4);
  if (a4) {
    char v4 = v5;
  }
  uint64_t v6 = (-126 - v4) / 3u;
  if (a2 - a1 < v6) {
    return a2;
  }
  uint64_t v7 = a1 + v6;
  if (__PAIR128__(a4, a3) < 0x41)
  {
    unint64_t v9 = a3;
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = a1 + v6;
    do
    {
      *((void *)&v10 + 1) = a4;
      *(void *)&long long v10 = a3;
      unint64_t v9 = v10 >> 6;
      a4 >>= 6;
      *(_WORD *)(v8 - 2) = std::__itoa::__base_8_lut[a3 & 0x3F];
      v8 -= 2;
      a3 = v9;
    }
    while (v9 > 0x40);
  }
  BOOL v11 = (unsigned char *)(v8 - 1);
  do
  {
    unint64_t v12 = v9 & 7;
    BOOL v13 = v9 <= 7;
    *((void *)&v14 + 1) = a4;
    *(void *)&long long v14 = v9;
    unint64_t v9 = v14 >> 3;
    a4 >>= 3;
    *v11-- = a01234567[v12];
  }
  while (!v13);
  return v7;
}

uint64_t std::__itoa::__integral<16u>::__to_chars[abi:ne180100]<unsigned __int128>(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = __clz(a3 | 1) | 0x40;
  unint64_t v5 = __clz(a4);
  if (a4) {
    unint64_t v4 = v5;
  }
  unint64_t v6 = 131 - v4;
  if (a2 - a1 < (uint64_t)(v6 >> 2)) {
    return a2;
  }
  uint64_t v7 = a1 + (v6 >> 2);
  if (__PAIR128__(a4, a3) < 0x101)
  {
    unint64_t v9 = a3;
    uint64_t v8 = v7;
  }
  else
  {
    uint64_t v8 = a1 + (v6 >> 2);
    do
    {
      *((void *)&v10 + 1) = a4;
      *(void *)&long long v10 = a3;
      unint64_t v9 = v10 >> 8;
      a4 >>= 8;
      *(_WORD *)(v8 - 2) = std::__itoa::__base_16_lut[a3];
      v8 -= 2;
      a3 = v9;
    }
    while (v9 > 0x100);
  }
  BOOL v11 = (unsigned char *)(v8 - 1);
  do
  {
    unint64_t v12 = v9 & 0xF;
    BOOL v13 = v9 <= 0xF;
    *((void *)&v14 + 1) = a4;
    *(void *)&long long v14 = v9;
    unint64_t v9 = v14 >> 4;
    a4 >>= 4;
    *v11-- = a0123456789abcd_0[v12];
  }
  while (!v13);
  return v7;
}

void *std::__formatter_integer<char>::format[abi:ne180100]<unsigned int,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, unsigned int a2, void *a3)
{
  unint64_t v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  unint64_t v7 = v5;
  if ((v6 & 0xFF00) == 0xA00)
  {
    uint64_t v8 = (void *)*a3;
    return std::__formatter::__format_char[abi:ne180100]<char,unsigned int,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, v8, v6, v7);
  }
  else
  {
    return std::__formatter::__format_integer[abi:ne180100]<unsigned int,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (void **)a3, v6, v5, 0);
  }
}

void *std::__formatter::__format_char[abi:ne180100]<char,unsigned int,std::back_insert_iterator<std::__format::__output_buffer<char>>>(unsigned int a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (a1 >= 0x80) {
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  }
  char __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a2, a3, a4, 1);
}

void *std::__formatter_integer<char>::format[abi:ne180100]<unsigned long long,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, unint64_t a2, void *a3)
{
  unint64_t v6 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  unint64_t v7 = v5;
  if ((v6 & 0xFF00) == 0xA00)
  {
    uint64_t v8 = (void *)*a3;
    return std::__formatter::__format_char[abi:ne180100]<char,unsigned long long,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, v8, v6, v7);
  }
  else
  {
    return std::__formatter::__format_integer[abi:ne180100]<unsigned long long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (void **)a3, v6, v5, 0);
  }
}

void *std::__formatter::__format_char[abi:ne180100]<char,unsigned long long,std::back_insert_iterator<std::__format::__output_buffer<char>>>(unint64_t a1, void *a2, uint64_t a3, unint64_t a4)
{
  if (a1 >= 0x80) {
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  }
  char __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a2, a3, a4, 1);
}

void *std::__formatter_integer<char>::format[abi:ne180100]<unsigned __int128,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, unint64_t a2, unint64_t a3, void *a4)
{
  unint64_t v8 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a4);
  if ((v8 & 0xFF00) == 0xA00)
  {
    unint64_t v9 = (void *)*a4;
    return std::__formatter::__format_char[abi:ne180100]<char,unsigned __int128,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, a3, v9, v8, v7);
  }
  else
  {
    return std::__formatter::__format_integer[abi:ne180100]<unsigned __int128,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, a3, (void **)a4, v8, v7, 0);
  }
}

void *std::__formatter::__format_char[abi:ne180100]<char,unsigned __int128,std::back_insert_iterator<std::__format::__output_buffer<char>>>(unint64_t a1, unint64_t a2, void *a3, uint64_t a4, unint64_t a5)
{
  if (__PAIR128__(a2, a1) >= 0x80) {
    std::__throw_format_error[abi:ne180100]("Integral value outside the range of the char type");
  }
  char __src = a1;
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, 1uLL, a3, a4, a5, 1);
}

void *std::__formatter::__format_floating_point[abi:ne180100]<float,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t **a1, uint64_t a2, unint64_t a3, float a4)
{
  v46[32] = *MEMORY[0x263EF8340];
  int v7 = LODWORD(a4) >> 31;
  if ((LODWORD(a4) & 0x7FFFFFFFu) < 0x7F800000)
  {
    unint64_t v8 = (unint64_t)a2 >> 8;
    if (a4 >= 0.0) {
      float v9 = a4;
    }
    else {
      float v9 = -a4;
    }
    if (a3 == -1) {
      int v10 = 149;
    }
    else {
      int v10 = a3;
    }
    int v42 = v10;
    int v43 = 0;
    if (v10 < 150)
    {
      unint64_t v44 = v10 + 45;
      if ((v10 + 45) >= 0x101)
      {
        BOOL v11 = operator new(v10 + 45);
LABEL_13:
        std::string __p = v11;
        std::__formatter::__format_buffer[abi:ne180100]<float,float>((unsigned int *)&v42, v7, (a3 & 0x80000000) == 0, (a2 >> 3) & 3, v8, (std::__1 **)&v38, v9);
        if ((a2 & 0x20) != 0)
        {
          unint64_t v12 = v39;
          if (v39 == *(char **)v41)
          {
            *(void *)uint64_t v41 = v39 + 1;
            *unsigned __int8 v39 = 46;
            BOOL v13 = v40;
            long long v14 = (char *)(*(void *)v41 - 1);
            if (v40 != (char *)(*(void *)v41 - 1))
            {
              if (v40 + 1 == v14)
              {
                char v16 = *v40;
                *uint64_t v40 = *v14;
                *long long v14 = v16;
              }
              else
              {
                char v15 = *(unsigned char *)(*(void *)v41 - 1);
                memmove(v40 + 1, v40, *(void *)v41 - 1 - (void)v40);
                *BOOL v13 = v15;
              }
            }
            unint64_t v12 = v40;
            unsigned __int8 v39 = v40++;
          }
          if ((BYTE1(a2) - 17) <= 1u)
          {
            if (a3 <= 1) {
              int v17 = 1;
            }
            else {
              int v17 = a3;
            }
            if ((a3 & 0x80000000) != 0) {
              int v17 = 6;
            }
            if (v40 == *(char **)v41) {
              int v18 = v38 - v12;
            }
            else {
              int v18 = -1;
            }
            int v19 = v18 + v17;
            int v20 = &v40[~(unint64_t)v12];
            if ((uint64_t)v20 < v19) {
              v43 += v19 - v20;
            }
          }
        }
        if ((a2 & 0x40) != 0)
        {
          uint64_t v28 = *a1;
          std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a1, &v37);
          unsigned int v29 = std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,float,char>(v28, (uint64_t)&v42, &v38, &v37, a2, a3);
          std::locale::~locale(&v37);
        }
        else
        {
          uint64_t v21 = *(void *)v41;
          BOOL v22 = (char *)__p;
          uint64_t v23 = *(void *)v41 - (void)__p;
          size_t v24 = v43;
          if (*(void *)v41 - (void)__p + v43 >= a2 >> 32)
          {
            if (!v43 || (uint64_t v30 = v40, v40 == *(char **)v41))
            {
              unsigned int v29 = *a1;
              std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, *(void *)v41 - (void)__p);
              std::__format::__output_buffer<char>::__fill[abi:ne180100](v29, v24, 48);
            }
            else
            {
              unsigned int v29 = *a1;
              std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v40 - (unsigned char *)__p);
              std::__format::__output_buffer<char>::__fill[abi:ne180100](v29, v24, 48);
              std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v29, v30, v21 - (void)v30);
            }
          }
          else
          {
            uint64_t v25 = *a1;
            if ((a2 & 7) == 4)
            {
              if (__p != v38)
              {
                unint64_t v36 = v25;
                std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v36, (char *)__p);
                ++v22;
              }
              unsigned __int8 v26 = a2 & 0xF8 | 3;
              unsigned __int8 v27 = 48;
            }
            else
            {
              unsigned __int8 v27 = BYTE4(a3);
              unsigned __int8 v26 = a2;
            }
            unint64_t v31 = a2 & 0xFFFFFFFFFFFFFF00 | v26;
            unint64_t v32 = a3 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v27 << 32);
            if (v24) {
              BOOL v33 = std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v22, *(uint64_t *)v41, v25, v31, v32, v23, v40, v24);
            }
            else {
              BOOL v33 = std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v22, *(void *)v41 - (void)v22, v25, v31, v32, v23);
            }
            unsigned int v29 = v33;
          }
        }
        if (v44 >= 0x101) {
          operator delete(__p);
        }
        return v29;
      }
    }
    else
    {
      int v42 = 149;
      int v43 = v10 - 149;
      unint64_t v44 = 194;
    }
    BOOL v11 = v46;
    goto LABEL_13;
  }
  unint64_t v35 = *a1;
  return std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(v35, a2, a3, a4 < 0.0, 0);
}

void sub_210AC12B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unint64_t a16, void *__p)
{
  if (a16 >= 0x101) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(void *a1, uint64_t a2, unint64_t a3, char a4, int a5)
{
  if (a4)
  {
    char v5 = 45;
  }
  else
  {
    int v6 = (a2 >> 3) & 3;
    if (v6 == 2)
    {
      char v5 = 43;
    }
    else
    {
      if (v6 != 3)
      {
        p_src = &__src;
        goto LABEL_8;
      }
      char v5 = 32;
    }
  }
  p_src = v14;
  char __src = v5;
LABEL_8:
  if (BYTE1(a2) <= 0x10u && ((1 << SBYTE1(a2)) & 0x15000) != 0)
  {
    uint64_t v8 = 6;
  }
  else
  {
    uint64_t v8 = 6;
    if (BYTE1(a2) != 18) {
      uint64_t v8 = 0;
    }
  }
  uint64_t v9 = 3;
  if (!a5) {
    uint64_t v9 = 0;
  }
  int v10 = &aInfnaninfnan[v8 + v9];
  *(_WORD *)p_src = *(_WORD *)v10;
  p_src[2] = v10[2];
  if ((a2 & 7) == 4) {
    unsigned __int8 v11 = a2 & 0xF8 | 3;
  }
  else {
    unsigned __int8 v11 = a2;
  }
  return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(&__src, p_src - &__src + 3, a1, a2 & 0xFFFFFFFFFFFFFF00 | v11, a3, p_src - &__src + 3);
}

uint64_t std::__formatter::__format_buffer[abi:ne180100]<float,float>@<X0>(unsigned int *a1@<X0>, char a2@<W1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, std::__1 **a6@<X8>, float a7@<S0>)
{
  uint64_t v9 = (std::__1 *)*((void *)a1 + 2);
  if (a2)
  {
    char v10 = 45;
  }
  else if (a4 == 2)
  {
    char v10 = 43;
  }
  else
  {
    if (a4 != 3) {
      goto LABEL_8;
    }
    char v10 = 32;
  }
  *(unsigned char *)uint64_t v9 = v10;
  uint64_t v9 = (std::__1 *)((char *)v9 + 1);
LABEL_8:
  switch(a5)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      __break(1u);
      JUMPOUT(0x210AC15A4);
    case 11:
      if (a3) {
        int v14 = *a1;
      }
      else {
        int v14 = -1;
      }
      return std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>((uint64_t)a1, v14, (uint64_t)v9, a6);
    case 12:
      if (a3) {
        int v17 = *a1;
      }
      else {
        int v17 = -1;
      }
      return std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<float,float>((uint64_t)a1, v17, (uint64_t)v9, a6);
    case 13:
      uint64_t v18 = *a1;
      return std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>((uint64_t)a1, v18, (uint64_t)v9, a6);
    case 14:
      uint64_t result = std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>((uint64_t)a1, *a1, (uint64_t)v9, a6);
      char v16 = a6[2];
      goto LABEL_25;
    case 15:
    case 16:
      uint64_t v11 = *a1;
      *a6 = v9;
      uint64_t result = MEMORY[0x21667A280](v9, *((void *)a1 + 2) + *((void *)a1 + 1), 2, v11);
      a6[2] = (std::__1 *)result;
      a6[3] = (std::__1 *)result;
      if (v11) {
        int v13 = v11 + 1;
      }
      else {
        int v13 = 0;
      }
      a6[1] = (std::__1 *)(result - v13);
      return result;
    case 17:
      goto LABEL_20;
    case 18:
      uint64_t result = (uint64_t)std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<float,float>((uint64_t)a1, *a1, (uint64_t)v9, a6);
      char v16 = a6[2];
      if (v16 != a6[3]) {
LABEL_25:
      }
        *(unsigned char *)char v16 = 69;
      break;
    default:
      if (a3)
      {
LABEL_20:
        uint64_t v15 = *a1;
        uint64_t result = (uint64_t)std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<float,float>((uint64_t)a1, v15, (uint64_t)v9, a6);
      }
      else
      {
        uint64_t result = (uint64_t)std::__formatter::__format_buffer_default[abi:ne180100]<float,float>(v9, (uint64_t)a1, (char *)v9, a6, a7);
      }
      break;
  }
  return result;
}

void *std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,float,char>(void *a1, uint64_t a2, char **a3, std::locale *this, uint64_t a5, unint64_t a6)
{
  uint64_t v11 = std::locale::use_facet(this, MEMORY[0x263F8C150]);
  ((void (*)(std::string *__return_ptr))v11->__vftable[1].__on_zero_shared)(&__p);
  unint64_t v12 = a3[2];
  int v13 = *a3;
  if (v12 >= a3[1]) {
    unint64_t v12 = a3[1];
  }
  int64_t __len = v12 - v13;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    if (!__p.__r_.__value_.__l.__size_) {
      goto LABEL_29;
    }
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (__len <= *__p.__r_.__value_.__l.__data_)
    {
      *__p.__r_.__value_.__l.__data_ = 0;
      __p.__r_.__value_.__l.__size_ = 0;
      goto LABEL_29;
    }
    std::string::size_type v16 = __p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
      goto LABEL_29;
    }
    if (__len <= __p.__r_.__value_.__s.__data_[0])
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_29;
    }
    p_p = &__p;
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    std::string::size_type v16 = __p.__r_.__value_.__r.__words[0];
  }
  memset(&v56, 0, sizeof(v56));
  int v17 = (char *)(v16 + size);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v17 = (char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  std::string::value_type v18 = p_p->__r_.__value_.__s.__data_[0];
  uint64_t v19 = __len - p_p->__r_.__value_.__s.__data_[0];
  if (v19 >= 1)
  {
    int v20 = v17 - 1;
    do
    {
      std::string::push_back(&v56, v18);
      if (p_p == (std::string *)v20)
      {
        std::string::value_type v18 = *v20;
        p_p = (std::string *)v20;
      }
      else
      {
        uint64_t v21 = &p_p->__r_.__value_.__s.__data_[1];
        BOOL v22 = &p_p->__r_.__value_.__s.__data_[1];
        do
        {
          int v23 = *v22++;
          std::string::value_type v18 = v23;
          if (v23) {
            BOOL v24 = 1;
          }
          else {
            BOOL v24 = v21 == v20;
          }
          uint64_t v21 = v22;
        }
        while (!v24);
        p_p = (std::string *)(v22 - 1);
      }
      v19 -= v18;
    }
    while (v19 > 0);
  }
  std::string::push_back(&v56, v18 + v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = v56;
LABEL_29:
  unint64_t v25 = HIDWORD(a6);
  unsigned __int8 v26 = *(char **)(a2 + 16);
  std::string::size_type v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v27 = __p.__r_.__value_.__l.__size_;
  }
  int64_t v28 = a3[3] - v26 + *(int *)(a2 + 4) + v27 - (v27 != 0);
  int v29 = a5 & 7;
  size_t v30 = (a5 >> 32) - v28;
  if (a5 >> 32 <= v28)
  {
    size_t v34 = 0;
    size_t v33 = 0;
    unsigned __int8 v31 = v25;
  }
  else
  {
    if (v29 == 4) {
      unsigned __int8 v31 = 48;
    }
    else {
      unsigned __int8 v31 = v25;
    }
    if (v29 == 4) {
      uint64_t v32 = 3;
    }
    else {
      uint64_t v32 = a5 & 7;
    }
    size_t v33 = 0;
    size_t v34 = (a5 >> 32) - v28;
    switch(v32)
    {
      case 1:
        break;
      case 2:
        size_t v33 = v30 >> 1;
        size_t v34 = v30 - (v30 >> 1);
        break;
      default:
        size_t v34 = 0;
        size_t v33 = v30;
        break;
    }
  }
  size_t v54 = v34;
  if (v29 == 4 && v13 != v26)
  {
    v56.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v56, v26);
  }
  int v35 = v25 & 0xFFFFFF00 | v31;
  unint64_t v36 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, v33, v35);
  std::locale v37 = v36;
  if (v29 != 4)
  {
    int v38 = *(char **)(a2 + 16);
    if (v13 != v38)
    {
      v56.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
      std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v56, v38);
    }
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type v39 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
    {
      uint64_t v40 = &__p.__r_.__value_.__s.__data_[1];
      uint64_t v41 = &__p;
      goto LABEL_52;
    }
LABEL_56:
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v37, v13, __len);
    goto LABEL_57;
  }
  std::string::size_type v39 = __p.__r_.__value_.__l.__size_;
  if (!__p.__r_.__value_.__l.__size_) {
    goto LABEL_56;
  }
  uint64_t v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
  uint64_t v40 = (char *)(__p.__r_.__value_.__r.__words[0] + 1);
LABEL_52:
  int v42 = (char *)v41 + v39;
  char v43 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet_0)(v11);
  while (1)
  {
    unint64_t v44 = v42 - 1;
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v37, v13, *(v42 - 1));
    if (v42 == v40) {
      break;
    }
    v13 += *(v42 - 1);
    uint64_t v45 = *v37;
    uint64_t v46 = v37[2];
    v37[2] = v46 + 1;
    *(unsigned char *)(v45 + v46) = v43;
    --v42;
    if (v37[2] == v37[1])
    {
      ((void (*)(void))v37[3])(*v37);
      v37[2] = 0;
      int v42 = v44;
    }
  }
LABEL_57:
  uint64_t v47 = a3[1];
  if (v47 != a3[3])
  {
    char v48 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet)(v11);
    uint64_t v49 = *v37;
    uint64_t v50 = v37[2];
    v37[2] = v50 + 1;
    *(unsigned char *)(v49 + v50) = v48;
    if (v37[2] == v37[1])
    {
      ((void (*)(void))v37[3])(*v37);
      v37[2] = 0;
    }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v37, a3[1] + 1, a3[2] - (a3[1] + 1));
    std::__format::__output_buffer<char>::__fill[abi:ne180100](v37, *(int *)(a2 + 4), 48);
    uint64_t v47 = a3[3];
  }
  unsigned int v51 = a3[2];
  if (v51 != v47) {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v37, v51, v47 - v51);
  }
  unint64_t v52 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v37, v54, v35);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v52;
}

void sub_210AC1A64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *a1, uint64_t a2, void *a3, uint64_t a4, unint64_t a5, uint64_t a6, char *a7, size_t a8)
{
  size_t v8 = (a4 >> 32) - (a6 + a8);
  size_t v13 = 0;
  switch(a4 & 7)
  {
    case 1:
      break;
    case 2:
      size_t v13 = v8 >> 1;
      v8 -= v8 >> 1;
      break;
    default:
      size_t v13 = (a4 >> 32) - (a6 + a8);
      size_t v8 = 0;
      break;
  }
  unint64_t v14 = HIDWORD(a5);
  uint64_t v15 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a3, v13, SHIDWORD(a5));
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v15, a1, a7 - a1);
  std::__format::__output_buffer<char>::__fill[abi:ne180100](v15, a8, 48);
  std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v15, a7, a2 - (void)a7);
  return std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v15, v8, v14);
}

unsigned char *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<float,float>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *(_DWORD *)(a1 + 4) = 0;
  *a4 = a3;
  uint64_t v6 = MEMORY[0x21667A280](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 3, a2);
  a4[3] = v6;
  uint64_t result = (unsigned char *)(a3 + 1);
  if (a3 + 1 != v6)
  {
    size_t v8 = v6 - (void)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a4[2] = v6;
    }
    else
    {
      uint64_t v9 = 6;
      if (v8 < 6) {
        uint64_t v9 = v6 - (void)result;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(v6 + v10) != 101)
      {
        if (++v10 == -3) {
          goto LABEL_8;
        }
      }
      a4[2] = v6 + v10;
      if (v10)
      {
        if (*result == 46) {
          uint64_t v11 = (unsigned char *)(a3 + 1);
        }
        else {
          uint64_t v11 = (unsigned char *)v6;
        }
        goto LABEL_12;
      }
    }
    uint64_t result = memchr(result, 46, v8);
    if (result) {
      uint64_t v11 = result;
    }
    else {
      uint64_t v11 = (unsigned char *)v6;
    }
LABEL_12:
    a4[1] = v11;
    return result;
  }
  a4[1] = v6;
  a4[2] = v6;
  return result;
}

unsigned char *std::__formatter::__format_buffer_default[abi:ne180100]<float,float>@<X0>(std::__1 *this@<X1>, uint64_t a2@<X0>, char *a3@<X2>, void *a4@<X8>, float a5@<S0>)
{
  *a4 = this;
  uint64_t v7 = std::to_chars(this, (char *)(*(void *)(a2 + 16) + *(void *)(a2 + 8)), a3, a5);
  size_t v8 = (unsigned char *)v7;
  a4[3] = v7;
  unint64_t v9 = v7 - (void)this;
  uint64_t v10 = (unsigned char *)v7;
  if (v7 - (uint64_t)this >= 4)
  {
    if (v9 >= 6) {
      unint64_t v9 = 6;
    }
    uint64_t v11 = -(uint64_t)v9;
    while (*(unsigned char *)(v7 + v11) != 101)
    {
      if (++v11 == -3)
      {
        uint64_t v10 = (unsigned char *)v7;
        goto LABEL_9;
      }
    }
    uint64_t v10 = (unsigned char *)(v7 + v11);
  }
LABEL_9:
  a4[2] = v10;
  uint64_t result = memchr((char *)this + 1, 46, v10 - ((char *)this + 1));
  if (result) {
    size_t v13 = result;
  }
  else {
    size_t v13 = v10;
  }
  if (v13 == v10) {
    size_t v13 = v8;
  }
  a4[1] = v13;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = a3;
  if (a2 == -1) {
    uint64_t result = std::to_chars();
  }
  else {
    uint64_t result = MEMORY[0x21667A280](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 4);
  }
  a4[3] = result;
  int v8 = *(unsigned __int8 *)(a3 + 1);
  uint64_t v7 = a3 + 1;
  if (v8 == 46)
  {
    uint64_t v9 = result - 2;
    uint64_t v10 = memchr((void *)(result - 5), 112, 3uLL);
    uint64_t result = v7;
    if (v10) {
      uint64_t v7 = (uint64_t)v10;
    }
    else {
      uint64_t v7 = v9;
    }
  }
  a4[1] = result;
  a4[2] = v7;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<float,float>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t result = std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<float,float>(a1, a2, a3, a4);
  uint64_t v6 = (unsigned char *)*a4;
  uint64_t v7 = (unsigned char *)a4[2];
  if ((unsigned char *)*a4 != v7)
  {
    do
    {
      int v8 = (char)*v6;
      if ((v8 - 97) < 6) {
        LOBYTE(v8) = v8 - 32;
      }
      *v6++ = v8;
    }
    while (v6 != v7);
    uint64_t v6 = (unsigned char *)a4[2];
  }
  *uint64_t v6 = 80;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<float,float>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = a3;
  uint64_t result = MEMORY[0x21667A280](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 1, a2);
  a4[3] = result;
  uint64_t v7 = a3 + 1;
  if (*(unsigned char *)(a3 + 1) == 46)
  {
    a4[1] = v7;
    uint64_t v8 = result - a3 - 2;
    uint64_t v7 = result;
    if (v8 >= 4)
    {
      uint64_t v9 = 6;
      if ((unint64_t)v8 < 6) {
        uint64_t v9 = result - a3 - 2;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(result + v10) != 101)
      {
        if (++v10 == -3)
        {
          uint64_t v7 = result;
          goto LABEL_11;
        }
      }
      uint64_t v7 = result + v10;
    }
  }
  else
  {
    a4[1] = result;
  }
LABEL_11:
  a4[2] = v7;
  return result;
}

void *std::__formatter::__format_floating_point[abi:ne180100]<double,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t **a1, uint64_t a2, unint64_t a3, double a4)
{
  v47[128] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)&a4 >> 63;
  if ((*(void *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
  {
    unint64_t v8 = (unint64_t)a2 >> 8;
    if (a4 >= 0.0) {
      double v9 = a4;
    }
    else {
      double v9 = -a4;
    }
    if (a3 == -1) {
      int v10 = 1074;
    }
    else {
      int v10 = a3;
    }
    int v43 = v10;
    int v44 = 0;
    if (v10 < 1075)
    {
      size_t v11 = v10 + 316;
      unint64_t v45 = v11;
      if ((v10 + 316) < 0x401)
      {
        unint64_t v12 = v47;
        goto LABEL_13;
      }
    }
    else
    {
      int v43 = 1074;
      int v44 = v10 - 1074;
      size_t v11 = 1390;
      unint64_t v45 = 1390;
    }
    unint64_t v12 = operator new(v11);
LABEL_13:
    std::string __p = v12;
    std::__formatter::__format_buffer[abi:ne180100]<double,double>((unsigned int *)&v43, v7, (a3 & 0x80000000) == 0, (a2 >> 3) & 3, v8, (std::__1 **)&v39, v9);
    if ((a2 & 0x20) != 0)
    {
      size_t v13 = v40;
      if (v40 == *(char **)v42)
      {
        *(void *)int v42 = v40 + 1;
        *uint64_t v40 = 46;
        unint64_t v14 = v41;
        uint64_t v15 = (char *)(*(void *)v42 - 1);
        if (v41 != (char *)(*(void *)v42 - 1))
        {
          if (v41 + 1 == v15)
          {
            char v17 = *v41;
            *uint64_t v41 = *v15;
            char *v15 = v17;
          }
          else
          {
            char v16 = *(unsigned char *)(*(void *)v42 - 1);
            memmove(v41 + 1, v41, *(void *)v42 - 1 - (void)v41);
            *unint64_t v14 = v16;
          }
        }
        size_t v13 = v41;
        uint64_t v40 = v41++;
      }
      if ((BYTE1(a2) - 17) <= 1u)
      {
        if (a3 <= 1) {
          int v18 = 1;
        }
        else {
          int v18 = a3;
        }
        if ((a3 & 0x80000000) != 0) {
          int v18 = 6;
        }
        if (v41 == *(char **)v42) {
          int v19 = v39 - v13;
        }
        else {
          int v19 = -1;
        }
        int v20 = v19 + v18;
        uint64_t v21 = &v41[~(unint64_t)v13];
        if ((uint64_t)v21 < v20) {
          v44 += v20 - v21;
        }
      }
    }
    if ((a2 & 0x40) != 0)
    {
      int v29 = *a1;
      std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a1, &v38);
      size_t v30 = std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(v29, (uint64_t)&v43, &v39, &v38, a2, a3);
      std::locale::~locale(&v38);
    }
    else
    {
      uint64_t v22 = *(void *)v42;
      int v23 = (char *)__p;
      uint64_t v24 = *(void *)v42 - (void)__p;
      size_t v25 = v44;
      if (*(void *)v42 - (void)__p + v44 >= a2 >> 32)
      {
        if (!v44 || (unsigned __int8 v31 = v41, v41 == *(char **)v42))
        {
          size_t v30 = *a1;
          std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, *(void *)v42 - (void)__p);
          std::__format::__output_buffer<char>::__fill[abi:ne180100](v30, v25, 48);
        }
        else
        {
          size_t v30 = *a1;
          std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v41 - (unsigned char *)__p);
          std::__format::__output_buffer<char>::__fill[abi:ne180100](v30, v25, 48);
          std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v30, v31, v22 - (void)v31);
        }
      }
      else
      {
        unsigned __int8 v26 = *a1;
        if ((a2 & 7) == 4)
        {
          if (__p != v39)
          {
            std::locale v37 = v26;
            std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v37, (char *)__p);
            ++v23;
          }
          unsigned __int8 v27 = a2 & 0xF8 | 3;
          unsigned __int8 v28 = 48;
        }
        else
        {
          unsigned __int8 v28 = BYTE4(a3);
          unsigned __int8 v27 = a2;
        }
        unint64_t v32 = a2 & 0xFFFFFFFFFFFFFF00 | v27;
        unint64_t v33 = a3 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v28 << 32);
        if (v25) {
          size_t v34 = std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v23, *(uint64_t *)v42, v26, v32, v33, v24, v41, v25);
        }
        else {
          size_t v34 = std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v23, *(void *)v42 - (void)v23, v26, v32, v33, v24);
        }
        size_t v30 = v34;
      }
    }
    if (v45 >= 0x401) {
      operator delete(__p);
    }
    return v30;
  }
  unint64_t v36 = *a1;
  return std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(v36, a2, a3, a4 < 0.0, 0);
}

void sub_210AC22CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unint64_t a16, void *__p)
{
  if (a16 >= 0x401) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__formatter::__format_buffer[abi:ne180100]<double,double>@<X0>(unsigned int *a1@<X0>, char a2@<W1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, std::__1 **a6@<X8>, double a7@<D0>)
{
  double v9 = (std::__1 *)*((void *)a1 + 2);
  if (a2)
  {
    char v10 = 45;
  }
  else if (a4 == 2)
  {
    char v10 = 43;
  }
  else
  {
    if (a4 != 3) {
      goto LABEL_8;
    }
    char v10 = 32;
  }
  *(unsigned char *)double v9 = v10;
  double v9 = (std::__1 *)((char *)v9 + 1);
LABEL_8:
  switch(a5)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      __break(1u);
      JUMPOUT(0x210AC24B8);
    case 11:
      if (a3) {
        int v14 = *a1;
      }
      else {
        int v14 = -1;
      }
      return std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>((uint64_t)a1, v14, (uint64_t)v9, a6);
    case 12:
      if (a3) {
        int v17 = *a1;
      }
      else {
        int v17 = -1;
      }
      return std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<double,double>((uint64_t)a1, v17, (uint64_t)v9, a6);
    case 13:
      uint64_t v18 = *a1;
      return std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>((uint64_t)a1, v18, (uint64_t)v9, a6);
    case 14:
      uint64_t result = std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>((uint64_t)a1, *a1, (uint64_t)v9, a6);
      char v16 = a6[2];
      goto LABEL_25;
    case 15:
    case 16:
      uint64_t v11 = *a1;
      *a6 = v9;
      uint64_t result = MEMORY[0x21667A220](v9, *((void *)a1 + 2) + *((void *)a1 + 1), 2, v11);
      a6[2] = (std::__1 *)result;
      a6[3] = (std::__1 *)result;
      if (v11) {
        int v13 = v11 + 1;
      }
      else {
        int v13 = 0;
      }
      a6[1] = (std::__1 *)(result - v13);
      return result;
    case 17:
      goto LABEL_20;
    case 18:
      uint64_t result = (uint64_t)std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,double>((uint64_t)a1, *a1, (uint64_t)v9, a6);
      char v16 = a6[2];
      if (v16 != a6[3]) {
LABEL_25:
      }
        *(unsigned char *)char v16 = 69;
      break;
    default:
      if (a3)
      {
LABEL_20:
        uint64_t v15 = *a1;
        uint64_t result = (uint64_t)std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,double>((uint64_t)a1, v15, (uint64_t)v9, a6);
      }
      else
      {
        uint64_t result = (uint64_t)std::__formatter::__format_buffer_default[abi:ne180100]<double,double>(v9, (uint64_t)a1, (char *)v9, a6, a7);
      }
      break;
  }
  return result;
}

void *std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(void *a1, uint64_t a2, char **a3, std::locale *this, uint64_t a5, unint64_t a6)
{
  uint64_t v11 = std::locale::use_facet(this, MEMORY[0x263F8C150]);
  ((void (*)(std::string *__return_ptr))v11->__vftable[1].__on_zero_shared)(&__p);
  unint64_t v12 = a3[2];
  int v13 = *a3;
  if (v12 >= a3[1]) {
    unint64_t v12 = a3[1];
  }
  int64_t __len = v12 - v13;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    if (!__p.__r_.__value_.__l.__size_) {
      goto LABEL_29;
    }
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (__len <= *__p.__r_.__value_.__l.__data_)
    {
      *__p.__r_.__value_.__l.__data_ = 0;
      __p.__r_.__value_.__l.__size_ = 0;
      goto LABEL_29;
    }
    std::string::size_type v16 = __p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
      goto LABEL_29;
    }
    if (__len <= __p.__r_.__value_.__s.__data_[0])
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
      goto LABEL_29;
    }
    p_p = &__p;
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    std::string::size_type v16 = __p.__r_.__value_.__r.__words[0];
  }
  memset(&v56, 0, sizeof(v56));
  int v17 = (char *)(v16 + size);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v17 = (char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  std::string::value_type v18 = p_p->__r_.__value_.__s.__data_[0];
  uint64_t v19 = __len - p_p->__r_.__value_.__s.__data_[0];
  if (v19 >= 1)
  {
    int v20 = v17 - 1;
    do
    {
      std::string::push_back(&v56, v18);
      if (p_p == (std::string *)v20)
      {
        std::string::value_type v18 = *v20;
        p_p = (std::string *)v20;
      }
      else
      {
        uint64_t v21 = &p_p->__r_.__value_.__s.__data_[1];
        uint64_t v22 = &p_p->__r_.__value_.__s.__data_[1];
        do
        {
          int v23 = *v22++;
          std::string::value_type v18 = v23;
          if (v23) {
            BOOL v24 = 1;
          }
          else {
            BOOL v24 = v21 == v20;
          }
          uint64_t v21 = v22;
        }
        while (!v24);
        p_p = (std::string *)(v22 - 1);
      }
      v19 -= v18;
    }
    while (v19 > 0);
  }
  std::string::push_back(&v56, v18 + v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = v56;
LABEL_29:
  unint64_t v25 = HIDWORD(a6);
  unsigned __int8 v26 = *(char **)(a2 + 16);
  std::string::size_type v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v27 = __p.__r_.__value_.__l.__size_;
  }
  int64_t v28 = a3[3] - v26 + *(int *)(a2 + 4) + v27 - (v27 != 0);
  int v29 = a5 & 7;
  size_t v30 = (a5 >> 32) - v28;
  if (a5 >> 32 <= v28)
  {
    size_t v34 = 0;
    size_t v33 = 0;
    unsigned __int8 v31 = v25;
  }
  else
  {
    if (v29 == 4) {
      unsigned __int8 v31 = 48;
    }
    else {
      unsigned __int8 v31 = v25;
    }
    if (v29 == 4) {
      uint64_t v32 = 3;
    }
    else {
      uint64_t v32 = a5 & 7;
    }
    size_t v33 = 0;
    size_t v34 = (a5 >> 32) - v28;
    switch(v32)
    {
      case 1:
        break;
      case 2:
        size_t v33 = v30 >> 1;
        size_t v34 = v30 - (v30 >> 1);
        break;
      default:
        size_t v34 = 0;
        size_t v33 = v30;
        break;
    }
  }
  size_t v54 = v34;
  if (v29 == 4 && v13 != v26)
  {
    v56.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v56, v26);
  }
  int v35 = v25 & 0xFFFFFF00 | v31;
  unint64_t v36 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a1, v33, v35);
  std::locale v37 = v36;
  if (v29 != 4)
  {
    std::locale v38 = *(char **)(a2 + 16);
    if (v13 != v38)
    {
      v56.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
      std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100]((uint64_t **)&v56, v38);
    }
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type v39 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&__p.__r_.__value_.__s + 23))
    {
      uint64_t v40 = &__p.__r_.__value_.__s.__data_[1];
      uint64_t v41 = &__p;
      goto LABEL_52;
    }
LABEL_56:
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v37, v13, __len);
    goto LABEL_57;
  }
  std::string::size_type v39 = __p.__r_.__value_.__l.__size_;
  if (!__p.__r_.__value_.__l.__size_) {
    goto LABEL_56;
  }
  uint64_t v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
  uint64_t v40 = (char *)(__p.__r_.__value_.__r.__words[0] + 1);
LABEL_52:
  int v42 = (char *)v41 + v39;
  char v43 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet_0)(v11);
  while (1)
  {
    int v44 = v42 - 1;
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v37, v13, *(v42 - 1));
    if (v42 == v40) {
      break;
    }
    v13 += *(v42 - 1);
    uint64_t v45 = *v37;
    uint64_t v46 = v37[2];
    v37[2] = v46 + 1;
    *(unsigned char *)(v45 + v46) = v43;
    --v42;
    if (v37[2] == v37[1])
    {
      ((void (*)(void))v37[3])(*v37);
      v37[2] = 0;
      int v42 = v44;
    }
  }
LABEL_57:
  uint64_t v47 = a3[1];
  if (v47 != a3[3])
  {
    char v48 = ((uint64_t (*)(const std::locale::facet *))v11->__vftable[1].~facet)(v11);
    uint64_t v49 = *v37;
    uint64_t v50 = v37[2];
    v37[2] = v50 + 1;
    *(unsigned char *)(v49 + v50) = v48;
    if (v37[2] == v37[1])
    {
      ((void (*)(void))v37[3])(*v37);
      v37[2] = 0;
    }
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v37, a3[1] + 1, a3[2] - (a3[1] + 1));
    std::__format::__output_buffer<char>::__fill[abi:ne180100](v37, *(int *)(a2 + 4), 48);
    uint64_t v47 = a3[3];
  }
  unsigned int v51 = a3[2];
  if (v51 != v47) {
    std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v37, v51, v47 - v51);
  }
  unint64_t v52 = std::__formatter::__fill[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v37, v54, v35);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v52;
}

void sub_210AC2978(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,double>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *(_DWORD *)(a1 + 4) = 0;
  *a4 = a3;
  uint64_t v6 = MEMORY[0x21667A220](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 3, a2);
  a4[3] = v6;
  uint64_t result = (unsigned char *)(a3 + 1);
  if (a3 + 1 != v6)
  {
    size_t v8 = v6 - (void)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a4[2] = v6;
    }
    else
    {
      uint64_t v9 = 6;
      if (v8 < 6) {
        uint64_t v9 = v6 - (void)result;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(v6 + v10) != 101)
      {
        if (++v10 == -3) {
          goto LABEL_8;
        }
      }
      a4[2] = v6 + v10;
      if (v10)
      {
        if (*result == 46) {
          uint64_t v11 = (unsigned char *)(a3 + 1);
        }
        else {
          uint64_t v11 = (unsigned char *)v6;
        }
        goto LABEL_12;
      }
    }
    uint64_t result = memchr(result, 46, v8);
    if (result) {
      uint64_t v11 = result;
    }
    else {
      uint64_t v11 = (unsigned char *)v6;
    }
LABEL_12:
    a4[1] = v11;
    return result;
  }
  a4[1] = v6;
  a4[2] = v6;
  return result;
}

unsigned char *std::__formatter::__format_buffer_default[abi:ne180100]<double,double>@<X0>(std::__1 *this@<X1>, uint64_t a2@<X0>, char *a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
  *a4 = this;
  uint64_t v7 = std::to_chars(this, (char *)(*(void *)(a2 + 16) + *(void *)(a2 + 8)), a3, a5);
  size_t v8 = (unsigned char *)v7;
  a4[3] = v7;
  unint64_t v9 = v7 - (void)this;
  uint64_t v10 = (unsigned char *)v7;
  if (v7 - (uint64_t)this >= 4)
  {
    if (v9 >= 6) {
      unint64_t v9 = 6;
    }
    uint64_t v11 = -(uint64_t)v9;
    while (*(unsigned char *)(v7 + v11) != 101)
    {
      if (++v11 == -3)
      {
        uint64_t v10 = (unsigned char *)v7;
        goto LABEL_9;
      }
    }
    uint64_t v10 = (unsigned char *)(v7 + v11);
  }
LABEL_9:
  a4[2] = v10;
  uint64_t result = memchr((char *)this + 1, 46, v10 - ((char *)this + 1));
  if (result) {
    int v13 = result;
  }
  else {
    int v13 = v10;
  }
  if (v13 == v10) {
    int v13 = v8;
  }
  a4[1] = v13;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = a3;
  if (a2 == -1) {
    uint64_t result = std::to_chars();
  }
  else {
    uint64_t result = MEMORY[0x21667A220](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 4);
  }
  a4[3] = result;
  int v8 = *(unsigned __int8 *)(a3 + 1);
  uint64_t v7 = a3 + 1;
  if (v8 == 46)
  {
    uint64_t v9 = result - 2;
    uint64_t v10 = memchr((void *)(result - 6), 112, 4uLL);
    uint64_t result = v7;
    if (v10) {
      uint64_t v7 = (uint64_t)v10;
    }
    else {
      uint64_t v7 = v9;
    }
  }
  a4[1] = result;
  a4[2] = v7;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<double,double>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t result = std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,double>(a1, a2, a3, a4);
  uint64_t v6 = (unsigned char *)*a4;
  uint64_t v7 = (unsigned char *)a4[2];
  if ((unsigned char *)*a4 != v7)
  {
    do
    {
      int v8 = (char)*v6;
      if ((v8 - 97) < 6) {
        LOBYTE(v8) = v8 - 32;
      }
      *v6++ = v8;
    }
    while (v6 != v7);
    uint64_t v6 = (unsigned char *)a4[2];
  }
  *uint64_t v6 = 80;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,double>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = a3;
  uint64_t result = MEMORY[0x21667A220](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 1, a2);
  a4[3] = result;
  uint64_t v7 = a3 + 1;
  if (*(unsigned char *)(a3 + 1) == 46)
  {
    a4[1] = v7;
    uint64_t v8 = result - a3 - 2;
    uint64_t v7 = result;
    if (v8 >= 4)
    {
      uint64_t v9 = 6;
      if ((unint64_t)v8 < 6) {
        uint64_t v9 = result - a3 - 2;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(result + v10) != 101)
      {
        if (++v10 == -3)
        {
          uint64_t v7 = result;
          goto LABEL_11;
        }
      }
      uint64_t v7 = result + v10;
    }
  }
  else
  {
    a4[1] = result;
  }
LABEL_11:
  a4[2] = v7;
  return result;
}

void *std::__formatter::__format_floating_point[abi:ne180100]<long double,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(uint64_t **a1, uint64_t a2, unint64_t a3, double a4)
{
  v47[128] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(void *)&a4 >> 63;
  if ((*(void *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
  {
    unint64_t v8 = (unint64_t)a2 >> 8;
    if (a4 >= 0.0) {
      double v9 = a4;
    }
    else {
      double v9 = -a4;
    }
    if (a3 == -1) {
      int v10 = 1074;
    }
    else {
      int v10 = a3;
    }
    int v43 = v10;
    int v44 = 0;
    if (v10 < 1075)
    {
      size_t v11 = v10 + 316;
      unint64_t v45 = v11;
      if ((v10 + 316) < 0x401)
      {
        unint64_t v12 = v47;
        goto LABEL_13;
      }
    }
    else
    {
      int v43 = 1074;
      int v44 = v10 - 1074;
      size_t v11 = 1390;
      unint64_t v45 = 1390;
    }
    unint64_t v12 = operator new(v11);
LABEL_13:
    std::string __p = v12;
    std::__formatter::__format_buffer[abi:ne180100]<double,long double>((unsigned int *)&v43, v7, (a3 & 0x80000000) == 0, (a2 >> 3) & 3, v8, (std::__1 **)&v39, v9);
    if ((a2 & 0x20) != 0)
    {
      int v13 = v40;
      if (v40 == *(char **)v42)
      {
        *(void *)int v42 = v40 + 1;
        *uint64_t v40 = 46;
        int v14 = v41;
        uint64_t v15 = (char *)(*(void *)v42 - 1);
        if (v41 != (char *)(*(void *)v42 - 1))
        {
          if (v41 + 1 == v15)
          {
            char v17 = *v41;
            *uint64_t v41 = *v15;
            char *v15 = v17;
          }
          else
          {
            char v16 = *(unsigned char *)(*(void *)v42 - 1);
            memmove(v41 + 1, v41, *(void *)v42 - 1 - (void)v41);
            *int v14 = v16;
          }
        }
        int v13 = v41;
        uint64_t v40 = v41++;
      }
      if ((BYTE1(a2) - 17) <= 1u)
      {
        if (a3 <= 1) {
          int v18 = 1;
        }
        else {
          int v18 = a3;
        }
        if ((a3 & 0x80000000) != 0) {
          int v18 = 6;
        }
        if (v41 == *(char **)v42) {
          int v19 = v39 - v13;
        }
        else {
          int v19 = -1;
        }
        int v20 = v19 + v18;
        uint64_t v21 = &v41[~(unint64_t)v13];
        if ((uint64_t)v21 < v20) {
          v44 += v20 - v21;
        }
      }
    }
    if ((a2 & 0x40) != 0)
    {
      int v29 = *a1;
      std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a1, &v38);
      size_t v30 = std::__formatter::__format_locale_specific_form[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,double,char>(v29, (uint64_t)&v43, &v39, &v38, a2, a3);
      std::locale::~locale(&v38);
    }
    else
    {
      uint64_t v22 = *(void *)v42;
      int v23 = (char *)__p;
      uint64_t v24 = *(void *)v42 - (void)__p;
      size_t v25 = v44;
      if (*(void *)v42 - (void)__p + v44 >= a2 >> 32)
      {
        if (!v44 || (unsigned __int8 v31 = v41, v41 == *(char **)v42))
        {
          size_t v30 = *a1;
          std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, *(void *)v42 - (void)__p);
          std::__format::__output_buffer<char>::__fill[abi:ne180100](v30, v25, 48);
        }
        else
        {
          size_t v30 = *a1;
          std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a1, (char *)__p, v41 - (unsigned char *)__p);
          std::__format::__output_buffer<char>::__fill[abi:ne180100](v30, v25, 48);
          std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(v30, v31, v22 - (void)v31);
        }
      }
      else
      {
        unsigned __int8 v26 = *a1;
        if ((a2 & 7) == 4)
        {
          if (__p != v39)
          {
            std::locale v37 = v26;
            std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v37, (char *)__p);
            ++v23;
          }
          unsigned __int8 v27 = a2 & 0xF8 | 3;
          unsigned __int8 v28 = 48;
        }
        else
        {
          unsigned __int8 v28 = BYTE4(a3);
          unsigned __int8 v27 = a2;
        }
        unint64_t v32 = a2 & 0xFFFFFFFFFFFFFF00 | v27;
        unint64_t v33 = a3 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v28 << 32);
        if (v25) {
          size_t v34 = std::__formatter::__write_using_trailing_zeros[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v23, *(uint64_t *)v42, v26, v32, v33, v24, v41, v25);
        }
        else {
          size_t v34 = std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v23, *(void *)v42 - (void)v23, v26, v32, v33, v24);
        }
        size_t v30 = v34;
      }
    }
    if (v45 >= 0x401) {
      operator delete(__p);
    }
    return v30;
  }
  unint64_t v36 = *a1;
  return std::__formatter::__format_floating_point_non_finite[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>(v36, a2, a3, a4 < 0.0, 0);
}

void sub_210AC30E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unint64_t a16, void *__p)
{
  if (a16 >= 0x401) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__formatter::__format_buffer[abi:ne180100]<double,long double>@<X0>(unsigned int *a1@<X0>, char a2@<W1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, std::__1 **a6@<X8>, double a7@<D0>)
{
  double v9 = (std::__1 *)*((void *)a1 + 2);
  if (a2)
  {
    char v10 = 45;
  }
  else if (a4 == 2)
  {
    char v10 = 43;
  }
  else
  {
    if (a4 != 3) {
      goto LABEL_8;
    }
    char v10 = 32;
  }
  *(unsigned char *)double v9 = v10;
  double v9 = (std::__1 *)((char *)v9 + 1);
LABEL_8:
  switch(a5)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      __break(1u);
      JUMPOUT(0x210AC32D4);
    case 11:
      if (a3) {
        int v14 = *a1;
      }
      else {
        int v14 = -1;
      }
      return std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>((uint64_t)a1, v14, (uint64_t)v9, a6);
    case 12:
      if (a3) {
        int v17 = *a1;
      }
      else {
        int v17 = -1;
      }
      return std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<double,long double>((uint64_t)a1, v17, (uint64_t)v9, a6);
    case 13:
      uint64_t v18 = *a1;
      return std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>((uint64_t)a1, v18, (uint64_t)v9, a6);
    case 14:
      uint64_t result = std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>((uint64_t)a1, *a1, (uint64_t)v9, a6);
      char v16 = a6[2];
      goto LABEL_25;
    case 15:
    case 16:
      uint64_t v11 = *a1;
      *a6 = v9;
      uint64_t result = MEMORY[0x21667A250](v9, *((void *)a1 + 2) + *((void *)a1 + 1), 2, v11);
      a6[2] = (std::__1 *)result;
      a6[3] = (std::__1 *)result;
      if (v11) {
        int v13 = v11 + 1;
      }
      else {
        int v13 = 0;
      }
      a6[1] = (std::__1 *)(result - v13);
      return result;
    case 17:
      goto LABEL_20;
    case 18:
      uint64_t result = (uint64_t)std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,long double>((uint64_t)a1, *a1, (uint64_t)v9, a6);
      char v16 = a6[2];
      if (v16 != a6[3]) {
LABEL_25:
      }
        *(unsigned char *)char v16 = 69;
      break;
    default:
      if (a3)
      {
LABEL_20:
        uint64_t v15 = *a1;
        uint64_t result = (uint64_t)std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,long double>((uint64_t)a1, v15, (uint64_t)v9, a6);
      }
      else
      {
        uint64_t result = (uint64_t)std::__formatter::__format_buffer_default[abi:ne180100]<double,long double>(v9, (uint64_t)a1, (char *)v9, a6, a7);
      }
      break;
  }
  return result;
}

unsigned char *std::__formatter::__format_buffer_general_lower_case[abi:ne180100]<double,long double>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *(_DWORD *)(a1 + 4) = 0;
  *a4 = a3;
  uint64_t v6 = MEMORY[0x21667A250](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 3, a2);
  a4[3] = v6;
  uint64_t result = (unsigned char *)(a3 + 1);
  if (a3 + 1 != v6)
  {
    size_t v8 = v6 - (void)result;
    if (v6 - (uint64_t)result < 4)
    {
LABEL_8:
      a4[2] = v6;
    }
    else
    {
      uint64_t v9 = 6;
      if (v8 < 6) {
        uint64_t v9 = v6 - (void)result;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(v6 + v10) != 101)
      {
        if (++v10 == -3) {
          goto LABEL_8;
        }
      }
      a4[2] = v6 + v10;
      if (v10)
      {
        if (*result == 46) {
          uint64_t v11 = (unsigned char *)(a3 + 1);
        }
        else {
          uint64_t v11 = (unsigned char *)v6;
        }
        goto LABEL_12;
      }
    }
    uint64_t result = memchr(result, 46, v8);
    if (result) {
      uint64_t v11 = result;
    }
    else {
      uint64_t v11 = (unsigned char *)v6;
    }
LABEL_12:
    a4[1] = v11;
    return result;
  }
  a4[1] = v6;
  a4[2] = v6;
  return result;
}

unsigned char *std::__formatter::__format_buffer_default[abi:ne180100]<double,long double>@<X0>(std::__1 *this@<X1>, uint64_t a2@<X0>, char *a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
  *a4 = this;
  uint64_t v7 = std::to_chars(this, (char *)(*(void *)(a2 + 16) + *(void *)(a2 + 8)), a3, a5);
  size_t v8 = (unsigned char *)v7;
  a4[3] = v7;
  unint64_t v9 = v7 - (void)this;
  uint64_t v10 = (unsigned char *)v7;
  if (v7 - (uint64_t)this >= 4)
  {
    if (v9 >= 6) {
      unint64_t v9 = 6;
    }
    uint64_t v11 = -(uint64_t)v9;
    while (*(unsigned char *)(v7 + v11) != 101)
    {
      if (++v11 == -3)
      {
        uint64_t v10 = (unsigned char *)v7;
        goto LABEL_9;
      }
    }
    uint64_t v10 = (unsigned char *)(v7 + v11);
  }
LABEL_9:
  a4[2] = v10;
  uint64_t result = memchr((char *)this + 1, 46, v10 - ((char *)this + 1));
  if (result) {
    int v13 = result;
  }
  else {
    int v13 = v10;
  }
  if (v13 == v10) {
    int v13 = v8;
  }
  a4[1] = v13;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = a3;
  if (a2 == -1) {
    uint64_t result = std::to_chars();
  }
  else {
    uint64_t result = MEMORY[0x21667A250](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 4);
  }
  a4[3] = result;
  int v8 = *(unsigned __int8 *)(a3 + 1);
  uint64_t v7 = a3 + 1;
  if (v8 == 46)
  {
    uint64_t v9 = result - 2;
    uint64_t v10 = memchr((void *)(result - 6), 112, 4uLL);
    uint64_t result = v7;
    if (v10) {
      uint64_t v7 = (uint64_t)v10;
    }
    else {
      uint64_t v7 = v9;
    }
  }
  a4[1] = result;
  a4[2] = v7;
  return result;
}

uint64_t std::__formatter::__format_buffer_hexadecimal_upper_case[abi:ne180100]<double,long double>@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t result = std::__formatter::__format_buffer_hexadecimal_lower_case[abi:ne180100]<double,long double>(a1, a2, a3, a4);
  uint64_t v6 = (unsigned char *)*a4;
  uint64_t v7 = (unsigned char *)a4[2];
  if ((unsigned char *)*a4 != v7)
  {
    do
    {
      int v8 = (char)*v6;
      if ((v8 - 97) < 6) {
        LOBYTE(v8) = v8 - 32;
      }
      *v6++ = v8;
    }
    while (v6 != v7);
    uint64_t v6 = (unsigned char *)a4[2];
  }
  *uint64_t v6 = 80;
  return result;
}

uint64_t std::__formatter::__format_buffer_scientific_lower_case[abi:ne180100]<double,long double>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = a3;
  uint64_t result = MEMORY[0x21667A250](a3, *(void *)(a1 + 16) + *(void *)(a1 + 8), 1, a2);
  a4[3] = result;
  uint64_t v7 = a3 + 1;
  if (*(unsigned char *)(a3 + 1) == 46)
  {
    a4[1] = v7;
    uint64_t v8 = result - a3 - 2;
    uint64_t v7 = result;
    if (v8 >= 4)
    {
      uint64_t v9 = 6;
      if ((unint64_t)v8 < 6) {
        uint64_t v9 = result - a3 - 2;
      }
      uint64_t v10 = -v9;
      while (*(unsigned char *)(result + v10) != 101)
      {
        if (++v10 == -3)
        {
          uint64_t v7 = result;
          goto LABEL_11;
        }
      }
      uint64_t v7 = result + v10;
    }
  }
  else
  {
    a4[1] = result;
  }
LABEL_11:
  a4[2] = v7;
  return result;
}

unsigned __int8 *std::__formatter_string<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(unsigned char *a1, unsigned __int8 **a2)
{
  uint64_t result = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(a1, a2, 0x128u);
  unsigned int v4 = a1[1];
  if (v4 >= 2 && v4 != 19) {
    std::__throw_format_error[abi:ne180100]("The type option contains an invalid value for a string formatting argument");
  }
  return result;
}

uint64_t *std::formatter<char const*,char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, char *a2, uint64_t **a3)
{
  unint64_t v5 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  if (SHIDWORD(v5) > 0 || (v6 & 0x80000000) == 0)
  {
    uint64_t v8 = v5;
    unint64_t v9 = v6;
    size_t v10 = strlen(a2);
    return std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(a2, v10, *a3, v8, v9);
  }
  else
  {
    uint64_t v11 = *a3;
    if (*a2)
    {
      do
      {
        int v14 = v11;
        std::back_insert_iterator<std::__format::__output_buffer<char>>::operator=[abi:ne180100](&v14, a2);
      }
      while (*++a2);
    }
  }
  return v11;
}

void *std::__formatter::__write_string[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(char *__src, size_t a2, void *a3, uint64_t a4, unint64_t a5)
{
  if ((a5 & 0x80000000) != 0)
  {
    return std::__formatter::__write_string_no_precision[abi:ne180100]<char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, a2, a3, a4, a5);
  }
  else
  {
    int v9 = std::__format_spec::__estimate_column_width[abi:ne180100]<char,char const*>((unsigned __int8 *)__src, a2, a5, 0);
    size_t v11 = v10 - (void)__src;
    return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(__src, v11, a3, a4, a5, v9);
  }
}

unsigned __int8 *std::__formatter_pointer<char>::parse[abi:ne180100]<std::basic_format_parse_context<char>>(unsigned char *a1, unsigned __int8 **a2)
{
  uint64_t result = std::__format_spec::__parser<char>::__parse[abi:ne180100]<std::basic_format_parse_context<char>>(a1, a2, 0x124u);
  int v4 = a1[1];
  if ((v4 - 8) >= 2 && v4 != 0) {
    std::__format_spec::__throw_invalid_type_format_error[abi:ne180100]("a pointer");
  }
  return result;
}

void *std::__formatter_pointer<char>::format[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(char *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = std::__format_spec::__parser<char>::__get_parsed_std_specifications[abi:ne180100]<std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a3);
  uint64_t v7 = 1536;
  if ((v5 & 0xFF00) == 0x900) {
    uint64_t v7 = 1792;
  }
  return std::__formatter::__format_integer[abi:ne180100]<unsigned long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a2, (void **)a3, v5 & 0xFFFFFFFFFFFF00FFLL | v7 | 0x20, v6, 0);
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned long,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, void **a2, unint64_t a3, unint64_t a4, char a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  switch(BYTE1(a3))
  {
    case 1:
      __break(1u);
      JUMPOUT(0x210AC39CCLL);
    case 2:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x200;
      uint64_t v7 = &v13;
      signed int v9 = 2;
      uint64_t v8 = "0b";
      goto LABEL_11;
    case 3:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x300;
      uint64_t v7 = &v13;
      signed int v9 = 2;
      uint64_t v8 = "0B";
      goto LABEL_11;
    case 4:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x400;
      uint64_t v7 = (uint64_t *)&v12[3];
      if (a1) {
        uint64_t v8 = "0";
      }
      else {
        uint64_t v8 = 0;
      }
      signed int v9 = 8;
      goto LABEL_11;
    case 6:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x600;
      uint64_t v7 = (uint64_t *)v11;
      signed int v9 = 16;
      uint64_t v8 = "0x";
      goto LABEL_11;
    case 7:
      unint64_t v6 = a3 & 0xFFFFFFFFFFFF00FFLL | 0x700;
      uint64_t v7 = (uint64_t *)v11;
      signed int v9 = 16;
      uint64_t v8 = "0X";
LABEL_11:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, v6, a4, a5, v10, (uint64_t)v7, v8, v9);
      break;
    default:
      uint64_t result = std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(a1, a2, a3, a4, a5, v10, (uint64_t)v12, 0, 10);
      break;
  }
  return result;
}

void *std::__formatter::__format_integer[abi:ne180100]<unsigned long,char *,char,std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>>(unint64_t a1, void **a2, unint64_t a3, unint64_t a4, char a5, char *a6, uint64_t a7, unsigned char *a8, signed int a9)
{
  signed int v9 = a6;
  char v13 = a3;
  if (a5)
  {
    char v14 = 45;
LABEL_7:
    *a6 = v14;
    char v16 = a6 + 1;
    goto LABEL_8;
  }
  int v15 = (a3 >> 3) & 3;
  if (v15 == 2)
  {
    char v14 = 43;
    goto LABEL_7;
  }
  char v16 = a6;
  if (v15 == 3)
  {
    char v14 = 32;
    goto LABEL_7;
  }
LABEL_8:
  if ((a3 & 0x20) != 0)
  {
    if (a8)
    {
      char v17 = *a8;
      if (*a8)
      {
        uint64_t v18 = a8 + 1;
        do
        {
          *(unsigned char *)char v16 = v17;
          char v16 = (_WORD *)((char *)v16 + 1);
          int v19 = *v18++;
          char v17 = v19;
        }
        while (v19);
      }
    }
  }
  int v20 = std::__to_chars_integral[abi:ne180100]<unsigned long long>(v16, a7, a1, a9);
  if ((v13 & 0x40) == 0) {
    goto LABEL_44;
  }
  std::basic_format_context<std::back_insert_iterator<std::__format::__output_buffer<char>>,char>::locale[abi:ne180100]((uint64_t)a2, &v45);
  uint64_t v21 = std::locale::use_facet(&v45, MEMORY[0x263F8C150]);
  std::locale::~locale(&v45);
  ((void (*)(std::locale *__return_ptr, const std::locale::facet *))v21->__vftable[1].__on_zero_shared)(&v45, v21);
  if ((char)v47 < 0)
  {
    locale = (char *)v45.__locale_;
    if (!v46)
    {
LABEL_43:
      operator delete(locale);
      goto LABEL_44;
    }
  }
  else
  {
    if (!v47) {
      goto LABEL_44;
    }
    locale = (char *)&v45;
  }
  if (v20 - (char *)v16 <= *locale)
  {
    if ((v47 & 0x80) != 0)
    {
      locale = (char *)v45.__locale_;
      goto LABEL_43;
    }
LABEL_44:
    unint64_t v35 = HIDWORD(a3);
    if ((v13 & 7) == 4)
    {
      std::__format::__output_buffer<char>::__copy[abi:ne180100]<char>(*a2, v9, (char *)v16 - v9);
      unsigned __int8 v36 = a3 & 0xF8 | 3;
      if (SHIDWORD(a3) >= (int)v16 - (int)v9) {
        int v37 = v16 - v9;
      }
      else {
        int v37 = HIDWORD(a3);
      }
      unint64_t v35 = (HIDWORD(a3) - v37);
      unsigned __int8 v38 = 48;
      signed int v9 = (char *)v16;
    }
    else
    {
      unsigned __int8 v38 = BYTE4(a4);
      unsigned __int8 v36 = a3;
    }
    std::string::size_type v39 = *a2;
    uint64_t v40 = a3 & 0xFFFFFF00 | (v35 << 32) | v36;
    unint64_t v41 = a4 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)v38 << 32);
    if ((a3 & 0xFF00) == 0x700) {
      return std::__formatter::__write_transformed[abi:ne180100]<char *,char,char,char (*)(char),std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20, v39, v40, v41, (uint64_t (*)(void))std::__formatter::__hex_to_upper[abi:ne180100]);
    }
    else {
      return std::__formatter::__write[abi:ne180100]<char,char,std::back_insert_iterator<std::__format::__output_buffer<char>>>(v9, v20 - v9, v39, v40, v41, v20 - v9);
    }
  }
  int v23 = *a2;
  memset(&__p, 0, sizeof(__p));
  if ((v47 & 0x80u) == 0) {
    uint64_t v24 = (std::string::value_type *)&v45;
  }
  else {
    uint64_t v24 = (std::string::value_type *)v45.__locale_;
  }
  if ((v47 & 0x80u) == 0) {
    size_t v25 = (char *)&v45 + v47;
  }
  else {
    size_t v25 = (char *)v45.__locale_ + v46;
  }
  std::string::value_type v26 = *v24;
  uint64_t v27 = v20 - (char *)v16 - *v24;
  if (v27 >= 1)
  {
    unsigned __int8 v28 = v25 - 1;
    do
    {
      std::string::push_back(&__p, v26);
      if (v24 == v28)
      {
        std::string::value_type v26 = *v28;
        uint64_t v24 = v28;
      }
      else
      {
        int v29 = v24 + 1;
        size_t v30 = v24 + 1;
        do
        {
          int v31 = *v30++;
          std::string::value_type v26 = v31;
          if (v31) {
            BOOL v32 = 1;
          }
          else {
            BOOL v32 = v29 == v28;
          }
          int v29 = v30;
        }
        while (!v32);
        uint64_t v24 = v30 - 1;
      }
      v27 -= v26;
    }
    while (v27 > 0);
  }
  std::string::push_back(&__p, v26 + v27);
  char v33 = ((uint64_t (*)(const std::locale::facet *))v21->__vftable[1].~facet_0)(v21);
  size_t v34 = std::__formatter::__write_using_decimal_separators[abi:ne180100]<std::back_insert_iterator<std::__format::__output_buffer<char>>,char *,char>(v23, v9, (char *)v16, (int)v20, (uint64_t *)&__p, v33, a3, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((char)v47 < 0) {
    operator delete(v45.__locale_);
  }
  return v34;
}

void sub_210AC3D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15.__locale_);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<as::WorkloopPool::WorkloopState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C312FB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<as::WorkloopPool::WorkloopState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C312FB8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21667A2D0);
}

void std::__shared_ptr_emplace<as::WorkloopPool::WorkloopState>::__on_zero_shared(uint64_t a1)
{
}

void std::allocate_shared[abi:ne180100]<as::WorkloopPool,std::allocator<as::WorkloopPool>,as::WorkloopPool::ConstructionTag,unsigned long &,void>(uint64_t a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x78uLL);
  std::__shared_ptr_emplace<as::WorkloopPool>::__shared_ptr_emplace[abi:ne180100]<as::WorkloopPool::ConstructionTag,unsigned long &,std::allocator<as::WorkloopPool>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  std::shared_ptr<as::WorkloopPool>::__enable_weak_this[abi:ne180100]<as::WorkloopPool,as::WorkloopPool,void>((uint64_t)a3, v6 + 3, (uint64_t)(v6 + 3));
}

void sub_210AC3E38(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<as::WorkloopPool>::__shared_ptr_emplace[abi:ne180100]<as::WorkloopPool::ConstructionTag,unsigned long &,std::allocator<as::WorkloopPool>,0>(void *a1, uint64_t a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C312FF0;
  as::WorkloopPool::WorkloopPool((uint64_t)(a1 + 3), a2, *a3);
  return a1;
}

void sub_210AC3E98(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<as::WorkloopPool>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C312FF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<as::WorkloopPool>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26C312FF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x21667A2D0);
}

void std::__shared_ptr_emplace<as::WorkloopPool>::__on_zero_shared(uint64_t a1)
{
}

void std::__destroy_at[abi:ne180100]<as::WorkloopPool,0>(uint64_t a1)
{
  std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::~deque[abi:ne180100]((void *)(a1 + 48));
  uint64_t v3 = (void **)(a1 + 24);
  std::vector<std::shared_ptr<as::WorkloopPool::WorkloopState>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unsigned int v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
}

void std::shared_ptr<as::WorkloopPool>::__enable_weak_this[abi:ne180100]<as::WorkloopPool,as::WorkloopPool,void>(uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    int v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      unint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        int v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v5)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v5);
      }
    }
  }
}

void std::deque<void({block_pointer} {__strong})(void),std::allocator<void({block_pointer} {__strong})(void)>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    signed int v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      size_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      unsigned __int8 v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    int v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      signed int v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::push_front((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    signed int v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      size_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(a1 + 3), v46);
      unint64_t v35 = &v34[8 * (v46 >> 2)];
      int v37 = &v34[8 * v47];
      char v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        unsigned int v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)unsigned int v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      int v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  std::string v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  char v53 = operator new(0x1000uLL);
  std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)> &>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)> &>::push_front((uint64_t)&v54, v27);
  }
  int v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_210AC42CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::push_back(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  unint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    uint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        unint64_t v18 = 1;
      }
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      int v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      unint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        unint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      uint64_t v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        unint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        unint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      unint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)unint64_t v6 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)>>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

void std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)> &>::push_back(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)uint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<void({block_pointer} {__strong}*)(void),std::allocator<void({block_pointer} {__strong}*)(void)> &>::push_front(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

uint64_t as::server::HardwareInfo::default_instance(as::server::HardwareInfo *this)
{
  {
    operator new();
  }
  return as::server::HardwareInfo::default_instance(void)::gInstance;
}

void sub_210AC4820(_Unwind_Exception *a1)
{
}

double as::server::HardwareInfo::HardwareInfo(as::server::HardwareInfo *this)
{
  *(void *)this = &unk_26C312980;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312980;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  return result;
}

as::server::HardwareInfo *as::server::HardwareInfo::HardwareInfo(as::server::HardwareInfo *this, const as::server::HardwareInfo *a2)
{
  *(void *)this = &unk_26C312980;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  as::server::HardwareInfo::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312980;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  as::server::HardwareInfo::copy_from(this, a2);
  return this;
}

uint64_t as::server::HardwareInfo::copy_from(as::server::HardwareInfo *this, const as::server::HardwareInfo *a2)
{
  caulk::xstring::assign((as::server::HardwareInfo *)((char *)this + 16), (const as::server::HardwareInfo *)((char *)a2 + 16));
  caulk::xstring::assign((as::server::HardwareInfo *)((char *)this + 32), (const as::server::HardwareInfo *)((char *)a2 + 32));
  uint64_t result = caulk::xstring::assign((as::server::HardwareInfo *)((char *)this + 48), (const as::server::HardwareInfo *)((char *)a2 + 48));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  return result;
}

as::server::HardwareInfo *as::server::HardwareInfo::operator=(as::server::HardwareInfo *a1, const as::server::HardwareInfo *a2)
{
  return a1;
}

uint64_t as::server::HardwareInfo::HardwareInfo(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312980;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  as::server::HardwareInfo::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312980;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  as::server::HardwareInfo::move_from(a1, a2);
  return a1;
}

uint64_t as::server::HardwareInfo::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v5);
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v5);
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)&v5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t as::server::HardwareInfo::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::server::HardwareInfo::clear(as::server::HardwareInfo *this)
{
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 16));
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 32));
  uint64_t result = caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 48));
  *((_DWORD *)this + 2) = 0;
  return result;
}

uint64_t as::server::HardwareInfo::isInitialized(as::server::HardwareInfo *this)
{
  return 1;
}

BOOL as::server::HardwareInfo::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
      break;
    }
    char v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = v2 + 1;
      a2[1] = v2 + 1;
      char v13 = *(unsigned char *)(v8 + v2);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0) {
        break;
      }
      v9 += 7;
      unint64_t v2 = v12;
      if (v10++ > 8) {
        goto LABEL_19;
      }
    }
LABEL_20:
    if ((v11 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v20 = v11 >> 3;
    if ((v11 >> 3) == 5)
    {
      PB::Reader::read();
      caulk::xstring::assign();
      int v21 = *(_DWORD *)(a1 + 8) | 4;
    }
    else if (v20 == 4)
    {
      PB::Reader::read();
      caulk::xstring::assign();
      int v21 = *(_DWORD *)(a1 + 8) | 2;
    }
    else
    {
      if (v20 != 2) {
        goto LABEL_28;
      }
      PB::Reader::read();
      caulk::xstring::assign();
      int v21 = *(_DWORD *)(a1 + 8) | 1;
    }
    *(_DWORD *)(a1 + 8) = v21;
LABEL_28:
    unint64_t v2 = a2[1];
    unint64_t v3 = a2[2];
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
      return v4 == 0;
    }
  }
  char v15 = 0;
  unsigned int v16 = 0;
  unint64_t v11 = 0;
  if (v2 > v3) {
    unint64_t v3 = v2;
  }
  while (v3 != v2)
  {
    unint64_t v17 = v2 + 1;
    char v18 = *(unsigned char *)(v8 + v2);
    a2[1] = v17;
    v11 |= (unint64_t)(v18 & 0x7F) << v15;
    if ((v18 & 0x80) == 0) {
      goto LABEL_20;
    }
    v15 += 7;
    unint64_t v2 = v17;
    if (v16++ >= 9)
    {
LABEL_19:
      unint64_t v11 = 0;
      goto LABEL_20;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_210AC4DD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::server::HardwareInfo::writeTo(as::server::HardwareInfo *this, PB::Writer *a2)
{
  int v3 = *((_DWORD *)this + 2);
  if (v3)
  {
    int v4 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(__p, v4);
    PB::Writer::write();
    if (v8 < 0) {
      operator delete(__p[0]);
    }
    int v3 = *((_DWORD *)this + 2);
  }
  if ((v3 & 2) != 0)
  {
    uint64_t v5 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 32));
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v8 < 0) {
      operator delete(__p[0]);
    }
    int v3 = *((_DWORD *)this + 2);
  }
  if ((v3 & 4) != 0)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 48));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::Writer::write();
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_210AC4ED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::HardwareInfo::formatText(as::server::HardwareInfo *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::TextFormatter::format();
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    uint64_t v7 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 32));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 4) != 0)
  {
    char v8 = (char *)caulk::xstring::c_str((as::server::HardwareInfo *)((char *)this + 48));
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::TextFormatter::format();
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AC4FF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::HardwareInfo::operator==(_DWORD *a1, _DWORD *a2)
{
  return a1[2] == a2[2]
      && !caulk::xstring::compare((caulk::xstring *)(a1 + 4), (const caulk::xstring *)(a2 + 4))
      && !caulk::xstring::compare((caulk::xstring *)(a1 + 8), (const caulk::xstring *)(a2 + 8))
      && caulk::xstring::compare((caulk::xstring *)(a1 + 12), (const caulk::xstring *)(a2 + 12)) == 0;
}

uint64_t as::server::Clock::default_instance(as::server::Clock *this)
{
  {
    operator new();
  }
  return as::server::Clock::default_instance(void)::gInstance;
}

void sub_210AC5134(_Unwind_Exception *a1)
{
}

double as::server::Clock::Clock(as::server::Clock *this)
{
  *(void *)this = &unk_26C312E18;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((void *)this + 16) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312E18;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((void *)this + 16) = 0;
  return result;
}

as::server::Clock *as::server::Clock::Clock(as::server::Clock *this, const as::server::Clock *a2)
{
  *(void *)this = &unk_26C312E18;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  as::server::Clock::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312E18;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  as::server::Clock::copy_from(this, a2);
  return this;
}

__n128 as::server::Clock::copy_from(as::server::Clock *this, const as::server::Clock *a2)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  int v4 = (const as::server::HardwareInfo *)*((void *)a2 + 12);
  if (v4)
  {
    int v5 = (as::server::HardwareInfo *)as::server::Clock::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v5, v4);
  }
  caulk::xstring::assign((as::server::Clock *)((char *)this + 64), (const as::server::Clock *)((char *)a2 + 64));
  caulk::xstring::assign((as::server::Clock *)((char *)this + 80), (const as::server::Clock *)((char *)a2 + 80));
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    operator new();
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 120);
  *(__n128 *)((char *)this + 104) = result;
  return result;
}

void sub_210AC54B0(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::Clock *as::server::Clock::operator=(as::server::Clock *a1, const as::server::Clock *a2)
{
  return a1;
}

uint64_t as::server::Clock::hardwareInfo(as::server::Clock *this)
{
  uint64_t result = *((void *)this + 12);
  if (!result) {
    return as::server::HardwareInfo::default_instance(0);
  }
  return result;
}

uint64_t as::server::Clock::mutableHardwareInfo(as::server::Clock *this)
{
  if (!*((void *)this + 12)) {
    operator new();
  }
  return *((void *)this + 12);
}

as::server::ControlAndValue *as::server::ControlAndValue::ControlAndValue(as::server::ControlAndValue *this, const as::server::ControlAndValue *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C312A60;
  as::server::ControlAndValue::copy_from(this, a2);
  return this;
}

{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C312A60;
  as::server::ControlAndValue::copy_from(this, a2);
  return this;
}

uint64_t as::server::Clock::Clock(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312E18;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0;
  as::server::Clock::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312E18;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0;
  as::server::Clock::move_from(a1, a2);
  return a1;
}

__n128 as::server::Clock::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  uint64_t v7 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = v7;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v12);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v12);
  uint64_t v8 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v8;
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v9;
  uint64_t v10 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v10;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 104);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(__n128 *)(a1 + 104) = result;
  return result;
}

uint64_t as::server::Clock::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

double as::server::Clock::clear(as::server::Clock *this)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  uint64_t v2 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  caulk::xstring::clear((as::server::Clock *)((char *)this + 64));
  caulk::xstring::clear((as::server::Clock *)((char *)this + 80));
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return result;
}

BOOL as::server::Clock::isInitialized(as::server::Clock *this)
{
  uint64_t v2 = (as::SampleRateRange **)*((void *)this + 2);
  int v3 = (as::SampleRateRange **)*((void *)this + 3);
  while (v2 != v3)
  {
    if (!as::SampleRateRange::isInitialized(*v2)) {
      return 0;
    }
    ++v2;
  }
  if (!*((void *)this + 12)) {
    return 0;
  }
  uint64_t v4 = (as::server::ControlAndValue **)*((void *)this + 5);
  uint64_t v5 = (as::server::ControlAndValue **)*((void *)this + 6);
  while (v4 != v5)
  {
    if (!as::server::ControlAndValue::isInitialized(*v4)) {
      return 0;
    }
    ++v4;
  }
  return (~*((_DWORD *)this + 2) & 0xBF) == 0;
}

BOOL as::server::ControlAndValue::isInitialized(as::server::ControlAndValue *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 16);
    uint64_t v3 = *(void *)(v1 + 24);
    if (v2 == v3)
    {
LABEL_5:
      if ((~*(_DWORD *)(v1 + 8) & 0x3F) == 0)
      {
        uint64_t v4 = *((void *)this + 2);
        if (v4) {
          return (~*(_DWORD *)(v4 + 8) & 3) == 0;
        }
      }
    }
    else
    {
      while ((~*(_DWORD *)(*(void *)v2 + 8) & 3) == 0)
      {
        v2 += 8;
        if (v2 == v3) {
          goto LABEL_5;
        }
      }
    }
  }
  return 0;
}

BOOL as::server::Clock::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v15 = 0;
        unsigned int v16 = 0;
        unint64_t v11 = 0;
        if (v3 <= v2) {
          unint64_t v17 = v2;
        }
        else {
          unint64_t v17 = v3;
        }
        while (v17 != v3)
        {
          unint64_t v18 = v3++;
          char v19 = *(unsigned char *)(v8 + v18);
          a2[1] = v3;
          v11 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0) {
            goto LABEL_21;
          }
          v15 += 7;
          BOOL v20 = v16++ >= 9;
          if (v20)
          {
            unint64_t v11 = 0;
LABEL_21:
            unint64_t v12 = v18 + 1;
            goto LABEL_22;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v9 = 0;
        unsigned int v10 = 0;
        unint64_t v11 = 0;
        while (1)
        {
          unint64_t v12 = v3 + 1;
          a2[1] = v3 + 1;
          char v13 = *(unsigned char *)(v8 + v3);
          v11 |= (unint64_t)(v13 & 0x7F) << v9;
          if ((v13 & 0x80) == 0) {
            break;
          }
          v9 += 7;
          unint64_t v3 = v12;
          BOOL v14 = v10++ > 8;
          if (v14)
          {
            unint64_t v11 = 0;
            break;
          }
        }
LABEL_22:
        if ((v11 & 7) != 4)
        {
          switch((v11 >> 3))
          {
            case 1u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v21 = 0;
                unsigned int v22 = 0;
                uint64_t v23 = 0;
                do
                {
                  unint64_t v24 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v25 = *(unsigned char *)(v8 + v12);
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if ((v25 & 0x80) == 0) {
                    goto LABEL_110;
                  }
                  v21 += 7;
                  unint64_t v12 = v24;
                  BOOL v14 = v22++ > 8;
                }
                while (!v14);
LABEL_88:
                uint64_t v23 = 0;
                goto LABEL_110;
              }
              char v55 = 0;
              unsigned int v56 = 0;
              uint64_t v23 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v57 = v12 + 1;
                char v58 = *(unsigned char *)(v8 + v12);
                a2[1] = v57;
                v23 |= (unint64_t)(v58 & 0x7F) << v55;
                if ((v58 & 0x80) == 0) {
                  goto LABEL_110;
                }
                v55 += 7;
                unint64_t v12 = v57;
                BOOL v20 = v56++ >= 9;
                if (v20) {
                  goto LABEL_88;
                }
              }
              uint64_t v23 = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_110:
              *(void *)(a1 + 112) = v23;
              int v59 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_115;
            case 3u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v36 = 0;
                unsigned int v37 = 0;
                uint64_t v38 = 0;
                do
                {
                  unint64_t v39 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v40 = *(unsigned char *)(v8 + v12);
                  v38 |= (unint64_t)(v40 & 0x7F) << v36;
                  if ((v40 & 0x80) == 0) {
                    goto LABEL_112;
                  }
                  v36 += 7;
                  unint64_t v12 = v39;
                  BOOL v14 = v37++ > 8;
                }
                while (!v14);
LABEL_97:
                LODWORD(v38) = 0;
                goto LABEL_112;
              }
              char v60 = 0;
              unsigned int v61 = 0;
              uint64_t v38 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v62 = v12 + 1;
                char v63 = *(unsigned char *)(v8 + v12);
                a2[1] = v62;
                v38 |= (unint64_t)(v63 & 0x7F) << v60;
                if ((v63 & 0x80) == 0) {
                  goto LABEL_112;
                }
                v60 += 7;
                unint64_t v12 = v62;
                BOOL v20 = v61++ >= 9;
                if (v20) {
                  goto LABEL_97;
                }
              }
              LODWORD(v38) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_112:
              *(_DWORD *)(a1 + 120) = v38;
              int v59 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_115;
            case 4u:
              if (v12 > 0xFFFFFFFFFFFFFFF7 || v12 + 8 > v2)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(void *)(a1 + 104) = *(void *)(v8 + v12);
                a2[1] += 8;
              }
              int v59 = *(_DWORD *)(a1 + 8) | 4;
              goto LABEL_115;
            case 5u:
              operator new();
            case 6u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v26 = 0;
                unsigned int v27 = 0;
                uint64_t v28 = 0;
                do
                {
                  unint64_t v29 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v30 = *(unsigned char *)(v8 + v12);
                  v28 |= (unint64_t)(v30 & 0x7F) << v26;
                  if ((v30 & 0x80) == 0) {
                    goto LABEL_106;
                  }
                  v26 += 7;
                  unint64_t v12 = v29;
                  BOOL v14 = v27++ > 8;
                }
                while (!v14);
LABEL_74:
                LODWORD(v28) = 0;
                goto LABEL_106;
              }
              char v47 = 0;
              unsigned int v48 = 0;
              uint64_t v28 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v49 = v12 + 1;
                char v50 = *(unsigned char *)(v8 + v12);
                a2[1] = v49;
                v28 |= (unint64_t)(v50 & 0x7F) << v47;
                if ((v50 & 0x80) == 0) {
                  goto LABEL_106;
                }
                v47 += 7;
                unint64_t v12 = v49;
                BOOL v20 = v48++ >= 9;
                if (v20) {
                  goto LABEL_74;
                }
              }
              LODWORD(v28) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_106:
              *(_DWORD *)(a1 + 124) = v28;
              int v59 = *(_DWORD *)(a1 + 8) | 8;
              goto LABEL_115;
            case 7u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v31 = 0;
                unsigned int v32 = 0;
                uint64_t v33 = 0;
                do
                {
                  unint64_t v34 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v35 = *(unsigned char *)(v8 + v12);
                  v33 |= (unint64_t)(v35 & 0x7F) << v31;
                  if ((v35 & 0x80) == 0) {
                    goto LABEL_108;
                  }
                  v31 += 7;
                  unint64_t v12 = v34;
                  BOOL v14 = v32++ > 8;
                }
                while (!v14);
LABEL_81:
                LODWORD(v33) = 0;
                goto LABEL_108;
              }
              char v51 = 0;
              unsigned int v52 = 0;
              uint64_t v33 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v53 = v12 + 1;
                char v54 = *(unsigned char *)(v8 + v12);
                a2[1] = v53;
                v33 |= (unint64_t)(v54 & 0x7F) << v51;
                if ((v54 & 0x80) == 0) {
                  goto LABEL_108;
                }
                v51 += 7;
                unint64_t v12 = v53;
                BOOL v20 = v52++ >= 9;
                if (v20) {
                  goto LABEL_81;
                }
              }
              LODWORD(v33) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_108:
              *(_DWORD *)(a1 + 128) = v33;
              int v59 = *(_DWORD *)(a1 + 8) | 0x10;
              goto LABEL_115;
            case 8u:
              operator new();
            case 9u:
              PB::Reader::read();
              caulk::xstring::assign();
              int v41 = *(_DWORD *)(a1 + 8) | 0x20;
              goto LABEL_67;
            case 0xAu:
              PB::Reader::read();
              caulk::xstring::assign();
              int v41 = *(_DWORD *)(a1 + 8) | 0x40;
LABEL_67:
              *(_DWORD *)(a1 + 8) = v41;
              goto LABEL_116;
            case 0xBu:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v42 = 0;
                unsigned int v43 = 0;
                uint64_t v44 = 0;
                do
                {
                  unint64_t v45 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v46 = *(unsigned char *)(v8 + v12);
                  v44 |= (unint64_t)(v46 & 0x7F) << v42;
                  if ((v46 & 0x80) == 0) {
                    goto LABEL_114;
                  }
                  v42 += 7;
                  unint64_t v12 = v45;
                  BOOL v14 = v43++ > 8;
                }
                while (!v14);
LABEL_104:
                LODWORD(v44) = 0;
                goto LABEL_114;
              }
              char v64 = 0;
              unsigned int v65 = 0;
              uint64_t v44 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v66 = v12 + 1;
                char v67 = *(unsigned char *)(v8 + v12);
                a2[1] = v66;
                v44 |= (unint64_t)(v67 & 0x7F) << v64;
                if ((v67 & 0x80) == 0) {
                  goto LABEL_114;
                }
                v64 += 7;
                unint64_t v12 = v66;
                BOOL v20 = v65++ >= 9;
                if (v20) {
                  goto LABEL_104;
                }
              }
              LODWORD(v44) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_114:
              *(_DWORD *)(a1 + 132) = v44;
              int v59 = *(_DWORD *)(a1 + 8) | 0x80;
LABEL_115:
              *(_DWORD *)(a1 + 8) = v59;
LABEL_116:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 0xCu:
              operator new();
            default:
              goto LABEL_116;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AC6304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::server::Clock::writeTo(as::server::Clock *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 1) == 0)
  {
    if ((v4 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_29:
    PB::Writer::writeVarInt(a2);
    if ((*((_DWORD *)this + 2) & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 2) != 0) {
    goto LABEL_29;
  }
LABEL_3:
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    PB::Writer::write(a2, *((double *)this + 13));
LABEL_5:
  uint64_t v5 = (const PB::Base **)*((void *)this + 2);
  uint64_t v6 = (const PB::Base **)*((void *)this + 3);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    PB::Writer::writeSubmessage(a2, v7);
  }
  int v8 = *((_DWORD *)this + 2);
  if ((v8 & 8) != 0)
  {
    PB::Writer::writeVarInt(a2);
    int v8 = *((_DWORD *)this + 2);
  }
  if ((v8 & 0x10) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  char v9 = (const PB::Base *)*((void *)this + 12);
  if (v9) {
    PB::Writer::writeSubmessage(a2, v9);
  }
  int v10 = *((_DWORD *)this + 2);
  if ((v10 & 0x20) != 0)
  {
    unint64_t v11 = (char *)caulk::xstring::c_str((as::server::Clock *)((char *)this + 64));
    std::string::basic_string[abi:ne180100]<0>(__p, v11);
    PB::Writer::write();
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    int v10 = *((_DWORD *)this + 2);
  }
  if ((v10 & 0x40) != 0)
  {
    unint64_t v12 = (char *)caulk::xstring::c_str((as::server::Clock *)((char *)this + 80));
    std::string::basic_string[abi:ne180100]<0>(__p, v12);
    PB::Writer::write();
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    int v10 = *((_DWORD *)this + 2);
  }
  if ((v10 & 0x80) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  BOOL v14 = (const PB::Base **)*((void *)this + 5);
  char v13 = (const PB::Base **)*((void *)this + 6);
  while (v14 != v13)
  {
    uint64_t v15 = *v14++;
    PB::Writer::writeSubmessage(a2, v15);
  }
}

void sub_210AC654C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::Clock::formatText(as::server::Clock *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "objectToken");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "transportType");
  if ((*((_DWORD *)this + 2) & 4) != 0) {
LABEL_4:
  }
    PB::TextFormatter::format(a2, "sampleRate", *((double *)this + 13));
LABEL_5:
  uint64_t v6 = (uint64_t *)*((void *)this + 2);
  uint64_t v7 = (uint64_t *)*((void *)this + 3);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "availableSampleRates");
  }
  int v9 = *((_DWORD *)this + 2);
  if ((v9 & 8) != 0)
  {
    PB::TextFormatter::format(a2, "outputLatency");
    int v9 = *((_DWORD *)this + 2);
  }
  if ((v9 & 0x10) != 0) {
    PB::TextFormatter::format(a2, "inputLatency");
  }
  uint64_t v10 = *((void *)this + 12);
  if (v10) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v10 + 32))(v10, a2, "hardwareInfo");
  }
  int v11 = *((_DWORD *)this + 2);
  if ((v11 & 0x20) != 0)
  {
    unint64_t v12 = (char *)caulk::xstring::c_str((as::server::Clock *)((char *)this + 64));
    std::string::basic_string[abi:ne180100]<0>(__p, v12);
    PB::TextFormatter::format();
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    int v11 = *((_DWORD *)this + 2);
  }
  if ((v11 & 0x40) != 0)
  {
    char v13 = (char *)caulk::xstring::c_str((as::server::Clock *)((char *)this + 80));
    std::string::basic_string[abi:ne180100]<0>(__p, v13);
    PB::TextFormatter::format();
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    int v11 = *((_DWORD *)this + 2);
  }
  if ((v11 & 0x80) != 0) {
    PB::TextFormatter::format(a2, "clockDomain");
  }
  BOOL v14 = (uint64_t *)*((void *)this + 5);
  uint64_t v15 = (uint64_t *)*((void *)this + 6);
  while (v14 != v15)
  {
    uint64_t v16 = *v14++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v16 + 32))(v16, a2, "controls");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AC67C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::Clock::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  BOOL v4 = *(void *)(a1 + 104) == *(void *)(a2 + 104) && *(void *)(a1 + 112) == *(void *)(a2 + 112);
  BOOL v5 = v4 && *(void *)(a1 + 120) == *(void *)(a2 + 120);
  if (!v5 || *(void *)(a1 + 128) != *(void *)(a2 + 128)) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  unint64_t v9 = (v7 - v8) >> 3;
  if (v9 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3) {
    return 0;
  }
  if (v7 != v8)
  {
    uint64_t v10 = 0;
    if (v9 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = (v7 - v8) >> 3;
    }
    do
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 16) + 8 * v10);
      uint64_t v13 = *(void *)(*(void *)(a2 + 16) + 8 * v10);
      if (v12) {
        BOOL v14 = v13 == 0;
      }
      else {
        BOOL v14 = 1;
      }
      if (v14)
      {
        if (v12 | v13) {
          return 0;
        }
      }
      else if (!as::SampleRateRange::operator==(v12, v13))
      {
        return 0;
      }
      ++v10;
    }
    while (v11 != v10);
  }
  unint64_t v15 = *(void *)(a1 + 96);
  unint64_t v16 = *(void *)(a2 + 96);
  if (v15 && v16)
  {
    if (!as::server::HardwareInfo::operator==((_DWORD *)v15, (_DWORD *)v16)) {
      return 0;
    }
  }
  else if (v15 | v16)
  {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 64), (const caulk::xstring *)(a2 + 64))) {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 80), (const caulk::xstring *)(a2 + 80))) {
    return 0;
  }
  uint64_t v18 = *(void *)(a1 + 40);
  uint64_t v17 = *(void *)(a1 + 48);
  unint64_t v19 = (v17 - v18) >> 3;
  if (v19 != (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3) {
    return 0;
  }
  if (v17 == v18)
  {
    return 1;
  }
  else
  {
    BOOL v20 = 0;
    uint64_t v21 = 0;
    if (v19 <= 1) {
      uint64_t v22 = 1;
    }
    else {
      uint64_t v22 = (v17 - v18) >> 3;
    }
    do
    {
      uint64_t v23 = *(void *)(*(void *)(a1 + 40) + 8 * v21);
      uint64_t v24 = *(void *)(*(void *)(a2 + 40) + 8 * v21);
      if (v23) {
        BOOL v25 = v24 == 0;
      }
      else {
        BOOL v25 = 1;
      }
      if (v25)
      {
        if (v23 | v24) {
          return v20;
        }
      }
      else if (!as::server::ControlAndValue::operator==(v23, v24))
      {
        return v20;
      }
      BOOL v20 = ++v21 >= v19;
    }
    while (v22 != v21);
  }
  return v20;
}

void as::server::Clock::addAvailableSampleRates(as::server::Clock *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  BOOL v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)BOOL v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::SampleRateRange>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *BOOL v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210AC6AB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::Clock::clearHardwareInfo(as::server::Clock *this)
{
  uint64_t result = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::server::Clock::addControls(as::server::Clock *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  BOOL v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)BOOL v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::ControlAndValue>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *BOOL v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210AC6C44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::HWStream::default_instance(as::server::HWStream *this)
{
  {
    operator new();
  }
  return as::server::HWStream::default_instance(void)::gInstance;
}

void sub_210AC6D00(_Unwind_Exception *a1)
{
}

double as::server::HWStream::HWStream(as::server::HWStream *this)
{
  *(void *)this = &unk_26C312EF8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312EF8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 0;
  return result;
}

as::server::HWStream *as::server::HWStream::HWStream(as::server::HWStream *this, const as::server::HWStream *a2)
{
  *(void *)this = &unk_26C312EF8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::HWStream::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312EF8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::HWStream::copy_from(this, a2);
  return this;
}

__n128 as::server::HWStream::copy_from(as::server::HWStream *this, const as::server::HWStream *a2)
{
  unint64_t v4 = (const as::server::HardwareInfo *)*((void *)a2 + 11);
  if (v4)
  {
    BOOL v5 = (as::server::HardwareInfo *)as::server::HWStream::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v5, v4);
  }
  uint64_t v6 = (const as::StreamFormat *)*((void *)a2 + 12);
  if (v6)
  {
    uint64_t v7 = (as::StreamFormat *)as::server::HWStream::mutablePrivateFormat(this);
    as::StreamFormat::operator=(v7, v6);
  }
  uint64_t v8 = (const as::StreamFormat *)*((void *)a2 + 13);
  if (v8)
  {
    uint64_t v9 = (as::StreamFormat *)as::server::HWStream::mutablePublicFormat(this);
    as::StreamFormat::operator=(v9, v8);
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 8);
  if (*((void *)a2 + 8) != *((void *)a2 + 9)) {
    operator new();
  }
  if (this != a2) {
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 16, *((caulk::xstring **)a2 + 2), *((caulk::xstring **)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 4);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *((__n128 *)a2 + 7);
  *((_DWORD *)this + 32) = *((_DWORD *)a2 + 32);
  *((__n128 *)this + 7) = result;
  return result;
}

void sub_210AC7080(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::HWStream *as::server::HWStream::operator=(as::server::HWStream *a1, const as::server::HWStream *a2)
{
  return a1;
}

uint64_t as::server::HWStream::hardwareInfo(as::server::HWStream *this)
{
  uint64_t result = *((void *)this + 11);
  if (!result) {
    return as::server::HardwareInfo::default_instance(0);
  }
  return result;
}

uint64_t as::server::HWStream::mutableHardwareInfo(as::server::HWStream *this)
{
  if (!*((void *)this + 11)) {
    operator new();
  }
  return *((void *)this + 11);
}

uint64_t as::server::HWStream::privateFormat(as::server::HWStream *this)
{
  uint64_t result = *((void *)this + 12);
  if (!result) {
    return as::StreamFormat::default_instance(0);
  }
  return result;
}

uint64_t as::server::HWStream::mutablePrivateFormat(as::server::HWStream *this)
{
  if (!*((void *)this + 12)) {
    operator new();
  }
  return *((void *)this + 12);
}

uint64_t as::server::HWStream::publicFormat(as::server::HWStream *this)
{
  uint64_t result = *((void *)this + 13);
  if (!result) {
    return as::StreamFormat::default_instance(0);
  }
  return result;
}

uint64_t as::server::HWStream::mutablePublicFormat(as::server::HWStream *this)
{
  if (!*((void *)this + 13)) {
    operator new();
  }
  return *((void *)this + 13);
}

uint64_t as::server::HWStream::HWStream(uint64_t a1, __n128 *a2)
{
  *(void *)a1 = &unk_26C312EF8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::HWStream::move_from((__n128 *)a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312EF8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::HWStream::move_from((__n128 *)a1, a2);
  return a1;
}

__n128 as::server::HWStream::move_from(__n128 *a1, __n128 *a2)
{
  unint64_t v2 = a1[5].n128_u64[1];
  a1[5].n128_u64[1] = a2[5].n128_u64[1];
  a2[5].n128_u64[1] = v2;
  unint64_t v3 = a1[6].n128_u64[0];
  a1[6].n128_u64[0] = a2[6].n128_u64[0];
  a2[6].n128_u64[0] = v3;
  unint64_t v4 = a1[6].n128_u64[1];
  a1[6].n128_u64[1] = a2[6].n128_u64[1];
  a2[6].n128_u64[1] = v4;
  unint64_t v5 = a1[2].n128_u64[1];
  a1[2].n128_u64[1] = a2[2].n128_u64[1];
  a2[2].n128_u64[1] = v5;
  unint64_t v6 = a1[3].n128_u64[0];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a2[3].n128_u64[0] = v6;
  unint64_t v7 = a1[3].n128_u64[1];
  a1[3].n128_u64[1] = a2[3].n128_u64[1];
  a2[3].n128_u64[1] = v7;
  unint64_t v8 = a1[4].n128_u64[0];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[4].n128_u64[0] = v8;
  unint64_t v9 = a1[4].n128_u64[1];
  a1[4].n128_u64[1] = a2[4].n128_u64[1];
  a2[4].n128_u64[1] = v9;
  unint64_t v10 = a1[5].n128_u64[0];
  a1[5].n128_u64[0] = a2[5].n128_u64[0];
  a2[5].n128_u64[0] = v10;
  unint64_t v11 = a1[1].n128_u64[0];
  a1[1].n128_u64[0] = a2[1].n128_u64[0];
  a2[1].n128_u64[0] = v11;
  unint64_t v12 = a1[1].n128_u64[1];
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = v12;
  unint64_t v13 = a1[2].n128_u64[0];
  a1[2].n128_u64[0] = a2[2].n128_u64[0];
  a2[2].n128_u64[0] = v13;
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[7];
  a1[8].n128_u32[0] = a2[8].n128_u32[0];
  a1[7] = result;
  return result;
}

__n128 *as::server::HWStream::operator=(__n128 *a1, __n128 *a2)
{
  return a1;
}

uint64_t as::server::HWStream::clear(as::server::HWStream *this)
{
  uint64_t v2 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 8);
  unint64_t v6 = (caulk::xstring *)*((void *)this + 2);
  unint64_t v5 = (char *)this + 16;
  uint64_t result = std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v5, v6);
  *((_DWORD *)v5 - 2) = 0;
  *((void *)v5 + 12) = 0;
  *((void *)v5 + 13) = 0;
  *((_DWORD *)v5 + 28) = 0;
  return result;
}

uint64_t as::server::HWStream::isInitialized(as::server::HWStream *this)
{
  if (!*((void *)this + 11)) {
    return 0;
  }
  uint64_t result = *((void *)this + 12);
  if (result)
  {
    uint64_t result = as::StreamFormat::isInitialized((as::StreamFormat *)result);
    if (result)
    {
      uint64_t result = *((void *)this + 13);
      if (result)
      {
        uint64_t result = as::StreamFormat::isInitialized((as::StreamFormat *)result);
        if (result)
        {
          uint64_t v3 = (as::AvailableStreamFormat **)*((void *)this + 5);
          uint64_t v4 = (as::AvailableStreamFormat **)*((void *)this + 6);
          while (v3 != v4)
          {
            if ((as::AvailableStreamFormat::isInitialized(*v3) & 1) == 0) {
              return 0;
            }
            ++v3;
          }
          unint64_t v5 = (as::AvailableStreamFormat **)*((void *)this + 8);
          unint64_t v6 = (as::AvailableStreamFormat **)*((void *)this + 9);
          while (v5 != v6)
          {
            if ((as::AvailableStreamFormat::isInitialized(*v5) & 1) == 0) {
              return 0;
            }
            ++v5;
          }
          return (~*((_DWORD *)this + 2) & 0xF) == 0;
        }
      }
    }
  }
  return result;
}

BOOL as::server::HWStream::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    unint64_t v8 = (uint64_t *)(a1 + 16);
    uint64_t v9 = a1 + 32;
    while (2)
    {
      uint64_t v10 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        unint64_t v13 = 0;
        if (v3 <= v2) {
          unint64_t v19 = v2;
        }
        else {
          unint64_t v19 = v3;
        }
        while (v19 != v3)
        {
          unint64_t v20 = v3++;
          char v21 = *(unsigned char *)(v10 + v20);
          a2[1] = v3;
          v13 |= (unint64_t)(v21 & 0x7F) << v17;
          if ((v21 & 0x80) == 0) {
            goto LABEL_22;
          }
          v17 += 7;
          BOOL v22 = v18++ >= 9;
          if (v22)
          {
            unint64_t v13 = 0;
LABEL_22:
            unint64_t v14 = v20 + 1;
            goto LABEL_23;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v11 = 0;
        unsigned int v12 = 0;
        unint64_t v13 = 0;
        while (1)
        {
          unint64_t v14 = v3 + 1;
          a2[1] = v3 + 1;
          char v15 = *(unsigned char *)(v10 + v3);
          v13 |= (unint64_t)(v15 & 0x7F) << v11;
          if ((v15 & 0x80) == 0) {
            break;
          }
          v11 += 7;
          unint64_t v3 = v14;
          BOOL v16 = v12++ > 8;
          if (v16)
          {
            unint64_t v13 = 0;
            break;
          }
        }
LABEL_23:
        if ((v13 & 7) != 4)
        {
          switch((v13 >> 3))
          {
            case 1u:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v23 = 0;
                unsigned int v24 = 0;
                uint64_t v25 = 0;
                do
                {
                  unint64_t v26 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v27 = *(unsigned char *)(v10 + v14);
                  v25 |= (unint64_t)(v27 & 0x7F) << v23;
                  if ((v27 & 0x80) == 0) {
                    goto LABEL_103;
                  }
                  v23 += 7;
                  unint64_t v14 = v26;
                  BOOL v16 = v24++ > 8;
                }
                while (!v16);
LABEL_73:
                uint64_t v25 = 0;
                goto LABEL_103;
              }
              char v50 = 0;
              unsigned int v51 = 0;
              uint64_t v25 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v52 = v14 + 1;
                char v53 = *(unsigned char *)(v10 + v14);
                a2[1] = v52;
                v25 |= (unint64_t)(v53 & 0x7F) << v50;
                if ((v53 & 0x80) == 0) {
                  goto LABEL_103;
                }
                v50 += 7;
                unint64_t v14 = v52;
                BOOL v22 = v51++ >= 9;
                if (v22) {
                  goto LABEL_73;
                }
              }
              uint64_t v25 = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_103:
              *(void *)(a1 + 112) = v25;
              int v68 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_108;
            case 2u:
              operator new();
            case 5u:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v28 = 0;
                unsigned int v29 = 0;
                uint64_t v30 = 0;
                do
                {
                  unint64_t v31 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v32 = *(unsigned char *)(v10 + v14);
                  v30 |= (unint64_t)(v32 & 0x7F) << v28;
                  if ((v32 & 0x80) == 0) {
                    goto LABEL_101;
                  }
                  v28 += 7;
                  unint64_t v14 = v31;
                  BOOL v16 = v29++ > 8;
                }
                while (!v16);
LABEL_66:
                LODWORD(v30) = 0;
                goto LABEL_101;
              }
              char v46 = 0;
              unsigned int v47 = 0;
              uint64_t v30 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v48 = v14 + 1;
                char v49 = *(unsigned char *)(v10 + v14);
                a2[1] = v48;
                v30 |= (unint64_t)(v49 & 0x7F) << v46;
                if ((v49 & 0x80) == 0) {
                  goto LABEL_101;
                }
                v46 += 7;
                unint64_t v14 = v48;
                BOOL v22 = v47++ >= 9;
                if (v22) {
                  goto LABEL_66;
                }
              }
              LODWORD(v30) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_101:
              *(_DWORD *)(a1 + 128) = v30;
              int v68 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_108;
            case 0xAu:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v33 = 0;
                unsigned int v34 = 0;
                uint64_t v35 = 0;
                do
                {
                  unint64_t v36 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v37 = *(unsigned char *)(v10 + v14);
                  v35 |= (unint64_t)(v37 & 0x7F) << v33;
                  if ((v37 & 0x80) == 0) {
                    goto LABEL_105;
                  }
                  v33 += 7;
                  unint64_t v14 = v36;
                  BOOL v16 = v34++ > 8;
                }
                while (!v16);
LABEL_80:
                LODWORD(v35) = 0;
                goto LABEL_105;
              }
              char v54 = 0;
              unsigned int v55 = 0;
              uint64_t v35 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v56 = v14 + 1;
                char v57 = *(unsigned char *)(v10 + v14);
                a2[1] = v56;
                v35 |= (unint64_t)(v57 & 0x7F) << v54;
                if ((v57 & 0x80) == 0) {
                  goto LABEL_105;
                }
                v54 += 7;
                unint64_t v14 = v56;
                BOOL v22 = v55++ >= 9;
                if (v22) {
                  goto LABEL_80;
                }
              }
              LODWORD(v35) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_105:
              *(_DWORD *)(a1 + 120) = v35;
              int v68 = *(_DWORD *)(a1 + 8) | 4;
              goto LABEL_108;
            case 0xBu:
              operator new();
            case 0xCu:
              operator new();
            case 0xDu:
              operator new();
            case 0xEu:
              operator new();
            case 0xFu:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v41 = 0;
                unsigned int v42 = 0;
                uint64_t v43 = 0;
                do
                {
                  unint64_t v44 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v45 = *(unsigned char *)(v10 + v14);
                  v43 |= (unint64_t)(v45 & 0x7F) << v41;
                  if ((v45 & 0x80) == 0) {
                    goto LABEL_107;
                  }
                  v41 += 7;
                  unint64_t v14 = v44;
                  BOOL v16 = v42++ > 8;
                }
                while (!v16);
LABEL_95:
                LODWORD(v43) = 0;
                goto LABEL_107;
              }
              char v63 = 0;
              unsigned int v64 = 0;
              uint64_t v43 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v65 = v14 + 1;
                char v66 = *(unsigned char *)(v10 + v14);
                a2[1] = v65;
                v43 |= (unint64_t)(v66 & 0x7F) << v63;
                if ((v66 & 0x80) == 0) {
                  goto LABEL_107;
                }
                v63 += 7;
                unint64_t v14 = v65;
                BOOL v22 = v64++ >= 9;
                if (v22) {
                  goto LABEL_95;
                }
              }
              LODWORD(v43) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_107:
              *(_DWORD *)(a1 + 124) = v43;
              int v68 = *(_DWORD *)(a1 + 8) | 8;
LABEL_108:
              *(_DWORD *)(a1 + 8) = v68;
LABEL_109:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 0x10u:
              unint64_t v39 = *(void **)(a1 + 24);
              unint64_t v38 = *(void *)(a1 + 32);
              if ((unint64_t)v39 >= v38)
              {
                uint64_t v58 = ((uint64_t)v39 - *v8) >> 4;
                unint64_t v59 = v58 + 1;
                if ((unint64_t)(v58 + 1) >> 60) {
                  std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v60 = v38 - *v8;
                if (v60 >> 3 > v59) {
                  unint64_t v59 = v60 >> 3;
                }
                if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v61 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v61 = v59;
                }
                uint64_t v75 = v9;
                if (v61) {
                  unint64_t v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v61);
                }
                else {
                  unint64_t v62 = 0;
                }
                char v67 = &v62[16 * v58];
                std::string __p = v62;
                unint64_t v72 = v67;
                char v74 = &v62[16 * v61];
                *(void *)char v67 = 0;
                *((void *)v67 + 1) = 0;
                char v73 = v67 + 16;
                std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
                char v40 = *(void **)(a1 + 24);
                std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
              }
              else
              {
                *unint64_t v39 = 0;
                v39[1] = 0;
                char v40 = v39 + 2;
                *(void *)(a1 + 24) = v39 + 2;
              }
              *(void *)(a1 + 24) = v40;
              std::string __p = 0;
              unint64_t v72 = 0;
              char v73 = 0;
              PB::Reader::read();
              caulk::xstring::assign();
              if (SHIBYTE(v73) < 0) {
                operator delete(__p);
              }
              goto LABEL_109;
            default:
              goto LABEL_109;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AC7F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::server::HWStream::writeTo(as::server::HWStream *this, PB::Writer *a2)
{
  if (*((unsigned char *)this + 8)) {
    PB::Writer::writeVarInt(a2);
  }
  int v4 = (const PB::Base *)*((void *)this + 11);
  if (v4) {
    PB::Writer::writeSubmessage(a2, v4);
  }
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 2) != 0)
  {
    PB::Writer::writeVarInt(a2);
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 4) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  unint64_t v6 = (const PB::Base *)*((void *)this + 12);
  if (v6) {
    PB::Writer::writeSubmessage(a2, v6);
  }
  unint64_t v7 = (const PB::Base *)*((void *)this + 13);
  if (v7) {
    PB::Writer::writeSubmessage(a2, v7);
  }
  unint64_t v8 = (const PB::Base **)*((void *)this + 5);
  uint64_t v9 = (const PB::Base **)*((void *)this + 6);
  while (v8 != v9)
  {
    uint64_t v10 = *v8++;
    PB::Writer::writeSubmessage(a2, v10);
  }
  char v11 = (const PB::Base **)*((void *)this + 8);
  unsigned int v12 = (const PB::Base **)*((void *)this + 9);
  while (v11 != v12)
  {
    unint64_t v13 = *v11++;
    PB::Writer::writeSubmessage(a2, v13);
  }
  if ((*((unsigned char *)this + 8) & 8) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  uint64_t v15 = (caulk::xstring *)*((void *)this + 2);
  unint64_t v14 = (caulk::xstring *)*((void *)this + 3);
  while (v15 != v14)
  {
    BOOL v16 = (char *)caulk::xstring::c_str(v15);
    std::string::basic_string[abi:ne180100]<0>(&__p, v16);
    PB::Writer::write();
    if (v18 < 0) {
      operator delete(__p);
    }
    uint64_t v15 = (caulk::xstring *)((char *)v15 + 16);
  }
}

void sub_210AC813C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::HWStream::formatText(as::server::HWStream *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  if (*((unsigned char *)this + 8)) {
    PB::TextFormatter::format(a2, "objectToken");
  }
  uint64_t v5 = *((void *)this + 11);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "hardwareInfo");
  }
  int v6 = *((_DWORD *)this + 2);
  if ((v6 & 2) != 0)
  {
    PB::TextFormatter::format(a2, "direction");
    int v6 = *((_DWORD *)this + 2);
  }
  if ((v6 & 4) != 0) {
    PB::TextFormatter::format(a2, "startingChannel");
  }
  uint64_t v7 = *((void *)this + 12);
  if (v7) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, a2, "privateFormat");
  }
  uint64_t v8 = *((void *)this + 13);
  if (v8) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "publicFormat");
  }
  uint64_t v9 = (uint64_t *)*((void *)this + 5);
  uint64_t v10 = (uint64_t *)*((void *)this + 6);
  while (v9 != v10)
  {
    uint64_t v11 = *v9++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v11 + 32))(v11, a2, "availablePrivateFormats");
  }
  unsigned int v12 = (uint64_t *)*((void *)this + 8);
  unint64_t v13 = (uint64_t *)*((void *)this + 9);
  while (v12 != v13)
  {
    uint64_t v14 = *v12++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v14 + 32))(v14, a2, "availablePublicFormats");
  }
  if ((*((unsigned char *)this + 8) & 8) != 0) {
    PB::TextFormatter::format(a2, "latency");
  }
  uint64_t v15 = (caulk::xstring *)*((void *)this + 2);
  for (uint64_t i = (caulk::xstring *)*((void *)this + 3); v15 != i; v15 = (caulk::xstring *)((char *)v15 + 16))
  {
    char v17 = (char *)caulk::xstring::c_str(v15);
    std::string::basic_string[abi:ne180100]<0>(&__p, v17);
    PB::TextFormatter::format();
    if (v20 < 0) {
      operator delete(__p);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AC83AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::HWStream::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  BOOL v4 = *(void *)(a1 + 112) == *(void *)(a2 + 112) && *(void *)(a1 + 120) == *(void *)(a2 + 120);
  if (!v4 || *(_DWORD *)(a1 + 128) != (unint64_t)*(unsigned int *)(a2 + 128)) {
    return 0;
  }
  unint64_t v7 = *(void *)(a1 + 88);
  unint64_t v8 = *(void *)(a2 + 88);
  if (v7 && v8)
  {
    if (!as::server::HardwareInfo::operator==((_DWORD *)v7, (_DWORD *)v8)) {
      return 0;
    }
  }
  else if (v7 | v8)
  {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 96);
  uint64_t v10 = *(void *)(a2 + 96);
  if (v9 && v10)
  {
    if (!as::StreamFormat::operator==(v9, v10)) {
      return 0;
    }
  }
  else if (v9 | v10)
  {
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 104);
  uint64_t v12 = *(void *)(a2 + 104);
  if (v11 && v12)
  {
    if (!as::StreamFormat::operator==(v11, v12)) {
      return 0;
    }
  }
  else if (v11 | v12)
  {
    return 0;
  }
  uint64_t v14 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 48);
  unint64_t v15 = (v13 - v14) >> 3;
  if (v15 != (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3) {
    return 0;
  }
  if (v13 != v14)
  {
    uint64_t v16 = 0;
    if (v15 <= 1) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = (v13 - v14) >> 3;
    }
    do
    {
      uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8 * v16);
      uint64_t v19 = *(void *)(*(void *)(a2 + 40) + 8 * v16);
      if (v18) {
        BOOL v20 = v19 == 0;
      }
      else {
        BOOL v20 = 1;
      }
      if (v20)
      {
        if (v18 | v19) {
          return 0;
        }
      }
      else if (!as::AvailableStreamFormat::operator==(v18, v19))
      {
        return 0;
      }
      ++v16;
    }
    while (v17 != v16);
  }
  uint64_t v22 = *(void *)(a1 + 64);
  uint64_t v21 = *(void *)(a1 + 72);
  unint64_t v23 = (v21 - v22) >> 3;
  if (v23 != (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 3) {
    return 0;
  }
  if (v21 != v22)
  {
    uint64_t v24 = 0;
    if (v23 <= 1) {
      uint64_t v25 = 1;
    }
    else {
      uint64_t v25 = (v21 - v22) >> 3;
    }
    do
    {
      uint64_t v26 = *(void *)(*(void *)(a1 + 64) + 8 * v24);
      uint64_t v27 = *(void *)(*(void *)(a2 + 64) + 8 * v24);
      if (v26) {
        BOOL v28 = v27 == 0;
      }
      else {
        BOOL v28 = 1;
      }
      if (v28)
      {
        if (v26 | v27) {
          return 0;
        }
      }
      else if (!as::AvailableStreamFormat::operator==(v26, v27))
      {
        return 0;
      }
      ++v24;
    }
    while (v25 != v24);
  }
  uint64_t v30 = *(void *)(a1 + 16);
  uint64_t v29 = *(void *)(a1 + 24);
  unint64_t v31 = (v29 - v30) >> 4;
  if (v31 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 4) {
    return 0;
  }
  if (v29 == v30) {
    return 1;
  }
  if (v31 <= 1) {
    uint64_t v32 = 1;
  }
  else {
    uint64_t v32 = (v29 - v30) >> 4;
  }
  if (caulk::xstring::compare(*(caulk::xstring **)(a1 + 16), *(const caulk::xstring **)(a2 + 16))) {
    return 0;
  }
  uint64_t v33 = 1;
  uint64_t v34 = 16;
  do
  {
    unint64_t v35 = v33;
    if (v32 == v33) {
      break;
    }
    int v36 = caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 16) + v34), (const caulk::xstring *)(*(void *)(a2 + 16) + v34));
    uint64_t v33 = v35 + 1;
    v34 += 16;
  }
  while (!v36);
  return v35 >= v31;
}

uint64_t as::server::HWStream::clearHardwareInfo(as::server::HWStream *this)
{
  uint64_t result = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::HWStream::clearPrivateFormat(as::server::HWStream *this)
{
  uint64_t result = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::HWStream::clearPublicFormat(as::server::HWStream *this)
{
  uint64_t result = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::server::HWStream::addAvailablePrivateFormats(as::server::HWStream *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::AvailableStreamFormat>>::__swap_out_circular_buffer(v7, v15);
    int v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    int v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210AC87CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::HWStream::addAvailablePublicFormats(as::server::HWStream *this)
{
  unint64_t v4 = *((void *)this + 10);
  unint64_t v2 = (char *)this + 80;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::AvailableStreamFormat>>::__swap_out_circular_buffer(v7, v15);
    int v6 = (void *)*((void *)this + 9);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    int v6 = v5 + 1;
    *((void *)this + 9) = v6;
  }
  *((void *)this + 9) = v6;
  operator new();
}

void sub_210AC890C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::Device::default_instance(as::server::Device *this)
{
  {
    operator new();
  }
  return as::server::Device::default_instance(void)::gInstance;
}

void sub_210AC89C4(_Unwind_Exception *a1)
{
}

double as::server::Device::Device(as::server::Device *this)
{
  *(void *)this = &unk_26C312E50;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312E50;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0;
  return result;
}

as::server::Device *as::server::Device::Device(as::server::Device *this, const as::server::Device *a2)
{
  *(void *)this = &unk_26C312E50;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::Device::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312E50;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::Device::copy_from(this, a2);
  return this;
}

void *as::server::Device::copy_from(as::server::Device *this, const as::server::Device *a2)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 8);
  if (*((void *)a2 + 8) != *((void *)a2 + 9)) {
    operator new();
  }
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 11);
  if (*((void *)a2 + 11) != *((void *)a2 + 12)) {
    operator new();
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 14) = *((void *)a2 + 14);
  return result;
}

void sub_210AC8F64(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::Device *as::server::Device::operator=(as::server::Device *a1, const as::server::Device *a2)
{
  return a1;
}

as::server::Port *as::server::Port::Port(as::server::Port *this, const as::server::Port *a2)
{
  *(void *)this = &unk_26C312DE0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((void *)this + 16) = 0;
  as::server::Port::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312DE0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((void *)this + 16) = 0;
  as::server::Port::copy_from(this, a2);
  return this;
}

uint64_t as::server::Device::Device(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312E50;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::Device::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312E50;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::Device::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Device::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  uint64_t v5 = *(void *)(result + 40);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v5;
  uint64_t v6 = *(void *)(result + 48);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v6;
  uint64_t v7 = *(void *)(result + 56);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v7;
  uint64_t v8 = *(void *)(result + 64);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v8;
  uint64_t v9 = *(void *)(result + 72);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v9;
  uint64_t v10 = *(void *)(result + 80);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v10;
  uint64_t v11 = *(void *)(result + 88);
  *(void *)(result + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v11;
  uint64_t v12 = *(void *)(result + 96);
  *(void *)(result + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = v12;
  uint64_t v13 = *(void *)(result + 104);
  *(void *)(result + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v13;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 112) = *(void *)(a2 + 112);
  return result;
}

uint64_t as::server::Device::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

void *as::server::Device::clear(as::server::Device *this)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 8);
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 11);
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 14) = 0;
  return result;
}

BOOL as::server::Device::isInitialized(as::server::Device *this)
{
  uint64_t v2 = (as::server::HWStream **)*((void *)this + 2);
  uint64_t v3 = (as::server::HWStream **)*((void *)this + 3);
  while (v2 != v3)
  {
    if ((as::server::HWStream::isInitialized(*v2) & 1) == 0) {
      return 0;
    }
    ++v2;
  }
  uint64_t v4 = (as::server::HWStream **)*((void *)this + 5);
  uint64_t v5 = (as::server::HWStream **)*((void *)this + 6);
  while (v4 != v5)
  {
    if ((as::server::HWStream::isInitialized(*v4) & 1) == 0) {
      return 0;
    }
    ++v4;
  }
  uint64_t v6 = *((void *)this + 8);
  uint64_t v7 = *((void *)this + 9);
  if (v6 == v7)
  {
LABEL_14:
    uint64_t v9 = *((void *)this + 11);
    uint64_t v10 = *((void *)this + 12);
    if (v9 == v10) {
      return (~*((_DWORD *)this + 2) & 3) == 0;
    }
    while (1)
    {
      uint64_t v11 = *(void *)(*(void *)v9 + 120);
      if (!v11 || (~*(_DWORD *)(v11 + 8) & 0x7F) != 0 || !*(void *)(*(void *)v9 + 128)) {
        break;
      }
      v9 += 8;
      if (v9 == v10) {
        return (~*((_DWORD *)this + 2) & 3) == 0;
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t v8 = *(void *)(*(void *)v6 + 120);
      if (!v8 || (~*(_DWORD *)(v8 + 8) & 0x7F) != 0 || !*(void *)(*(void *)v6 + 128)) {
        break;
      }
      v6 += 8;
      if (v6 == v7) {
        goto LABEL_14;
      }
    }
  }
  return 0;
}

BOOL as::server::Port::isInitialized(as::server::Port *this)
{
  uint64_t v1 = *((void *)this + 15);
  return v1 && (~*(_DWORD *)(v1 + 8) & 0x7F) == 0 && *((void *)this + 16) != 0;
}

BOOL as::server::Device::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      uint64_t v6 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v13 = 0;
        unsigned int v14 = 0;
        unint64_t v9 = 0;
        if (v3 <= v2) {
          unint64_t v15 = v2;
        }
        else {
          unint64_t v15 = v3;
        }
        while (v15 != v3)
        {
          unint64_t v16 = v3++;
          char v17 = *(unsigned char *)(v6 + v16);
          a2[1] = v3;
          v9 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0) {
            goto LABEL_21;
          }
          v13 += 7;
          BOOL v18 = v14++ >= 9;
          if (v18)
          {
            unint64_t v9 = 0;
LABEL_21:
            unint64_t v10 = v16 + 1;
            goto LABEL_22;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v7 = 0;
        unsigned int v8 = 0;
        unint64_t v9 = 0;
        while (1)
        {
          unint64_t v10 = v3 + 1;
          a2[1] = v3 + 1;
          char v11 = *(unsigned char *)(v6 + v3);
          v9 |= (unint64_t)(v11 & 0x7F) << v7;
          if ((v11 & 0x80) == 0) {
            break;
          }
          v7 += 7;
          unint64_t v3 = v10;
          BOOL v12 = v8++ > 8;
          if (v12)
          {
            unint64_t v9 = 0;
            break;
          }
        }
LABEL_22:
        if ((v9 & 7) != 4)
        {
          switch((v9 >> 3))
          {
            case 2u:
              if (v10 <= 0xFFFFFFFFFFFFFFF5 && v10 + 10 <= v2)
              {
                char v19 = 0;
                unsigned int v20 = 0;
                uint64_t v21 = 0;
                do
                {
                  unint64_t v22 = v10 + 1;
                  a2[1] = v10 + 1;
                  char v23 = *(unsigned char *)(v6 + v10);
                  v21 |= (unint64_t)(v23 & 0x7F) << v19;
                  if ((v23 & 0x80) == 0) {
                    goto LABEL_57;
                  }
                  v19 += 7;
                  unint64_t v10 = v22;
                  BOOL v12 = v20++ > 8;
                }
                while (!v12);
LABEL_48:
                LODWORD(v21) = 0;
                goto LABEL_57;
              }
              char v29 = 0;
              unsigned int v30 = 0;
              uint64_t v21 = 0;
              if (v2 <= v10) {
                unint64_t v2 = v10;
              }
              while (v2 != v10)
              {
                unint64_t v31 = v10 + 1;
                char v32 = *(unsigned char *)(v6 + v10);
                a2[1] = v31;
                v21 |= (unint64_t)(v32 & 0x7F) << v29;
                if ((v32 & 0x80) == 0) {
                  goto LABEL_57;
                }
                v29 += 7;
                unint64_t v10 = v31;
                BOOL v18 = v30++ >= 9;
                if (v18) {
                  goto LABEL_48;
                }
              }
              LODWORD(v21) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_57:
              a1[28] = v21;
              int v37 = a1[2] | 1;
              goto LABEL_60;
            case 3u:
              if (v10 <= 0xFFFFFFFFFFFFFFF5 && v10 + 10 <= v2)
              {
                char v24 = 0;
                unsigned int v25 = 0;
                uint64_t v26 = 0;
                do
                {
                  unint64_t v27 = v10 + 1;
                  a2[1] = v10 + 1;
                  char v28 = *(unsigned char *)(v6 + v10);
                  v26 |= (unint64_t)(v28 & 0x7F) << v24;
                  if ((v28 & 0x80) == 0) {
                    goto LABEL_59;
                  }
                  v24 += 7;
                  unint64_t v10 = v27;
                  BOOL v12 = v25++ > 8;
                }
                while (!v12);
LABEL_55:
                LODWORD(v26) = 0;
                goto LABEL_59;
              }
              char v33 = 0;
              unsigned int v34 = 0;
              uint64_t v26 = 0;
              if (v2 <= v10) {
                unint64_t v2 = v10;
              }
              while (v2 != v10)
              {
                unint64_t v35 = v10 + 1;
                char v36 = *(unsigned char *)(v6 + v10);
                a2[1] = v35;
                v26 |= (unint64_t)(v36 & 0x7F) << v33;
                if ((v36 & 0x80) == 0) {
                  goto LABEL_59;
                }
                v33 += 7;
                unint64_t v10 = v35;
                BOOL v18 = v34++ >= 9;
                if (v18) {
                  goto LABEL_55;
                }
              }
              LODWORD(v26) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_59:
              a1[29] = v26;
              int v37 = a1[2] | 2;
LABEL_60:
              a1[2] = v37;
LABEL_61:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 4u:
              operator new();
            case 5u:
              operator new();
            case 6u:
              operator new();
            case 7u:
              operator new();
            default:
              goto LABEL_61;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AC9B2C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::Device::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::writeVarInt(a2);
    int v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0) {
    this = PB::Writer::writeVarInt(a2);
  }
  uint64_t v5 = *(const PB::Base ***)(v3 + 16);
  uint64_t v6 = *(const PB::Base ***)(v3 + 24);
  while (v5 != v6)
  {
    char v7 = *v5++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  unsigned int v8 = *(const PB::Base ***)(v3 + 40);
  unint64_t v9 = *(const PB::Base ***)(v3 + 48);
  while (v8 != v9)
  {
    unint64_t v10 = *v8++;
    this = PB::Writer::writeSubmessage(a2, v10);
  }
  char v11 = *(const PB::Base ***)(v3 + 64);
  BOOL v12 = *(const PB::Base ***)(v3 + 72);
  while (v11 != v12)
  {
    char v13 = *v11++;
    this = PB::Writer::writeSubmessage(a2, v13);
  }
  unint64_t v15 = *(const PB::Base ***)(v3 + 88);
  unsigned int v14 = *(const PB::Base ***)(v3 + 96);
  while (v15 != v14)
  {
    unint64_t v16 = *v15++;
    this = PB::Writer::writeSubmessage(a2, v16);
  }
  return this;
}

uint64_t as::server::Device::formatText(as::server::Device *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "inputSafetyOffset");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "outputSafetyOffset");
  }
  uint64_t v6 = (uint64_t *)*((void *)this + 2);
  char v7 = (uint64_t *)*((void *)this + 3);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "inputStreams");
  }
  unint64_t v9 = (uint64_t *)*((void *)this + 5);
  unint64_t v10 = (uint64_t *)*((void *)this + 6);
  while (v9 != v10)
  {
    uint64_t v11 = *v9++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v11 + 32))(v11, a2, "outputStreams");
  }
  BOOL v12 = (uint64_t *)*((void *)this + 8);
  char v13 = (uint64_t *)*((void *)this + 9);
  while (v12 != v13)
  {
    uint64_t v14 = *v12++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v14 + 32))(v14, a2, "inputPorts");
  }
  unint64_t v15 = (uint64_t *)*((void *)this + 11);
  unint64_t v16 = (uint64_t *)*((void *)this + 12);
  while (v15 != v16)
  {
    uint64_t v17 = *v15++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v17 + 32))(v17, a2, "outputPorts");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::Device::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (*(void *)(a1 + 112) != *(void *)(a2 + 112)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t v6 = (v4 - v5) >> 3;
  if (v6 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3) {
    return 0;
  }
  if (v4 != v5)
  {
    uint64_t v7 = 0;
    if (v6 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = (v4 - v5) >> 3;
    }
    do
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 16) + 8 * v7);
      uint64_t v10 = *(void *)(*(void *)(a2 + 16) + 8 * v7);
      if (v9) {
        BOOL v11 = v10 == 0;
      }
      else {
        BOOL v11 = 1;
      }
      if (v11)
      {
        if (v9 | v10) {
          return 0;
        }
      }
      else if (!as::server::HWStream::operator==(v9, v10))
      {
        return 0;
      }
      ++v7;
    }
    while (v8 != v7);
  }
  uint64_t v13 = *(void *)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 48);
  unint64_t v14 = (v12 - v13) >> 3;
  if (v14 != (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3) {
    return 0;
  }
  if (v12 != v13)
  {
    uint64_t v15 = 0;
    if (v14 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = (v12 - v13) >> 3;
    }
    do
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8 * v15);
      uint64_t v18 = *(void *)(*(void *)(a2 + 40) + 8 * v15);
      if (v17) {
        BOOL v19 = v18 == 0;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19)
      {
        if (v17 | v18) {
          return 0;
        }
      }
      else if (!as::server::HWStream::operator==(v17, v18))
      {
        return 0;
      }
      ++v15;
    }
    while (v16 != v15);
  }
  uint64_t v21 = *(void *)(a1 + 64);
  uint64_t v20 = *(void *)(a1 + 72);
  unint64_t v22 = (v20 - v21) >> 3;
  if (v22 != (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 3) {
    return 0;
  }
  if (v20 != v21)
  {
    uint64_t v23 = 0;
    if (v22 <= 1) {
      uint64_t v24 = 1;
    }
    else {
      uint64_t v24 = (v20 - v21) >> 3;
    }
    do
    {
      uint64_t v25 = *(void *)(*(void *)(a1 + 64) + 8 * v23);
      uint64_t v26 = *(void *)(*(void *)(a2 + 64) + 8 * v23);
      if (v25) {
        BOOL v27 = v26 == 0;
      }
      else {
        BOOL v27 = 1;
      }
      if (v27)
      {
        if (v25 | v26) {
          return 0;
        }
      }
      else if (!as::server::Port::operator==(v25, v26))
      {
        return 0;
      }
      ++v23;
    }
    while (v24 != v23);
  }
  uint64_t v29 = *(void *)(a1 + 88);
  uint64_t v28 = *(void *)(a1 + 96);
  unint64_t v30 = (v28 - v29) >> 3;
  if (v30 == (uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 3)
  {
    if (v28 == v29)
    {
      return 1;
    }
    else
    {
      BOOL v31 = 0;
      uint64_t v32 = 0;
      if (v30 <= 1) {
        uint64_t v33 = 1;
      }
      else {
        uint64_t v33 = (v28 - v29) >> 3;
      }
      do
      {
        uint64_t v34 = *(void *)(*(void *)(a1 + 88) + 8 * v32);
        uint64_t v35 = *(void *)(*(void *)(a2 + 88) + 8 * v32);
        if (v34) {
          BOOL v36 = v35 == 0;
        }
        else {
          BOOL v36 = 1;
        }
        if (v36)
        {
          if (v34 | v35) {
            return v31;
          }
        }
        else if (!as::server::Port::operator==(v34, v35))
        {
          return v31;
        }
        BOOL v31 = ++v32 >= v30;
      }
      while (v33 != v32);
    }
  }
  else
  {
    return 0;
  }
  return v31;
}

void as::server::Device::addInputStreams(as::server::Device *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::HWStream>>::__swap_out_circular_buffer(v7, v15);
    unint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    unint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210ACA1D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::Device::addOutputStreams(as::server::Device *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::HWStream>>::__swap_out_circular_buffer(v7, v15);
    unint64_t v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    unint64_t v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210ACA34C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::Device::addInputPorts(as::server::Device *this)
{
  unint64_t v4 = *((void *)this + 10);
  unint64_t v2 = (char *)this + 80;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::Port>>::__swap_out_circular_buffer(v7, v15);
    unint64_t v6 = (void *)*((void *)this + 9);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    unint64_t v6 = v5 + 1;
    *((void *)this + 9) = v6;
  }
  *((void *)this + 9) = v6;
  operator new();
}

void sub_210ACA4C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::Device::addOutputPorts(as::server::Device *this)
{
  unint64_t v4 = *((void *)this + 13);
  unint64_t v2 = (char *)this + 104;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::Port>>::__swap_out_circular_buffer(v7, v15);
    unint64_t v6 = (void *)*((void *)this + 12);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    unint64_t v6 = v5 + 1;
    *((void *)this + 12) = v6;
  }
  *((void *)this + 12) = v6;
  operator new();
}

void sub_210ACA634(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::Device_Clock::default_instance(as::server::Device_Clock *this)
{
  {
    operator new();
  }
  return as::server::Device_Clock::default_instance(void)::gInstance;
}

void sub_210ACA6D8(_Unwind_Exception *a1)
{
}

void *as::server::Device_Clock::Device_Clock(void *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312948;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312948;
  return this;
}

as::server::Device_Clock *as::server::Device_Clock::Device_Clock(as::server::Device_Clock *this, const as::server::Device_Clock *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C312948;
  as::server::Device_Clock::copy_from(this, a2);
  return this;
}

{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C312948;
  as::server::Device_Clock::copy_from(this, a2);
  return this;
}

void as::server::Device_Clock::copy_from(as::server::Device_Clock *this, const as::server::Device_Clock *a2)
{
  unint64_t v4 = (const as::server::Clock *)*((void *)a2 + 1);
  if (v4)
  {
    uint64_t v5 = (as::server::Clock *)as::server::Device_Clock::mutableClock(this);
    as::server::Clock::copy_from(v5, v4);
  }
  unint64_t v6 = (const as::server::Device *)*((void *)a2 + 2);
  if (v6)
  {
    uint64_t v7 = (as::server::Device *)as::server::Device_Clock::mutableDevice(this);
    as::server::Device::copy_from(v7, v6);
  }
}

as::server::Device_Clock *as::server::Device_Clock::operator=(as::server::Device_Clock *a1, const as::server::Device_Clock *a2)
{
  return a1;
}

uint64_t as::server::Device_Clock::clock(as::server::Device_Clock *this)
{
  uint64_t result = *((void *)this + 1);
  if (!result) {
    return as::server::Clock::default_instance(0);
  }
  return result;
}

uint64_t as::server::Device_Clock::mutableClock(as::server::Device_Clock *this)
{
  if (!*((void *)this + 1)) {
    operator new();
  }
  return *((void *)this + 1);
}

uint64_t as::server::Device_Clock::device(as::server::Device_Clock *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return as::server::Device::default_instance(0);
  }
  return result;
}

uint64_t as::server::Device_Clock::mutableDevice(as::server::Device_Clock *this)
{
  if (!*((void *)this + 2)) {
    operator new();
  }
  return *((void *)this + 2);
}

void *as::server::Device_Clock::Device_Clock(void *result, uint64_t a2)
{
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C312948;
  result[1] = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = result[2];
  result[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  return result;
}

{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C312948;
  result[1] = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = result[2];
  result[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  return result;
}

uint64_t as::server::Device_Clock::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::Device_Clock::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::Device_Clock::clear(as::server::Device_Clock *this)
{
  uint64_t v2 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result)
  {
    unint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v4();
  }
  return result;
}

BOOL as::server::Device_Clock::isInitialized(as::server::Device_Clock *this)
{
  uint64_t v2 = (as::server::Clock *)*((void *)this + 1);
  if (!v2) {
    return 0;
  }
  if (!as::server::Clock::isInitialized(v2)) {
    return 0;
  }
  uint64_t v3 = (as::server::Device *)*((void *)this + 2);
  if (!v3) {
    return 0;
  }
  return as::server::Device::isInitialized(v3);
}

BOOL as::server::Device_Clock::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v2 + 1;
        a2[1] = v2 + 1;
        char v11 = *(unsigned char *)(v6 + v2);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v2 = v10;
        if (v8++ > 8) {
          goto LABEL_19;
        }
      }
LABEL_20:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v9 >> 3) == 2) {
        operator new();
      }
      if ((v9 >> 3) == 1) {
        operator new();
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v15 = v2 + 1;
      char v16 = *(unsigned char *)(v6 + v2);
      a2[1] = v15;
      v9 |= (unint64_t)(v16 & 0x7F) << v13;
      if ((v16 & 0x80) == 0) {
        goto LABEL_20;
      }
      v13 += 7;
      unint64_t v2 = v15;
      if (v14++ >= 9)
      {
LABEL_19:
        unint64_t v9 = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::Device_Clock::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(const PB::Base **)(this + 8);
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  uint64_t v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
  {
    return PB::Writer::writeSubmessage(a2, v5);
  }
  return this;
}

uint64_t as::server::Device_Clock::formatText(as::server::Device_Clock *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 1);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "clock");
  }
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, a2, "device");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::Device_Clock::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (as::server::Clock::operator==(v4, v5)) {
      goto LABEL_9;
    }
    return 0;
  }
  if (v4 | v5) {
    return 0;
  }
LABEL_9:
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(a2 + 16);
  BOOL result = (v8 | v9) == 0;
  if (v8 && v9)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    return as::server::Device::operator==(v10, v9);
  }
  return result;
}

uint64_t as::server::Device_Clock::clearClock(as::server::Device_Clock *this)
{
  uint64_t result = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::Device_Clock::clearDevice(as::server::Device_Clock *this)
{
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::Box::default_instance(as::server::Box *this)
{
  {
    operator new();
  }
  return as::server::Box::default_instance(void)::gInstance;
}

void sub_210ACB104(_Unwind_Exception *a1)
{
}

double as::server::Box::Box(as::server::Box *this)
{
  *(void *)this = &unk_26C312DA8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((unsigned char *)this + 96) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312DA8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((unsigned char *)this + 96) = 0;
  return result;
}

as::server::Box *as::server::Box::Box(as::server::Box *this, const as::server::Box *a2)
{
  *(void *)this = &unk_26C312DA8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  as::server::Box::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312DA8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  as::server::Box::copy_from(this, a2);
  return this;
}

void *as::server::Box::copy_from(as::server::Box *this, const as::server::Box *a2)
{
  uint64_t v4 = (const as::server::HardwareInfo *)*((void *)a2 + 11);
  if (v4)
  {
    uint64_t v5 = (as::server::HardwareInfo *)as::server::Box::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v5, v4);
  }
  if (this != a2)
  {
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((char *)this + 40, *((char **)a2 + 5), *((void *)a2 + 6), (uint64_t)(*((void *)a2 + 6) - *((void *)a2 + 5)) >> 3);
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((char *)this + 64, *((char **)a2 + 8), *((void *)a2 + 9), (uint64_t)(*((void *)a2 + 9) - *((void *)a2 + 8)) >> 3);
  }
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((unsigned char *)this + 96) = *((unsigned char *)a2 + 96);
  return result;
}

void sub_210ACB394(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::Box *as::server::Box::operator=(as::server::Box *a1, const as::server::Box *a2)
{
  return a1;
}

uint64_t as::server::Box::hardwareInfo(as::server::Box *this)
{
  uint64_t result = *((void *)this + 11);
  if (!result) {
    return as::server::HardwareInfo::default_instance(0);
  }
  return result;
}

uint64_t as::server::Box::mutableHardwareInfo(as::server::Box *this)
{
  if (!*((void *)this + 11)) {
    operator new();
  }
  return *((void *)this + 11);
}

uint64_t as::server::Box::Box(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312DA8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  as::server::Box::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312DA8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  as::server::Box::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Box::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 88);
  *(void *)(result + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v2;
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v3;
  uint64_t v4 = *(void *)(result + 48);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v4;
  uint64_t v5 = *(void *)(result + 56);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v5;
  uint64_t v6 = *(void *)(result + 64);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v6;
  uint64_t v7 = *(void *)(result + 72);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v7;
  uint64_t v8 = *(void *)(result + 80);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v8;
  uint64_t v9 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v9;
  uint64_t v10 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v10;
  uint64_t v11 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v11;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(unsigned char *)(result + 96) = *(unsigned char *)(a2 + 96);
  return result;
}

uint64_t as::server::Box::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

void *as::server::Box::clear(as::server::Box *this)
{
  uint64_t v2 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 6) = *((void *)this + 5);
  *((void *)this + 9) = *((void *)this + 8);
  uint64_t result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 96) = 0;
  return result;
}

uint64_t as::server::Box::isInitialized(as::server::Box *this)
{
  if (!*((void *)this + 11)) {
    return 0;
  }
  uint64_t v2 = (as::server::ControlAndValue **)*((void *)this + 2);
  uint64_t v3 = (as::server::ControlAndValue **)*((void *)this + 3);
  while (v2 != v3)
  {
    if (!as::server::ControlAndValue::isInitialized(*v2)) {
      return 0;
    }
    ++v2;
  }
  return *((unsigned char *)this + 8) & 1;
}

BOOL as::server::Box::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    uint64_t v8 = (void **)(a1 + 64);
    uint64_t v9 = (void *)(a1 + 80);
    uint64_t v10 = (void **)(a1 + 40);
    uint64_t v11 = (void *)(a1 + 56);
    while (1)
    {
      uint64_t v12 = *a2;
      if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
      {
        char v13 = 0;
        unsigned int v14 = 0;
        unint64_t v15 = 0;
        while (1)
        {
          unint64_t v16 = v3 + 1;
          a2[1] = v3 + 1;
          char v17 = *(unsigned char *)(v12 + v3);
          v15 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0) {
            goto LABEL_23;
          }
          v13 += 7;
          unint64_t v3 = v16;
          BOOL v38 = v14++ > 8;
          if (v38)
          {
            unint64_t v15 = 0;
            goto LABEL_23;
          }
        }
      }
      char v18 = 0;
      unsigned int v19 = 0;
      unint64_t v15 = 0;
      unint64_t v20 = v3 <= v2 ? v2 : v3;
      do
      {
        if (v20 == v3)
        {
          int v4 = 1;
          *((unsigned char *)a2 + 24) = 1;
          return v4 == 0;
        }
        unint64_t v21 = v3++;
        char v22 = *(unsigned char *)(v12 + v21);
        a2[1] = v3;
        v15 |= (unint64_t)(v22 & 0x7F) << v18;
        if ((v22 & 0x80) == 0) {
          goto LABEL_22;
        }
        v18 += 7;
      }
      while (v19++ < 9);
      unint64_t v15 = 0;
LABEL_22:
      unint64_t v16 = v21 + 1;
LABEL_23:
      int v24 = v15 & 7;
      if (v24 == 4) {
        break;
      }
      switch((v15 >> 3))
      {
        case 2u:
          operator new();
        case 3u:
          if (v16 >= v2)
          {
            BOOL v73 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v72 = *(unsigned __int8 *)(v12 + v16);
            a2[1] = v16 + 1;
            BOOL v73 = v72 != 0;
          }
          *(unsigned char *)(a1 + 96) = v73;
          *(_DWORD *)(a1 + 8) |= 1u;
          goto LABEL_190;
        case 4u:
          if (v24 == 2)
          {
            if (PB::Reader::placeMark()) {
              return 0;
            }
            if (a2[1] < (unint64_t)a2[2] && !*((unsigned char *)a2 + 24))
            {
              uint64_t v25 = *(char **)(a1 + 48);
              do
              {
                if ((unint64_t)v25 >= *v11)
                {
                  uint64_t v26 = (char *)*v10;
                  uint64_t v27 = (v25 - (unsigned char *)*v10) >> 3;
                  unint64_t v28 = v27 + 1;
                  if ((unint64_t)(v27 + 1) >> 61) {
                    goto LABEL_201;
                  }
                  uint64_t v29 = *v11 - (void)v26;
                  if (v29 >> 2 > v28) {
                    unint64_t v28 = v29 >> 2;
                  }
                  if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v30 = v28;
                  }
                  if (v30)
                  {
                    BOOL v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v11, v30);
                    uint64_t v26 = *(char **)(a1 + 40);
                    uint64_t v25 = *(char **)(a1 + 48);
                  }
                  else
                  {
                    BOOL v31 = 0;
                  }
                  uint64_t v32 = &v31[8 * v27];
                  *(void *)uint64_t v32 = 0;
                  uint64_t v33 = v32 + 8;
                  while (v25 != v26)
                  {
                    uint64_t v34 = *((void *)v25 - 1);
                    v25 -= 8;
                    *((void *)v32 - 1) = v34;
                    v32 -= 8;
                  }
                  *(void *)(a1 + 40) = v32;
                  *(void *)(a1 + 48) = v33;
                  *(void *)(a1 + 56) = &v31[8 * v30];
                  if (v26) {
                    operator delete(v26);
                  }
                  uint64_t v25 = v33;
                }
                else
                {
                  *(void *)uint64_t v25 = 0;
                  v25 += 8;
                }
                *(void *)(a1 + 48) = v25;
                unint64_t v36 = a2[1];
                unint64_t v35 = a2[2];
                uint64_t v37 = *a2;
                BOOL v38 = v36 > 0xFFFFFFFFFFFFFFF5 || v36 + 10 > v35;
                if (v38)
                {
                  char v39 = 0;
                  unsigned int v40 = 0;
                  uint64_t v46 = 0;
                  if (v35 <= v36) {
                    uint64_t v41 = a2[1];
                  }
                  else {
                    uint64_t v41 = a2[2];
                  }
                  while (1)
                  {
                    if (v41 == v36) {
                      goto LABEL_125;
                    }
                    unint64_t v42 = v36++;
                    char v43 = *(unsigned char *)(v37 + v42);
                    a2[1] = v36;
                    v46 |= (unint64_t)(v43 & 0x7F) << v39;
                    if ((v43 & 0x80) == 0) {
                      break;
                    }
                    v39 += 7;
                    BOOL v38 = v40++ > 8;
                    if (v38)
                    {
                      uint64_t v46 = 0;
                      goto LABEL_68;
                    }
                  }
                  if (*((unsigned char *)a2 + 24)) {
                    uint64_t v46 = 0;
                  }
LABEL_68:
                  unint64_t v47 = v42 + 1;
                }
                else
                {
                  char v44 = 0;
                  unsigned int v45 = 0;
                  uint64_t v46 = 0;
                  while (1)
                  {
                    unint64_t v47 = v36 + 1;
                    a2[1] = v36 + 1;
                    char v48 = *(unsigned char *)(v37 + v36);
                    v46 |= (unint64_t)(v48 & 0x7F) << v44;
                    if ((v48 & 0x80) == 0) {
                      break;
                    }
                    v44 += 7;
                    unint64_t v36 = v47;
                    BOOL v38 = v45++ > 8;
                    if (v38)
                    {
                      uint64_t v46 = 0;
                      break;
                    }
                  }
                }
                *((void *)v25 - 1) = v46;
              }
              while (v47 < v35 && !*((unsigned char *)a2 + 24));
            }
            goto LABEL_190;
          }
          uint64_t v75 = *(char **)(a1 + 48);
          unint64_t v74 = *(void *)(a1 + 56);
          if ((unint64_t)v75 >= v74)
          {
            char v79 = (char *)*v10;
            uint64_t v80 = (v75 - (unsigned char *)*v10) >> 3;
            unint64_t v81 = v80 + 1;
            if ((unint64_t)(v80 + 1) >> 61) {
LABEL_201:
            }
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            uint64_t v82 = v74 - (void)v79;
            if (v82 >> 2 > v81) {
              unint64_t v81 = v82 >> 2;
            }
            if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v83 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v83 = v81;
            }
            if (v83)
            {
              int v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v11, v83);
              char v79 = *(char **)(a1 + 40);
              uint64_t v75 = *(char **)(a1 + 48);
            }
            else
            {
              int v84 = 0;
            }
            char v91 = &v84[8 * v80];
            *(void *)char v91 = 0;
            uint64_t v76 = v91 + 8;
            while (v75 != v79)
            {
              uint64_t v92 = *((void *)v75 - 1);
              v75 -= 8;
              *((void *)v91 - 1) = v92;
              v91 -= 8;
            }
            *(void *)(a1 + 40) = v91;
            *(void *)(a1 + 48) = v76;
            *(void *)(a1 + 56) = &v84[8 * v83];
            if (v79) {
              operator delete(v79);
            }
          }
          else
          {
            *(void *)uint64_t v75 = 0;
            uint64_t v76 = v75 + 8;
          }
          *(void *)(a1 + 48) = v76;
          unint64_t v93 = a2[1];
          unint64_t v94 = a2[2];
          uint64_t v95 = *a2;
          char v96 = 0;
          unsigned int v97 = 0;
          if (v93 <= 0xFFFFFFFFFFFFFFF5 && v93 + 10 <= v94)
          {
            uint64_t v101 = 0;
            while (1)
            {
              unint64_t v102 = v93 + 1;
              a2[1] = v93 + 1;
              char v103 = *(unsigned char *)(v95 + v93);
              v101 |= (unint64_t)(v103 & 0x7F) << v96;
              if ((v103 & 0x80) == 0) {
                goto LABEL_189;
              }
              v96 += 7;
              unint64_t v93 = v102;
              BOOL v38 = v97++ > 8;
              if (v38) {
                goto LABEL_185;
              }
            }
          }
          uint64_t v101 = 0;
          if (v94 <= v93) {
            unint64_t v94 = a2[1];
          }
          while (v94 != v93)
          {
            unint64_t v99 = v93 + 1;
            char v100 = *(unsigned char *)(v95 + v93);
            a2[1] = v99;
            v101 |= (unint64_t)(v100 & 0x7F) << v96;
            if ((v100 & 0x80) == 0) {
              goto LABEL_187;
            }
            v96 += 7;
            unint64_t v93 = v99;
            BOOL v38 = v97++ > 8;
            if (v38) {
              goto LABEL_185;
            }
          }
          goto LABEL_186;
        case 5u:
          if (v24 == 2)
          {
            if (PB::Reader::placeMark()) {
              return 0;
            }
            if (a2[1] >= (unint64_t)a2[2] || *((unsigned char *)a2 + 24)) {
              goto LABEL_190;
            }
            uint64_t v25 = *(char **)(a1 + 72);
            do
            {
              if ((unint64_t)v25 >= *v9)
              {
                char v49 = (char *)*v8;
                uint64_t v50 = (v25 - (unsigned char *)*v8) >> 3;
                unint64_t v51 = v50 + 1;
                if ((unint64_t)(v50 + 1) >> 61) {
                  goto LABEL_200;
                }
                uint64_t v52 = *v9 - (void)v49;
                if (v52 >> 2 > v51) {
                  unint64_t v51 = v52 >> 2;
                }
                if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v53 = v51;
                }
                if (v53)
                {
                  char v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v9, v53);
                  char v49 = *(char **)(a1 + 64);
                  uint64_t v25 = *(char **)(a1 + 72);
                }
                else
                {
                  char v54 = 0;
                }
                unsigned int v55 = &v54[8 * v50];
                *(void *)unsigned int v55 = 0;
                unint64_t v56 = v55 + 8;
                while (v25 != v49)
                {
                  uint64_t v57 = *((void *)v25 - 1);
                  v25 -= 8;
                  *((void *)v55 - 1) = v57;
                  v55 -= 8;
                }
                *(void *)(a1 + 64) = v55;
                *(void *)(a1 + 72) = v56;
                *(void *)(a1 + 80) = &v54[8 * v53];
                if (v49) {
                  operator delete(v49);
                }
                uint64_t v25 = v56;
              }
              else
              {
                *(void *)uint64_t v25 = 0;
                v25 += 8;
              }
              *(void *)(a1 + 72) = v25;
              unint64_t v59 = a2[1];
              unint64_t v58 = a2[2];
              uint64_t v60 = *a2;
              if (v59 <= 0xFFFFFFFFFFFFFFF5 && v59 + 10 <= v58)
              {
                char v67 = 0;
                unsigned int v68 = 0;
                uint64_t v69 = 0;
                while (1)
                {
                  unint64_t v70 = v59 + 1;
                  a2[1] = v59 + 1;
                  char v71 = *(unsigned char *)(v60 + v59);
                  v69 |= (unint64_t)(v71 & 0x7F) << v67;
                  if ((v71 & 0x80) == 0) {
                    goto LABEL_114;
                  }
                  v67 += 7;
                  unint64_t v59 = v70;
                  BOOL v38 = v68++ > 8;
                  if (v38)
                  {
                    uint64_t v69 = 0;
                    goto LABEL_114;
                  }
                }
              }
              char v62 = 0;
              unsigned int v63 = 0;
              uint64_t v69 = 0;
              if (v58 <= v59) {
                uint64_t v64 = a2[1];
              }
              else {
                uint64_t v64 = a2[2];
              }
              while (1)
              {
                if (v64 == v59)
                {
LABEL_125:
                  *((unsigned char *)a2 + 24) = 1;
                  *((void *)v25 - 1) = 0;
                  goto LABEL_190;
                }
                unint64_t v65 = v59++;
                char v66 = *(unsigned char *)(v60 + v65);
                a2[1] = v59;
                v69 |= (unint64_t)(v66 & 0x7F) << v62;
                if ((v66 & 0x80) == 0) {
                  break;
                }
                v62 += 7;
                BOOL v38 = v63++ > 8;
                if (v38)
                {
                  uint64_t v69 = 0;
                  goto LABEL_113;
                }
              }
              if (*((unsigned char *)a2 + 24)) {
                uint64_t v69 = 0;
              }
LABEL_113:
              unint64_t v70 = v65 + 1;
LABEL_114:
              *((void *)v25 - 1) = v69;
            }
            while (v70 < v58 && !*((unsigned char *)a2 + 24));
          }
          else
          {
            char v78 = *(char **)(a1 + 72);
            unint64_t v77 = *(void *)(a1 + 80);
            if ((unint64_t)v78 >= v77)
            {
              BOOL v85 = (char *)*v8;
              uint64_t v86 = (v78 - (unsigned char *)*v8) >> 3;
              unint64_t v87 = v86 + 1;
              if ((unint64_t)(v86 + 1) >> 61) {
LABEL_200:
              }
                std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
              uint64_t v88 = v77 - (void)v85;
              if (v88 >> 2 > v87) {
                unint64_t v87 = v88 >> 2;
              }
              if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v89 = v87;
              }
              if (v89)
              {
                char v90 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v9, v89);
                BOOL v85 = *(char **)(a1 + 64);
                char v78 = *(char **)(a1 + 72);
              }
              else
              {
                char v90 = 0;
              }
              int v104 = &v90[8 * v86];
              *(void *)int v104 = 0;
              uint64_t v76 = v104 + 8;
              while (v78 != v85)
              {
                uint64_t v105 = *((void *)v78 - 1);
                v78 -= 8;
                *((void *)v104 - 1) = v105;
                v104 -= 8;
              }
              *(void *)(a1 + 64) = v104;
              *(void *)(a1 + 72) = v76;
              *(void *)(a1 + 80) = &v90[8 * v89];
              if (v85) {
                operator delete(v85);
              }
            }
            else
            {
              *(void *)char v78 = 0;
              uint64_t v76 = v78 + 8;
            }
            *(void *)(a1 + 72) = v76;
            unint64_t v106 = a2[1];
            unint64_t v107 = a2[2];
            uint64_t v108 = *a2;
            char v109 = 0;
            unsigned int v110 = 0;
            if (v106 > 0xFFFFFFFFFFFFFFF5 || v106 + 10 > v107)
            {
              uint64_t v101 = 0;
              if (v107 <= v106) {
                unint64_t v107 = a2[1];
              }
              while (v107 != v106)
              {
                unint64_t v112 = v106 + 1;
                char v113 = *(unsigned char *)(v108 + v106);
                a2[1] = v112;
                v101 |= (unint64_t)(v113 & 0x7F) << v109;
                if ((v113 & 0x80) == 0)
                {
LABEL_187:
                  if (*((unsigned char *)a2 + 24)) {
                    uint64_t v101 = 0;
                  }
                  goto LABEL_189;
                }
                v109 += 7;
                unint64_t v106 = v112;
                BOOL v38 = v110++ > 8;
                if (v38)
                {
LABEL_185:
                  uint64_t v101 = 0;
                  goto LABEL_189;
                }
              }
LABEL_186:
              uint64_t v101 = 0;
              *((unsigned char *)a2 + 24) = 1;
            }
            else
            {
              uint64_t v101 = 0;
              while (1)
              {
                unint64_t v114 = v106 + 1;
                a2[1] = v106 + 1;
                char v115 = *(unsigned char *)(v108 + v106);
                v101 |= (unint64_t)(v115 & 0x7F) << v109;
                if ((v115 & 0x80) == 0) {
                  break;
                }
                v109 += 7;
                unint64_t v106 = v114;
                BOOL v38 = v110++ > 8;
                if (v38) {
                  goto LABEL_185;
                }
              }
            }
LABEL_189:
            *(v76 - 1) = v101;
          }
LABEL_190:
          unint64_t v3 = a2[1];
          unint64_t v2 = a2[2];
          int v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || v4 != 0) {
            return v4 == 0;
          }
          break;
        case 6u:
          operator new();
        default:
          goto LABEL_190;
      }
    }
    int v4 = 0;
  }
  return v4 == 0;
}

void sub_210ACC160(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::Box::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(const PB::Base **)(this + 88);
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  if (*(unsigned char *)(v3 + 8)) {
    this = PB::Writer::write(a2);
  }
  uint64_t v5 = *(void *)(v3 + 40);
  uint64_t v6 = *(void *)(v3 + 48);
  while (v5 != v6)
  {
    v5 += 8;
    this = PB::Writer::writeVarInt(a2);
  }
  uint64_t v7 = *(void *)(v3 + 64);
  uint64_t v8 = *(void *)(v3 + 72);
  while (v7 != v8)
  {
    v7 += 8;
    this = PB::Writer::writeVarInt(a2);
  }
  uint64_t v10 = *(const PB::Base ***)(v3 + 16);
  uint64_t v9 = *(const PB::Base ***)(v3 + 24);
  while (v10 != v9)
  {
    uint64_t v11 = *v10++;
    this = PB::Writer::writeSubmessage(a2, v11);
  }
  return this;
}

uint64_t as::server::Box::formatText(as::server::Box *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 11);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "hardwareInfo");
  }
  if (*((unsigned char *)this + 8)) {
    PB::TextFormatter::format(a2, "activated");
  }
  uint64_t v6 = *((void *)this + 5);
  uint64_t v7 = *((void *)this + 6);
  while (v6 != v7)
  {
    v6 += 8;
    PB::TextFormatter::format(a2, "clocksIDs");
  }
  uint64_t v8 = *((void *)this + 8);
  uint64_t v9 = *((void *)this + 9);
  while (v8 != v9)
  {
    v8 += 8;
    PB::TextFormatter::format(a2, "deviceIDs");
  }
  uint64_t v10 = (uint64_t *)*((void *)this + 2);
  uint64_t v11 = (uint64_t *)*((void *)this + 3);
  while (v10 != v11)
  {
    uint64_t v12 = *v10++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v12 + 32))(v12, a2, "controls");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::Box::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(unsigned __int8 *)(a1 + 96) != *(unsigned __int8 *)(a2 + 96)) {
    return 0;
  }
  unint64_t v4 = *(void *)(a1 + 88);
  unint64_t v5 = *(void *)(a2 + 88);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 | v5) {
      return 0;
    }
  }
  else if (!as::server::HardwareInfo::operator==((_DWORD *)v4, (_DWORD *)v5))
  {
    return 0;
  }
  uint64_t v7 = *(uint64_t **)(a1 + 40);
  uint64_t v8 = *(void **)(a1 + 48);
  unint64_t v9 = v8 - v7;
  uint64_t v10 = *(uint64_t **)(a2 + 40);
  if (v9 != (uint64_t)(*(void *)(a2 + 48) - (void)v10) >> 3) {
    return 0;
  }
  if (v8 != v7)
  {
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    do
    {
      uint64_t v12 = *v7++;
      uint64_t v11 = v12;
      uint64_t v13 = *v10++;
      if (v11 != v13) {
        return 0;
      }
    }
    while (--v9);
  }
  unsigned int v14 = *(uint64_t **)(a1 + 64);
  unint64_t v15 = *(void **)(a1 + 72);
  unint64_t v16 = v15 - v14;
  char v17 = *(uint64_t **)(a2 + 64);
  if (v16 != (uint64_t)(*(void *)(a2 + 72) - (void)v17) >> 3) {
    return 0;
  }
  if (v15 != v14)
  {
    if (v16 <= 1) {
      unint64_t v16 = 1;
    }
    do
    {
      uint64_t v19 = *v14++;
      uint64_t v18 = v19;
      uint64_t v20 = *v17++;
      if (v18 != v20) {
        return 0;
      }
    }
    while (--v16);
  }
  uint64_t v22 = *(void *)(a1 + 16);
  uint64_t v21 = *(void *)(a1 + 24);
  unint64_t v23 = (v21 - v22) >> 3;
  if (v23 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3) {
    return 0;
  }
  if (v21 == v22)
  {
    return 1;
  }
  else
  {
    BOOL v24 = 0;
    uint64_t v25 = 0;
    if (v23 <= 1) {
      uint64_t v26 = 1;
    }
    else {
      uint64_t v26 = (v21 - v22) >> 3;
    }
    do
    {
      uint64_t v27 = *(void *)(*(void *)(a1 + 16) + 8 * v25);
      uint64_t v28 = *(void *)(*(void *)(a2 + 16) + 8 * v25);
      if (v27) {
        BOOL v29 = v28 == 0;
      }
      else {
        BOOL v29 = 1;
      }
      if (v29)
      {
        if (v27 | v28) {
          return v24;
        }
      }
      else if (!as::server::ControlAndValue::operator==(v27, v28))
      {
        return v24;
      }
      BOOL v24 = ++v25 >= v23;
    }
    while (v26 != v25);
  }
  return v24;
}

uint64_t as::server::Box::clearHardwareInfo(as::server::Box *this)
{
  uint64_t result = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::server::Box::addControls(as::server::Box *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  unint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unsigned int v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unsigned int v14 = 0;
    v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::ControlAndValue>>::__swap_out_circular_buffer(v7, v15);
    BOOL v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *unint64_t v5 = 0;
    BOOL v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210ACC6D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::Driver::default_instance(as::server::Driver *this)
{
  {
    operator new();
  }
  return as::server::Driver::default_instance(void)::gInstance;
}

void sub_210ACC788(_Unwind_Exception *a1)
{
}

double as::server::Driver::Driver(as::server::Driver *this)
{
  *(void *)this = &unk_26C312E88;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312E88;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0;
  return result;
}

as::server::Driver *as::server::Driver::Driver(as::server::Driver *this, const as::server::Driver *a2)
{
  *(void *)this = &unk_26C312E88;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::Driver::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312E88;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  as::server::Driver::copy_from(this, a2);
  return this;
}

void *as::server::Driver::copy_from(as::server::Driver *this, const as::server::Driver *a2)
{
  caulk::xstring::assign((as::server::Driver *)((char *)this + 88), (const as::server::Driver *)((char *)a2 + 88));
  unint64_t v4 = (const as::server::HardwareInfo *)*((void *)a2 + 13);
  if (v4)
  {
    unint64_t v5 = (as::server::HardwareInfo *)as::server::Driver::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v5, v4);
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    operator new();
  }
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 8);
  if (*((void *)a2 + 8) != *((void *)a2 + 9)) {
    operator new();
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 14) = *((void *)a2 + 14);
  return result;
}

void sub_210ACCC30(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::Driver *as::server::Driver::operator=(as::server::Driver *a1, const as::server::Driver *a2)
{
  return a1;
}

uint64_t as::server::Driver::hardwareInfo(as::server::Driver *this)
{
  uint64_t result = *((void *)this + 13);
  if (!result) {
    return as::server::HardwareInfo::default_instance(0);
  }
  return result;
}

uint64_t as::server::Driver::mutableHardwareInfo(as::server::Driver *this)
{
  if (!*((void *)this + 13)) {
    operator new();
  }
  return *((void *)this + 13);
}

uint64_t as::server::Driver::Driver(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312E88;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::Driver::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312E88;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  as::server::Driver::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Driver::move_from(uint64_t a1, uint64_t a2)
{
  v15[0] = 0;
  v15[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)v15);
  uint64_t v5 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v5;
  uint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v6;
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v7;
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v8;
  uint64_t v9 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v9;
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v10;
  uint64_t v11 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v11;
  uint64_t v12 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v12;
  uint64_t v13 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v13;
  uint64_t v14 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v14;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  return result;
}

uint64_t as::server::Driver::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

void *as::server::Driver::clear(as::server::Driver *this)
{
  caulk::xstring::clear((as::server::Driver *)((char *)this + 88));
  uint64_t v2 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  uint64_t result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 8);
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 14) = 0;
  return result;
}

BOOL as::server::Driver::isInitialized(as::server::Driver *this)
{
  if (!*((void *)this + 13)) {
    return 0;
  }
  uint64_t v2 = (as::server::Device_Clock **)*((void *)this + 2);
  unint64_t v3 = (as::server::Device_Clock **)*((void *)this + 3);
  while (v2 != v3)
  {
    if (!as::server::Device_Clock::isInitialized(*v2)) {
      return 0;
    }
    ++v2;
  }
  unint64_t v4 = (as::server::Clock **)*((void *)this + 5);
  uint64_t v5 = (as::server::Clock **)*((void *)this + 6);
  while (v4 != v5)
  {
    if (!as::server::Clock::isInitialized(*v4)) {
      return 0;
    }
    ++v4;
  }
  uint64_t v6 = (as::server::Box **)*((void *)this + 8);
  uint64_t v7 = (as::server::Box **)*((void *)this + 9);
  while (v6 != v7)
  {
    if ((as::server::Box::isInitialized(*v6) & 1) == 0) {
      return 0;
    }
    ++v6;
  }
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::Driver::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v15 = 0;
        unsigned int v16 = 0;
        unint64_t v11 = 0;
        if (v3 <= v2) {
          unint64_t v17 = v2;
        }
        else {
          unint64_t v17 = v3;
        }
        while (v17 != v3)
        {
          unint64_t v18 = v3++;
          char v19 = *(unsigned char *)(v8 + v18);
          a2[1] = v3;
          v11 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0) {
            goto LABEL_21;
          }
          v15 += 7;
          BOOL v20 = v16++ >= 9;
          if (v20)
          {
            unint64_t v11 = 0;
LABEL_21:
            unint64_t v12 = v18 + 1;
            goto LABEL_22;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v9 = 0;
        unsigned int v10 = 0;
        unint64_t v11 = 0;
        while (1)
        {
          unint64_t v12 = v3 + 1;
          a2[1] = v3 + 1;
          char v13 = *(unsigned char *)(v8 + v3);
          v11 |= (unint64_t)(v13 & 0x7F) << v9;
          if ((v13 & 0x80) == 0) {
            break;
          }
          v9 += 7;
          unint64_t v3 = v12;
          BOOL v14 = v10++ > 8;
          if (v14)
          {
            unint64_t v11 = 0;
            break;
          }
        }
LABEL_22:
        if ((v11 & 7) != 4)
        {
          switch((v11 >> 3))
          {
            case 1u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v21 = 0;
                unsigned int v22 = 0;
                uint64_t v23 = 0;
                do
                {
                  unint64_t v24 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v25 = *(unsigned char *)(v8 + v12);
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if ((v25 & 0x80) == 0) {
                    goto LABEL_44;
                  }
                  v21 += 7;
                  unint64_t v12 = v24;
                  BOOL v14 = v22++ > 8;
                }
                while (!v14);
LABEL_42:
                uint64_t v23 = 0;
                goto LABEL_44;
              }
              char v26 = 0;
              unsigned int v27 = 0;
              uint64_t v23 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v28 = v12 + 1;
                char v29 = *(unsigned char *)(v8 + v12);
                a2[1] = v28;
                v23 |= (unint64_t)(v29 & 0x7F) << v26;
                if ((v29 & 0x80) == 0) {
                  goto LABEL_44;
                }
                v26 += 7;
                unint64_t v12 = v28;
                BOOL v20 = v27++ >= 9;
                if (v20) {
                  goto LABEL_42;
                }
              }
              uint64_t v23 = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_44:
              *(void *)(a1 + 112) = v23;
              *(_DWORD *)(a1 + 8) |= 1u;
LABEL_45:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 2u:
              PB::Reader::read();
              caulk::xstring::assign();
              *(_DWORD *)(a1 + 8) |= 2u;
              goto LABEL_45;
            case 3u:
              operator new();
            case 4u:
              operator new();
            case 5u:
              operator new();
            case 6u:
              operator new();
            default:
              goto LABEL_45;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210ACD744(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::server::Driver::writeTo(as::server::Driver *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v5 = (char *)caulk::xstring::c_str((as::server::Driver *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v17 < 0) {
      operator delete(__p);
    }
  }
  uint64_t v6 = (const PB::Base *)*((void *)this + 13);
  if (v6) {
    PB::Writer::writeSubmessage(a2, v6);
  }
  uint64_t v7 = (const PB::Base **)*((void *)this + 2);
  uint64_t v8 = (const PB::Base **)*((void *)this + 3);
  while (v7 != v8)
  {
    char v9 = *v7++;
    PB::Writer::writeSubmessage(a2, v9);
  }
  unsigned int v10 = (const PB::Base **)*((void *)this + 5);
  unint64_t v11 = (const PB::Base **)*((void *)this + 6);
  while (v10 != v11)
  {
    unint64_t v12 = *v10++;
    PB::Writer::writeSubmessage(a2, v12);
  }
  BOOL v14 = (const PB::Base **)*((void *)this + 8);
  char v13 = (const PB::Base **)*((void *)this + 9);
  while (v14 != v13)
  {
    uint64_t v15 = *v14++;
    PB::Writer::writeSubmessage(a2, v15);
  }
}

void sub_210ACD8E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::Driver::formatText(as::server::Driver *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "objectToken");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::server::Driver *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v19 < 0) {
      operator delete(__p);
    }
  }
  uint64_t v7 = *((void *)this + 13);
  if (v7) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, a2, "hardwareInfo");
  }
  uint64_t v8 = (uint64_t *)*((void *)this + 2);
  char v9 = (uint64_t *)*((void *)this + 3);
  while (v8 != v9)
  {
    uint64_t v10 = *v8++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v10 + 32))(v10, a2, "devices");
  }
  unint64_t v11 = (uint64_t *)*((void *)this + 5);
  unint64_t v12 = (uint64_t *)*((void *)this + 6);
  while (v11 != v12)
  {
    uint64_t v13 = *v11++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v13 + 32))(v13, a2, "clocks");
  }
  BOOL v14 = (uint64_t *)*((void *)this + 8);
  uint64_t v15 = (uint64_t *)*((void *)this + 9);
  while (v14 != v15)
  {
    uint64_t v16 = *v14++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v16 + 32))(v16, a2, "boxes");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210ACDACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::Driver::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(void *)(a1 + 112) != *(void *)(a2 + 112)
    || caulk::xstring::compare((caulk::xstring *)(a1 + 88), (const caulk::xstring *)(a2 + 88)))
  {
    return 0;
  }
  unint64_t v6 = *(void *)(a1 + 104);
  unint64_t v7 = *(void *)(a2 + 104);
  if (v6 && v7)
  {
    if (as::server::HardwareInfo::operator==((_DWORD *)v6, (_DWORD *)v7)) {
      goto LABEL_11;
    }
    return 0;
  }
  if (v6 | v7) {
    return 0;
  }
LABEL_11:
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v8 = *(void *)(a1 + 24);
  unint64_t v10 = (v8 - v9) >> 3;
  if (v10 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3) {
    return 0;
  }
  if (v8 != v9)
  {
    uint64_t v11 = 0;
    if (v10 <= 1) {
      uint64_t v12 = 1;
    }
    else {
      uint64_t v12 = (v8 - v9) >> 3;
    }
    do
    {
      uint64_t v13 = *(void *)(*(void *)(a1 + 16) + 8 * v11);
      uint64_t v14 = *(void *)(*(void *)(a2 + 16) + 8 * v11);
      if (v13) {
        BOOL v15 = v14 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      if (v15)
      {
        if (v13 | v14) {
          return 0;
        }
      }
      else if (!as::server::Device_Clock::operator==(v13, v14))
      {
        return 0;
      }
      ++v11;
    }
    while (v12 != v11);
  }
  uint64_t v17 = *(void *)(a1 + 40);
  uint64_t v16 = *(void *)(a1 + 48);
  unint64_t v18 = (v16 - v17) >> 3;
  if (v18 != (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3) {
    return 0;
  }
  if (v16 != v17)
  {
    uint64_t v19 = 0;
    if (v18 <= 1) {
      uint64_t v20 = 1;
    }
    else {
      uint64_t v20 = (v16 - v17) >> 3;
    }
    do
    {
      uint64_t v21 = *(void *)(*(void *)(a1 + 40) + 8 * v19);
      uint64_t v22 = *(void *)(*(void *)(a2 + 40) + 8 * v19);
      if (v21) {
        BOOL v23 = v22 == 0;
      }
      else {
        BOOL v23 = 1;
      }
      if (v23)
      {
        if (v21 | v22) {
          return 0;
        }
      }
      else if (!as::server::Clock::operator==(v21, v22))
      {
        return 0;
      }
      ++v19;
    }
    while (v20 != v19);
  }
  uint64_t v25 = *(void *)(a1 + 64);
  uint64_t v24 = *(void *)(a1 + 72);
  unint64_t v26 = (v24 - v25) >> 3;
  if (v26 != (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 3) {
    return 0;
  }
  if (v24 == v25)
  {
    return 1;
  }
  else
  {
    BOOL v4 = 0;
    uint64_t v27 = 0;
    if (v26 <= 1) {
      uint64_t v28 = 1;
    }
    else {
      uint64_t v28 = (v24 - v25) >> 3;
    }
    do
    {
      uint64_t v29 = *(void *)(*(void *)(a1 + 64) + 8 * v27);
      uint64_t v30 = *(void *)(*(void *)(a2 + 64) + 8 * v27);
      if (v29) {
        BOOL v31 = v30 == 0;
      }
      else {
        BOOL v31 = 1;
      }
      if (v31)
      {
        if (v29 | v30) {
          return v4;
        }
      }
      else if (!as::server::Box::operator==(v29, v30))
      {
        return v4;
      }
      BOOL v4 = ++v27 >= v26;
    }
    while (v28 != v27);
  }
  return v4;
}

uint64_t as::server::Driver::clearHardwareInfo(as::server::Driver *this)
{
  uint64_t result = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::server::Driver::addDevices(as::server::Driver *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  int v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::Device_Clock>>::__swap_out_circular_buffer(v7, v15);
    unint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *int v5 = 0;
    unint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210ACDE54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::Driver::addClocks(as::server::Driver *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  int v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::Clock>>::__swap_out_circular_buffer(v7, v15);
    unint64_t v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *int v5 = 0;
    unint64_t v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210ACDFC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::Driver::addBoxes(as::server::Driver *this)
{
  unint64_t v4 = *((void *)this + 10);
  unint64_t v2 = (char *)this + 80;
  unint64_t v3 = v4;
  int v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::Box>>::__swap_out_circular_buffer(v7, v15);
    unint64_t v6 = (void *)*((void *)this + 9);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *int v5 = 0;
    unint64_t v6 = v5 + 1;
    *((void *)this + 9) = v6;
  }
  *((void *)this + 9) = v6;
  operator new();
}

void sub_210ACE138(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::HardwareSystemState::default_instance(as::server::HardwareSystemState *this)
{
  {
    operator new();
  }
  return as::server::HardwareSystemState::default_instance(void)::gInstance;
}

void sub_210ACE1E8(_Unwind_Exception *a1)
{
}

double as::server::HardwareSystemState::HardwareSystemState(as::server::HardwareSystemState *this)
{
  *(void *)this = &unk_26C312C90;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312C90;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  return result;
}

as::server::HardwareSystemState *as::server::HardwareSystemState::HardwareSystemState(as::server::HardwareSystemState *this, const as::server::HardwareSystemState *a2)
{
  *(void *)this = &unk_26C312C90;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  as::server::HardwareSystemState::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312C90;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  as::server::HardwareSystemState::copy_from(this, a2);
  return this;
}

void *as::server::HardwareSystemState::copy_from(as::server::HardwareSystemState *this, const as::server::HardwareSystemState *a2)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 1);
  if (*((void *)a2 + 1) != *((void *)a2 + 2)) {
    operator new();
  }
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 4);
  if (*((void *)a2 + 4) != *((void *)a2 + 5)) {
    operator new();
  }
  return result;
}

void sub_210ACE50C(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::HardwareSystemState *as::server::HardwareSystemState::operator=(as::server::HardwareSystemState *a1, const as::server::HardwareSystemState *a2)
{
  return a1;
}

uint64_t as::server::HardwareSystemState::HardwareSystemState(uint64_t a1, void *a2)
{
  *(void *)a1 = &unk_26C312C90;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  as::server::HardwareSystemState::move_from((void *)a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312C90;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  as::server::HardwareSystemState::move_from((void *)a1, a2);
  return a1;
}

void *as::server::HardwareSystemState::move_from(void *result, void *a2)
{
  uint64_t v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  uint64_t v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  uint64_t v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  uint64_t v5 = result[4];
  result[4] = a2[4];
  a2[4] = v5;
  uint64_t v6 = result[5];
  result[5] = a2[5];
  a2[5] = v6;
  uint64_t v7 = result[6];
  result[6] = a2[6];
  a2[6] = v7;
  return result;
}

void *as::server::HardwareSystemState::operator=(void *a1, void *a2)
{
  return a1;
}

void *as::server::HardwareSystemState::clear(as::server::HardwareSystemState *this)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 1);
  return std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 4);
}

uint64_t as::server::HardwareSystemState::isInitialized(as::server::HardwareSystemState *this)
{
  uint64_t v2 = (as::server::Driver **)*((void *)this + 1);
  uint64_t v3 = (as::server::Driver **)*((void *)this + 2);
  while (v2 != v3)
  {
    if (!as::server::Driver::isInitialized(*v2)) {
      return 0;
    }
    ++v2;
  }
  uint64_t v4 = *((void *)this + 4);
  uint64_t v5 = *((void *)this + 5);
  if (v4 == v5) {
    return 1;
  }
  uint64_t v6 = v4 + 8;
  do
  {
    uint64_t result = as::RouteIdentifier::isInitialized(*(as::RouteIdentifier **)(v6 - 8));
    if (result) {
      BOOL v8 = v6 == v5;
    }
    else {
      BOOL v8 = 1;
    }
    v6 += 8;
  }
  while (!v8);
  return result;
}

BOOL as::server::HardwareSystemState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v2 + 1;
        a2[1] = v2 + 1;
        char v11 = *(unsigned char *)(v6 + v2);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v2 = v10;
        if (v8++ > 8) {
          goto LABEL_19;
        }
      }
LABEL_20:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v9 >> 3) == 2) {
        operator new();
      }
      if ((v9 >> 3) == 1) {
        operator new();
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v15 = v2 + 1;
      char v16 = *(unsigned char *)(v6 + v2);
      a2[1] = v15;
      v9 |= (unint64_t)(v16 & 0x7F) << v13;
      if ((v16 & 0x80) == 0) {
        goto LABEL_20;
      }
      v13 += 7;
      unint64_t v2 = v15;
      if (v14++ >= 9)
      {
LABEL_19:
        unint64_t v9 = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210ACEB30(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::HardwareSystemState::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(const PB::Base ***)(this + 8);
  uint64_t v5 = *(const PB::Base ***)(this + 16);
  while (v4 != v5)
  {
    uint64_t v6 = *v4++;
    this = PB::Writer::writeSubmessage(a2, v6);
  }
  unsigned int v8 = *(const PB::Base ***)(v3 + 32);
  char v7 = *(const PB::Base ***)(v3 + 40);
  while (v8 != v7)
  {
    unint64_t v9 = *v8++;
    this = PB::Writer::writeSubmessage(a2, v9);
  }
  return this;
}

uint64_t as::server::HardwareSystemState::formatText(as::server::HardwareSystemState *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = (uint64_t *)*((void *)this + 1);
  uint64_t v6 = (uint64_t *)*((void *)this + 2);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, a2, "drivers");
  }
  unsigned int v8 = (uint64_t *)*((void *)this + 4);
  unint64_t v9 = (uint64_t *)*((void *)this + 5);
  while (v8 != v9)
  {
    uint64_t v10 = *v8++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v10 + 32))(v10, a2, "defaultRoutes");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::HardwareSystemState::operator==(void *a1, void *a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  unint64_t v4 = (v2 - v3) >> 3;
  if (v4 != (uint64_t)(a2[2] - a2[1]) >> 3) {
    return 0;
  }
  if (v2 != v3)
  {
    uint64_t v7 = 0;
    if (v4 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = (v2 - v3) >> 3;
    }
    do
    {
      uint64_t v9 = *(void *)(a1[1] + 8 * v7);
      uint64_t v10 = *(void *)(a2[1] + 8 * v7);
      if (v9) {
        BOOL v11 = v10 == 0;
      }
      else {
        BOOL v11 = 1;
      }
      if (v11)
      {
        if (v9 | v10) {
          return 0;
        }
      }
      else if (!as::server::Driver::operator==(v9, v10))
      {
        return 0;
      }
      ++v7;
    }
    while (v8 != v7);
  }
  uint64_t v13 = a1[4];
  uint64_t v12 = a1[5];
  unint64_t v14 = (v12 - v13) >> 3;
  if (v14 == (uint64_t)(a2[5] - a2[4]) >> 3)
  {
    if (v12 == v13)
    {
      return 1;
    }
    else
    {
      BOOL v15 = 0;
      uint64_t v16 = 0;
      if (v14 <= 1) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = (v12 - v13) >> 3;
      }
      do
      {
        uint64_t v18 = *(void *)(a1[4] + 8 * v16);
        uint64_t v19 = *(void *)(a2[4] + 8 * v16);
        if (v18) {
          BOOL v20 = v19 == 0;
        }
        else {
          BOOL v20 = 1;
        }
        if (v20)
        {
          if (v18 | v19) {
            return v15;
          }
        }
        else if (!as::RouteIdentifier::operator==(v18, v19))
        {
          return v15;
        }
        BOOL v15 = ++v16 >= v14;
      }
      while (v17 != v16);
    }
  }
  else
  {
    return 0;
  }
  return v15;
}

void as::server::HardwareSystemState::addDrivers(as::server::HardwareSystemState *this)
{
  unint64_t v4 = *((void *)this + 3);
  uint64_t v2 = (char *)this + 24;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::Driver>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 2);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 2) = v6;
  }
  *((void *)this + 2) = v6;
  operator new();
}

void sub_210ACEF70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::HardwareSystemState::addDefaultRoutes(as::server::HardwareSystemState *this)
{
  unint64_t v4 = *((void *)this + 6);
  uint64_t v2 = (char *)this + 48;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::RouteIdentifier>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 5);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 5) = v6;
  }
  *((void *)this + 5) = v6;
  operator new();
}

void sub_210ACF0B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::SelectorControlItem::default_instance(as::server::SelectorControlItem *this)
{
  {
    operator new();
  }
  return as::server::SelectorControlItem::default_instance(void)::gInstance;
}

void sub_210ACF15C(_Unwind_Exception *a1)
{
}

uint64_t as::server::SelectorControlItem::SelectorControlItem(uint64_t this)
{
  *(void *)this = &unk_26C312CC8;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 16) = 0;
  return this;
}

{
  *(void *)this = &unk_26C312CC8;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 16) = 0;
  return this;
}

as::server::SelectorControlItem *as::server::SelectorControlItem::SelectorControlItem(as::server::SelectorControlItem *this, const as::server::SelectorControlItem *a2)
{
  *(void *)this = &unk_26C312CC8;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::server::SelectorControlItem::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312CC8;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::server::SelectorControlItem::copy_from(this, a2);
  return this;
}

uint64_t as::server::SelectorControlItem::copy_from(as::server::SelectorControlItem *this, const as::server::SelectorControlItem *a2)
{
  uint64_t result = caulk::xstring::assign((as::server::SelectorControlItem *)((char *)this + 16), (const as::server::SelectorControlItem *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 4) = *((void *)a2 + 4);
  return result;
}

as::server::SelectorControlItem *as::server::SelectorControlItem::operator=(as::server::SelectorControlItem *a1, const as::server::SelectorControlItem *a2)
{
  return a1;
}

void *as::server::SelectorControlItem::SelectorControlItem(void *a1, uint64_t a2)
{
  *a1 = &unk_26C312CC8;
  a1[2] = 0;
  a1[3] = 0;
  as::server::SelectorControlItem::move_from((uint64_t)a1, a2);
  return a1;
}

{
  *a1 = &unk_26C312CC8;
  a1[2] = 0;
  a1[3] = 0;
  as::server::SelectorControlItem::move_from((uint64_t)a1, a2);
  return a1;
}

uint64_t as::server::SelectorControlItem::move_from(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)v5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return result;
}

uint64_t as::server::SelectorControlItem::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::server::SelectorControlItem::clear(as::server::SelectorControlItem *this)
{
  uint64_t result = caulk::xstring::clear((as::server::SelectorControlItem *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 4) = 0;
  return result;
}

BOOL as::server::SelectorControlItem::isInitialized(as::server::SelectorControlItem *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::SelectorControlItem::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *a2;
    if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
      break;
    }
    char v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = v3 + 1;
      a2[1] = v3 + 1;
      char v13 = *(unsigned char *)(v8 + v3);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0) {
        break;
      }
      v9 += 7;
      unint64_t v3 = v12;
      BOOL v14 = v10++ > 8;
      if (v14)
      {
        unint64_t v11 = 0;
        break;
      }
    }
    unint64_t v3 = v12;
LABEL_23:
    if ((v11 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v21 = v11 >> 3;
    if (v21 == 3)
    {
      PB::Reader::read();
      caulk::xstring::assign();
      a1[2] |= 4u;
      unint64_t v3 = a2[1];
      unint64_t v2 = a2[2];
    }
    else
    {
      if (v21 == 2)
      {
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v29 = 0;
          if (v2 <= v3) {
            unint64_t v25 = v3;
          }
          else {
            unint64_t v25 = v2;
          }
          while (v25 != v3)
          {
            unint64_t v37 = v3++;
            char v38 = *(unsigned char *)(v8 + v37);
            a2[1] = v3;
            v29 |= (unint64_t)(v38 & 0x7F) << v35;
            if ((v38 & 0x80) == 0) {
              goto LABEL_59;
            }
            v35 += 7;
            BOOL v20 = v36++ >= 9;
            if (v20)
            {
              LODWORD(v29) = 0;
LABEL_59:
              unint64_t v25 = v37 + 1;
              goto LABEL_63;
            }
          }
          LODWORD(v29) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v29 = 0;
          while (1)
          {
            unint64_t v25 = v3 + 1;
            a2[1] = v3 + 1;
            char v30 = *(unsigned char *)(v8 + v3);
            v29 |= (unint64_t)(v30 & 0x7F) << v27;
            if ((v30 & 0x80) == 0) {
              break;
            }
            v27 += 7;
            unint64_t v3 = v25;
            BOOL v14 = v28++ > 8;
            if (v14)
            {
              LODWORD(v29) = 0;
              break;
            }
          }
        }
LABEL_63:
        a1[9] = v29;
        int v39 = a1[2] | 2;
      }
      else
      {
        if (v21 != 1) {
          goto LABEL_65;
        }
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v31 = 0;
          unsigned int v32 = 0;
          uint64_t v24 = 0;
          if (v2 <= v3) {
            unint64_t v25 = v3;
          }
          else {
            unint64_t v25 = v2;
          }
          while (v25 != v3)
          {
            unint64_t v33 = v3++;
            char v34 = *(unsigned char *)(v8 + v33);
            a2[1] = v3;
            v24 |= (unint64_t)(v34 & 0x7F) << v31;
            if ((v34 & 0x80) == 0) {
              goto LABEL_50;
            }
            v31 += 7;
            BOOL v20 = v32++ >= 9;
            if (v20)
            {
              LODWORD(v24) = 0;
LABEL_50:
              unint64_t v25 = v33 + 1;
              goto LABEL_61;
            }
          }
          LODWORD(v24) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v22 = 0;
          unsigned int v23 = 0;
          uint64_t v24 = 0;
          while (1)
          {
            unint64_t v25 = v3 + 1;
            a2[1] = v3 + 1;
            char v26 = *(unsigned char *)(v8 + v3);
            v24 |= (unint64_t)(v26 & 0x7F) << v22;
            if ((v26 & 0x80) == 0) {
              break;
            }
            v22 += 7;
            unint64_t v3 = v25;
            BOOL v14 = v23++ > 8;
            if (v14)
            {
              LODWORD(v24) = 0;
              break;
            }
          }
        }
LABEL_61:
        a1[8] = v24;
        int v39 = a1[2] | 1;
      }
      a1[2] = v39;
      unint64_t v3 = v25;
    }
LABEL_65:
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
      return v4 == 0;
    }
  }
  char v15 = 0;
  unsigned int v16 = 0;
  unint64_t v11 = 0;
  if (v3 <= v2) {
    unint64_t v17 = v2;
  }
  else {
    unint64_t v17 = v3;
  }
  while (v17 != v3)
  {
    unint64_t v18 = v3++;
    char v19 = *(unsigned char *)(v8 + v18);
    a2[1] = v3;
    v11 |= (unint64_t)(v19 & 0x7F) << v15;
    if ((v19 & 0x80) == 0) {
      goto LABEL_22;
    }
    v15 += 7;
    BOOL v20 = v16++ >= 9;
    if (v20)
    {
      unint64_t v11 = 0;
LABEL_22:
      unint64_t v3 = v18 + 1;
      goto LABEL_23;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_210ACF79C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::server::SelectorControlItem::writeTo(as::server::SelectorControlItem *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        return;
      }
      goto LABEL_7;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::Writer::writeVarInt(a2);
  if ((*((_DWORD *)this + 2) & 4) == 0) {
    return;
  }
LABEL_7:
  uint64_t v5 = (char *)caulk::xstring::c_str((as::server::SelectorControlItem *)((char *)this + 16));
  std::string::basic_string[abi:ne180100]<0>(&__p, v5);
  PB::Writer::write();
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_210ACF85C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::SelectorControlItem::formatText(as::server::SelectorControlItem *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 1) == 0)
  {
    if ((v5 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    PB::TextFormatter::format(a2, "kind");
    if ((*((_DWORD *)this + 2) & 4) == 0) {
      return PB::TextFormatter::endObject(a2);
    }
    goto LABEL_7;
  }
  PB::TextFormatter::format(a2, "ID");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v5 & 4) == 0) {
    return PB::TextFormatter::endObject(a2);
  }
LABEL_7:
  uint64_t v6 = (char *)caulk::xstring::c_str((as::server::SelectorControlItem *)((char *)this + 16));
  std::string::basic_string[abi:ne180100]<0>(&__p, v6);
  PB::TextFormatter::format();
  if (v9 < 0) {
    operator delete(__p);
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210ACF93C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::SelectorControlItem::operator==(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(void *)(a1 + 32) == *(void *)(a2 + 32)
      && caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
}

uint64_t as::server::ControlValue::default_instance(as::server::ControlValue *this)
{
  {
    operator new();
  }
  return as::server::ControlValue::default_instance(void)::gInstance;
}

void sub_210ACFA48(_Unwind_Exception *a1)
{
}

double as::server::ControlValue::ControlValue(as::server::ControlValue *this)
{
  *(void *)this = &unk_26C312910;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312910;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

as::server::ControlValue *as::server::ControlValue::ControlValue(as::server::ControlValue *this, const as::server::ControlValue *a2)
{
  *(void *)this = &unk_26C312910;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  as::server::ControlValue::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312910;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  as::server::ControlValue::copy_from(this, a2);
  return this;
}

__n128 as::server::ControlValue::copy_from(as::server::ControlValue *this, const as::server::ControlValue *a2)
{
  if (this != a2) {
    std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((char *)this + 16, *((char **)a2 + 2), *((void *)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 2);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 40);
  long long v5 = *(_OWORD *)((char *)a2 + 56);
  *((unsigned char *)this + 72) = *((unsigned char *)a2 + 72);
  *(_OWORD *)((char *)this + 56) = v5;
  *(__n128 *)((char *)this + 40) = result;
  return result;
}

as::server::ControlValue *as::server::ControlValue::operator=(as::server::ControlValue *a1, const as::server::ControlValue *a2)
{
  return a1;
}

__n128 as::server::ControlValue::ControlValue(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312910;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v2;
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 40);
  long long v5 = *(_OWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  __n128 result;
  long long v5;

  *(void *)a1 = &unk_26C312910;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v2;
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 40);
  long long v5 = *(_OWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v5;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 as::server::ControlValue::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v6;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 as::server::ControlValue::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v6;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double as::server::ControlValue::clear(as::server::ControlValue *this)
{
  *((void *)this + 3) = *((void *)this + 2);
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((unsigned char *)this + 72) = 0;
  return result;
}

BOOL as::server::ControlValue::isInitialized(as::server::ControlValue *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::ControlValue::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    uint64_t v8 = (void **)(a1 + 16);
    char v9 = (void *)(a1 + 32);
    do
    {
      uint64_t v10 = *a2;
      if (v2 <= 0xFFFFFFFFFFFFFFF5 && v2 + 10 <= v3)
      {
        char v11 = 0;
        unsigned int v12 = 0;
        unint64_t v13 = 0;
        while (1)
        {
          unint64_t v14 = v2 + 1;
          a2[1] = v2 + 1;
          char v15 = *(unsigned char *)(v10 + v2);
          v13 |= (unint64_t)(v15 & 0x7F) << v11;
          if ((v15 & 0x80) == 0) {
            break;
          }
          v11 += 7;
          unint64_t v2 = v14;
          BOOL v44 = v12++ > 8;
          if (v44)
          {
            unint64_t v13 = 0;
            break;
          }
        }
        unint64_t v2 = v14;
        goto LABEL_24;
      }
      char v16 = 0;
      unsigned int v17 = 0;
      unint64_t v13 = 0;
      if (v2 <= v3) {
        unint64_t v18 = v3;
      }
      else {
        unint64_t v18 = v2;
      }
      do
      {
        if (v18 == v2)
        {
          int v4 = 1;
          *((unsigned char *)a2 + 24) = 1;
          return v4 == 0;
        }
        unint64_t v19 = v2++;
        char v20 = *(unsigned char *)(v10 + v19);
        a2[1] = v2;
        v13 |= (unint64_t)(v20 & 0x7F) << v16;
        if ((v20 & 0x80) == 0) {
          goto LABEL_23;
        }
        v16 += 7;
        BOOL v21 = v17++ >= 9;
      }
      while (!v21);
      unint64_t v13 = 0;
LABEL_23:
      unint64_t v2 = v19 + 1;
LABEL_24:
      int v22 = v13 & 7;
      if (v22 == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v23 = v13 >> 3;
      if ((int)v23 <= 20)
      {
        if ((int)v23 <= 9)
        {
          if (v23 == 1)
          {
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              char v66 = 0;
              unsigned int v67 = 0;
              uint64_t v50 = 0;
              if (v3 <= v2) {
                unint64_t v3 = v2;
              }
              while (v3 != v2)
              {
                unint64_t v68 = v2++;
                char v69 = *(unsigned char *)(v10 + v68);
                a2[1] = v2;
                v50 |= (unint64_t)(v69 & 0x7F) << v66;
                if ((v69 & 0x80) == 0) {
                  goto LABEL_134;
                }
                v66 += 7;
                BOOL v21 = v67++ >= 9;
                if (v21)
                {
                  uint64_t v50 = 0;
LABEL_134:
                  unint64_t v3 = v68 + 1;
                  goto LABEL_160;
                }
              }
              uint64_t v50 = 0;
              *((unsigned char *)a2 + 24) = 1;
            }
            else
            {
              char v48 = 0;
              unsigned int v49 = 0;
              uint64_t v50 = 0;
              while (1)
              {
                unint64_t v3 = v2 + 1;
                a2[1] = v2 + 1;
                char v51 = *(unsigned char *)(v10 + v2);
                v50 |= (unint64_t)(v51 & 0x7F) << v48;
                if ((v51 & 0x80) == 0) {
                  break;
                }
                v48 += 7;
                unint64_t v2 = v3;
                BOOL v44 = v49++ > 8;
                if (v44)
                {
                  uint64_t v50 = 0;
                  break;
                }
              }
            }
LABEL_160:
            *(void *)(a1 + 56) = v50;
            int v80 = *(_DWORD *)(a1 + 8) | 1;
          }
          else
          {
            if (v23 != 6) {
              goto LABEL_164;
            }
            if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
            {
              char v58 = 0;
              unsigned int v59 = 0;
              uint64_t v26 = 0;
              if (v3 <= v2) {
                unint64_t v3 = v2;
              }
              while (v3 != v2)
              {
                unint64_t v60 = v2++;
                char v61 = *(unsigned char *)(v10 + v60);
                a2[1] = v2;
                v26 |= (unint64_t)(v61 & 0x7F) << v58;
                if ((v61 & 0x80) == 0) {
                  goto LABEL_120;
                }
                v58 += 7;
                BOOL v21 = v59++ >= 9;
                if (v21)
                {
                  LODWORD(v26) = 0;
LABEL_120:
                  unint64_t v3 = v60 + 1;
                  goto LABEL_158;
                }
              }
              LODWORD(v26) = 0;
              *((unsigned char *)a2 + 24) = 1;
            }
            else
            {
              char v24 = 0;
              unsigned int v25 = 0;
              uint64_t v26 = 0;
              while (1)
              {
                unint64_t v3 = v2 + 1;
                a2[1] = v2 + 1;
                char v27 = *(unsigned char *)(v10 + v2);
                v26 |= (unint64_t)(v27 & 0x7F) << v24;
                if ((v27 & 0x80) == 0) {
                  break;
                }
                v24 += 7;
                unint64_t v2 = v3;
                BOOL v44 = v25++ > 8;
                if (v44)
                {
                  LODWORD(v26) = 0;
                  break;
                }
              }
            }
LABEL_158:
            *(_DWORD *)(a1 + 68) = v26;
            int v80 = *(_DWORD *)(a1 + 8) | 2;
          }
          goto LABEL_163;
        }
        if (v23 == 10)
        {
          if (v2 >= v3)
          {
            BOOL v53 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v52 = *(unsigned __int8 *)(v10 + v2++);
            a2[1] = v2;
            BOOL v53 = v52 != 0;
          }
          *(unsigned char *)(a1 + 72) = v53;
          int v65 = *(_DWORD *)(a1 + 8) | 4;
        }
        else
        {
          if (v23 != 20) {
            goto LABEL_164;
          }
          if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
          {
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            *(_DWORD *)(a1 + 40) = *(_DWORD *)(v10 + v2);
            unint64_t v2 = a2[1] + 4;
            a2[1] = v2;
          }
          int v65 = *(_DWORD *)(a1 + 8) | 8;
        }
LABEL_139:
        *(_DWORD *)(a1 + 8) = v65;
        goto LABEL_164;
      }
      if ((int)v23 > 39)
      {
        if (v23 != 40)
        {
          if (v23 != 50) {
            goto LABEL_164;
          }
          if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
          {
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(v10 + v2);
            unint64_t v2 = a2[1] + 4;
            a2[1] = v2;
          }
          int v65 = *(_DWORD *)(a1 + 8) | 0x40;
          goto LABEL_139;
        }
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          char v70 = 0;
          unsigned int v71 = 0;
          uint64_t v56 = 0;
          if (v3 <= v2) {
            unint64_t v3 = v2;
          }
          while (v3 != v2)
          {
            unint64_t v72 = v2++;
            char v73 = *(unsigned char *)(v10 + v72);
            a2[1] = v2;
            v56 |= (unint64_t)(v73 & 0x7F) << v70;
            if ((v73 & 0x80) == 0) {
              goto LABEL_147;
            }
            v70 += 7;
            BOOL v21 = v71++ >= 9;
            if (v21)
            {
              LODWORD(v56) = 0;
LABEL_147:
              unint64_t v3 = v72 + 1;
              goto LABEL_162;
            }
          }
          LODWORD(v56) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v54 = 0;
          unsigned int v55 = 0;
          uint64_t v56 = 0;
          while (1)
          {
            unint64_t v3 = v2 + 1;
            a2[1] = v2 + 1;
            char v57 = *(unsigned char *)(v10 + v2);
            v56 |= (unint64_t)(v57 & 0x7F) << v54;
            if ((v57 & 0x80) == 0) {
              break;
            }
            v54 += 7;
            unint64_t v2 = v3;
            BOOL v44 = v55++ > 8;
            if (v44)
            {
              LODWORD(v56) = 0;
              break;
            }
          }
        }
LABEL_162:
        *(_DWORD *)(a1 + 64) = v56;
        int v80 = *(_DWORD *)(a1 + 8) | 0x20;
LABEL_163:
        *(_DWORD *)(a1 + 8) = v80;
        unint64_t v2 = v3;
      }
      else
      {
        if (v23 == 21)
        {
          if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
          {
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            *(_DWORD *)(a1 + 44) = *(_DWORD *)(v10 + v2);
            unint64_t v2 = a2[1] + 4;
            a2[1] = v2;
          }
          int v65 = *(_DWORD *)(a1 + 8) | 0x10;
          goto LABEL_139;
        }
        if (v23 != 31) {
          goto LABEL_164;
        }
        if (v22 == 2)
        {
          if (PB::Reader::placeMark()) {
            return 0;
          }
          unint64_t v2 = a2[1];
          if (v2 >= a2[2] || *((unsigned char *)a2 + 24)) {
            goto LABEL_164;
          }
          unsigned int v28 = *(char **)(a1 + 24);
          do
          {
            if ((unint64_t)v28 >= *v9)
            {
              uint64_t v29 = (char *)*v8;
              uint64_t v30 = (v28 - (unsigned char *)*v8) >> 2;
              unint64_t v31 = v30 + 1;
              if ((unint64_t)(v30 + 1) >> 62) {
                goto LABEL_201;
              }
              uint64_t v32 = *v9 - (void)v29;
              if (v32 >> 1 > v31) {
                unint64_t v31 = v32 >> 1;
              }
              if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v33 = v31;
              }
              if (v33)
              {
                char v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v33);
                uint64_t v29 = *(char **)(a1 + 16);
                unsigned int v28 = *(char **)(a1 + 24);
              }
              else
              {
                char v34 = 0;
              }
              char v35 = &v34[4 * v30];
              *(_DWORD *)char v35 = 0;
              unsigned int v36 = v35 + 4;
              while (v28 != v29)
              {
                int v37 = *((_DWORD *)v28 - 1);
                v28 -= 4;
                *((_DWORD *)v35 - 1) = v37;
                v35 -= 4;
              }
              *(void *)(a1 + 16) = v35;
              *(void *)(a1 + 24) = v36;
              *(void *)(a1 + 32) = &v34[4 * v33];
              if (v29) {
                operator delete(v29);
              }
              unsigned int v28 = v36;
            }
            else
            {
              *(_DWORD *)unsigned int v28 = 0;
              v28 += 4;
            }
            *(void *)(a1 + 24) = v28;
            unint64_t v39 = a2[1];
            unint64_t v38 = a2[2];
            uint64_t v40 = *a2;
            char v41 = 0;
            unsigned int v42 = 0;
            uint64_t v43 = 0;
            BOOL v44 = v39 > 0xFFFFFFFFFFFFFFF5 || v39 + 10 > v38;
            if (!v44)
            {
              while (1)
              {
                unint64_t v2 = v39 + 1;
                a2[1] = v39 + 1;
                char v47 = *(unsigned char *)(v40 + v39);
                v43 |= (unint64_t)(v47 & 0x7F) << v41;
                if ((v47 & 0x80) == 0) {
                  goto LABEL_81;
                }
                v41 += 7;
                unint64_t v39 = v2;
                BOOL v44 = v42++ > 8;
                if (v44)
                {
                  LODWORD(v43) = 0;
                  goto LABEL_81;
                }
              }
            }
            if (v38 <= v39) {
              unint64_t v2 = a2[1];
            }
            else {
              unint64_t v2 = a2[2];
            }
            while (1)
            {
              if (v2 == v39)
              {
                *((unsigned char *)a2 + 24) = 1;
                *((_DWORD *)v28 - 1) = 0;
                goto LABEL_164;
              }
              unint64_t v45 = v39++;
              char v46 = *(unsigned char *)(v40 + v45);
              a2[1] = v39;
              v43 |= (unint64_t)(v46 & 0x7F) << v41;
              if ((v46 & 0x80) == 0) {
                break;
              }
              v41 += 7;
              BOOL v44 = v42++ > 8;
              if (v44)
              {
                LODWORD(v43) = 0;
                goto LABEL_80;
              }
            }
            if (*((unsigned char *)a2 + 24)) {
              LODWORD(v43) = 0;
            }
LABEL_80:
            unint64_t v2 = v45 + 1;
LABEL_81:
            *((_DWORD *)v28 - 1) = v43;
          }
          while (v2 < v38 && !*((unsigned char *)a2 + 24));
        }
        else
        {
          unsigned int v63 = *(char **)(a1 + 24);
          unint64_t v62 = *(void *)(a1 + 32);
          if ((unint64_t)v63 >= v62)
          {
            unint64_t v74 = (char *)*v8;
            uint64_t v75 = (v63 - (unsigned char *)*v8) >> 2;
            unint64_t v76 = v75 + 1;
            if ((unint64_t)(v75 + 1) >> 62) {
LABEL_201:
            }
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            uint64_t v77 = v62 - (void)v74;
            if (v77 >> 1 > v76) {
              unint64_t v76 = v77 >> 1;
            }
            if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v78 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v78 = v76;
            }
            if (v78)
            {
              char v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v78);
              unint64_t v74 = *(char **)(a1 + 16);
              unsigned int v63 = *(char **)(a1 + 24);
            }
            else
            {
              char v79 = 0;
            }
            uint64_t v82 = &v79[4 * v75];
            *(_DWORD *)uint64_t v82 = 0;
            uint64_t v64 = v82 + 4;
            while (v63 != v74)
            {
              int v83 = *((_DWORD *)v63 - 1);
              v63 -= 4;
              *((_DWORD *)v82 - 1) = v83;
              v82 -= 4;
            }
            *(void *)(a1 + 16) = v82;
            *(void *)(a1 + 24) = v64;
            *(void *)(a1 + 32) = &v79[4 * v78];
            if (v74) {
              operator delete(v74);
            }
          }
          else
          {
            *(_DWORD *)unsigned int v63 = 0;
            uint64_t v64 = v63 + 4;
          }
          *(void *)(a1 + 24) = v64;
          unint64_t v84 = a2[1];
          unint64_t v2 = a2[2];
          uint64_t v85 = *a2;
          char v86 = 0;
          unsigned int v87 = 0;
          if (v84 > 0xFFFFFFFFFFFFFFF5 || v84 + 10 > v2)
          {
            uint64_t v91 = 0;
            if (v2 <= v84) {
              unint64_t v2 = a2[1];
            }
            while (1)
            {
              if (v2 == v84)
              {
                LODWORD(v91) = 0;
                *((unsigned char *)a2 + 24) = 1;
                goto LABEL_195;
              }
              unint64_t v89 = v84++;
              char v90 = *(unsigned char *)(v85 + v89);
              a2[1] = v84;
              v91 |= (unint64_t)(v90 & 0x7F) << v86;
              if ((v90 & 0x80) == 0) {
                break;
              }
              v86 += 7;
              BOOL v44 = v87++ > 8;
              if (v44)
              {
                LODWORD(v91) = 0;
                goto LABEL_194;
              }
            }
            if (*((unsigned char *)a2 + 24)) {
              LODWORD(v91) = 0;
            }
LABEL_194:
            unint64_t v2 = v89 + 1;
          }
          else
          {
            uint64_t v91 = 0;
            while (1)
            {
              unint64_t v2 = v84 + 1;
              a2[1] = v84 + 1;
              char v92 = *(unsigned char *)(v85 + v84);
              v91 |= (unint64_t)(v92 & 0x7F) << v86;
              if ((v92 & 0x80) == 0) {
                break;
              }
              v86 += 7;
              unint64_t v84 = v2;
              BOOL v44 = v87++ > 8;
              if (v44)
              {
                LODWORD(v91) = 0;
                break;
              }
            }
          }
LABEL_195:
          *(v64 - 1) = v91;
        }
      }
LABEL_164:
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && v4 == 0);
  }
  return v4 == 0;
}

uint64_t as::server::ControlValue::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::writeVarInt(a2);
    int v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_17:
    this = PB::Writer::write(a2, *(float *)(v3 + 40));
    if ((*(_DWORD *)(v3 + 8) & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_16:
  this = PB::Writer::write(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 8) != 0) {
    goto LABEL_17;
  }
LABEL_5:
  if ((v4 & 0x10) != 0) {
LABEL_6:
  }
    this = PB::Writer::write(a2, *(float *)(v3 + 44));
LABEL_7:
  uint64_t v5 = *(void *)(v3 + 16);
  uint64_t v6 = *(void *)(v3 + 24);
  while (v5 != v6)
  {
    v5 += 4;
    this = PB::Writer::writeVarInt(a2);
  }
  int v7 = *(_DWORD *)(v3 + 8);
  if ((v7 & 0x20) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    int v7 = *(_DWORD *)(v3 + 8);
  }
  if ((v7 & 0x40) != 0)
  {
    float v8 = *(float *)(v3 + 48);
    return PB::Writer::write(a2, v8);
  }
  return this;
}

uint64_t as::server::ControlValue::formatText(as::server::ControlValue *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "objectToken");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_18;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "type");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_19;
  }
LABEL_18:
  PB::TextFormatter::format(a2, "BOOLValue");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_19:
  PB::TextFormatter::format(a2, "scalarValue", *((float *)this + 10));
  if ((*((_DWORD *)this + 2) & 0x10) != 0) {
LABEL_6:
  }
    PB::TextFormatter::format(a2, "decibelValue", *((float *)this + 11));
LABEL_7:
  uint64_t v6 = *((void *)this + 2);
  uint64_t v7 = *((void *)this + 3);
  while (v6 != v7)
  {
    v6 += 4;
    PB::TextFormatter::format(a2, "activeSelectorValues");
  }
  int v8 = *((_DWORD *)this + 2);
  if ((v8 & 0x20) != 0)
  {
    PB::TextFormatter::format(a2, "sliderValue");
    int v8 = *((_DWORD *)this + 2);
  }
  if ((v8 & 0x40) != 0) {
    PB::TextFormatter::format(a2, "panValue", *((float *)this + 12));
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::ControlValue::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (memcmp((const void *)(a1 + 40), (const void *)(a2 + 40), 0x21uLL)) {
    return 0;
  }
  int v4 = *(_DWORD **)(a1 + 16);
  int v5 = *(_DWORD **)(a1 + 24);
  unint64_t v6 = v5 - v4;
  uint64_t v7 = *(_DWORD **)(a2 + 16);
  if (v6 != (uint64_t)(*(void *)(a2 + 24) - (void)v7) >> 2) {
    return 0;
  }
  if (v5 == v4) {
    return 1;
  }
  uint64_t v8 = v6 <= 1 ? 1 : v5 - v4;
  if (*v4 != *v7) {
    return 0;
  }
  uint64_t v9 = 1;
  do
  {
    unint64_t v10 = v9;
    if (v8 == v9) {
      break;
    }
    int v11 = v4[v9];
    int v12 = v7[v9++];
  }
  while (v11 == v12);
  return v10 >= v6;
}

uint64_t as::server::Control::default_instance(as::server::Control *this)
{
  {
    operator new();
  }
  return as::server::Control::default_instance(void)::gInstance;
}

void sub_210AD09E0(_Unwind_Exception *a1)
{
}

double as::server::Control::Control(as::server::Control *this)
{
  *(void *)this = &unk_26C312EC0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_WORD *)this + 48) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312EC0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_WORD *)this + 48) = 0;
  return result;
}

as::server::Control *as::server::Control::Control(as::server::Control *this, const as::server::Control *a2)
{
  *(void *)this = &unk_26C312EC0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  as::server::Control::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312EC0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  as::server::Control::copy_from(this, a2);
  return this;
}

__n128 as::server::Control::copy_from(as::server::Control *this, const as::server::Control *a2)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 40);
  long long v5 = *(_OWORD *)((char *)a2 + 56);
  long long v6 = *(_OWORD *)((char *)a2 + 72);
  *(_OWORD *)((char *)this + 82) = *(_OWORD *)((char *)a2 + 82);
  *(_OWORD *)((char *)this + 72) = v6;
  *(_OWORD *)((char *)this + 56) = v5;
  *(__n128 *)((char *)this + 40) = result;
  return result;
}

void sub_210AD0C38(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::Control *as::server::Control::operator=(as::server::Control *a1, const as::server::Control *a2)
{
  return a1;
}

__n128 as::server::Control::Control(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312EC0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v2;
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 40);
  long long v5 = *(_OWORD *)(a2 + 56);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v6;
  *(_OWORD *)(a1 + 56) = v5;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  __n128 result;
  long long v5;
  long long v6;

  *(void *)a1 = &unk_26C312EC0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v2;
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v3;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 40);
  long long v5 = *(_OWORD *)(a2 + 56);
  long long v6 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v6;
  *(_OWORD *)(a1 + 56) = v5;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 as::server::Control::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  long long v7 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 as::server::Control::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  long long v7 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 82) = *(_OWORD *)(a2 + 82);
  *(_OWORD *)(a1 + 72) = v7;
  *(_OWORD *)(a1 + 56) = v6;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

double as::server::Control::clear(as::server::Control *this)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 82) = 0u;
  return result;
}

BOOL as::server::Control::isInitialized(as::server::Control *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *((void *)this + 3);
  if (v1 == v2) {
    return (~*((_DWORD *)this + 2) & 0x3F) == 0;
  }
  while ((~*(_DWORD *)(*(void *)v1 + 8) & 3) == 0)
  {
    v1 += 8;
    if (v1 == v2) {
      return (~*((_DWORD *)this + 2) & 0x3F) == 0;
    }
  }
  return 0;
}

BOOL as::server::Control::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v6 = *a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
      break;
    }
    char v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v10 = v2 + 1;
      a2[1] = v2 + 1;
      char v11 = *(unsigned char *)(v6 + v2);
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0) {
        break;
      }
      v7 += 7;
      unint64_t v2 = v10;
      BOOL v12 = v8++ > 8;
      if (v12)
      {
        unint64_t v9 = 0;
        break;
      }
    }
    unint64_t v2 = v10;
LABEL_23:
    if ((v9 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v19 = v9 >> 3;
    if ((int)v19 <= 22)
    {
      switch((int)v19)
      {
        case 1:
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            char v85 = 0;
            unsigned int v86 = 0;
            uint64_t v22 = 0;
            if (v3 <= v2) {
              unint64_t v3 = v2;
            }
            while (v3 != v2)
            {
              unint64_t v87 = v2++;
              char v88 = *(unsigned char *)(v6 + v87);
              a2[1] = v2;
              v22 |= (unint64_t)(v88 & 0x7F) << v85;
              if ((v88 & 0x80) == 0) {
                goto LABEL_171;
              }
              v85 += 7;
              BOOL v18 = v86++ >= 9;
              if (v18)
              {
                uint64_t v22 = 0;
LABEL_171:
                unint64_t v3 = v87 + 1;
                goto LABEL_204;
              }
            }
            uint64_t v22 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            char v20 = 0;
            unsigned int v21 = 0;
            uint64_t v22 = 0;
            do
            {
              unint64_t v3 = v2 + 1;
              a2[1] = v2 + 1;
              char v23 = *(unsigned char *)(v6 + v2);
              v22 |= (unint64_t)(v23 & 0x7F) << v20;
              if ((v23 & 0x80) == 0) {
                goto LABEL_204;
              }
              v20 += 7;
              unint64_t v2 = v3;
              BOOL v12 = v21++ > 8;
            }
            while (!v12);
            uint64_t v22 = 0;
          }
LABEL_204:
          *(void *)(a1 + 56) = v22;
          int v97 = *(_DWORD *)(a1 + 8) | 1;
          break;
        case 2:
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            char v89 = 0;
            unsigned int v90 = 0;
            uint64_t v54 = 0;
            if (v3 <= v2) {
              unint64_t v3 = v2;
            }
            while (v3 != v2)
            {
              unint64_t v91 = v2++;
              char v92 = *(unsigned char *)(v6 + v91);
              a2[1] = v2;
              v54 |= (unint64_t)(v92 & 0x7F) << v89;
              if ((v92 & 0x80) == 0) {
                goto LABEL_179;
              }
              v89 += 7;
              BOOL v18 = v90++ >= 9;
              if (v18)
              {
                LODWORD(v54) = 0;
LABEL_179:
                unint64_t v3 = v91 + 1;
                goto LABEL_206;
              }
            }
            LODWORD(v54) = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            char v52 = 0;
            unsigned int v53 = 0;
            uint64_t v54 = 0;
            do
            {
              unint64_t v3 = v2 + 1;
              a2[1] = v2 + 1;
              char v55 = *(unsigned char *)(v6 + v2);
              v54 |= (unint64_t)(v55 & 0x7F) << v52;
              if ((v55 & 0x80) == 0) {
                goto LABEL_206;
              }
              v52 += 7;
              unint64_t v2 = v3;
              BOOL v12 = v53++ > 8;
            }
            while (!v12);
            LODWORD(v54) = 0;
          }
LABEL_206:
          *(_DWORD *)(a1 + 64) = v54;
          int v97 = *(_DWORD *)(a1 + 8) | 2;
          break;
        case 3:
          if (v2 >= v3)
          {
            BOOL v45 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v44 = *(unsigned __int8 *)(v6 + v2++);
            a2[1] = v2;
            BOOL v45 = v44 != 0;
          }
          *(unsigned char *)(a1 + 96) = v45;
          int v64 = *(_DWORD *)(a1 + 8) | 4;
          goto LABEL_182;
        case 4:
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            char v81 = 0;
            unsigned int v82 = 0;
            uint64_t v48 = 0;
            if (v3 <= v2) {
              unint64_t v3 = v2;
            }
            while (v3 != v2)
            {
              unint64_t v83 = v2++;
              char v84 = *(unsigned char *)(v6 + v83);
              a2[1] = v2;
              v48 |= (unint64_t)(v84 & 0x7F) << v81;
              if ((v84 & 0x80) == 0) {
                goto LABEL_163;
              }
              v81 += 7;
              BOOL v18 = v82++ >= 9;
              if (v18)
              {
                LODWORD(v48) = 0;
LABEL_163:
                unint64_t v3 = v83 + 1;
                goto LABEL_202;
              }
            }
            LODWORD(v48) = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            char v46 = 0;
            unsigned int v47 = 0;
            uint64_t v48 = 0;
            do
            {
              unint64_t v3 = v2 + 1;
              a2[1] = v2 + 1;
              char v49 = *(unsigned char *)(v6 + v2);
              v48 |= (unint64_t)(v49 & 0x7F) << v46;
              if ((v49 & 0x80) == 0) {
                goto LABEL_202;
              }
              v46 += 7;
              unint64_t v2 = v3;
              BOOL v12 = v47++ > 8;
            }
            while (!v12);
            LODWORD(v48) = 0;
          }
LABEL_202:
          *(_DWORD *)(a1 + 68) = v48;
          int v97 = *(_DWORD *)(a1 + 8) | 8;
          break;
        case 5:
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            char v60 = 0;
            unsigned int v61 = 0;
            uint64_t v34 = 0;
            if (v3 <= v2) {
              unint64_t v3 = v2;
            }
            while (v3 != v2)
            {
              unint64_t v62 = v2++;
              char v63 = *(unsigned char *)(v6 + v62);
              a2[1] = v2;
              v34 |= (unint64_t)(v63 & 0x7F) << v60;
              if ((v63 & 0x80) == 0) {
                goto LABEL_117;
              }
              v60 += 7;
              BOOL v18 = v61++ >= 9;
              if (v18)
              {
                LODWORD(v34) = 0;
LABEL_117:
                unint64_t v3 = v62 + 1;
                goto LABEL_192;
              }
            }
            LODWORD(v34) = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            char v32 = 0;
            unsigned int v33 = 0;
            uint64_t v34 = 0;
            do
            {
              unint64_t v3 = v2 + 1;
              a2[1] = v2 + 1;
              char v35 = *(unsigned char *)(v6 + v2);
              v34 |= (unint64_t)(v35 & 0x7F) << v32;
              if ((v35 & 0x80) == 0) {
                goto LABEL_192;
              }
              v32 += 7;
              unint64_t v2 = v3;
              BOOL v12 = v33++ > 8;
            }
            while (!v12);
            LODWORD(v34) = 0;
          }
LABEL_192:
          *(_DWORD *)(a1 + 72) = v34;
          int v97 = *(_DWORD *)(a1 + 8) | 0x10;
          break;
        case 6:
          if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
          {
            char v93 = 0;
            unsigned int v94 = 0;
            uint64_t v58 = 0;
            if (v3 <= v2) {
              unint64_t v3 = v2;
            }
            while (v3 != v2)
            {
              unint64_t v95 = v2++;
              char v96 = *(unsigned char *)(v6 + v95);
              a2[1] = v2;
              v58 |= (unint64_t)(v96 & 0x7F) << v93;
              if ((v96 & 0x80) == 0) {
                goto LABEL_190;
              }
              v93 += 7;
              BOOL v18 = v94++ >= 9;
              if (v18)
              {
                LODWORD(v58) = 0;
LABEL_190:
                unint64_t v3 = v95 + 1;
                goto LABEL_208;
              }
            }
            LODWORD(v58) = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            char v56 = 0;
            unsigned int v57 = 0;
            uint64_t v58 = 0;
            do
            {
              unint64_t v3 = v2 + 1;
              a2[1] = v2 + 1;
              char v59 = *(unsigned char *)(v6 + v2);
              v58 |= (unint64_t)(v59 & 0x7F) << v56;
              if ((v59 & 0x80) == 0) {
                goto LABEL_208;
              }
              v56 += 7;
              unint64_t v2 = v3;
              BOOL v12 = v57++ > 8;
            }
            while (!v12);
            LODWORD(v58) = 0;
          }
LABEL_208:
          *(_DWORD *)(a1 + 92) = v58;
          int v97 = *(_DWORD *)(a1 + 8) | 0x20;
          break;
        default:
          if (v19 != 22) {
            goto LABEL_210;
          }
          if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > v3)
          {
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            *(void *)(a1 + 40) = *(void *)(v6 + v2);
            unint64_t v2 = a2[1] + 8;
            a2[1] = v2;
          }
          int v64 = *(_DWORD *)(a1 + 8) | 0x40;
          goto LABEL_182;
      }
LABEL_209:
      *(_DWORD *)(a1 + 8) = v97;
      unint64_t v2 = v3;
      goto LABEL_210;
    }
    if ((int)v19 <= 40)
    {
      switch(v19)
      {
        case 0x17:
          if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > v3)
          {
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            *(void *)(a1 + 48) = *(void *)(v6 + v2);
            unint64_t v2 = a2[1] + 8;
            a2[1] = v2;
          }
          int v64 = *(_DWORD *)(a1 + 8) | 0x80;
          break;
        case 0x1E:
          if (v2 >= v3)
          {
            BOOL v51 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v50 = *(unsigned __int8 *)(v6 + v2++);
            a2[1] = v2;
            BOOL v51 = v50 != 0;
          }
          *(unsigned char *)(a1 + 97) = v51;
          int v64 = *(_DWORD *)(a1 + 8) | 0x100;
          break;
        case 0x20:
          operator new();
        default:
          goto LABEL_210;
      }
LABEL_182:
      *(_DWORD *)(a1 + 8) = v64;
    }
    else if ((int)v19 > 50)
    {
      if (v19 == 51)
      {
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          char v69 = 0;
          unsigned int v70 = 0;
          uint64_t v42 = 0;
          if (v3 <= v2) {
            unint64_t v3 = v2;
          }
          while (v3 != v2)
          {
            unint64_t v71 = v2++;
            char v72 = *(unsigned char *)(v6 + v71);
            a2[1] = v2;
            v42 |= (unint64_t)(v72 & 0x7F) << v69;
            if ((v72 & 0x80) == 0) {
              goto LABEL_135;
            }
            v69 += 7;
            BOOL v18 = v70++ >= 9;
            if (v18)
            {
              LODWORD(v42) = 0;
LABEL_135:
              unint64_t v3 = v71 + 1;
              goto LABEL_196;
            }
          }
          LODWORD(v42) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v40 = 0;
          unsigned int v41 = 0;
          uint64_t v42 = 0;
          while (1)
          {
            unint64_t v3 = v2 + 1;
            a2[1] = v2 + 1;
            char v43 = *(unsigned char *)(v6 + v2);
            v42 |= (unint64_t)(v43 & 0x7F) << v40;
            if ((v43 & 0x80) == 0) {
              break;
            }
            v40 += 7;
            unint64_t v2 = v3;
            BOOL v12 = v41++ > 8;
            if (v12)
            {
              LODWORD(v42) = 0;
              break;
            }
          }
        }
LABEL_196:
        *(_DWORD *)(a1 + 84) = v42;
        int v97 = *(_DWORD *)(a1 + 8) | 0x800;
        goto LABEL_209;
      }
      if (v19 == 52)
      {
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          char v77 = 0;
          unsigned int v78 = 0;
          uint64_t v30 = 0;
          if (v3 <= v2) {
            unint64_t v3 = v2;
          }
          while (v3 != v2)
          {
            unint64_t v79 = v2++;
            char v80 = *(unsigned char *)(v6 + v79);
            a2[1] = v2;
            v30 |= (unint64_t)(v80 & 0x7F) << v77;
            if ((v80 & 0x80) == 0) {
              goto LABEL_155;
            }
            v77 += 7;
            BOOL v18 = v78++ >= 9;
            if (v18)
            {
              LODWORD(v30) = 0;
LABEL_155:
              unint64_t v3 = v79 + 1;
              goto LABEL_200;
            }
          }
          LODWORD(v30) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v28 = 0;
          unsigned int v29 = 0;
          uint64_t v30 = 0;
          while (1)
          {
            unint64_t v3 = v2 + 1;
            a2[1] = v2 + 1;
            char v31 = *(unsigned char *)(v6 + v2);
            v30 |= (unint64_t)(v31 & 0x7F) << v28;
            if ((v31 & 0x80) == 0) {
              break;
            }
            v28 += 7;
            unint64_t v2 = v3;
            BOOL v12 = v29++ > 8;
            if (v12)
            {
              LODWORD(v30) = 0;
              break;
            }
          }
        }
LABEL_200:
        *(_DWORD *)(a1 + 88) = v30;
        int v97 = *(_DWORD *)(a1 + 8) | 0x1000;
        goto LABEL_209;
      }
    }
    else
    {
      if (v19 == 41)
      {
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          char v65 = 0;
          unsigned int v66 = 0;
          uint64_t v38 = 0;
          if (v3 <= v2) {
            unint64_t v3 = v2;
          }
          while (v3 != v2)
          {
            unint64_t v67 = v2++;
            char v68 = *(unsigned char *)(v6 + v67);
            a2[1] = v2;
            v38 |= (unint64_t)(v68 & 0x7F) << v65;
            if ((v68 & 0x80) == 0) {
              goto LABEL_127;
            }
            v65 += 7;
            BOOL v18 = v66++ >= 9;
            if (v18)
            {
              LODWORD(v38) = 0;
LABEL_127:
              unint64_t v3 = v67 + 1;
              goto LABEL_194;
            }
          }
          LODWORD(v38) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v36 = 0;
          unsigned int v37 = 0;
          uint64_t v38 = 0;
          while (1)
          {
            unint64_t v3 = v2 + 1;
            a2[1] = v2 + 1;
            char v39 = *(unsigned char *)(v6 + v2);
            v38 |= (unint64_t)(v39 & 0x7F) << v36;
            if ((v39 & 0x80) == 0) {
              break;
            }
            v36 += 7;
            unint64_t v2 = v3;
            BOOL v12 = v37++ > 8;
            if (v12)
            {
              LODWORD(v38) = 0;
              break;
            }
          }
        }
LABEL_194:
        *(_DWORD *)(a1 + 76) = v38;
        int v97 = *(_DWORD *)(a1 + 8) | 0x200;
        goto LABEL_209;
      }
      if (v19 == 42)
      {
        if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
        {
          char v73 = 0;
          unsigned int v74 = 0;
          uint64_t v26 = 0;
          if (v3 <= v2) {
            unint64_t v3 = v2;
          }
          while (v3 != v2)
          {
            unint64_t v75 = v2++;
            char v76 = *(unsigned char *)(v6 + v75);
            a2[1] = v2;
            v26 |= (unint64_t)(v76 & 0x7F) << v73;
            if ((v76 & 0x80) == 0) {
              goto LABEL_147;
            }
            v73 += 7;
            BOOL v18 = v74++ >= 9;
            if (v18)
            {
              LODWORD(v26) = 0;
LABEL_147:
              unint64_t v3 = v75 + 1;
              goto LABEL_198;
            }
          }
          LODWORD(v26) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v24 = 0;
          unsigned int v25 = 0;
          uint64_t v26 = 0;
          while (1)
          {
            unint64_t v3 = v2 + 1;
            a2[1] = v2 + 1;
            char v27 = *(unsigned char *)(v6 + v2);
            v26 |= (unint64_t)(v27 & 0x7F) << v24;
            if ((v27 & 0x80) == 0) {
              break;
            }
            v24 += 7;
            unint64_t v2 = v3;
            BOOL v12 = v25++ > 8;
            if (v12)
            {
              LODWORD(v26) = 0;
              break;
            }
          }
        }
LABEL_198:
        *(_DWORD *)(a1 + 80) = v26;
        int v97 = *(_DWORD *)(a1 + 8) | 0x400;
        goto LABEL_209;
      }
    }
LABEL_210:
    unint64_t v3 = a2[2];
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  char v13 = 0;
  unsigned int v14 = 0;
  unint64_t v9 = 0;
  if (v2 <= v3) {
    unint64_t v15 = v3;
  }
  else {
    unint64_t v15 = v2;
  }
  while (v15 != v2)
  {
    unint64_t v16 = v2++;
    char v17 = *(unsigned char *)(v6 + v16);
    a2[1] = v2;
    v9 |= (unint64_t)(v17 & 0x7F) << v13;
    if ((v17 & 0x80) == 0) {
      goto LABEL_22;
    }
    v13 += 7;
    BOOL v18 = v14++ >= 9;
    if (v18)
    {
      unint64_t v9 = 0;
LABEL_22:
      unint64_t v2 = v16 + 1;
      goto LABEL_23;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_210AD1A7C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::Control::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::writeVarInt(a2);
    int v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_21;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_22;
  }
LABEL_21:
  this = PB::Writer::write(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_23;
  }
LABEL_22:
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_24;
  }
LABEL_23:
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_25;
  }
LABEL_24:
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x40) == 0)
  {
LABEL_8:
    if ((v4 & 0x80) == 0) {
      goto LABEL_9;
    }
LABEL_26:
    this = PB::Writer::write(a2, *(double *)(v3 + 48));
    if ((*(_DWORD *)(v3 + 8) & 0x100) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
LABEL_25:
  this = PB::Writer::write(a2, *(double *)(v3 + 40));
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x80) != 0) {
    goto LABEL_26;
  }
LABEL_9:
  if ((v4 & 0x100) != 0) {
LABEL_10:
  }
    this = PB::Writer::write(a2);
LABEL_11:
  long long v5 = *(const PB::Base ***)(v3 + 16);
  uint64_t v6 = *(const PB::Base ***)(v3 + 24);
  while (v5 != v6)
  {
    char v7 = *v5++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  int v8 = *(_DWORD *)(v3 + 8);
  if ((v8 & 0x200) != 0)
  {
    this = PB::Writer::writeVarInt(a2);
    int v8 = *(_DWORD *)(v3 + 8);
    if ((v8 & 0x400) == 0)
    {
LABEL_16:
      if ((v8 & 0x800) == 0) {
        goto LABEL_17;
      }
LABEL_30:
      this = PB::Writer::writeVarInt(a2);
      if ((*(_DWORD *)(v3 + 8) & 0x1000) == 0) {
        return this;
      }
      goto LABEL_31;
    }
  }
  else if ((v8 & 0x400) == 0)
  {
    goto LABEL_16;
  }
  this = PB::Writer::writeVarInt(a2);
  int v8 = *(_DWORD *)(v3 + 8);
  if ((v8 & 0x800) != 0) {
    goto LABEL_30;
  }
LABEL_17:
  if ((v8 & 0x1000) == 0) {
    return this;
  }
LABEL_31:
  return PB::Writer::writeVarInt(a2);
}

uint64_t as::server::Control::formatText(as::server::Control *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "objectToken");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_23;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "classID");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_24;
  }
LABEL_23:
  PB::TextFormatter::format(a2, "settable");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_25;
  }
LABEL_24:
  PB::TextFormatter::format(a2, "scope");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_26;
  }
LABEL_25:
  PB::TextFormatter::format(a2, "element");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_27;
  }
LABEL_26:
  PB::TextFormatter::format(a2, "type");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x40) == 0)
  {
LABEL_8:
    if ((v5 & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_28;
  }
LABEL_27:
  PB::TextFormatter::format(a2, "decibelMinimum", *((double *)this + 5));
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x80) == 0)
  {
LABEL_9:
    if ((v5 & 0x100) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
LABEL_28:
  PB::TextFormatter::format(a2, "decibelMaximum", *((double *)this + 6));
  if ((*((_DWORD *)this + 2) & 0x100) != 0) {
LABEL_10:
  }
    PB::TextFormatter::format(a2, "isMultiValue");
LABEL_11:
  uint64_t v6 = (uint64_t *)*((void *)this + 2);
  char v7 = (uint64_t *)*((void *)this + 3);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "supportedSelectorValues");
  }
  int v9 = *((_DWORD *)this + 2);
  if ((v9 & 0x200) != 0)
  {
    PB::TextFormatter::format(a2, "sliderMinimum");
    int v9 = *((_DWORD *)this + 2);
    if ((v9 & 0x400) == 0)
    {
LABEL_15:
      if ((v9 & 0x800) == 0) {
        goto LABEL_16;
      }
      goto LABEL_32;
    }
  }
  else if ((v9 & 0x400) == 0)
  {
    goto LABEL_15;
  }
  PB::TextFormatter::format(a2, "sliderMaximum");
  int v9 = *((_DWORD *)this + 2);
  if ((v9 & 0x800) == 0)
  {
LABEL_16:
    if ((v9 & 0x1000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_32:
  PB::TextFormatter::format(a2, "panLeftChannel");
  if ((*((_DWORD *)this + 2) & 0x1000) != 0) {
LABEL_17:
  }
    PB::TextFormatter::format(a2, "panRightChannel");
LABEL_18:
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::Control::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && !memcmp((const void *)(a1 + 40), (const void *)(a2 + 40), 0x3AuLL)
    && (uint64_t v5 = *(void *)(a1 + 16),
        uint64_t v4 = *(void *)(a1 + 24),
        unint64_t v6 = (v4 - v5) >> 3,
        v6 == (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3))
  {
    if (v4 == v5)
    {
      return 1;
    }
    else
    {
      BOOL v7 = 0;
      uint64_t v8 = 0;
      if (v6 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = (v4 - v5) >> 3;
      }
      do
      {
        uint64_t v10 = *(void *)(*(void *)(a1 + 16) + 8 * v8);
        uint64_t v11 = *(void *)(*(void *)(a2 + 16) + 8 * v8);
        if (v10) {
          BOOL v12 = v11 == 0;
        }
        else {
          BOOL v12 = 1;
        }
        if (v12)
        {
          if (v10 | v11) {
            return v7;
          }
        }
        else if (!as::server::SelectorControlItem::operator==(v10, v11))
        {
          return v7;
        }
        BOOL v7 = ++v8 >= v6;
      }
      while (v9 != v8);
    }
  }
  else
  {
    return 0;
  }
  return v7;
}

void as::server::Control::addSupportedSelectorValues(as::server::Control *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    BOOL v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      char v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      char v13 = 0;
    }
    unsigned int v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unsigned int v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::SelectorControlItem>>::__swap_out_circular_buffer(v7, v15);
    unint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    unint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210AD2120(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::ControlAndValue::default_instance(as::server::ControlAndValue *this)
{
  {
    operator new();
  }
  return as::server::ControlAndValue::default_instance(void)::gInstance;
}

void sub_210AD21C4(_Unwind_Exception *a1)
{
}

void *as::server::ControlAndValue::ControlAndValue(void *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312A60;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312A60;
  return this;
}

double as::server::ControlAndValue::copy_from(as::server::ControlAndValue *this, const as::server::ControlAndValue *a2)
{
  unint64_t v4 = (const as::server::Control *)*((void *)a2 + 1);
  if (v4)
  {
    uint64_t v5 = (as::server::Control *)as::server::ControlAndValue::mutableControl(this);
    *(void *)&double result = as::server::Control::copy_from(v5, v4).n128_u64[0];
  }
  BOOL v7 = (const as::server::ControlValue *)*((void *)a2 + 2);
  if (v7)
  {
    uint64_t v8 = (as::server::ControlValue *)as::server::ControlAndValue::mutableValue(this);
    *(void *)&double result = as::server::ControlValue::copy_from(v8, v7).n128_u64[0];
  }
  return result;
}

as::server::ControlAndValue *as::server::ControlAndValue::operator=(as::server::ControlAndValue *a1, const as::server::ControlAndValue *a2)
{
  return a1;
}

uint64_t as::server::ControlAndValue::control(as::server::ControlAndValue *this)
{
  uint64_t result = *((void *)this + 1);
  if (!result) {
    return as::server::Control::default_instance(0);
  }
  return result;
}

uint64_t as::server::ControlAndValue::mutableControl(as::server::ControlAndValue *this)
{
  if (!*((void *)this + 1)) {
    operator new();
  }
  return *((void *)this + 1);
}

uint64_t as::server::ControlAndValue::value(as::server::ControlAndValue *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return as::server::ControlValue::default_instance(0);
  }
  return result;
}

uint64_t as::server::ControlAndValue::mutableValue(as::server::ControlAndValue *this)
{
  if (!*((void *)this + 2)) {
    operator new();
  }
  return *((void *)this + 2);
}

void *as::server::ControlAndValue::ControlAndValue(void *result, uint64_t a2)
{
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C312A60;
  result[1] = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = result[2];
  result[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  return result;
}

{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C312A60;
  result[1] = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = result[2];
  result[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  return result;
}

uint64_t as::server::ControlAndValue::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::ControlAndValue::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::ControlAndValue::clear(as::server::ControlAndValue *this)
{
  uint64_t v2 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result)
  {
    unint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v4();
  }
  return result;
}

BOOL as::server::ControlAndValue::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v2 + 1;
        a2[1] = v2 + 1;
        char v11 = *(unsigned char *)(v6 + v2);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v2 = v10;
        if (v8++ > 8) {
          goto LABEL_19;
        }
      }
LABEL_20:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v9 >> 3) == 2) {
        operator new();
      }
      if ((v9 >> 3) == 1) {
        operator new();
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v15 = v2 + 1;
      char v16 = *(unsigned char *)(v6 + v2);
      a2[1] = v15;
      v9 |= (unint64_t)(v16 & 0x7F) << v13;
      if ((v16 & 0x80) == 0) {
        goto LABEL_20;
      }
      v13 += 7;
      unint64_t v2 = v15;
      if (v14++ >= 9)
      {
LABEL_19:
        unint64_t v9 = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::ControlAndValue::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(const PB::Base **)(this + 8);
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  uint64_t v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
  {
    return PB::Writer::writeSubmessage(a2, v5);
  }
  return this;
}

uint64_t as::server::ControlAndValue::formatText(as::server::ControlAndValue *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 1);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "control");
  }
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, a2, "value");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::ControlAndValue::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (as::server::Control::operator==(v4, v5)) {
      goto LABEL_9;
    }
    return 0;
  }
  if (v4 | v5) {
    return 0;
  }
LABEL_9:
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(a2 + 16);
  BOOL result = (v8 | v9) == 0;
  if (v8 && v9)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    return as::server::ControlValue::operator==(v10, v9);
  }
  return result;
}

uint64_t as::server::ControlAndValue::clearControl(as::server::ControlAndValue *this)
{
  uint64_t result = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::ControlAndValue::clearValue(as::server::ControlAndValue *this)
{
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::IOStreamState::default_instance(as::server::IOStreamState *this)
{
  {
    operator new();
  }
  return as::server::IOStreamState::default_instance(void)::gInstance;
}

void sub_210AD2B3C(_Unwind_Exception *a1)
{
}

double as::server::IOStreamState::IOStreamState(as::server::IOStreamState *this)
{
  *(void *)this = &unk_26C3129F0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C3129F0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_DWORD *)this + 20) = 0;
  return result;
}

as::server::IOStreamState *as::server::IOStreamState::IOStreamState(as::server::IOStreamState *this, const as::server::IOStreamState *a2)
{
  *(void *)this = &unk_26C3129F0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  as::server::IOStreamState::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3129F0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  as::server::IOStreamState::copy_from(this, a2);
  return this;
}

void *as::server::IOStreamState::copy_from(as::server::IOStreamState *this, const as::server::IOStreamState *a2)
{
  uint64_t v4 = (const as::StreamFormat *)*((void *)a2 + 8);
  if (v4)
  {
    uint64_t v5 = (as::StreamFormat *)as::server::IOStreamState::mutableStreamFormat(this);
    as::StreamFormat::operator=(v5, v4);
  }
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    operator new();
  }
  if (this != a2) {
    double result = std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 16, *((caulk::xstring **)a2 + 2), *((caulk::xstring **)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 4);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  uint64_t v7 = *((void *)a2 + 9);
  *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
  *((void *)this + 9) = v7;
  return result;
}

void sub_210AD2D98(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::IOStreamState *as::server::IOStreamState::operator=(as::server::IOStreamState *a1, const as::server::IOStreamState *a2)
{
  return a1;
}

uint64_t as::server::IOStreamState::streamFormat(as::server::IOStreamState *this)
{
  uint64_t result = *((void *)this + 8);
  if (!result) {
    return as::StreamFormat::default_instance(0);
  }
  return result;
}

uint64_t as::server::IOStreamState::mutableStreamFormat(as::server::IOStreamState *this)
{
  if (!*((void *)this + 8)) {
    operator new();
  }
  return *((void *)this + 8);
}

uint64_t as::server::IOStreamState::IOStreamState(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C3129F0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 64) = 0;
  as::server::IOStreamState::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C3129F0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 64) = 0;
  as::server::IOStreamState::move_from(a1, a2);
  return a1;
}

uint64_t as::server::IOStreamState::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 64);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v2;
  uint64_t v3 = *(void *)(result + 40);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v3;
  uint64_t v4 = *(void *)(result + 48);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v4;
  uint64_t v5 = *(void *)(result + 56);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v5;
  uint64_t v6 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v6;
  uint64_t v7 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v7;
  uint64_t v8 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v8;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v9 = *(void *)(a2 + 72);
  *(_DWORD *)(result + 80) = *(_DWORD *)(a2 + 80);
  *(void *)(result + 72) = v9;
  return result;
}

uint64_t as::server::IOStreamState::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::server::IOStreamState::clear(as::server::IOStreamState *this)
{
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  uint64_t v4 = (caulk::xstring *)*((void *)this + 2);
  uint64_t v3 = (char *)this + 16;
  uint64_t result = std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v3, v4);
  *((_DWORD *)v3 - 2) = 0;
  *((void *)v3 + 7) = 0;
  *((_DWORD *)v3 + 16) = 0;
  return result;
}

uint64_t as::server::IOStreamState::isInitialized(as::server::IOStreamState *this)
{
  uint64_t result = *((void *)this + 8);
  if (result)
  {
    uint64_t result = as::StreamFormat::isInitialized((as::StreamFormat *)result);
    if (result)
    {
      uint64_t v3 = (as::AvailableStreamFormat **)*((void *)this + 5);
      uint64_t v4 = (as::AvailableStreamFormat **)*((void *)this + 6);
      while (1)
      {
        if (v3 == v4) {
          return (~*((_DWORD *)this + 2) & 5) == 0;
        }
        if ((as::AvailableStreamFormat::isInitialized(*v3) & 1) == 0) {
          break;
        }
        ++v3;
      }
      return 0;
    }
  }
  return result;
}

BOOL as::server::IOStreamState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    uint64_t v8 = (uint64_t *)(a1 + 16);
    uint64_t v9 = a1 + 32;
    while (2)
    {
      uint64_t v10 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        unint64_t v13 = 0;
        if (v3 <= v2) {
          unint64_t v19 = v2;
        }
        else {
          unint64_t v19 = v3;
        }
        while (v19 != v3)
        {
          unint64_t v20 = v3++;
          char v21 = *(unsigned char *)(v10 + v20);
          a2[1] = v3;
          v13 |= (unint64_t)(v21 & 0x7F) << v17;
          if ((v21 & 0x80) == 0) {
            goto LABEL_22;
          }
          v17 += 7;
          BOOL v22 = v18++ >= 9;
          if (v22)
          {
            unint64_t v13 = 0;
LABEL_22:
            unint64_t v14 = v20 + 1;
            goto LABEL_23;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v11 = 0;
        unsigned int v12 = 0;
        unint64_t v13 = 0;
        while (1)
        {
          unint64_t v14 = v3 + 1;
          a2[1] = v3 + 1;
          char v15 = *(unsigned char *)(v10 + v3);
          v13 |= (unint64_t)(v15 & 0x7F) << v11;
          if ((v15 & 0x80) == 0) {
            break;
          }
          v11 += 7;
          unint64_t v3 = v14;
          BOOL v16 = v12++ > 8;
          if (v16)
          {
            unint64_t v13 = 0;
            break;
          }
        }
LABEL_23:
        if ((v13 & 7) != 4)
        {
          switch((v13 >> 3))
          {
            case 1u:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v23 = 0;
                unsigned int v24 = 0;
                uint64_t v25 = 0;
                do
                {
                  unint64_t v26 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v27 = *(unsigned char *)(v10 + v14);
                  v25 |= (unint64_t)(v27 & 0x7F) << v23;
                  if ((v27 & 0x80) == 0) {
                    goto LABEL_84;
                  }
                  v23 += 7;
                  unint64_t v14 = v26;
                  BOOL v16 = v24++ > 8;
                }
                while (!v16);
LABEL_64:
                LODWORD(v25) = 0;
                goto LABEL_84;
              }
              char v46 = 0;
              unsigned int v47 = 0;
              uint64_t v25 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v48 = v14 + 1;
                char v49 = *(unsigned char *)(v10 + v14);
                a2[1] = v48;
                v25 |= (unint64_t)(v49 & 0x7F) << v46;
                if ((v49 & 0x80) == 0) {
                  goto LABEL_84;
                }
                v46 += 7;
                unint64_t v14 = v48;
                BOOL v22 = v47++ >= 9;
                if (v22) {
                  goto LABEL_64;
                }
              }
              LODWORD(v25) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_84:
              *(_DWORD *)(a1 + 72) = v25;
              int v59 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_89;
            case 2u:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v31 = 0;
                unsigned int v32 = 0;
                uint64_t v33 = 0;
                do
                {
                  unint64_t v34 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v35 = *(unsigned char *)(v10 + v14);
                  v33 |= (unint64_t)(v35 & 0x7F) << v31;
                  if ((v35 & 0x80) == 0) {
                    goto LABEL_86;
                  }
                  v31 += 7;
                  unint64_t v14 = v34;
                  BOOL v16 = v32++ > 8;
                }
                while (!v16);
LABEL_71:
                LODWORD(v33) = 0;
                goto LABEL_86;
              }
              char v50 = 0;
              unsigned int v51 = 0;
              uint64_t v33 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v52 = v14 + 1;
                char v53 = *(unsigned char *)(v10 + v14);
                a2[1] = v52;
                v33 |= (unint64_t)(v53 & 0x7F) << v50;
                if ((v53 & 0x80) == 0) {
                  goto LABEL_86;
                }
                v50 += 7;
                unint64_t v14 = v52;
                BOOL v22 = v51++ >= 9;
                if (v22) {
                  goto LABEL_71;
                }
              }
              LODWORD(v33) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_86:
              *(_DWORD *)(a1 + 76) = v33;
              int v59 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_89;
            case 3u:
              operator new();
            case 4u:
              operator new();
            case 5u:
              unsigned int v29 = *(void **)(a1 + 24);
              unint64_t v28 = *(void *)(a1 + 32);
              if ((unint64_t)v29 >= v28)
              {
                uint64_t v41 = ((uint64_t)v29 - *v8) >> 4;
                unint64_t v42 = v41 + 1;
                if ((unint64_t)(v41 + 1) >> 60) {
                  std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v43 = v28 - *v8;
                if (v43 >> 3 > v42) {
                  unint64_t v42 = v43 >> 3;
                }
                if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v44 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v44 = v42;
                }
                uint64_t v66 = v9;
                if (v44) {
                  BOOL v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v44);
                }
                else {
                  BOOL v45 = 0;
                }
                uint64_t v58 = &v45[16 * v41];
                std::string __p = v45;
                char v63 = v58;
                char v65 = &v45[16 * v44];
                *(void *)uint64_t v58 = 0;
                *((void *)v58 + 1) = 0;
                int v64 = v58 + 16;
                std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
                uint64_t v30 = *(void **)(a1 + 24);
                std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
              }
              else
              {
                *unsigned int v29 = 0;
                v29[1] = 0;
                uint64_t v30 = v29 + 2;
                *(void *)(a1 + 24) = v29 + 2;
              }
              *(void *)(a1 + 24) = v30;
              std::string __p = 0;
              char v63 = 0;
              int v64 = 0;
              PB::Reader::read();
              caulk::xstring::assign();
              if (SHIBYTE(v64) < 0) {
                operator delete(__p);
              }
              goto LABEL_90;
            case 6u:
              if (v14 <= 0xFFFFFFFFFFFFFFF5 && v14 + 10 <= v2)
              {
                char v36 = 0;
                unsigned int v37 = 0;
                uint64_t v38 = 0;
                do
                {
                  unint64_t v39 = v14 + 1;
                  a2[1] = v14 + 1;
                  char v40 = *(unsigned char *)(v10 + v14);
                  v38 |= (unint64_t)(v40 & 0x7F) << v36;
                  if ((v40 & 0x80) == 0) {
                    goto LABEL_88;
                  }
                  v36 += 7;
                  unint64_t v14 = v39;
                  BOOL v16 = v37++ > 8;
                }
                while (!v16);
LABEL_78:
                LODWORD(v38) = 0;
                goto LABEL_88;
              }
              char v54 = 0;
              unsigned int v55 = 0;
              uint64_t v38 = 0;
              if (v2 <= v14) {
                unint64_t v2 = v14;
              }
              while (v2 != v14)
              {
                unint64_t v56 = v14 + 1;
                char v57 = *(unsigned char *)(v10 + v14);
                a2[1] = v56;
                v38 |= (unint64_t)(v57 & 0x7F) << v54;
                if ((v57 & 0x80) == 0) {
                  goto LABEL_88;
                }
                v54 += 7;
                unint64_t v14 = v56;
                BOOL v22 = v55++ >= 9;
                if (v22) {
                  goto LABEL_78;
                }
              }
              LODWORD(v38) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_88:
              *(_DWORD *)(a1 + 80) = v38;
              int v59 = *(_DWORD *)(a1 + 8) | 4;
LABEL_89:
              *(_DWORD *)(a1 + 8) = v59;
LABEL_90:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            default:
              goto LABEL_90;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AD3794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::server::IOStreamState::writeTo(as::server::IOStreamState *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  uint64_t v5 = (const PB::Base *)*((void *)this + 8);
  if (v5) {
    PB::Writer::writeSubmessage(a2, v5);
  }
  uint64_t v6 = (const PB::Base **)*((void *)this + 5);
  uint64_t v7 = (const PB::Base **)*((void *)this + 6);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    PB::Writer::writeSubmessage(a2, v8);
  }
  uint64_t v9 = (caulk::xstring *)*((void *)this + 2);
  uint64_t v10 = (caulk::xstring *)*((void *)this + 3);
  while (v9 != v10)
  {
    char v11 = (char *)caulk::xstring::c_str(v9);
    std::string::basic_string[abi:ne180100]<0>(&__p, v11);
    PB::Writer::write();
    if (v13 < 0) {
      operator delete(__p);
    }
    uint64_t v9 = (caulk::xstring *)((char *)v9 + 16);
  }
  if ((*((unsigned char *)this + 8) & 4) != 0) {
    PB::Writer::writeVarInt(a2);
  }
}

void sub_210AD3914(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::IOStreamState::formatText(as::server::IOStreamState *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "streamToken");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "DSPFlavor");
  }
  uint64_t v6 = *((void *)this + 8);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, a2, "streamFormat");
  }
  uint64_t v7 = (uint64_t *)*((void *)this + 5);
  uint64_t v8 = (uint64_t *)*((void *)this + 6);
  while (v7 != v8)
  {
    uint64_t v9 = *v7++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, a2, "availableFormats");
  }
  uint64_t v10 = (caulk::xstring *)*((void *)this + 2);
  for (uint64_t i = (caulk::xstring *)*((void *)this + 3); v10 != i; v10 = (caulk::xstring *)((char *)v10 + 16))
  {
    unsigned int v12 = (char *)caulk::xstring::c_str(v10);
    std::string::basic_string[abi:ne180100]<0>(&__p, v12);
    PB::TextFormatter::format();
    if (v15 < 0) {
      operator delete(__p);
    }
  }
  if ((*((unsigned char *)this + 8) & 4) != 0) {
    PB::TextFormatter::format(a2, "latency");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AD3AAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::IOStreamState::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (*(void *)(a1 + 72) != *(void *)(a2 + 72)
    || *(_DWORD *)(a1 + 80) != (unint64_t)*(unsigned int *)(a2 + 80))
  {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = *(void *)(a2 + 64);
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    if (v6 | v7) {
      return 0;
    }
  }
  else if (!as::StreamFormat::operator==(v6, v7))
  {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  unint64_t v11 = (v9 - v10) >> 3;
  if (v11 != (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3) {
    return 0;
  }
  if (v9 != v10)
  {
    uint64_t v12 = 0;
    if (v11 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = (v9 - v10) >> 3;
    }
    do
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8 * v12);
      uint64_t v15 = *(void *)(*(void *)(a2 + 40) + 8 * v12);
      if (v14) {
        BOOL v16 = v15 == 0;
      }
      else {
        BOOL v16 = 1;
      }
      if (v16)
      {
        if (v14 | v15) {
          return 0;
        }
      }
      else if (!as::AvailableStreamFormat::operator==(v14, v15))
      {
        return 0;
      }
      ++v12;
    }
    while (v13 != v12);
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  unint64_t v19 = (v17 - v18) >> 4;
  if (v19 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 4) {
    return 0;
  }
  if (v17 == v18) {
    return 1;
  }
  if (v19 <= 1) {
    uint64_t v20 = 1;
  }
  else {
    uint64_t v20 = (v17 - v18) >> 4;
  }
  if (caulk::xstring::compare(*(caulk::xstring **)(a1 + 16), *(const caulk::xstring **)(a2 + 16))) {
    return 0;
  }
  uint64_t v21 = 1;
  uint64_t v22 = 16;
  do
  {
    unint64_t v23 = v21;
    if (v20 == v21) {
      break;
    }
    int v24 = caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 16) + v22), (const caulk::xstring *)(*(void *)(a2 + 16) + v22));
    uint64_t v21 = v23 + 1;
    v22 += 16;
  }
  while (!v24);
  return v23 >= v19;
}

uint64_t as::server::IOStreamState::clearStreamFormat(as::server::IOStreamState *this)
{
  uint64_t result = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::server::IOStreamState::addAvailableFormats(as::server::IOStreamState *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  int v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::AvailableStreamFormat>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *int v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210AD3DA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::PortInvariants::default_instance(as::server::PortInvariants *this)
{
  {
    operator new();
  }
  return as::server::PortInvariants::default_instance(void)::gInstance;
}

void sub_210AD3E5C(_Unwind_Exception *a1)
{
}

double as::server::PortInvariants::PortInvariants(as::server::PortInvariants *this)
{
  *(void *)this = &unk_26C312A28;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312A28;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  return result;
}

as::server::PortInvariants *as::server::PortInvariants::PortInvariants(as::server::PortInvariants *this, __n128 *a2)
{
  *(void *)this = &unk_26C312A28;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::server::PortInvariants::copy_from((__n128 *)this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312A28;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::server::PortInvariants::copy_from((__n128 *)this, a2);
  return this;
}

__n128 as::server::PortInvariants::copy_from(__n128 *this, __n128 *a2)
{
  caulk::xstring::assign((caulk::xstring *)&this[1], (const caulk::xstring *)&a2[1]);
  caulk::xstring::assign((caulk::xstring *)&this[2], (const caulk::xstring *)&a2[2]);
  this->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[3];
  this[4].n128_u64[0] = a2[4].n128_u64[0];
  this[3] = result;
  return result;
}

__n128 *as::server::PortInvariants::operator=(__n128 *a1, __n128 *a2)
{
  return a1;
}

{
  as::server::PortInvariants::move_from(a1, a2);
  return a1;
}

uint64_t as::server::PortInvariants::PortInvariants(uint64_t a1, __n128 *a2)
{
  *(void *)a1 = &unk_26C312A28;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  as::server::PortInvariants::move_from((__n128 *)a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312A28;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  as::server::PortInvariants::move_from((__n128 *)a1, a2);
  return a1;
}

__n128 as::server::PortInvariants::move_from(__n128 *a1, __n128 *a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v5);
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v5);
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  return result;
}

uint64_t as::server::PortInvariants::clear(as::server::PortInvariants *this)
{
  caulk::xstring::clear((as::server::PortInvariants *)((char *)this + 16));
  uint64_t result = caulk::xstring::clear((as::server::PortInvariants *)((char *)this + 32));
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  return result;
}

BOOL as::server::PortInvariants::isInitialized(as::server::PortInvariants *this)
{
  return (~*((_DWORD *)this + 2) & 0x7F) == 0;
}

BOOL as::server::PortInvariants::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v15 = 0;
        unsigned int v16 = 0;
        unint64_t v11 = 0;
        if (v3 <= v2) {
          unint64_t v17 = v2;
        }
        else {
          unint64_t v17 = v3;
        }
        while (v17 != v3)
        {
          unint64_t v18 = v3++;
          char v19 = *(unsigned char *)(v8 + v18);
          a2[1] = v3;
          v11 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0) {
            goto LABEL_21;
          }
          v15 += 7;
          BOOL v20 = v16++ >= 9;
          if (v20)
          {
            unint64_t v11 = 0;
LABEL_21:
            unint64_t v12 = v18 + 1;
            goto LABEL_22;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v9 = 0;
        unsigned int v10 = 0;
        unint64_t v11 = 0;
        while (1)
        {
          unint64_t v12 = v3 + 1;
          a2[1] = v3 + 1;
          char v13 = *(unsigned char *)(v8 + v3);
          v11 |= (unint64_t)(v13 & 0x7F) << v9;
          if ((v13 & 0x80) == 0) {
            break;
          }
          v9 += 7;
          unint64_t v3 = v12;
          BOOL v14 = v10++ > 8;
          if (v14)
          {
            unint64_t v11 = 0;
            break;
          }
        }
LABEL_22:
        if ((v11 & 7) != 4)
        {
          switch((v11 >> 3))
          {
            case 1u:
              if (v12 > 0xFFFFFFFFFFFFFFF5 || v12 + 10 > v2)
              {
                char v47 = 0;
                unsigned int v48 = 0;
                uint64_t v23 = 0;
                if (v2 <= v12) {
                  unint64_t v2 = v12;
                }
                do
                {
                  if (v2 == v12)
                  {
                    uint64_t v23 = 0;
                    *((unsigned char *)a2 + 24) = 1;
                    goto LABEL_98;
                  }
                  unint64_t v49 = v12 + 1;
                  char v50 = *(unsigned char *)(v8 + v12);
                  a2[1] = v49;
                  v23 |= (unint64_t)(v50 & 0x7F) << v47;
                  if ((v50 & 0x80) == 0) {
                    goto LABEL_98;
                  }
                  v47 += 7;
                  unint64_t v12 = v49;
                  BOOL v20 = v48++ >= 9;
                }
                while (!v20);
LABEL_68:
                uint64_t v23 = 0;
              }
              else
              {
                char v21 = 0;
                unsigned int v22 = 0;
                uint64_t v23 = 0;
                while (1)
                {
                  unint64_t v24 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v25 = *(unsigned char *)(v8 + v12);
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if ((v25 & 0x80) == 0) {
                    break;
                  }
                  v21 += 7;
                  unint64_t v12 = v24;
                  BOOL v14 = v22++ > 8;
                  if (v14) {
                    goto LABEL_68;
                  }
                }
              }
LABEL_98:
              *(void *)(a1 + 48) = v23;
              int v67 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_107;
            case 2u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v26 = 0;
                unsigned int v27 = 0;
                uint64_t v28 = 0;
                do
                {
                  unint64_t v29 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v30 = *(unsigned char *)(v8 + v12);
                  v28 |= (unint64_t)(v30 & 0x7F) << v26;
                  if ((v30 & 0x80) == 0) {
                    goto LABEL_100;
                  }
                  v26 += 7;
                  unint64_t v12 = v29;
                  BOOL v14 = v27++ > 8;
                }
                while (!v14);
LABEL_75:
                LODWORD(v28) = 0;
                goto LABEL_100;
              }
              char v51 = 0;
              unsigned int v52 = 0;
              uint64_t v28 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v53 = v12 + 1;
                char v54 = *(unsigned char *)(v8 + v12);
                a2[1] = v53;
                v28 |= (unint64_t)(v54 & 0x7F) << v51;
                if ((v54 & 0x80) == 0) {
                  goto LABEL_100;
                }
                v51 += 7;
                unint64_t v12 = v53;
                BOOL v20 = v52++ >= 9;
                if (v20) {
                  goto LABEL_75;
                }
              }
              LODWORD(v28) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_100:
              *(_DWORD *)(a1 + 56) = v28;
              int v67 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_107;
            case 3u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v31 = 0;
                unsigned int v32 = 0;
                uint64_t v33 = 0;
                do
                {
                  unint64_t v34 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v35 = *(unsigned char *)(v8 + v12);
                  v33 |= (unint64_t)(v35 & 0x7F) << v31;
                  if ((v35 & 0x80) == 0) {
                    goto LABEL_102;
                  }
                  v31 += 7;
                  unint64_t v12 = v34;
                  BOOL v14 = v32++ > 8;
                }
                while (!v14);
LABEL_82:
                LODWORD(v33) = 0;
                goto LABEL_102;
              }
              char v55 = 0;
              unsigned int v56 = 0;
              uint64_t v33 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v57 = v12 + 1;
                char v58 = *(unsigned char *)(v8 + v12);
                a2[1] = v57;
                v33 |= (unint64_t)(v58 & 0x7F) << v55;
                if ((v58 & 0x80) == 0) {
                  goto LABEL_102;
                }
                v55 += 7;
                unint64_t v12 = v57;
                BOOL v20 = v56++ >= 9;
                if (v20) {
                  goto LABEL_82;
                }
              }
              LODWORD(v33) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_102:
              *(_DWORD *)(a1 + 60) = v33;
              int v67 = *(_DWORD *)(a1 + 8) | 4;
              goto LABEL_107;
            case 4u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v36 = 0;
                unsigned int v37 = 0;
                uint64_t v38 = 0;
                do
                {
                  unint64_t v39 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v40 = *(unsigned char *)(v8 + v12);
                  v38 |= (unint64_t)(v40 & 0x7F) << v36;
                  if ((v40 & 0x80) == 0) {
                    goto LABEL_104;
                  }
                  v36 += 7;
                  unint64_t v12 = v39;
                  BOOL v14 = v37++ > 8;
                }
                while (!v14);
LABEL_89:
                LODWORD(v38) = 0;
                goto LABEL_104;
              }
              char v59 = 0;
              unsigned int v60 = 0;
              uint64_t v38 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v61 = v12 + 1;
                char v62 = *(unsigned char *)(v8 + v12);
                a2[1] = v61;
                v38 |= (unint64_t)(v62 & 0x7F) << v59;
                if ((v62 & 0x80) == 0) {
                  goto LABEL_104;
                }
                v59 += 7;
                unint64_t v12 = v61;
                BOOL v20 = v60++ >= 9;
                if (v20) {
                  goto LABEL_89;
                }
              }
              LODWORD(v38) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_104:
              *(_DWORD *)(a1 + 64) = v38;
              int v67 = *(_DWORD *)(a1 + 8) | 8;
              goto LABEL_107;
            case 5u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v41 = 0;
                unsigned int v42 = 0;
                uint64_t v43 = 0;
                do
                {
                  unint64_t v44 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v45 = *(unsigned char *)(v8 + v12);
                  v43 |= (unint64_t)(v45 & 0x7F) << v41;
                  if ((v45 & 0x80) == 0) {
                    goto LABEL_106;
                  }
                  v41 += 7;
                  unint64_t v12 = v44;
                  BOOL v14 = v42++ > 8;
                }
                while (!v14);
LABEL_96:
                LODWORD(v43) = 0;
                goto LABEL_106;
              }
              char v63 = 0;
              unsigned int v64 = 0;
              uint64_t v43 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v65 = v12 + 1;
                char v66 = *(unsigned char *)(v8 + v12);
                a2[1] = v65;
                v43 |= (unint64_t)(v66 & 0x7F) << v63;
                if ((v66 & 0x80) == 0) {
                  goto LABEL_106;
                }
                v63 += 7;
                unint64_t v12 = v65;
                BOOL v20 = v64++ >= 9;
                if (v20) {
                  goto LABEL_96;
                }
              }
              LODWORD(v43) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_106:
              *(_DWORD *)(a1 + 68) = v43;
              int v67 = *(_DWORD *)(a1 + 8) | 0x10;
LABEL_107:
              *(_DWORD *)(a1 + 8) = v67;
LABEL_108:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 6u:
              PB::Reader::read();
              caulk::xstring::assign();
              int v46 = *(_DWORD *)(a1 + 8) | 0x20;
              goto LABEL_61;
            case 7u:
              PB::Reader::read();
              caulk::xstring::assign();
              int v46 = *(_DWORD *)(a1 + 8) | 0x40;
LABEL_61:
              *(_DWORD *)(a1 + 8) = v46;
              goto LABEL_108;
            default:
              goto LABEL_108;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AD47B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::server::PortInvariants::writeTo(as::server::PortInvariants *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_14;
  }
LABEL_13:
  PB::Writer::writeVarInt(a2);
  int v4 = *((_DWORD *)this + 2);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0) {
      return;
    }
    goto LABEL_17;
  }
LABEL_14:
  uint64_t v5 = (char *)caulk::xstring::c_str((as::server::PortInvariants *)((char *)this + 16));
  std::string::basic_string[abi:ne180100]<0>(__p, v5);
  PB::Writer::write();
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  if ((*((_DWORD *)this + 2) & 0x40) != 0)
  {
LABEL_17:
    uint64_t v6 = (char *)caulk::xstring::c_str((as::server::PortInvariants *)((char *)this + 32));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::Writer::write();
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_210AD492C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::PortInvariants::formatText(as::server::PortInvariants *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "objectToken");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "portType");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  PB::TextFormatter::format(a2, "endpointType");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  PB::TextFormatter::format(a2, "connectionType");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_14;
  }
LABEL_13:
  PB::TextFormatter::format(a2, "direction");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0) {
      return PB::TextFormatter::endObject(a2);
    }
    goto LABEL_17;
  }
LABEL_14:
  uint64_t v6 = (char *)caulk::xstring::c_str((as::server::PortInvariants *)((char *)this + 16));
  std::string::basic_string[abi:ne180100]<0>(__p, v6);
  PB::TextFormatter::format();
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  if ((*((_DWORD *)this + 2) & 0x40) != 0)
  {
LABEL_17:
    uint64_t v7 = (char *)caulk::xstring::c_str((as::server::PortInvariants *)((char *)this + 32));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AD4AB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::PortInvariants::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && (*(void *)(a1 + 48) == *(void *)(a2 + 48) ? (BOOL v4 = *(void *)(a1 + 56) == *(void *)(a2 + 56)) : (BOOL v4 = 0),
        v4 ? (BOOL v5 = *(void *)(a1 + 64) == *(void *)(a2 + 64)) : (BOOL v5 = 0),
        v5 && !caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16))))
  {
    return caulk::xstring::compare((caulk::xstring *)(a1 + 32), (const caulk::xstring *)(a2 + 32)) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t as::server::Port::default_instance(as::server::Port *this)
{
  {
    operator new();
  }
  return as::server::Port::default_instance(void)::gInstance;
}

void sub_210AD4BFC(_Unwind_Exception *a1)
{
}

double as::server::Port::Port(as::server::Port *this)
{
  *(void *)this = &unk_26C312DE0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 121) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312DE0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 121) = 0u;
  return result;
}

uint64_t as::server::Port::copy_from(as::server::Port *this, const as::server::Port *a2)
{
  BOOL v4 = (__n128 *)*((void *)a2 + 15);
  if (v4)
  {
    BOOL v5 = (__n128 *)as::server::Port::mutableInvariants(this);
    as::server::PortInvariants::copy_from(v5, v4);
  }
  caulk::xstring::assign((as::server::Port *)((char *)this + 88), (const as::server::Port *)((char *)a2 + 88));
  if (this != a2)
  {
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 16, *((caulk::xstring **)a2 + 2), *((caulk::xstring **)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 4);
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 40, *((caulk::xstring **)a2 + 5), *((caulk::xstring **)a2 + 6), (uint64_t)(*((void *)a2 + 6) - *((void *)a2 + 5)) >> 4);
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 64, *((caulk::xstring **)a2 + 8), *((caulk::xstring **)a2 + 9), (uint64_t)(*((void *)a2 + 9) - *((void *)a2 + 8)) >> 4);
  }
  uint64_t v6 = (const as::server::HardwareInfo *)*((void *)a2 + 16);
  if (v6)
  {
    uint64_t v7 = (as::server::HardwareInfo *)as::server::Port::mutableHardwareInfo(this);
    as::server::HardwareInfo::copy_from(v7, v6);
  }
  uint64_t result = caulk::xstring::assign((as::server::Port *)((char *)this + 104), (const as::server::Port *)((char *)a2 + 104));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((unsigned char *)this + 136) = *((unsigned char *)a2 + 136);
  return result;
}

as::server::Port *as::server::Port::operator=(as::server::Port *a1, const as::server::Port *a2)
{
  return a1;
}

uint64_t as::server::Port::invariants(as::server::Port *this)
{
  uint64_t result = *((void *)this + 15);
  if (!result) {
    return as::server::PortInvariants::default_instance(0);
  }
  return result;
}

uint64_t as::server::Port::mutableInvariants(as::server::Port *this)
{
  if (!*((void *)this + 15)) {
    operator new();
  }
  return *((void *)this + 15);
}

uint64_t as::server::Port::hardwareInfo(as::server::Port *this)
{
  uint64_t result = *((void *)this + 16);
  if (!result) {
    return as::server::HardwareInfo::default_instance(0);
  }
  return result;
}

uint64_t as::server::Port::mutableHardwareInfo(as::server::Port *this)
{
  if (!*((void *)this + 16)) {
    operator new();
  }
  return *((void *)this + 16);
}

uint64_t as::server::Port::Port(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312DE0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 128) = 0;
  as::server::Port::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312DE0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 128) = 0;
  as::server::Port::move_from(a1, a2);
  return a1;
}

uint64_t as::server::Port::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 120);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = v4;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v16);
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v5;
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v6;
  uint64_t v7 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v7;
  uint64_t v8 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v8;
  uint64_t v9 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v9;
  uint64_t v10 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v10;
  uint64_t v11 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v11;
  uint64_t v12 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v12;
  uint64_t v13 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v13;
  uint64_t v14 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(void *)(a2 + 128) = v14;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)&v16);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 136) = *(unsigned char *)(a2 + 136);
  return result;
}

uint64_t as::server::Port::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::server::Port::clear(as::server::Port *this)
{
  uint64_t v2 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  caulk::xstring::clear((as::server::Port *)((char *)this + 88));
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 16, *((caulk::xstring **)this + 2));
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 40, *((caulk::xstring **)this + 5));
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 64, *((caulk::xstring **)this + 8));
  uint64_t v3 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t result = caulk::xstring::clear((as::server::Port *)((char *)this + 104));
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 136) = 0;
  return result;
}

BOOL as::server::Port::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    uint64_t v8 = (uint64_t *)(a1 + 64);
    uint64_t v57 = a1 + 80;
    uint64_t v9 = (uint64_t *)(a1 + 40);
    uint64_t v10 = a1 + 56;
    uint64_t v11 = (uint64_t *)(a1 + 16);
    uint64_t v12 = a1 + 32;
    while (1)
    {
      uint64_t v13 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v14 = 0;
      unsigned int v15 = 0;
      unint64_t v16 = 0;
      while (1)
      {
        unint64_t v17 = v3 + 1;
        a2[1] = v3 + 1;
        char v18 = *(unsigned char *)(v13 + v3);
        v16 |= (unint64_t)(v18 & 0x7F) << v14;
        if ((v18 & 0x80) == 0) {
          break;
        }
        v14 += 7;
        unint64_t v3 = v17;
        if (v15++ > 8)
        {
          unint64_t v16 = 0;
          break;
        }
      }
LABEL_23:
      if ((v16 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      switch((v16 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          std::string __p = 0;
          char v59 = 0;
          unsigned int v60 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          int v26 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_37;
        case 4u:
          uint64_t v28 = *(void **)(a1 + 24);
          unint64_t v27 = *(void *)(a1 + 32);
          if ((unint64_t)v28 >= v27)
          {
            uint64_t v38 = ((uint64_t)v28 - *v11) >> 4;
            unint64_t v39 = v38 + 1;
            if ((unint64_t)(v38 + 1) >> 60) {
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v40 = v27 - *v11;
            if (v40 >> 3 > v39) {
              unint64_t v39 = v40 >> 3;
            }
            if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v41 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v41 = v39;
            }
            uint64_t v62 = v12;
            if (v41) {
              unsigned int v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v12, v41);
            }
            else {
              unsigned int v42 = 0;
            }
            unint64_t v53 = &v42[16 * v38];
            std::string __p = v42;
            char v59 = v53;
            unint64_t v61 = &v42[16 * v41];
            *(void *)unint64_t v53 = 0;
            *((void *)v53 + 1) = 0;
            unsigned int v60 = v53 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v11, &__p);
            unint64_t v29 = *(void **)(a1 + 24);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *uint64_t v28 = 0;
            v28[1] = 0;
            unint64_t v29 = v28 + 2;
            *(void *)(a1 + 24) = v28 + 2;
          }
          *(void *)(a1 + 24) = v29;
          std::string __p = 0;
          char v59 = 0;
          unsigned int v60 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          goto LABEL_73;
        case 5u:
          char v31 = *(void **)(a1 + 48);
          unint64_t v30 = *(void *)(a1 + 56);
          if ((unint64_t)v31 >= v30)
          {
            uint64_t v43 = ((uint64_t)v31 - *v9) >> 4;
            unint64_t v44 = v43 + 1;
            if ((unint64_t)(v43 + 1) >> 60) {
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v45 = v30 - *v9;
            if (v45 >> 3 > v44) {
              unint64_t v44 = v45 >> 3;
            }
            if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v46 = v44;
            }
            uint64_t v62 = v10;
            if (v46) {
              char v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v10, v46);
            }
            else {
              char v47 = 0;
            }
            char v54 = &v47[16 * v43];
            std::string __p = v47;
            char v59 = v54;
            unint64_t v61 = &v47[16 * v46];
            *(void *)char v54 = 0;
            *((void *)v54 + 1) = 0;
            unsigned int v60 = v54 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v9, &__p);
            unsigned int v32 = *(void **)(a1 + 48);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *char v31 = 0;
            v31[1] = 0;
            unsigned int v32 = v31 + 2;
            *(void *)(a1 + 48) = v31 + 2;
          }
          *(void *)(a1 + 48) = v32;
          std::string __p = 0;
          char v59 = 0;
          unsigned int v60 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          goto LABEL_73;
        case 6u:
          unint64_t v34 = *(void **)(a1 + 72);
          unint64_t v33 = *(void *)(a1 + 80);
          if ((unint64_t)v34 >= v33)
          {
            uint64_t v48 = ((uint64_t)v34 - *v8) >> 4;
            unint64_t v49 = v48 + 1;
            if ((unint64_t)(v48 + 1) >> 60) {
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v50 = v33 - *v8;
            if (v50 >> 3 > v49) {
              unint64_t v49 = v50 >> 3;
            }
            if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v51 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v51 = v49;
            }
            uint64_t v62 = v57;
            if (v51) {
              unsigned int v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v57, v51);
            }
            else {
              unsigned int v52 = 0;
            }
            char v55 = &v52[16 * v48];
            std::string __p = v52;
            char v59 = v55;
            unint64_t v61 = &v52[16 * v51];
            *(void *)char v55 = 0;
            *((void *)v55 + 1) = 0;
            unsigned int v60 = v55 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
            char v35 = *(void **)(a1 + 72);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *unint64_t v34 = 0;
            v34[1] = 0;
            char v35 = v34 + 2;
            *(void *)(a1 + 72) = v34 + 2;
          }
          *(void *)(a1 + 72) = v35;
          std::string __p = 0;
          char v59 = 0;
          unsigned int v60 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          goto LABEL_73;
        case 7u:
          operator new();
        case 8u:
          if (v17 >= v2)
          {
            BOOL v37 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v36 = *(unsigned __int8 *)(v13 + v17);
            a2[1] = v17 + 1;
            BOOL v37 = v36 != 0;
          }
          *(unsigned char *)(a1 + 136) = v37;
          *(_DWORD *)(a1 + 8) |= 2u;
          break;
        case 9u:
          std::string __p = 0;
          char v59 = 0;
          unsigned int v60 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          int v26 = *(_DWORD *)(a1 + 8) | 4;
LABEL_37:
          *(_DWORD *)(a1 + 8) = v26;
LABEL_73:
          if (SHIBYTE(v60) < 0) {
            operator delete(__p);
          }
          break;
        default:
          break;
      }
      unint64_t v3 = a2[1];
      unint64_t v2 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v20 = 0;
    unsigned int v21 = 0;
    unint64_t v16 = 0;
    if (v3 <= v2) {
      unint64_t v22 = v2;
    }
    else {
      unint64_t v22 = v3;
    }
    while (v22 != v3)
    {
      unint64_t v23 = v3++;
      char v24 = *(unsigned char *)(v13 + v23);
      a2[1] = v3;
      v16 |= (unint64_t)(v24 & 0x7F) << v20;
      if ((v24 & 0x80) == 0) {
        goto LABEL_22;
      }
      v20 += 7;
      if (v21++ >= 9)
      {
        unint64_t v16 = 0;
LABEL_22:
        unint64_t v17 = v23 + 1;
        goto LABEL_23;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210AD587C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void as::server::Port::writeTo(as::server::Port *this, PB::Writer *a2)
{
  int v4 = (const PB::Base *)*((void *)this + 15);
  if (v4) {
    PB::Writer::writeSubmessage(a2, v4);
  }
  if (*((unsigned char *)this + 8))
  {
    uint64_t v5 = (char *)caulk::xstring::c_str((as::server::Port *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v19 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v6 = (caulk::xstring *)*((void *)this + 2);
  uint64_t v7 = (caulk::xstring *)*((void *)this + 3);
  while (v6 != v7)
  {
    uint64_t v8 = (char *)caulk::xstring::c_str(v6);
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::Writer::write();
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v6 = (caulk::xstring *)((char *)v6 + 16);
  }
  uint64_t v9 = (caulk::xstring *)*((void *)this + 5);
  uint64_t v10 = (caulk::xstring *)*((void *)this + 6);
  while (v9 != v10)
  {
    uint64_t v11 = (char *)caulk::xstring::c_str(v9);
    std::string::basic_string[abi:ne180100]<0>(__p, v11);
    PB::Writer::write();
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v9 = (caulk::xstring *)((char *)v9 + 16);
  }
  uint64_t v12 = (caulk::xstring *)*((void *)this + 8);
  uint64_t v13 = (caulk::xstring *)*((void *)this + 9);
  while (v12 != v13)
  {
    char v14 = (char *)caulk::xstring::c_str(v12);
    std::string::basic_string[abi:ne180100]<0>(__p, v14);
    PB::Writer::write();
    if (v19 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v12 = (caulk::xstring *)((char *)v12 + 16);
  }
  unsigned int v15 = (const PB::Base *)*((void *)this + 16);
  if (v15) {
    PB::Writer::writeSubmessage(a2, v15);
  }
  int v16 = *((_DWORD *)this + 2);
  if ((v16 & 2) != 0)
  {
    PB::Writer::write(a2);
    int v16 = *((_DWORD *)this + 2);
  }
  if ((v16 & 4) != 0)
  {
    unint64_t v17 = (char *)caulk::xstring::c_str((as::server::Port *)((char *)this + 104));
    std::string::basic_string[abi:ne180100]<0>(__p, v17);
    PB::Writer::write();
    if (v19 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_210AD5AA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::Port::formatText(as::server::Port *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 15);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "invariants");
  }
  if (*((unsigned char *)this + 8))
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::server::Port *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::TextFormatter::format();
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v7 = (caulk::xstring *)*((void *)this + 2);
  for (i = (caulk::xstring *)*((void *)this + 3); v7 != i; uint64_t v7 = (caulk::xstring *)((char *)v7 + 16))
  {
    uint64_t v9 = (char *)caulk::xstring::c_str(v7);
    std::string::basic_string[abi:ne180100]<0>(__p, v9);
    PB::TextFormatter::format();
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v10 = (caulk::xstring *)*((void *)this + 5);
  for (j = (caulk::xstring *)*((void *)this + 6); v10 != j; uint64_t v10 = (caulk::xstring *)((char *)v10 + 16))
  {
    uint64_t v12 = (char *)caulk::xstring::c_str(v10);
    std::string::basic_string[abi:ne180100]<0>(__p, v12);
    PB::TextFormatter::format();
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v13 = (caulk::xstring *)*((void *)this + 8);
  for (k = (caulk::xstring *)*((void *)this + 9); v13 != k; uint64_t v13 = (caulk::xstring *)((char *)v13 + 16))
  {
    unsigned int v15 = (char *)caulk::xstring::c_str(v13);
    std::string::basic_string[abi:ne180100]<0>(__p, v15);
    PB::TextFormatter::format();
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v16 = *((void *)this + 16);
  if (v16) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v16 + 32))(v16, a2, "hardwareInfo");
  }
  int v17 = *((_DWORD *)this + 2);
  if ((v17 & 2) != 0)
  {
    PB::TextFormatter::format(a2, "turnByTurnUseAllowed");
    int v17 = *((_DWORD *)this + 2);
  }
  if ((v17 & 4) != 0)
  {
    char v18 = (char *)caulk::xstring::c_str((as::server::Port *)((char *)this + 104));
    std::string::basic_string[abi:ne180100]<0>(__p, v18);
    PB::TextFormatter::format();
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AD5D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::Port::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(unsigned __int8 *)(a1 + 136) != *(unsigned __int8 *)(a2 + 136)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 120);
  uint64_t v5 = *(void *)(a2 + 120);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 | v5) {
      return 0;
    }
  }
  else if (!as::server::PortInvariants::operator==(v4, v5))
  {
    return 0;
  }
  if (!caulk::xstring::compare((caulk::xstring *)(a1 + 88), (const caulk::xstring *)(a2 + 88)))
  {
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(a1 + 24);
    unint64_t v9 = (v7 - v8) >> 4;
    if (v9 == (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 4)
    {
      if (v7 != v8)
      {
        uint64_t v10 = 0;
        if (v9 <= 1) {
          uint64_t v11 = 1;
        }
        else {
          uint64_t v11 = (v7 - v8) >> 4;
        }
        while (!caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 16) + v10), (const caulk::xstring *)(*(void *)(a2 + 16) + v10)))
        {
          v10 += 16;
          if (!--v11) {
            goto LABEL_19;
          }
        }
        return 0;
      }
LABEL_19:
      uint64_t v13 = *(void *)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 48);
      unint64_t v14 = (v12 - v13) >> 4;
      if (v14 == (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 4)
      {
        if (v12 != v13)
        {
          uint64_t v15 = 0;
          if (v14 <= 1) {
            uint64_t v16 = 1;
          }
          else {
            uint64_t v16 = (v12 - v13) >> 4;
          }
          while (!caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 40) + v15), (const caulk::xstring *)(*(void *)(a2 + 40) + v15)))
          {
            v15 += 16;
            if (!--v16) {
              goto LABEL_26;
            }
          }
          return 0;
        }
LABEL_26:
        uint64_t v18 = *(void *)(a1 + 64);
        uint64_t v17 = *(void *)(a1 + 72);
        unint64_t v19 = (v17 - v18) >> 4;
        if (v19 == (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 4)
        {
          if (v17 != v18)
          {
            uint64_t v20 = 0;
            if (v19 <= 1) {
              uint64_t v21 = 1;
            }
            else {
              uint64_t v21 = (v17 - v18) >> 4;
            }
            while (!caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 64) + v20), (const caulk::xstring *)(*(void *)(a2 + 64) + v20)))
            {
              v20 += 16;
              if (!--v21) {
                goto LABEL_33;
              }
            }
            return 0;
          }
LABEL_33:
          unint64_t v22 = *(void *)(a1 + 128);
          unint64_t v23 = *(void *)(a2 + 128);
          if (v22 && v23)
          {
            if (as::server::HardwareInfo::operator==((_DWORD *)v22, (_DWORD *)v23)) {
              return caulk::xstring::compare((caulk::xstring *)(a1 + 104), (const caulk::xstring *)(a2 + 104)) == 0;
            }
          }
          else if (!(v22 | v23))
          {
            return caulk::xstring::compare((caulk::xstring *)(a1 + 104), (const caulk::xstring *)(a2 + 104)) == 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t as::server::Port::clearInvariants(as::server::Port *this)
{
  uint64_t result = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::Port::clearHardwareInfo(as::server::Port *this)
{
  uint64_t result = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::SessionUpdateSummary::default_instance(as::server::SessionUpdateSummary *this)
{
  {
    operator new();
  }
  return as::server::SessionUpdateSummary::default_instance(void)::gInstance;
}

void sub_210AD6018(_Unwind_Exception *a1)
{
}

uint64_t as::server::SessionUpdateSummary::SessionUpdateSummary(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_26C312D00;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = &unk_26C312D00;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

__n128 as::server::SessionUpdateSummary::SessionUpdateSummary(as::server::SessionUpdateSummary *this, const as::server::SessionUpdateSummary *a2)
{
  *(void *)this = &unk_26C312D00;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 12);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

{
  __n128 result;

  *(void *)this = &unk_26C312D00;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 12);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

__n128 as::server::SessionUpdateSummary::copy_from(as::server::SessionUpdateSummary *this, const as::server::SessionUpdateSummary *a2)
{
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 12);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

__n128 as::server::SessionUpdateSummary::operator=(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

{
  __n128 result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

__n128 as::server::SessionUpdateSummary::SessionUpdateSummary(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312D00;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

{
  __n128 result;

  *(void *)a1 = &unk_26C312D00;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

__n128 as::server::SessionUpdateSummary::move_from(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

uint64_t as::server::SessionUpdateSummary::clear(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

BOOL as::server::SessionUpdateSummary::isInitialized(as::server::SessionUpdateSummary *this)
{
  return (~*((_DWORD *)this + 2) & 0xF) == 0;
}

BOOL as::server::SessionUpdateSummary::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    uint64_t v6 = *a2;
    while (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v3 + 1;
        a2[1] = v3 + 1;
        char v11 = *(unsigned char *)(v6 + v3);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v3 = v10;
        BOOL v12 = v8++ > 8;
        if (v12)
        {
          unint64_t v9 = 0;
          break;
        }
      }
      unint64_t v3 = v10;
LABEL_24:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      switch((v9 >> 3))
      {
        case 1u:
          if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
          {
            char v20 = 0;
            unsigned int v21 = 0;
            uint64_t v22 = 0;
            do
            {
              unint64_t v23 = v3 + 1;
              a2[1] = v3 + 1;
              char v24 = *(unsigned char *)(v6 + v3);
              v22 |= (unint64_t)(v24 & 0x7F) << v20;
              if ((v24 & 0x80) == 0) {
                goto LABEL_33;
              }
              v20 += 7;
              unint64_t v3 = v23;
              BOOL v12 = v21++ > 8;
            }
            while (!v12);
            LODWORD(v22) = 0;
LABEL_33:
            int v25 = 1;
            int v26 = a1 + 3;
            goto LABEL_99;
          }
          char v36 = 0;
          unsigned int v37 = 0;
          uint64_t v22 = 0;
          uint64_t v38 = *a2;
          if (v3 <= v2) {
            unint64_t v23 = v2;
          }
          else {
            unint64_t v23 = v3;
          }
          while (v23 != v3)
          {
            unint64_t v39 = v3++;
            char v40 = *(unsigned char *)(v38 + v39);
            a2[1] = v3;
            v22 |= (unint64_t)(v40 & 0x7F) << v36;
            if ((v40 & 0x80) == 0) {
              goto LABEL_66;
            }
            v36 += 7;
            BOOL v12 = v37++ > 8;
            if (v12)
            {
              LODWORD(v22) = 0;
LABEL_66:
              unint64_t v3 = v39 + 1;
              int v25 = 1;
              int v26 = a1 + 3;
              goto LABEL_100;
            }
          }
          int v25 = 1;
          int v26 = a1 + 3;
          goto LABEL_98;
        case 2u:
          if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
          {
            char v27 = 0;
            unsigned int v28 = 0;
            uint64_t v22 = 0;
            do
            {
              unint64_t v23 = v3 + 1;
              a2[1] = v3 + 1;
              char v29 = *(unsigned char *)(v6 + v3);
              v22 |= (unint64_t)(v29 & 0x7F) << v27;
              if ((v29 & 0x80) == 0) {
                goto LABEL_41;
              }
              v27 += 7;
              unint64_t v3 = v23;
              BOOL v12 = v28++ > 8;
            }
            while (!v12);
            LODWORD(v22) = 0;
LABEL_41:
            int v25 = 2;
            int v26 = a1 + 4;
            goto LABEL_99;
          }
          char v41 = 0;
          unsigned int v42 = 0;
          uint64_t v22 = 0;
          uint64_t v43 = *a2;
          if (v3 <= v2) {
            unint64_t v23 = v2;
          }
          else {
            unint64_t v23 = v3;
          }
          while (v23 != v3)
          {
            unint64_t v44 = v3++;
            char v45 = *(unsigned char *)(v43 + v44);
            a2[1] = v3;
            v22 |= (unint64_t)(v45 & 0x7F) << v41;
            if ((v45 & 0x80) == 0) {
              goto LABEL_75;
            }
            v41 += 7;
            BOOL v12 = v42++ > 8;
            if (v12)
            {
              LODWORD(v22) = 0;
LABEL_75:
              unint64_t v3 = v44 + 1;
              int v25 = 2;
              int v26 = a1 + 4;
              goto LABEL_100;
            }
          }
          int v25 = 2;
          int v26 = a1 + 4;
          goto LABEL_98;
        case 3u:
          if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
          {
            char v30 = 0;
            unsigned int v31 = 0;
            uint64_t v22 = 0;
            do
            {
              unint64_t v23 = v3 + 1;
              a2[1] = v3 + 1;
              char v32 = *(unsigned char *)(v6 + v3);
              v22 |= (unint64_t)(v32 & 0x7F) << v30;
              if ((v32 & 0x80) == 0) {
                goto LABEL_49;
              }
              v30 += 7;
              unint64_t v3 = v23;
              BOOL v12 = v31++ > 8;
            }
            while (!v12);
            LODWORD(v22) = 0;
LABEL_49:
            int v25 = 4;
            int v26 = a1 + 5;
            goto LABEL_99;
          }
          char v46 = 0;
          unsigned int v47 = 0;
          uint64_t v22 = 0;
          uint64_t v48 = *a2;
          if (v3 <= v2) {
            unint64_t v23 = v2;
          }
          else {
            unint64_t v23 = v3;
          }
          while (v23 != v3)
          {
            unint64_t v49 = v3++;
            char v50 = *(unsigned char *)(v48 + v49);
            a2[1] = v3;
            v22 |= (unint64_t)(v50 & 0x7F) << v46;
            if ((v50 & 0x80) == 0) {
              goto LABEL_84;
            }
            v46 += 7;
            BOOL v12 = v47++ > 8;
            if (v12)
            {
              LODWORD(v22) = 0;
LABEL_84:
              unint64_t v3 = v49 + 1;
              int v25 = 4;
              int v26 = a1 + 5;
              goto LABEL_100;
            }
          }
          int v25 = 4;
          int v26 = a1 + 5;
          goto LABEL_98;
        case 4u:
          if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
          {
            char v33 = 0;
            unsigned int v34 = 0;
            uint64_t v22 = 0;
            do
            {
              unint64_t v23 = v3 + 1;
              a2[1] = v3 + 1;
              char v35 = *(unsigned char *)(v6 + v3);
              v22 |= (unint64_t)(v35 & 0x7F) << v33;
              if ((v35 & 0x80) == 0) {
                goto LABEL_57;
              }
              v33 += 7;
              unint64_t v3 = v23;
              BOOL v12 = v34++ > 8;
            }
            while (!v12);
            LODWORD(v22) = 0;
LABEL_57:
            int v25 = 8;
            int v26 = a1 + 6;
            goto LABEL_99;
          }
          char v51 = 0;
          unsigned int v52 = 0;
          uint64_t v22 = 0;
          uint64_t v53 = *a2;
          if (v3 <= v2) {
            unint64_t v23 = v2;
          }
          else {
            unint64_t v23 = v3;
          }
          break;
        default:
          goto LABEL_101;
      }
      while (v23 != v3)
      {
        unint64_t v54 = v3++;
        char v55 = *(unsigned char *)(v53 + v54);
        a2[1] = v3;
        v22 |= (unint64_t)(v55 & 0x7F) << v51;
        if ((v55 & 0x80) == 0) {
          goto LABEL_93;
        }
        v51 += 7;
        BOOL v12 = v52++ > 8;
        if (v12)
        {
          LODWORD(v22) = 0;
LABEL_93:
          unint64_t v3 = v54 + 1;
          int v25 = 8;
          int v26 = a1 + 6;
          goto LABEL_100;
        }
      }
      int v25 = 8;
      int v26 = a1 + 6;
LABEL_98:
      LODWORD(v22) = 0;
      *((unsigned char *)a2 + 24) = 1;
LABEL_99:
      unint64_t v3 = v23;
LABEL_100:
      _DWORD *v26 = v22;
      a1[2] |= v25;
LABEL_101:
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    uint64_t v15 = *a2;
    if (v3 <= v2) {
      unint64_t v16 = v2;
    }
    else {
      unint64_t v16 = v3;
    }
    while (v16 != v3)
    {
      unint64_t v17 = v3++;
      char v18 = *(unsigned char *)(v15 + v17);
      a2[1] = v3;
      v9 |= (unint64_t)(v18 & 0x7F) << v13;
      if ((v18 & 0x80) == 0) {
        goto LABEL_23;
      }
      v13 += 7;
      if (v14++ >= 9)
      {
        unint64_t v9 = 0;
LABEL_23:
        unint64_t v3 = v17 + 1;
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::SessionUpdateSummary::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::writeVarInt(a2);
    int v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      this = PB::Writer::writeVarInt(a2);
      if ((*(_DWORD *)(v3 + 8) & 8) == 0) {
        return this;
      }
      goto LABEL_9;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) != 0) {
    goto LABEL_8;
  }
LABEL_4:
  if ((v4 & 8) == 0) {
    return this;
  }
LABEL_9:
  return PB::Writer::writeVarInt(a2);
}

uint64_t as::server::SessionUpdateSummary::formatText(as::server::SessionUpdateSummary *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "sessionToken");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "changeFlags");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_11:
  PB::TextFormatter::format(a2, "generationCount");
  if ((*((_DWORD *)this + 2) & 8) != 0) {
LABEL_5:
  }
    PB::TextFormatter::format(a2, "changeReason");
LABEL_6:
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::SessionUpdateSummary::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  return *(void *)(a1 + 12) == *(void *)(a2 + 12) && *(void *)(a1 + 20) == *(void *)(a2 + 20);
}

uint64_t as::server::ConfigChangeSummary::default_instance(as::server::ConfigChangeSummary *this)
{
  {
    operator new();
  }
  return as::server::ConfigChangeSummary::default_instance(void)::gInstance;
}

void sub_210AD68C8(_Unwind_Exception *a1)
{
}

double as::server::ConfigChangeSummary::ConfigChangeSummary(as::server::ConfigChangeSummary *this)
{
  *(void *)this = &unk_26C312C58;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312C58;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

as::server::ConfigChangeSummary *as::server::ConfigChangeSummary::ConfigChangeSummary(as::server::ConfigChangeSummary *this, const as::server::ConfigChangeSummary *a2)
{
  *(void *)this = &unk_26C312C58;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  as::server::ConfigChangeSummary::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312C58;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  as::server::ConfigChangeSummary::copy_from(this, a2);
  return this;
}

void *as::server::ConfigChangeSummary::copy_from(as::server::ConfigChangeSummary *this, const as::server::ConfigChangeSummary *a2)
{
  int v4 = (const as::server::ChangedObject *)*((void *)a2 + 4);
  if (v4)
  {
    int v5 = (as::server::ChangedObject *)as::server::ConfigChangeSummary::mutableHardwareSystemChange(this);
    as::server::ChangedObject::copy_from(v5, v4);
  }
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 1);
  if (*((void *)a2 + 1) != *((void *)a2 + 2)) {
    operator new();
  }
  return result;
}

void sub_210AD6B04(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::ConfigChangeSummary *as::server::ConfigChangeSummary::operator=(as::server::ConfigChangeSummary *a1, const as::server::ConfigChangeSummary *a2)
{
  return a1;
}

uint64_t as::server::ConfigChangeSummary::hardwareSystemChange(as::server::ConfigChangeSummary *this)
{
  uint64_t result = *((void *)this + 4);
  if (!result) {
    return as::server::ChangedObject::default_instance(0);
  }
  return result;
}

uint64_t as::server::ConfigChangeSummary::mutableHardwareSystemChange(as::server::ConfigChangeSummary *this)
{
  if (!*((void *)this + 4)) {
    operator new();
  }
  return *((void *)this + 4);
}

as::server::ChangedObject *as::server::ChangedObject::operator=(as::server::ChangedObject *a1, const as::server::ChangedObject *a2)
{
  return a1;
}

double as::server::ConfigChangeSummary::ConfigChangeSummary(uint64_t a1, void *a2)
{
  *(void *)a1 = &unk_26C312C58;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 32) = a2[4];
  a2[4] = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[1];
  a2[1] = v3;
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[2];
  a2[2] = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = a2[3];
  a2[3] = v5;
  return result;
}

{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(void *)a1 = &unk_26C312C58;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 32) = a2[4];
  a2[4] = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[1];
  a2[1] = v3;
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[2];
  a2[2] = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = a2[3];
  a2[3] = v5;
  return result;
}

void *as::server::ConfigChangeSummary::move_from(void *result, void *a2)
{
  uint64_t v2 = result[4];
  result[4] = a2[4];
  a2[4] = v2;
  uint64_t v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  uint64_t v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  uint64_t v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  return result;
}

void *as::server::ConfigChangeSummary::operator=(void *result, void *a2)
{
  uint64_t v2 = result[4];
  result[4] = a2[4];
  a2[4] = v2;
  uint64_t v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  uint64_t v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  uint64_t v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  return result;
}

void *as::server::ConfigChangeSummary::clear(as::server::ConfigChangeSummary *this)
{
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 1);
}

BOOL as::server::ConfigChangeSummary::isInitialized(as::server::ConfigChangeSummary *this)
{
  uint64_t v2 = *((void *)this + 1);
  uint64_t v1 = *((void *)this + 2);
  if (v2 == v1) {
    return 1;
  }
  uint64_t v3 = v2 + 8;
  do
  {
    BOOL result = (*(_DWORD *)(*(void *)(v3 - 8) + 8) & 0xF) == 15;
    BOOL v5 = (*(_DWORD *)(*(void *)(v3 - 8) + 8) & 0xF) != 0xF || v3 == v1;
    v3 += 8;
  }
  while (!v5);
  return result;
}

BOOL as::server::ConfigChangeSummary::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v2 + 1;
        a2[1] = v2 + 1;
        char v11 = *(unsigned char *)(v6 + v2);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v2 = v10;
        if (v8++ > 8) {
          goto LABEL_19;
        }
      }
LABEL_20:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v9 >> 3) == 3) {
        operator new();
      }
      if ((v9 >> 3) == 2) {
        operator new();
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v15 = v2 + 1;
      char v16 = *(unsigned char *)(v6 + v2);
      a2[1] = v15;
      v9 |= (unint64_t)(v16 & 0x7F) << v13;
      if ((v16 & 0x80) == 0) {
        goto LABEL_20;
      }
      v13 += 7;
      unint64_t v2 = v15;
      if (v14++ >= 9)
      {
LABEL_19:
        unint64_t v9 = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210AD71C8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::ConfigChangeSummary::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(const PB::Base **)(this + 32);
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  uint64_t v6 = *(const PB::Base ***)(v3 + 8);
  BOOL v5 = *(const PB::Base ***)(v3 + 16);
  while (v6 != v5)
  {
    char v7 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  return this;
}

uint64_t as::server::ConfigChangeSummary::formatText(as::server::ConfigChangeSummary *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 4);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "hardwareSystemChange");
  }
  uint64_t v6 = (uint64_t *)*((void *)this + 1);
  char v7 = (uint64_t *)*((void *)this + 2);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "sessionChanges");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::ConfigChangeSummary::operator==(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  unint64_t v5 = *(void *)(a2 + 32);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 | v5) {
      return 0;
    }
  }
  else if (!as::server::ChangedObject::operator==((void *)v4, (void *)v5))
  {
    return 0;
  }
  uint64_t v9 = a1 + 8;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(v9 + 8);
  unint64_t v10 = (v7 - v8) >> 3;
  uint64_t v12 = a2 + 8;
  uint64_t v11 = *(void *)(a2 + 8);
  if (v10 != (*(void *)(v12 + 8) - v11) >> 3) {
    return 0;
  }
  if (v7 == v8)
  {
    return 1;
  }
  else
  {
    BOOL v13 = 0;
    uint64_t v14 = 0;
    if (v10 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = (v7 - v8) >> 3;
    }
    do
    {
      uint64_t v16 = *(void *)(v8 + 8 * v14);
      uint64_t v17 = *(void *)(v11 + 8 * v14);
      if (v16) {
        BOOL v18 = v17 == 0;
      }
      else {
        BOOL v18 = 1;
      }
      if (v18)
      {
        if (v16 | v17) {
          return v13;
        }
      }
      else if (!as::server::SessionUpdateSummary::operator==(v16, v17))
      {
        return v13;
      }
      BOOL v13 = ++v14 >= v10;
    }
    while (v15 != v14);
  }
  return v13;
}

uint64_t as::server::ChangedObject::default_instance(as::server::ChangedObject *this)
{
  {
    operator new();
  }
  return as::server::ChangedObject::default_instance(void)::gInstance;
}

void sub_210AD74D0(_Unwind_Exception *a1)
{
}

double as::server::ChangedObject::ChangedObject(as::server::ChangedObject *this)
{
  *(void *)this = &unk_26C3129B8;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C3129B8;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return result;
}

uint64_t as::server::ConfigChangeSummary::clearHardwareSystemChange(as::server::ConfigChangeSummary *this)
{
  uint64_t result = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::server::ConfigChangeSummary::addSessionChanges(as::server::ConfigChangeSummary *this)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v2 = (char *)this + 24;
  unint64_t v3 = v4;
  unint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      BOOL v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      BOOL v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::SessionUpdateSummary>>::__swap_out_circular_buffer(v7, v15);
    BOOL v6 = (void *)*((void *)this + 2);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *unint64_t v5 = 0;
    BOOL v6 = v5 + 1;
    *((void *)this + 2) = v6;
  }
  *((void *)this + 2) = v6;
  operator new();
}

void sub_210AD76B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::CustomPropertyAddress::default_instance(as::server::CustomPropertyAddress *this)
{
  {
    operator new();
  }
  return as::server::CustomPropertyAddress::default_instance(void)::gInstance;
}

void sub_210AD7754(_Unwind_Exception *a1)
{
}

void *as::server::CustomPropertyAddress::CustomPropertyAddress(void *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312D38;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312D38;
  return this;
}

uint64_t as::server::CustomPropertyAddress::CustomPropertyAddress(uint64_t this, const as::server::CustomPropertyAddress *a2)
{
  *(void *)this = &unk_26C312D38;
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  uint64_t v2 = *(void *)((char *)a2 + 12);
  *(_DWORD *)(this + 20) = *((_DWORD *)a2 + 5);
  *(void *)(this + 12) = v2;
  return this;
}

{
  uint64_t v2;

  *(void *)this = &unk_26C312D38;
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  uint64_t v2 = *(void *)((char *)a2 + 12);
  *(_DWORD *)(this + 20) = *((_DWORD *)a2 + 5);
  *(void *)(this + 12) = v2;
  return this;
}

uint64_t as::server::CustomPropertyAddress::copy_from(uint64_t this, const as::server::CustomPropertyAddress *a2)
{
  *(_DWORD *)(this + 8) = *((_DWORD *)a2 + 2);
  uint64_t v2 = *(void *)((char *)a2 + 12);
  *(_DWORD *)(this + 20) = *((_DWORD *)a2 + 5);
  *(void *)(this + 12) = v2;
  return this;
}

uint64_t as::server::CustomPropertyAddress::operator=(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(void *)(result + 12) = v2;
  return result;
}

{
  uint64_t v2;

  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(void *)(result + 12) = v2;
  return result;
}

uint64_t as::server::CustomPropertyAddress::CustomPropertyAddress(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = &unk_26C312D38;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(void *)(result + 12) = v2;
  return result;
}

{
  uint64_t v2;

  *(void *)uint64_t result = &unk_26C312D38;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(void *)(result + 12) = v2;
  return result;
}

uint64_t as::server::CustomPropertyAddress::move_from(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v2 = *(void *)(a2 + 12);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
  *(void *)(result + 12) = v2;
  return result;
}

uint64_t as::server::CustomPropertyAddress::clear(uint64_t this)
{
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  return this;
}

BOOL as::server::CustomPropertyAddress::isInitialized(as::server::CustomPropertyAddress *this)
{
  return (~*((_DWORD *)this + 2) & 7) == 0;
}

BOOL as::server::CustomPropertyAddress::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0) {
    return v4 == 0;
  }
  uint64_t v6 = *a2;
  while (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
  {
    char v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v10 = v3 + 1;
      a2[1] = v3 + 1;
      char v11 = *(unsigned char *)(v6 + v3);
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0) {
        break;
      }
      v7 += 7;
      unint64_t v3 = v10;
      BOOL v12 = v8++ > 8;
      if (v12)
      {
        unint64_t v9 = 0;
        break;
      }
    }
    unint64_t v3 = v10;
LABEL_24:
    if ((v9 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v20 = v9 >> 3;
    switch(v20)
    {
      case 3:
        if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
        {
          char v28 = 0;
          unsigned int v29 = 0;
          uint64_t v23 = 0;
          while (1)
          {
            unint64_t v24 = v3 + 1;
            a2[1] = v3 + 1;
            char v30 = *(unsigned char *)(v6 + v3);
            v23 |= (unint64_t)(v30 & 0x7F) << v28;
            if ((v30 & 0x80) == 0) {
              break;
            }
            v28 += 7;
            unint64_t v3 = v24;
            BOOL v12 = v29++ > 8;
            if (v12)
            {
              LODWORD(v23) = 0;
              break;
            }
          }
          int v26 = 4;
          char v27 = a1 + 5;
LABEL_83:
          unint64_t v3 = v24;
LABEL_84:
          *char v27 = v23;
          a1[2] |= v26;
          break;
        }
        char v39 = 0;
        unsigned int v40 = 0;
        uint64_t v23 = 0;
        uint64_t v41 = *a2;
        if (v3 <= v2) {
          unint64_t v24 = v2;
        }
        else {
          unint64_t v24 = v3;
        }
        while (v24 != v3)
        {
          unint64_t v42 = v3++;
          char v43 = *(unsigned char *)(v41 + v42);
          a2[1] = v3;
          v23 |= (unint64_t)(v43 & 0x7F) << v39;
          if ((v43 & 0x80) == 0) {
            goto LABEL_69;
          }
          v39 += 7;
          BOOL v12 = v40++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
LABEL_69:
            unint64_t v3 = v42 + 1;
            int v26 = 4;
            char v27 = a1 + 5;
            goto LABEL_84;
          }
        }
        int v26 = 4;
        char v27 = a1 + 5;
LABEL_82:
        LODWORD(v23) = 0;
        *((unsigned char *)a2 + 24) = 1;
        goto LABEL_83;
      case 2:
        if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
        {
          char v31 = 0;
          unsigned int v32 = 0;
          uint64_t v23 = 0;
          while (1)
          {
            unint64_t v24 = v3 + 1;
            a2[1] = v3 + 1;
            char v33 = *(unsigned char *)(v6 + v3);
            v23 |= (unint64_t)(v33 & 0x7F) << v31;
            if ((v33 & 0x80) == 0) {
              break;
            }
            v31 += 7;
            unint64_t v3 = v24;
            BOOL v12 = v32++ > 8;
            if (v12)
            {
              LODWORD(v23) = 0;
              break;
            }
          }
          int v26 = 2;
          char v27 = a1 + 4;
          goto LABEL_83;
        }
        char v44 = 0;
        unsigned int v45 = 0;
        uint64_t v23 = 0;
        uint64_t v46 = *a2;
        if (v3 <= v2) {
          unint64_t v24 = v2;
        }
        else {
          unint64_t v24 = v3;
        }
        while (v24 != v3)
        {
          unint64_t v47 = v3++;
          char v48 = *(unsigned char *)(v46 + v47);
          a2[1] = v3;
          v23 |= (unint64_t)(v48 & 0x7F) << v44;
          if ((v48 & 0x80) == 0) {
            goto LABEL_78;
          }
          v44 += 7;
          BOOL v12 = v45++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
LABEL_78:
            unint64_t v3 = v47 + 1;
            int v26 = 2;
            char v27 = a1 + 4;
            goto LABEL_84;
          }
        }
        int v26 = 2;
        char v27 = a1 + 4;
        goto LABEL_82;
      case 1:
        if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
        {
          char v21 = 0;
          unsigned int v22 = 0;
          uint64_t v23 = 0;
          while (1)
          {
            unint64_t v24 = v3 + 1;
            a2[1] = v3 + 1;
            char v25 = *(unsigned char *)(v6 + v3);
            v23 |= (unint64_t)(v25 & 0x7F) << v21;
            if ((v25 & 0x80) == 0) {
              break;
            }
            v21 += 7;
            unint64_t v3 = v24;
            BOOL v12 = v22++ > 8;
            if (v12)
            {
              LODWORD(v23) = 0;
              break;
            }
          }
          int v26 = 1;
          char v27 = a1 + 3;
          goto LABEL_83;
        }
        char v34 = 0;
        unsigned int v35 = 0;
        uint64_t v23 = 0;
        uint64_t v36 = *a2;
        if (v3 <= v2) {
          unint64_t v24 = v2;
        }
        else {
          unint64_t v24 = v3;
        }
        while (v24 != v3)
        {
          unint64_t v37 = v3++;
          char v38 = *(unsigned char *)(v36 + v37);
          a2[1] = v3;
          v23 |= (unint64_t)(v38 & 0x7F) << v34;
          if ((v38 & 0x80) == 0) {
            goto LABEL_60;
          }
          v34 += 7;
          BOOL v12 = v35++ > 8;
          if (v12)
          {
            LODWORD(v23) = 0;
LABEL_60:
            unint64_t v3 = v37 + 1;
            int v26 = 1;
            char v27 = a1 + 3;
            goto LABEL_84;
          }
        }
        int v26 = 1;
        char v27 = a1 + 3;
        goto LABEL_82;
    }
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
      return v4 == 0;
    }
  }
  char v13 = 0;
  unsigned int v14 = 0;
  unint64_t v9 = 0;
  uint64_t v15 = *a2;
  if (v3 <= v2) {
    unint64_t v16 = v2;
  }
  else {
    unint64_t v16 = v3;
  }
  while (v16 != v3)
  {
    unint64_t v17 = v3++;
    char v18 = *(unsigned char *)(v15 + v17);
    a2[1] = v3;
    v9 |= (unint64_t)(v18 & 0x7F) << v13;
    if ((v18 & 0x80) == 0) {
      goto LABEL_23;
    }
    v13 += 7;
    if (v14++ >= 9)
    {
      unint64_t v9 = 0;
LABEL_23:
      unint64_t v3 = v17 + 1;
      goto LABEL_24;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

uint64_t as::server::CustomPropertyAddress::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if ((v4 & 1) == 0)
  {
    if ((v4 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    this = PB::Writer::writeVarInt(a2);
    if ((*(_DWORD *)(v3 + 8) & 4) == 0) {
      return this;
    }
    goto LABEL_7;
  }
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v4 & 4) == 0) {
    return this;
  }
LABEL_7:
  return PB::Writer::writeVarInt(a2);
}

uint64_t as::server::CustomPropertyAddress::formatText(as::server::CustomPropertyAddress *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "selector");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "scope");
  if ((*((_DWORD *)this + 2) & 4) != 0) {
LABEL_4:
  }
    PB::TextFormatter::format(a2, "element");
LABEL_5:
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::CustomPropertyAddress::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  return *(void *)(a1 + 12) == *(void *)(a2 + 12)
      && *(_DWORD *)(a1 + 20) == (unint64_t)*(unsigned int *)(a2 + 20);
}

uint64_t as::server::ObjectDescription::default_instance(as::server::ObjectDescription *this)
{
  {
    operator new();
  }
  return as::server::ObjectDescription::default_instance(void)::gInstance;
}

void sub_210AD7F08(_Unwind_Exception *a1)
{
}

double as::server::ObjectDescription::ObjectDescription(as::server::ObjectDescription *this)
{
  *(void *)this = &unk_26C312BE8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312BE8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  return result;
}

as::server::ObjectDescription *as::server::ObjectDescription::ObjectDescription(as::server::ObjectDescription *this, const as::server::ObjectDescription *a2)
{
  *(void *)this = &unk_26C312BE8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  as::server::ObjectDescription::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312BE8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  as::server::ObjectDescription::copy_from(this, a2);
  return this;
}

void as::server::ObjectDescription::copy_from(as::server::ObjectDescription *this, const as::server::ObjectDescription *a2)
{
  int v4 = (const as::server::Driver *)*((void *)a2 + 2);
  if (v4)
  {
    int v5 = (as::server::Driver *)as::server::ObjectDescription::mutableDriver(this);
    as::server::Driver::copy_from(v5, v4);
  }
  uint64_t v6 = (const as::server::Box *)*((void *)a2 + 3);
  if (v6)
  {
    char v7 = (as::server::Box *)as::server::ObjectDescription::mutableBox(this);
    as::server::Box::copy_from(v7, v6);
  }
  unsigned int v8 = (const as::server::Clock *)*((void *)a2 + 4);
  if (v8)
  {
    unint64_t v9 = (as::server::Clock *)as::server::ObjectDescription::mutableClock(this);
    as::server::Clock::copy_from(v9, v8);
  }
  unint64_t v10 = (const as::server::Device_Clock *)*((void *)a2 + 5);
  if (v10)
  {
    char v11 = (as::server::Device_Clock *)as::server::ObjectDescription::mutableDevice(this);
    as::server::Device_Clock::copy_from(v11, v10);
  }
  BOOL v12 = (const as::server::Port *)*((void *)a2 + 6);
  if (v12)
  {
    char v13 = (as::server::Port *)as::server::ObjectDescription::mutableHwPort(this);
    as::server::Port::copy_from(v13, v12);
  }
  unsigned int v14 = (const as::server::HWStream *)*((void *)a2 + 7);
  if (v14)
  {
    uint64_t v15 = (as::server::HWStream *)as::server::ObjectDescription::mutableHwStream(this);
    as::server::HWStream::copy_from(v15, v14);
  }
  unint64_t v16 = (const as::server::ControlAndValue *)*((void *)a2 + 8);
  if (v16)
  {
    unint64_t v17 = (as::server::ControlAndValue *)as::server::ObjectDescription::mutableControlAndValue(this);
    as::server::ControlAndValue::copy_from(v17, v16);
  }
  char v18 = (const as::server::IOControllerState *)*((void *)a2 + 9);
  if (v18)
  {
    unint64_t v19 = (as::server::IOControllerState *)as::server::ObjectDescription::mutableController(this);
    as::server::IOControllerState::copy_from(v19, v18);
  }
  unint64_t v20 = (const as::server::IOStreamState *)*((void *)a2 + 10);
  if (v20)
  {
    char v21 = (as::server::IOStreamState *)as::server::ObjectDescription::mutableIoStream(this);
    as::server::IOStreamState::copy_from(v21, v20);
  }
  unsigned int v22 = (const as::server::VirtualPort *)*((void *)a2 + 11);
  if (v22)
  {
    uint64_t v23 = (as::server::VirtualPort *)as::server::ObjectDescription::mutableVirtualPort(this);
    as::server::VirtualPort::copy_from(v23, v22);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  uint64_t v24 = *((void *)a2 + 12);
  *((_DWORD *)this + 26) = *((_DWORD *)a2 + 26);
  *((void *)this + 12) = v24;
}

as::server::ObjectDescription *as::server::ObjectDescription::operator=(as::server::ObjectDescription *a1, const as::server::ObjectDescription *a2)
{
  return a1;
}

uint64_t as::server::ObjectDescription::driver(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return as::server::Driver::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableDriver(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 2)) {
    operator new();
  }
  return *((void *)this + 2);
}

uint64_t as::server::ObjectDescription::box(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 3);
  if (!result) {
    return as::server::Box::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableBox(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 3)) {
    operator new();
  }
  return *((void *)this + 3);
}

uint64_t as::server::ObjectDescription::clock(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 4);
  if (!result) {
    return as::server::Clock::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableClock(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 4)) {
    operator new();
  }
  return *((void *)this + 4);
}

uint64_t as::server::ObjectDescription::device(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 5);
  if (!result) {
    return as::server::Device_Clock::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableDevice(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 5)) {
    operator new();
  }
  return *((void *)this + 5);
}

uint64_t as::server::ObjectDescription::hwPort(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 6);
  if (!result) {
    return as::server::Port::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableHwPort(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 6)) {
    operator new();
  }
  return *((void *)this + 6);
}

uint64_t as::server::ObjectDescription::hwStream(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 7);
  if (!result) {
    return as::server::HWStream::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableHwStream(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 7)) {
    operator new();
  }
  return *((void *)this + 7);
}

uint64_t as::server::ObjectDescription::controlAndValue(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 8);
  if (!result) {
    return as::server::ControlAndValue::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableControlAndValue(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 8)) {
    operator new();
  }
  return *((void *)this + 8);
}

uint64_t as::server::ObjectDescription::controller(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 9);
  if (!result) {
    return as::server::IOControllerState::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableController(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 9)) {
    operator new();
  }
  return *((void *)this + 9);
}

as::server::IOControllerState *as::server::IOControllerState::operator=(as::server::IOControllerState *a1, const as::server::IOControllerState *a2)
{
  return a1;
}

uint64_t as::server::ObjectDescription::ioStream(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 10);
  if (!result) {
    return as::server::IOStreamState::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableIoStream(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 10)) {
    operator new();
  }
  return *((void *)this + 10);
}

uint64_t as::server::ObjectDescription::virtualPort(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 11);
  if (!result) {
    return as::server::VirtualPort::default_instance(0);
  }
  return result;
}

uint64_t as::server::ObjectDescription::mutableVirtualPort(as::server::ObjectDescription *this)
{
  if (!*((void *)this + 11)) {
    operator new();
  }
  return *((void *)this + 11);
}

as::server::VirtualPort *as::server::VirtualPort::operator=(as::server::VirtualPort *a1, const as::server::VirtualPort *a2)
{
  return a1;
}

uint64_t as::server::ObjectDescription::ObjectDescription(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312BE8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  as::server::ObjectDescription::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312BE8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  as::server::ObjectDescription::move_from(a1, a2);
  return a1;
}

uint64_t as::server::ObjectDescription::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  uint64_t v5 = *(void *)(result + 40);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v5;
  uint64_t v6 = *(void *)(result + 48);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v6;
  uint64_t v7 = *(void *)(result + 56);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v7;
  uint64_t v8 = *(void *)(result + 64);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v8;
  uint64_t v9 = *(void *)(result + 72);
  *(void *)(result + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v9;
  uint64_t v10 = *(void *)(result + 80);
  *(void *)(result + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v10;
  uint64_t v11 = *(void *)(result + 88);
  *(void *)(result + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v11;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v12 = *(void *)(a2 + 96);
  *(_DWORD *)(result + 104) = *(_DWORD *)(a2 + 104);
  *(void *)(result + 96) = v12;
  return result;
}

uint64_t as::server::ObjectDescription::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::server::ObjectDescription::clear(as::server::ObjectDescription *this)
{
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t result = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  return result;
}

BOOL as::server::ObjectDescription::isInitialized(as::server::ObjectDescription *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::ObjectDescription::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v3 + 1;
        a2[1] = v3 + 1;
        char v11 = *(unsigned char *)(v6 + v3);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v3 = v10;
        BOOL v12 = v8++ > 8;
        if (v12)
        {
          unint64_t v9 = 0;
          break;
        }
      }
LABEL_22:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v9 >> 3;
      if ((int)(v9 >> 3) > 39)
      {
        switch(v19)
        {
          case '(':
            operator new();
          case ')':
            operator new();
          case '*':
            operator new();
        }
      }
      else
      {
        switch((int)v19)
        {
          case 1:
            if (v10 <= 0xFFFFFFFFFFFFFFF5 && v10 + 10 <= v2)
            {
              char v20 = 0;
              unsigned int v21 = 0;
              uint64_t v22 = 0;
              do
              {
                unint64_t v23 = v10 + 1;
                a2[1] = v10 + 1;
                char v24 = *(unsigned char *)(v6 + v10);
                v22 |= (unint64_t)(v24 & 0x7F) << v20;
                if ((v24 & 0x80) == 0) {
                  goto LABEL_72;
                }
                v20 += 7;
                unint64_t v10 = v23;
                BOOL v12 = v21++ > 8;
              }
              while (!v12);
LABEL_63:
              uint64_t v22 = 0;
              goto LABEL_72;
            }
            char v31 = 0;
            unsigned int v32 = 0;
            uint64_t v22 = 0;
            if (v2 <= v10) {
              unint64_t v2 = v10;
            }
            while (v2 != v10)
            {
              unint64_t v33 = v10 + 1;
              char v34 = *(unsigned char *)(v6 + v10);
              a2[1] = v33;
              v22 |= (unint64_t)(v34 & 0x7F) << v31;
              if ((v34 & 0x80) == 0) {
                goto LABEL_72;
              }
              v31 += 7;
              unint64_t v10 = v33;
              BOOL v18 = v32++ >= 9;
              if (v18) {
                goto LABEL_63;
              }
            }
            uint64_t v22 = 0;
            *((unsigned char *)a2 + 24) = 1;
LABEL_72:
            *(void *)(a1 + 96) = v22;
            int v39 = *(_DWORD *)(a1 + 8) | 1;
            goto LABEL_75;
          case 2:
            if (v10 <= 0xFFFFFFFFFFFFFFF5 && v10 + 10 <= v2)
            {
              char v25 = 0;
              unsigned int v26 = 0;
              uint64_t v27 = 0;
              do
              {
                unint64_t v28 = v10 + 1;
                a2[1] = v10 + 1;
                char v29 = *(unsigned char *)(v6 + v10);
                v27 |= (unint64_t)(v29 & 0x7F) << v25;
                if ((v29 & 0x80) == 0) {
                  goto LABEL_74;
                }
                v25 += 7;
                unint64_t v10 = v28;
                BOOL v12 = v26++ > 8;
              }
              while (!v12);
LABEL_70:
              LODWORD(v27) = 0;
              goto LABEL_74;
            }
            char v35 = 0;
            unsigned int v36 = 0;
            uint64_t v27 = 0;
            if (v2 <= v10) {
              unint64_t v2 = v10;
            }
            while (v2 != v10)
            {
              unint64_t v37 = v10 + 1;
              char v38 = *(unsigned char *)(v6 + v10);
              a2[1] = v37;
              v27 |= (unint64_t)(v38 & 0x7F) << v35;
              if ((v38 & 0x80) == 0) {
                goto LABEL_74;
              }
              v35 += 7;
              unint64_t v10 = v37;
              BOOL v18 = v36++ >= 9;
              if (v18) {
                goto LABEL_70;
              }
            }
            LODWORD(v27) = 0;
            *((unsigned char *)a2 + 24) = 1;
LABEL_74:
            *(_DWORD *)(a1 + 104) = v27;
            int v39 = *(_DWORD *)(a1 + 8) | 2;
LABEL_75:
            *(_DWORD *)(a1 + 8) = v39;
            break;
          case 3:
            operator new();
          case 4:
            operator new();
          case 5:
            operator new();
          case 6:
            operator new();
          case 7:
            operator new();
          case 8:
            operator new();
          case 9:
            operator new();
          default:
            break;
        }
      }
      unint64_t v3 = a2[1];
      unint64_t v2 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v3 <= v2) {
      unint64_t v15 = v2;
    }
    else {
      unint64_t v15 = v3;
    }
    while (v15 != v3)
    {
      unint64_t v16 = v3++;
      char v17 = *(unsigned char *)(v6 + v16);
      a2[1] = v3;
      v9 |= (unint64_t)(v17 & 0x7F) << v13;
      if ((v17 & 0x80) == 0) {
        goto LABEL_21;
      }
      v13 += 7;
      BOOL v18 = v14++ >= 9;
      if (v18)
      {
        unint64_t v9 = 0;
LABEL_21:
        unint64_t v10 = v16 + 1;
        goto LABEL_22;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::ObjectDescription::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::writeVarInt(a2);
    int v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0) {
    this = PB::Writer::writeVarInt(a2);
  }
  uint64_t v5 = *(const PB::Base **)(v3 + 16);
  if (v5) {
    this = PB::Writer::writeSubmessage(a2, v5);
  }
  uint64_t v6 = *(const PB::Base **)(v3 + 24);
  if (v6) {
    this = PB::Writer::writeSubmessage(a2, v6);
  }
  char v7 = *(const PB::Base **)(v3 + 32);
  if (v7) {
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  unsigned int v8 = *(const PB::Base **)(v3 + 40);
  if (v8) {
    this = PB::Writer::writeSubmessage(a2, v8);
  }
  unint64_t v9 = *(const PB::Base **)(v3 + 48);
  if (v9) {
    this = PB::Writer::writeSubmessage(a2, v9);
  }
  unint64_t v10 = *(const PB::Base **)(v3 + 56);
  if (v10) {
    this = PB::Writer::writeSubmessage(a2, v10);
  }
  char v11 = *(const PB::Base **)(v3 + 64);
  if (v11) {
    this = PB::Writer::writeSubmessage(a2, v11);
  }
  BOOL v12 = *(const PB::Base **)(v3 + 72);
  if (v12) {
    this = PB::Writer::writeSubmessage(a2, v12);
  }
  char v13 = *(const PB::Base **)(v3 + 80);
  if (v13) {
    this = PB::Writer::writeSubmessage(a2, v13);
  }
  unsigned int v14 = *(const PB::Base **)(v3 + 88);
  if (v14)
  {
    return PB::Writer::writeSubmessage(a2, v14);
  }
  return this;
}

uint64_t as::server::ObjectDescription::formatText(as::server::ObjectDescription *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "objectToken");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "classTypeID");
  }
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, a2, "driver");
  }
  uint64_t v7 = *((void *)this + 3);
  if (v7) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, a2, "box");
  }
  uint64_t v8 = *((void *)this + 4);
  if (v8) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "clock");
  }
  uint64_t v9 = *((void *)this + 5);
  if (v9) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v9 + 32))(v9, a2, "device");
  }
  uint64_t v10 = *((void *)this + 6);
  if (v10) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v10 + 32))(v10, a2, "hwPort");
  }
  uint64_t v11 = *((void *)this + 7);
  if (v11) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v11 + 32))(v11, a2, "hwStream");
  }
  uint64_t v12 = *((void *)this + 8);
  if (v12) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v12 + 32))(v12, a2, "controlAndValue");
  }
  uint64_t v13 = *((void *)this + 9);
  if (v13) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v13 + 32))(v13, a2, "controller");
  }
  uint64_t v14 = *((void *)this + 10);
  if (v14) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v14 + 32))(v14, a2, "ioStream");
  }
  uint64_t v15 = *((void *)this + 11);
  if (v15) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v15 + 32))(v15, a2, "virtualPort");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::ObjectDescription::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (*(void *)(a1 + 96) != *(void *)(a2 + 96)
    || *(_DWORD *)(a1 + 104) != (unint64_t)*(unsigned int *)(a2 + 104))
  {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a2 + 16);
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    if (v6 | v7) {
      return 0;
    }
  }
  else if (!as::server::Driver::operator==(v6, v7))
  {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a2 + 24);
  if (v9 && v10)
  {
    if (!as::server::Box::operator==(v9, v10)) {
      return 0;
    }
  }
  else if (v9 | v10)
  {
    return 0;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = *(void *)(a2 + 32);
  if (v11 && v12)
  {
    if (!as::server::Clock::operator==(v11, v12)) {
      return 0;
    }
  }
  else if (v11 | v12)
  {
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 40);
  uint64_t v14 = *(void *)(a2 + 40);
  if (v13 && v14)
  {
    if (!as::server::Device_Clock::operator==(v13, v14)) {
      return 0;
    }
  }
  else if (v13 | v14)
  {
    return 0;
  }
  uint64_t v15 = *(void *)(a1 + 48);
  uint64_t v16 = *(void *)(a2 + 48);
  if (v15 && v16)
  {
    if (!as::server::Port::operator==(v15, v16)) {
      return 0;
    }
  }
  else if (v15 | v16)
  {
    return 0;
  }
  uint64_t v17 = *(void *)(a1 + 56);
  uint64_t v18 = *(void *)(a2 + 56);
  if (v17 && v18)
  {
    if (!as::server::HWStream::operator==(v17, v18)) {
      return 0;
    }
  }
  else if (v17 | v18)
  {
    return 0;
  }
  uint64_t v19 = *(void *)(a1 + 64);
  uint64_t v20 = *(void *)(a2 + 64);
  if (v19 && v20)
  {
    if (!as::server::ControlAndValue::operator==(v19, v20)) {
      return 0;
    }
  }
  else if (v19 | v20)
  {
    return 0;
  }
  uint64_t v21 = *(void *)(a1 + 72);
  uint64_t v22 = *(void *)(a2 + 72);
  if (v21 && v22)
  {
    if (!as::server::IOControllerState::operator==(v21, v22)) {
      return 0;
    }
  }
  else if (v21 | v22)
  {
    return 0;
  }
  uint64_t v23 = *(void *)(a1 + 80);
  uint64_t v24 = *(void *)(a2 + 80);
  if (v23 && v24)
  {
    if (as::server::IOStreamState::operator==(v23, v24)) {
      goto LABEL_56;
    }
    return 0;
  }
  if (v23 | v24) {
    return 0;
  }
LABEL_56:
  uint64_t v25 = *(void *)(a1 + 88);
  uint64_t v26 = *(void *)(a2 + 88);
  BOOL result = (v25 | v26) == 0;
  if (v25 && v26)
  {
    uint64_t v27 = *(void *)(a1 + 88);
    return as::server::VirtualPort::operator==(v27, v26);
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearDriver(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearBox(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearClock(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearDevice(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearHwPort(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearHwStream(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearControlAndValue(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::IOControllerState::default_instance(as::server::IOControllerState *this)
{
  {
    operator new();
  }
  return as::server::IOControllerState::default_instance(void)::gInstance;
}

void sub_210AD9D74(_Unwind_Exception *a1)
{
}

double as::server::IOControllerState::IOControllerState(as::server::IOControllerState *this)
{
  *(void *)this = &unk_26C312BB0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((void *)this + 16) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312BB0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((void *)this + 16) = 0;
  return result;
}

uint64_t as::server::ObjectDescription::clearController(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::ObjectDescription::clearIoStream(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::VirtualPort::default_instance(as::server::VirtualPort *this)
{
  {
    operator new();
  }
  return as::server::VirtualPort::default_instance(void)::gInstance;
}

void sub_210AD9ED4(_Unwind_Exception *a1)
{
}

double as::server::VirtualPort::VirtualPort(as::server::VirtualPort *this)
{
  *(void *)this = &unk_26C3128D8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_WORD *)this + 24) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C3128D8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_WORD *)this + 24) = 0;
  return result;
}

uint64_t as::server::ObjectDescription::clearVirtualPort(as::server::ObjectDescription *this)
{
  uint64_t result = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

as::server::ChangedObject *as::server::ChangedObject::ChangedObject(as::server::ChangedObject *this, const as::server::ChangedObject *a2)
{
  *(void *)this = &unk_26C3129B8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  as::server::ChangedObject::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3129B8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  as::server::ChangedObject::copy_from(this, a2);
  return this;
}

void *as::server::ChangedObject::copy_from(as::server::ChangedObject *this, const as::server::ChangedObject *a2)
{
  int v4 = (const as::server::ObjectDescription *)*((void *)a2 + 16);
  if (v4)
  {
    int v5 = (as::server::ObjectDescription *)as::server::ChangedObject::mutableObjectDescription(this);
    as::server::ObjectDescription::copy_from(v5, v4);
  }
  if (this != a2) {
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 8, *((caulk::xstring **)a2 + 1), *((caulk::xstring **)a2 + 2), (uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 4);
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 4);
  if (*((void *)a2 + 4) != *((void *)a2 + 5)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 7);
  if (*((void *)a2 + 7) != *((void *)a2 + 8)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 10);
  if (*((void *)a2 + 10) != *((void *)a2 + 11)) {
    operator new();
  }
  uint64_t result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 13);
  if (*((void *)a2 + 13) != *((void *)a2 + 14)) {
    operator new();
  }
  return result;
}

void sub_210ADA4FC(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

uint64_t as::server::ChangedObject::objectDescription(as::server::ChangedObject *this)
{
  uint64_t result = *((void *)this + 16);
  if (!result) {
    return as::server::ObjectDescription::default_instance(0);
  }
  return result;
}

uint64_t as::server::ChangedObject::mutableObjectDescription(as::server::ChangedObject *this)
{
  if (!*((void *)this + 16)) {
    operator new();
  }
  return *((void *)this + 16);
}

uint64_t as::server::ChangedObject::ChangedObject(uint64_t a1, void *a2)
{
  *(void *)a1 = &unk_26C3129B8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  as::server::ChangedObject::move_from((void *)a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C3129B8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  as::server::ChangedObject::move_from((void *)a1, a2);
  return a1;
}

void *as::server::ChangedObject::move_from(void *result, void *a2)
{
  uint64_t v2 = result[16];
  result[16] = a2[16];
  a2[16] = v2;
  uint64_t v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  uint64_t v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  uint64_t v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  uint64_t v6 = result[4];
  result[4] = a2[4];
  a2[4] = v6;
  uint64_t v7 = result[5];
  result[5] = a2[5];
  a2[5] = v7;
  uint64_t v8 = result[6];
  result[6] = a2[6];
  a2[6] = v8;
  uint64_t v9 = result[7];
  result[7] = a2[7];
  a2[7] = v9;
  uint64_t v10 = result[8];
  result[8] = a2[8];
  a2[8] = v10;
  uint64_t v11 = result[9];
  result[9] = a2[9];
  a2[9] = v11;
  uint64_t v12 = result[10];
  result[10] = a2[10];
  a2[10] = v12;
  uint64_t v13 = result[11];
  result[11] = a2[11];
  a2[11] = v13;
  uint64_t v14 = result[12];
  result[12] = a2[12];
  a2[12] = v14;
  uint64_t v15 = result[13];
  result[13] = a2[13];
  a2[13] = v15;
  uint64_t v16 = result[14];
  result[14] = a2[14];
  a2[14] = v16;
  uint64_t v17 = result[15];
  result[15] = a2[15];
  a2[15] = v17;
  return result;
}

void *as::server::ChangedObject::operator=(void *a1, void *a2)
{
  return a1;
}

void *as::server::ChangedObject::clear(as::server::ChangedObject *this)
{
  uint64_t v2 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v4 = (caulk::xstring *)*((void *)this + 1);
  uint64_t v3 = (void *)((char *)this + 8);
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)v3, v4);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100](v3 + 3);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100](v3 + 6);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100](v3 + 9);
  return std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100](v3 + 12);
}

uint64_t as::server::ChangedObject::isInitialized(as::server::ChangedObject *this)
{
  uint64_t v1 = *((void *)this + 16);
  if (!v1 || (~*(_DWORD *)(v1 + 8) & 3) != 0) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = *((void *)this + 5);
  if (v2 != v3)
  {
    while ((~*(_DWORD *)(*(void *)v2 + 8) & 7) == 0)
    {
      v2 += 8;
      if (v2 == v3) {
        goto LABEL_6;
      }
    }
    return 0;
  }
LABEL_6:
  uint64_t v4 = *((void *)this + 7);
  uint64_t v5 = *((void *)this + 8);
  if (v4 != v5)
  {
    while ((~*(_DWORD *)(*(void *)v4 + 8) & 3) == 0)
    {
      v4 += 8;
      if (v4 == v5) {
        goto LABEL_9;
      }
    }
    return 0;
  }
LABEL_9:
  uint64_t v6 = *((void *)this + 10);
  uint64_t v7 = *((void *)this + 11);
  if (v6 != v7)
  {
    while ((~*(_DWORD *)(*(void *)v6 + 8) & 3) == 0)
    {
      v6 += 8;
      if (v6 == v7) {
        goto LABEL_12;
      }
    }
    return 0;
  }
LABEL_12:
  uint64_t v8 = *((void *)this + 13);
  uint64_t v9 = *((void *)this + 14);
  if (v8 == v9) {
    return 1;
  }
  uint64_t v10 = v8 + 8;
  do
  {
    uint64_t result = as::server::ChangedObject::isInitialized(*(as::server::ChangedObject **)(v10 - 8));
    if (result) {
      BOOL v12 = v10 == v9;
    }
    else {
      BOOL v12 = 1;
    }
    v10 += 8;
  }
  while (!v12);
  return result;
}

BOOL as::server::ChangedObject::readFrom(uint64_t *a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    uint64_t v8 = a1 + 1;
    uint64_t v9 = (uint64_t)(a1 + 3);
    while (1)
    {
      uint64_t v10 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v11 = 0;
      unsigned int v12 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        unint64_t v14 = v2 + 1;
        a2[1] = v2 + 1;
        char v15 = *(unsigned char *)(v10 + v2);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0) {
          break;
        }
        v11 += 7;
        unint64_t v2 = v14;
        if (v12++ > 8) {
          goto LABEL_20;
        }
      }
LABEL_21:
      if ((v13 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      switch((v13 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          uint64_t v23 = (void *)a1[2];
          unint64_t v22 = a1[3];
          if ((unint64_t)v23 >= v22)
          {
            uint64_t v25 = ((uint64_t)v23 - *v8) >> 4;
            unint64_t v26 = v25 + 1;
            if ((unint64_t)(v25 + 1) >> 60) {
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v27 = v22 - *v8;
            if (v27 >> 3 > v26) {
              unint64_t v26 = v27 >> 3;
            }
            if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v28 = v26;
            }
            uint64_t v36 = v9;
            if (v28) {
              char v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v28);
            }
            else {
              char v29 = 0;
            }
            char v30 = &v29[16 * v25];
            std::string __p = v29;
            unint64_t v33 = v30;
            char v35 = &v29[16 * v28];
            *(void *)char v30 = 0;
            *((void *)v30 + 1) = 0;
            char v34 = v30 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
            uint64_t v24 = (void *)a1[2];
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *uint64_t v23 = 0;
            v23[1] = 0;
            uint64_t v24 = v23 + 2;
            a1[2] = (uint64_t)(v23 + 2);
          }
          a1[2] = (uint64_t)v24;
          std::string __p = 0;
          unint64_t v33 = 0;
          char v34 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          if (SHIBYTE(v34) < 0) {
            operator delete(__p);
          }
          break;
        case 3u:
          operator new();
        case 4u:
          operator new();
        case 5u:
          operator new();
        case 6u:
          operator new();
        default:
          break;
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v17 = 0;
    unsigned int v18 = 0;
    unint64_t v13 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v19 = v2 + 1;
      char v20 = *(unsigned char *)(v10 + v2);
      a2[1] = v19;
      v13 |= (unint64_t)(v20 & 0x7F) << v17;
      if ((v20 & 0x80) == 0) {
        goto LABEL_21;
      }
      v17 += 7;
      unint64_t v2 = v19;
      if (v18++ >= 9)
      {
LABEL_20:
        unint64_t v13 = 0;
        goto LABEL_21;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210ADB140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  _Unwind_Resume(a1);
}

void as::server::ChangedObject::writeTo(as::server::ChangedObject *this, PB::Writer *a2)
{
  int v4 = (const PB::Base *)*((void *)this + 16);
  if (v4) {
    PB::Writer::writeSubmessage(a2, v4);
  }
  uint64_t v5 = (caulk::xstring *)*((void *)this + 1);
  uint64_t v6 = (caulk::xstring *)*((void *)this + 2);
  while (v5 != v6)
  {
    uint64_t v7 = (char *)caulk::xstring::c_str(v5);
    std::string::basic_string[abi:ne180100]<0>(&__p, v7);
    PB::Writer::write();
    if (v21 < 0) {
      operator delete(__p);
    }
    uint64_t v5 = (caulk::xstring *)((char *)v5 + 16);
  }
  uint64_t v8 = (const PB::Base **)*((void *)this + 4);
  uint64_t v9 = (const PB::Base **)*((void *)this + 5);
  while (v8 != v9)
  {
    uint64_t v10 = *v8++;
    PB::Writer::writeSubmessage(a2, v10);
  }
  char v11 = (const PB::Base **)*((void *)this + 7);
  unsigned int v12 = (const PB::Base **)*((void *)this + 8);
  while (v11 != v12)
  {
    unint64_t v13 = *v11++;
    PB::Writer::writeSubmessage(a2, v13);
  }
  unint64_t v14 = (const PB::Base **)*((void *)this + 10);
  char v15 = (const PB::Base **)*((void *)this + 11);
  while (v14 != v15)
  {
    uint64_t v16 = *v14++;
    PB::Writer::writeSubmessage(a2, v16);
  }
  unsigned int v18 = (const PB::Base **)*((void *)this + 13);
  char v17 = (const PB::Base **)*((void *)this + 14);
  while (v18 != v17)
  {
    uint64_t v19 = *v18++;
    PB::Writer::writeSubmessage(a2, v19);
  }
}

void sub_210ADB314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::ChangedObject::formatText(as::server::ChangedObject *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 16);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "objectDescription");
  }
  uint64_t v6 = (caulk::xstring *)*((void *)this + 1);
  for (i = (caulk::xstring *)*((void *)this + 2); v6 != i; uint64_t v6 = (caulk::xstring *)((char *)v6 + 16))
  {
    uint64_t v8 = (char *)caulk::xstring::c_str(v6);
    std::string::basic_string[abi:ne180100]<0>(&__p, v8);
    PB::TextFormatter::format();
    if (v23 < 0) {
      operator delete(__p);
    }
  }
  uint64_t v9 = (uint64_t *)*((void *)this + 4);
  uint64_t v10 = (uint64_t *)*((void *)this + 5);
  while (v9 != v10)
  {
    uint64_t v11 = *v9++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v11 + 32))(v11, a2, "changedCustomProperties");
  }
  unsigned int v12 = (uint64_t *)*((void *)this + 7);
  unint64_t v13 = (uint64_t *)*((void *)this + 8);
  while (v12 != v13)
  {
    uint64_t v14 = *v12++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v14 + 32))(v14, a2, "createdChildren");
  }
  char v15 = (uint64_t *)*((void *)this + 10);
  uint64_t v16 = (uint64_t *)*((void *)this + 11);
  while (v15 != v16)
  {
    uint64_t v17 = *v15++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v17 + 32))(v17, a2, "destroyedChildren");
  }
  unsigned int v18 = (uint64_t *)*((void *)this + 13);
  uint64_t v19 = (uint64_t *)*((void *)this + 14);
  while (v18 != v19)
  {
    uint64_t v20 = *v18++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v20 + 32))(v20, a2, "changedChildren");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210ADB53C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::ChangedObject::operator==(void *a1, void *a2)
{
  uint64_t v4 = a1[16];
  uint64_t v5 = a2[16];
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 | v5) {
      return 0;
    }
  }
  else if (!as::server::ObjectDescription::operator==(v4, v5))
  {
    return 0;
  }
  uint64_t v8 = a1[1];
  uint64_t v7 = a1[2];
  unint64_t v9 = (v7 - v8) >> 4;
  if (v9 != (uint64_t)(a2[2] - a2[1]) >> 4) {
    return 0;
  }
  if (v7 != v8)
  {
    uint64_t v10 = 0;
    if (v9 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = (v7 - v8) >> 4;
    }
    while (!caulk::xstring::compare((caulk::xstring *)(a1[1] + v10), (const caulk::xstring *)(a2[1] + v10)))
    {
      v10 += 16;
      if (!--v11) {
        goto LABEL_16;
      }
    }
    return 0;
  }
LABEL_16:
  unint64_t v13 = (uint64_t *)a1[4];
  unsigned int v12 = (uint64_t *)a1[5];
  unint64_t v14 = v12 - v13;
  char v15 = (uint64_t *)a2[4];
  if (v14 != (uint64_t)(a2[5] - (void)v15) >> 3) {
    return 0;
  }
  if (v12 != v13)
  {
    if (v14 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v12 - v13;
    }
    do
    {
      uint64_t v17 = *v13;
      uint64_t v18 = *v15;
      if (*v13) {
        BOOL v19 = v18 == 0;
      }
      else {
        BOOL v19 = 1;
      }
      if (v19)
      {
        if (v17 | v18) {
          return 0;
        }
      }
      else if (!as::server::CustomPropertyAddress::operator==(v17, v18))
      {
        return 0;
      }
      ++v13;
      ++v15;
      --v16;
    }
    while (v16);
  }
  uint64_t v21 = a1[7];
  uint64_t v20 = a1[8];
  unint64_t v22 = (v20 - v21) >> 3;
  if (v22 != (uint64_t)(a2[8] - a2[7]) >> 3) {
    return 0;
  }
  if (v20 != v21)
  {
    uint64_t v23 = 0;
    if (v22 <= 1) {
      uint64_t v24 = 1;
    }
    else {
      uint64_t v24 = (v20 - v21) >> 3;
    }
    do
    {
      uint64_t v25 = *(void *)(a1[7] + 8 * v23);
      uint64_t v26 = *(void *)(a2[7] + 8 * v23);
      if (v25) {
        BOOL v27 = v26 == 0;
      }
      else {
        BOOL v27 = 1;
      }
      if (v27)
      {
        if (v25 | v26) {
          return 0;
        }
      }
      else if (!as::server::ObjectDescription::operator==(v25, v26))
      {
        return 0;
      }
      ++v23;
    }
    while (v24 != v23);
  }
  uint64_t v29 = a1[10];
  uint64_t v28 = a1[11];
  unint64_t v30 = (v28 - v29) >> 3;
  if (v30 != (uint64_t)(a2[11] - a2[10]) >> 3) {
    return 0;
  }
  if (v28 != v29)
  {
    uint64_t v31 = 0;
    if (v30 <= 1) {
      uint64_t v32 = 1;
    }
    else {
      uint64_t v32 = (v28 - v29) >> 3;
    }
    do
    {
      uint64_t v33 = *(void *)(a1[10] + 8 * v31);
      uint64_t v34 = *(void *)(a2[10] + 8 * v31);
      if (v33) {
        BOOL v35 = v34 == 0;
      }
      else {
        BOOL v35 = 1;
      }
      if (v35)
      {
        if (v33 | v34) {
          return 0;
        }
      }
      else if (!as::server::ObjectDescription::operator==(v33, v34))
      {
        return 0;
      }
      ++v31;
    }
    while (v32 != v31);
  }
  uint64_t v37 = a1[13];
  uint64_t v36 = a1[14];
  unint64_t v38 = (v36 - v37) >> 3;
  if (v38 != (uint64_t)(a2[14] - a2[13]) >> 3) {
    return 0;
  }
  if (v36 != v37)
  {
    BOOL v39 = 0;
    uint64_t v40 = 0;
    if (v38 <= 1) {
      uint64_t v41 = 1;
    }
    else {
      uint64_t v41 = (v36 - v37) >> 3;
    }
    while (1)
    {
      uint64_t v42 = *(void *)(a2[13] + 8 * v40);
      if (*(void *)(a1[13] + 8 * v40))
      {
        if (!v42 || !as::server::ChangedObject::operator==()) {
          return v39;
        }
      }
      else if (v42)
      {
        return v39;
      }
      BOOL v39 = ++v40 >= v38;
      if (v41 == v40) {
        return v39;
      }
    }
  }
  return 1;
}

uint64_t as::server::ChangedObject::clearObjectDescription(as::server::ChangedObject *this)
{
  uint64_t result = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::server::ChangedObject::addChangedCustomProperties(as::server::ChangedObject *this)
{
  unint64_t v4 = *((void *)this + 6);
  unint64_t v2 = (char *)this + 48;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::CustomPropertyAddress>>::__swap_out_circular_buffer(v7, v15);
    BOOL v6 = (void *)*((void *)this + 5);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    BOOL v6 = v5 + 1;
    *((void *)this + 5) = v6;
  }
  *((void *)this + 5) = v6;
  operator new();
}

void sub_210ADB948(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::ChangedObject::addCreatedChildren(as::server::ChangedObject *this)
{
  unint64_t v4 = *((void *)this + 9);
  unint64_t v2 = (char *)this + 72;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::ObjectDescription>>::__swap_out_circular_buffer(v7, v15);
    BOOL v6 = (void *)*((void *)this + 8);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    BOOL v6 = v5 + 1;
    *((void *)this + 8) = v6;
  }
  *((void *)this + 8) = v6;
  operator new();
}

void sub_210ADBAB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::ChangedObject::addDestroyedChildren(as::server::ChangedObject *this)
{
  unint64_t v4 = *((void *)this + 12);
  unint64_t v2 = (char *)this + 96;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::ObjectDescription>>::__swap_out_circular_buffer(v7, v15);
    BOOL v6 = (void *)*((void *)this + 11);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    BOOL v6 = v5 + 1;
    *((void *)this + 11) = v6;
  }
  *((void *)this + 11) = v6;
  operator new();
}

void sub_210ADBC28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::ChangedObject::addChangedChildren(as::server::ChangedObject *this)
{
  unint64_t v4 = *((void *)this + 15);
  unint64_t v2 = (char *)this + 120;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::ChangedObject>>::__swap_out_circular_buffer(v7, v15);
    BOOL v6 = (void *)*((void *)this + 14);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    BOOL v6 = v5 + 1;
    *((void *)this + 14) = v6;
  }
  *((void *)this + 14) = v6;
  operator new();
}

void sub_210ADBDA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

as::server::VirtualPort *as::server::VirtualPort::VirtualPort(as::server::VirtualPort *this, const as::server::VirtualPort *a2)
{
  *(void *)this = &unk_26C3128D8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::server::VirtualPort::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3128D8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  as::server::VirtualPort::copy_from(this, a2);
  return this;
}

uint64_t as::server::VirtualPort::copy_from(as::server::VirtualPort *this, const as::server::VirtualPort *a2)
{
  unint64_t v4 = (__n128 *)*((void *)a2 + 4);
  if (v4)
  {
    uint64_t v5 = (__n128 *)as::server::VirtualPort::mutableHwPortInvariants(this);
    as::server::PortInvariants::copy_from(v5, v4);
  }
  BOOL v6 = (const as::server::MicrophoneConfiguration *)*((void *)a2 + 5);
  if (v6)
  {
    active = (as::server::MicrophoneConfiguration *)as::server::VirtualPort::mutableActiveMicrophoneConfiguration(this);
    as::server::MicrophoneConfiguration::copy_from(active, v6);
  }
  uint64_t result = caulk::xstring::assign((as::server::VirtualPort *)((char *)this + 16), (const as::server::VirtualPort *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_WORD *)this + 24) = *((_WORD *)a2 + 24);
  return result;
}

uint64_t as::server::VirtualPort::hwPortInvariants(as::server::VirtualPort *this)
{
  uint64_t result = *((void *)this + 4);
  if (!result) {
    return as::server::PortInvariants::default_instance(0);
  }
  return result;
}

uint64_t as::server::VirtualPort::mutableHwPortInvariants(as::server::VirtualPort *this)
{
  if (!*((void *)this + 4)) {
    operator new();
  }
  return *((void *)this + 4);
}

uint64_t as::server::VirtualPort::activeMicrophoneConfiguration(as::server::VirtualPort *this)
{
  uint64_t result = *((void *)this + 5);
  if (!result) {
    return as::server::MicrophoneConfiguration::default_instance(0);
  }
  return result;
}

uint64_t as::server::VirtualPort::mutableActiveMicrophoneConfiguration(as::server::VirtualPort *this)
{
  if (!*((void *)this + 5)) {
    operator new();
  }
  return *((void *)this + 5);
}

as::server::MicrophoneConfiguration *as::server::MicrophoneConfiguration::operator=(as::server::MicrophoneConfiguration *a1, const as::server::MicrophoneConfiguration *a2)
{
  return a1;
}

uint64_t as::server::VirtualPort::VirtualPort(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C3128D8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  as::server::VirtualPort::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C3128D8;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  as::server::VirtualPort::move_from(a1, a2);
  return a1;
}

uint64_t as::server::VirtualPort::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v5;
  v7[0] = 0;
  v7[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)v7);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  return result;
}

uint64_t as::server::VirtualPort::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::server::VirtualPort::clear(as::server::VirtualPort *this)
{
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t result = caulk::xstring::clear((as::server::VirtualPort *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((_WORD *)this + 24) = 0;
  return result;
}

BOOL as::server::VirtualPort::isInitialized(as::server::VirtualPort *this)
{
  uint64_t v1 = *((void *)this + 4);
  return v1 && (~*(_DWORD *)(v1 + 8) & 0x7F) == 0 && (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::server::VirtualPort::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v3 + 1;
        a2[1] = v3 + 1;
        char v13 = *(unsigned char *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v3 = v12;
        if (v10++ > 8)
        {
          unint64_t v11 = 0;
          break;
        }
      }
LABEL_22:
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      switch((v11 >> 3))
      {
        case 1u:
          operator new();
        case 2u:
          if (v12 >= v2)
          {
            BOOL v22 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v21 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v22 = v21 != 0;
          }
          *(unsigned char *)(a1 + 48) = v22;
          int v25 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_35;
        case 3u:
          if (v12 >= v2)
          {
            BOOL v24 = 0;
            *((unsigned char *)a2 + 24) = 1;
          }
          else
          {
            int v23 = *(unsigned __int8 *)(v8 + v12);
            a2[1] = v12 + 1;
            BOOL v24 = v23 != 0;
          }
          *(unsigned char *)(a1 + 49) = v24;
          int v25 = *(_DWORD *)(a1 + 8) | 2;
LABEL_35:
          *(_DWORD *)(a1 + 8) = v25;
          break;
        case 4u:
          operator new();
        case 5u:
          PB::Reader::read();
          caulk::xstring::assign();
          *(_DWORD *)(a1 + 8) |= 4u;
          break;
        default:
          break;
      }
      unint64_t v3 = a2[1];
      unint64_t v2 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v3 <= v2) {
      unint64_t v17 = v2;
    }
    else {
      unint64_t v17 = v3;
    }
    while (v17 != v3)
    {
      unint64_t v18 = v3++;
      char v19 = *(unsigned char *)(v8 + v18);
      a2[1] = v3;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0) {
        goto LABEL_21;
      }
      v15 += 7;
      if (v16++ >= 9)
      {
        unint64_t v11 = 0;
LABEL_21:
        unint64_t v12 = v18 + 1;
        goto LABEL_22;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210ADC650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::server::VirtualPort::writeTo(as::server::VirtualPort *this, PB::Writer *a2)
{
  int v4 = (const PB::Base *)*((void *)this + 4);
  if (v4) {
    PB::Writer::writeSubmessage(a2, v4);
  }
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::Writer::write(a2);
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::Writer::write(a2);
  }
  BOOL v6 = (const PB::Base *)*((void *)this + 5);
  if (v6) {
    PB::Writer::writeSubmessage(a2, v6);
  }
  if ((*((unsigned char *)this + 8) & 4) != 0)
  {
    uint64_t v7 = (char *)caulk::xstring::c_str((as::server::VirtualPort *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v7);
    PB::Writer::write();
    if (v9 < 0) {
      operator delete(__p);
    }
  }
}

void sub_210ADC740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::VirtualPort::formatText(as::server::VirtualPort *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 4);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "hwPortInvariants");
  }
  int v6 = *((_DWORD *)this + 2);
  if (v6)
  {
    PB::TextFormatter::format(a2, "routable");
    int v6 = *((_DWORD *)this + 2);
  }
  if ((v6 & 2) != 0) {
    PB::TextFormatter::format(a2, "canSetRoutable");
  }
  uint64_t v7 = *((void *)this + 5);
  if (v7) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, a2, "activeMicrophoneConfiguration");
  }
  if ((*((unsigned char *)this + 8) & 4) != 0)
  {
    uint64_t v8 = (char *)caulk::xstring::c_str((as::server::VirtualPort *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v8);
    PB::TextFormatter::format();
    if (v11 < 0) {
      operator delete(__p);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210ADC884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::VirtualPort::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(unsigned __int16 *)(a1 + 48) != *(unsigned __int16 *)(a2 + 48)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a2 + 32);
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    if (v5 | v6) {
      return 0;
    }
  }
  else if (!as::server::PortInvariants::operator==(v5, v6))
  {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a2 + 40);
  if (v8 && v9)
  {
    if (as::server::MicrophoneConfiguration::operator==(v8, v9)) {
      return caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
    }
    return 0;
  }
  if (v8 | v9) {
    return 0;
  }
  return caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
}

uint64_t as::server::VirtualPort::clearHwPortInvariants(as::server::VirtualPort *this)
{
  uint64_t result = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::MicrophoneConfiguration::default_instance(as::server::MicrophoneConfiguration *this)
{
  {
    operator new();
  }
  return as::server::MicrophoneConfiguration::default_instance(void)::gInstance;
}

void sub_210ADCA24(_Unwind_Exception *a1)
{
}

double as::server::MicrophoneConfiguration::MicrophoneConfiguration(as::server::MicrophoneConfiguration *this)
{
  *(void *)this = &unk_26C312D70;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312D70;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

uint64_t as::server::VirtualPort::clearActiveMicrophoneConfiguration(as::server::VirtualPort *this)
{
  uint64_t result = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

as::server::MicrophoneConfiguration *as::server::MicrophoneConfiguration::MicrophoneConfiguration(as::server::MicrophoneConfiguration *this, const as::server::MicrophoneConfiguration *a2)
{
  *(void *)this = &unk_26C312D70;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 6) = 0;
  as::server::MicrophoneConfiguration::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312D70;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 6) = 0;
  as::server::MicrophoneConfiguration::copy_from(this, a2);
  return this;
}

__n128 as::server::MicrophoneConfiguration::copy_from(as::server::MicrophoneConfiguration *this, const as::server::MicrophoneConfiguration *a2)
{
  caulk::xstring::assign((as::server::MicrophoneConfiguration *)((char *)this + 40), (const as::server::MicrophoneConfiguration *)((char *)a2 + 40));
  if (this != a2) {
    std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((char *)this + 16, *((char **)a2 + 2), *((void *)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 2);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 56);
  *((unsigned char *)this + 72) = *((unsigned char *)a2 + 72);
  *(__n128 *)((char *)this + 56) = result;
  return result;
}

uint64_t as::server::MicrophoneConfiguration::MicrophoneConfiguration(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312D70;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 48) = 0;
  as::server::MicrophoneConfiguration::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312D70;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 48) = 0;
  as::server::MicrophoneConfiguration::move_from(a1, a2);
  return a1;
}

__n128 as::server::MicrophoneConfiguration::move_from(uint64_t a1, uint64_t a2)
{
  v8[0] = 0;
  v8[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)v8);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(__n128 *)(a1 + 56) = result;
  return result;
}

uint64_t as::server::MicrophoneConfiguration::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::server::MicrophoneConfiguration::clear(as::server::MicrophoneConfiguration *this)
{
  uint64_t result = caulk::xstring::clear((as::server::MicrophoneConfiguration *)((char *)this + 40));
  *((void *)this + 3) = *((void *)this + 2);
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 0;
  return result;
}

BOOL as::server::MicrophoneConfiguration::isInitialized(as::server::MicrophoneConfiguration *this)
{
  return (~*((_DWORD *)this + 2) & 0x3F) == 0;
}

BOOL as::server::MicrophoneConfiguration::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0) {
    return v4 == 0;
  }
  uint64_t v8 = (void **)(a1 + 16);
  uint64_t v9 = (void *)(a1 + 32);
  while (2)
  {
    uint64_t v10 = *a2;
    if (v3 <= 0xFFFFFFFFFFFFFFF5 && v3 + 10 <= v2)
    {
      char v11 = 0;
      unsigned int v12 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        unint64_t v14 = v3 + 1;
        a2[1] = v3 + 1;
        char v15 = *(unsigned char *)(v10 + v3);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0) {
          break;
        }
        v11 += 7;
        unint64_t v3 = v14;
        BOOL v50 = v12++ > 8;
        if (v50)
        {
          unint64_t v13 = 0;
          break;
        }
      }
      unint64_t v3 = v14;
      goto LABEL_24;
    }
    char v16 = 0;
    unsigned int v17 = 0;
    unint64_t v13 = 0;
    if (v3 <= v2) {
      unint64_t v18 = v2;
    }
    else {
      unint64_t v18 = v3;
    }
    do
    {
      if (v18 == v3)
      {
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
        return v4 == 0;
      }
      unint64_t v19 = v3++;
      char v20 = *(unsigned char *)(v10 + v19);
      a2[1] = v3;
      v13 |= (unint64_t)(v20 & 0x7F) << v16;
      if ((v20 & 0x80) == 0) {
        goto LABEL_23;
      }
      v16 += 7;
      BOOL v21 = v17++ >= 9;
    }
    while (!v21);
    unint64_t v13 = 0;
LABEL_23:
    unint64_t v3 = v19 + 1;
LABEL_24:
    if ((v13 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    switch((v13 >> 3))
    {
      case 1u:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v60 = 0;
          unsigned int v61 = 0;
          uint64_t v24 = 0;
          if (v2 <= v3) {
            unint64_t v25 = v3;
          }
          else {
            unint64_t v25 = v2;
          }
          while (v25 != v3)
          {
            unint64_t v62 = v3++;
            char v63 = *(unsigned char *)(v10 + v62);
            a2[1] = v3;
            v24 |= (unint64_t)(v63 & 0x7F) << v60;
            if ((v63 & 0x80) == 0) {
              goto LABEL_110;
            }
            v60 += 7;
            BOOL v21 = v61++ >= 9;
            if (v21)
            {
              LODWORD(v24) = 0;
LABEL_110:
              unint64_t v25 = v62 + 1;
              goto LABEL_152;
            }
          }
          LODWORD(v24) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v22 = 0;
          unsigned int v23 = 0;
          uint64_t v24 = 0;
          do
          {
            unint64_t v25 = v3 + 1;
            a2[1] = v3 + 1;
            char v26 = *(unsigned char *)(v10 + v3);
            v24 |= (unint64_t)(v26 & 0x7F) << v22;
            if ((v26 & 0x80) == 0) {
              goto LABEL_152;
            }
            v22 += 7;
            unint64_t v3 = v25;
            BOOL v50 = v23++ > 8;
          }
          while (!v50);
          LODWORD(v24) = 0;
        }
LABEL_152:
        *(_DWORD *)(a1 + 56) = v24;
        int v85 = *(_DWORD *)(a1 + 8) | 1;
        goto LABEL_159;
      case 2u:
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 2u;
        unint64_t v3 = a2[1];
        unint64_t v2 = a2[2];
        goto LABEL_160;
      case 3u:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v64 = 0;
          unsigned int v65 = 0;
          uint64_t v29 = 0;
          if (v2 <= v3) {
            unint64_t v25 = v3;
          }
          else {
            unint64_t v25 = v2;
          }
          while (v25 != v3)
          {
            unint64_t v66 = v3++;
            char v67 = *(unsigned char *)(v10 + v66);
            a2[1] = v3;
            v29 |= (unint64_t)(v67 & 0x7F) << v64;
            if ((v67 & 0x80) == 0) {
              goto LABEL_119;
            }
            v64 += 7;
            BOOL v21 = v65++ >= 9;
            if (v21)
            {
              LODWORD(v29) = 0;
LABEL_119:
              unint64_t v25 = v66 + 1;
              goto LABEL_154;
            }
          }
          LODWORD(v29) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v29 = 0;
          do
          {
            unint64_t v25 = v3 + 1;
            a2[1] = v3 + 1;
            char v30 = *(unsigned char *)(v10 + v3);
            v29 |= (unint64_t)(v30 & 0x7F) << v27;
            if ((v30 & 0x80) == 0) {
              goto LABEL_154;
            }
            v27 += 7;
            unint64_t v3 = v25;
            BOOL v50 = v28++ > 8;
          }
          while (!v50);
          LODWORD(v29) = 0;
        }
LABEL_154:
        *(_DWORD *)(a1 + 60) = v29;
        int v85 = *(_DWORD *)(a1 + 8) | 4;
        goto LABEL_159;
      case 4u:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v68 = 0;
          unsigned int v69 = 0;
          uint64_t v33 = 0;
          if (v2 <= v3) {
            unint64_t v25 = v3;
          }
          else {
            unint64_t v25 = v2;
          }
          while (v25 != v3)
          {
            unint64_t v70 = v3++;
            char v71 = *(unsigned char *)(v10 + v70);
            a2[1] = v3;
            v33 |= (unint64_t)(v71 & 0x7F) << v68;
            if ((v71 & 0x80) == 0) {
              goto LABEL_128;
            }
            v68 += 7;
            BOOL v21 = v69++ >= 9;
            if (v21)
            {
              LODWORD(v33) = 0;
LABEL_128:
              unint64_t v25 = v70 + 1;
              goto LABEL_156;
            }
          }
          LODWORD(v33) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v31 = 0;
          unsigned int v32 = 0;
          uint64_t v33 = 0;
          do
          {
            unint64_t v25 = v3 + 1;
            a2[1] = v3 + 1;
            char v34 = *(unsigned char *)(v10 + v3);
            v33 |= (unint64_t)(v34 & 0x7F) << v31;
            if ((v34 & 0x80) == 0) {
              goto LABEL_156;
            }
            v31 += 7;
            unint64_t v3 = v25;
            BOOL v50 = v32++ > 8;
          }
          while (!v50);
          LODWORD(v33) = 0;
        }
LABEL_156:
        *(_DWORD *)(a1 + 64) = v33;
        int v85 = *(_DWORD *)(a1 + 8) | 8;
        goto LABEL_159;
      case 5u:
        if ((v13 & 7) != 2)
        {
          char v73 = *(char **)(a1 + 24);
          unint64_t v72 = *(void *)(a1 + 32);
          if ((unint64_t)v73 >= v72)
          {
            unint64_t v79 = (char *)*v8;
            uint64_t v80 = (v73 - (unsigned char *)*v8) >> 2;
            unint64_t v81 = v80 + 1;
            if ((unint64_t)(v80 + 1) >> 62) {
LABEL_195:
            }
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            uint64_t v82 = v72 - (void)v79;
            if (v82 >> 1 > v81) {
              unint64_t v81 = v82 >> 1;
            }
            if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v83 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v83 = v81;
            }
            if (v83)
            {
              char v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v83);
              unint64_t v79 = *(char **)(a1 + 16);
              char v73 = *(char **)(a1 + 24);
            }
            else
            {
              char v84 = 0;
            }
            unsigned int v86 = &v84[4 * v80];
            *(_DWORD *)unsigned int v86 = 0;
            unsigned int v74 = v86 + 4;
            while (v73 != v79)
            {
              int v87 = *((_DWORD *)v73 - 1);
              v73 -= 4;
              *((_DWORD *)v86 - 1) = v87;
              v86 -= 4;
            }
            *(void *)(a1 + 16) = v86;
            *(void *)(a1 + 24) = v74;
            *(void *)(a1 + 32) = &v84[4 * v83];
            if (v79) {
              operator delete(v79);
            }
          }
          else
          {
            *(_DWORD *)char v73 = 0;
            unsigned int v74 = v73 + 4;
          }
          *(void *)(a1 + 24) = v74;
          unint64_t v88 = a2[1];
          unint64_t v2 = a2[2];
          uint64_t v89 = *a2;
          char v90 = 0;
          unsigned int v91 = 0;
          uint64_t v92 = 0;
          if (v88 > 0xFFFFFFFFFFFFFFF5 || v88 + 10 > v2)
          {
            if (v2 <= v88) {
              unint64_t v3 = a2[1];
            }
            else {
              unint64_t v3 = a2[2];
            }
            while (1)
            {
              if (v3 == v88)
              {
                LODWORD(v92) = 0;
                *((unsigned char *)a2 + 24) = 1;
                goto LABEL_190;
              }
              unint64_t v94 = v88++;
              char v95 = *(unsigned char *)(v89 + v94);
              a2[1] = v88;
              v92 |= (unint64_t)(v95 & 0x7F) << v90;
              if ((v95 & 0x80) == 0) {
                break;
              }
              v90 += 7;
              BOOL v50 = v91++ > 8;
              if (v50)
              {
                LODWORD(v92) = 0;
                goto LABEL_189;
              }
            }
            if (*((unsigned char *)a2 + 24)) {
              LODWORD(v92) = 0;
            }
LABEL_189:
            unint64_t v3 = v94 + 1;
          }
          else
          {
            do
            {
              unint64_t v3 = v88 + 1;
              a2[1] = v88 + 1;
              char v96 = *(unsigned char *)(v89 + v88);
              v92 |= (unint64_t)(v96 & 0x7F) << v90;
              if ((v96 & 0x80) == 0) {
                goto LABEL_190;
              }
              v90 += 7;
              unint64_t v88 = v3;
              BOOL v50 = v91++ > 8;
            }
            while (!v50);
            LODWORD(v92) = 0;
          }
LABEL_190:
          *(v74 - 1) = v92;
          goto LABEL_160;
        }
        if ((PB::Reader::placeMark() & 1) == 0)
        {
          unint64_t v3 = a2[1];
          unint64_t v2 = a2[2];
          if (v3 < v2 && !*((unsigned char *)a2 + 24))
          {
            BOOL v35 = *(char **)(a1 + 24);
            do
            {
              if ((unint64_t)v35 >= *v9)
              {
                uint64_t v36 = (char *)*v8;
                uint64_t v37 = (v35 - (unsigned char *)*v8) >> 2;
                unint64_t v38 = v37 + 1;
                if ((unint64_t)(v37 + 1) >> 62) {
                  goto LABEL_195;
                }
                uint64_t v39 = *v9 - (void)v36;
                if (v39 >> 1 > v38) {
                  unint64_t v38 = v39 >> 1;
                }
                if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v40 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v40 = v38;
                }
                if (v40)
                {
                  uint64_t v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v40);
                  uint64_t v36 = *(char **)(a1 + 16);
                  BOOL v35 = *(char **)(a1 + 24);
                }
                else
                {
                  uint64_t v41 = 0;
                }
                uint64_t v42 = &v41[4 * v37];
                *(_DWORD *)uint64_t v42 = 0;
                char v43 = v42 + 4;
                while (v35 != v36)
                {
                  int v44 = *((_DWORD *)v35 - 1);
                  v35 -= 4;
                  *((_DWORD *)v42 - 1) = v44;
                  v42 -= 4;
                }
                *(void *)(a1 + 16) = v42;
                *(void *)(a1 + 24) = v43;
                *(void *)(a1 + 32) = &v41[4 * v40];
                if (v36) {
                  operator delete(v36);
                }
                BOOL v35 = v43;
              }
              else
              {
                *(_DWORD *)BOOL v35 = 0;
                v35 += 4;
              }
              *(void *)(a1 + 24) = v35;
              unint64_t v45 = a2[1];
              unint64_t v2 = a2[2];
              uint64_t v46 = *a2;
              char v47 = 0;
              unsigned int v48 = 0;
              uint64_t v49 = 0;
              BOOL v50 = v45 > 0xFFFFFFFFFFFFFFF5 || v45 + 10 > v2;
              if (!v50)
              {
                while (1)
                {
                  unint64_t v3 = v45 + 1;
                  a2[1] = v45 + 1;
                  char v53 = *(unsigned char *)(v46 + v45);
                  v49 |= (unint64_t)(v53 & 0x7F) << v47;
                  if ((v53 & 0x80) == 0) {
                    goto LABEL_90;
                  }
                  v47 += 7;
                  unint64_t v45 = v3;
                  BOOL v50 = v48++ > 8;
                  if (v50)
                  {
                    LODWORD(v49) = 0;
                    goto LABEL_90;
                  }
                }
              }
              if (v2 <= v45) {
                unint64_t v3 = a2[1];
              }
              else {
                unint64_t v3 = a2[2];
              }
              while (1)
              {
                if (v3 == v45)
                {
                  *((unsigned char *)a2 + 24) = 1;
                  *((_DWORD *)v35 - 1) = 0;
                  goto LABEL_160;
                }
                unint64_t v51 = v45++;
                char v52 = *(unsigned char *)(v46 + v51);
                a2[1] = v45;
                v49 |= (unint64_t)(v52 & 0x7F) << v47;
                if ((v52 & 0x80) == 0) {
                  break;
                }
                v47 += 7;
                BOOL v50 = v48++ > 8;
                if (v50)
                {
                  LODWORD(v49) = 0;
                  goto LABEL_89;
                }
              }
              if (*((unsigned char *)a2 + 24)) {
                LODWORD(v49) = 0;
              }
LABEL_89:
              unint64_t v3 = v51 + 1;
LABEL_90:
              *((_DWORD *)v35 - 1) = v49;
            }
            while (v3 < v2 && !*((unsigned char *)a2 + 24));
          }
LABEL_160:
          int v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
            return v4 == 0;
          }
          continue;
        }
        return 0;
      case 6u:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v75 = 0;
          unsigned int v76 = 0;
          uint64_t v56 = 0;
          if (v2 <= v3) {
            unint64_t v25 = v3;
          }
          else {
            unint64_t v25 = v2;
          }
          while (v25 != v3)
          {
            unint64_t v77 = v3++;
            char v78 = *(unsigned char *)(v10 + v77);
            a2[1] = v3;
            v56 |= (unint64_t)(v78 & 0x7F) << v75;
            if ((v78 & 0x80) == 0) {
              goto LABEL_139;
            }
            v75 += 7;
            BOOL v21 = v76++ >= 9;
            if (v21)
            {
              LODWORD(v56) = 0;
LABEL_139:
              unint64_t v25 = v77 + 1;
              goto LABEL_158;
            }
          }
          LODWORD(v56) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v54 = 0;
          unsigned int v55 = 0;
          uint64_t v56 = 0;
          do
          {
            unint64_t v25 = v3 + 1;
            a2[1] = v3 + 1;
            char v57 = *(unsigned char *)(v10 + v3);
            v56 |= (unint64_t)(v57 & 0x7F) << v54;
            if ((v57 & 0x80) == 0) {
              goto LABEL_158;
            }
            v54 += 7;
            unint64_t v3 = v25;
            BOOL v50 = v55++ > 8;
          }
          while (!v50);
          LODWORD(v56) = 0;
        }
LABEL_158:
        *(_DWORD *)(a1 + 68) = v56;
        int v85 = *(_DWORD *)(a1 + 8) | 0x10;
LABEL_159:
        *(_DWORD *)(a1 + 8) = v85;
        unint64_t v3 = v25;
        goto LABEL_160;
      case 7u:
        if (v3 >= v2)
        {
          BOOL v59 = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          int v58 = *(unsigned __int8 *)(v10 + v3++);
          a2[1] = v3;
          BOOL v59 = v58 != 0;
        }
        *(unsigned char *)(a1 + 72) = v59;
        *(_DWORD *)(a1 + 8) |= 0x20u;
        goto LABEL_160;
      default:
        goto LABEL_160;
    }
  }
}

void sub_210ADD64C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::server::MicrophoneConfiguration::writeTo(as::server::MicrophoneConfiguration *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v5 = (char *)caulk::xstring::c_str((as::server::MicrophoneConfiguration *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v10 < 0) {
      operator delete(__p);
    }
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 4) != 0)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 8) != 0) {
    PB::Writer::writeVarInt(a2);
  }
  uint64_t v6 = *((void *)this + 2);
  uint64_t v7 = *((void *)this + 3);
  while (v6 != v7)
  {
    v6 += 4;
    PB::Writer::writeVarInt(a2);
  }
  int v8 = *((_DWORD *)this + 2);
  if ((v8 & 0x10) != 0)
  {
    PB::Writer::writeVarInt(a2);
    int v8 = *((_DWORD *)this + 2);
  }
  if ((v8 & 0x20) != 0) {
    PB::Writer::write(a2);
  }
}

void sub_210ADD78C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::MicrophoneConfiguration::formatText(as::server::MicrophoneConfiguration *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "configurationID");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::server::MicrophoneConfiguration *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v12 < 0) {
      operator delete(__p);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 4) != 0)
  {
    PB::TextFormatter::format(a2, "location");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 8) != 0) {
    PB::TextFormatter::format(a2, "orientation");
  }
  uint64_t v7 = *((void *)this + 2);
  uint64_t v8 = *((void *)this + 3);
  while (v7 != v8)
  {
    v7 += 4;
    PB::TextFormatter::format(a2, "availablePolarPatterns");
  }
  int v9 = *((_DWORD *)this + 2);
  if ((v9 & 0x10) != 0)
  {
    PB::TextFormatter::format(a2, "activePolarPattern");
    int v9 = *((_DWORD *)this + 2);
  }
  if ((v9 & 0x20) != 0) {
    PB::TextFormatter::format(a2, "SDKClientVisible");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210ADD8F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::MicrophoneConfiguration::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  BOOL v4 = *(void *)(a1 + 56) == *(void *)(a2 + 56) && *(void *)(a1 + 64) == *(void *)(a2 + 64);
  if (!v4 || *(unsigned __int8 *)(a1 + 72) != (unint64_t)*(unsigned __int8 *)(a2 + 72)) {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 40), (const caulk::xstring *)(a2 + 40))) {
    return 0;
  }
  uint64_t v6 = *(_DWORD **)(a1 + 16);
  uint64_t v7 = *(_DWORD **)(a1 + 24);
  unint64_t v8 = v7 - v6;
  int v9 = *(_DWORD **)(a2 + 16);
  if (v8 != (uint64_t)(*(void *)(a2 + 24) - (void)v9) >> 2) {
    return 0;
  }
  if (v7 == v6) {
    return 1;
  }
  uint64_t v10 = v8 <= 1 ? 1 : v7 - v6;
  if (*v6 != *v9) {
    return 0;
  }
  uint64_t v11 = 1;
  do
  {
    unint64_t v12 = v11;
    if (v10 == v11) {
      break;
    }
    int v13 = v6[v11];
    int v14 = v9[v11++];
  }
  while (v13 == v14);
  return v12 >= v8;
}

as::server::IOControllerState *as::server::IOControllerState::IOControllerState(as::server::IOControllerState *this, const as::server::IOControllerState *a2)
{
  *(void *)this = &unk_26C312BB0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  as::server::IOControllerState::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312BB0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  as::server::IOControllerState::copy_from(this, a2);
  return this;
}

__n128 as::server::IOControllerState::copy_from(as::server::IOControllerState *this, const as::server::IOControllerState *a2)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    operator new();
  }
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 8);
  if (*((void *)a2 + 8) != *((void *)a2 + 9)) {
    operator new();
  }
  caulk::xstring::assign((as::server::IOControllerState *)((char *)this + 88), (const as::server::IOControllerState *)((char *)a2 + 88));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 120);
  *(__n128 *)((char *)this + 104) = result;
  return result;
}

void sub_210ADDE08(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

uint64_t as::server::IOControllerState::IOControllerState(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312BB0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0;
  as::server::IOControllerState::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312BB0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0;
  as::server::IOControllerState::move_from(a1, a2);
  return a1;
}

__n128 as::server::IOControllerState::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  uint64_t v7 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v7;
  uint64_t v8 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v8;
  uint64_t v9 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v9;
  uint64_t v10 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v10;
  uint64_t v11 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v11;
  uint64_t v12 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v12;
  v14[0] = 0;
  v14[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)v14);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 104);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(__n128 *)(a1 + 104) = result;
  return result;
}

uint64_t as::server::IOControllerState::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

double as::server::IOControllerState::clear(as::server::IOControllerState *this)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 8);
  caulk::xstring::clear((as::server::IOControllerState *)((char *)this + 88));
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  return result;
}

BOOL as::server::IOControllerState::isInitialized(as::server::IOControllerState *this)
{
  unint64_t v2 = (as::SampleRateRange **)*((void *)this + 2);
  unint64_t v3 = (as::SampleRateRange **)*((void *)this + 3);
  while (v2 != v3)
  {
    if (!as::SampleRateRange::isInitialized(*v2)) {
      return 0;
    }
    ++v2;
  }
  uint64_t v4 = (as::server::IOStreamState **)*((void *)this + 5);
  uint64_t v5 = (as::server::IOStreamState **)*((void *)this + 6);
  while (v4 != v5)
  {
    if ((as::server::IOStreamState::isInitialized(*v4) & 1) == 0) {
      return 0;
    }
    ++v4;
  }
  uint64_t v6 = (as::server::IOStreamState **)*((void *)this + 8);
  uint64_t v7 = (as::server::IOStreamState **)*((void *)this + 9);
  while (v6 != v7)
  {
    if ((as::server::IOStreamState::isInitialized(*v6) & 1) == 0) {
      return 0;
    }
    ++v6;
  }
  return (~*((_DWORD *)this + 2) & 0xF) == 0;
}

BOOL as::server::IOControllerState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v15 = 0;
        unsigned int v16 = 0;
        unint64_t v11 = 0;
        if (v3 <= v2) {
          unint64_t v17 = v2;
        }
        else {
          unint64_t v17 = v3;
        }
        while (v17 != v3)
        {
          unint64_t v18 = v3++;
          char v19 = *(unsigned char *)(v8 + v18);
          a2[1] = v3;
          v11 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0) {
            goto LABEL_21;
          }
          v15 += 7;
          BOOL v20 = v16++ >= 9;
          if (v20)
          {
            unint64_t v11 = 0;
LABEL_21:
            unint64_t v12 = v18 + 1;
            goto LABEL_22;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v9 = 0;
        unsigned int v10 = 0;
        unint64_t v11 = 0;
        while (1)
        {
          unint64_t v12 = v3 + 1;
          a2[1] = v3 + 1;
          char v13 = *(unsigned char *)(v8 + v3);
          v11 |= (unint64_t)(v13 & 0x7F) << v9;
          if ((v13 & 0x80) == 0) {
            break;
          }
          v9 += 7;
          unint64_t v3 = v12;
          BOOL v14 = v10++ > 8;
          if (v14)
          {
            unint64_t v11 = 0;
            break;
          }
        }
LABEL_22:
        if ((v11 & 7) != 4)
        {
          switch((v11 >> 3))
          {
            case 2u:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v21 = 0;
                unsigned int v22 = 0;
                uint64_t v23 = 0;
                do
                {
                  unint64_t v24 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v25 = *(unsigned char *)(v8 + v12);
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if ((v25 & 0x80) == 0) {
                    goto LABEL_73;
                  }
                  v21 += 7;
                  unint64_t v12 = v24;
                  BOOL v14 = v22++ > 8;
                }
                while (!v14);
LABEL_60:
                LODWORD(v23) = 0;
                goto LABEL_73;
              }
              char v32 = 0;
              unsigned int v33 = 0;
              uint64_t v23 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v34 = v12 + 1;
                char v35 = *(unsigned char *)(v8 + v12);
                a2[1] = v34;
                v23 |= (unint64_t)(v35 & 0x7F) << v32;
                if ((v35 & 0x80) == 0) {
                  goto LABEL_73;
                }
                v32 += 7;
                unint64_t v12 = v34;
                BOOL v20 = v33++ >= 9;
                if (v20) {
                  goto LABEL_60;
                }
              }
              LODWORD(v23) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_73:
              *(_DWORD *)(a1 + 132) = v23;
              int v31 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_76;
            case 3u:
            case 4u:
            case 5u:
            case 6u:
            case 7u:
            case 8u:
            case 9u:
            case 0xFu:
            case 0x10u:
            case 0x11u:
            case 0x12u:
            case 0x13u:
              goto LABEL_77;
            case 0xAu:
              if (v12 > 0xFFFFFFFFFFFFFFF7 || v12 + 8 > v2)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(void *)(a1 + 104) = *(void *)(v8 + v12);
                a2[1] += 8;
              }
              int v31 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_76;
            case 0xBu:
              operator new();
            case 0xCu:
              if (v12 > 0xFFFFFFFFFFFFFFF7 || v12 + 8 > v2)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(void *)(a1 + 112) = *(void *)(v8 + v12);
                a2[1] += 8;
              }
              int v31 = *(_DWORD *)(a1 + 8) | 4;
              goto LABEL_76;
            case 0xDu:
              if (v12 > 0xFFFFFFFFFFFFFFF7 || v12 + 8 > v2)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(void *)(a1 + 120) = *(void *)(v8 + v12);
                a2[1] += 8;
              }
              int v31 = *(_DWORD *)(a1 + 8) | 8;
              goto LABEL_76;
            case 0xEu:
              if (v12 <= 0xFFFFFFFFFFFFFFF5 && v12 + 10 <= v2)
              {
                char v26 = 0;
                unsigned int v27 = 0;
                uint64_t v28 = 0;
                do
                {
                  unint64_t v29 = v12 + 1;
                  a2[1] = v12 + 1;
                  char v30 = *(unsigned char *)(v8 + v12);
                  v28 |= (unint64_t)(v30 & 0x7F) << v26;
                  if ((v30 & 0x80) == 0) {
                    goto LABEL_75;
                  }
                  v26 += 7;
                  unint64_t v12 = v29;
                  BOOL v14 = v27++ > 8;
                }
                while (!v14);
LABEL_71:
                LODWORD(v28) = 0;
                goto LABEL_75;
              }
              char v36 = 0;
              unsigned int v37 = 0;
              uint64_t v28 = 0;
              if (v2 <= v12) {
                unint64_t v2 = v12;
              }
              while (v2 != v12)
              {
                unint64_t v38 = v12 + 1;
                char v39 = *(unsigned char *)(v8 + v12);
                a2[1] = v38;
                v28 |= (unint64_t)(v39 & 0x7F) << v36;
                if ((v39 & 0x80) == 0) {
                  goto LABEL_75;
                }
                v36 += 7;
                unint64_t v12 = v38;
                BOOL v20 = v37++ >= 9;
                if (v20) {
                  goto LABEL_71;
                }
              }
              LODWORD(v28) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_75:
              *(_DWORD *)(a1 + 128) = v28;
              int v31 = *(_DWORD *)(a1 + 8) | 0x10;
LABEL_76:
              *(_DWORD *)(a1 + 8) = v31;
LABEL_77:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 0x14u:
              operator new();
            case 0x15u:
              operator new();
            default:
              if ((v11 >> 3) == 30)
              {
                PB::Reader::read();
                caulk::xstring::assign();
                *(_DWORD *)(a1 + 8) |= 0x20u;
              }
              goto LABEL_77;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210ADE8E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void as::server::IOControllerState::writeTo(as::server::IOControllerState *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0) {
    PB::Writer::write(a2, *((double *)this + 13));
  }
  uint64_t v5 = (const PB::Base **)*((void *)this + 2);
  uint64_t v6 = (const PB::Base **)*((void *)this + 3);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    PB::Writer::writeSubmessage(a2, v7);
  }
  int v8 = *((_DWORD *)this + 2);
  if ((v8 & 4) == 0)
  {
    if ((v8 & 8) == 0) {
      goto LABEL_10;
    }
LABEL_23:
    PB::Writer::write(a2, *((double *)this + 15));
    if ((*((_DWORD *)this + 2) & 0x10) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  PB::Writer::write(a2, *((double *)this + 14));
  int v8 = *((_DWORD *)this + 2);
  if ((v8 & 8) != 0) {
    goto LABEL_23;
  }
LABEL_10:
  if ((v8 & 0x10) != 0) {
LABEL_11:
  }
    PB::Writer::writeVarInt(a2);
LABEL_12:
  char v9 = (const PB::Base **)*((void *)this + 5);
  unsigned int v10 = (const PB::Base **)*((void *)this + 6);
  while (v9 != v10)
  {
    unint64_t v11 = *v9++;
    PB::Writer::writeSubmessage(a2, v11);
  }
  unint64_t v12 = (const PB::Base **)*((void *)this + 8);
  char v13 = (const PB::Base **)*((void *)this + 9);
  while (v12 != v13)
  {
    BOOL v14 = *v12++;
    PB::Writer::writeSubmessage(a2, v14);
  }
  if ((*((unsigned char *)this + 8) & 0x20) != 0)
  {
    uint64_t v15 = (char *)caulk::xstring::c_str((as::server::IOControllerState *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(&__p, v15);
    PB::Writer::write();
    if (v17 < 0) {
      operator delete(__p);
    }
  }
}

void sub_210ADEB0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::IOControllerState::formatText(as::server::IOControllerState *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "type");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "sampleRate", *((double *)this + 13));
  }
  uint64_t v6 = (uint64_t *)*((void *)this + 2);
  uint64_t v7 = (uint64_t *)*((void *)this + 3);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "availableSampleRates");
  }
  int v9 = *((_DWORD *)this + 2);
  if ((v9 & 4) != 0)
  {
    PB::TextFormatter::format(a2, "minimumSampleRate", *((double *)this + 14));
    int v9 = *((_DWORD *)this + 2);
    if ((v9 & 8) == 0)
    {
LABEL_9:
      if ((v9 & 0x10) == 0) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }
  else if ((v9 & 8) == 0)
  {
    goto LABEL_9;
  }
  PB::TextFormatter::format(a2, "maximumSampleRate", *((double *)this + 15));
  if ((*((_DWORD *)this + 2) & 0x10) != 0) {
LABEL_10:
  }
    PB::TextFormatter::format(a2, "bufferFrameSize");
LABEL_11:
  unsigned int v10 = (uint64_t *)*((void *)this + 5);
  unint64_t v11 = (uint64_t *)*((void *)this + 6);
  while (v10 != v11)
  {
    uint64_t v12 = *v10++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v12 + 32))(v12, a2, "inputIOStreams");
  }
  char v13 = (uint64_t *)*((void *)this + 8);
  BOOL v14 = (uint64_t *)*((void *)this + 9);
  while (v13 != v14)
  {
    uint64_t v15 = *v13++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v15 + 32))(v15, a2, "outputIOStreams");
  }
  if ((*((unsigned char *)this + 8) & 0x20) != 0)
  {
    unsigned int v16 = (char *)caulk::xstring::c_str((as::server::IOControllerState *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(&__p, v16);
    PB::TextFormatter::format();
    if (v19 < 0) {
      operator delete(__p);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210ADED34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::IOControllerState::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  BOOL v4 = *(void *)(a1 + 104) == *(void *)(a2 + 104) && *(void *)(a1 + 112) == *(void *)(a2 + 112);
  BOOL v5 = v4 && *(void *)(a1 + 120) == *(void *)(a2 + 120);
  if (!v5 || *(void *)(a1 + 128) != *(void *)(a2 + 128)) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  unint64_t v9 = (v7 - v8) >> 3;
  if (v9 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3) {
    return 0;
  }
  if (v7 != v8)
  {
    uint64_t v10 = 0;
    if (v9 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = (v7 - v8) >> 3;
    }
    do
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 16) + 8 * v10);
      uint64_t v13 = *(void *)(*(void *)(a2 + 16) + 8 * v10);
      if (v12) {
        BOOL v14 = v13 == 0;
      }
      else {
        BOOL v14 = 1;
      }
      if (v14)
      {
        if (v12 | v13) {
          return 0;
        }
      }
      else if (!as::SampleRateRange::operator==(v12, v13))
      {
        return 0;
      }
      ++v10;
    }
    while (v11 != v10);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v15 = *(void *)(a1 + 48);
  unint64_t v17 = (v15 - v16) >> 3;
  if (v17 != (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3) {
    return 0;
  }
  if (v15 != v16)
  {
    uint64_t v18 = 0;
    if (v17 <= 1) {
      uint64_t v19 = 1;
    }
    else {
      uint64_t v19 = (v15 - v16) >> 3;
    }
    do
    {
      uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8 * v18);
      uint64_t v21 = *(void *)(*(void *)(a2 + 40) + 8 * v18);
      if (v20) {
        BOOL v22 = v21 == 0;
      }
      else {
        BOOL v22 = 1;
      }
      if (v22)
      {
        if (v20 | v21) {
          return 0;
        }
      }
      else if (!as::server::IOStreamState::operator==(v20, v21))
      {
        return 0;
      }
      ++v18;
    }
    while (v19 != v18);
  }
  uint64_t v24 = *(void *)(a1 + 64);
  uint64_t v23 = *(void *)(a1 + 72);
  unint64_t v25 = (v23 - v24) >> 3;
  if (v25 != (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 3) {
    return 0;
  }
  if (v23 != v24)
  {
    uint64_t v26 = 0;
    if (v25 <= 1) {
      uint64_t v27 = 1;
    }
    else {
      uint64_t v27 = (v23 - v24) >> 3;
    }
    do
    {
      uint64_t v28 = *(void *)(*(void *)(a1 + 64) + 8 * v26);
      uint64_t v29 = *(void *)(*(void *)(a2 + 64) + 8 * v26);
      if (v28) {
        BOOL v30 = v29 == 0;
      }
      else {
        BOOL v30 = 1;
      }
      if (v30)
      {
        if (v28 | v29) {
          return 0;
        }
      }
      else if (!as::server::IOStreamState::operator==(v28, v29))
      {
        return 0;
      }
      ++v26;
    }
    while (v27 != v26);
  }
  return caulk::xstring::compare((caulk::xstring *)(a1 + 88), (const caulk::xstring *)(a2 + 88)) == 0;
}

void as::server::IOControllerState::addAvailableSampleRates(as::server::IOControllerState *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  BOOL v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)BOOL v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::SampleRateRange>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *BOOL v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210ADF03C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::IOControllerState::addInputIOStreams(as::server::IOControllerState *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  BOOL v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)BOOL v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::IOStreamState>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *BOOL v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210ADF1A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::IOControllerState::addOutputIOStreams(as::server::IOControllerState *this)
{
  unint64_t v4 = *((void *)this + 10);
  unint64_t v2 = (char *)this + 80;
  unint64_t v3 = v4;
  BOOL v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)BOOL v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::IOStreamState>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 9);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *BOOL v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 9) = v6;
  }
  *((void *)this + 9) = v6;
  operator new();
}

void sub_210ADF314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::PlatformSupport::default_instance(as::server::PlatformSupport *this)
{
  {
    operator new();
  }
  return as::server::PlatformSupport::default_instance(void)::gInstance;
}

void sub_210ADF3C4(_Unwind_Exception *a1)
{
}

double as::server::PlatformSupport::PlatformSupport(as::server::PlatformSupport *this)
{
  *(void *)this = &unk_26C312A98;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312A98;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  return result;
}

as::server::PlatformSupport *as::server::PlatformSupport::PlatformSupport(as::server::PlatformSupport *this, caulk::xstring **a2)
{
  *(void *)this = &unk_26C312A98;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  as::server::PlatformSupport::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312A98;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  as::server::PlatformSupport::copy_from(this, a2);
  return this;
}

caulk::xstring *as::server::PlatformSupport::copy_from(caulk::xstring *this, caulk::xstring **a2)
{
  if (this != (caulk::xstring *)a2)
  {
    unint64_t v3 = this;
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)this + 8, a2[1], a2[2], (a2[2] - a2[1]) >> 4);
    return std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)v3 + 32, a2[4], a2[5], (a2[5] - a2[4]) >> 4);
  }
  return this;
}

caulk::xstring *as::server::PlatformSupport::operator=(caulk::xstring *a1, caulk::xstring **a2)
{
  return a1;
}

uint64_t as::server::PlatformSupport::PlatformSupport(uint64_t a1, void *a2)
{
  *(void *)a1 = &unk_26C312A98;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  as::server::PlatformSupport::move_from((void *)a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312A98;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  as::server::PlatformSupport::move_from((void *)a1, a2);
  return a1;
}

void *as::server::PlatformSupport::move_from(void *result, void *a2)
{
  uint64_t v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  uint64_t v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  uint64_t v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  uint64_t v5 = result[4];
  result[4] = a2[4];
  a2[4] = v5;
  uint64_t v6 = result[5];
  result[5] = a2[5];
  a2[5] = v6;
  uint64_t v7 = result[6];
  result[6] = a2[6];
  a2[6] = v7;
  return result;
}

void *as::server::PlatformSupport::operator=(void *a1, void *a2)
{
  return a1;
}

uint64_t as::server::PlatformSupport::clear(caulk::xstring **this)
{
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)(this + 1), this[1]);
  uint64_t v2 = this[4];
  return std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)(this + 4), v2);
}

uint64_t as::server::PlatformSupport::isInitialized(as::server::PlatformSupport *this)
{
  return 1;
}

BOOL as::server::PlatformSupport::readFrom(void *a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  uint64_t v8 = a1 + 4;
  uint64_t v9 = (uint64_t)(a1 + 6);
  uint64_t v10 = a1 + 1;
  uint64_t v11 = (uint64_t)(a1 + 3);
  while (1)
  {
    uint64_t v12 = *a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
      break;
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v15 = 0;
    while (1)
    {
      unint64_t v16 = v2 + 1;
      a2[1] = v2 + 1;
      char v17 = *(unsigned char *)(v12 + v2);
      v15 |= (unint64_t)(v17 & 0x7F) << v13;
      if ((v17 & 0x80) == 0) {
        break;
      }
      v13 += 7;
      unint64_t v2 = v16;
      if (v14++ > 8) {
        goto LABEL_20;
      }
    }
LABEL_21:
    if ((v15 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    if ((v15 >> 3) == 2)
    {
      uint64_t v28 = (void *)a1[5];
      unint64_t v27 = a1[6];
      if ((unint64_t)v28 >= v27)
      {
        uint64_t v35 = ((uint64_t)v28 - *v8) >> 4;
        unint64_t v36 = v35 + 1;
        if ((unint64_t)(v35 + 1) >> 60) {
          std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v37 = v27 - *v8;
        if (v37 >> 3 > v36) {
          unint64_t v36 = v37 >> 3;
        }
        if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v38 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v38 = v36;
        }
        uint64_t v47 = v9;
        if (v38) {
          char v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v38);
        }
        else {
          char v39 = 0;
        }
        uint64_t v41 = &v39[16 * v35];
        std::string __p = v39;
        int v44 = v41;
        uint64_t v46 = &v39[16 * v38];
        *(void *)uint64_t v41 = 0;
        *((void *)v41 + 1) = 0;
        unint64_t v45 = v41 + 16;
        std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
        uint64_t v29 = (void *)a1[5];
        std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
      }
      else
      {
        *uint64_t v28 = 0;
        v28[1] = 0;
        uint64_t v29 = v28 + 2;
        a1[5] = v28 + 2;
      }
      a1[5] = v29;
      std::string __p = 0;
      int v44 = 0;
      unint64_t v45 = 0;
      PB::Reader::read();
      caulk::xstring::assign();
      goto LABEL_50;
    }
    if ((v15 >> 3) == 1)
    {
      unint64_t v25 = (void *)a1[2];
      unint64_t v24 = a1[3];
      if ((unint64_t)v25 >= v24)
      {
        uint64_t v30 = ((uint64_t)v25 - *v10) >> 4;
        unint64_t v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 60) {
          std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v32 = v24 - *v10;
        if (v32 >> 3 > v31) {
          unint64_t v31 = v32 >> 3;
        }
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v33 = v31;
        }
        uint64_t v47 = v11;
        if (v33) {
          unint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v11, v33);
        }
        else {
          unint64_t v34 = 0;
        }
        unint64_t v40 = &v34[16 * v30];
        std::string __p = v34;
        int v44 = v40;
        uint64_t v46 = &v34[16 * v33];
        *(void *)unint64_t v40 = 0;
        *((void *)v40 + 1) = 0;
        unint64_t v45 = v40 + 16;
        std::vector<caulk::xstring>::__swap_out_circular_buffer(v10, &__p);
        uint64_t v26 = (void *)a1[2];
        std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
      }
      else
      {
        void *v25 = 0;
        v25[1] = 0;
        uint64_t v26 = v25 + 2;
        a1[2] = v25 + 2;
      }
      a1[2] = v26;
      std::string __p = 0;
      int v44 = 0;
      unint64_t v45 = 0;
      PB::Reader::read();
      caulk::xstring::assign();
LABEL_50:
      if (SHIBYTE(v45) < 0) {
        operator delete(__p);
      }
    }
    unint64_t v2 = a2[1];
    unint64_t v3 = a2[2];
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
      return v4 == 0;
    }
  }
  char v19 = 0;
  unsigned int v20 = 0;
  unint64_t v15 = 0;
  if (v2 > v3) {
    unint64_t v3 = v2;
  }
  while (v3 != v2)
  {
    unint64_t v21 = v2 + 1;
    char v22 = *(unsigned char *)(v12 + v2);
    a2[1] = v21;
    v15 |= (unint64_t)(v22 & 0x7F) << v19;
    if ((v22 & 0x80) == 0) {
      goto LABEL_21;
    }
    v19 += 7;
    unint64_t v2 = v21;
    if (v20++ >= 9)
    {
LABEL_20:
      unint64_t v15 = 0;
      goto LABEL_21;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_210ADF9F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void as::server::PlatformSupport::writeTo(as::server::PlatformSupport *this, PB::Writer *a2)
{
  unint64_t v3 = (caulk::xstring *)*((void *)this + 1);
  int v4 = (caulk::xstring *)*((void *)this + 2);
  while (v3 != v4)
  {
    uint64_t v5 = (char *)caulk::xstring::c_str(v3);
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v3 = (caulk::xstring *)((char *)v3 + 16);
  }
  uint64_t v7 = (caulk::xstring *)*((void *)this + 4);
  uint64_t v6 = (caulk::xstring *)*((void *)this + 5);
  while (v7 != v6)
  {
    uint64_t v8 = (char *)caulk::xstring::c_str(v7);
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::Writer::write();
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v7 = (caulk::xstring *)((char *)v7 + 16);
  }
}

void sub_210ADFAE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::server::PlatformSupport::formatText(as::server::PlatformSupport *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = (caulk::xstring *)*((void *)this + 1);
  for (i = (caulk::xstring *)*((void *)this + 2); v5 != i; uint64_t v5 = (caulk::xstring *)((char *)v5 + 16))
  {
    uint64_t v7 = (char *)caulk::xstring::c_str(v5);
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v8 = (caulk::xstring *)*((void *)this + 4);
  for (j = (caulk::xstring *)*((void *)this + 5); v8 != j; uint64_t v8 = (caulk::xstring *)((char *)v8 + 16))
  {
    char v10 = (char *)caulk::xstring::c_str(v8);
    std::string::basic_string[abi:ne180100]<0>(__p, v10);
    PB::TextFormatter::format();
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210ADFC00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::server::PlatformSupport::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  unint64_t v4 = (v2 - v3) >> 4;
  if (v4 != (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 4) {
    return 0;
  }
  if (v2 != v3)
  {
    uint64_t v7 = 0;
    if (v4 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = (v2 - v3) >> 4;
    }
    while (!caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 8) + v7), (const caulk::xstring *)(*(void *)(a2 + 8) + v7)))
    {
      v7 += 16;
      if (!--v8) {
        goto LABEL_8;
      }
    }
    return 0;
  }
LABEL_8:
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  unint64_t v11 = (v9 - v10) >> 4;
  if (v11 != (uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 4) {
    return 0;
  }
  if (v9 == v10) {
    return 1;
  }
  if (v11 <= 1) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = (v9 - v10) >> 4;
  }
  if (caulk::xstring::compare(*(caulk::xstring **)(a1 + 32), *(const caulk::xstring **)(a2 + 32))) {
    return 0;
  }
  uint64_t v14 = 1;
  uint64_t v15 = 16;
  do
  {
    unint64_t v16 = v14;
    if (v12 == v14) {
      break;
    }
    int v17 = caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 32) + v15), (const caulk::xstring *)(*(void *)(a2 + 32) + v15));
    uint64_t v14 = v16 + 1;
    v15 += 16;
  }
  while (!v17);
  return v16 >= v11;
}

uint64_t as::server::SessionServerState::default_instance(as::server::SessionServerState *this)
{
  {
    operator new();
  }
  return as::server::SessionServerState::default_instance(void)::gInstance;
}

void sub_210ADFDD0(_Unwind_Exception *a1)
{
}

double as::server::SessionServerState::SessionServerState(as::server::SessionServerState *this)
{
  *(void *)this = &unk_26C312C20;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312C20;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)((char *)this + 57) = 0u;
  return result;
}

as::server::SessionServerState *as::server::SessionServerState::SessionServerState(as::server::SessionServerState *this, const as::server::SessionServerState *a2)
{
  *(void *)this = &unk_26C312C20;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  as::server::SessionServerState::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312C20;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  as::server::SessionServerState::copy_from(this, a2);
  return this;
}

void *as::server::SessionServerState::copy_from(as::server::SessionServerState *this, const as::server::SessionServerState *a2)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  if (*((void *)a2 + 5) != *((void *)a2 + 6)) {
    operator new();
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  uint64_t v5 = *((void *)a2 + 8);
  *((unsigned char *)this + 72) = *((unsigned char *)a2 + 72);
  *((void *)this + 8) = v5;
  return result;
}

void sub_210AE0138(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::SessionServerState *as::server::SessionServerState::operator=(as::server::SessionServerState *a1, const as::server::SessionServerState *a2)
{
  return a1;
}

uint64_t as::server::SessionServerState::SessionServerState(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312C20;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  as::server::SessionServerState::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312C20;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  as::server::SessionServerState::move_from(a1, a2);
  return a1;
}

uint64_t as::server::SessionServerState::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  uint64_t v5 = *(void *)(result + 40);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v5;
  uint64_t v6 = *(void *)(result + 48);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v6;
  uint64_t v7 = *(void *)(result + 56);
  *(void *)(result + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v7;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v8 = *(void *)(a2 + 64);
  *(unsigned char *)(result + 72) = *(unsigned char *)(a2 + 72);
  *(void *)(result + 64) = v8;
  return result;
}

uint64_t as::server::SessionServerState::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

void *as::server::SessionServerState::clear(as::server::SessionServerState *this)
{
  std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 5);
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 0;
  return result;
}

BOOL as::server::SessionServerState::isInitialized(as::server::SessionServerState *this)
{
  uint64_t v2 = (as::server::IOControllerState **)*((void *)this + 2);
  uint64_t v3 = (as::server::IOControllerState **)*((void *)this + 3);
  while (v2 != v3)
  {
    if (!as::server::IOControllerState::isInitialized(*v2)) {
      return 0;
    }
    ++v2;
  }
  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = *((void *)this + 6);
  if (v4 == v5) {
    return (~*((_DWORD *)this + 2) & 7) == 0;
  }
  while (1)
  {
    uint64_t v6 = *(void *)(*(void *)v4 + 32);
    if (!v6 || (~*(_DWORD *)(v6 + 8) & 0x7F) != 0 || (~*(_DWORD *)(*(void *)v4 + 8) & 3) != 0) {
      break;
    }
    v4 += 8;
    if (v4 == v5) {
      return (~*((_DWORD *)this + 2) & 7) == 0;
    }
  }
  return 0;
}

BOOL as::server::SessionServerState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      uint64_t v6 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v13 = 0;
        unsigned int v14 = 0;
        unint64_t v9 = 0;
        if (v3 <= v2) {
          unint64_t v15 = v2;
        }
        else {
          unint64_t v15 = v3;
        }
        while (v15 != v3)
        {
          unint64_t v16 = v3++;
          char v17 = *(unsigned char *)(v6 + v16);
          a2[1] = v3;
          v9 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0) {
            goto LABEL_21;
          }
          v13 += 7;
          BOOL v18 = v14++ >= 9;
          if (v18)
          {
            unint64_t v9 = 0;
LABEL_21:
            unint64_t v10 = v16 + 1;
            goto LABEL_22;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v7 = 0;
        unsigned int v8 = 0;
        unint64_t v9 = 0;
        while (1)
        {
          unint64_t v10 = v3 + 1;
          a2[1] = v3 + 1;
          char v11 = *(unsigned char *)(v6 + v3);
          v9 |= (unint64_t)(v11 & 0x7F) << v7;
          if ((v11 & 0x80) == 0) {
            break;
          }
          v7 += 7;
          unint64_t v3 = v10;
          BOOL v12 = v8++ > 8;
          if (v12)
          {
            unint64_t v9 = 0;
            break;
          }
        }
LABEL_22:
        if ((v9 & 7) != 4)
        {
          switch((v9 >> 3))
          {
            case 1u:
              if (v10 <= 0xFFFFFFFFFFFFFFF5 && v10 + 10 <= v2)
              {
                char v19 = 0;
                unsigned int v20 = 0;
                uint64_t v21 = 0;
                do
                {
                  unint64_t v22 = v10 + 1;
                  a2[1] = v10 + 1;
                  char v23 = *(unsigned char *)(v6 + v10);
                  v21 |= (unint64_t)(v23 & 0x7F) << v19;
                  if ((v23 & 0x80) == 0) {
                    goto LABEL_61;
                  }
                  v19 += 7;
                  unint64_t v10 = v22;
                  BOOL v12 = v20++ > 8;
                }
                while (!v12);
LABEL_55:
                LODWORD(v21) = 0;
                goto LABEL_61;
              }
              char v35 = 0;
              unsigned int v36 = 0;
              uint64_t v21 = 0;
              if (v2 <= v10) {
                unint64_t v2 = v10;
              }
              while (v2 != v10)
              {
                unint64_t v37 = v10 + 1;
                char v38 = *(unsigned char *)(v6 + v10);
                a2[1] = v37;
                v21 |= (unint64_t)(v38 & 0x7F) << v35;
                if ((v38 & 0x80) == 0) {
                  goto LABEL_61;
                }
                v35 += 7;
                unint64_t v10 = v37;
                BOOL v18 = v36++ >= 9;
                if (v18) {
                  goto LABEL_55;
                }
              }
              LODWORD(v21) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_61:
              *(_DWORD *)(a1 + 64) = v21;
              int v39 = *(_DWORD *)(a1 + 8) | 1;
              goto LABEL_62;
            case 2u:
              operator new();
            case 3u:
              operator new();
            case 4u:
              if (v10 >= v2)
              {
                BOOL v30 = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                int v29 = *(unsigned __int8 *)(v6 + v10);
                a2[1] = v10 + 1;
                BOOL v30 = v29 != 0;
              }
              *(unsigned char *)(a1 + 72) = v30;
              int v39 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_62;
            case 5u:
              if (v10 <= 0xFFFFFFFFFFFFFFF5 && v10 + 10 <= v2)
              {
                char v24 = 0;
                unsigned int v25 = 0;
                uint64_t v26 = 0;
                do
                {
                  unint64_t v27 = v10 + 1;
                  a2[1] = v10 + 1;
                  char v28 = *(unsigned char *)(v6 + v10);
                  v26 |= (unint64_t)(v28 & 0x7F) << v24;
                  if ((v28 & 0x80) == 0) {
                    goto LABEL_59;
                  }
                  v24 += 7;
                  unint64_t v10 = v27;
                  BOOL v12 = v25++ > 8;
                }
                while (!v12);
LABEL_48:
                LODWORD(v26) = 0;
                goto LABEL_59;
              }
              char v31 = 0;
              unsigned int v32 = 0;
              uint64_t v26 = 0;
              if (v2 <= v10) {
                unint64_t v2 = v10;
              }
              while (v2 != v10)
              {
                unint64_t v33 = v10 + 1;
                char v34 = *(unsigned char *)(v6 + v10);
                a2[1] = v33;
                v26 |= (unint64_t)(v34 & 0x7F) << v31;
                if ((v34 & 0x80) == 0) {
                  goto LABEL_59;
                }
                v31 += 7;
                unint64_t v10 = v33;
                BOOL v18 = v32++ >= 9;
                if (v18) {
                  goto LABEL_48;
                }
              }
              LODWORD(v26) = 0;
              *((unsigned char *)a2 + 24) = 1;
LABEL_59:
              *(_DWORD *)(a1 + 68) = v26;
              int v39 = *(_DWORD *)(a1 + 8) | 4;
LABEL_62:
              *(_DWORD *)(a1 + 8) = v39;
LABEL_63:
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            default:
              goto LABEL_63;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AE09B4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::SessionServerState::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  if (*(unsigned char *)(this + 8)) {
    this = PB::Writer::writeVarInt(a2);
  }
  int v4 = *(const PB::Base ***)(v3 + 16);
  uint64_t v5 = *(const PB::Base ***)(v3 + 24);
  while (v4 != v5)
  {
    uint64_t v6 = *v4++;
    this = PB::Writer::writeSubmessage(a2, v6);
  }
  char v7 = *(const PB::Base ***)(v3 + 40);
  unsigned int v8 = *(const PB::Base ***)(v3 + 48);
  while (v7 != v8)
  {
    unint64_t v9 = *v7++;
    this = PB::Writer::writeSubmessage(a2, v9);
  }
  int v10 = *(_DWORD *)(v3 + 8);
  if ((v10 & 2) != 0)
  {
    this = PB::Writer::write(a2);
    int v10 = *(_DWORD *)(v3 + 8);
  }
  if ((v10 & 4) != 0)
  {
    return PB::Writer::writeVarInt(a2);
  }
  return this;
}

uint64_t as::server::SessionServerState::formatText(as::server::SessionServerState *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  if (*((unsigned char *)this + 8)) {
    PB::TextFormatter::format(a2, "generationCount");
  }
  uint64_t v5 = (uint64_t *)*((void *)this + 2);
  uint64_t v6 = (uint64_t *)*((void *)this + 3);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, a2, "controllers");
  }
  unsigned int v8 = (uint64_t *)*((void *)this + 5);
  unint64_t v9 = (uint64_t *)*((void *)this + 6);
  while (v8 != v9)
  {
    uint64_t v10 = *v8++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v10 + 32))(v10, a2, "ports");
  }
  int v11 = *((_DWORD *)this + 2);
  if ((v11 & 2) != 0)
  {
    PB::TextFormatter::format(a2, "simulated");
    int v11 = *((_DWORD *)this + 2);
  }
  if ((v11 & 4) != 0) {
    PB::TextFormatter::format(a2, "sessionToken");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::SessionServerState::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (*(void *)(a1 + 64) != *(void *)(a2 + 64)
    || *(unsigned __int8 *)(a1 + 72) != (unint64_t)*(unsigned __int8 *)(a2 + 72))
  {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  unint64_t v7 = (v5 - v6) >> 3;
  if (v7 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3) {
    return 0;
  }
  if (v5 != v6)
  {
    uint64_t v8 = 0;
    if (v7 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = (v5 - v6) >> 3;
    }
    do
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 16) + 8 * v8);
      uint64_t v11 = *(void *)(*(void *)(a2 + 16) + 8 * v8);
      if (v10) {
        BOOL v12 = v11 == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12)
      {
        if (v10 | v11) {
          return 0;
        }
      }
      else if (!as::server::IOControllerState::operator==(v10, v11))
      {
        return 0;
      }
      ++v8;
    }
    while (v9 != v8);
  }
  uint64_t v14 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 48);
  unint64_t v15 = (v13 - v14) >> 3;
  if (v15 == (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3)
  {
    if (v13 == v14)
    {
      return 1;
    }
    else
    {
      BOOL v16 = 0;
      uint64_t v17 = 0;
      if (v15 <= 1) {
        uint64_t v18 = 1;
      }
      else {
        uint64_t v18 = (v13 - v14) >> 3;
      }
      do
      {
        uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8 * v17);
        uint64_t v20 = *(void *)(*(void *)(a2 + 40) + 8 * v17);
        if (v19) {
          BOOL v21 = v20 == 0;
        }
        else {
          BOOL v21 = 1;
        }
        if (v21)
        {
          if (v19 | v20) {
            return v16;
          }
        }
        else if (!as::server::VirtualPort::operator==(v19, v20))
        {
          return v16;
        }
        BOOL v16 = ++v17 >= v15;
      }
      while (v18 != v17);
    }
  }
  else
  {
    return 0;
  }
  return v16;
}

void as::server::SessionServerState::addControllers(as::server::SessionServerState *this)
{
  unint64_t v4 = *((void *)this + 4);
  unint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::IOControllerState>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210AE0EF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void as::server::SessionServerState::addPorts(as::server::SessionServerState *this)
{
  unint64_t v4 = *((void *)this + 7);
  unint64_t v2 = (char *)this + 56;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::VirtualPort>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 6);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 6) = v6;
  }
  *((void *)this + 6) = v6;
  operator new();
}

void sub_210AE1058(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::SessionFullState::default_instance(as::server::SessionFullState *this)
{
  {
    operator new();
  }
  return as::server::SessionFullState::default_instance(void)::gInstance;
}

void sub_210AE10FC(_Unwind_Exception *a1)
{
}

void *as::server::SessionFullState::SessionFullState(void *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312B40;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312B40;
  return this;
}

as::server::SessionFullState *as::server::SessionFullState::SessionFullState(as::server::SessionFullState *this, const as::server::SessionFullState *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C312B40;
  as::server::SessionFullState::copy_from(this, a2);
  return this;
}

{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C312B40;
  as::server::SessionFullState::copy_from(this, a2);
  return this;
}

as::client::SessionState *as::server::SessionFullState::copy_from(as::client::SessionState *this, const as::server::SessionFullState *a2)
{
  unint64_t v3 = this;
  unint64_t v4 = (const as::server::SessionServerState *)*((void *)a2 + 1);
  if (v4)
  {
    uint64_t v5 = (as::server::SessionServerState *)as::server::SessionFullState::mutableServerState(this);
    this = (as::client::SessionState *)as::server::SessionServerState::copy_from(v5, v4);
  }
  uint64_t v6 = (const as::client::SessionState *)*((void *)a2 + 2);
  if (v6)
  {
    unint64_t v7 = (as::client::SessionState *)as::server::SessionFullState::mutableClientState(v3);
    return as::client::SessionState::operator=(v7, v6);
  }
  return this;
}

as::client::SessionState *as::server::SessionFullState::operator=(as::client::SessionState *a1, const as::server::SessionFullState *a2)
{
  return a1;
}

uint64_t as::server::SessionFullState::serverState(as::server::SessionFullState *this)
{
  uint64_t result = *((void *)this + 1);
  if (!result) {
    return as::server::SessionServerState::default_instance(0);
  }
  return result;
}

uint64_t as::server::SessionFullState::mutableServerState(as::server::SessionFullState *this)
{
  if (!*((void *)this + 1)) {
    operator new();
  }
  return *((void *)this + 1);
}

uint64_t as::server::SessionFullState::clientState(as::server::SessionFullState *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return as::client::SessionState::default_instance(0);
  }
  return result;
}

uint64_t as::server::SessionFullState::mutableClientState(as::server::SessionFullState *this)
{
  if (!*((void *)this + 2)) {
    operator new();
  }
  return *((void *)this + 2);
}

void *as::server::SessionFullState::SessionFullState(void *result, uint64_t a2)
{
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C312B40;
  result[1] = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = result[2];
  result[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  return result;
}

{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C312B40;
  result[1] = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = result[2];
  result[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  return result;
}

uint64_t as::server::SessionFullState::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::SessionFullState::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::SessionFullState::clear(as::server::SessionFullState *this)
{
  uint64_t v2 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result)
  {
    unint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v4();
  }
  return result;
}

as::client::SessionState *as::server::SessionFullState::isInitialized(as::server::SessionFullState *this)
{
  uint64_t result = (as::client::SessionState *)*((void *)this + 2);
  if (result) {
    return (as::client::SessionState *)as::client::SessionState::isInitialized(result);
  }
  return result;
}

BOOL as::server::SessionFullState::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v2 + 1;
        a2[1] = v2 + 1;
        char v11 = *(unsigned char *)(v6 + v2);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v2 = v10;
        if (v8++ > 8) {
          goto LABEL_19;
        }
      }
LABEL_20:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v9 >> 3) == 2) {
        operator new();
      }
      if ((v9 >> 3) == 1) {
        operator new();
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v15 = v2 + 1;
      char v16 = *(unsigned char *)(v6 + v2);
      a2[1] = v15;
      v9 |= (unint64_t)(v16 & 0x7F) << v13;
      if ((v16 & 0x80) == 0) {
        goto LABEL_20;
      }
      v13 += 7;
      unint64_t v2 = v15;
      if (v14++ >= 9)
      {
LABEL_19:
        unint64_t v9 = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::SessionFullState::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(const PB::Base **)(this + 8);
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  uint64_t v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
  {
    return PB::Writer::writeSubmessage(a2, v5);
  }
  return this;
}

uint64_t as::server::SessionFullState::formatText(as::server::SessionFullState *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 1);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "serverState");
  }
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, a2, "clientState");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::SessionFullState::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (as::server::SessionServerState::operator==(v4, v5)) {
      goto LABEL_9;
    }
    return 0;
  }
  if (v4 | v5) {
    return 0;
  }
LABEL_9:
  uint64_t v8 = *(void *)(a1 + 16);
  unint64_t v9 = *(void *)(a2 + 16);
  BOOL result = (v8 | v9) == 0;
  if (v8 && v9)
  {
    unint64_t v10 = *(void **)(a1 + 16);
    return as::client::SessionState::operator==(v10, (void *)v9);
  }
  return result;
}

uint64_t as::server::SessionFullState::clearServerState(as::server::SessionFullState *this)
{
  uint64_t result = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::SessionFullState::clearClientState(as::server::SessionFullState *this)
{
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::VirtualPortList::default_instance(as::server::VirtualPortList *this)
{
  {
    operator new();
  }
  return as::server::VirtualPortList::default_instance(void)::gInstance;
}

void sub_210AE1A5C(_Unwind_Exception *a1)
{
}

void *as::server::VirtualPortList::VirtualPortList(void *this)
{
  *this = &unk_26C312AD0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

{
  *this = &unk_26C312AD0;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

as::server::VirtualPortList *as::server::VirtualPortList::VirtualPortList(as::server::VirtualPortList *this, const as::server::VirtualPortList *a2)
{
  *(void *)this = &unk_26C312AD0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::server::VirtualPortList::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312AD0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::server::VirtualPortList::copy_from(this, a2);
  return this;
}

void *as::server::VirtualPortList::copy_from(as::server::VirtualPortList *this, const as::server::VirtualPortList *a2)
{
  uint64_t result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 1);
  if (*((void *)a2 + 1) != *((void *)a2 + 2)) {
    operator new();
  }
  return result;
}

void sub_210AE1C64(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::server::VirtualPortList *as::server::VirtualPortList::operator=(as::server::VirtualPortList *a1, const as::server::VirtualPortList *a2)
{
  return a1;
}

void *as::server::VirtualPortList::VirtualPortList(void *result, void *a2)
{
  *uint64_t result = &unk_26C312AD0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[1] = a2[1];
  a2[1] = 0;
  uint64_t v2 = result[2];
  result[2] = a2[2];
  a2[2] = v2;
  uint64_t v3 = result[3];
  result[3] = a2[3];
  a2[3] = v3;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;

  *uint64_t result = &unk_26C312AD0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[1] = a2[1];
  a2[1] = 0;
  uint64_t v2 = result[2];
  result[2] = a2[2];
  a2[2] = v2;
  uint64_t v3 = result[3];
  result[3] = a2[3];
  a2[3] = v3;
  return result;
}

void *as::server::VirtualPortList::move_from(void *result, void *a2)
{
  uint64_t v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  uint64_t v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  uint64_t v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  return result;
}

void *as::server::VirtualPortList::operator=(void *result, void *a2)
{
  uint64_t v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  uint64_t v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  uint64_t v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  return result;
}

void *as::server::VirtualPortList::clear(as::server::VirtualPortList *this)
{
  return std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 1);
}

uint64_t as::server::VirtualPortList::isInitialized(as::server::VirtualPortList *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  if (v1 == v2) {
    return 1;
  }
  while (1)
  {
    uint64_t v3 = *(void *)(*(void *)v1 + 32);
    if (!v3 || (~*(_DWORD *)(v3 + 8) & 0x7F) != 0 || (~*(_DWORD *)(*(void *)v1 + 8) & 3) != 0) {
      break;
    }
    v1 += 8;
    if (v1 == v2) {
      return 1;
    }
  }
  return 0;
}

BOOL as::server::VirtualPortList::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    int v4 = 0;
    while (1)
    {
      uint64_t v6 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      uint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v3 + 1;
        a2[1] = v3 + 1;
        char v11 = *(unsigned char *)(v6 + v3);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v3 = v10;
        if (v8++ > 8)
        {
          uint64_t v9 = 0;
          break;
        }
      }
      unint64_t v3 = v10;
LABEL_24:
      if ((v9 & 7) != 4)
      {
        if ((v9 & 0x7FFFFFFF8) == 8) {
          operator new();
        }
        if (v3 < v2) {
          continue;
        }
      }
      return v4 == 0;
    }
    char v13 = 0;
    unsigned int v14 = 0;
    uint64_t v9 = 0;
    if (v3 <= v2) {
      unint64_t v15 = v2;
    }
    else {
      unint64_t v15 = v3;
    }
    while (v15 != v3)
    {
      unint64_t v16 = v3++;
      char v17 = *(unsigned char *)(v6 + v16);
      a2[1] = v3;
      v9 |= (unint64_t)(v17 & 0x7F) << v13;
      if ((v17 & 0x80) == 0) {
        goto LABEL_23;
      }
      v13 += 7;
      if (v14++ >= 9)
      {
        uint64_t v9 = 0;
LABEL_23:
        unint64_t v3 = v16 + 1;
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210AE210C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::server::VirtualPortList::writeTo(uint64_t this, PB::Writer *a2)
{
  unint64_t v2 = *(const PB::Base ***)(this + 8);
  for (uint64_t i = *(const PB::Base ***)(this + 16); v2 != i; this = PB::Writer::writeSubmessage(a2, v5))
    uint64_t v5 = *v2++;
  return this;
}

uint64_t as::server::VirtualPortList::formatText(as::server::VirtualPortList *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = (uint64_t *)*((void *)this + 1);
  uint64_t v6 = (uint64_t *)*((void *)this + 2);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v7 + 32))(v7, a2, "ports");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::VirtualPortList::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  unint64_t v4 = (v2 - v3) >> 3;
  if (v4 == (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3)
  {
    if (v2 == v3)
    {
      return 1;
    }
    else
    {
      BOOL v7 = 0;
      uint64_t v8 = 0;
      if (v4 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = (v2 - v3) >> 3;
      }
      do
      {
        uint64_t v10 = *(void *)(*(void *)(a1 + 8) + 8 * v8);
        uint64_t v11 = *(void *)(*(void *)(a2 + 8) + 8 * v8);
        if (v10) {
          BOOL v12 = v11 == 0;
        }
        else {
          BOOL v12 = 1;
        }
        if (v12)
        {
          if (v10 | v11) {
            return v7;
          }
        }
        else if (!as::server::VirtualPort::operator==(v10, v11))
        {
          return v7;
        }
        BOOL v7 = ++v8 >= v4;
      }
      while (v9 != v8);
    }
  }
  else
  {
    return 0;
  }
  return v7;
}

void as::server::VirtualPortList::addPorts(as::server::VirtualPortList *this)
{
  unint64_t v4 = *((void *)this + 3);
  uint64_t v2 = (char *)this + 24;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    BOOL v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      char v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      char v13 = 0;
    }
    unsigned int v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unsigned int v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::server::VirtualPort>>::__swap_out_circular_buffer(v7, v15);
    uint64_t v6 = (void *)*((void *)this + 2);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    *((void *)this + 2) = v6;
  }
  *((void *)this + 2) = v6;
  operator new();
}

void sub_210AE244C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::server::EligiblePortList::default_instance(as::server::EligiblePortList *this)
{
  {
    operator new();
  }
  return as::server::EligiblePortList::default_instance(void)::gInstance;
}

void sub_210AE24F0(_Unwind_Exception *a1)
{
}

void *as::server::EligiblePortList::EligiblePortList(void *this)
{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312B08;
  return this;
}

{
  this[1] = 0;
  this[2] = 0;
  *this = &unk_26C312B08;
  return this;
}

as::server::EligiblePortList *as::server::EligiblePortList::EligiblePortList(as::server::EligiblePortList *this, const as::server::EligiblePortList *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C312B08;
  as::server::EligiblePortList::copy_from(this, a2);
  return this;
}

{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C312B08;
  as::server::EligiblePortList::copy_from(this, a2);
  return this;
}

as::server::EligiblePortList *as::server::EligiblePortList::copy_from(as::server::EligiblePortList *this, const as::server::EligiblePortList *a2)
{
  unint64_t v3 = this;
  unint64_t v4 = (const as::server::VirtualPortList *)*((void *)a2 + 1);
  if (v4)
  {
    uint64_t v5 = (as::server::VirtualPortList *)as::server::EligiblePortList::mutableStandardPorts(this);
    this = (as::server::EligiblePortList *)as::server::VirtualPortList::copy_from(v5, v4);
  }
  uint64_t v6 = (const as::server::VirtualPortList *)*((void *)a2 + 2);
  if (v6)
  {
    BOOL v7 = (as::server::VirtualPortList *)as::server::EligiblePortList::mutableDecoupledPorts(v3);
    return (as::server::EligiblePortList *)as::server::VirtualPortList::copy_from(v7, v6);
  }
  return this;
}

as::server::EligiblePortList *as::server::EligiblePortList::operator=(as::server::EligiblePortList *a1, const as::server::EligiblePortList *a2)
{
  return a1;
}

uint64_t as::server::EligiblePortList::standardPorts(as::server::EligiblePortList *this)
{
  uint64_t result = *((void *)this + 1);
  if (!result) {
    return as::server::VirtualPortList::default_instance(0);
  }
  return result;
}

uint64_t as::server::EligiblePortList::mutableStandardPorts(as::server::EligiblePortList *this)
{
  if (!*((void *)this + 1)) {
    operator new();
  }
  return *((void *)this + 1);
}

uint64_t as::server::EligiblePortList::decoupledPorts(as::server::EligiblePortList *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return as::server::VirtualPortList::default_instance(0);
  }
  return result;
}

uint64_t as::server::EligiblePortList::mutableDecoupledPorts(as::server::EligiblePortList *this)
{
  if (!*((void *)this + 2)) {
    operator new();
  }
  return *((void *)this + 2);
}

void *as::server::EligiblePortList::EligiblePortList(void *result, uint64_t a2)
{
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C312B08;
  result[1] = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = result[2];
  result[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  return result;
}

{
  uint64_t v2;

  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C312B08;
  result[1] = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  uint64_t v2 = result[2];
  result[2] = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  return result;
}

uint64_t as::server::EligiblePortList::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::EligiblePortList::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v2;
  uint64_t v3 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v3;
  return result;
}

uint64_t as::server::EligiblePortList::clear(as::server::EligiblePortList *this)
{
  uint64_t v2 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result)
  {
    unint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v4();
  }
  return result;
}

uint64_t as::server::EligiblePortList::isInitialized(as::server::EligiblePortList *this)
{
  return 1;
}

BOOL as::server::EligiblePortList::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v2 + 1;
        a2[1] = v2 + 1;
        char v11 = *(unsigned char *)(v6 + v2);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v2 = v10;
        if (v8++ > 8) {
          goto LABEL_19;
        }
      }
LABEL_20:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v9 >> 3) == 2) {
        operator new();
      }
      if ((v9 >> 3) == 1) {
        operator new();
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v15 = v2 + 1;
      char v16 = *(unsigned char *)(v6 + v2);
      a2[1] = v15;
      v9 |= (unint64_t)(v16 & 0x7F) << v13;
      if ((v16 & 0x80) == 0) {
        goto LABEL_20;
      }
      v13 += 7;
      unint64_t v2 = v15;
      if (v14++ >= 9)
      {
LABEL_19:
        unint64_t v9 = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::EligiblePortList::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(const PB::Base **)(this + 8);
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  uint64_t v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
  {
    return PB::Writer::writeSubmessage(a2, v5);
  }
  return this;
}

uint64_t as::server::EligiblePortList::formatText(as::server::EligiblePortList *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 1);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "standardPorts");
  }
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, a2, "decoupledPorts");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::EligiblePortList::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    if (as::server::VirtualPortList::operator==(v4, v5)) {
      goto LABEL_9;
    }
    return 0;
  }
  if (v4 | v5) {
    return 0;
  }
LABEL_9:
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(a2 + 16);
  BOOL result = (v8 | v9) == 0;
  if (v8 && v9)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    return as::server::VirtualPortList::operator==(v10, v9);
  }
  return result;
}

uint64_t as::server::EligiblePortList::clearStandardPorts(as::server::EligiblePortList *this)
{
  uint64_t result = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::EligiblePortList::clearDecoupledPorts(as::server::EligiblePortList *this)
{
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::server::SessionTokenList::default_instance(as::server::SessionTokenList *this)
{
  {
    operator new();
  }
  return as::server::SessionTokenList::default_instance(void)::gInstance;
}

void sub_210AE2E60(_Unwind_Exception *a1)
{
}

void *as::server::SessionTokenList::SessionTokenList(void *this)
{
  *this = &unk_26C312B78;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

{
  *this = &unk_26C312B78;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

as::server::SessionTokenList *as::server::SessionTokenList::SessionTokenList(as::server::SessionTokenList *this, const as::server::SessionTokenList *a2)
{
  *(void *)this = &unk_26C312B78;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::server::SessionTokenList::copy_from((char *)this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312B78;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::server::SessionTokenList::copy_from((char *)this, a2);
  return this;
}

char *as::server::SessionTokenList::copy_from(char *this, const as::server::SessionTokenList *a2)
{
  if (this != (char *)a2) {
    return std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(this + 8, *((char **)a2 + 1), *((void *)a2 + 2), (uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 2);
  }
  return this;
}

char *as::server::SessionTokenList::operator=(char *a1, const as::server::SessionTokenList *a2)
{
  return a1;
}

void *as::server::SessionTokenList::SessionTokenList(void *result, void *a2)
{
  *uint64_t result = &unk_26C312B78;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[1] = a2[1];
  a2[1] = 0;
  uint64_t v2 = result[2];
  result[2] = a2[2];
  a2[2] = v2;
  uint64_t v3 = result[3];
  result[3] = a2[3];
  a2[3] = v3;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;

  *uint64_t result = &unk_26C312B78;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[1] = a2[1];
  a2[1] = 0;
  uint64_t v2 = result[2];
  result[2] = a2[2];
  a2[2] = v2;
  uint64_t v3 = result[3];
  result[3] = a2[3];
  a2[3] = v3;
  return result;
}

void *as::server::SessionTokenList::move_from(void *result, void *a2)
{
  uint64_t v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  uint64_t v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  uint64_t v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  return result;
}

void *as::server::SessionTokenList::operator=(void *result, void *a2)
{
  uint64_t v2 = result[1];
  result[1] = a2[1];
  a2[1] = v2;
  uint64_t v3 = result[2];
  result[2] = a2[2];
  a2[2] = v3;
  uint64_t v4 = result[3];
  result[3] = a2[3];
  a2[3] = v4;
  return result;
}

uint64_t as::server::SessionTokenList::clear(uint64_t this)
{
  *(void *)(this + 16) = *(void *)(this + 8);
  return this;
}

uint64_t as::server::SessionTokenList::isInitialized(as::server::SessionTokenList *this)
{
  return 1;
}

BOOL as::server::SessionTokenList::readFrom(void *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    int v4 = 0;
    uint64_t v8 = (void **)(a1 + 1);
    uint64_t v9 = a1 + 3;
    while (1)
    {
      uint64_t v10 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v11 = 0;
      unsigned int v12 = 0;
      uint64_t v13 = 0;
      while (1)
      {
        unint64_t v14 = v3 + 1;
        a2[1] = v3 + 1;
        char v15 = *(unsigned char *)(v10 + v3);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0) {
          break;
        }
        v11 += 7;
        unint64_t v3 = v14;
        BOOL v37 = v12++ > 8;
        if (v37)
        {
          uint64_t v13 = 0;
          break;
        }
      }
      unint64_t v3 = v14;
LABEL_24:
      if ((v13 & 7) == 4) {
        return v4 == 0;
      }
      if ((v13 & 0x7FFFFFFF8) == 8)
      {
        if ((v13 & 7) == 2)
        {
          if (PB::Reader::placeMark()) {
            return 0;
          }
          unint64_t v3 = a2[1];
          unint64_t v2 = a2[2];
          int v4 = *((unsigned __int8 *)a2 + 24);
          if (v3 < v2 && !*((unsigned char *)a2 + 24))
          {
            unint64_t v22 = (char *)a1[2];
            do
            {
              if ((unint64_t)v22 >= *v9)
              {
                char v23 = (char *)*v8;
                uint64_t v24 = (v22 - (unsigned char *)*v8) >> 2;
                unint64_t v25 = v24 + 1;
                if ((unint64_t)(v24 + 1) >> 62) {
                  goto LABEL_119;
                }
                uint64_t v26 = *v9 - (void)v23;
                if (v26 >> 1 > v25) {
                  unint64_t v25 = v26 >> 1;
                }
                if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v27 = v25;
                }
                if (v27)
                {
                  char v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v27);
                  char v23 = (char *)a1[1];
                  unint64_t v22 = (char *)a1[2];
                }
                else
                {
                  char v28 = 0;
                }
                int v29 = &v28[4 * v24];
                *(_DWORD *)int v29 = 0;
                BOOL v30 = v29 + 4;
                while (v22 != v23)
                {
                  int v31 = *((_DWORD *)v22 - 1);
                  v22 -= 4;
                  *((_DWORD *)v29 - 1) = v31;
                  v29 -= 4;
                }
                a1[1] = v29;
                a1[2] = v30;
                a1[3] = &v28[4 * v27];
                if (v23) {
                  operator delete(v23);
                }
                unint64_t v22 = v30;
              }
              else
              {
                *(_DWORD *)unint64_t v22 = 0;
                v22 += 4;
              }
              a1[2] = v22;
              unint64_t v32 = a2[1];
              unint64_t v2 = a2[2];
              uint64_t v33 = *a2;
              char v34 = 0;
              unsigned int v35 = 0;
              uint64_t v36 = 0;
              BOOL v37 = v32 > 0xFFFFFFFFFFFFFFF5 || v32 + 10 > v2;
              if (!v37)
              {
                while (1)
                {
                  unint64_t v3 = v32 + 1;
                  a2[1] = v32 + 1;
                  char v40 = *(unsigned char *)(v33 + v32);
                  v36 |= (unint64_t)(v40 & 0x7F) << v34;
                  if ((v40 & 0x80) == 0) {
                    goto LABEL_68;
                  }
                  v34 += 7;
                  unint64_t v32 = v3;
                  BOOL v37 = v35++ > 8;
                  if (v37)
                  {
                    LODWORD(v36) = 0;
                    goto LABEL_68;
                  }
                }
              }
              if (v2 <= v32) {
                unint64_t v3 = a2[1];
              }
              else {
                unint64_t v3 = a2[2];
              }
              while (1)
              {
                if (v3 == v32)
                {
                  int v4 = 1;
                  *((unsigned char *)a2 + 24) = 1;
                  *((_DWORD *)v22 - 1) = 0;
                  goto LABEL_111;
                }
                unint64_t v38 = v32++;
                char v39 = *(unsigned char *)(v33 + v38);
                a2[1] = v32;
                v36 |= (unint64_t)(v39 & 0x7F) << v34;
                if ((v39 & 0x80) == 0) {
                  break;
                }
                v34 += 7;
                BOOL v37 = v35++ > 8;
                if (v37)
                {
                  LODWORD(v36) = 0;
                  goto LABEL_67;
                }
              }
              if (*((unsigned char *)a2 + 24)) {
                LODWORD(v36) = 0;
              }
LABEL_67:
              unint64_t v3 = v38 + 1;
LABEL_68:
              *((_DWORD *)v22 - 1) = v36;
              int v4 = *((unsigned __int8 *)a2 + 24);
            }
            while (v3 < v2 && !*((unsigned char *)a2 + 24));
          }
        }
        else
        {
          char v43 = (char *)a1[2];
          unint64_t v42 = a1[3];
          if ((unint64_t)v43 >= v42)
          {
            unint64_t v45 = (char *)*v8;
            uint64_t v46 = (v43 - (unsigned char *)*v8) >> 2;
            unint64_t v47 = v46 + 1;
            if ((unint64_t)(v46 + 1) >> 62) {
LABEL_119:
            }
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            uint64_t v48 = v42 - (void)v45;
            if (v48 >> 1 > v47) {
              unint64_t v47 = v48 >> 1;
            }
            if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v49 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v49 = v47;
            }
            if (v49)
            {
              BOOL v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v9, v49);
              unint64_t v45 = (char *)a1[1];
              char v43 = (char *)a1[2];
            }
            else
            {
              BOOL v50 = 0;
            }
            unint64_t v51 = &v50[4 * v46];
            *(_DWORD *)unint64_t v51 = 0;
            int v44 = v51 + 4;
            while (v43 != v45)
            {
              int v52 = *((_DWORD *)v43 - 1);
              v43 -= 4;
              *((_DWORD *)v51 - 1) = v52;
              v51 -= 4;
            }
            a1[1] = v51;
            a1[2] = v44;
            a1[3] = &v50[4 * v49];
            if (v45) {
              operator delete(v45);
            }
          }
          else
          {
            *(_DWORD *)char v43 = 0;
            int v44 = v43 + 4;
          }
          a1[2] = v44;
          unint64_t v53 = a2[1];
          unint64_t v2 = a2[2];
          uint64_t v54 = *a2;
          char v55 = 0;
          unsigned int v56 = 0;
          uint64_t v57 = 0;
          if (v53 > 0xFFFFFFFFFFFFFFF5 || v53 + 10 > v2)
          {
            if (v2 <= v53) {
              unint64_t v3 = a2[1];
            }
            else {
              unint64_t v3 = a2[2];
            }
            while (1)
            {
              if (v3 == v53)
              {
                LODWORD(v57) = 0;
                *((unsigned char *)a2 + 24) = 1;
                goto LABEL_110;
              }
              unint64_t v59 = v53++;
              char v60 = *(unsigned char *)(v54 + v59);
              a2[1] = v53;
              v57 |= (unint64_t)(v60 & 0x7F) << v55;
              if ((v60 & 0x80) == 0) {
                break;
              }
              v55 += 7;
              BOOL v37 = v56++ > 8;
              if (v37)
              {
                LODWORD(v57) = 0;
                goto LABEL_109;
              }
            }
            if (*((unsigned char *)a2 + 24)) {
              LODWORD(v57) = 0;
            }
LABEL_109:
            unint64_t v3 = v59 + 1;
          }
          else
          {
            while (1)
            {
              unint64_t v3 = v53 + 1;
              a2[1] = v53 + 1;
              char v61 = *(unsigned char *)(v54 + v53);
              v57 |= (unint64_t)(v61 & 0x7F) << v55;
              if ((v61 & 0x80) == 0) {
                break;
              }
              v55 += 7;
              unint64_t v53 = v3;
              BOOL v37 = v56++ > 8;
              if (v37)
              {
                LODWORD(v57) = 0;
                break;
              }
            }
          }
LABEL_110:
          *(v44 - 1) = v57;
          int v4 = *((unsigned __int8 *)a2 + 24);
        }
LABEL_111:
        int v41 = v4;
      }
      else
      {
        int v41 = 0;
      }
      if (v3 >= v2 || v41) {
        return v4 == 0;
      }
    }
    char v16 = 0;
    unsigned int v17 = 0;
    uint64_t v13 = 0;
    if (v3 <= v2) {
      unint64_t v18 = v2;
    }
    else {
      unint64_t v18 = v3;
    }
    while (v18 != v3)
    {
      unint64_t v19 = v3++;
      char v20 = *(unsigned char *)(v10 + v19);
      a2[1] = v3;
      v13 |= (unint64_t)(v20 & 0x7F) << v16;
      if ((v20 & 0x80) == 0) {
        goto LABEL_23;
      }
      v16 += 7;
      if (v17++ >= 9)
      {
        uint64_t v13 = 0;
LABEL_23:
        unint64_t v3 = v19 + 1;
        goto LABEL_24;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::server::SessionTokenList::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v2 = *(void *)(this + 8);
  for (uint64_t i = *(void *)(this + 16); v2 != i; this = PB::Writer::writeVarInt(a2))
    v2 += 4;
  return this;
}

uint64_t as::server::SessionTokenList::formatText(as::server::SessionTokenList *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *((void *)this + 2);
  while (v5 != v6)
  {
    v5 += 4;
    PB::TextFormatter::format(a2, "tokens");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::server::SessionTokenList::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 8);
  unint64_t v3 = *(_DWORD **)(a1 + 16);
  unint64_t v4 = v3 - v2;
  uint64_t v5 = *(_DWORD **)(a2 + 8);
  if (v4 != (uint64_t)(*(void *)(a2 + 16) - (void)v5) >> 2) {
    return 0;
  }
  if (v3 == v2) {
    return 1;
  }
  uint64_t v6 = v4 <= 1 ? 1 : v3 - v2;
  if (*v2 != *v5) {
    return 0;
  }
  uint64_t v7 = 1;
  do
  {
    unint64_t v8 = v7;
    if (v6 == v7) {
      break;
    }
    int v9 = v2[v7];
    int v10 = v5[v7++];
  }
  while (v9 == v10);
  return v8 >= v4;
}

void as::server::HardwareInfo::~HardwareInfo(as::server::HardwareInfo *this)
{
  as::server::HardwareInfo::~HardwareInfo(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26C312980;
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 48));
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 32));
  caulk::xstring::clear((as::server::HardwareInfo *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::server::Clock::~Clock(as::server::Clock *this)
{
  as::server::Clock::~Clock(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_26C312E18;
  uint64_t v2 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  caulk::xstring::clear((as::server::Clock *)((char *)this + 80));
  caulk::xstring::clear((as::server::Clock *)((char *)this + 64));
  unint64_t v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::HWStream::~HWStream(as::server::HWStream *this)
{
  as::server::HWStream::~HWStream(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;

  *(void *)this = &unk_26C312EF8;
  uint64_t v2 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  unint64_t v4 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v5);
  uint64_t v5 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v5);
  uint64_t v5 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v5);
  PB::Base::~Base(this);
}

void as::server::Device::~Device(as::server::Device *this)
{
  as::server::Device::~Device(this);
  JUMPOUT(0x21667A2D0);
}

{
  void **v2;
  void **v3;

  *(void *)this = &unk_26C312E50;
  uint64_t v2 = (void **)((char *)this + 16);
  unint64_t v3 = (void **)((char *)this + 88);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = v2;
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::Device_Clock::~Device_Clock(as::server::Device_Clock *this)
{
  as::server::Device_Clock::~Device_Clock(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26C312948;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  PB::Base::~Base(this);
}

void as::server::Box::~Box(as::server::Box *this)
{
  as::server::Box::~Box(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  void *v3;
  void *v4;
  void **v5;

  *(void *)this = &unk_26C312DA8;
  uint64_t v2 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 8);
  if (v3)
  {
    *((void *)this + 9) = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 5);
  if (v4)
  {
    *((void *)this + 6) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v5);
  PB::Base::~Base(this);
}

void as::server::Driver::~Driver(as::server::Driver *this)
{
  as::server::Driver::~Driver(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_26C312E88;
  uint64_t v2 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  caulk::xstring::clear((as::server::Driver *)((char *)this + 88));
  unint64_t v3 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::HardwareSystemState::~HardwareSystemState(as::server::HardwareSystemState *this)
{
  as::server::HardwareSystemState::~HardwareSystemState(this);
  JUMPOUT(0x21667A2D0);
}

{
  void **v2;
  void **v3;

  *(void *)this = &unk_26C312C90;
  uint64_t v2 = (void **)((char *)this + 8);
  unint64_t v3 = (void **)((char *)this + 32);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = v2;
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::SelectorControlItem::~SelectorControlItem(as::server::SelectorControlItem *this)
{
  as::server::SelectorControlItem::~SelectorControlItem(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26C312CC8;
  caulk::xstring::clear((as::server::SelectorControlItem *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::server::ControlValue::~ControlValue(as::server::ControlValue *this)
{
  as::server::ControlValue::~ControlValue(this);
  JUMPOUT(0x21667A2D0);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26C312910;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
  PB::Base::~Base(this);
}

void as::server::Control::~Control(as::server::Control *this)
{
  *(void *)this = &unk_26C312EC0;
  uint64_t v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

{
  void **v2;

  *(void *)this = &unk_26C312EC0;
  uint64_t v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
  MEMORY[0x21667A2D0]();
}

void as::server::ControlAndValue::~ControlAndValue(as::server::ControlAndValue *this)
{
  as::server::ControlAndValue::~ControlAndValue(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26C312A60;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  PB::Base::~Base(this);
}

void as::server::IOStreamState::~IOStreamState(as::server::IOStreamState *this)
{
  as::server::IOStreamState::~IOStreamState(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_26C3129F0;
  uint64_t v2 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::PortInvariants::~PortInvariants(as::server::PortInvariants *this)
{
  as::server::PortInvariants::~PortInvariants(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26C312A28;
  caulk::xstring::clear((as::server::PortInvariants *)((char *)this + 32));
  caulk::xstring::clear((as::server::PortInvariants *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::server::Port::~Port(as::server::Port *this)
{
  as::server::Port::~Port(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  void **v4;

  *(void *)this = &unk_26C312DE0;
  uint64_t v2 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  caulk::xstring::clear((as::server::Port *)((char *)this + 104));
  caulk::xstring::clear((as::server::Port *)((char *)this + 88));
  unint64_t v4 = (void **)((char *)this + 64);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v4);
  unint64_t v4 = (void **)((char *)this + 40);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v4);
  unint64_t v4 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v4);
  PB::Base::~Base(this);
}

void as::server::SessionUpdateSummary::~SessionUpdateSummary(as::server::SessionUpdateSummary *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x21667A2D0);
}

void as::server::ConfigChangeSummary::~ConfigChangeSummary(as::server::ConfigChangeSummary *this)
{
  as::server::ConfigChangeSummary::~ConfigChangeSummary(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_26C312C58;
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::CustomPropertyAddress::~CustomPropertyAddress(as::server::CustomPropertyAddress *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x21667A2D0);
}

void as::server::ObjectDescription::~ObjectDescription(as::server::ObjectDescription *this)
{
  as::server::ObjectDescription::~ObjectDescription(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t vars8;

  *(void *)this = &unk_26C312BE8;
  uint64_t v2 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  unint64_t v4 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  unint64_t v8 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  int v9 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  int v10 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  char v11 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  PB::Base::~Base(this);
}

void as::server::ChangedObject::~ChangedObject(as::server::ChangedObject *this)
{
  as::server::ChangedObject::~ChangedObject(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_26C3129B8;
  uint64_t v2 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void **)((char *)this + 104);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 80);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 56);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 32);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = (void **)((char *)this + 8);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::VirtualPort::~VirtualPort(as::server::VirtualPort *this)
{
  as::server::VirtualPort::~VirtualPort(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26C3128D8;
  uint64_t v2 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  caulk::xstring::clear((as::server::VirtualPort *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::server::MicrophoneConfiguration::~MicrophoneConfiguration(as::server::MicrophoneConfiguration *this)
{
  as::server::MicrophoneConfiguration::~MicrophoneConfiguration(this);
  JUMPOUT(0x21667A2D0);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26C312D70;
  caulk::xstring::clear((as::server::MicrophoneConfiguration *)((char *)this + 40));
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
  PB::Base::~Base(this);
}

void as::server::IOControllerState::~IOControllerState(as::server::IOControllerState *this)
{
  as::server::IOControllerState::~IOControllerState(this);
  JUMPOUT(0x21667A2D0);
}

{
  void **v2;

  *(void *)this = &unk_26C312BB0;
  caulk::xstring::clear((as::server::IOControllerState *)((char *)this + 88));
  uint64_t v2 = (void **)((char *)this + 64);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  uint64_t v2 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  uint64_t v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

void as::server::PlatformSupport::~PlatformSupport(as::server::PlatformSupport *this)
{
  as::server::PlatformSupport::~PlatformSupport(this);
  JUMPOUT(0x21667A2D0);
}

{
  void **v2;
  void **v3;

  *(void *)this = &unk_26C312A98;
  uint64_t v2 = (void **)((char *)this + 8);
  unint64_t v3 = (void **)((char *)this + 32);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = v2;
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::SessionServerState::~SessionServerState(as::server::SessionServerState *this)
{
  as::server::SessionServerState::~SessionServerState(this);
  JUMPOUT(0x21667A2D0);
}

{
  void **v2;
  void **v3;

  *(void *)this = &unk_26C312C20;
  uint64_t v2 = (void **)((char *)this + 16);
  unint64_t v3 = (void **)((char *)this + 40);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  unint64_t v3 = v2;
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::server::SessionFullState::~SessionFullState(as::server::SessionFullState *this)
{
  as::server::SessionFullState::~SessionFullState(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26C312B40;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  PB::Base::~Base(this);
}

void as::server::VirtualPortList::~VirtualPortList(as::server::VirtualPortList *this)
{
  *(void *)this = &unk_26C312AD0;
  uint64_t v2 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

{
  void **v2;

  *(void *)this = &unk_26C312AD0;
  uint64_t v2 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
  MEMORY[0x21667A2D0]();
}

void as::server::EligiblePortList::~EligiblePortList(as::server::EligiblePortList *this)
{
  as::server::EligiblePortList::~EligiblePortList(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26C312B08;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  PB::Base::~Base(this);
}

void as::server::SessionTokenList::~SessionTokenList(as::server::SessionTokenList *this)
{
  as::server::SessionTokenList::~SessionTokenList(this);
  JUMPOUT(0x21667A2D0);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26C312B78;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
  PB::Base::~Base(this);
}

uint64_t std::vector<std::unique_ptr<as::SampleRateRange>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::SampleRateRange>>,std::reverse_iterator<std::unique_ptr<as::SampleRateRange>*>,std::reverse_iterator<std::unique_ptr<as::SampleRateRange>*>,std::reverse_iterator<std::unique_ptr<as::SampleRateRange>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::SampleRateRange>>,std::reverse_iterator<std::unique_ptr<as::SampleRateRange>*>,std::reverse_iterator<std::unique_ptr<as::SampleRateRange>*>,std::reverse_iterator<std::unique_ptr<as::SampleRateRange>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::SampleRateRange>>,std::reverse_iterator<std::unique_ptr<as::SampleRateRange>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::SampleRateRange>>,std::reverse_iterator<std::unique_ptr<as::SampleRateRange>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::ControlAndValue>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::ControlAndValue>>,std::reverse_iterator<std::unique_ptr<as::server::ControlAndValue>*>,std::reverse_iterator<std::unique_ptr<as::server::ControlAndValue>*>,std::reverse_iterator<std::unique_ptr<as::server::ControlAndValue>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::ControlAndValue>>,std::reverse_iterator<std::unique_ptr<as::server::ControlAndValue>*>,std::reverse_iterator<std::unique_ptr<as::server::ControlAndValue>*>,std::reverse_iterator<std::unique_ptr<as::server::ControlAndValue>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::ControlAndValue>>,std::reverse_iterator<std::unique_ptr<as::server::ControlAndValue>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::ControlAndValue>>,std::reverse_iterator<std::unique_ptr<as::server::ControlAndValue>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::AvailableStreamFormat>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::AvailableStreamFormat>>,std::reverse_iterator<std::unique_ptr<as::AvailableStreamFormat>*>,std::reverse_iterator<std::unique_ptr<as::AvailableStreamFormat>*>,std::reverse_iterator<std::unique_ptr<as::AvailableStreamFormat>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::AvailableStreamFormat>>,std::reverse_iterator<std::unique_ptr<as::AvailableStreamFormat>*>,std::reverse_iterator<std::unique_ptr<as::AvailableStreamFormat>*>,std::reverse_iterator<std::unique_ptr<as::AvailableStreamFormat>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::AvailableStreamFormat>>,std::reverse_iterator<std::unique_ptr<as::AvailableStreamFormat>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::AvailableStreamFormat>>,std::reverse_iterator<std::unique_ptr<as::AvailableStreamFormat>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::HWStream>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::HWStream>>,std::reverse_iterator<std::unique_ptr<as::server::HWStream>*>,std::reverse_iterator<std::unique_ptr<as::server::HWStream>*>,std::reverse_iterator<std::unique_ptr<as::server::HWStream>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::HWStream>>,std::reverse_iterator<std::unique_ptr<as::server::HWStream>*>,std::reverse_iterator<std::unique_ptr<as::server::HWStream>*>,std::reverse_iterator<std::unique_ptr<as::server::HWStream>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::HWStream>>,std::reverse_iterator<std::unique_ptr<as::server::HWStream>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::HWStream>>,std::reverse_iterator<std::unique_ptr<as::server::HWStream>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::Port>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Port>>,std::reverse_iterator<std::unique_ptr<as::server::Port>*>,std::reverse_iterator<std::unique_ptr<as::server::Port>*>,std::reverse_iterator<std::unique_ptr<as::server::Port>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Port>>,std::reverse_iterator<std::unique_ptr<as::server::Port>*>,std::reverse_iterator<std::unique_ptr<as::server::Port>*>,std::reverse_iterator<std::unique_ptr<as::server::Port>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Port>>,std::reverse_iterator<std::unique_ptr<as::server::Port>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Port>>,std::reverse_iterator<std::unique_ptr<as::server::Port>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

char *std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  int v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned long long>::__vallocate[abi:ne180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    unsigned int v12 = (void **)(v7 + 1);
    int v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unsigned int v12 = (void **)(result + 8);
  char v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  long long v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    int v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    unint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unsigned int v12 = &v9[v17];
  return result;
}

char *std::vector<unsigned long long>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

uint64_t std::vector<std::unique_ptr<as::server::Device_Clock>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Device_Clock>>,std::reverse_iterator<std::unique_ptr<as::server::Device_Clock>*>,std::reverse_iterator<std::unique_ptr<as::server::Device_Clock>*>,std::reverse_iterator<std::unique_ptr<as::server::Device_Clock>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Device_Clock>>,std::reverse_iterator<std::unique_ptr<as::server::Device_Clock>*>,std::reverse_iterator<std::unique_ptr<as::server::Device_Clock>*>,std::reverse_iterator<std::unique_ptr<as::server::Device_Clock>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Device_Clock>>,std::reverse_iterator<std::unique_ptr<as::server::Device_Clock>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Device_Clock>>,std::reverse_iterator<std::unique_ptr<as::server::Device_Clock>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::Clock>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Clock>>,std::reverse_iterator<std::unique_ptr<as::server::Clock>*>,std::reverse_iterator<std::unique_ptr<as::server::Clock>*>,std::reverse_iterator<std::unique_ptr<as::server::Clock>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Clock>>,std::reverse_iterator<std::unique_ptr<as::server::Clock>*>,std::reverse_iterator<std::unique_ptr<as::server::Clock>*>,std::reverse_iterator<std::unique_ptr<as::server::Clock>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Clock>>,std::reverse_iterator<std::unique_ptr<as::server::Clock>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Clock>>,std::reverse_iterator<std::unique_ptr<as::server::Clock>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::Box>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Box>>,std::reverse_iterator<std::unique_ptr<as::server::Box>*>,std::reverse_iterator<std::unique_ptr<as::server::Box>*>,std::reverse_iterator<std::unique_ptr<as::server::Box>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Box>>,std::reverse_iterator<std::unique_ptr<as::server::Box>*>,std::reverse_iterator<std::unique_ptr<as::server::Box>*>,std::reverse_iterator<std::unique_ptr<as::server::Box>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Box>>,std::reverse_iterator<std::unique_ptr<as::server::Box>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Box>>,std::reverse_iterator<std::unique_ptr<as::server::Box>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::Driver>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Driver>>,std::reverse_iterator<std::unique_ptr<as::server::Driver>*>,std::reverse_iterator<std::unique_ptr<as::server::Driver>*>,std::reverse_iterator<std::unique_ptr<as::server::Driver>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::Driver>>,std::reverse_iterator<std::unique_ptr<as::server::Driver>*>,std::reverse_iterator<std::unique_ptr<as::server::Driver>*>,std::reverse_iterator<std::unique_ptr<as::server::Driver>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Driver>>,std::reverse_iterator<std::unique_ptr<as::server::Driver>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::Driver>>,std::reverse_iterator<std::unique_ptr<as::server::Driver>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::RouteIdentifier>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::RouteIdentifier>>,std::reverse_iterator<std::unique_ptr<as::RouteIdentifier>*>,std::reverse_iterator<std::unique_ptr<as::RouteIdentifier>*>,std::reverse_iterator<std::unique_ptr<as::RouteIdentifier>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::RouteIdentifier>>,std::reverse_iterator<std::unique_ptr<as::RouteIdentifier>*>,std::reverse_iterator<std::unique_ptr<as::RouteIdentifier>*>,std::reverse_iterator<std::unique_ptr<as::RouteIdentifier>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::RouteIdentifier>>,std::reverse_iterator<std::unique_ptr<as::RouteIdentifier>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::RouteIdentifier>>,std::reverse_iterator<std::unique_ptr<as::RouteIdentifier>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

char *std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  int v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 62) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned int>::__vallocate[abi:ne180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    unsigned int v12 = (void **)(v7 + 1);
    int v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      unint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unsigned int v12 = (void **)(result + 8);
  char v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  long long v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    int v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    unint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unsigned int v12 = &v9[v17];
  return result;
}

char *std::vector<unsigned int>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a2);
}

uint64_t std::vector<std::unique_ptr<as::server::SelectorControlItem>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::SelectorControlItem>>,std::reverse_iterator<std::unique_ptr<as::server::SelectorControlItem>*>,std::reverse_iterator<std::unique_ptr<as::server::SelectorControlItem>*>,std::reverse_iterator<std::unique_ptr<as::server::SelectorControlItem>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::SelectorControlItem>>,std::reverse_iterator<std::unique_ptr<as::server::SelectorControlItem>*>,std::reverse_iterator<std::unique_ptr<as::server::SelectorControlItem>*>,std::reverse_iterator<std::unique_ptr<as::server::SelectorControlItem>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::SelectorControlItem>>,std::reverse_iterator<std::unique_ptr<as::server::SelectorControlItem>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::SelectorControlItem>>,std::reverse_iterator<std::unique_ptr<as::server::SelectorControlItem>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::SessionUpdateSummary>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::SessionUpdateSummary>>,std::reverse_iterator<std::unique_ptr<as::server::SessionUpdateSummary>*>,std::reverse_iterator<std::unique_ptr<as::server::SessionUpdateSummary>*>,std::reverse_iterator<std::unique_ptr<as::server::SessionUpdateSummary>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::SessionUpdateSummary>>,std::reverse_iterator<std::unique_ptr<as::server::SessionUpdateSummary>*>,std::reverse_iterator<std::unique_ptr<as::server::SessionUpdateSummary>*>,std::reverse_iterator<std::unique_ptr<as::server::SessionUpdateSummary>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::SessionUpdateSummary>>,std::reverse_iterator<std::unique_ptr<as::server::SessionUpdateSummary>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::SessionUpdateSummary>>,std::reverse_iterator<std::unique_ptr<as::server::SessionUpdateSummary>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::CustomPropertyAddress>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::CustomPropertyAddress>>,std::reverse_iterator<std::unique_ptr<as::server::CustomPropertyAddress>*>,std::reverse_iterator<std::unique_ptr<as::server::CustomPropertyAddress>*>,std::reverse_iterator<std::unique_ptr<as::server::CustomPropertyAddress>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::CustomPropertyAddress>>,std::reverse_iterator<std::unique_ptr<as::server::CustomPropertyAddress>*>,std::reverse_iterator<std::unique_ptr<as::server::CustomPropertyAddress>*>,std::reverse_iterator<std::unique_ptr<as::server::CustomPropertyAddress>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::CustomPropertyAddress>>,std::reverse_iterator<std::unique_ptr<as::server::CustomPropertyAddress>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::CustomPropertyAddress>>,std::reverse_iterator<std::unique_ptr<as::server::CustomPropertyAddress>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::ObjectDescription>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::ObjectDescription>>,std::reverse_iterator<std::unique_ptr<as::server::ObjectDescription>*>,std::reverse_iterator<std::unique_ptr<as::server::ObjectDescription>*>,std::reverse_iterator<std::unique_ptr<as::server::ObjectDescription>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::ObjectDescription>>,std::reverse_iterator<std::unique_ptr<as::server::ObjectDescription>*>,std::reverse_iterator<std::unique_ptr<as::server::ObjectDescription>*>,std::reverse_iterator<std::unique_ptr<as::server::ObjectDescription>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::ObjectDescription>>,std::reverse_iterator<std::unique_ptr<as::server::ObjectDescription>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::ObjectDescription>>,std::reverse_iterator<std::unique_ptr<as::server::ObjectDescription>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::ChangedObject>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::ChangedObject>>,std::reverse_iterator<std::unique_ptr<as::server::ChangedObject>*>,std::reverse_iterator<std::unique_ptr<as::server::ChangedObject>*>,std::reverse_iterator<std::unique_ptr<as::server::ChangedObject>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::ChangedObject>>,std::reverse_iterator<std::unique_ptr<as::server::ChangedObject>*>,std::reverse_iterator<std::unique_ptr<as::server::ChangedObject>*>,std::reverse_iterator<std::unique_ptr<as::server::ChangedObject>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::ChangedObject>>,std::reverse_iterator<std::unique_ptr<as::server::ChangedObject>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::ChangedObject>>,std::reverse_iterator<std::unique_ptr<as::server::ChangedObject>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::IOStreamState>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::IOStreamState>>,std::reverse_iterator<std::unique_ptr<as::server::IOStreamState>*>,std::reverse_iterator<std::unique_ptr<as::server::IOStreamState>*>,std::reverse_iterator<std::unique_ptr<as::server::IOStreamState>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::IOStreamState>>,std::reverse_iterator<std::unique_ptr<as::server::IOStreamState>*>,std::reverse_iterator<std::unique_ptr<as::server::IOStreamState>*>,std::reverse_iterator<std::unique_ptr<as::server::IOStreamState>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::IOStreamState>>,std::reverse_iterator<std::unique_ptr<as::server::IOStreamState>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::IOStreamState>>,std::reverse_iterator<std::unique_ptr<as::server::IOStreamState>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::IOControllerState>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::IOControllerState>>,std::reverse_iterator<std::unique_ptr<as::server::IOControllerState>*>,std::reverse_iterator<std::unique_ptr<as::server::IOControllerState>*>,std::reverse_iterator<std::unique_ptr<as::server::IOControllerState>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::IOControllerState>>,std::reverse_iterator<std::unique_ptr<as::server::IOControllerState>*>,std::reverse_iterator<std::unique_ptr<as::server::IOControllerState>*>,std::reverse_iterator<std::unique_ptr<as::server::IOControllerState>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::IOControllerState>>,std::reverse_iterator<std::unique_ptr<as::server::IOControllerState>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::IOControllerState>>,std::reverse_iterator<std::unique_ptr<as::server::IOControllerState>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t std::vector<std::unique_ptr<as::server::VirtualPort>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::VirtualPort>>,std::reverse_iterator<std::unique_ptr<as::server::VirtualPort>*>,std::reverse_iterator<std::unique_ptr<as::server::VirtualPort>*>,std::reverse_iterator<std::unique_ptr<as::server::VirtualPort>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::server::VirtualPort>>,std::reverse_iterator<std::unique_ptr<as::server::VirtualPort>*>,std::reverse_iterator<std::unique_ptr<as::server::VirtualPort>*>,std::reverse_iterator<std::unique_ptr<as::server::VirtualPort>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    int v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::VirtualPort>>,std::reverse_iterator<std::unique_ptr<as::server::VirtualPort>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::server::VirtualPort>>,std::reverse_iterator<std::unique_ptr<as::server::VirtualPort>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

uint64_t as::smipc_Server_types_utility::updateDefaultRoute(as::smipc_Server_types_utility *this, const as::RouteIdentifier *a2, as::server::HardwareSystemState *a3)
{
  uint64_t result = as::RouteIdentifier::isInitialized(this);
  if ((result & 1) == 0) {
    as::smipc_Server_types_utility::updateDefaultRoute();
  }
  uint64_t v7 = (uint64_t *)*((void *)a2 + 4);
  uint64_t v6 = (uint64_t *)*((void *)a2 + 5);
  if (v7 != v6)
  {
    while (*(_DWORD *)(*v7 + 24) != *((_DWORD *)this + 6))
    {
      if (++v7 == v6) {
        goto LABEL_9;
      }
    }
  }
  if (v7 == v6)
  {
LABEL_9:
    if (*((void *)this + 2)) {
      as::server::HardwareSystemState::addDefaultRoutes(a2);
    }
  }
  else if (*((void *)this + 2))
  {
    uint64_t v8 = (as::RouteIdentifier *)*v7;
    return (uint64_t)as::RouteIdentifier::operator=(v8, this);
  }
  else
  {
    uint64_t result = (uint64_t)std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<as::RouteIdentifier> *,std::unique_ptr<as::RouteIdentifier> *,std::unique_ptr<as::RouteIdentifier> *,0>(v7 + 1, v6, v7);
    uint64_t v10 = v9;
    uint64_t v11 = (void *)*((void *)a2 + 5);
    if (v11 != v9)
    {
      do
      {
        uint64_t v12 = *--v11;
        uint64_t result = v12;
        *uint64_t v11 = 0;
        if (v12) {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
        }
      }
      while (v11 != v10);
    }
    *((void *)a2 + 5) = v10;
  }
  return result;
}

uint64_t *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<as::RouteIdentifier> *,std::unique_ptr<as::RouteIdentifier> *,std::unique_ptr<as::RouteIdentifier> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      uint64_t v6 = *v4;
      uint64_t *v4 = 0;
      uint64_t v7 = *a3;
      *a3 = v6;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
      ++v4;
      ++a3;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

void as::SetServerXPCListenerEndpoint(id obj, NSXPCListenerEndpoint *a2)
{
}

uint64_t as::ChannelDescription::default_instance(as::ChannelDescription *this)
{
  {
    operator new();
  }
  return as::ChannelDescription::default_instance(void)::gInstance;
}

void sub_210AE6B10(_Unwind_Exception *a1)
{
}

void *as::ChannelDescription::ChannelDescription(void *this)
{
  *this = &unk_26C312650;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

{
  *this = &unk_26C312650;
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

__n128 as::ChannelDescription::ChannelDescription(as::ChannelDescription *this, const as::ChannelDescription *a2)
{
  *(void *)this = &unk_26C312650;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 12);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

{
  __n128 result;

  *(void *)this = &unk_26C312650;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 12);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

__n128 as::ChannelDescription::copy_from(as::ChannelDescription *this, const as::ChannelDescription *a2)
{
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 12);
  *((_DWORD *)this + 7) = *((_DWORD *)a2 + 7);
  *(__n128 *)((char *)this + 12) = result;
  return result;
}

__n128 as::ChannelDescription::operator=(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

{
  __n128 result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

__n128 as::ChannelDescription::ChannelDescription(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312650;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

{
  __n128 result;

  *(void *)a1 = &unk_26C312650;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

__n128 as::ChannelDescription::move_from(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 12);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(__n128 *)(a1 + 12) = result;
  return result;
}

void *as::ChannelDescription::clear(void *this)
{
  this[1] = 0;
  this[2] = 0;
  this[3] = 0;
  return this;
}

uint64_t as::ChannelDescription::isInitialized(as::ChannelDescription *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::ChannelDescription::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (2)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        char v13 = 0;
        unsigned int v14 = 0;
        unint64_t v9 = 0;
        if (v2 <= v3) {
          unint64_t v15 = v3;
        }
        else {
          unint64_t v15 = v2;
        }
        while (v15 != v2)
        {
          unint64_t v16 = v2++;
          char v17 = *(unsigned char *)(v6 + v16);
          a2[1] = v2;
          v9 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0) {
            goto LABEL_22;
          }
          v13 += 7;
          BOOL v18 = v14++ >= 9;
          if (v18)
          {
            unint64_t v9 = 0;
LABEL_22:
            unint64_t v2 = v16 + 1;
            goto LABEL_23;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v7 = 0;
        unsigned int v8 = 0;
        unint64_t v9 = 0;
        while (1)
        {
          unint64_t v10 = v2 + 1;
          a2[1] = v2 + 1;
          char v11 = *(unsigned char *)(v6 + v2);
          v9 |= (unint64_t)(v11 & 0x7F) << v7;
          if ((v11 & 0x80) == 0) {
            break;
          }
          v7 += 7;
          unint64_t v2 = v10;
          BOOL v12 = v8++ > 8;
          if (v12)
          {
            unint64_t v9 = 0;
            break;
          }
        }
        unint64_t v2 = v10;
LABEL_23:
        if ((v9 & 7) != 4)
        {
          switch((v9 >> 3))
          {
            case 1u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v27 = 0;
                unsigned int v28 = 0;
                uint64_t v21 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                do
                {
                  if (v3 == v2)
                  {
                    LODWORD(v21) = 0;
                    *((unsigned char *)a2 + 24) = 1;
                    goto LABEL_71;
                  }
                  unint64_t v29 = v2++;
                  char v30 = *(unsigned char *)(v6 + v29);
                  a2[1] = v2;
                  v21 |= (unint64_t)(v30 & 0x7F) << v27;
                  if ((v30 & 0x80) == 0) {
                    goto LABEL_55;
                  }
                  v27 += 7;
                  BOOL v18 = v28++ >= 9;
                }
                while (!v18);
                LODWORD(v21) = 0;
LABEL_55:
                unint64_t v3 = v29 + 1;
              }
              else
              {
                char v19 = 0;
                unsigned int v20 = 0;
                uint64_t v21 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v22 = *(unsigned char *)(v6 + v2);
                  v21 |= (unint64_t)(v22 & 0x7F) << v19;
                  if ((v22 & 0x80) == 0) {
                    goto LABEL_71;
                  }
                  v19 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v20++ > 8;
                }
                while (!v12);
                LODWORD(v21) = 0;
              }
LABEL_71:
              a1[6] = v21;
              int v35 = 1;
              goto LABEL_74;
            case 2u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v31 = 0;
                unsigned int v32 = 0;
                uint64_t v25 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                while (v3 != v2)
                {
                  unint64_t v33 = v2++;
                  char v34 = *(unsigned char *)(v6 + v33);
                  a2[1] = v2;
                  v25 |= (unint64_t)(v34 & 0x7F) << v31;
                  if ((v34 & 0x80) == 0) {
                    goto LABEL_63;
                  }
                  v31 += 7;
                  BOOL v18 = v32++ >= 9;
                  if (v18)
                  {
                    LODWORD(v25) = 0;
LABEL_63:
                    unint64_t v3 = v33 + 1;
                    goto LABEL_73;
                  }
                }
                LODWORD(v25) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v23 = 0;
                unsigned int v24 = 0;
                uint64_t v25 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v26 = *(unsigned char *)(v6 + v2);
                  v25 |= (unint64_t)(v26 & 0x7F) << v23;
                  if ((v26 & 0x80) == 0) {
                    goto LABEL_73;
                  }
                  v23 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v24++ > 8;
                }
                while (!v12);
                LODWORD(v25) = 0;
              }
LABEL_73:
              a1[7] = v25;
              int v35 = 2;
LABEL_74:
              unint64_t v2 = v3;
LABEL_75:
              a1[2] |= v35;
LABEL_76:
              unint64_t v3 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v2 >= v3 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 3u:
              if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                a1[3] = *(_DWORD *)(v6 + v2);
                unint64_t v2 = a2[1] + 4;
                a2[1] = v2;
              }
              int v35 = 4;
              goto LABEL_75;
            case 4u:
              if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                a1[4] = *(_DWORD *)(v6 + v2);
                unint64_t v2 = a2[1] + 4;
                a2[1] = v2;
              }
              int v35 = 8;
              goto LABEL_75;
            case 5u:
              if (v2 > 0xFFFFFFFFFFFFFFFBLL || v2 + 4 > v3)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                a1[5] = *(_DWORD *)(v6 + v2);
                unint64_t v2 = a2[1] + 4;
                a2[1] = v2;
              }
              int v35 = 16;
              goto LABEL_75;
            default:
              goto LABEL_76;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

uint64_t as::ChannelDescription::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::writeVarInt(a2);
    int v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    this = PB::Writer::write(a2, *(float *)(v3 + 16));
    if ((*(_DWORD *)(v3 + 8) & 0x10) == 0) {
      return this;
    }
    goto LABEL_11;
  }
LABEL_9:
  this = PB::Writer::write(a2, *(float *)(v3 + 12));
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 8) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v4 & 0x10) == 0) {
    return this;
  }
LABEL_11:
  float v5 = *(float *)(v3 + 20);
  return PB::Writer::write(a2, v5);
}

uint64_t as::ChannelDescription::formatText(as::ChannelDescription *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "flags");
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "label");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  PB::TextFormatter::format(a2, "coord0", *((float *)this + 3));
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_13:
  PB::TextFormatter::format(a2, "coord1", *((float *)this + 4));
  if ((*((_DWORD *)this + 2) & 0x10) != 0) {
LABEL_6:
  }
    PB::TextFormatter::format(a2, "coord2", *((float *)this + 5));
LABEL_7:
  return PB::TextFormatter::endObject(a2);
}

BOOL as::ChannelDescription::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  return *(void *)(a1 + 12) == *(void *)(a2 + 12)
      && *(void *)(a1 + 20) == *(void *)(a2 + 20)
      && *(_DWORD *)(a1 + 28) == (unint64_t)*(unsigned int *)(a2 + 28);
}

uint64_t as::ChannelLayout::default_instance(as::ChannelLayout *this)
{
  {
    operator new();
  }
  return as::ChannelLayout::default_instance(void)::gInstance;
}

void sub_210AE7300(_Unwind_Exception *a1)
{
}

double as::ChannelLayout::ChannelLayout(as::ChannelLayout *this)
{
  *(void *)this = &unk_26C3124F0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C3124F0;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  return result;
}

as::ChannelLayout *as::ChannelLayout::ChannelLayout(as::ChannelLayout *this, const as::ChannelLayout *a2)
{
  *(void *)this = &unk_26C3124F0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  as::ChannelLayout::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3124F0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  as::ChannelLayout::copy_from(this, a2);
  return this;
}

void *as::ChannelLayout::copy_from(as::ChannelLayout *this, const as::ChannelLayout *a2)
{
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  if (*((void *)a2 + 2) != *((void *)a2 + 3)) {
    operator new();
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 5) = *((void *)a2 + 5);
  return result;
}

void sub_210AE7538(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::ChannelLayout *as::ChannelLayout::operator=(as::ChannelLayout *a1, const as::ChannelLayout *a2)
{
  return a1;
}

uint64_t as::ChannelLayout::ChannelLayout(uint64_t result, uint64_t a2)
{
  *(void *)double result = &unk_26C3124F0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v2;
  uint64_t v3 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v3;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  return result;
}

{
  uint64_t v2;
  uint64_t v3;

  *(void *)double result = &unk_26C3124F0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  uint64_t v2 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v2;
  uint64_t v3 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v3;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  return result;
}

uint64_t as::ChannelLayout::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  return result;
}

uint64_t as::ChannelLayout::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  uint64_t v3 = *(void *)(result + 24);
  *(void *)(result + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v3;
  uint64_t v4 = *(void *)(result + 32);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  return result;
}

void *as::ChannelLayout::clear(as::ChannelLayout *this)
{
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 2);
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 5) = 0;
  return result;
}

uint64_t as::ChannelLayout::isInitialized(as::ChannelLayout *this)
{
  for (uint64_t i = *((void *)this + 2); ; i += 8)
  {
    if (i == *((void *)this + 3)) {
      return *((unsigned char *)this + 8) & 1;
    }
    if ((*(unsigned char *)(*(void *)i + 8) & 1) == 0) {
      break;
    }
  }
  return 0;
}

BOOL as::ChannelLayout::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v6 = *a2;
    if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
      break;
    }
    char v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v10 = v3 + 1;
      a2[1] = v3 + 1;
      char v11 = *(unsigned char *)(v6 + v3);
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0) {
        break;
      }
      v7 += 7;
      unint64_t v3 = v10;
      BOOL v12 = v8++ > 8;
      if (v12)
      {
        unint64_t v9 = 0;
        break;
      }
    }
    unint64_t v3 = v10;
LABEL_23:
    if ((v9 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v19 = v9 >> 3;
    switch(v19)
    {
      case 3:
        operator new();
      case 2:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v29 = 0;
          unsigned int v30 = 0;
          uint64_t v27 = 0;
          if (v2 <= v3) {
            unint64_t v23 = v3;
          }
          else {
            unint64_t v23 = v2;
          }
          while (v23 != v3)
          {
            unint64_t v31 = v3++;
            char v32 = *(unsigned char *)(v6 + v31);
            a2[1] = v3;
            v27 |= (unint64_t)(v32 & 0x7F) << v29;
            if ((v32 & 0x80) == 0) {
              goto LABEL_50;
            }
            v29 += 7;
            BOOL v18 = v30++ >= 9;
            if (v18)
            {
              LODWORD(v27) = 0;
LABEL_50:
              unint64_t v23 = v31 + 1;
              goto LABEL_61;
            }
          }
          LODWORD(v27) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v27 = 0;
          while (1)
          {
            unint64_t v23 = v3 + 1;
            a2[1] = v3 + 1;
            char v28 = *(unsigned char *)(v6 + v3);
            v27 |= (unint64_t)(v28 & 0x7F) << v25;
            if ((v28 & 0x80) == 0) {
              break;
            }
            v25 += 7;
            unint64_t v3 = v23;
            BOOL v12 = v26++ > 8;
            if (v12)
            {
              LODWORD(v27) = 0;
              break;
            }
          }
        }
LABEL_61:
        a1[11] = v27;
        int v37 = a1[2] | 2;
        break;
      case 1:
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v33 = 0;
          unsigned int v34 = 0;
          uint64_t v22 = 0;
          if (v2 <= v3) {
            unint64_t v23 = v3;
          }
          else {
            unint64_t v23 = v2;
          }
          while (v23 != v3)
          {
            unint64_t v35 = v3++;
            char v36 = *(unsigned char *)(v6 + v35);
            a2[1] = v3;
            v22 |= (unint64_t)(v36 & 0x7F) << v33;
            if ((v36 & 0x80) == 0) {
              goto LABEL_59;
            }
            v33 += 7;
            BOOL v18 = v34++ >= 9;
            if (v18)
            {
              LODWORD(v22) = 0;
LABEL_59:
              unint64_t v23 = v35 + 1;
              goto LABEL_63;
            }
          }
          LODWORD(v22) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v20 = 0;
          unsigned int v21 = 0;
          uint64_t v22 = 0;
          while (1)
          {
            unint64_t v23 = v3 + 1;
            a2[1] = v3 + 1;
            char v24 = *(unsigned char *)(v6 + v3);
            v22 |= (unint64_t)(v24 & 0x7F) << v20;
            if ((v24 & 0x80) == 0) {
              break;
            }
            v20 += 7;
            unint64_t v3 = v23;
            BOOL v12 = v21++ > 8;
            if (v12)
            {
              LODWORD(v22) = 0;
              break;
            }
          }
        }
LABEL_63:
        a1[10] = v22;
        int v37 = a1[2] | 1;
        break;
      default:
        goto LABEL_65;
    }
    a1[2] = v37;
    unint64_t v3 = v23;
LABEL_65:
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
      return v4 == 0;
    }
  }
  char v13 = 0;
  unsigned int v14 = 0;
  unint64_t v9 = 0;
  if (v3 <= v2) {
    unint64_t v15 = v2;
  }
  else {
    unint64_t v15 = v3;
  }
  while (v15 != v3)
  {
    unint64_t v16 = v3++;
    char v17 = *(unsigned char *)(v6 + v16);
    a2[1] = v3;
    v9 |= (unint64_t)(v17 & 0x7F) << v13;
    if ((v17 & 0x80) == 0) {
      goto LABEL_22;
    }
    v13 += 7;
    BOOL v18 = v14++ >= 9;
    if (v18)
    {
      unint64_t v9 = 0;
LABEL_22:
      unint64_t v3 = v16 + 1;
      goto LABEL_23;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

void sub_210AE7BE4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::ChannelLayout::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::writeVarInt(a2);
    int v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0) {
    this = PB::Writer::writeVarInt(a2);
  }
  uint64_t v6 = *(const PB::Base ***)(v3 + 16);
  int v5 = *(const PB::Base ***)(v3 + 24);
  while (v6 != v5)
  {
    char v7 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  return this;
}

uint64_t as::ChannelLayout::formatText(as::ChannelLayout *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "tag");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "bitmap");
  }
  uint64_t v6 = (uint64_t *)*((void *)this + 2);
  char v7 = (uint64_t *)*((void *)this + 3);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "descriptions");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::ChannelLayout::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && *(void *)(a1 + 40) == *(void *)(a2 + 40)
    && (uint64_t v3 = *(void *)(a1 + 16),
        uint64_t v2 = *(void *)(a1 + 24),
        unint64_t v4 = (v2 - v3) >> 3,
        uint64_t v5 = *(void *)(a2 + 16),
        v4 == (*(void *)(a2 + 24) - v5) >> 3))
  {
    if (v2 == v3)
    {
      return 1;
    }
    else
    {
      BOOL v6 = 0;
      uint64_t v7 = 0;
      if (v4 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = (v2 - v3) >> 3;
      }
      do
      {
        uint64_t v9 = *(void *)(v3 + 8 * v7);
        uint64_t v10 = *(void *)(v5 + 8 * v7);
        if (v9) {
          BOOL v11 = v10 == 0;
        }
        else {
          BOOL v11 = 1;
        }
        if (v11)
        {
          if (v9 | v10) {
            return v6;
          }
        }
        else if (!as::ChannelDescription::operator==(v9, v10))
        {
          return v6;
        }
        BOOL v6 = ++v7 >= v4;
      }
      while (v8 != v7);
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

void as::ChannelLayout::addDescriptions(as::ChannelLayout *this)
{
  unint64_t v4 = *((void *)this + 4);
  uint64_t v2 = (char *)this + 32;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      char v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      char v13 = 0;
    }
    unsigned int v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)unsigned int v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::ChannelDescription>>::__swap_out_circular_buffer(v7, v15);
    BOOL v6 = (void *)*((void *)this + 3);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    BOOL v6 = v5 + 1;
    *((void *)this + 3) = v6;
  }
  *((void *)this + 3) = v6;
  operator new();
}

void sub_210AE7F90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::StreamFormat::default_instance(as::StreamFormat *this)
{
  {
    operator new();
  }
  return as::StreamFormat::default_instance(void)::gInstance;
}

void sub_210AE8040(_Unwind_Exception *a1)
{
}

double as::StreamFormat::StreamFormat(as::StreamFormat *this)
{
  *(void *)this = &unk_26C3124B8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C3124B8;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 44) = 0u;
  return result;
}

as::StreamFormat *as::StreamFormat::StreamFormat(as::StreamFormat *this, const as::StreamFormat *a2)
{
  *(void *)this = &unk_26C3124B8;
  *((void *)this + 2) = 0;
  as::StreamFormat::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3124B8;
  *((void *)this + 2) = 0;
  as::StreamFormat::copy_from(this, a2);
  return this;
}

__n128 as::StreamFormat::copy_from(as::StreamFormat *this, const as::StreamFormat *a2)
{
  unint64_t v4 = (const as::ChannelLayout *)*((void *)a2 + 2);
  if (v4)
  {
    uint64_t v5 = (as::ChannelLayout *)as::StreamFormat::mutableLayout(this);
    as::ChannelLayout::copy_from(v5, v4);
  }
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  __n128 result = *(__n128 *)((char *)a2 + 24);
  long long v7 = *(_OWORD *)((char *)a2 + 40);
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  *(_OWORD *)((char *)this + 40) = v7;
  *(__n128 *)((char *)this + 24) = result;
  return result;
}

as::StreamFormat *as::StreamFormat::operator=(as::StreamFormat *a1, const as::StreamFormat *a2)
{
  return a1;
}

uint64_t as::StreamFormat::layout(as::StreamFormat *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return as::ChannelLayout::default_instance(0);
  }
  return result;
}

uint64_t as::StreamFormat::mutableLayout(as::StreamFormat *this)
{
  if (!*((void *)this + 2)) {
    operator new();
  }
  return *((void *)this + 2);
}

__n128 as::StreamFormat::StreamFormat(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C3124B8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 24);
  long long v3 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v3;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

{
  __n128 result;
  long long v3;

  *(void *)a1 = &unk_26C3124B8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 24);
  long long v3 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v3;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

__n128 as::StreamFormat::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 24);
  long long v4 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v4;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

__n128 as::StreamFormat::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __n128 result = *(__n128 *)(a2 + 24);
  long long v4 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v4;
  *(__n128 *)(a1 + 24) = result;
  return result;
}

double as::StreamFormat::clear(as::StreamFormat *this)
{
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  return result;
}

BOOL as::StreamFormat::isInitialized(as::StreamFormat *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (!v1) {
    return 0;
  }
  for (uint64_t i = *(void *)(v1 + 16); i != *(void *)(v1 + 24); i += 8)
  {
    if ((*(unsigned char *)(*(void *)i + 8) & 1) == 0) {
      return 0;
    }
  }
  return (*(unsigned char *)(v1 + 8) & 1) != 0 && *((unsigned __int8 *)this + 8) == 0xFF;
}

BOOL as::StreamFormat::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (2)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        char v13 = 0;
        unsigned int v14 = 0;
        unint64_t v9 = 0;
        if (v2 <= v3) {
          unint64_t v15 = v3;
        }
        else {
          unint64_t v15 = v2;
        }
        while (v15 != v2)
        {
          unint64_t v16 = v2++;
          char v17 = *(unsigned char *)(v6 + v16);
          a2[1] = v2;
          v9 |= (unint64_t)(v17 & 0x7F) << v13;
          if ((v17 & 0x80) == 0) {
            goto LABEL_22;
          }
          v13 += 7;
          BOOL v18 = v14++ >= 9;
          if (v18)
          {
            unint64_t v9 = 0;
LABEL_22:
            unint64_t v2 = v16 + 1;
            goto LABEL_23;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v7 = 0;
        unsigned int v8 = 0;
        unint64_t v9 = 0;
        while (1)
        {
          unint64_t v10 = v2 + 1;
          a2[1] = v2 + 1;
          char v11 = *(unsigned char *)(v6 + v2);
          v9 |= (unint64_t)(v11 & 0x7F) << v7;
          if ((v11 & 0x80) == 0) {
            break;
          }
          v7 += 7;
          unint64_t v2 = v10;
          BOOL v12 = v8++ > 8;
          if (v12)
          {
            unint64_t v9 = 0;
            break;
          }
        }
        unint64_t v2 = v10;
LABEL_23:
        if ((v9 & 7) != 4)
        {
          switch((v9 >> 3))
          {
            case 1u:
              if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > v3)
              {
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                *(void *)(a1 + 24) = *(void *)(v6 + v2);
                unint64_t v2 = a2[1] + 8;
                a2[1] = v2;
              }
              *(_DWORD *)(a1 + 8) |= 1u;
              goto LABEL_151;
            case 2u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v47 = 0;
                unsigned int v48 = 0;
                uint64_t v21 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                while (v3 != v2)
                {
                  unint64_t v49 = v2++;
                  char v50 = *(unsigned char *)(v6 + v49);
                  a2[1] = v2;
                  v21 |= (unint64_t)(v50 & 0x7F) << v47;
                  if ((v50 & 0x80) == 0) {
                    goto LABEL_87;
                  }
                  v47 += 7;
                  BOOL v18 = v48++ >= 9;
                  if (v18)
                  {
                    LODWORD(v21) = 0;
LABEL_87:
                    unint64_t v3 = v49 + 1;
                    goto LABEL_137;
                  }
                }
                LODWORD(v21) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v19 = 0;
                unsigned int v20 = 0;
                uint64_t v21 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v22 = *(unsigned char *)(v6 + v2);
                  v21 |= (unint64_t)(v22 & 0x7F) << v19;
                  if ((v22 & 0x80) == 0) {
                    goto LABEL_137;
                  }
                  v19 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v20++ > 8;
                }
                while (!v12);
                LODWORD(v21) = 0;
              }
LABEL_137:
              *(_DWORD *)(a1 + 32) = v21;
              int v75 = *(_DWORD *)(a1 + 8) | 2;
              goto LABEL_150;
            case 3u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v51 = 0;
                unsigned int v52 = 0;
                uint64_t v25 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                while (v3 != v2)
                {
                  unint64_t v53 = v2++;
                  char v54 = *(unsigned char *)(v6 + v53);
                  a2[1] = v2;
                  v25 |= (unint64_t)(v54 & 0x7F) << v51;
                  if ((v54 & 0x80) == 0) {
                    goto LABEL_95;
                  }
                  v51 += 7;
                  BOOL v18 = v52++ >= 9;
                  if (v18)
                  {
                    LODWORD(v25) = 0;
LABEL_95:
                    unint64_t v3 = v53 + 1;
                    goto LABEL_139;
                  }
                }
                LODWORD(v25) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v23 = 0;
                unsigned int v24 = 0;
                uint64_t v25 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v26 = *(unsigned char *)(v6 + v2);
                  v25 |= (unint64_t)(v26 & 0x7F) << v23;
                  if ((v26 & 0x80) == 0) {
                    goto LABEL_139;
                  }
                  v23 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v24++ > 8;
                }
                while (!v12);
                LODWORD(v25) = 0;
              }
LABEL_139:
              *(_DWORD *)(a1 + 36) = v25;
              int v75 = *(_DWORD *)(a1 + 8) | 4;
              goto LABEL_150;
            case 4u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v55 = 0;
                unsigned int v56 = 0;
                uint64_t v29 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                while (v3 != v2)
                {
                  unint64_t v57 = v2++;
                  char v58 = *(unsigned char *)(v6 + v57);
                  a2[1] = v2;
                  v29 |= (unint64_t)(v58 & 0x7F) << v55;
                  if ((v58 & 0x80) == 0) {
                    goto LABEL_103;
                  }
                  v55 += 7;
                  BOOL v18 = v56++ >= 9;
                  if (v18)
                  {
                    LODWORD(v29) = 0;
LABEL_103:
                    unint64_t v3 = v57 + 1;
                    goto LABEL_141;
                  }
                }
                LODWORD(v29) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v27 = 0;
                unsigned int v28 = 0;
                uint64_t v29 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v30 = *(unsigned char *)(v6 + v2);
                  v29 |= (unint64_t)(v30 & 0x7F) << v27;
                  if ((v30 & 0x80) == 0) {
                    goto LABEL_141;
                  }
                  v27 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v28++ > 8;
                }
                while (!v12);
                LODWORD(v29) = 0;
              }
LABEL_141:
              *(_DWORD *)(a1 + 40) = v29;
              int v75 = *(_DWORD *)(a1 + 8) | 8;
              goto LABEL_150;
            case 5u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v59 = 0;
                unsigned int v60 = 0;
                uint64_t v33 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                while (v3 != v2)
                {
                  unint64_t v61 = v2++;
                  char v62 = *(unsigned char *)(v6 + v61);
                  a2[1] = v2;
                  v33 |= (unint64_t)(v62 & 0x7F) << v59;
                  if ((v62 & 0x80) == 0) {
                    goto LABEL_111;
                  }
                  v59 += 7;
                  BOOL v18 = v60++ >= 9;
                  if (v18)
                  {
                    LODWORD(v33) = 0;
LABEL_111:
                    unint64_t v3 = v61 + 1;
                    goto LABEL_143;
                  }
                }
                LODWORD(v33) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v31 = 0;
                unsigned int v32 = 0;
                uint64_t v33 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v34 = *(unsigned char *)(v6 + v2);
                  v33 |= (unint64_t)(v34 & 0x7F) << v31;
                  if ((v34 & 0x80) == 0) {
                    goto LABEL_143;
                  }
                  v31 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v32++ > 8;
                }
                while (!v12);
                LODWORD(v33) = 0;
              }
LABEL_143:
              *(_DWORD *)(a1 + 44) = v33;
              int v75 = *(_DWORD *)(a1 + 8) | 0x10;
              goto LABEL_150;
            case 6u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v63 = 0;
                unsigned int v64 = 0;
                uint64_t v37 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                while (v3 != v2)
                {
                  unint64_t v65 = v2++;
                  char v66 = *(unsigned char *)(v6 + v65);
                  a2[1] = v2;
                  v37 |= (unint64_t)(v66 & 0x7F) << v63;
                  if ((v66 & 0x80) == 0) {
                    goto LABEL_119;
                  }
                  v63 += 7;
                  BOOL v18 = v64++ >= 9;
                  if (v18)
                  {
                    LODWORD(v37) = 0;
LABEL_119:
                    unint64_t v3 = v65 + 1;
                    goto LABEL_145;
                  }
                }
                LODWORD(v37) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v35 = 0;
                unsigned int v36 = 0;
                uint64_t v37 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v38 = *(unsigned char *)(v6 + v2);
                  v37 |= (unint64_t)(v38 & 0x7F) << v35;
                  if ((v38 & 0x80) == 0) {
                    goto LABEL_145;
                  }
                  v35 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v36++ > 8;
                }
                while (!v12);
                LODWORD(v37) = 0;
              }
LABEL_145:
              *(_DWORD *)(a1 + 48) = v37;
              int v75 = *(_DWORD *)(a1 + 8) | 0x20;
              goto LABEL_150;
            case 7u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v67 = 0;
                unsigned int v68 = 0;
                uint64_t v41 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                while (v3 != v2)
                {
                  unint64_t v69 = v2++;
                  char v70 = *(unsigned char *)(v6 + v69);
                  a2[1] = v2;
                  v41 |= (unint64_t)(v70 & 0x7F) << v67;
                  if ((v70 & 0x80) == 0) {
                    goto LABEL_127;
                  }
                  v67 += 7;
                  BOOL v18 = v68++ >= 9;
                  if (v18)
                  {
                    LODWORD(v41) = 0;
LABEL_127:
                    unint64_t v3 = v69 + 1;
                    goto LABEL_147;
                  }
                }
                LODWORD(v41) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v39 = 0;
                unsigned int v40 = 0;
                uint64_t v41 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v42 = *(unsigned char *)(v6 + v2);
                  v41 |= (unint64_t)(v42 & 0x7F) << v39;
                  if ((v42 & 0x80) == 0) {
                    goto LABEL_147;
                  }
                  v39 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v40++ > 8;
                }
                while (!v12);
                LODWORD(v41) = 0;
              }
LABEL_147:
              *(_DWORD *)(a1 + 52) = v41;
              int v75 = *(_DWORD *)(a1 + 8) | 0x40;
              goto LABEL_150;
            case 8u:
              if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
              {
                char v71 = 0;
                unsigned int v72 = 0;
                uint64_t v45 = 0;
                if (v3 <= v2) {
                  unint64_t v3 = v2;
                }
                while (v3 != v2)
                {
                  unint64_t v73 = v2++;
                  char v74 = *(unsigned char *)(v6 + v73);
                  a2[1] = v2;
                  v45 |= (unint64_t)(v74 & 0x7F) << v71;
                  if ((v74 & 0x80) == 0) {
                    goto LABEL_135;
                  }
                  v71 += 7;
                  BOOL v18 = v72++ >= 9;
                  if (v18)
                  {
                    LODWORD(v45) = 0;
LABEL_135:
                    unint64_t v3 = v73 + 1;
                    goto LABEL_149;
                  }
                }
                LODWORD(v45) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v43 = 0;
                unsigned int v44 = 0;
                uint64_t v45 = 0;
                do
                {
                  unint64_t v3 = v2 + 1;
                  a2[1] = v2 + 1;
                  char v46 = *(unsigned char *)(v6 + v2);
                  v45 |= (unint64_t)(v46 & 0x7F) << v43;
                  if ((v46 & 0x80) == 0) {
                    goto LABEL_149;
                  }
                  v43 += 7;
                  unint64_t v2 = v3;
                  BOOL v12 = v44++ > 8;
                }
                while (!v12);
                LODWORD(v45) = 0;
              }
LABEL_149:
              *(_DWORD *)(a1 + 56) = v45;
              int v75 = *(_DWORD *)(a1 + 8) | 0x80;
LABEL_150:
              *(_DWORD *)(a1 + 8) = v75;
              unint64_t v2 = v3;
LABEL_151:
              unint64_t v3 = a2[2];
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v2 >= v3 || v4 != 0) {
                return v4 == 0;
              }
              continue;
            case 9u:
              operator new();
            default:
              goto LABEL_151;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

uint64_t as::StreamFormat::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::write(a2, *(double *)(this + 24));
    int v4 = *(_DWORD *)(v3 + 8);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
LABEL_16:
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_18;
  }
LABEL_17:
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_19;
  }
LABEL_18:
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_20;
  }
LABEL_19:
  this = PB::Writer::writeVarInt(a2);
  int v4 = *(_DWORD *)(v3 + 8);
  if ((v4 & 0x40) == 0)
  {
LABEL_8:
    if ((v4 & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_20:
  this = PB::Writer::writeVarInt(a2);
  if ((*(_DWORD *)(v3 + 8) & 0x80) != 0) {
LABEL_9:
  }
    this = PB::Writer::writeVarInt(a2);
LABEL_10:
  uint64_t v5 = *(const PB::Base **)(v3 + 16);
  if (v5)
  {
    return PB::Writer::writeSubmessage(a2, v5);
  }
  return this;
}

uint64_t as::StreamFormat::formatText(as::StreamFormat *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "sampleRate", *((double *)this + 3));
    int v5 = *((_DWORD *)this + 2);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_17;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "formatID");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 4) == 0)
  {
LABEL_4:
    if ((v5 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_18;
  }
LABEL_17:
  PB::TextFormatter::format(a2, "formatFlags");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 8) == 0)
  {
LABEL_5:
    if ((v5 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_19;
  }
LABEL_18:
  PB::TextFormatter::format(a2, "bytesPerPacket");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x10) == 0)
  {
LABEL_6:
    if ((v5 & 0x20) == 0) {
      goto LABEL_7;
    }
    goto LABEL_20;
  }
LABEL_19:
  PB::TextFormatter::format(a2, "framesPerPacket");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    if ((v5 & 0x40) == 0) {
      goto LABEL_8;
    }
    goto LABEL_21;
  }
LABEL_20:
  PB::TextFormatter::format(a2, "bytesPerFrame");
  int v5 = *((_DWORD *)this + 2);
  if ((v5 & 0x40) == 0)
  {
LABEL_8:
    if ((v5 & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_21:
  PB::TextFormatter::format(a2, "channelsPerFrame");
  if ((*((_DWORD *)this + 2) & 0x80) != 0) {
LABEL_9:
  }
    PB::TextFormatter::format(a2, "bitsPerChannel");
LABEL_10:
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v6 + 32))(v6, a2, "layout");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::StreamFormat::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || memcmp((const void *)(a1 + 24), (const void *)(a2 + 24), 0x24uLL)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a2 + 16);
  BOOL result = (v5 | v6) == 0;
  if (v5 && v6)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    return as::ChannelLayout::operator==(v7, v6);
  }
  return result;
}

uint64_t as::StreamFormat::clearLayout(as::StreamFormat *this)
{
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t as::AvailableStreamFormat::default_instance(as::AvailableStreamFormat *this)
{
  {
    operator new();
  }
  return as::AvailableStreamFormat::default_instance(void)::gInstance;
}

void sub_210AE90A4(_Unwind_Exception *a1)
{
}

double as::AvailableStreamFormat::AvailableStreamFormat(as::AvailableStreamFormat *this)
{
  *(void *)this = &unk_26C3126C0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C3126C0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  return result;
}

as::AvailableStreamFormat *as::AvailableStreamFormat::AvailableStreamFormat(as::AvailableStreamFormat *this, const as::AvailableStreamFormat *a2)
{
  *(void *)this = &unk_26C3126C0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  as::AvailableStreamFormat::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3126C0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  as::AvailableStreamFormat::copy_from(this, a2);
  return this;
}

void *as::AvailableStreamFormat::copy_from(as::AvailableStreamFormat *this, const as::AvailableStreamFormat *a2)
{
  int v4 = (const as::StreamFormat *)*((void *)a2 + 4);
  if (v4)
  {
    uint64_t v5 = (as::StreamFormat *)as::AvailableStreamFormat::mutableFormat(this);
    as::StreamFormat::copy_from(v5, v4);
  }
  double result = std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 1);
  if (*((void *)a2 + 1) != *((void *)a2 + 2)) {
    operator new();
  }
  return result;
}

void sub_210AE92E0(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  __clang_call_terminate(a1);
}

as::AvailableStreamFormat *as::AvailableStreamFormat::operator=(as::AvailableStreamFormat *a1, const as::AvailableStreamFormat *a2)
{
  return a1;
}

uint64_t as::AvailableStreamFormat::format(as::AvailableStreamFormat *this)
{
  uint64_t result = *((void *)this + 4);
  if (!result) {
    return as::StreamFormat::default_instance(0);
  }
  return result;
}

uint64_t as::AvailableStreamFormat::mutableFormat(as::AvailableStreamFormat *this)
{
  if (!*((void *)this + 4)) {
    operator new();
  }
  return *((void *)this + 4);
}

__n128 as::SampleRateRange::SampleRateRange(__n128 *a1, __n128 *a2)
{
  a1->n128_u64[0] = (unint64_t)&unk_26C3125E0;
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[1];
  a1[1] = result;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&unk_26C3125E0;
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[1];
  a1[1] = result;
  return result;
}

{
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&unk_26C3125E0;
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[1];
  a1[1] = result;
  return result;
}

double as::AvailableStreamFormat::AvailableStreamFormat(uint64_t a1, void *a2)
{
  *(void *)a1 = &unk_26C3126C0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 32) = a2[4];
  a2[4] = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[1];
  a2[1] = v3;
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[2];
  a2[2] = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = a2[3];
  a2[3] = v5;
  return result;
}

{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(void *)a1 = &unk_26C3126C0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 32) = a2[4];
  a2[4] = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[1];
  a2[1] = v3;
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[2];
  a2[2] = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = a2[3];
  a2[3] = v5;
  return result;
}

void *as::AvailableStreamFormat::move_from(void *result, void *a2)
{
  uint64_t v2 = result[4];
  result[4] = a2[4];
  a2[4] = v2;
  uint64_t v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  uint64_t v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  uint64_t v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  return result;
}

void *as::AvailableStreamFormat::operator=(void *result, void *a2)
{
  uint64_t v2 = result[4];
  result[4] = a2[4];
  a2[4] = v2;
  uint64_t v3 = result[1];
  result[1] = a2[1];
  a2[1] = v3;
  uint64_t v4 = result[2];
  result[2] = a2[2];
  a2[2] = v4;
  uint64_t v5 = result[3];
  result[3] = a2[3];
  a2[3] = v5;
  return result;
}

void *as::AvailableStreamFormat::clear(as::AvailableStreamFormat *this)
{
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return std::vector<std::unique_ptr<as::client::PortPrefs>>::__clear[abi:ne180100]((void *)this + 1);
}

uint64_t as::AvailableStreamFormat::isInitialized(as::AvailableStreamFormat *this)
{
  uint64_t result = *((void *)this + 4);
  if (result)
  {
    uint64_t result = as::StreamFormat::isInitialized((as::StreamFormat *)result);
    if (result)
    {
      uint64_t v4 = *((void *)this + 1);
      uint64_t v3 = *((void *)this + 2);
      if (v4 == v3)
      {
        return 1;
      }
      else
      {
        uint64_t v5 = v4 + 8;
        do
        {
          uint64_t result = (*(_DWORD *)(*(void *)(v5 - 8) + 8) & 3) == 3;
          BOOL v6 = (*(_DWORD *)(*(void *)(v5 - 8) + 8) & 3) != 3 || v5 == v3;
          v5 += 8;
        }
        while (!v6);
      }
    }
  }
  return result;
}

BOOL as::SampleRateRange::isInitialized(as::SampleRateRange *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::AvailableStreamFormat::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v2 + 1;
        a2[1] = v2 + 1;
        char v11 = *(unsigned char *)(v6 + v2);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v2 = v10;
        if (v8++ > 8) {
          goto LABEL_19;
        }
      }
LABEL_20:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v9 >> 3) == 2) {
        operator new();
      }
      if ((v9 >> 3) == 1) {
        operator new();
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v15 = v2 + 1;
      char v16 = *(unsigned char *)(v6 + v2);
      a2[1] = v15;
      v9 |= (unint64_t)(v16 & 0x7F) << v13;
      if ((v16 & 0x80) == 0) {
        goto LABEL_20;
      }
      v13 += 7;
      unint64_t v2 = v15;
      if (v14++ >= 9)
      {
LABEL_19:
        unint64_t v9 = 0;
        goto LABEL_20;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210AE99C4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t as::AvailableStreamFormat::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(const PB::Base **)(this + 32);
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  uint64_t v6 = *(const PB::Base ***)(v3 + 8);
  uint64_t v5 = *(const PB::Base ***)(v3 + 16);
  while (v6 != v5)
  {
    char v7 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  return this;
}

uint64_t as::AvailableStreamFormat::formatText(as::AvailableStreamFormat *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 4);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "format");
  }
  uint64_t v6 = (uint64_t *)*((void *)this + 1);
  char v7 = (uint64_t *)*((void *)this + 2);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "sampleRateRange");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::AvailableStreamFormat::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a2 + 32);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 | v5) {
      return 0;
    }
  }
  else if (!as::StreamFormat::operator==(v4, v5))
  {
    return 0;
  }
  uint64_t v9 = a1 + 8;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(v9 + 8);
  unint64_t v10 = (v7 - v8) >> 3;
  uint64_t v12 = a2 + 8;
  uint64_t v11 = *(void *)(a2 + 8);
  if (v10 != (*(void *)(v12 + 8) - v11) >> 3) {
    return 0;
  }
  if (v7 == v8)
  {
    return 1;
  }
  else
  {
    BOOL v13 = 0;
    uint64_t v14 = 0;
    if (v10 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = (v7 - v8) >> 3;
    }
    do
    {
      uint64_t v16 = *(void *)(v8 + 8 * v14);
      uint64_t v17 = *(void *)(v11 + 8 * v14);
      if (v16) {
        BOOL v18 = v17 == 0;
      }
      else {
        BOOL v18 = 1;
      }
      if (v18)
      {
        if (v16 | v17) {
          return v13;
        }
      }
      else if (!as::SampleRateRange::operator==(v16, v17))
      {
        return v13;
      }
      BOOL v13 = ++v14 >= v10;
    }
    while (v15 != v14);
  }
  return v13;
}

uint64_t as::AvailableStreamFormat::clearFormat(as::AvailableStreamFormat *this)
{
  uint64_t result = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::AvailableStreamFormat::addSampleRateRange(as::AvailableStreamFormat *this)
{
  unint64_t v4 = *((void *)this + 3);
  unint64_t v2 = (char *)this + 24;
  unint64_t v3 = v4;
  uint64_t v5 = (void *)*((void *)v2 - 1);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (uint64_t *)(v2 - 16);
    uint64_t v8 = *((void *)v2 - 2);
    uint64_t v9 = ((uint64_t)v5 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v3 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    v15[4] = v2;
    if (v12) {
      BOOL v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<NSString * {__strong}>>((uint64_t)v2, v12);
    }
    else {
      BOOL v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    v15[0] = v13;
    v15[1] = v14;
    uint64_t v15[3] = &v13[8 * v12];
    *(void *)uint64_t v14 = 0;
    void v15[2] = v14 + 8;
    std::vector<std::unique_ptr<as::SampleRateRange>>::__swap_out_circular_buffer(v7, v15);
    BOOL v6 = (void *)*((void *)this + 2);
    std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer(v15);
  }
  else
  {
    *uint64_t v5 = 0;
    BOOL v6 = v5 + 1;
    *((void *)this + 2) = v6;
  }
  *((void *)this + 2) = v6;
  operator new();
}

void sub_210AE9DA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<as::client::PortPrefs>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t as::SampleRateRange::default_instance(as::SampleRateRange *this)
{
  {
    operator new();
  }
  return as::SampleRateRange::default_instance(void)::gInstance;
}

void sub_210AE9E48(_Unwind_Exception *a1)
{
}

uint64_t as::SampleRateRange::SampleRateRange(uint64_t this)
{
  *(void *)this = &unk_26C3125E0;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  return this;
}

{
  *(void *)this = &unk_26C3125E0;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  return this;
}

__n128 as::SampleRateRange::SampleRateRange(__n128 *this, __n128 *a2)
{
  this->n128_u64[0] = (unint64_t)&unk_26C3125E0;
  this->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[1];
  this[1] = result;
  return result;
}

__n128 as::SampleRateRange::copy_from(__n128 *this, __n128 *a2)
{
  this->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[1];
  this[1] = result;
  return result;
}

__n128 as::SampleRateRange::operator=(__n128 *a1, __n128 *a2)
{
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[1];
  a1[1] = result;
  return result;
}

{
  __n128 result;

  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[1];
  a1[1] = result;
  return result;
}

__n128 as::SampleRateRange::move_from(__n128 *a1, __n128 *a2)
{
  a1->n128_u32[2] = a2->n128_u32[2];
  __n128 result = a2[1];
  a1[1] = result;
  return result;
}

uint64_t as::SampleRateRange::clear(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  return this;
}

BOOL as::SampleRateRange::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 >= v2 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v6 = *a2;
    if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
      break;
    }
    char v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v10 = v3 + 1;
      a2[1] = v3 + 1;
      char v11 = *(unsigned char *)(v6 + v3);
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0) {
        break;
      }
      v7 += 7;
      unint64_t v3 = v10;
      if (v8++ > 8)
      {
        unint64_t v9 = 0;
        break;
      }
    }
    unint64_t v3 = v10;
LABEL_23:
    if ((v9 & 7) == 4)
    {
      int v4 = 0;
      return v4 == 0;
    }
    unint64_t v19 = v9 >> 3;
    if (v19 == 2)
    {
      if (v3 > 0xFFFFFFFFFFFFFFF7 || v3 + 8 > v2) {
        goto LABEL_33;
      }
      *(void *)(a1 + 24) = *(void *)(v6 + v3);
    }
    else
    {
      if (v19 != 1) {
        goto LABEL_35;
      }
      if (v3 > 0xFFFFFFFFFFFFFFF7 || v3 + 8 > v2)
      {
LABEL_33:
        *((unsigned char *)a2 + 24) = 1;
        goto LABEL_34;
      }
      *(void *)(a1 + 16) = *(void *)(v6 + v3);
    }
    unint64_t v3 = a2[1] + 8;
    a2[1] = v3;
LABEL_34:
    *(_DWORD *)(a1 + 8) |= v19;
LABEL_35:
    unint64_t v2 = a2[2];
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
      return v4 == 0;
    }
  }
  char v13 = 0;
  unsigned int v14 = 0;
  unint64_t v9 = 0;
  if (v3 <= v2) {
    unint64_t v15 = v2;
  }
  else {
    unint64_t v15 = v3;
  }
  while (v15 != v3)
  {
    unint64_t v16 = v3++;
    char v17 = *(unsigned char *)(v6 + v16);
    a2[1] = v3;
    v9 |= (unint64_t)(v17 & 0x7F) << v13;
    if ((v17 & 0x80) == 0) {
      goto LABEL_22;
    }
    v13 += 7;
    if (v14++ >= 9)
    {
      unint64_t v9 = 0;
LABEL_22:
      unint64_t v3 = v16 + 1;
      goto LABEL_23;
    }
  }
  int v4 = 1;
  *((unsigned char *)a2 + 24) = 1;
  return v4 == 0;
}

uint64_t as::SampleRateRange::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 8);
  if (v4)
  {
    this = PB::Writer::write(a2, *(double *)(this + 16));
    int v4 = *(_DWORD *)(v3 + 8);
  }
  if ((v4 & 2) != 0)
  {
    double v5 = *(double *)(v3 + 24);
    return PB::Writer::write(a2, v5);
  }
  return this;
}

uint64_t as::SampleRateRange::formatText(as::SampleRateRange *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "minimum", *((double *)this + 2));
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "maximum", *((double *)this + 3));
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::SampleRateRange::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  return *(void *)(a1 + 16) == *(void *)(a2 + 16) && *(void *)(a1 + 24) == *(void *)(a2 + 24);
}

uint64_t as::ActivationContext::default_instance(as::ActivationContext *this)
{
  {
    operator new();
  }
  return as::ActivationContext::default_instance(void)::gInstance;
}

void sub_210AEA2D4(_Unwind_Exception *a1)
{
}

uint64_t as::ActivationContext::ActivationContext(uint64_t this)
{
  *(void *)this = &unk_26C312618;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 16) = 0;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

{
  *(void *)this = &unk_26C312618;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 16) = 0;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

as::ActivationContext *as::ActivationContext::ActivationContext(as::ActivationContext *this, const as::ActivationContext *a2)
{
  *(void *)this = &unk_26C312618;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::ActivationContext::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312618;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::ActivationContext::copy_from(this, a2);
  return this;
}

uint64_t as::ActivationContext::copy_from(as::ActivationContext *this, const as::ActivationContext *a2)
{
  uint64_t result = caulk::xstring::assign((as::ActivationContext *)((char *)this + 16), (const as::ActivationContext *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  uint64_t v5 = *((void *)a2 + 4);
  *((_DWORD *)this + 10) = *((_DWORD *)a2 + 10);
  *((void *)this + 4) = v5;
  return result;
}

as::ActivationContext *as::ActivationContext::operator=(as::ActivationContext *a1, const as::ActivationContext *a2)
{
  return a1;
}

void *as::ActivationContext::ActivationContext(void *a1, uint64_t a2)
{
  *a1 = &unk_26C312618;
  a1[2] = 0;
  a1[3] = 0;
  as::ActivationContext::move_from((uint64_t)a1, a2);
  return a1;
}

{
  *a1 = &unk_26C312618;
  a1[2] = 0;
  a1[3] = 0;
  as::ActivationContext::move_from((uint64_t)a1, a2);
  return a1;
}

uint64_t as::ActivationContext::move_from(uint64_t a1, uint64_t a2)
{
  v6[0] = 0;
  v6[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)v6);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 32);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(void *)(a1 + 32) = v5;
  return result;
}

uint64_t as::ActivationContext::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::ActivationContext::clear(as::ActivationContext *this)
{
  uint64_t result = caulk::xstring::clear((as::ActivationContext *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  return result;
}

uint64_t as::ActivationContext::isInitialized(as::ActivationContext *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::ActivationContext::readFrom(_DWORD *a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (2)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
      {
        char v15 = 0;
        unsigned int v16 = 0;
        unint64_t v11 = 0;
        if (v3 <= v2) {
          unint64_t v17 = v2;
        }
        else {
          unint64_t v17 = v3;
        }
        while (v17 != v3)
        {
          unint64_t v18 = v3++;
          char v19 = *(unsigned char *)(v8 + v18);
          a2[1] = v3;
          v11 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0) {
            goto LABEL_22;
          }
          v15 += 7;
          BOOL v20 = v16++ >= 9;
          if (v20)
          {
            unint64_t v11 = 0;
LABEL_22:
            unint64_t v3 = v18 + 1;
            goto LABEL_23;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
      }
      else
      {
        char v9 = 0;
        unsigned int v10 = 0;
        unint64_t v11 = 0;
        while (1)
        {
          unint64_t v12 = v3 + 1;
          a2[1] = v3 + 1;
          char v13 = *(unsigned char *)(v8 + v3);
          v11 |= (unint64_t)(v13 & 0x7F) << v9;
          if ((v13 & 0x80) == 0) {
            break;
          }
          v9 += 7;
          unint64_t v3 = v12;
          BOOL v14 = v10++ > 8;
          if (v14)
          {
            unint64_t v11 = 0;
            break;
          }
        }
        unint64_t v3 = v12;
LABEL_23:
        if ((v11 & 7) != 4)
        {
          switch((v11 >> 3))
          {
            case 1u:
              if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
              {
                char v34 = 0;
                unsigned int v35 = 0;
                uint64_t v23 = 0;
                if (v2 <= v3) {
                  unint64_t v24 = v3;
                }
                else {
                  unint64_t v24 = v2;
                }
                do
                {
                  if (v24 == v3)
                  {
                    LODWORD(v23) = 0;
                    *((unsigned char *)a2 + 24) = 1;
                    goto LABEL_75;
                  }
                  unint64_t v36 = v3++;
                  char v37 = *(unsigned char *)(v8 + v36);
                  a2[1] = v3;
                  v23 |= (unint64_t)(v37 & 0x7F) << v34;
                  if ((v37 & 0x80) == 0) {
                    goto LABEL_55;
                  }
                  v34 += 7;
                  BOOL v20 = v35++ >= 9;
                }
                while (!v20);
                LODWORD(v23) = 0;
LABEL_55:
                unint64_t v24 = v36 + 1;
              }
              else
              {
                char v21 = 0;
                unsigned int v22 = 0;
                uint64_t v23 = 0;
                do
                {
                  unint64_t v24 = v3 + 1;
                  a2[1] = v3 + 1;
                  char v25 = *(unsigned char *)(v8 + v3);
                  v23 |= (unint64_t)(v25 & 0x7F) << v21;
                  if ((v25 & 0x80) == 0) {
                    goto LABEL_75;
                  }
                  v21 += 7;
                  unint64_t v3 = v24;
                  BOOL v14 = v22++ > 8;
                }
                while (!v14);
                LODWORD(v23) = 0;
              }
LABEL_75:
              a1[8] = v23;
              int v46 = a1[2] | 1;
              goto LABEL_80;
            case 2u:
              PB::Reader::read();
              caulk::xstring::assign();
              a1[2] |= 2u;
              unint64_t v3 = a2[1];
              unint64_t v2 = a2[2];
              goto LABEL_81;
            case 3u:
              if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
              {
                char v38 = 0;
                unsigned int v39 = 0;
                uint64_t v28 = 0;
                if (v2 <= v3) {
                  unint64_t v24 = v3;
                }
                else {
                  unint64_t v24 = v2;
                }
                while (v24 != v3)
                {
                  unint64_t v40 = v3++;
                  char v41 = *(unsigned char *)(v8 + v40);
                  a2[1] = v3;
                  v28 |= (unint64_t)(v41 & 0x7F) << v38;
                  if ((v41 & 0x80) == 0) {
                    goto LABEL_64;
                  }
                  v38 += 7;
                  BOOL v20 = v39++ >= 9;
                  if (v20)
                  {
                    LODWORD(v28) = 0;
LABEL_64:
                    unint64_t v24 = v40 + 1;
                    goto LABEL_77;
                  }
                }
                LODWORD(v28) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v26 = 0;
                unsigned int v27 = 0;
                uint64_t v28 = 0;
                do
                {
                  unint64_t v24 = v3 + 1;
                  a2[1] = v3 + 1;
                  char v29 = *(unsigned char *)(v8 + v3);
                  v28 |= (unint64_t)(v29 & 0x7F) << v26;
                  if ((v29 & 0x80) == 0) {
                    goto LABEL_77;
                  }
                  v26 += 7;
                  unint64_t v3 = v24;
                  BOOL v14 = v27++ > 8;
                }
                while (!v14);
                LODWORD(v28) = 0;
              }
LABEL_77:
              a1[9] = v28;
              int v46 = a1[2] | 8;
              goto LABEL_80;
            case 4u:
              if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
              {
                char v42 = 0;
                unsigned int v43 = 0;
                uint64_t v32 = 0;
                if (v2 <= v3) {
                  unint64_t v24 = v3;
                }
                else {
                  unint64_t v24 = v2;
                }
                while (v24 != v3)
                {
                  unint64_t v44 = v3++;
                  char v45 = *(unsigned char *)(v8 + v44);
                  a2[1] = v3;
                  v32 |= (unint64_t)(v45 & 0x7F) << v42;
                  if ((v45 & 0x80) == 0) {
                    goto LABEL_73;
                  }
                  v42 += 7;
                  BOOL v20 = v43++ >= 9;
                  if (v20)
                  {
                    LODWORD(v32) = 0;
LABEL_73:
                    unint64_t v24 = v44 + 1;
                    goto LABEL_79;
                  }
                }
                LODWORD(v32) = 0;
                *((unsigned char *)a2 + 24) = 1;
              }
              else
              {
                char v30 = 0;
                unsigned int v31 = 0;
                uint64_t v32 = 0;
                do
                {
                  unint64_t v24 = v3 + 1;
                  a2[1] = v3 + 1;
                  char v33 = *(unsigned char *)(v8 + v3);
                  v32 |= (unint64_t)(v33 & 0x7F) << v30;
                  if ((v33 & 0x80) == 0) {
                    goto LABEL_79;
                  }
                  v30 += 7;
                  unint64_t v3 = v24;
                  BOOL v14 = v31++ > 8;
                }
                while (!v14);
                LODWORD(v32) = 0;
              }
LABEL_79:
              a1[10] = v32;
              int v46 = a1[2] | 4;
LABEL_80:
              a1[2] = v46;
              unint64_t v3 = v24;
LABEL_81:
              int v4 = *((unsigned __int8 *)a2 + 24);
              if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
                return v4 == 0;
              }
              continue;
            default:
              goto LABEL_81;
          }
        }
        int v4 = 0;
      }
      break;
    }
  }
  return v4 == 0;
}

void sub_210AEAA0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::ActivationContext::writeTo(as::ActivationContext *this, PB::Writer *a2)
{
  int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v5 = (char *)caulk::xstring::c_str((as::ActivationContext *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v5);
    PB::Writer::write();
    if (v7 < 0) {
      operator delete(__p);
    }
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 4) != 0)
  {
    PB::Writer::writeVarInt(a2);
    int v4 = *((_DWORD *)this + 2);
  }
  if ((v4 & 8) != 0) {
    PB::Writer::writeVarInt(a2);
  }
}

void sub_210AEAAE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::ActivationContext::formatText(as::ActivationContext *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "trigger");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::ActivationContext *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v9 < 0) {
      operator delete(__p);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 4) != 0)
  {
    PB::TextFormatter::format(a2, "accessibilityPreference");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 8) != 0) {
    PB::TextFormatter::format(a2, "callDirection");
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AEABD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::ActivationContext::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
    && (*(void *)(a1 + 32) == *(void *)(a2 + 32)
      ? (BOOL v2 = *(unsigned int *)(a1 + 40) == (unint64_t)*(unsigned int *)(a2 + 40))
      : (BOOL v2 = 0),
        v2))
  {
    return caulk::xstring::compare((caulk::xstring *)(a1 + 16), (const caulk::xstring *)(a2 + 16)) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t as::AggregateDevice::default_instance(as::AggregateDevice *this)
{
  {
    operator new();
  }
  return as::AggregateDevice::default_instance(void)::gInstance;
}

void sub_210AEACF4(_Unwind_Exception *a1)
{
}

double as::AggregateDevice::AggregateDevice(as::AggregateDevice *this)
{
  *(void *)this = &unk_26C312570;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  return result;
}

{
  double result;

  *(void *)this = &unk_26C312570;
  *((_DWORD *)this + 2) = 0;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  return result;
}

as::AggregateDevice *as::AggregateDevice::AggregateDevice(as::AggregateDevice *this, caulk::xstring **a2)
{
  *(void *)this = &unk_26C312570;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  as::AggregateDevice::copy_from((caulk::xstring **)this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312570;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 12) = 0;
  as::AggregateDevice::copy_from((caulk::xstring **)this, a2);
  return this;
}

uint64_t as::AggregateDevice::copy_from(caulk::xstring **this, caulk::xstring **a2)
{
  caulk::xstring::assign((caulk::xstring *)(this + 5), (const caulk::xstring *)(a2 + 5));
  caulk::xstring::assign((caulk::xstring *)(this + 7), (const caulk::xstring *)(a2 + 7));
  if (this != a2) {
    std::vector<caulk::xstring>::__assign_with_size[abi:ne180100]<caulk::xstring*,caulk::xstring*>((uint64_t)(this + 2), a2[2], a2[3], (a2[3] - a2[2]) >> 4);
  }
  caulk::xstring::assign((caulk::xstring *)(this + 9), (const caulk::xstring *)(a2 + 9));
  uint64_t result = caulk::xstring::assign((caulk::xstring *)(this + 11), (const caulk::xstring *)(a2 + 11));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  return result;
}

caulk::xstring **as::AggregateDevice::operator=(caulk::xstring **a1, caulk::xstring **a2)
{
  return a1;
}

uint64_t as::AggregateDevice::AggregateDevice(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C312570;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0;
  as::AggregateDevice::move_from(a1, a2);
  return a1;
}

{
  *(void *)a1 = &unk_26C312570;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0;
  as::AggregateDevice::move_from(a1, a2);
  return a1;
}

uint64_t as::AggregateDevice::move_from(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v8);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v8);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v4;
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v6;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::clear((caulk::xstring *)&v8);
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)&v8);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t as::AggregateDevice::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::AggregateDevice::clear(caulk::xstring **this)
{
  caulk::xstring::clear((caulk::xstring *)(this + 5));
  caulk::xstring::clear((caulk::xstring *)(this + 7));
  std::vector<caulk::xstring>::__base_destruct_at_end[abi:ne180100]((uint64_t)(this + 2), this[2]);
  caulk::xstring::clear((caulk::xstring *)(this + 9));
  uint64_t result = caulk::xstring::clear((caulk::xstring *)(this + 11));
  *((_DWORD *)this + 2) = 0;
  return result;
}

BOOL as::AggregateDevice::isInitialized(as::AggregateDevice *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::AggregateDevice::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v3 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    uint64_t v8 = (uint64_t *)(a1 + 16);
    uint64_t v9 = a1 + 32;
    while (1)
    {
      uint64_t v10 = *a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v11 = 0;
      unsigned int v12 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        unint64_t v14 = v2 + 1;
        a2[1] = v2 + 1;
        char v15 = *(unsigned char *)(v10 + v2);
        v13 |= (unint64_t)(v15 & 0x7F) << v11;
        if ((v15 & 0x80) == 0) {
          break;
        }
        v11 += 7;
        unint64_t v2 = v14;
        if (v12++ > 8) {
          goto LABEL_20;
        }
      }
LABEL_21:
      if ((v13 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      switch((v13 >> 3))
      {
        case 1u:
          std::string __p = 0;
          char v34 = 0;
          unsigned int v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          int v22 = *(_DWORD *)(a1 + 8) | 1;
          goto LABEL_29;
        case 2u:
          std::string __p = 0;
          char v34 = 0;
          unsigned int v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          int v22 = *(_DWORD *)(a1 + 8) | 2;
          goto LABEL_29;
        case 3u:
          unint64_t v24 = *(void **)(a1 + 24);
          unint64_t v23 = *(void *)(a1 + 32);
          if ((unint64_t)v24 >= v23)
          {
            uint64_t v26 = ((uint64_t)v24 - *v8) >> 4;
            unint64_t v27 = v26 + 1;
            if ((unint64_t)(v26 + 1) >> 60) {
              std::vector<NSString * {__strong}>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v28 = v23 - *v8;
            if (v28 >> 3 > v27) {
              unint64_t v27 = v28 >> 3;
            }
            if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v29 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v29 = v27;
            }
            uint64_t v37 = v9;
            if (v29) {
              char v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<caulk::xstring>>(v9, v29);
            }
            else {
              char v30 = 0;
            }
            unsigned int v31 = &v30[16 * v26];
            std::string __p = v30;
            char v34 = v31;
            unint64_t v36 = &v30[16 * v29];
            *(void *)unsigned int v31 = 0;
            *((void *)v31 + 1) = 0;
            unsigned int v35 = v31 + 16;
            std::vector<caulk::xstring>::__swap_out_circular_buffer(v8, &__p);
            char v25 = *(void **)(a1 + 24);
            std::__split_buffer<caulk::xstring>::~__split_buffer((uint64_t)&__p);
          }
          else
          {
            *unint64_t v24 = 0;
            v24[1] = 0;
            char v25 = v24 + 2;
            *(void *)(a1 + 24) = v24 + 2;
          }
          *(void *)(a1 + 24) = v25;
          std::string __p = 0;
          char v34 = 0;
          unsigned int v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          goto LABEL_30;
        case 4u:
          std::string __p = 0;
          char v34 = 0;
          unsigned int v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          int v22 = *(_DWORD *)(a1 + 8) | 4;
          goto LABEL_29;
        case 5u:
          std::string __p = 0;
          char v34 = 0;
          unsigned int v35 = 0;
          PB::Reader::read();
          caulk::xstring::assign();
          int v22 = *(_DWORD *)(a1 + 8) | 8;
LABEL_29:
          *(_DWORD *)(a1 + 8) = v22;
LABEL_30:
          if (SHIBYTE(v35) < 0) {
            operator delete(__p);
          }
          break;
        default:
          break;
      }
      unint64_t v2 = a2[1];
      unint64_t v3 = a2[2];
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v17 = 0;
    unsigned int v18 = 0;
    unint64_t v13 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v19 = v2 + 1;
      char v20 = *(unsigned char *)(v10 + v2);
      a2[1] = v19;
      v13 |= (unint64_t)(v20 & 0x7F) << v17;
      if ((v20 & 0x80) == 0) {
        goto LABEL_21;
      }
      v17 += 7;
      unint64_t v2 = v19;
      if (v18++ >= 9)
      {
LABEL_20:
        unint64_t v13 = 0;
        goto LABEL_21;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210AEB4C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void as::AggregateDevice::writeTo(as::AggregateDevice *this, PB::Writer *a2)
{
  int v3 = *((_DWORD *)this + 2);
  if (v3)
  {
    int v4 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(__p, v4);
    PB::Writer::write();
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    int v3 = *((_DWORD *)this + 2);
  }
  if ((v3 & 2) != 0)
  {
    uint64_t v5 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 56));
    std::string::basic_string[abi:ne180100]<0>(__p, v5);
    PB::Writer::write();
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v6 = (caulk::xstring *)*((void *)this + 2);
  char v7 = (caulk::xstring *)*((void *)this + 3);
  while (v6 != v7)
  {
    uint64_t v8 = (char *)caulk::xstring::c_str(v6);
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    PB::Writer::write();
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v6 = (caulk::xstring *)((char *)v6 + 16);
  }
  int v9 = *((_DWORD *)this + 2);
  if ((v9 & 4) != 0)
  {
    uint64_t v10 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 72));
    std::string::basic_string[abi:ne180100]<0>(__p, v10);
    PB::Writer::write();
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    int v9 = *((_DWORD *)this + 2);
  }
  if ((v9 & 8) != 0)
  {
    char v11 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(__p, v11);
    PB::Writer::write();
    if (v13 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_210AEB67C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::AggregateDevice::formatText(as::AggregateDevice *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    uint64_t v6 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 40));
    std::string::basic_string[abi:ne180100]<0>(__p, v6);
    PB::TextFormatter::format();
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    char v7 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 56));
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    PB::TextFormatter::format();
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v8 = (caulk::xstring *)*((void *)this + 2);
  for (i = (caulk::xstring *)*((void *)this + 3); v8 != i; uint64_t v8 = (caulk::xstring *)((char *)v8 + 16))
  {
    uint64_t v10 = (char *)caulk::xstring::c_str(v8);
    std::string::basic_string[abi:ne180100]<0>(__p, v10);
    PB::TextFormatter::format();
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  int v11 = *((_DWORD *)this + 2);
  if ((v11 & 4) != 0)
  {
    unsigned int v12 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 72));
    std::string::basic_string[abi:ne180100]<0>(__p, v12);
    PB::TextFormatter::format();
    if (v16 < 0) {
      operator delete(__p[0]);
    }
    int v11 = *((_DWORD *)this + 2);
  }
  if ((v11 & 8) != 0)
  {
    char v13 = (char *)caulk::xstring::c_str((as::AggregateDevice *)((char *)this + 88));
    std::string::basic_string[abi:ne180100]<0>(__p, v13);
    PB::TextFormatter::format();
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AEB84C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::AggregateDevice::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 40), (const caulk::xstring *)(a2 + 40))) {
    return 0;
  }
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 56), (const caulk::xstring *)(a2 + 56))) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t v6 = (v4 - v5) >> 4;
  if (v6 != (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 4) {
    return 0;
  }
  if (v4 != v5)
  {
    uint64_t v7 = 0;
    if (v6 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = (v4 - v5) >> 4;
    }
    while (!caulk::xstring::compare((caulk::xstring *)(*(void *)(a1 + 16) + v7), (const caulk::xstring *)(*(void *)(a2 + 16) + v7)))
    {
      v7 += 16;
      if (!--v8) {
        goto LABEL_11;
      }
    }
    return 0;
  }
LABEL_11:
  if (caulk::xstring::compare((caulk::xstring *)(a1 + 72), (const caulk::xstring *)(a2 + 72))) {
    return 0;
  }
  return caulk::xstring::compare((caulk::xstring *)(a1 + 88), (const caulk::xstring *)(a2 + 88)) == 0;
}

uint64_t as::RouteIdentifierCore::default_instance(as::RouteIdentifierCore *this)
{
  {
    operator new();
  }
  return as::RouteIdentifierCore::default_instance(void)::gInstance;
}

void sub_210AEB9EC(_Unwind_Exception *a1)
{
}

uint64_t as::RouteIdentifierCore::RouteIdentifierCore(uint64_t this)
{
  *(void *)this = &unk_26C312688;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

{
  *(void *)this = &unk_26C312688;
  *(_DWORD *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

as::RouteIdentifierCore *as::RouteIdentifierCore::RouteIdentifierCore(as::RouteIdentifierCore *this, const as::RouteIdentifierCore *a2)
{
  *(void *)this = &unk_26C312688;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::RouteIdentifierCore::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C312688;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  as::RouteIdentifierCore::copy_from(this, a2);
  return this;
}

uint64_t as::RouteIdentifierCore::copy_from(as::RouteIdentifierCore *this, const as::RouteIdentifierCore *a2)
{
  uint64_t result = caulk::xstring::assign((as::RouteIdentifierCore *)((char *)this + 16), (const as::RouteIdentifierCore *)((char *)a2 + 16));
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  return result;
}

as::RouteIdentifierCore *as::RouteIdentifierCore::operator=(as::RouteIdentifierCore *a1, const as::RouteIdentifierCore *a2)
{
  return a1;
}

void *as::RouteIdentifierCore::RouteIdentifierCore(void *a1, uint64_t a2)
{
  *a1 = &unk_26C312688;
  a1[2] = 0;
  a1[3] = 0;
  as::RouteIdentifierCore::move_from((uint64_t)a1, a2);
  return a1;
}

{
  *a1 = &unk_26C312688;
  a1[2] = 0;
  a1[3] = 0;
  as::RouteIdentifierCore::move_from((uint64_t)a1, a2);
  return a1;
}

uint64_t as::RouteIdentifierCore::move_from(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = 0;
  caulk::xstring::move();
  caulk::xstring::move();
  caulk::xstring::move();
  uint64_t result = caulk::xstring::clear((caulk::xstring *)v5);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  return result;
}

uint64_t as::RouteIdentifierCore::operator=(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t as::RouteIdentifierCore::clear(as::RouteIdentifierCore *this)
{
  uint64_t result = caulk::xstring::clear((as::RouteIdentifierCore *)((char *)this + 16));
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 8) = 0;
  return result;
}

BOOL as::RouteIdentifierCore::isInitialized(as::RouteIdentifierCore *this)
{
  return (~*((_DWORD *)this + 2) & 3) == 0;
}

BOOL as::RouteIdentifierCore::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v3 + 1;
        a2[1] = v3 + 1;
        char v13 = *(unsigned char *)(v8 + v3);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v3 = v12;
        BOOL v14 = v10++ > 8;
        if (v14)
        {
          unint64_t v11 = 0;
          break;
        }
      }
      unint64_t v3 = v12;
LABEL_23:
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v21 = v11 >> 3;
      if (v21 == 2)
      {
        PB::Reader::read();
        caulk::xstring::assign();
        *(_DWORD *)(a1 + 8) |= 2u;
        unint64_t v3 = a2[1];
        unint64_t v2 = a2[2];
      }
      else if (v21 == 1)
      {
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v24 = 0;
          if (v2 <= v3) {
            unint64_t v25 = v3;
          }
          else {
            unint64_t v25 = v2;
          }
          while (v25 != v3)
          {
            unint64_t v29 = v3++;
            char v30 = *(unsigned char *)(v8 + v29);
            a2[1] = v3;
            v24 |= (unint64_t)(v30 & 0x7F) << v27;
            if ((v30 & 0x80) == 0) {
              goto LABEL_42;
            }
            v27 += 7;
            BOOL v20 = v28++ >= 9;
            if (v20)
            {
              LODWORD(v24) = 0;
LABEL_42:
              unint64_t v25 = v29 + 1;
              goto LABEL_44;
            }
          }
          LODWORD(v24) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v22 = 0;
          unsigned int v23 = 0;
          uint64_t v24 = 0;
          while (1)
          {
            unint64_t v25 = v3 + 1;
            a2[1] = v3 + 1;
            char v26 = *(unsigned char *)(v8 + v3);
            v24 |= (unint64_t)(v26 & 0x7F) << v22;
            if ((v26 & 0x80) == 0) {
              break;
            }
            v22 += 7;
            unint64_t v3 = v25;
            BOOL v14 = v23++ > 8;
            if (v14)
            {
              LODWORD(v24) = 0;
              break;
            }
          }
        }
LABEL_44:
        *(_DWORD *)(a1 + 32) = v24;
        *(_DWORD *)(a1 + 8) |= 1u;
        unint64_t v3 = v25;
      }
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v3 <= v2) {
      unint64_t v17 = v2;
    }
    else {
      unint64_t v17 = v3;
    }
    while (v17 != v3)
    {
      unint64_t v18 = v3++;
      char v19 = *(unsigned char *)(v8 + v18);
      a2[1] = v3;
      v11 |= (unint64_t)(v19 & 0x7F) << v15;
      if ((v19 & 0x80) == 0) {
        goto LABEL_22;
      }
      v15 += 7;
      BOOL v20 = v16++ >= 9;
      if (v20)
      {
        unint64_t v11 = 0;
LABEL_22:
        unint64_t v3 = v18 + 1;
        goto LABEL_23;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

void sub_210AEBF54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::RouteIdentifierCore::writeTo(as::RouteIdentifierCore *this, PB::Writer *a2)
{
  int v3 = *((_DWORD *)this + 2);
  if (v3)
  {
    PB::Writer::writeVarInt(a2);
    int v3 = *((_DWORD *)this + 2);
  }
  if ((v3 & 2) != 0)
  {
    int v4 = (char *)caulk::xstring::c_str((as::RouteIdentifierCore *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v4);
    PB::Writer::write();
    if (v6 < 0) {
      operator delete(__p);
    }
  }
}

void sub_210AEBFF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t as::RouteIdentifierCore::formatText(as::RouteIdentifierCore *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    PB::TextFormatter::format(a2, "topologySource");
    int v5 = *((_DWORD *)this + 2);
  }
  if ((v5 & 2) != 0)
  {
    char v6 = (char *)caulk::xstring::c_str((as::RouteIdentifierCore *)((char *)this + 16));
    std::string::basic_string[abi:ne180100]<0>(&__p, v6);
    PB::TextFormatter::format();
    if (v9 < 0) {
      operator delete(__p);
    }
  }
  return PB::TextFormatter::endObject(a2);
}

void sub_210AEC0A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL as::RouteIdentifierCore::operator==(_DWORD *a1, _DWORD *a2)
{
  return a1[2] == a2[2]
      && a1[8] == a2[8]
      && caulk::xstring::compare((caulk::xstring *)(a1 + 4), (const caulk::xstring *)(a2 + 4)) == 0;
}

uint64_t as::RouteIdentifier::default_instance(as::RouteIdentifier *this)
{
  {
    operator new();
  }
  return as::RouteIdentifier::default_instance(void)::gInstance;
}

void sub_210AEC1AC(_Unwind_Exception *a1)
{
}

uint64_t as::RouteIdentifier::RouteIdentifier(uint64_t this)
{
  *(void *)this = &unk_26C3125A8;
  *(void *)(this + 16) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

{
  *(void *)this = &unk_26C3125A8;
  *(void *)(this + 16) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

as::RouteIdentifier *as::RouteIdentifier::RouteIdentifier(as::RouteIdentifier *this, const as::RouteIdentifier *a2)
{
  *(void *)this = &unk_26C3125A8;
  *((void *)this + 2) = 0;
  as::RouteIdentifier::copy_from(this, a2);
  return this;
}

{
  *(void *)this = &unk_26C3125A8;
  *((void *)this + 2) = 0;
  as::RouteIdentifier::copy_from(this, a2);
  return this;
}

as::RouteIdentifier *as::RouteIdentifier::copy_from(as::RouteIdentifier *this, const as::RouteIdentifier *a2)
{
  int v3 = this;
  int v4 = (const as::RouteIdentifierCore *)*((void *)a2 + 2);
  if (v4)
  {
    int v5 = (as::RouteIdentifierCore *)as::RouteIdentifier::mutableCoreIdentifier(this);
    this = (as::RouteIdentifier *)as::RouteIdentifierCore::copy_from(v5, v4);
  }
  *((_DWORD *)v3 + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)v3 + 6) = *((_DWORD *)a2 + 6);
  return this;
}

as::RouteIdentifier *as::RouteIdentifier::operator=(as::RouteIdentifier *a1, const as::RouteIdentifier *a2)
{
  return a1;
}

uint64_t as::RouteIdentifier::coreIdentifier(as::RouteIdentifier *this)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return as::RouteIdentifierCore::default_instance(0);
  }
  return result;
}

uint64_t as::RouteIdentifier::mutableCoreIdentifier(as::RouteIdentifier *this)
{
  if (!*((void *)this + 2)) {
    operator new();
  }
  return *((void *)this + 2);
}

uint64_t as::RouteIdentifier::RouteIdentifier(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = &unk_26C3125A8;
  *(void *)(result + 16) = 0;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

{
  *(void *)uint64_t result = &unk_26C3125A8;
  *(void *)(result + 16) = 0;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t as::RouteIdentifier::move_from(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t as::RouteIdentifier::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v2;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

uint64_t as::RouteIdentifier::clear(as::RouteIdentifier *this)
{
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  return result;
}

uint64_t as::RouteIdentifier::isInitialized(as::RouteIdentifier *this)
{
  return *((_DWORD *)this + 2) & 1;
}

BOOL as::RouteIdentifier::readFrom(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2[1];
  unint64_t v2 = a2[2];
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v3 < v2 && v4 == 0)
  {
    while (1)
    {
      uint64_t v6 = *a2;
      if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2) {
        break;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = v3 + 1;
        a2[1] = v3 + 1;
        char v11 = *(unsigned char *)(v6 + v3);
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          break;
        }
        v7 += 7;
        unint64_t v3 = v10;
        BOOL v12 = v8++ > 8;
        if (v12)
        {
          unint64_t v9 = 0;
          break;
        }
      }
      unint64_t v3 = v10;
LABEL_23:
      if ((v9 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v9 >> 3;
      if (v19 == 2) {
        operator new();
      }
      if (v19 == 1)
      {
        if (v3 > 0xFFFFFFFFFFFFFFF5 || v3 + 10 > v2)
        {
          char v25 = 0;
          unsigned int v26 = 0;
          uint64_t v22 = 0;
          if (v2 <= v3) {
            unint64_t v23 = v3;
          }
          else {
            unint64_t v23 = v2;
          }
          while (v23 != v3)
          {
            unint64_t v27 = v3++;
            char v28 = *(unsigned char *)(v6 + v27);
            a2[1] = v3;
            v22 |= (unint64_t)(v28 & 0x7F) << v25;
            if ((v28 & 0x80) == 0) {
              goto LABEL_42;
            }
            v25 += 7;
            BOOL v18 = v26++ >= 9;
            if (v18)
            {
              LODWORD(v22) = 0;
LABEL_42:
              unint64_t v23 = v27 + 1;
              goto LABEL_44;
            }
          }
          LODWORD(v22) = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          char v20 = 0;
          unsigned int v21 = 0;
          uint64_t v22 = 0;
          while (1)
          {
            unint64_t v23 = v3 + 1;
            a2[1] = v3 + 1;
            char v24 = *(unsigned char *)(v6 + v3);
            v22 |= (unint64_t)(v24 & 0x7F) << v20;
            if ((v24 & 0x80) == 0) {
              break;
            }
            v20 += 7;
            unint64_t v3 = v23;
            BOOL v12 = v21++ > 8;
            if (v12)
            {
              LODWORD(v22) = 0;
              break;
            }
          }
        }
LABEL_44:
        *(_DWORD *)(a1 + 24) = v22;
        *(_DWORD *)(a1 + 8) |= 1u;
        unint64_t v3 = v23;
      }
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v3 >= v2 || *((unsigned char *)a2 + 24)) {
        return v4 == 0;
      }
    }
    char v13 = 0;
    unsigned int v14 = 0;
    unint64_t v9 = 0;
    if (v3 <= v2) {
      unint64_t v15 = v2;
    }
    else {
      unint64_t v15 = v3;
    }
    while (v15 != v3)
    {
      unint64_t v16 = v3++;
      char v17 = *(unsigned char *)(v6 + v16);
      a2[1] = v3;
      v9 |= (unint64_t)(v17 & 0x7F) << v13;
      if ((v17 & 0x80) == 0) {
        goto LABEL_22;
      }
      v13 += 7;
      BOOL v18 = v14++ >= 9;
      if (v18)
      {
        unint64_t v9 = 0;
LABEL_22:
        unint64_t v3 = v16 + 1;
        goto LABEL_23;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t as::RouteIdentifier::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  if (*(unsigned char *)(this + 8)) {
    this = PB::Writer::writeVarInt(a2);
  }
  int v4 = *(const PB::Base **)(v3 + 16);
  if (v4)
  {
    return PB::Writer::writeSubmessage(a2, v4);
  }
  return this;
}

uint64_t as::RouteIdentifier::formatText(as::RouteIdentifier *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  if (*((unsigned char *)this + 8)) {
    PB::TextFormatter::format(a2, "topologyClass");
  }
  uint64_t v5 = *((void *)this + 2);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "coreIdentifier");
  }
  return PB::TextFormatter::endObject(a2);
}

BOOL as::RouteIdentifier::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8) || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)) {
    return 0;
  }
  unint64_t v3 = *(void *)(a1 + 16);
  unint64_t v4 = *(void *)(a2 + 16);
  BOOL result = (v3 | v4) == 0;
  if (v3) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    return as::RouteIdentifierCore::operator==((_DWORD *)v3, (_DWORD *)v4);
  }
  return result;
}

uint64_t as::RouteIdentifier::clearCoreIdentifier(as::RouteIdentifier *this)
{
  uint64_t result = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void as::ChannelDescription::~ChannelDescription(as::ChannelDescription *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x21667A2D0);
}

void as::ChannelLayout::~ChannelLayout(as::ChannelLayout *this)
{
  *(void *)this = &unk_26C3124F0;
  unint64_t v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

{
  void **v2;

  *(void *)this = &unk_26C3124F0;
  unint64_t v2 = (void **)((char *)this + 16);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
  MEMORY[0x21667A2D0]();
}

void as::StreamFormat::~StreamFormat(as::StreamFormat *this)
{
  as::StreamFormat::~StreamFormat(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_26C3124B8;
  unint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  PB::Base::~Base(this);
}

void as::AvailableStreamFormat::~AvailableStreamFormat(as::AvailableStreamFormat *this)
{
  as::AvailableStreamFormat::~AvailableStreamFormat(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  void **v3;

  *(void *)this = &unk_26C3126C0;
  unint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<as::client::IOControllerPrefs>>::__destroy_vector::operator()[abi:ne180100](&v3);
  PB::Base::~Base(this);
}

void as::SampleRateRange::~SampleRateRange(as::SampleRateRange *this)
{
  PB::Base::~Base(this);
  JUMPOUT(0x21667A2D0);
}

void as::ActivationContext::~ActivationContext(as::ActivationContext *this)
{
  as::ActivationContext::~ActivationContext(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26C312618;
  caulk::xstring::clear((as::ActivationContext *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::AggregateDevice::~AggregateDevice(as::AggregateDevice *this)
{
  as::AggregateDevice::~AggregateDevice(this);
  JUMPOUT(0x21667A2D0);
}

{
  void **v2;

  *(void *)this = &unk_26C312570;
  caulk::xstring::clear((as::AggregateDevice *)((char *)this + 88));
  caulk::xstring::clear((as::AggregateDevice *)((char *)this + 72));
  caulk::xstring::clear((as::AggregateDevice *)((char *)this + 56));
  caulk::xstring::clear((as::AggregateDevice *)((char *)this + 40));
  unint64_t v2 = (void **)((char *)this + 16);
  std::vector<caulk::xstring>::__destroy_vector::operator()[abi:ne180100](&v2);
  PB::Base::~Base(this);
}

void as::RouteIdentifierCore::~RouteIdentifierCore(as::RouteIdentifierCore *this)
{
  as::RouteIdentifierCore::~RouteIdentifierCore(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26C312688;
  caulk::xstring::clear((as::RouteIdentifierCore *)((char *)this + 16));
  PB::Base::~Base(this);
}

void as::RouteIdentifier::~RouteIdentifier(as::RouteIdentifier *this)
{
  as::RouteIdentifier::~RouteIdentifier(this);
  JUMPOUT(0x21667A2D0);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_26C3125A8;
  unint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  PB::Base::~Base(this);
}

uint64_t std::vector<std::unique_ptr<as::ChannelDescription>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::ChannelDescription>>,std::reverse_iterator<std::unique_ptr<as::ChannelDescription>*>,std::reverse_iterator<std::unique_ptr<as::ChannelDescription>*>,std::reverse_iterator<std::unique_ptr<as::ChannelDescription>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<as::ChannelDescription>>,std::reverse_iterator<std::unique_ptr<as::ChannelDescription>*>,std::reverse_iterator<std::unique_ptr<as::ChannelDescription>*>,std::reverse_iterator<std::unique_ptr<as::ChannelDescription>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    unint64_t v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::ChannelDescription>>,std::reverse_iterator<std::unique_ptr<as::ChannelDescription>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::ChannelDescription>>,std::reverse_iterator<std::unique_ptr<as::ChannelDescription>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<as::client::PortPrefs>>,std::reverse_iterator<std::unique_ptr<as::client::PortPrefs>*>>::operator()[abi:ne180100]((void *)a1);
  }
  return a1;
}

void (***as::error_category::instance(as::error_category *this))(as::error_category *__hidden this)
{
  return as::error_category::instance(void)::gInstance;
}

void as::error_category::message(int __val@<W1>, void *a2@<X8>)
{
  switch(__val)
  {
    case -1:
      unint64_t v4 = "Unknown error";
      goto LABEL_27;
    case 0:
      unint64_t v4 = "None";
      goto LABEL_27;
    case 1:
      unint64_t v4 = "Exception caught";
      goto LABEL_27;
    case 2:
      unint64_t v4 = "Unimplemented";
      goto LABEL_27;
    case 3:
      unint64_t v4 = "XPC timeout";
      goto LABEL_27;
    case 4:
      unint64_t v4 = "Invalid session token";
      goto LABEL_27;
    case 5:
      unint64_t v4 = "Session access permission error";
      goto LABEL_27;
    case 6:
      unint64_t v4 = "Message parse error";
      goto LABEL_27;
    case 7:
      unint64_t v4 = "Invalid state change";
      goto LABEL_27;
    case 8:
      unint64_t v4 = "Too many configuration requests";
      goto LABEL_27;
    case 9:
      unint64_t v4 = "Invalid parameter";
      goto LABEL_27;
    case 10:
      unint64_t v4 = "Block already started/stopped";
      goto LABEL_27;
    case 11:
      unint64_t v4 = "Client session is no longer valid";
      goto LABEL_27;
    case 12:
      unint64_t v4 = "Invalid IO controller type";
      goto LABEL_27;
    case 13:
      unint64_t v4 = "Expired AURA object";
      goto LABEL_27;
    case 14:
      unint64_t v4 = "Expired sub-session object";
      goto LABEL_27;
    case 16:
      unint64_t v4 = "Restarting I/O after session reconfiguration failed";
      goto LABEL_27;
    case 17:
      unint64_t v4 = "AURA simulation failed";
      goto LABEL_27;
    case 18:
      unint64_t v4 = "Multiple I/O blocks with an unmixable output format";
      goto LABEL_27;
    case 19:
      unint64_t v4 = "Cannot transfer I/O resources of an active session";
      goto LABEL_27;
    case 20:
      unint64_t v4 = "Process does not own session's I/O resources";
      goto LABEL_27;
    case 21:
      unint64_t v4 = "Starting I/O timed out";
      goto LABEL_27;
    case 22:
      unint64_t v4 = "Unknown property";
      goto LABEL_27;
    case 23:
      unint64_t v4 = "Exception when dispatching property";
      goto LABEL_27;
    case 24:
      unint64_t v4 = "Bad hardware state (e.g. sample rate 0)";
LABEL_27:
      std::string::basic_string[abi:ne180100]<0>(a2, v4);
      break;
    default:
      std::to_string(&v7, __val);
      uint64_t v5 = std::string::insert(&v7, 0, "Garbage error code: ", 0x14uLL);
      long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
      a2[2] = *((void *)&v5->__r_.__value_.__l + 2);
      *(_OWORD *)a2 = v6;
      v5->__r_.__value_.__l.__size_ = 0;
      v5->__r_.__value_.__r.__words[2] = 0;
      v5->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v7.__r_.__value_.__l.__data_);
      }
      break;
  }
}

void sub_210AED240(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void (***as::public_error_category::instance(as::public_error_category *this))(as::public_error_category *__hidden this)
{
  return as::public_error_category::instance(void)::gInstance;
}

void as::public_error_category::message(int __val@<W1>, void *a2@<X8>)
{
  if (__val <= 561145186)
  {
    if (__val <= 560161139)
    {
      switch(__val)
      {
        case -50:
          unint64_t v4 = "Bad parameter";
          goto LABEL_37;
        case 0:
          unint64_t v4 = (char *)&unk_210AEF8EF;
          goto LABEL_37;
        case 560030580:
          unint64_t v4 = "Action cannot be performed while I/O is running";
          goto LABEL_37;
      }
    }
    else if (__val > 561015904)
    {
      if (__val == 561015905)
      {
        unint64_t v4 = "Missing background mode or category is not compatible with background audio usage";
        goto LABEL_37;
      }
      if (__val == 561017449)
      {
        unint64_t v4 = "Insufficient priority to activate at this time";
        goto LABEL_37;
      }
    }
    else
    {
      if (__val == 560161140)
      {
        unint64_t v4 = "Operation is incompatible with the current audio category";
        goto LABEL_37;
      }
      if (__val == 560557684)
      {
        unint64_t v4 = "Activation cannot be performed when the application is backgrounded";
        goto LABEL_37;
      }
    }
  }
  else if (__val > 1768841570)
  {
    if (__val > 1936290408)
    {
      if (__val == 1936290409)
      {
        unint64_t v4 = "Action cannot be performed because Siri is recording";
        goto LABEL_37;
      }
      if (__val == 2003329396)
      {
        unint64_t v4 = "An unspecifed error occurred";
        goto LABEL_37;
      }
    }
    else
    {
      if (__val == 1768841571)
      {
        unint64_t v4 = "Session not active";
        goto LABEL_37;
      }
      if (__val == 1836282486)
      {
        unint64_t v4 = "Server error";
        goto LABEL_37;
      }
    }
  }
  else if (__val > 561210738)
  {
    if (__val == 561210739)
    {
      unint64_t v4 = "The session has been destroyed";
      goto LABEL_37;
    }
    if (__val == 1701737535)
    {
      unint64_t v4 = "Missing entitlement";
      goto LABEL_37;
    }
  }
  else
  {
    if (__val == 561145187)
    {
      unint64_t v4 = "Cannot start recording at this time";
      goto LABEL_37;
    }
    if (__val == 561145203)
    {
      unint64_t v4 = "Hardware resource not available";
LABEL_37:
      std::string::basic_string[abi:ne180100]<0>(a2, v4);
      return;
    }
  }
  std::to_string(&v7, __val);
  uint64_t v5 = std::string::insert(&v7, 0, "Garbage error code: ", 0x14uLL);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  a2[2] = *((void *)&v5->__r_.__value_.__l + 2);
  *(_OWORD *)a2 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
}

void sub_210AED554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void as::error_category::~error_category(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x21667A2D0);
}

const char *as::error_category::name(as::error_category *this)
{
  return "Session Manager Error";
}

void as::public_error_category::~public_error_category(std::error_category *this)
{
  std::error_category::~error_category(this);
  JUMPOUT(0x21667A2D0);
}

const char *as::public_error_category::name(as::public_error_category *this)
{
  return "AVAudioSession Error";
}

void applesauce::dispatch::v1::queue::~queue(id *this)
{
  id v2 = *this;
  *this = 0;
}

void FormatNSErrorForReturn(int a1)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 67109120;
  v1[1] = a1;
  _os_log_fault_impl(&dword_210AAE000, &_os_log_internal, OS_LOG_TYPE_FAULT, "Not expected to see error code %d!", (uint8_t *)v1, 8u);
}

void as::smipc_Server_types_utility::updateDefaultRoute()
{
  v0 = (_Unwind_Exception *)_os_crash();
  __break(1u);
  _Unwind_Resume(v0);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t PB::TextFormatter::beginObject(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x270F587A0](this, a2);
}

uint64_t PB::TextFormatter::format()
{
  return MEMORY[0x270F587B0]();
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x270F587B8](this, a2);
}

{
  return MEMORY[0x270F587D0](this, a2);
}

{
  return MEMORY[0x270F587D8](this, a2);
}

{
  return MEMORY[0x270F587E8](this, a2);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, double a3)
{
  return MEMORY[0x270F587C0](this, a2, a3);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, float a3)
{
  return MEMORY[0x270F587C8](this, a2, a3);
}

uint64_t PB::TextFormatter::endObject(PB::TextFormatter *this)
{
  return MEMORY[0x270F587F0](this);
}

void PB::Base::~Base(PB::Base *this)
{
}

uint64_t PB::Reader::recallMark()
{
  return MEMORY[0x270F58810]();
}

uint64_t PB::Reader::read()
{
  return MEMORY[0x270F58820]();
}

uint64_t PB::Reader::placeMark()
{
  return MEMORY[0x270F58830]();
}

uint64_t PB::Writer::writeVarInt(PB::Writer *this)
{
  return MEMORY[0x270F58840](this);
}

{
  return MEMORY[0x270F58848](this);
}

{
  return MEMORY[0x270F58858](this);
}

uint64_t PB::Writer::writeSubmessage(PB::Writer *this, const PB::Base *a2)
{
  return MEMORY[0x270F58860](this, a2);
}

uint64_t PB::Writer::write()
{
  return MEMORY[0x270F58870]();
}

uint64_t PB::Writer::write(PB::Writer *this)
{
  return MEMORY[0x270F58878](this);
}

uint64_t PB::Writer::write(PB::Writer *this, double a2)
{
  return MEMORY[0x270F58880](this, a2);
}

uint64_t PB::Writer::write(PB::Writer *this, float a2)
{
  return MEMORY[0x270F58888](this, a2);
}

uint64_t caulk::xstring::move()
{
  return MEMORY[0x270F87BD0]();
}

uint64_t caulk::xstring::clear(caulk::xstring *this)
{
  return MEMORY[0x270F87BD8](this);
}

uint64_t caulk::xstring::assign()
{
  return MEMORY[0x270F87BE0]();
}

uint64_t caulk::xstring::assign(caulk::xstring *this, const caulk::xstring *a2)
{
  return MEMORY[0x270F87BE8](this, a2);
}

uint64_t caulk::xstring::c_str(caulk::xstring *this)
{
  return MEMORY[0x270F87C38](this);
}

uint64_t caulk::xstring::compare(caulk::xstring *this, const caulk::xstring *a2)
{
  return MEMORY[0x270F87C40](this, a2);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x270F983C8](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984A0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984E8](this, __pos, __s, __n);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

void std::error_category::~error_category(std::error_category *this)
{
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x270F989E8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x270F98C70](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x270F98C78](this);
}

void std::locale::~locale(std::locale *this)
{
}

const std::locale *__cdecl std::locale::operator=(std::locale *this, const std::locale *a2)
{
  return (const std::locale *)MEMORY[0x270F98C88](this, a2);
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, double a4)
{
  return MEMORY[0x270F98DA0](this, a2, a3, a4);
}

{
  return MEMORY[0x270F98DB8](this, a2, a3, a4);
}

uint64_t std::to_chars()
{
  return MEMORY[0x270F98DA8]();
}

{
  return MEMORY[0x270F98DB0]();
}

{
  return MEMORY[0x270F98DC0]();
}

{
  return MEMORY[0x270F98DC8]();
}

{
  return MEMORY[0x270F98DD8]();
}

{
  return MEMORY[0x270F98DE0]();
}

uint64_t std::to_chars(std::__1 *this, char *a2, char *a3, float a4)
{
  return MEMORY[0x270F98DD0](this, a2, a3, a4);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x270F98E08](retstr, *(void *)&__val);
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

uint64_t __udivti3()
{
  return MEMORY[0x270ED7F10]();
}

uint64_t __umodti3()
{
  return MEMORY[0x270ED7F28]();
}

uint64_t _os_crash()
{
  return MEMORY[0x270ED8060]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x270ED8070]();
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

uint64_t dispatch_pthread_root_queue_create()
{
  return MEMORY[0x270ED9438]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9440](attr);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9448](attr, frequency);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x270ED9468](label, attr, target);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x270ED95D0](label);
}

void dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t workloop, dispatch_autorelease_frequency_t frequency)
{
}

uint64_t dispatch_workloop_set_scheduler_priority()
{
  return MEMORY[0x270ED9600]();
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x270F9A898](a1);
}

void objc_storeStrong(id *location, id obj)
{
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x270EDADF8](a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return MEMORY[0x270EDAE00](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x270EDAE10](a1);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x270EDAE30](a1, a2);
}

int pthread_attr_setschedpolicy(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x270EDAE38](a1, *(void *)&a2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}