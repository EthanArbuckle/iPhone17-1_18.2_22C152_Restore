void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

void **std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

uint64_t TNode::GetNodeFromPath(TString *a1, TNodePtr *a2, unsigned int a3)
{
  TPathName::TPathName((TPathName *)v57, a1, TPathName::kPOSIXPathNameSeparator);
  v5 = (TNode *)std::deque<TString>::deque((uint64_t)&v52, v57);
  TGlobalNodes::BootNode((FINode **)&obj, v5);
  TNodePtr::operator=((void **)&a2->fFINode, &obj);

  if (v54 == v53
    || (v6 = (TNode **)(v53 + 8 * (v55 >> 9)),
        v7 = *v6,
        v8 = (TNode *)((char *)*v6 + 8 * (v55 & 0x1FF)),
        uint64_t v9 = *(void *)(v53 + (((v56 + v55) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v56 + v55) & 0x1FF),
        v8 == (TNode *)v9))
  {
    uint64_t v10 = 0;
    goto LABEL_51;
  }
  uint64_t v10 = 0;
  while (1)
  {
    uint64_t v11 = v8 - v7;
    uint64_t v12 = (v8 - v7) >> 3;
    if (v11 < -7) {
      uint64_t v13 = (uint64_t)v6[-((unint64_t)(510 - v12) >> 9)] + 8 * (~(510 - (unsigned __int16)v12) & 0x1FF);
    }
    else {
      uint64_t v13 = *(uint64_t *)((char *)v6 + (((unint64_t)(v12 + 1) >> 6) & 0x3FFFFFFFFFFFFF8))
    }
          + 8 * ((v12 + 1) & 0x1FF);
    BOOL v14 = v13 == v9;
    if ((a3 & 0x200) != 0)
    {
      uint64_t v15 = TNodeFromFINode(a2->fFINode);
      v16 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v15);
      os_unfair_lock_lock(v16);
      TNodePtr::TNodePtr((TNodePtr *)&obj, *(const TNode **)(v15 + 48));
      os_unfair_lock_unlock(v16);
      v17 = (TNode *)TNodeFromFINode((FINode *)obj);
      TGlobalNodes::BootNode(&v50, v17);
      if (v17 == (TNode *)TNodeFromFINode(v50))
      {
        uint64_t v18 = TNodeFromFINode(a2->fFINode);
        v19 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v18);
        os_unfair_lock_lock(v19);
        v21 = *(TFSInfo **)(v18 + 16);
        v20 = *(std::__shared_weak_count **)(v18 + 24);
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v19);
        TFSInfo::Name(v21, &v49);
        if (v20) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v20);
        }
        TPathName::VolumesDirectory(&v48);
        int v22 = CFEqual(v49.fString.fRef, v48.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v48.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v49.fString.fRef);

        if (v22)
        {
          uint64_t v23 = TNodeFromFINode(a2->fFINode);
          TNode::HandleSync(v23, 0x1000000u);
        }
      }
      else
      {
      }
    }
    uint64_t v24 = TNodeFromFINode(a2->fFINode);
    v25 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v24);
    os_unfair_lock_lock(v25);
    v27 = *(TFSInfo **)(v24 + 16);
    v26 = *(std::__shared_weak_count **)(v24 + 24);
    if (v26) {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v25);
    BOOL IsAlias = TFSInfo::IsAlias(v27);
    if (v26) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v26);
    }
    if (IsAlias)
    {
      v29 = (TNode *)TNodeFromFINode(a2->fFINode);
      id obj = 0;
      uint64_t v10 = TNode::FollowAlias(v29, a2, (TNodeRequest **)&obj, 8);
    }
    if (!v10)
    {
      if ((a3 & 0x40000) != 0)
      {
        uint64_t v30 = TNodeFromFINode(a2->fFINode);
        TNode::HandleSync(v30, 0x11000000u);
      }
      v31 = (TNode *)TNodeFromFINode(a2->fFINode);
      TNode::FindChild(v31, v8, v14 & (a3 >> 13), 0, &obj);
      if (TNodeFromFINode((FINode *)obj))
      {
        uint64_t v32 = TNodeFromFINode((FINode *)obj);
        v33 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v32);
        os_unfair_lock_lock(v33);
        uint64_t v35 = *(void *)(v32 + 16);
        v34 = *(std::__shared_weak_count **)(v32 + 24);
        if (v34) {
          atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v33);
        v36 = (os_unfair_lock_s *)(v35 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v35 + 100));
        int v37 = *(_DWORD *)(v35 + 115);
        os_unfair_lock_unlock(v36);
        if (v34) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v34);
        }
        if ((v37 & 0x8000) != 0)
        {
          uint64_t v41 = TNodeFromFINode((FINode *)obj);
          v42 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v41);
          os_unfair_lock_lock(v42);
          v44 = *(TFSInfo **)(v41 + 16);
          v43 = *(std::__shared_weak_count **)(v41 + 24);
          if (v43) {
            atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          os_unfair_lock_unlock(v42);
          uint64_t v10 = TFSInfo::TriggerMount(v44);
          if (v43) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v43);
          }
          if (v10) {
            goto LABEL_43;
          }
          uint64_t v45 = TNodeFromFINode((FINode *)obj);
          TNode::HandleSync(v45, 0x80000u);
        }
        else if ((a3 & 0x80) == 0)
        {
          v38 = (TNode *)TNodeFromFINode((FINode *)obj);
          if (!TNode::ValidateURL(v38))
          {
            uint64_t v39 = TNodeFromFINode((FINode *)obj);
            TNode::HandleSync(v39, 0x80000u);
            v40 = (TNode *)TNodeFromFINode((FINode *)obj);
            if (TNode::ValidateURL(v40)) {
              uint64_t v10 = 0;
            }
            else {
              uint64_t v10 = 4294959236;
            }
            goto LABEL_43;
          }
        }
      }
      uint64_t v10 = 0;
LABEL_43:
      objc_storeStrong((id *)&a2->fFINode, obj);
    }
    if (!TNodeFromFINode(a2->fFINode)) {
      break;
    }
    v8 = (TNode *)((char *)v8 + 8);
    v7 = *v6;
    if (v8 - *v6 == 4096)
    {
      v46 = v6[1];
      ++v6;
      v7 = v46;
      v8 = v46;
    }
    if (v8 == (TNode *)v9) {
      goto LABEL_51;
    }
  }
  uint64_t v10 = 4294959236;
LABEL_51:
  if (TNodeFromFINode(a2->fFINode)) {
    TNodeFromFINode(a2->fFINode);
  }
  else {
    uint64_t v10 = 4294959236;
  }
  std::deque<TString>::~deque[abi:ne180100](&v52);
  std::deque<TString>::~deque[abi:ne180100](v57);
  return v10;
}

void sub_1D3440184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }

  std::deque<TString>::~deque[abi:ne180100]((uint64_t *)va);
  std::deque<TString>::~deque[abi:ne180100]((uint64_t *)va1);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsAlias(TFSInfo *this)
{
  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  return (v3 & 0x800) != 0 || (*((unsigned char *)this + 112) & 0xFB) == 3;
}

BOOL TNode::ValidateURL(TNode *this)
{
  __p = 0;
  TNode::CopyURL(this, (const __CFURL **)&__p);
  CFURLRef url = (CFURLRef)__p;
  if (__p)
  {
    std::vector<unsigned char>::vector(&__p, 0x400uLL);
    BOOL v1 = CFURLGetFileSystemRepresentation(url, 1u, (UInt8 *)__p, v4 - (unsigned char *)__p) != 0;
    if (__p)
    {
      v4 = __p;
      operator delete(__p);
    }
  }
  else
  {
    BOOL v1 = 1;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&url);
  return v1;
}

void sub_1D3440348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, const void *a12)
{
  if (__p) {
    operator delete(__p);
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a12);
  _Unwind_Resume(a1);
}

uint64_t TNode::CopyURL(TNode *this, const __CFURL **a2)
{
  *a2 = 0;
  BOOL v14 = &stru_1F2ABD380;
  v4 = (TNode *)CFRetain(&stru_1F2ABD380);
  v5 = (os_unfair_lock_s *)TNode::InfoLock(v4);
  os_unfair_lock_lock(v5);
  v6 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v5);
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  else
  {
    os_unfair_lock_unlock(v5);
  }
  v8 = (os_unfair_lock_s *)TNode::InfoLock(v7);
  os_unfair_lock_lock(v8);
  uint64_t v10 = (TFSInfo *)*((void *)this + 2);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  CFURLRef URL = (const __CFURL *)TFSInfo::MakeURL(v10);
  *a2 = URL;
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    CFURLRef URL = *a2;
  }
  if (URL)
  {
    _CFURLCacheSetAutoFlushingEnabled();
    if (*a2) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = 4294959236;
    }
  }
  else
  {
    uint64_t v12 = 4294959236;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14);
  return v12;
}

void sub_1D344046C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void *TFSInfo::MakeURL(TFSInfo *this)
{
  v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = (const void *)*((void *)this + 2);
  CFTypeRef cf = v3;
  if (v3)
  {
    CFRetain(v3);
    os_unfair_lock_unlock(v2);
  }
  else
  {
    os_unfair_lock_unlock(v2);
    if (*((unsigned char *)this + 112) == 27)
    {
      v4 = (os_unfair_lock_s *)((char *)this + 96);
      os_unfair_lock_lock((os_unfair_lock_t)this + 24);
      uint64_t v5 = *((void *)this + 10);
      if (v5
        && (os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72)),
            int v6 = *(unsigned __int8 *)(v5 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72)),
            v6 == 1))
      {
        id v7 = *(id *)(v5 + 24);
      }
      else
      {
        id v7 = 0;
      }
      os_unfair_lock_unlock(v4);
      if (v7)
      {
        if ([v7 isUsingFPFS])
        {
          v8 = [v7 rootURL];
          uint64_t v9 = static_objc_cast<NSString,objc_object * {__strong}>(v8);

          id v10 = v9;
          int v3 = static_cf_cast<__CFString const*,void const*>(v10);
        }
        else
        {
          int v3 = cf;
        }
      }
      else
      {
        int v3 = 0;
      }
    }
    else
    {
      int v3 = 0;
    }
  }
  CFTypeRef cf = 0;
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf);
  return v3;
}

void sub_1D34405D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void *std::vector<unsigned char>::vector(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<char>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    uint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1D344066C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<char>::__vallocate[abi:ne180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void TFSInfo::~TFSInfo(TFSInfo *this)
{
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)this + 11);
  std::unique_ptr<TFSInfoOverflow>::reset[abi:ne180100]((TFSInfoOverflow **)this + 10, 0);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)this + 2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)this + 1);
  v2 = *(const void ***)this;
  *(void *)this = 0;
  if (v2) {
    std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)this, v2);
  }
}

const void **TFSInfo::GetPath@<X0>(TFSInfo *this@<X0>, uint64_t a2@<X8>)
{
  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  uint64_t v5 = (void *)*((void *)this + 2);
  id v10 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    TCFURLInfo::FileSystemRepresentation((TCFURLInfo *)v5, (const __CFURL *)1, (TString *)&theString);
    if (CFStringGetLength(theString))
    {
      fstd::optional_err<TString,int>::optional_err(a2, (TString **)&theString);
    }
    else
    {
      TString::TString(&v8, "");
      int v7 = -43;
      fstd::optional_err<TString,int>::optional_err(a2, (CFTypeRef *)&v8.fString.fRef, &v7);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
    }
  }
  else
  {
    os_unfair_lock_unlock(v4);
    TString::TString((TString *)&theString, "");
    LODWORD(v8.fString.fRef) = -8058;
    fstd::optional_err<TString,int>::optional_err(a2, (CFTypeRef *)&theString, &v8);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v10);
}

void sub_1D344085C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

const void **TFSInfo::GetVolumeID@<X0>(TFSInfo *this@<X0>, void *a2@<X8>)
{
  v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  uint64_t v5 = (void *)*((void *)this + 2);
  uint64_t v9 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    CFTypeRef VolumeIdentifier = TCFURLInfo::GetVolumeIdentifier((TCFURLInfo *)v5, v6);
    *a2 = VolumeIdentifier;
    if (VolumeIdentifier) {
      CFRetain(VolumeIdentifier);
    }
    return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v9);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    result = TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v9);
    *a2 = 0;
  }
  return result;
}

void sub_1D3440928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

const void **TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(const void **a1)
{
  v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

CFTypeRef TCFURLInfo::GetVolumeIdentifier(TCFURLInfo *this, const __CFURL *a2)
{
  CFTypeRef propertyValueTypeRefPtr = 0;
  if (!this) {
    return 0;
  }
  CFURLCopyResourcePropertyForKey(this, (CFStringRef)*MEMORY[0x1E4F1D838], &propertyValueTypeRefPtr, 0);
  CFTypeRef v2 = propertyValueTypeRefPtr;
  if (propertyValueTypeRefPtr) {
    CFAutorelease(propertyValueTypeRefPtr);
  }
  return v2;
}

TString *TCFURLInfo::FileSystemRepresentation@<X0>(TCFURLInfo *this@<X0>, const __CFURL *a2@<X1>, TString *a3@<X8>)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (TCFURLInfo::GetFileSystemRepresentation(this, a2, (UInt8 *)v5, (unsigned __int8 *)0x409)) {
    return TString::TString(a3, v5);
  }
  a3->fString.fRef = &stru_1F2ABD380;
  return (TString *)CFRetain(&stru_1F2ABD380);
}

uint64_t TCFURLInfo::GetFileSystemRepresentation(TCFURLInfo *this, const __CFURL *a2, UInt8 *a3, unsigned __int8 *a4)
{
  Boolean v6 = a2;
  uint64_t result = _CFURLIsFileURL();
  if (result) {
    return CFURLGetFileSystemRepresentation(this, v6, a3, (CFIndex)a4) != 0;
  }
  return result;
}

uint64_t fstd::optional_err<TString,int>::optional_err(uint64_t a1, CFTypeRef *a2, _DWORD *a3)
{
  *(void *)a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
  *(_DWORD *)(a1 + 8) = *a3;
  return a1;
}

const void **TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(const void **a1)
{
  CFTypeRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

CFIndex TFSInfo::initialize(uint64_t a1, const __CFURL *a2, int a3, int a4, int a5, char a6, int a7)
{
  BOOL v14 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  unint64_t v15 = *(_DWORD *)(a1 + 115) & 0xBFFFFFFF | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
  *(_DWORD *)(a1 + 115) &= ~0x40000000u;
  *(_WORD *)(a1 + 119) = WORD2(v15);
  os_unfair_lock_unlock(v14);
  v17 = (CFTypeRef *)(a1 + 16);
  v16 = *(const void **)(a1 + 16);
  if (v16) {
    CFRelease(v16);
  }
  v19 = (CFTypeRef *)(a1 + 8);
  uint64_t v18 = *(const void **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  if (v18) {
    CFRelease(v18);
  }
  v20 = *(__CFString **)(a1 + 24);
  *(void *)(a1 + 8) = 0;
  if (v20 != @"?") {
    TString::SetStringRefAsImmutable((TString *)(a1 + 24), (TString *)@"?");
  }
  TString::SetStringRefAsImmutable((TString *)(a1 + 32), 0);
  std::unique_ptr<TFSInfoOverflow>::reset[abi:ne180100]((TFSInfoOverflow **)(a1 + 80), 0);
  unint64_t v21 = *(_DWORD *)(a1 + 115) & 0xF9FFFFFF | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
  *(_DWORD *)(a1 + 115) = *(_DWORD *)(a1 + 115) & 0xF9FFFFFF | 0x4000000;
  *(_WORD *)(a1 + 119) = WORD2(v21);
  if (a7)
  {
    if (!a2) {
      goto LABEL_20;
    }
  }
  else
  {
    if (!a2) {
      goto LABEL_20;
    }
    _CFURLCacheSetAutoFlushingEnabled();
  }
  if (a5 && (!CFURLIsFileReferenceURL(a2) && (a6 & 1) != 0 || CFURLGetBaseURL(a2)))
  {
    CFURLClearResourcePropertyCache(a2);
    CFURLRef v22 = CFURLCreateFileReferenceURL(0, a2, 0);
    if (*v19) {
      CFRelease(*v19);
    }
    CFTypeRef *v19 = v22;
    if (!v22)
    {
LABEL_24:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a1 + 8), a2);
      if (!a4) {
        goto LABEL_32;
      }
      goto LABEL_25;
    }
    _CFURLCacheSetAutoFlushingEnabled();
  }
LABEL_20:
  if (!*v19) {
    goto LABEL_24;
  }
  uint64_t v23 = [(id)*v19 path];
  uint64_t v24 = [v23 length];

  if (!v24) {
    goto LABEL_24;
  }
  if (!a4) {
    goto LABEL_32;
  }
LABEL_25:
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a1 + 8));
  CFIndex Properties = TFSInfo::FetchProperties((TFSInfo *)a1, a3 == 0);
  if (!Properties)
  {
    os_unfair_lock_lock(v14);
    int v26 = *(_DWORD *)(a1 + 115);
    os_unfair_lock_unlock(v14);
    if ((v26 & 0x20) != 0
      || (os_unfair_lock_lock(v14), int v27 = *(_DWORD *)(a1 + 115), os_unfair_lock_unlock(v14), (v27 & 0x400) != 0)
      || (os_unfair_lock_lock(v14), int v28 = *(_DWORD *)(a1 + 115), os_unfair_lock_unlock(v14), (v28 & 0x40) != 0))
    {
LABEL_32:
      uint64_t v29 = _CFURLCopyFileURL();
      if (*v17) {
        CFRelease(*v17);
      }
      CFIndex Properties = 0;
      CFTypeRef *v17 = (CFTypeRef)v29;
      if (!v29) {
        goto LABEL_35;
      }
      return Properties;
    }
    CFIndex Properties = 4294967253;
  }
  if (!*v17) {
LABEL_35:
  }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(v17, *v19);
  return Properties;
}

void sub_1D3440DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

TFSInfoOverflow *std::unique_ptr<TFSInfoOverflow>::reset[abi:ne180100](TFSInfoOverflow **a1, TFSInfoOverflow *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    TFSInfoOverflow::~TFSInfoOverflow(result);
    JUMPOUT(0x1D9436740);
  }
  return result;
}

uint64_t std::deque<TString>::~deque[abi:ne180100](void *a1)
{
  CFTypeRef v2 = (void **)a1[1];
  int v3 = (void **)a1[2];
  if (v3 == v2)
  {
    v4 = a1 + 5;
    int v3 = (void **)a1[1];
  }
  else
  {
    v4 = a1 + 5;
    unint64_t v5 = a1[4];
    Boolean v6 = &v2[v5 >> 9];
    int v7 = (const void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v5) & 0x1FF);
    if (v7 != (const void **)v8)
    {
      do
      {
        int v7 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v7) + 1;
        if ((char *)v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v9 = (const void **)v6[1];
          ++v6;
          int v7 = v9;
        }
      }
      while (v7 != (const void **)v8);
      CFTypeRef v2 = (void **)a1[1];
      int v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      int v3 = (void **)a1[2];
      CFTypeRef v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 256;
  }
  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 512;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    uint64_t v13 = *v2++;
    operator delete(v13);
  }
  return std::__split_buffer<TNodeEventPtr *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<TNodeEventPtr *>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

uint64_t fstd::optional_err<TString,int>::optional_err(uint64_t a1, TString **a2)
{
  *(void *)a1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void sub_1D3440FFC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TPathName::TPathName(TPathName *this, TString *a2, int a3)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  CFIndex Length = CFStringGetLength(a2->fString.fRef);
  if (Length >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 1;
    while (1)
    {
      if (CFStringGetLength(a2->fString.fRef) <= v9 - 1) {
        int CharacterAtIndex = 0;
      }
      else {
        int CharacterAtIndex = CFStringGetCharacterAtIndex(a2->fString.fRef, v9 - 1);
      }
      if (CharacterAtIndex == a3)
      {
        if (v7)
        {
          TString::SubString(a2, v8, v7, (TString *)&theString);
          if (CFStringGetLength(theString) == 1
            && CFStringGetLength(theString) >= 1
            && CFStringGetCharacterAtIndex(theString, 0) == 46
            || CFStringGetLength(theString) == 2
            && CFStringGetLength(theString) >= 1
            && CFStringGetCharacterAtIndex(theString, 0) == 46
            && CFStringGetLength(theString) >= 2
            && CFStringGetCharacterAtIndex(theString, 1) == 46)
          {
            goto LABEL_32;
          }
          std::deque<TString>::push_back(this, (TString **)&theString);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
          uint64_t v7 = 0;
        }
        uint64_t v8 = v9;
      }
      else
      {
        ++v7;
        if (Length == v9 && v7)
        {
          TString::SubString(a2, v8, v7, (TString *)&theString);
          if (CFStringGetLength(theString) == 1
            && CFStringGetLength(theString) >= 1
            && CFStringGetCharacterAtIndex(theString, 0) == 46
            || CFStringGetLength(theString) == 2
            && CFStringGetLength(theString) >= 1
            && CFStringGetCharacterAtIndex(theString, 0) == 46
            && CFStringGetLength(theString) >= 2
            && CFStringGetCharacterAtIndex(theString, 1) == 46)
          {
LABEL_32:
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
            return;
          }
          std::deque<TString>::push_back(this, (TString **)&theString);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
          uint64_t v7 = 0;
          uint64_t v8 = Length;
        }
      }
      if (Length > v9)
      {
        ++v9;
        if (v7 < 256) {
          continue;
        }
      }
      return;
    }
  }
}

void sub_1D3441264(_Unwind_Exception *a1)
{
  std::deque<TString>::~deque[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void TString::TString(TString *this, const char *a2)
{
  this->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, &stru_1F2ABD380);
  if (a2)
  {
    CFIndex v4 = strlen(a2);
    TString::SetFromUTF8(this, (const UInt8 *)a2, v4);
  }
}

void sub_1D3441304(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **TString::SetFromUTF8(TString *this, const UInt8 *a2, CFIndex a3)
{
  if (a3)
  {
    CFStringRef v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, 0x8000100u, 0);
    CFStringRef v7 = v4;
    if (v4) {
      unint64_t v5 = (__CFString *)v4;
    }
    else {
      unint64_t v5 = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, v5);
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7);
  }
  else
  {
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, &stru_1F2ABD380);
  }
}

void sub_1D34413B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

CFTypeRef *TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(CFTypeRef *a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  if (*a1) {
    CFRelease(*a1);
  }
  *a1 = cf;
  return a1;
}

const void **TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

id static_objc_cast<DSFileServiceConnection,void *>(void *a1)
{
  uint64_t v1 = static_objc_cast<NSString,objc_object * {__strong}>(a1);
  return v1;
}

uint64_t TNodeFromFINode(FINode *a1)
{
  uint64_t v1 = static_objc_cast<NSString,objc_object * {__strong}>(a1);
  uint64_t v2 = [v1 asTNode];

  return v2;
}

void sub_1D34414A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id static_objc_cast<NSString,objc_object * {__strong}>(id a1)
{
  if (a1)
  {
    uint64_t v2 = a1;
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      a1 = 0;
    }
    else {
      a1 = v2;
    }
    uint64_t v1 = vars8;
  }
  return a1;
}

uint64_t TString::IsMutable(TString *this, const __CFString *a2)
{
  if (!this)
  {
    BOOL v3 = 0;
    int v4 = 1;
    return v3 | (v4 << 8);
  }
  ClassName = object_getClassName(this);
  if (!strcmp(ClassName, "__NSCFConstantString") || !strcmp(ClassName, "NSTaggedPointerString"))
  {
    BOOL v3 = 0;
LABEL_9:
    int v4 = 1;
    return v3 | (v4 << 8);
  }
  if (!strcmp(ClassName, "__NSCFString"))
  {
    BOOL v3 = __CFStringIsMutable() != 0;
    goto LABEL_9;
  }
  BOOL v3 = 0;
  int v4 = 0;
  return v3 | (v4 << 8);
}

TString *std::deque<TString>::push_back(void *a1, TString **a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = ((v5 - v4) << 6) - 1;
  if (v5 == v4) {
    uint64_t v6 = 0;
  }
  if (v6 == a1[5] + a1[4])
  {
    std::deque<TString>::__add_back_capacity(a1);
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
  }
  if (v5 == v4)
  {
    uint64_t v8 = 0;
  }
  else
  {
    unint64_t v7 = a1[5] + a1[4];
    uint64_t v8 = (TString *)(*(void *)(v4 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7 & 0x1FF));
  }
  uint64_t result = std::construct_at[abi:ne180100]<TString,TString const&,TString*>(v8, a2);
  ++a1[5];
  return result;
}

CFIndex TFSInfo::FetchProperties(TFSInfo *this, int a2)
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    int v3 = *(_DWORD *)((char *)this + 115);
    *(_DWORD *)((char *)this + 115) = v3 | 0x40000000;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v3 & 0x40000000) != 0) {
      return 0;
    }
  }
  if (*((void *)this + 1))
  {
    int v4 = *((unsigned __int8 *)this + 112);
    long long v131 = 0u;
    long long v132 = 0u;
    long long v129 = 0u;
    long long v130 = 0u;
    long long v127 = 0u;
    long long v128 = 0u;
    long long v125 = 0u;
    long long v126 = 0u;
    uint64_t v120 = 0;
    uint64_t v121 = 0;
    CFTypeRef cf = 0;
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if (_CFURLCopyResourcePropertyValuesAndFlags())
    {
      v117 = (const void *)*((void *)&v132 + 1);
      v118 = (const void *)v125;
    }
    else
    {
      CFIndex v15 = TCFURLInfo::TranslateCFError((TCFURLInfo *)cf, v5);
      if (v15 == -43)
      {
        v117 = (const void *)*((void *)&v132 + 1);
        v118 = (const void *)v125;
LABEL_179:
        TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&v117);
        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&v118);
        TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&cf);
        return v15;
      }
      v16 = LogObj(5);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        v17 = (NSURL *)*((id *)this + 1);
        SanitizedURL(v17);
        id v18 = (id)objc_claimAutoreleasedReturnValue();
        v19 = [NSNumber numberWithInt:v15];
        theString[0].char st_dev = 138543618;
        *(void *)&theString[0].st_mode = v18;
        WORD2(theString[0].st_ino) = 2114;
        *(__darwin_ino64_t *)((char *)&theString[0].st_ino + 6) = (__darwin_ino64_t)v19;
        _os_log_impl(&dword_1D343E000, v16, OS_LOG_TYPE_DEBUG, "_CFURLCopyResourcePropertyValuesAndFlags failed %{public}@, status = %{public}@", (uint8_t *)theString, 0x16u);
      }
      v117 = (const void *)*((void *)&v132 + 1);
      v118 = (const void *)v125;
      if (v15) {
        goto LABEL_179;
      }
    }
    TFSInfo::GetObjectIdentifier(this);
    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFF7EDF | (32
                                                                                    * ((v120 >> 1) & 1)) & 0xFFFFFEFF | (((v120 >> 3) & 1) << 8) | (v120 >> 1) & 0x8000;
    uint64_t v6 = (TString *)v125;
    CFTypeRef cf1 = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&cf1, v6);
    if (UseFileProviderFramework())
    {
      uint64_t v8 = TFSInfo::GetFPItem(this);
      BOOL v9 = v8 == 0;

      if (!v9) {
        TFSInfo::FetchBladeRunnerProperties(this, v10, v7);
      }
    }
    if ((*(_DWORD *)((char *)this + 115) & 0x120) == 0
      && (TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E4F1CDC8], v7) & 0x40000000) == 0|| (os_unfair_lock_lock((os_unfair_lock_t)this + 25), int v11 = *(_DWORD *)((char *)this + 115), os_unfair_lock_unlock((os_unfair_lock_t)this + 25), (v11 & 0x40000000) != 0))
    {
      CFIndex v15 = 0;
      goto LABEL_34;
    }
    FileSuffix((const TString *)&cf1, (TString *)theString);
    CFIndex Length = CFStringGetLength(*(CFStringRef *)&theString[0].st_dev);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
    if (Length)
    {
      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
      *(_DWORD *)((char *)this + 115) |= 0x40000000u;
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      goto LABEL_31;
    }
    TString::TString((TString *)theString, "Documents", 9uLL);
    if (CFEqual(cf1, *(CFTypeRef *)&theString[0].st_dev))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
    }
    else
    {
      TString::TString((TString *)&cf2, "BDMV", 4uLL);
      int v20 = CFEqual(cf1, cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
      if (!v20)
      {
        if ((*(_DWORD *)((char *)this + 115) & 0x8000) == 0
          && TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E4F1D870], v21))
        {
          TFSInfo::Path(this, &cf2);
          if (CFStringGetLength((CFStringRef)cf2))
          {
            TString::TString(&v122, ".localized", 0xAuLL);
            AppendPath((const TString *)&cf2, &v122, (TString *)theString);
            TString::operator=(&cf2, (const void **)theString);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v122.fString.fRef);
            v114 = (const char *)TString::c_str((TString *)&cf2);
            if (stat(v114, theString) != -1) {
              TFSInfo::SetHasLSProperties(this, 1);
            }
            CFIndex v15 = 0;
          }
          else
          {
            CFIndex v15 = 4294959238;
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
          goto LABEL_32;
        }
LABEL_31:
        CFIndex v15 = 0;
LABEL_32:
        os_unfair_lock_lock((os_unfair_lock_t)this + 25);
        int v22 = *(_DWORD *)((char *)this + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
        if ((v22 & 0x40000000) != 0)
        {
          v122.fString.fRef = 0;
          CFTypeRef cf2 = 0;
          _CFURLCopyResourcePropertyValuesAndFlags();
          v120 |= (unint64_t)cf2;
        }
LABEL_34:
        *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFBBF | ((v120 & 1) << 10) | (((v120 >> 2) & 1) << 6);
        os_unfair_lock_lock((os_unfair_lock_t)this + 25);
        int v23 = *(_DWORD *)((char *)this + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
        if ((v23 & 0x40000000) != 0)
        {
          unsigned int v36 = v120;
          os_unfair_lock_lock((os_unfair_lock_t)this + 25);
          unint64_t v37 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | (v36 >> 3) & 2;
          *(_WORD *)((char *)this + 119) = WORD2(v37);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
          unsigned int v38 = v120;
          os_unfair_lock_lock((os_unfair_lock_t)this + 25);
          unint64_t v39 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | (v38 >> 7) & 0x10;
          *(_WORD *)((char *)this + 119) = WORD2(v39);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
          os_unfair_lock_lock((os_unfair_lock_t)this + 25);
          *(_WORD *)((char *)this + 119) |= 0x800u;
          os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
          unsigned int v40 = v120;
          os_unfair_lock_lock((os_unfair_lock_t)this + 25);
          unint64_t v41 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | (v40 >> 7) & 4;
          *(_WORD *)((char *)this + 119) = WORD2(v41);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
          BOOL v24 = 0;
          int v27 = 0;
          goto LABEL_64;
        }
        BOOL v24 = 0;
        int v25 = *(_DWORD *)((char *)this + 115);
        unint64_t v26 = v25 & 0xFFFFFFF9 | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
        *(_DWORD *)((char *)this + 115) = v25 & 0xFFFFFFE9 | 0x10;
        *(_WORD *)((char *)this + 119) = WORD2(v26);
        if ((v25 & 0x40) != 0)
        {
          int v27 = 0;
          goto LABEL_64;
        }
        int v27 = 0;
        if (!(void)v125) {
          goto LABEL_64;
        }
        if (!CFStringGetCString((CFStringRef)v125, (char *)theString, 1024, 0x8000100u))
        {
          BOOL v24 = 0;
          goto LABEL_62;
        }
        int v28 = strrchr((char *)theString, 46);
        if (!v28 || v28 == (char *)theString)
        {
          BOOL v24 = 0;
          unint64_t v42 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          goto LABEL_53;
        }
        uint64_t v29 = v28;
        BOOL v24 = strchr((char *)theString, 46) != v28;
        char v30 = *v29;
        if (*v29)
        {
          v31 = (unsigned __int8 *)(v29 + 1);
          do
          {
            *(v31 - 1) = __tolower(v30);
            int v32 = *v31++;
            char v30 = v32;
          }
          while (v32);
        }
        if (!strcmp(v29, ".app"))
        {
          unint64_t v34 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
        }
        else
        {
          int v33 = strcmp(v29, ".service");
          unint64_t v34 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
          if (v33)
          {
            uint64_t v35 = 0;
LABEL_52:
            unint64_t v42 = v34 & 0xFFFFFFFFFFFFFFFBLL | v35;
LABEL_53:
            *(_DWORD *)((char *)this + 115) = v42;
            *(_WORD *)((char *)this + 119) = WORD2(v42);
            char st_dev = theString[0].st_dev;
            if (LOBYTE(theString[0].st_dev))
            {
              char v44 = 0;
              uint64_t v45 = (unsigned __int8 *)&theString[0].st_dev + 1;
              do
              {
                if (st_dev < 32) {
                  char v44 = 1;
                }
                int v46 = *v45++;
                char st_dev = v46;
                if (v46) {
                  BOOL v47 = (v44 & 1) == 0;
                }
                else {
                  BOOL v47 = 0;
                }
              }
              while (v47);
              goto LABEL_63;
            }
LABEL_62:
            char v44 = 0;
LABEL_63:
            int v27 = v44 & 1;
LABEL_64:
            char v48 = v120;
            os_unfair_lock_lock((os_unfair_lock_t)this + 25);
            TString v49 = (unsigned int *)((char *)this + 115);
            unint64_t v50 = *(_DWORD *)((char *)this + 115) & 0xFFFFFF7F | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
            *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFF7F | (2 * (v48 & 0x40));
            *(_WORD *)((char *)this + 119) = WORD2(v50);
            os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
            char v51 = v120;
            os_unfair_lock_lock((os_unfair_lock_t)this + 25);
            unint64_t v52 = *(_DWORD *)((char *)this + 115) & 0xFFFEFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
            *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFEFFFF | ((v51 & 0x20) << 11);
            *(_WORD *)((char *)this + 119) = WORD2(v52);
            os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
            unsigned int v53 = v120;
            BOOL v55 = (v120 & 0x80) == 0 || v4 == 7;
            *TString v49 = *v49 & 0xFFFFFFFE | v55;
            os_unfair_lock_lock((os_unfair_lock_t)this + 25);
            unint64_t v56 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFF7 | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
            *TString v49 = *v49 & 0xFFFFFFF7 | (v53 >> 5) & 8;
            *(_WORD *)((char *)this + 119) = WORD2(v56);
            os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
            __int16 v57 = v120;
            os_unfair_lock_lock((os_unfair_lock_t)this + 25);
            uint64_t v58 = *v49;
            char v59 = *v49;
            if (v57 < 0)
            {
              unint64_t v60 = v58 | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
            }
            else
            {
              os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
              os_unfair_lock_lock((os_unfair_lock_t)this + 25);
              unint64_t v60 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
              if ((v59 & 0x40) == 0)
              {
                int v61 = 0;
LABEL_75:
                *(_DWORD *)((char *)this + 115) = v60 & 0xFFFFF7FF | v61;
                *(_WORD *)((char *)this + 119) = WORD2(v60);
                os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                int v62 = *(_DWORD *)((char *)this + 115);
                os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                if ((v62 & 0x800) != 0)
                {
                  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                  int v63 = *(_DWORD *)((char *)this + 115);
                  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  if ((v63 & 0x40) == 0)
                  {
                    if (TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E4F1D870], v64))TFSInfo::GetAliasInfoFrom(this, (BOOL *)theString, (BOOL *)&cf2, 0, 0); {
                  }
                    }
                }
                unint64_t v65 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
                uint64x2_t v66 = (uint64x2_t)vdupq_lane_s64(v120, 0);
                int8x16_t v67 = (int8x16_t)vdupq_n_s64(1uLL);
                int8x16_t v68 = vorrq_s8((int8x16_t)vshlq_u64((uint64x2_t)vandq_s8((int8x16_t)vshlq_u64(v66, (uint64x2_t)xmmword_1D350AF10), v67), (uint64x2_t)xmmword_1D350AF30), (int8x16_t)vshlq_u64((uint64x2_t)vandq_s8((int8x16_t)vshlq_u64(v66, (uint64x2_t)xmmword_1D350AF00), v67), (uint64x2_t)xmmword_1D350AF20));
                uint64_t v69 = *(void *)&vorr_s8(*(int8x8_t *)v68.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL)) | v65 & 0xFFFFFFFF8DFFLL;
                *(_DWORD *)((char *)this + 115) = v69;
                *(_WORD *)((char *)this + 119) = WORD2(v69);
                if (v4 != 7 && (v121 & 1) != 0)
                {
                  v70 = (TString *)v125;
                  if ((void)v125)
                  {
                    if ((v65 & 0x100) == 0)
                    {
LABEL_87:
                      *(void *)&theString[0].char st_dev = &stru_1F2ABD380;
                      CFRetain(&stru_1F2ABD380);
                      TString::SetStringRefAsImmutable((TString *)theString, v70);
                      TFSInfo::SetItemName(this, (const TString *)theString);
                      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
                      goto LABEL_88;
                    }
                    CFStringRef PathComponent = CFURLCopyLastPathComponent(*((CFURLRef *)this + 1));
                    *(void *)&theString[0].char st_dev = PathComponent;
                    if (!PathComponent
                      || CFStringGetLength(PathComponent) < 1
                      || (IsEqual(*(const void **)&theString[0].st_dev, @"/") & 1) != 0)
                    {
                      TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)theString);
                      v70 = (TString *)v125;
                      goto LABEL_87;
                    }
                    TString::TString((TString *)&cf2, *(TString **)&theString[0].st_dev);
                    TFSInfo::SetItemName(this, (const TString *)&cf2);
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                    TCFURLInfo::StringProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E4F1D898], (TString *)&cf2);
                    TFSInfo::SetDisplayName(this, (const TString *)&cf2);
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                    TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)theString);
                  }
                }
LABEL_88:
                *((void *)this + 13) = 0;
                if ((*(_DWORD *)((char *)this + 115) & 0x20) != 0)
                {
                  if ((*(_DWORD *)((char *)this + 115) & 2) != 0)
                  {
                    if (*((unsigned char *)this + 112)
                      || (double CreationDate = TFSInfo::GetCreationDate(this), CreationDate != -534528000.0)
                      && CreationDate != -3061152000.0)
                    {
                      theString[0].char st_dev = 0;
                      LODWORD(cf2) = 0;
                      if (CFBundleGetPackageInfoInDirectory(*((CFURLRef *)this + 1), (UInt32 *)theString, (UInt32 *)&cf2))
                      {
                        int v74 = (int)cf2;
                        *((_DWORD *)this + 26) = theString[0].st_dev;
                        *((_DWORD *)this + 27) = v74;
                      }
                    }
                  }
                }
                else
                {
                  *(void *)&theString[0].char st_dev = 0;
                  if (CFURLCopyResourcePropertyForKey(*((CFURLRef *)this + 1), (CFStringRef)*MEMORY[0x1E4F1CDE0], theString, 0))
                  {
                    if (*(void *)&theString[0].st_dev)
                    {
                      if (CFDataGetLength(*(CFDataRef *)&theString[0].st_dev) == 32)
                      {
                        BytePtr = CFDataGetBytePtr(*(CFDataRef *)&theString[0].st_dev);
                        *((_DWORD *)this + 27) = *((_DWORD *)BytePtr + 1);
                        *((_DWORD *)this + 26) = *(_DWORD *)BytePtr;
                        if ((TFSInfo::HasLSProperties(this) & 1) == 0 && *((_DWORD *)this + 26) == 1095782476) {
                          *(_DWORD *)((char *)this + 115) |= 4u;
                        }
                      }
                    }
                  }
                  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)theString);
                }
                os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                unint64_t v75 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 30) & 1;
                os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                if ((v75 | v24 | v27) != 1)
                {
                  *(void *)&theString[0].char st_dev = &stru_1F2ABD380;
                  CFRetain(&stru_1F2ABD380);
                  TString::SetStringRefAsImmutable((TString *)theString, *((TString **)this + 3));
                  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                  int v82 = *(_DWORD *)((char *)this + 115);
                  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  if ((v82 & 8) != 0 && (TCFURLInfo::ShowAllExtensions(v83) & 1) == 0)
                  {
                    FileSuffix((const TString *)theString, (TString *)&cf2);
                    CFIndex v84 = CFStringGetLength(*(CFStringRef *)&theString[0].st_dev);
                    CFIndex v85 = CFStringGetLength((CFStringRef)cf2);
                    TString::SubString((TString *)theString, 0, v84 - v85, &v122);
                    TString::operator=((const void **)theString, (const void **)&v122.fString.fRef);
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v122.fString.fRef);
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                  }
                  ColonsToSlashes((const TString *)theString, (TString *)&cf2);
                  TFSInfo::SetDisplayName(this, (const TString *)&cf2);
                  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                  v86 = (const void **)theString;
                  goto LABEL_124;
                }
                CFTypeRef cf2 = 0;
                if (!CFURLCopyResourcePropertyForKey(*((CFURLRef *)this + 1), (CFStringRef)*MEMORY[0x1E4F1D718], &cf2, 0))
                {
                  CFTypeRef v115 = &stru_1F2ABD380;
                  CFRetain(&stru_1F2ABD380);
LABEL_117:
                  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&cf2);
                  if (CFStringGetLength((CFStringRef)v115))
                  {
                    v87 = (void)v125 ? (__CFString *)v125 : &stru_1F2ABD380;
                    if (!CFEqual(v115, v87)) {
                      TFSInfo::SetDisplayName(this, (const TString *)&v115);
                    }
                  }
                  v86 = &v115;
LABEL_124:
                  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v86);
                  if ((*(_DWORD *)((char *)this + 115) & 0x40) != 0
                    && !CFEqual(*((CFTypeRef *)this + 4), *((CFTypeRef *)this + 3)))
                  {
                    TFSInfo::SetDisplayName(this, (const TString *)this + 3);
                  }
                  if ((v121 & 2) != 0)
                  {
                    unint64_t v88 = *(_DWORD *)((char *)this + 115) & 0xFEFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
                    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFEFFFFFF | ((DWORD2(v125) > 1) << 24);
                    *(_WORD *)((char *)this + 119) = WORD2(v88);
                  }
                  if (TFSInfo::IsAlias(this) && v4 != 7)
                  {
                    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                    int v89 = *(_DWORD *)((char *)this + 115);
                    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                    if ((v89 & 0x40) == 0)
                    {
                      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                      int v90 = *(_DWORD *)((char *)this + 115);
                      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                      int v91 = *((unsigned __int8 *)this + 112);
                      if ((v90 & 0x40) == 0)
                      {
                        if (v91 == 21) {
                          int v92 = 0;
                        }
                        else {
                          int v92 = *((_DWORD *)this + 26);
                        }
                        BOOL v93 = v92 == 1717661793 || v92 == 1718643553;
                        int v94 = 2;
                        if (!v93) {
                          int v94 = 0;
                        }
                        unint64_t v95 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
                        *(_DWORD *)((char *)this + 115) = v94 | *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD;
                        *(_WORD *)((char *)this + 119) = WORD2(v95);
                      }
                      if (v91 == 21) {
                        int v96 = 0;
                      }
                      else {
                        int v96 = 4 * (*((_DWORD *)this + 26) == 1717661793);
                      }
                      unint64_t v97 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
                      *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | v96;
                      *(_WORD *)((char *)this + 119) = WORD2(v97);
                    }
                  }
                  double v98 = TFSInfo::GetCreationDate(this);
                  if (v98 == -534528000.0 || v98 == -3061152000.0)
                  {
                    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                    int v99 = *(_DWORD *)((char *)this + 115);
                    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                    if ((v99 & 0x20) != 0)
                    {
                      TCFURLInfo::SourcePathForResumableCopy((TString *)theString);
                      CFIndex v100 = CFStringGetLength(*(CFStringRef *)&theString[0].st_dev);
                      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
                      if (v100)
                      {
                        TFSInfo::Path(this, (CFTypeRef *)theString);
                        CFTypeRef cf2 = 0;
                        if (CFStringGetLength(*(CFStringRef *)&theString[0].st_dev))
                        {
                          v101 = (const char *)TString::c_str((TString *)theString);
                          v102 = (const char *)SourceInodeXattrName(0);
                          if (getxattr(v101, v102, &cf2, 8uLL, 0, 1) != -1
                            || (v103 = (const char *)TString::c_str((TString *)theString),
                                v104 = (const char *)SourceInodeXattrName(1),
                                getxattr(v103, v104, &cf2, 8uLL, 0, 1) != -1))
                          {
                            TFSInfo::SetIsResumableCopyTarget(this, 1);
                          }
                        }
                        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
                      }
                    }
                  }
                  if (cf) {
                    CFRelease(cf);
                  }
                  CFTypeRef cf = 0;
                  if ((*(_DWORD *)((char *)this + 115) & 0x100) != 0)
                  {
                    if (TCFURLInfo::VolumeIsAll(*((TCFURLInfo **)this + 1), (const __CFURL *)0x10000)) {
                      CFIndex v15 = 4294967253;
                    }
                    else {
                      CFIndex v15 = v15;
                    }
                  }
                  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                  int v105 = *(_DWORD *)((char *)this + 115);
                  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  if ((v105 & 0x20) == 0)
                  {
                    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                    *(_DWORD *)((char *)this + 115) |= 0x10000000u;
                    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  }
                  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
                  int v106 = *(_DWORD *)((char *)this + 115);
                  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
                  if ((v106 & 0x40) != 0)
                  {
                    unint64_t v107 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32) | 0x200020000;
                    *(_DWORD *)((char *)this + 115) |= 0x20000u;
                    *(_WORD *)((char *)this + 119) = WORD2(v107);
                  }
                  TFSInfo::SetIfSavedSearch(this);
                  if (*((unsigned char *)this + 112) != 21 && *((_DWORD *)this + 26) == 1651666795)
                  {
                    unint64_t v108 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFDFFFFFFFFFFLL | ((unint64_t)(*((_DWORD *)this + 27) == 1095779404) << 41);
                    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
                    *(_WORD *)((char *)this + 119) = WORD2(v108);
                  }
                  if (TFSInfo::GetCreationDate(this) == -534528000.0)
                  {
                    TFSInfo::Path(this, &cf2);
                    if (CFStringGetLength((CFStringRef)cf2)) {
                      CFIndex v15 = v15;
                    }
                    else {
                      CFIndex v15 = 4294959238;
                    }
                    if (!v15)
                    {
                      v109 = (const char *)TString::c_str((TString *)&cf2);
                      ssize_t v110 = getxattr(v109, "com.apple.progress.fractionCompleted", theString, 0x64uLL, 0, 0);
                      unint64_t v111 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFDFFFFFFFFFFLL;
                      *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
                      *(_WORD *)((char *)this + 119) = (v111 | ((unint64_t)(v110 != -1) << 41)) >> 32;
                      if (v110 >= 1)
                      {
                        v112 = (__CFString *)CFStringCreateWithBytes(0, (const UInt8 *)theString, v110, 0x8000100u, 0);
                        v122.fString.fRef = v112;
                        if (v112)
                        {
                          double DoubleValue = CFStringGetDoubleValue(v112);
                          TFSInfo::SetOperationFractionCompleted(this, DoubleValue);
                        }
                        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v122.fString.fRef);
                      }
                    }
                    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
                  }
                  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
                  goto LABEL_179;
                }
                v76 = (TString *)cf2;
                CFTypeRef v115 = &stru_1F2ABD380;
                CFRetain(&stru_1F2ABD380);
                TString::SetStringRefAsImmutable((TString *)&v115, v76);
                TString::TString((TString *)theString, "Downloads", 9uLL);
                LODWORD(v76) = CFEqual(v115, *(CFTypeRef *)&theString[0].st_dev);
                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
                if (!v76) {
                  goto LABEL_117;
                }
                TFSInfo::GetFPItem(this);
                v77 = (__CFString *)objc_claimAutoreleasedReturnValue();
                if (!v77)
                {
                  v78 = FPItemManagerInstance();
                  id v79 = *((id *)this + 2);
                  v122.fString.fRef = 0;
                  v77 = [v78 itemForURL:v79 error:&v122];
                  v80 = v122.fString.fRef;

                  if (!v77)
                  {
                    v81 = LogObj(4);
                    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                    {
                      theString[0].char st_dev = 138412290;
                      *(void *)&theString[0].st_mode = v80;
                      _os_log_impl(&dword_1D343E000, v81, OS_LOG_TYPE_ERROR, "Failed to get FPItem for Downloads: %@", (uint8_t *)theString, 0xCu);
                    }
                    goto LABEL_111;
                  }
                }
                v81 = [(__CFString *)v77 displayName];
                if (v115 != v81) {
                  TString::SetStringRefAsImmutable((TString *)&v115, (TString *)v81);
                }

                v80 = v77;
LABEL_111:

                goto LABEL_117;
              }
            }
            int v61 = 2048;
            goto LABEL_75;
          }
        }
        uint64_t v35 = 4;
        goto LABEL_52;
      }
    }
    TFSInfo::SetHasLSProperties(this, 1);
    goto LABEL_31;
  }
  uint64_t v13 = TFSInfo::GetFPItem(this);

  if (!v13) {
    return 4294959236;
  }
  return TFSInfo::FetchFPItemProperties(this);
}

void sub_1D344293C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va5, a3);
  va_start(va4, a3);
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  int v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v8 = va_arg(va3, const void *);
  va_copy(va4, va3);
  uint64_t v10 = va_arg(va4, const void *);
  uint64_t v12 = va_arg(va4, void);
  uint64_t v13 = va_arg(va4, void);
  va_copy(va5, va4);
  BOOL v14 = va_arg(va5, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va1);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)va2);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va3);
  _Unwind_Resume(a1);
}

void TString::SubString(TString *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, TString *a4@<X8>)
{
  CFIndex v6 = a2 & ~(a2 >> 63);
  CFIndex v7 = a3 + v6 - 1;
  CFIndex Length = CFStringGetLength(this->fString.fRef);
  if (Length - 1 < v7) {
    CFIndex v7 = Length - 1;
  }
  if (v7 >= v6)
  {
    CFIndex Length = CFStringGetCharacterAtIndex(this->fString.fRef, v6);
    if ((Length & 0xFC00) == 0xDC00) {
      ++v6;
    }
  }
  if (v7 >= v6)
  {
    CFIndex Length = CFStringGetCharacterAtIndex(this->fString.fRef, v7);
    v7 -= (Length & 0xFC00) == 55296;
  }
  if (v6 || (CFIndex Length = CFStringGetLength(this->fString.fRef), v7 != Length - 1))
  {
    if (v7 >= v6)
    {
      v12.length = v7 - v6 + 1;
      v12.location = v6;
      uint64_t v10 = (TString *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], this->fString.fRef, v12);
      int v11 = v10;
      a4->fString.fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(a4, v10);
      TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v11);
    }
    else
    {
      BOOL v9 = TString::KEmptyString((TString *)Length);
      a4->fString.fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(a4, (TString *)*v9);
    }
  }
  else
  {
    a4->fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a4, (TString *)this->fString.fRef);
  }
}

void sub_1D3442C88(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

TString *std::construct_at[abi:ne180100]<TString,TString const&,TString*>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *a2);
  return a1;
}

void sub_1D3442D38(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::Name(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  int v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  TFSInfo::GetNameWhileLocked(this, a2);
  os_unfair_lock_unlock(v4);
}

void sub_1D3442DA4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::GetNameWhileLocked(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  a2->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 3));
}

void sub_1D3442DF8(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TString::SetStringRefAsImmutable(TString *this, TString *a2)
{
  uint64_t v2 = this;
  if (!a2)
  {
    uint64_t v5 = &stru_1F2ABD380;
    goto LABEL_6;
  }
  unsigned __int16 IsMutable = TString::IsMutable(a2, (const __CFString *)a2);
  if (IsMutable >= 0x100u && !(_BYTE)IsMutable)
  {
    this = v2;
    uint64_t v5 = (__CFString *)a2;
LABEL_6:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, v5);
    return;
  }
  CFStringRef Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFStringRef)a2);
  if (v2->fString.fRef) {
    CFRelease(v2->fString.fRef);
  }
  v2->fString.fRef = (__CFString *)Copy;
}

uint64_t UseFileProviderFramework(void)
{
  unsigned __int8 v0 = atomic_load(sUseFileProviderFramework);
  return v0 & 1;
}

double TFSInfo::GetCreationDate(TFSInfo *this)
{
  double v1 = -6.31140768e10;
  if (*((unsigned char *)this + 112) != 34)
  {
    int v3 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    int v4 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock(v3);
    if ((v4 & 0x2000000) == 0)
    {
      if (*((unsigned __int8 *)this + 112) - 27 > 1)
      {
        double v1 = 0.0;
        TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
      }
      else
      {
        uint64_t v5 = TFSInfo::GetFPItem(this);
        CFIndex v6 = [v5 creationDate];

        if (v6) {
          double v1 = MEMORY[0x1D9435A50](v6);
        }
        else {
          double v1 = -6.31140768e10;
        }
      }
    }
  }
  return v1;
}

void sub_1D3442FDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::CopyPropertyValues(uint64_t a1)
{
  if (!a1) {
    return 4294959238;
  }
  v4[0] = 0;
  v4[1] = 0;
  if (_CFURLCopyResourcePropertyValuesAndFlags()) {
    CFIndex v2 = 0;
  }
  else {
    CFIndex v2 = TCFURLInfo::TranslateCFError(v4[0], v1);
  }
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)v4);
  return v2;
}

void sub_1D3443068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(const void **a1)
{
  CFIndex v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t TFSInfo::GetObjectIdentifier(TFSInfo *this)
{
  int v1 = TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
  uint64_t result = 0;
  if (!v1) {
    return 0;
  }
  return result;
}

const void **TFSInfo::SetItemName(TFSInfo *this, const TString *a2)
{
  int v3 = a2->fString.fRef;
  TString::TString((TString *)&theString, (const char *)[(__CFString *)v3 UTF8String]);

  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  CFIndex Length = CFStringGetLength(theString);
  uint64_t v5 = (TString *)((char *)this + 24);
  if (Length)
  {
    if (v5 != (TString *)&theString) {
      TString::SetStringRefAsImmutable(v5, (TString *)theString);
    }
  }
  else if (v5->fString.fRef != @"?")
  {
    TString::SetStringRefAsImmutable(v5, (TString *)@"?");
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1D34431E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  os_unfair_lock_unlock(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(const void **a1)
{
  CFIndex v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1D344329C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

id TFSInfo::GetFPItem(TFSInfo *this)
{
  CFIndex v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  id v3 = *((id *)this + 8);
  os_unfair_lock_unlock(v2);
  return v3;
}

void TFSInfo::SetDisplayName(TFSInfo *this, const TString *a2)
{
  int v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t v5 = a2->fString.fRef;
  CFIndex v6 = (const char *)[(__CFString *)v5 UTF8String];
  CFIndex v7 = (TString *)((char *)this + 32);
  TString::SetStringRefAsImmutable(v7, 0);
  if (v6)
  {
    CFIndex v8 = strlen(v6);
    TString::SetFromUTF8(v7, (const UInt8 *)v6, v8);
  }

  os_unfair_lock_unlock(v4);
}

void sub_1D3443404(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::SetIfSavedSearch(TFSInfo *this)
{
  {
    operator new();
  }
  if (!*((unsigned char *)this + 112))
  {
    TFSInfo::Name(this, &v12);
    BOOL v8 = TString::EndsWith(&v12, (const TString *)TFSInfo::SetIfSavedSearch(void)::kSavedSearchExtension)
      || *((unsigned char *)this + 112) != 21 && *((_DWORD *)this + 26) == 1936945525;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);
    CFIndex v2 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    unsigned int v10 = *(_DWORD *)((char *)this + 115);
    int v4 = (unsigned int *)((char *)this + 115);
    unint64_t v6 = v10 | ((unint64_t)*((unsigned __int16 *)v4 + 2) << 32);
    if (v8) {
      goto LABEL_5;
    }
LABEL_13:
    uint64_t v7 = 0;
    goto LABEL_14;
  }
  CFIndex v2 = (os_unfair_lock_s *)((char *)this + 100);
  id v3 = (os_unfair_lock_s *)((char *)this + 100);
  if (*((unsigned char *)this + 112) != 19)
  {
    os_unfair_lock_lock(v3);
    uint64_t v7 = 0;
    unsigned int v9 = *(_DWORD *)((char *)this + 115);
    int v4 = (unsigned int *)((char *)this + 115);
    unint64_t v6 = v9 | ((unint64_t)*((unsigned __int16 *)v4 + 2) << 32);
    goto LABEL_14;
  }
  os_unfair_lock_lock(v3);
  int v5 = *(_DWORD *)((char *)this + 115);
  int v4 = (unsigned int *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock(v2);
  unint64_t v6 = *v4 | ((unint64_t)*((unsigned __int16 *)v4 + 2) << 32);
  if ((v5 & 0x100) != 0) {
    goto LABEL_13;
  }
LABEL_5:
  uint64_t v7 = 0x4000000000;
LABEL_14:
  uint64_t v11 = v7 | v6 & 0xFFBFFFFFFFFFLL;
  unsigned int *v4 = v11;
  *((_WORD *)v4 + 2) = WORD2(v11);
  os_unfair_lock_unlock(v2);
}

void sub_1D34435AC(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

const void **TCFURLInfo::StringProperty@<X0>(TCFURLInfo *this@<X0>, const __CFString *a2@<X1>, TString *a3@<X8>)
{
  CFTypeRef propertyValueTypeRefPtr = 0;
  if (this)
  {
    CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0);
    int v5 = propertyValueTypeRefPtr;
  }
  else
  {
    int v5 = 0;
  }
  a3->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a3, v5);
  return TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
}

void sub_1D3443660(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

void std::deque<TString>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unsigned int v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)BOOL v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      unsigned int v38 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        BOOL v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      unsigned int v9 = (char *)a1[1];
    }
    BOOL v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &v54);
    char v44 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    unsigned int v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      char v48 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        BOOL v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        char v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)char v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        BOOL v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  unint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unsigned int v53 = operator new(0x1000uLL);
  std::__split_buffer<TNodeEventPtr *>::push_back(&v54, &v53);
  int v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1D3443950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__split_buffer<TNodeEventPtr *>::push_back(void *a1, void *a2)
{
  unint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(a1[4], v16);
      v19 = &v17[8 * (v16 >> 2)];
      int64_t v20 = (uint64_t *)a1[1];
      unint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        unint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        unint64_t v4 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        unint64_t v4 = (char *)a1[1];
      }
      uint64_t v15 = &v4[8 * v11];
      unint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;

  uint64_t v5 = (char *)a1[3];
  unint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    uint64_t v7 = (char *)a1[1];
    BOOL v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1) {
        uint64_t v18 = 1;
      }
      else {
        uint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      uint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      int v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }
    else
    {
      uint64_t v9 = v8 >> 3;
      uint64_t v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      int64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      unint64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }
      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(void *)uint64_t v6 = *a2;
  a1[2] += 8;
}

BOOL TCFURLInfo::VolumeIsAll(TCFURLInfo *this, const __CFURL *a2)
{
  return _CFURLGetVolumePropertyFlags() && a2 == 0;
}

void TString::TString(TString *this, TString *a2)
{
  this->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(this, a2);
}

void sub_1D3443B40(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void ColonsToSlashes(const TString *a1@<X0>, TString *a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!CFStringGetLength(a1->fString.fRef)) {
    goto LABEL_12;
  }
  CFStringRef v4 = (const __CFString *)RetainCF<__CFString const*>((const void **)&a1->fString.fRef);
  if (v4)
  {
    CFTypeRef v5 = CFAutorelease(v4);
    CFStringRef v4 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v5);
  }
  if (!CFStringGetCString(v4, buffer, 1024, 0x8000100u))
  {
LABEL_12:
    a2->fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, (TString *)a1->fString.fRef);
    return;
  }
  char v6 = 0;
  for (i = buffer; *i == 58; ++i)
  {
    char *i = 47;
    char v6 = 1;
LABEL_10:
    ;
  }
  if (*i) {
    goto LABEL_10;
  }
  if ((v6 & 1) == 0) {
    goto LABEL_12;
  }
  BOOL v8 = (TString *)CFStringCreateWithCString(0, buffer, 0x8000100u);
  uint64_t v9 = v8;
  a2->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9);
}

void sub_1D3443C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

const void **AppendPath@<X0>(const TString *a1@<X0>, const TString *a2@<X1>, TString *a3@<X8>)
{
  CFStringRef theString = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&theString, (TString *)a1->fString.fRef);
  if (CFStringGetLength(a2->fString.fRef))
  {
    if (CFStringGetLength(theString))
    {
      TString::TString(&v10, "/", 1uLL);
      BOOL v6 = TString::EndsWith((TString *)&theString, &v10);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
      if (!v6) {
        TString::Append((TString *)&theString, (const __CFString *)(unsigned __int16)TPathName::kPOSIXPathNameSeparator);
      }
    }
  }
  CFStringRef v7 = theString;
  a3->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v7);
  CFRelease(&stru_1F2ABD380);
  a3->fString.fRef = MutableCopy;
  TString::Append(a3, a2);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1D3443DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t std::deque<TString>::deque(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  CFStringRef v7 = (char *)(v5 + 8 * (v4 >> 9));
  if (v6 == v5)
  {
    BOOL v8 = 0;
    uint64_t v11 = 0;
    TString v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 9));
  }
  else
  {
    BOOL v8 = (TString **)(*(void *)v7 + 8 * (v4 & 0x1FF));
    unint64_t v9 = a2[5] + v4;
    TString v10 = (char *)(v5 + 8 * (v9 >> 9));
    uint64_t v11 = (TString **)(*(void *)v10 + 8 * (v9 & 0x1FF));
  }
  std::deque<TString>::__append<std::__deque_iterator<TString,TString const*,TString const&,TString const* const*,long,512l>,0>((void *)a1, v7, v8, v10, v11);
  return a1;
}

void sub_1D3443E90(_Unwind_Exception *a1)
{
  std::__split_buffer<TNodeEventPtr *>::~__split_buffer(v1);
  _Unwind_Resume(a1);
}

TString *std::deque<TString>::__append<std::__deque_iterator<TString,TString const*,TString const&,TString const* const*,long,512l>,0>(void *a1, char *a2, TString **a3, char *a4, TString **a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0;
  }
  else {
    unint64_t v5 = (((uint64_t)a5 - *(void *)a4) >> 3) + ((a4 - a2) << 6) - (((uint64_t)a3 - *(void *)a2) >> 3);
  }
  return std::deque<TString>::__append_with_size[abi:ne180100]<std::__deque_iterator<TString,TString const*,TString const&,TString const* const*,long,512l>>(a1, a2, a3, v5);
}

const void **TString::operator=(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a1, a2);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
  }
  return a1;
}

TString *TString::Append(TString *this, const __CFString *a2)
{
  UniChar chars = (unsigned __int16)a2;
  BOOL v3 = (__CFString *)TString::MutableRef(this, a2);
  CFStringAppendCharacters(v3, &chars, 1);
  return this;
}

{
  __CFString *v4;

  unint64_t v4 = (__CFString *)TString::MutableRef(this, a2);
  CFStringAppendCString(v4, (const char *)a2, 0x8000100u);
  return this;
}

void std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    unint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

unint64_t TFSInfo::HasLSProperties(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 30) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

const void **TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__deallocate_node(a1, *(id **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__deallocate_node(uint64_t a1, id *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

BOOL TNode::LowLevelIsLockFile(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  unint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock(v4);
  os_unfair_lock_lock(v5);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v5);
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  else
  {
    os_unfair_lock_unlock(v5);
  }
  BOOL v8 = (os_unfair_lock_s *)TNode::InfoLock(v7);
  os_unfair_lock_lock(v8);
  TString v10 = (TFSInfo *)*((void *)this + 2);
  unint64_t v9 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  BOOL IsLockFile = TFSInfo::LowLevelIsLockFile(v10);
  BOOL v12 = IsLockFile;
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  if (v12) {
    return 1;
  }
  int64_t v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLockFile);
  os_unfair_lock_lock(v14);
  uint64_t v16 = *((void *)this + 2);
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v14);
  uint64_t v17 = (os_unfair_lock_s *)(v16 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v16 + 100));
  int v18 = *(_DWORD *)(v16 + 115);
  os_unfair_lock_unlock(v17);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  if ((v18 & 0x100) == 0) {
    return 0;
  }
  TNode::GetVolumeInfo(this, &v20);
  if (*(unsigned char *)(v20 + 123)) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = *(unsigned __int8 *)(v20 + 128) != 0;
  }
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  }
  return v13;
}

void sub_1D34442D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL TNode::ReconcileInternalProperties(uint64_t a1, TFSInfo **a2, TNodeEventPtrs *a3, int a4)
{
  v137[0] = 0;
  v137[1] = 0;
  v136 = v137;
  BOOL v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v8);
  uint64_t v10 = *(void *)(a1 + 16);
  unint64_t v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  int v11 = TFSInfo::SynchronizeProperties((TFSInfo *)v10, a2, (uint64_t)&v136);
  TNodePtr::TNodePtr(&v138, (const TNode *)a1);
  TNodeEventPtrs::AddPropertyChanges(a3, &v138, &v136);

  if (!v11)
  {
    char v44 = TFSInfo::GetFPItem(*a2);
    if (!v44)
    {
LABEL_161:

      goto LABEL_162;
    }
    uint64_t v45 = TFSInfo::GetFPItem((TFSInfo *)v10);
    unint64_t v46 = (void *)v45;
    if (v45 && (void *)v45 != v44) {
      TFSInfo::SetFPItem((TFSInfo *)v10, (FPItem *)v44);
    }
LABEL_160:

    goto LABEL_161;
  }
  BOOL v13 = (os_unfair_lock_s *)TNode::InfoLock(v12);
  os_unfair_lock_lock(v13);
  uint64_t v15 = *(void *)(a1 + 16);
  int64_t v14 = *(std::__shared_weak_count **)(a1 + 24);
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v13);
  uint64_t v16 = (os_unfair_lock_s *)(v15 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v15 + 100));
  int v17 = *(_DWORD *)(v15 + 115);
  os_unfair_lock_unlock(v16);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  if ((v17 & 0x100) != 0)
  {
    int v18 = *a2;
    v19 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v19);
    LODWORD(v18) = *(_DWORD *)((char *)v18 + 115);
    os_unfair_lock_unlock(v19);
    if (((unsigned __int16)v18 & 0x100) == 0)
    {
      TGlobalNodes::RootNode((uint64_t *)&v140);
      TNode::StPopulating::StPopulating((TNode::StPopulating *)&v138, &v140, 0);
      uint64_t v20 = TNodeFromFINode(v140.fFINode);
      TNodePtr::TNodePtr((TNodePtr *)&v135, (const TNode *)a1);
      LODWORD(v20) = TChildrenList::RemoveChild(*(TChildrenList **)(v20 + 56), (const TNodePtr *)&v135);

      if (v20)
      {
        uint64_t v21 = (const TNode *)TNodeFromFINode(v140.fFINode);
        TNodePtr::TNodePtr((TNodePtr *)&v135, (const TNode *)a1);
        TNode::SendNotification(v21, 4, (id *)&v135, 0, 0);
      }
      TNode::StPopulating::~StPopulating(&v138.fFINode);
    }
  }
  if (!*((unsigned char *)*a2 + 112) && !TFSInfo::FileSystemObjectExists(*a2))
  {
    BOOL v47 = 0;
    if (!v9) {
      goto LABEL_175;
    }
    goto LABEL_174;
  }
  TNode::SetFSInfo(a1, (os_unfair_lock_s **)a2, a4);
  uint64_t v23 = (os_unfair_lock_s *)TNode::InfoLock(v22);
  os_unfair_lock_lock(v23);
  uint64_t v25 = *(void *)(a1 + 16);
  uint64_t v24 = *(std::__shared_weak_count **)(a1 + 24);
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v23);
  os_unfair_lock_lock((os_unfair_lock_t)(v25 + 100));
  int v26 = *(_DWORD *)(v25 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(v25 + 100));
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  if ((v26 & 0x100) != 0)
  {
    uint64_t v28 = v137[0];
    if (v137[0])
    {
      uint64_t v29 = v137;
      do
      {
        long long v30 = v28;
        long long v31 = v29;
        unsigned int v32 = *((_DWORD *)v28 + 7);
        if (v32 >= 0x706E616D) {
          uint64_t v29 = (void **)v28;
        }
        else {
          ++v28;
        }
        uint64_t v28 = (void *)*v28;
      }
      while (v28);
      if (v29 != v137)
      {
        if (v32 < 0x706E616D) {
          long long v30 = v31;
        }
        if (*((_DWORD *)v30 + 7) < 0x706E616Eu)
        {
          TGlobalNodes::RootNode((uint64_t *)&v140);
          TNode::StPopulating::StPopulating((TNode::StPopulating *)&v138, &v140, 0);
          uint64_t v33 = TNodeFromFINode(v140.fFINode);
          TChildrenList::InvalidateSortOrder(*(TChildrenList **)(v33 + 56));
          TNode::StPopulating::~StPopulating(&v138.fFINode);
        }
      }
    }
  }
  unint64_t v34 = (os_unfair_lock_s *)TNode::InfoLock(v27);
  os_unfair_lock_lock(v34);
  uint64_t v36 = *(void *)(a1 + 16);
  uint64_t v35 = *(std::__shared_weak_count **)(a1 + 24);
  if (v35) {
    atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v34);
  unint64_t v37 = (os_unfair_lock_s *)(v36 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v36 + 100));
  int v38 = *(_DWORD *)(v36 + 115);
  os_unfair_lock_unlock(v37);
  if (v35) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v35);
  }
  if ((v38 & 0x20) != 0)
  {
    uint64_t v40 = (os_unfair_lock_s *)TNode::InfoLock(NotifierList);
    os_unfair_lock_lock(v40);
    uint64_t v42 = *(void *)(a1 + 16);
    unint64_t v41 = *(std::__shared_weak_count **)(a1 + 24);
    if (v41)
    {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v40);
      int v43 = *(unsigned __int8 *)(v42 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v41);
      if (v43) {
        goto LABEL_68;
      }
    }
    else
    {
      os_unfair_lock_unlock(v40);
      if (*(unsigned char *)(v42 + 112)) {
        goto LABEL_68;
      }
    }
    char v48 = v137[0];
    if (v137[0])
    {
      uint64_t v49 = v137;
      uint64_t v50 = v137[0];
      do
      {
        char v51 = v50;
        uint64_t v52 = v49;
        unsigned int v53 = *((_DWORD *)v50 + 7);
        if (v53 >= 0x6F626A64) {
          uint64_t v49 = (void **)v50;
        }
        else {
          ++v50;
        }
        uint64_t v50 = (void *)*v50;
      }
      while (v50);
      if (v49 == v137)
      {
        long long v54 = v137;
      }
      else
      {
        if (v53 < 0x6F626A64) {
          char v51 = v52;
        }
        long long v54 = v137;
        if (*((_DWORD *)v51 + 7) < 0x6F626A65u)
        {
          TNode::HandleListeners((TNode *)a1, 256);
          TNode::HandleRecursiveListeners((TNode *)a1);
          goto LABEL_68;
        }
      }
      do
      {
        long long v55 = v48;
        unint64_t v56 = v54;
        unsigned int v57 = *((_DWORD *)v48 + 7);
        uint64_t v58 = v48 + 1;
        if (v57 >= 0x706E616D)
        {
          uint64_t v58 = v55;
          long long v54 = (void **)v55;
        }
        char v48 = (void *)*v58;
      }
      while (v48);
      if (v54 != v137)
      {
        char v59 = v57 >= 0x706E616D ? v55 : v56;
        if (*((_DWORD *)v59 + 7) < 0x706E616Eu)
        {
          NotifierList = (TNode *)TNode::GetNotifierList((TNode *)a1);
          int v60 = atomic_load((unsigned int *)NotifierList);
          if (v60 >= 1) {
            TNode::HandleListeners((TNode *)a1, 0);
          }
        }
      }
    }
  }
LABEL_68:
  int v61 = (os_unfair_lock_s *)TNode::ParentLock(NotifierList);
  os_unfair_lock_lock(v61);
  TNodePtr::TNodePtr(&v140, *(const TNode **)(a1 + 48));
  os_unfair_lock_unlock(v61);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)&v138, &v140, 0);
  int v62 = v137[0];
  if (v137[0])
  {
    int v63 = v137;
    do
    {
      CFStringRef v64 = v62;
      unint64_t v65 = v63;
      unsigned int v66 = *((_DWORD *)v62 + 7);
      int8x16_t v67 = v62 + 1;
      if (v66 >= 0x706E616D)
      {
        int8x16_t v67 = v64;
        int v63 = (void **)v64;
      }
      int v62 = (void *)*v67;
    }
    while (v62);
    if (v63 != v137)
    {
      if (v66 < 0x706E616D) {
        CFStringRef v64 = v65;
      }
      if (*((_DWORD *)v64 + 7) < 0x706E616Eu)
      {
        if (*(unsigned char *)(v10 + 112) == 21) {
          goto LABEL_78;
        }
        if (TNodeFromFINode(v140.fFINode))
        {
          uint64_t v69 = TNodeFromFINode(v140.fFINode);
          v70 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v69);
          os_unfair_lock_lock(v70);
          uint64_t v72 = *(void *)(v69 + 16);
          v71 = *(std::__shared_weak_count **)(v69 + 24);
          if (v71)
          {
            atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
            os_unfair_lock_unlock(v70);
            int v73 = *(unsigned __int8 *)(v72 + 112);
            std::__shared_weak_count::__release_shared[abi:ne180100](v71);
          }
          else
          {
            os_unfair_lock_unlock(v70);
            int v73 = *(unsigned __int8 *)(v72 + 112);
          }
          if (!v73)
          {
LABEL_78:
            uint64_t v68 = TNodeFromFINode(v140.fFINode);
            TChildrenList::InvalidateSortOrder(*(TChildrenList **)(v68 + 56));
          }
        }
      }
    }
  }
  TNode::StPopulating::~StPopulating(&v138.fFINode);

  int v74 = v137[0];
  if (v137[0])
  {
    unint64_t v75 = v137;
    do
    {
      v76 = v74;
      v77 = v75;
      unsigned int v78 = *((_DWORD *)v74 + 7);
      id v79 = v74 + 1;
      if (v78 >= 0x6D6F6464)
      {
        id v79 = v76;
        unint64_t v75 = (void **)v76;
      }
      int v74 = (void *)*v79;
    }
    while (v74);
    if (v75 != v137)
    {
      if (v78 < 0x6D6F6464) {
        v76 = v77;
      }
      if (*((_DWORD *)v76 + 7) < 0x6D6F6465u)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
        int v80 = *(_DWORD *)(v10 + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 100));
        if ((v80 & 0x40) != 0)
        {
          TNode::ClearAliasTarget((TNode *)a1, 1);
          v81 = *a2;
          int v82 = (os_unfair_lock_s *)((char *)*a2 + 100);
          os_unfair_lock_lock(v82);
          LODWORD(v81) = *(_DWORD *)((char *)v81 + 115);
          os_unfair_lock_unlock(v82);
          if ((v81 & 0x40) != 0)
          {
            v138.fFINode = 0;
            v139 = 0;
            TNodeRequest::Make();
          }
        }
      }
    }
    v83 = v137[0];
    if (v137[0])
    {
      CFIndex v84 = v137;
      do
      {
        CFIndex v85 = v83;
        v86 = v84;
        unsigned int v87 = *((_DWORD *)v83 + 7);
        unint64_t v88 = v83 + 1;
        if (v87 >= 0x6F726967)
        {
          unint64_t v88 = v85;
          CFIndex v84 = (void **)v85;
        }
        v83 = (void *)*v88;
      }
      while (v83);
      if (v84 != v137)
      {
        if (v87 < 0x6F726967) {
          CFIndex v85 = v86;
        }
        if (*((_DWORD *)v85 + 7) < 0x6F726968u)
        {
          int v89 = TFSInfo::OriginatorInfo(*a2);

          if (!v89)
          {
            int v91 = (os_unfair_lock_s *)TNode::InfoLock(v90);
            os_unfair_lock_lock(v91);
            uint64_t v93 = *(void *)(a1 + 16);
            int v92 = *(std::__shared_weak_count **)(a1 + 24);
            if (v92)
            {
              atomic_fetch_add_explicit(&v92->__shared_owners_, 1uLL, memory_order_relaxed);
              os_unfair_lock_unlock(v91);
              int v94 = *(unsigned __int8 *)(v93 + 112);
              std::__shared_weak_count::__release_shared[abi:ne180100](v92);
            }
            else
            {
              os_unfair_lock_unlock(v91);
              int v94 = *(unsigned __int8 *)(v93 + 112);
            }
            if (v94 == 7)
            {
              unint64_t v95 = *a2;
              int v96 = (os_unfair_lock_s *)((char *)*a2 + 100);
              os_unfair_lock_lock(v96);
              unsigned int v97 = *(_DWORD *)((char *)v95 + 115);
              unint64_t v95 = (TFSInfo *)((char *)v95 + 115);
              uint64_t v98 = *((unsigned __int16 *)v95 + 2);
              *(_DWORD *)unint64_t v95 = v97;
              *((_WORD *)v95 + 2) = ((v97 | (unint64_t)(v98 << 32)) & 0xFFFFDFFFFFFFFFFFLL) >> 32;
              os_unfair_lock_unlock(v96);
            }
            int v99 = TFSInfo::OriginatorInfo((TFSInfo *)v10);
            TFSInfo::SetTemporaryOriginatorInfo((uint64_t)*a2, v99);
          }
        }
      }
    }
  }
  if (TNode::VirtualType((TNode *)a1) == 27)
  {
    char v44 = TNode::GetFIProvider((TNode *)a1);
    unint64_t v46 = [v44 domain];
    if ([v44 isUsingFPFS])
    {
      TNode::UpdateOnDiskProviderRoot((TNode *)a1);
    }
    else
    {
      TNode::ProviderNodeForProviderDomain(v44, 0, (void **)&v135);
      if (TNodeFromFINode(v135))
      {
        uint64_t v100 = TNodeFromFINode(v135);
        TNode::HandleSync(v100, 0x88000u);
        v101 = v137[0];
        if (v137[0])
        {
          v102 = v137;
          do
          {
            v103 = v101;
            v104 = v102;
            unsigned int v105 = *((_DWORD *)v101 + 7);
            int v106 = v101 + 1;
            if (v105 >= 0x66706175)
            {
              int v106 = v103;
              v102 = (void **)v103;
            }
            v101 = (void *)*v106;
          }
          while (v101);
          if (v102 != v137)
          {
            if (v105 < 0x66706175) {
              v103 = v104;
            }
            if (*((_DWORD *)v103 + 7) < 0x66706176u && ([v46 needsAuthentication] & 1) == 0)
            {
              unint64_t v107 = (TNode *)TNodeFromFINode(v135);
              TNode::RecursiveSyncOfObserveNodes(v107);
            }
          }
          unint64_t v108 = v137[0];
          if (v137[0])
          {
            v109 = v137;
            ssize_t v110 = v137[0];
            do
            {
              unint64_t v111 = v110;
              v112 = v109;
              unsigned int v113 = *((_DWORD *)v110 + 7);
              if (v113 >= 0x6E746373) {
                v109 = (void **)v110;
              }
              else {
                ++v110;
              }
              ssize_t v110 = (void *)*v110;
            }
            while (v110);
            if (v109 != v137)
            {
              if (v113 < 0x6E746373) {
                unint64_t v111 = v112;
              }
              if (*((_DWORD *)v111 + 7) < 0x6E746374u) {
                goto LABEL_155;
              }
            }
            v114 = v137;
            CFTypeRef v115 = v137[0];
            do
            {
              v116 = v115;
              v117 = v114;
              unsigned int v118 = *((_DWORD *)v115 + 7);
              if (v118 >= 0x66706175) {
                v114 = (void **)v115;
              }
              else {
                ++v115;
              }
              CFTypeRef v115 = (void *)*v115;
            }
            while (v115);
            if (v114 != v137)
            {
              if (v118 < 0x66706175) {
                v116 = v117;
              }
              if (*((_DWORD *)v116 + 7) < 0x66706176u) {
                goto LABEL_155;
              }
            }
            v119 = v137;
            do
            {
              uint64_t v120 = v108;
              uint64_t v121 = v119;
              unsigned int v122 = *((_DWORD *)v108 + 7);
              v123 = v108 + 1;
              if (v122 >= 0x7046726D)
              {
                v123 = v120;
                v119 = (void **)v120;
              }
              unint64_t v108 = (void *)*v123;
            }
            while (v108);
            if (v119 != v137)
            {
              v124 = v122 >= 0x7046726D ? v120 : v121;
              if (*((_DWORD *)v124 + 7) < 0x7046726Eu)
              {
LABEL_155:
                LODWORD(v138.fFINode) = 1853121395;
                std::__tree<Property>::__erase_unique<Property>((uint64_t)&v136, (unsigned int *)&v138);
                LODWORD(v138.fFINode) = 1883665005;
                std::__tree<Property>::__erase_unique<Property>((uint64_t)&v136, (unsigned int *)&v138);
                long long v125 = (TNode *)TNodeFromFINode(v135);
                TNode::RecursiveChildrenAndSelf(v125, 1, &v138);
                fFINode = (FINode **)v138.fFINode;
                long long v127 = v139;
                while (fFINode != v127)
                {
                  long long v128 = (const TNode *)TNodeFromFINode(*fFINode);
                  TNode::SendNotification(v128, 2, (id *)fFINode++, 1969385844, 0);
                }
                v140.fFINode = (FINode *)&v138;
                std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v140);
              }
            }
          }
        }
      }
    }
    goto LABEL_160;
  }
LABEL_162:
  long long v129 = v137[0];
  if (!v137[0]) {
    goto LABEL_172;
  }
  long long v130 = v137;
  do
  {
    long long v131 = v129;
    long long v132 = v130;
    unsigned int v133 = *((_DWORD *)v129 + 7);
    if (v133 >= 0x6F626A64) {
      long long v130 = (void **)v129;
    }
    else {
      ++v129;
    }
    long long v129 = (void *)*v129;
  }
  while (v129);
  if (v130 == v137) {
    goto LABEL_172;
  }
  if (v133 < 0x6F626A64) {
    long long v131 = v132;
  }
  if (*((_DWORD *)v131 + 7) > 0x6F626A64u) {
LABEL_172:
  }
    long long v130 = v137;
  BOOL v47 = v130 != v137;
  if (v9) {
LABEL_174:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
LABEL_175:
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&v136, v137[0]);
  return v47;
}

void sub_1D3444DB4(_Unwind_Exception *a1, char a2, uint64_t a3, uint64_t a4, TPropertyValue *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void TNode::HandleSyncCompleted(uint64_t a1, int a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *(TFSInfo **)(a1 + 16);
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  char IsDatalessNow = TFSInfo::IsDatalessNow(v6);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  if (IsDatalessNow) {
    goto LABEL_59;
  }
  StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v40);
  if ((a2 & 0xC00000) == 0) {
    goto LABEL_12;
  }
  unint64_t v9 = (os_unfair_lock_s *)TNode::InfoLock(v8);
  os_unfair_lock_lock(v9);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 24);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v9);
  BOOL v12 = (os_unfair_lock_s *)(v11 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v11 + 100));
  int v13 = *(_DWORD *)(v11 + 115);
  os_unfair_lock_unlock(v12);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  if ((v13 & 0x20) != 0) {
    int v14 = TNode::IsPopulated((TNode *)a1) ^ 1;
  }
  else {
LABEL_12:
  }
    int v14 = 0;
  if (TNode::VirtualType((TNode *)a1) == 26) {
    int v15 = v14;
  }
  else {
    int v15 = 0;
  }
  if (v15 == 1)
  {
    uint64_t NotifierList = TNode::GetNotifierList((TNode *)a1);
    uint64_t v18 = *(void *)(NotifierList + 24);
    int v17 = *(std::__shared_weak_count **)(NotifierList + 32);
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_lock((os_unfair_lock_t)v18);
    id v19 = *(id *)(v18 + 8);
    os_unfair_lock_unlock((os_unfair_lock_t)v18);
    if (v17) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
    }
    int v14 = [v19 populated];
    if (v14)
    {
      uint64_t v20 = LogObj(4);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        Description(0x1Au, (TString *)&v39);
        id v21 = v39;
        *(_DWORD *)buf = 138543362;
        *(void *)&buf[4] = v21;
        _os_log_impl(&dword_1D343E000, v20, OS_LOG_TYPE_INFO, "Deferred All Providers Node open sync is now complete: %{public}@", buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39);
      }
    }
    else
    {
      if ((atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x20u) & 0x20) != 0)
      {
LABEL_29:

        goto LABEL_30;
      }
      uint64_t v20 = LogObj(4);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        Description(0x1Au, (TString *)&v39);
        id v22 = v39;
        *(_DWORD *)buf = 138543362;
        *(void *)&buf[4] = v22;
        _os_log_impl(&dword_1D343E000, v20, OS_LOG_TYPE_INFO, "Deferring All Providers Node open sync: %{public}@", buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39);
      }
    }

    goto LABEL_29;
  }
LABEL_30:
  unsigned int v23 = TNode::VirtualType((TNode *)a1);
  if (v14)
  {
    unsigned int v24 = v23;
    int v25 = ICloudDriveFPFSEnabled();
    if (v24 - 23 < 2) {
      int v26 = v25;
    }
    else {
      int v26 = 0;
    }
    if (v26 == 1)
    {
      int v27 = TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(a1 + 56));
      if (![v27 isPopulated])
      {
        if ((atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x20u) & 0x20) != 0)
        {
LABEL_57:

          goto LABEL_58;
        }
        uint64_t v36 = LogObj(4);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
        {
          Description(v24, (TString *)&v39);
          unint64_t v37 = TString::AsNSString((TString *)&v39);
          *(_DWORD *)buf = 138543362;
          *(void *)&buf[4] = v37;
          _os_log_impl(&dword_1D343E000, v36, OS_LOG_TYPE_INFO, "Deferring App Library Collection open sync: %{public}@", buf, 0xCu);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39);
        }
LABEL_56:

        goto LABEL_57;
      }
      uint64_t v28 = LogObj(4);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
      {
        Description(v24, (TString *)&v39);
        uint64_t v29 = TString::AsNSString((TString *)&v39);
        *(_DWORD *)buf = 138543362;
        *(void *)&buf[4] = v29;
        _os_log_impl(&dword_1D343E000, v28, OS_LOG_TYPE_INFO, "Deferred App Library Collection open sync is now complete: %{public}@", buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39);
      }
    }
    if (!TNode::IsFPv2((TNode *)a1, 1)) {
      goto LABEL_48;
    }
    int v27 = TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(a1 + 56));
    if ([v27 isPopulated])
    {
      long long v30 = LogObj(4);
      BOOL v31 = os_log_type_enabled(v30, OS_LOG_TYPE_INFO);
      if (v31)
      {
        unsigned int v32 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v31);
        os_unfair_lock_lock(v32);
        unint64_t v34 = *(TFSInfo **)(a1 + 16);
        uint64_t v33 = *(std::__shared_weak_count **)(a1 + 24);
        if (v33) {
          atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v32);
        TFSInfo::Name(v34, (TString *)&v39);
        if (v33) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v33);
        }
        uint64_t v35 = SanitizedStr((TString *)&v39);
        *(_DWORD *)buf = 138543362;
        *(void *)&buf[4] = v35;
        _os_log_impl(&dword_1D343E000, v30, OS_LOG_TYPE_INFO, "Deferred FPv2 open sync is now complete: %{public}@", buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39);
      }
LABEL_48:
      if ((atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x10u) & 0x10) == 0)
      {
        atomic_fetch_and((atomic_ushort *volatile)(a1 + 80), 0xFFDFu);
        StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v40);
        TNodePtr::TNodePtr((TNodePtr *)buf, (const TNode *)a1);
        TNode::SendNotification((const TNode *)a1, 8, (id *)buf, 0, 0);

        return;
      }
      goto LABEL_58;
    }
    if ((atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x20u) & 0x20) != 0) {
      goto LABEL_57;
    }
    uint64_t v36 = LogObj(4);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
    {
      TNode::Name((TNode *)a1, (TString *)&v39);
      int v38 = SanitizedStr((TString *)&v39);
      *(_DWORD *)buf = 138543362;
      *(void *)&buf[4] = v38;
      _os_log_impl(&dword_1D343E000, v36, OS_LOG_TYPE_INFO, "Deferring FPv2 open sync: %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39);
    }
    goto LABEL_56;
  }
LABEL_58:
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v40);
LABEL_59:
  TNodePtr::TNodePtr((TNodePtr *)buf, (const TNode *)a1);
}

void sub_1D3445510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, int a10, __int16 a11, char a12, char a13)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);

  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&a13);
  _Unwind_Resume(a1);
}

uint64_t TNode::VirtualType(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    uint64_t v5 = *(unsigned __int8 *)(v4 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    os_unfair_lock_unlock(v2);
    return *(unsigned __int8 *)(v4 + 112);
  }
  return v5;
}

id TNode::GetFIProvider(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 96));
  uint64_t v6 = *(void *)(v4 + 80);
  if (v6
    && (os_unfair_lock_lock((os_unfair_lock_t)(v6 + 72)),
        int v7 = *(unsigned __int8 *)(v6 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 72)),
        v7 == 1))
  {
    id v8 = *(id *)(v6 + 24);
  }
  else
  {
    id v8 = 0;
  }
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if (!v8)
  {
    uint64_t v10 = (os_unfair_lock_s *)TNode::ParentLock(v9);
    os_unfair_lock_lock(v10);
    TNodePtr::TNodePtr((TNodePtr *)&v25, *((const TNode **)this + 6));
    os_unfair_lock_unlock(v10);
    while (TNodeFromFINode((FINode *)v25))
    {
      uint64_t v11 = TNodeFromFINode((FINode *)v25);
      BOOL v12 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v11);
      os_unfair_lock_lock(v12);
      uint64_t v14 = *(void *)(v11 + 16);
      int v13 = *(std::__shared_weak_count **)(v11 + 24);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v12);
      int v15 = (os_unfair_lock_s *)(v14 + 96);
      os_unfair_lock_lock((os_unfair_lock_t)(v14 + 96));
      uint64_t v16 = *(void *)(v14 + 80);
      if (v16
        && (os_unfair_lock_lock((os_unfair_lock_t)(v16 + 72)),
            int v17 = *(unsigned __int8 *)(v16 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v16 + 72)),
            v17 == 1))
      {
        id v8 = *(id *)(v16 + 24);
      }
      else
      {
        id v8 = 0;
      }
      os_unfair_lock_unlock(v15);
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      }
      if (v8)
      {

        goto LABEL_30;
      }
      uint64_t v18 = TNodeFromFINode((FINode *)v25);
      id v19 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v18);
      os_unfair_lock_lock(v19);
      TNodePtr::TNodePtr(&v24, *(const TNode **)(v18 + 48));
      os_unfair_lock_unlock(v19);
      TNodePtr::operator=(&v25, (void **)&v24.fFINode);
    }
    uint64_t v20 = FINodeFromTNode(this);
    id v21 = [v20 _uiParent];

    if (v21)
    {
      while (1)
      {
        id v22 = objc_cast<FILocalStorageNode,FINode * {__strong}>(v21);

        if (v22) {
          break;
        }
        id v8 = [v21 _uiParent];

        id v21 = v8;
        if (!v8) {
          goto LABEL_30;
        }
      }
      {
        TString::TString((TString *)&TNode::GetFIProvider(void)const::kLocalStorageID, "com.apple.FileProvider.LocalStorage");
      }
      id v8 = +[FIProviderDomain providerDomainForID:TNode::GetFIProvider(void)const::kLocalStorageID cachePolicy:3 error:0];
    }
    else
    {
      id v8 = 0;
    }
  }
LABEL_30:
  return v8;
}

void sub_1D3445970(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int *TNode::ParentLock(TNode *this)
{
  {
    TNode::ParentLock(void)::sParentLock = 0;
  }
  return &TNode::ParentLock(void)::sParentLock;
}

uint64_t TNode::Compare(TNode *this, const TString *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *((void *)this + 2);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  if (v6)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    unint64_t v7 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
    os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 100));
    if ((v7 & 0x100000000) == 0)
    {
      if (*(unsigned char *)(v6 + 112))
      {
        if (*(unsigned char *)(v6 + 112) == 21)
        {
          TFSInfo::Name((TFSInfo *)v6, (TString *)&cf);
          if (cf && (v8 = CFRetain(cf), (unint64_t v9 = static_cf_cast<__CFString const*,void const*>(v8)) != 0))
          {
            CFTypeRef v10 = CFAutorelease(v9);
            CFStringRef v11 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v10);
          }
          else
          {
            CFStringRef v11 = 0;
          }
          int v15 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
          if (v15)
          {
            CFTypeRef v16 = CFAutorelease(v15);
            CFStringRef v17 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v16);
          }
          else
          {
            CFStringRef v17 = 0;
          }
          CFComparisonResult v14 = SpotlightStringCompare(v11, v17);
LABEL_21:
          uint64_t v12 = v14;
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          if (!v5) {
            return v12;
          }
          goto LABEL_11;
        }
      }
      else if (!TFSInfo::IsBootVolume((TFSInfo *)v6))
      {
        TFSInfo::Name((TFSInfo *)v6, (TString *)&cf);
        CFComparisonResult v14 = TString::StringCompare((TString *)&cf, a2);
        goto LABEL_21;
      }
      TFSInfo::DisplayName((TFSInfo *)v6, (TString *)&cf);
      CFComparisonResult v14 = TString::StringCompare((TString *)&cf, a2);
      goto LABEL_21;
    }
  }
  uint64_t v12 = -1;
  if (v5) {
LABEL_11:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  return v12;
}

void sub_1D3445B94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  _Unwind_Resume(a1);
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

int *TNode::InfoLock(TNode *this)
{
  {
    TNode::InfoLock(void)::sInfoLock = 0;
  }
  return &TNode::InfoLock(void)::sInfoLock;
}

CFComparisonResult TString::StringCompare(TString *this, const TString *a2)
{
  return CFStringCompare(this->fString.fRef, a2->fString.fRef, 0);
}

BOOL TFSInfo::IsBootVolume(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x100) == 0) {
    return 0;
  }
  TFSInfo::GetVolumeID(this, (void *)&v6 + 1);
  ROSPVolumeID::BootVolumeID(&v6);
  BOOL v4 = v6 == 0;
  if (*((void *)&v6 + 1) && (void)v6) {
    BOOL v4 = CFEqual(*((CFTypeRef *)&v6 + 1), (CFTypeRef)v6) != 0;
  }
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v6);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v6 + 1);
  return v4;
}

void sub_1D3445D50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

CFTypeRef ROSPVolumeID::BootVolumeID@<X0>(void *a1@<X8>)
{
  {
    ROSPVolumeID::BootVolumeID(void)::$_0::operator()();
  }
  CFTypeRef result = (CFTypeRef)ROSPVolumeID::BootVolumeID(void)::sBootDeviceID;
  *a1 = ROSPVolumeID::BootVolumeID(void)::sBootDeviceID;
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

void sub_1D3445E28(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<std::mutex>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<TFSInfo>::__on_zero_shared(uint64_t a1)
{
}

void StRegistrationLock::StRegistrationLock(StRegistrationLock *this)
{
  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock((TDSNotifier *)this);
  TDSMutex::lock(RegistrationLock);
}

void StRegistrationLock::~StRegistrationLock(TDSNotifier *this)
{
  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock(this);
  TDSMutex::unlock(RegistrationLock);
}

uint64_t TDSNotifier::GetRegistrationLock(TDSNotifier *this)
{
  {
    operator new();
  }
  return TDSNotifier::GetRegistrationLock(void)::gRegistrationLock;
}

void sub_1D3445F2C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x1000C40FA0F61DDLL);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<std::unordered_map<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::__on_zero_shared(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::~__hash_table(a1 + 24);
}

uint64_t std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__deallocate_node(a1, *(void ***)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__deallocate_node(uint64_t a1, void **a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      int v3 = (void **)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,0>(v2 + 2);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void *std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::__on_zero_shared(uint64_t a1)
{
  return std::__function::__value_func<void ()(__CFURL const*,FPItem *,NSError *)>::~__value_func[abi:ne180100]((void *)(a1 + 24));
}

uint64_t std::__shared_ptr_emplace<std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>::__on_zero_shared(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::~__hash_table(a1 + 24);
}

uint64_t std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      int v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

const void **std::__destroy_at[abi:ne180100]<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(unsigned char *)(a1 + 32)) {

  }
  if (*(unsigned char *)(a1 + 16)) {
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)a1);
  }
}

void std::__shared_ptr_emplace<TNodeTask>::__on_zero_shared(uint64_t a1)
{
}

void std::__destroy_at[abi:ne180100]<TNodeTask,0>(uint64_t a1)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)(a1 + 24));
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)(a1 + 8));
  uint64_t v2 = *(void **)a1;
}

void sub_1D3446178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **TRef<OpaqueNodeRef *,TRetainReleasePolicy<OpaqueNodeRef *>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

OpaqueNodeRef *NodeCopyParentNode(TNode *a1, OpaqueNodeRef *a2)
{
  id location = 0;
  uint64_t v2 = TNode::NodeFromNodeRef(a1, a2);
  BOOL v4 = (TNode *)TNode::Validate((TNode *)v2, v3);
  if (!v4)
  {
    uint64_t v5 = (os_unfair_lock_s *)TNode::ParentLock(v4);
    os_unfair_lock_lock(v5);
    TNodePtr::TNodePtr(&v20, *(const TNode **)(v2 + 48));
    os_unfair_lock_unlock(v5);
    TNodePtr::operator=(&location, (void **)&v20.fFINode);

    unint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
    os_unfair_lock_lock(v7);
    uint64_t v9 = *(void *)(v2 + 16);
    CFTypeRef v8 = *(std::__shared_weak_count **)(v2 + 24);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v7);
    CFTypeRef v10 = (os_unfair_lock_s *)(v9 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
    int v11 = *(_DWORD *)(v9 + 115);
    os_unfair_lock_unlock(v10);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    if ((v11 & 0x100) != 0)
    {
      TNode::GetSuperRootNode((uint64_t *)&obj, v12);
      TNode::StPopulating::StPopulating((TNode::StPopulating *)&v20, (const TNodePtr *)&obj, 0);
      uint64_t v14 = *(void *)(TNodeFromFINode((FINode *)obj) + 56);
      if (v14) {
        int v15 = (FINode ***)(v14 + 64);
      }
      else {
        int v15 = (FINode ***)&TNode::GetChildren(void)const::sEmptyList;
      }
      CFTypeRef v16 = *v15;
      CFStringRef v17 = v15[1];
      while (v16 != v17)
      {
        if (v2 == TNodeFromFINode(*v16))
        {
          objc_storeStrong(&location, obj);
          break;
        }
        ++v16;
      }
      TNode::StPopulating::~StPopulating((TNode::StPopulating *)&v20);
      fFINode = obj;
      goto LABEL_18;
    }
    if (TNode::IsFirmlink((TNode *)v2))
    {
      TNode::SecondParent((TNode *)v2, &v20);
      TNodePtr::operator=(&location, (void **)&v20.fFINode);
      fFINode = v20.fFINode;
LABEL_18:
    }
  }
  uint64_t v18 = TNodePtr::CopyAsNodeRef((TNodePtr *)&location);

  return v18;
}

void sub_1D3446394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

OpaqueNodeRef *TNodePtr::CopyAsNodeRef(TNodePtr *this)
{
  uint64_t v1 = [this->fFINode nodeRef];
  uint64_t v2 = v1;
  if (v1) {
    CFRetain(v1);
  }
  return v2;
}

uint64_t TNode::Validate(TNode *this, const TNode *a2)
{
  int v3 = (TNode *)TNode::WeakValidate(this, a2);
  if (v3) {
    return 4294959238;
  }
  uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock(v3);
  os_unfair_lock_lock(v5);
  uint64_t v6 = *((void *)this + 2);
  uint64_t v4 = 4294959238;
  if (v6)
  {
    unint64_t v7 = (os_unfair_lock_s *)(v6 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    unint64_t v8 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
    os_unfair_lock_unlock(v7);
    if ((v8 & 0x100000000) != 0) {
      uint64_t v4 = 4294959238;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  os_unfair_lock_unlock(v5);
  return v4;
}

{
  const TNode *v3;
  uint64_t vars8;

  if (TNode::WeakValidate(this, a2)) {
    return 4294959238;
  }
  return TNode::Validate(this, v3);
}

id objc_cast<FILocalStorageNode,FINode * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void sub_1D3446604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3446698(_Unwind_Exception *a1)
{
}

void sub_1D3446724(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

unint64_t TFSInfo::IsDatalessNow(TFSInfo *this)
{
  CFURLRef v1 = (const __CFURL *)*((void *)this + 1);
  if (!v1) {
    return 0;
  }
  CFURLRef v2 = CFURLCreateFilePathURL(0, v1, 0);
  CFURLRef v6 = v2;
  if (v2) {
    unint64_t v4 = ((unint64_t)TCFURLInfo::GetNumericalProperty(v2, (const __CFString *)*MEMORY[0x1E4F1CDC8], v3) >> 30) & 1;
  }
  else {
    unint64_t v4 = 0;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v6);
  return v4;
}

void sub_1D34467B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void std::__destroy_at[abi:ne180100]<std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,0>(void **a1)
{
  CFURLRef v2 = *a1;
}

void TFSInfo::TFSInfo(TFSInfo *this, FIProviderDomain *a2, FPItem *a3, int a4)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = a2;
  unint64_t v8 = a3;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  TFSInfo::TFSInfo(this);
  uint64_t v9 = [(FIProviderDomain *)v7 domain];
  if (!v9)
  {
    CFTypeRef v10 = [(FIProviderDomain *)v7 asyncFetchedDomain];

    if (!v10) {
      goto LABEL_5;
    }
    uint64_t v9 = [(FIProviderDomain *)v7 asyncFetchedDomain];
    uint64_t v11 = +[FIProviderDomain providerDomainForDomain:v9];

    unint64_t v7 = (FIProviderDomain *)v11;
  }

LABEL_5:
  uint64_t v12 = [(FIProviderDomain *)v7 domain];

  if (v12)
  {
    int v13 = [(FIProviderDomain *)v7 domain];
    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFE | [v13 isHidden] ^ 1;

    *((unsigned char *)this + 112) = 27;
    unint64_t v14 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFE7FF8FFFFFCFLL | 0x80070000020;
    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0x8FFFFFCF | 0x70000020;
    *(_WORD *)((char *)this + 119) = WORD2(v14);
    int v15 = [(FIProviderDomain *)v7 domain];
    ProviderDisplayName(v15, &v40);
  }
  else
  {
    unint64_t v16 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
    *((unsigned char *)this + 112) = 27;
    unint64_t v17 = v16 & 0xFFFFE7FF8FFFFFCELL | 0x80070000020;
    *(_DWORD *)((char *)this + 115) = v17 | 1;
    *(_WORD *)((char *)this + 119) = WORD2(v17);
    int v15 = [(FIProviderDomain *)v7 identifier];
    v40.fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v40, (TString *)v15);
  }
  TFSInfo::SetItemName(this, &v40);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40.fString.fRef);

  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t Overflow = TFSInfo::GetOrCreateOverflow(this);
  id v19 = (os_unfair_lock_s *)(Overflow + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(Overflow + 72));
  int v20 = *(unsigned __int8 *)(Overflow + 76);
  if (v20 == 2)
  {
    TFSInfoOverflow::MigrateToType(Overflow, 1);
    LOBYTE(v20) = *(unsigned char *)(Overflow + 76);
  }
  else if (v20 == 3)
  {
    LOBYTE(v20) = 1;
    *(unsigned char *)(Overflow + 76) = 1;
    *(void *)(Overflow + 32) = 0;
    *(_OWORD *)uint64_t Overflow = 0u;
    *(_OWORD *)(Overflow + 16) = 0u;
    *(_DWORD *)(Overflow + 32) = 0x80000000;
  }
  int v21 = v20;
  unint64_t v22 = Overflow & 0xFFFFFFFFFFFFFF00;
  uint64_t v23 = Overflow & 0xF8;
  os_unfair_lock_unlock(v19);
  if (v21 == 1) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = 0;
  }
  unint64_t v25 = v24 | v22;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  objc_storeStrong((id *)(v25 + 24), v7);
  if (!v8 && a4)
  {
    if (![(FIProviderDomain *)v7 expectFPItems]
      || (FPItemManagerInstance(),
          int v26 = objc_claimAutoreleasedReturnValue(),
          BOOL v27 = v26 == 0,
          v26,
          v27))
    {
      unint64_t v8 = 0;
    }
    else
    {
      uint64_t v28 = [(FIProviderDomain *)v7 domain];
      uint64_t v37 = 0x4014000000000000;
      uint64_t v41 = 0;
      TNode::RootFPItemForDomainWithTimeout(v28, (double *)&v37, (uint64_t)&v40, &v38);
      if (v39)
      {
        unint64_t v8 = 0;
      }
      else
      {
        unint64_t v8 = v38;
        int v38 = 0;
      }

      std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](&v40);
    }
  }
  if (v8 || !v12)
  {
    objc_storeStrong((id *)this + 8, v8);
    uint64_t v29 = [(FPItem *)v8 fileURL];
    if (!(v29 | v12))
    {
      if (![(FIProviderDomain *)v7 isUsingFPFS])
      {
        uint64_t v29 = 0;
LABEL_35:

        goto LABEL_36;
      }
      uint64_t v29 = [(FIProviderDomain *)v7 rootURL];
    }
    if (v29 && [(FIProviderDomain *)v7 isUsingFPFS])
    {
      CFURLRef v30 = CFURLCreateFileReferenceURL(0, (CFURLRef)v29, 0);
      BOOL v31 = (const void *)*((void *)this + 2);
      if (v31) {
        CFRelease(v31);
      }
      *((void *)this + 2) = v30;
    }
    goto LABEL_35;
  }
LABEL_36:
  unsigned int v32 = TFSInfo::FetchISIcon(this);
  uint64_t v33 = [v32 symbol];
  unint64_t v34 = v33;
  if (v33)
  {
    id v35 = v33;
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    uint64_t v36 = TFSInfo::GetOrCreateOverflow(this);
    TFSInfoOverflow::SetIFSymbol(v36, v35);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  }
}

void sub_1D3446C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100]((uint64_t *)va);

  TFSInfo::~TFSInfo(v5);
  _Unwind_Resume(a1);
}

void sub_1D3446EEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

TNode *NodeGetFIProviderDomain(TNode *a1, OpaqueNodeRef *a2)
{
  CFURLRef v2 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
  if (v2)
  {
    unint64_t v4 = v2;
    if (TNode::WeakValidate(v2, v3))
    {
      CFURLRef v2 = 0;
    }
    else
    {
      TNode::GetFIProvider(v4);
      CFURLRef v2 = (TNode *)objc_claimAutoreleasedReturnValue();
    }
  }
  return v2;
}

uint64_t TNode::NodeFromNodeRef(TNode *this, OpaqueNodeRef *a2)
{
  CFURLRef v2 = +[FINode nodeFromNodeRef:this];
  CFStringRef v3 = objc_cast<FIDSNode,FINode * {__strong}>(v2);

  uint64_t v4 = [v3 asTNode];
  return v4;
}

void sub_1D3447004(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id objc_cast<FIDSNode,FINode * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

uint64_t TNode::WeakValidate(TNode *this, const TNode *a2)
{
  if (this) {
    return 0;
  }
  else {
    return 4294959238;
  }
}

uint64_t TFSInfo::GetOrCreateOverflow(TFSInfo *this)
{
  uint64_t result = *((void *)this + 10);
  if (!result) {
    operator new();
  }
  return result;
}

void sub_1D34471E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);

  _Unwind_Resume(a1);
}

BOOL TFSInfo::LessThan(TFSInfo *this, TFSInfo **a2)
{
  v43[2] = *(TString *)MEMORY[0x1E4F143B8];
  if (*a2 == this) {
    return 0;
  }
  int v4 = *((unsigned __int8 *)this + 112);
  if (v4 == 25)
  {
    TFSInfo::GetFPItem(this);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    id v6 = [v5 itemIdentifier];
    unint64_t v7 = TFSInfo::GetFPItem(*a2);
    unint64_t v8 = [v7 itemIdentifier];
    uint64_t v9 = [v6 compare:v8];
    goto LABEL_4;
  }
  if ((v4 - 23) <= 1) {
    return v4 == 23;
  }
  if (v4 != 28)
  {
    if (v4 == 27)
    {
      uint64_t v11 = (os_unfair_lock_s *)((char *)this + 96);
      os_unfair_lock_lock((os_unfair_lock_t)this + 24);
      uint64_t v12 = *((void *)this + 10);
      if (v12
        && (os_unfair_lock_lock((os_unfair_lock_t)(v12 + 72)),
            int v13 = *(unsigned __int8 *)(v12 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 72)),
            v13 == 1))
      {
        id v5 = *(id *)(v12 + 24);
      }
      else
      {
        id v5 = 0;
      }
      os_unfair_lock_unlock(v11);
      unint64_t v22 = *a2;
      uint64_t v23 = (os_unfair_lock_s *)((char *)*a2 + 96);
      os_unfair_lock_lock(v23);
      uint64_t v24 = *((void *)v22 + 10);
      if (v24
        && (os_unfair_lock_lock((os_unfair_lock_t)(v24 + 72)),
            int v25 = *(unsigned __int8 *)(v24 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v24 + 72)),
            v25 == 1))
      {
        id v6 = *(id *)(v24 + 24);
      }
      else
      {
        id v6 = 0;
      }
      os_unfair_lock_unlock(v23);
      if (!v5 && v6)
      {
        BOOL v10 = 1;
        goto LABEL_5;
      }
      if (!v6)
      {
        BOOL v10 = 0;
        goto LABEL_5;
      }
      unint64_t v7 = [v5 identifier];
      unint64_t v8 = [v6 identifier];
      uint64_t v9 = [v7 compare:v8];
LABEL_4:
      BOOL v10 = v9 == 1;

LABEL_5:
      return v10;
    }
    TFSInfo::Name(this, &v41);
    TFSInfo::Name(*a2, &v39);
    CFComparisonResult v17 = TString::StringCompare(&v41, &v39);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v41.fString.fRef);
    if (v17 == kCFCompareLessThan) {
      return 1;
    }
    if (v17 == kCFCompareEqualTo)
    {
      unint64_t VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
      unint64_t v19 = TFSInfo::GetVolumeIdentifier(*a2);
      if (VolumeIdentifier != v19) {
        return VolumeIdentifier < v19;
      }
      unint64_t ObjectIdentifier = TFSInfo::GetObjectIdentifier(this);
      return ObjectIdentifier > TFSInfo::GetObjectIdentifier(*a2);
    }
    return 0;
  }
  unint64_t v14 = TFSInfo::GetFPItem(this);
  uint64_t v15 = TFSInfo::GetFPItem(*a2);
  unint64_t v16 = (void *)v15;
  if (v14 || !v15)
  {
    if (v15)
    {
      TFSInfo::Name(this, &v38);
      TFSInfo::Name(*a2, &v37);
      std::pair<TString,TString>::pair[abi:ne180100]<TString,TString,0>((CFTypeRef *)&v41.fString.fRef, (CFTypeRef *)&v38.fString.fRef, (CFTypeRef *)&v37.fString.fRef);
      id v36 = [v14 providerDomainID];
      id v35 = [v16 providerDomainID];
      std::pair<TString,TString>::pair[abi:ne180100]<NSString * {__strong},NSString * {__strong},0>(&v42, &v36, &v35);
      int v26 = [v14 itemID];
      id v34 = [v26 identifier];
      BOOL v27 = [v16 itemID];
      id v33 = [v27 identifier];
      std::pair<TString,TString>::pair[abi:ne180100]<NSString * {__strong},NSString * {__strong},0>(v43, &v34, &v33);
      std::vector<std::pair<TString,TString>>::vector[abi:ne180100]((uint64_t)&v39, (TString **)&v41, 3uLL);
      uint64_t v28 = 6;
      do
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40[v28 + 1]);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40[v28]);
        v28 -= 2;
      }
      while (v28 * 8);

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v37.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);
      fRef = (TString *)v39.fString.fRef;
      CFURLRef v30 = (TString *)v40[0];
      while (1)
      {
        if (fRef == v30)
        {
LABEL_41:
          BOOL v10 = 0;
          goto LABEL_46;
        }
        BOOL v31 = fRef + 1;
        CFComparisonResult v32 = TString::StringCompare(fRef, fRef + 1);
        if (v32 == kCFCompareLessThan) {
          break;
        }
        if (v32 == kCFCompareGreaterThan) {
          goto LABEL_41;
        }
        fRef = v31 + 1;
      }
      BOOL v10 = 1;
LABEL_46:
      v41.fString.fRef = (__CFString *)&v39;
      std::vector<std::pair<TString,TString>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v41);
    }
    else
    {
      BOOL v10 = 0;
    }
  }
  else
  {
    BOOL v10 = 1;
  }

  return v10;
}

void sub_1D3447708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D344794C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3447AD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ProviderDisplayName(FPProviderDomain *a1@<X0>, TString *a2@<X8>)
{
  CFStringRef v3 = [(FPProviderDomain *)a1 domainFullDisplayName];
  a2->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, v3);
}

void sub_1D3447B70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v10);

  _Unwind_Resume(a1);
}

id TFSInfo::FetchISIcon(TFSInfo *this)
{
  id v2 = TFSInfo::GetISIcon(this);
  if (!v2)
  {
    uint64_t v9 = this;
    if (TFSInfo::IsFPv2(this, 1))
    {
      CFStringRef v3 = TFSInfo::ISIconRefFromTypeInfo(this);
      id v2 = TFSInfo::FetchISIcon(void)const::$_0::operator()(&v9, v3);

LABEL_13:
      TFSInfo::SetISIcon((uint64_t)this, v2);
      goto LABEL_14;
    }
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    int v4 = (const void *)*((void *)this + 2);
    unint64_t v8 = v4;
    if (v4)
    {
      CFRetain(v4);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      if (!*((unsigned char *)this + 112) || *((unsigned char *)this + 112) == 7)
      {
        if (((*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0x400000000) != 0)
        {
          id v5 = TFSInfo::ISIconRefFromTypeInfo(this);
        }
        else
        {
          id v5 = (void *)[objc_alloc(MEMORY[0x1E4F6F248]) initWithURL:v8];
        }
        id v6 = v5;
        id v2 = TFSInfo::FetchISIcon(void)const::$_0::operator()(&v9, v5);

        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v8);
        goto LABEL_13;
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    }
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v8);
    id v2 = 0;
  }
LABEL_14:
  return v2;
}

void sub_1D3447CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL TNode::IsFPv2(TNode *this, int a2)
{
  int v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  id v6 = (TFSInfo *)*((void *)this + 2);
  id v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  IsFPid v2 = TFSInfo::IsFPv2(v6, a2);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return IsFPv2;
}

void sub_1D3447DA0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL TFSInfo::IsFPv2(TFSInfo *this, int a2)
{
  int v2 = *((unsigned __int8 *)this + 112);
  if (!a2 || v2 != 27) {
    return v2 == 28;
  }
  int v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t v5 = *((void *)this + 10);
  if (v5
    && (os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72)),
        int v6 = *(unsigned __int8 *)(v5 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72)),
        v6 == 1))
  {
    id v7 = *(id *)(v5 + 24);
  }
  else
  {
    id v7 = 0;
  }
  os_unfair_lock_unlock(v4);
  uint64_t v8 = [v7 isFPv2];

  return v8;
}

void sub_1D3447E60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::IsFirmlink(TNode *this)
{
  unsigned int v1 = atomic_load((unsigned __int16 *)this + 40);
  return (v1 >> 1) & 1;
}

BOOL IsExternalDeviceDomainID(const TString *this)
{
  {
    TString::TString(&IsExternalDeviceDomainID(TString const&)::kUSBDomainID, "com.apple.filesystems.UserFS.FileProvider", 0x29uLL);
  }
  {
    TString::TString(&IsExternalDeviceDomainID(TString const&)::kSMBDomainID, "com.apple.SMBClientProvider.FileProvider", 0x28uLL);
  }
  if (TString::BeginsWith((TString *)this, &IsExternalDeviceDomainID(TString const&)::kUSBDomainID)) {
    return 1;
  }
  return TString::BeginsWith((TString *)this, &IsExternalDeviceDomainID(TString const&)::kSMBDomainID);
}

void sub_1D3447F70(_Unwind_Exception *a1)
{
}

void TNode::SetFSInfo(uint64_t a1, os_unfair_lock_s **a2, int a3)
{
  int v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v6);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = (os_unfair_lock_s *)(v7 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v7 + 100));
  LODWORD(v7) = *(_DWORD *)(v7 + 115);
  os_unfair_lock_unlock(v8);
  if ((v7 & 0x100) != 0
    && (uint64_t v9 = *a2,
        BOOL v10 = *a2 + 25,
        os_unfair_lock_lock(v10),
        LODWORD(v9) = *(os_unfair_lock_s *)((char *)v9 + 115),
        os_unfair_lock_unlock(v10),
        ((unsigned __int16)v9 & 0x8000) != 0))
  {
    os_unfair_lock_unlock(v6);
    uint64_t v11 = 0;
  }
  else
  {
    int v58 = a3;
    TFSInfo::GetFPItem(*(TFSInfo **)(a1 + 16));
    uint64_t v11 = (FPItem *)objc_claimAutoreleasedReturnValue();
    uint64_t v12 = *(void *)(a1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
    int v13 = *(_DWORD *)(v12 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 100));
    uint64_t v14 = *(void *)(a1 + 16);
    uint64_t v15 = (os_unfair_lock_s *)(v14 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
    int v16 = *(_DWORD *)(v14 + 115);
    os_unfair_lock_unlock(v15);
    uint64_t v17 = *(void *)(a1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(v17 + 100));
    int v18 = *(_DWORD *)(v17 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 100));
    if ((v18 & 0x2000000) != 0)
    {
      BOOL v20 = 0;
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v17 + 100));
      int v19 = *(_DWORD *)(v17 + 115);
      os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 100));
      BOOL v20 = (v19 & 0x10000000) != 0 || *(unsigned __int8 *)(v17 + 112) == 7;
    }
    TFSInfo::DisplayName(*(TFSInfo **)(a1 + 16), &v62);
    uint64_t v61 = 0;
    uint64_t v21 = *(void *)(a1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(v21 + 96));
    uint64_t v22 = *(void *)(v21 + 80);
    if (v22) {
      TFSInfoOverflow::TakeFolderSizeRecord(v22, &v61);
    }
    else {
      uint64_t v61 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v21 + 96));
    int v60 = 0;
    if ((v13 & 0x20000000) != 0)
    {
      uint64_t v23 = *(void *)(a1 + 16);
      os_unfair_lock_lock((os_unfair_lock_t)(v23 + 96));
      uint64_t v24 = *(const void ***)v23;
      *(void *)uint64_t v23 = 0;
      int v25 = v60;
      int v60 = v24;
      if (v25) {
        std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v60, v25);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v23 + 96));
    }
    uint64_t v26 = *(void *)(a1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(v26 + 100));
    uint64_t v27 = *(unsigned __int16 *)(v26 + 119);
    os_unfair_lock_unlock((os_unfair_lock_t)(v26 + 100));
    uint64_t v29 = (TFSInfo *)*a2;
    uint64_t v28 = a2[1];
    if (v28) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)&v28[2], 1uLL, memory_order_relaxed);
    }
    CFURLRef v30 = *(std::__shared_weak_count **)(a1 + 24);
    *(void *)(a1 + 16) = v29;
    *(void *)(a1 + 24) = v28;
    if (v30)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v30);
      uint64_t v29 = *(TFSInfo **)(a1 + 16);
    }
    os_unfair_lock_lock((os_unfair_lock_t)v29 + 25);
    int v31 = *(_DWORD *)((char *)v29 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)v29 + 25);
    if ((v31 & 0x20) != 0 && !*(void *)(a1 + 56)) {
      operator new();
    }
    if (v61)
    {
      uint64_t v32 = *(void *)(a1 + 16);
      os_unfair_lock_lock((os_unfair_lock_t)(v32 + 96));
      if (v61 || *(void *)(v32 + 80))
      {
        uint64_t Overflow = TFSInfo::GetOrCreateOverflow((TFSInfo *)v32);
        TFSInfoOverflow::SetFolderSizeRecord(Overflow, &v61);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v32 + 96));
      uint64_t v34 = *(void *)(a1 + 16);
      id v35 = (os_unfair_lock_s *)(v34 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v34 + 100));
      int v36 = *(_DWORD *)(v34 + 115);
      v34 += 115;
      unint64_t v37 = v36 & 0xF7FFFFFF | ((unint64_t)*(unsigned __int16 *)(v34 + 4) << 32);
      *(_DWORD *)uint64_t v34 = v36 & 0xF7FFFFFF | v16 & 0x8000000;
      *(_WORD *)(v34 + 4) = WORD2(v37);
      os_unfair_lock_unlock(v35);
      uint64_t v38 = *(void *)(a1 + 16);
      TString v39 = (os_unfair_lock_s *)(v38 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v38 + 100));
      unsigned int v41 = *(_DWORD *)(v38 + 115);
      uint64_t v40 = v38 + 115;
      unint64_t v42 = v41 | ((unint64_t)*(unsigned __int16 *)(v40 + 4) << 32);
      int v43 = 0x10000000;
      if (!v20) {
        int v43 = 0;
      }
      unint64_t v44 = v42 & 0xFFFFFFFFEFFFFFFFLL;
      *(_DWORD *)uint64_t v40 = v44 | v43;
      *(_WORD *)(v40 + 4) = WORD2(v44);
      os_unfair_lock_unlock(v39);
    }
    if (v60)
    {
      uint64_t v45 = *(void *)(a1 + 16);
      os_unfair_lock_lock((os_unfair_lock_t)(v45 + 96));
      unint64_t v46 = v60;
      int v60 = 0;
      BOOL v47 = *(const void ***)v45;
      *(void *)uint64_t v45 = v46;
      if (v47) {
        std::default_delete<TVersionData>::operator()[abi:ne180100](v45, v47);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v45 + 96));
    }
    uint64_t v48 = *(void *)(a1 + 16);
    uint64_t v49 = (os_unfair_lock_s *)(v48 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v48 + 100));
    unsigned int v50 = *(_DWORD *)(v48 + 115);
    v48 += 115;
    uint64_t v51 = *(unsigned __int16 *)(v48 + 4);
    *(_DWORD *)uint64_t v48 = v50;
    *(_WORD *)(v48 + 4) = ((v50 | (unint64_t)(v51 << 32)) & 0xFFFFFFF7FFFFFFFFLL | (v27 << 32) & 0x800000000) >> 32;
    os_unfair_lock_unlock(v49);
    uint64_t v52 = *(void *)(a1 + 16);
    if (*(unsigned char *)(v52 + 112) == 18)
    {
      TFSInfo::DisplayName((TFSInfo *)v52, (TString *)&theString);
      CFIndex Length = CFStringGetLength(theString);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      if (!Length) {
        TFSInfo::SetDisplayName(*(TFSInfo **)(a1 + 16), &v62);
      }
    }
    long long v54 = v60;
    int v60 = 0;
    if (v54) {
      std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&v60, v54);
    }
    uint64_t v55 = v61;
    uint64_t v61 = 0;
    if (v55) {
      MEMORY[0x1D9436740](v55, 0x1000C40E0EAB150);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v62.fString.fRef);
    os_unfair_lock_unlock(v6);
    if (v11 && v58)
    {
      unint64_t v56 = TFSInfo::GetFPItem((TFSInfo *)*a2);
      if (!v56)
      {
        unsigned int v57 = TNode::GetFIProvider((TNode *)a1);

        if (v57) {
          TFSInfo::SetFPItem((TFSInfo *)*a2, v11);
        }
      }
    }
  }
}

void sub_1D3448450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v9 = va_arg(va1, const void **);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v7 = v9;
  uint64_t v9 = 0;
  if (v7) {
    std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)va, v7);
  }
  uint64_t v8 = v11;
  uint64_t v11 = 0;
  if (v8) {
    MEMORY[0x1D9436740](v8, 0x1000C40E0EAB150);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);

  os_unfair_lock_unlock(v5);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::LowLevelIsLockFile(TFSInfo *this)
{
  if (*((unsigned char *)this + 112)) {
    return 0;
  }
  if (*((_DWORD *)this + 26) == 1651666795) {
    return 1;
  }
  return TFSInfo::GetCreationDate(this) == -534528000.0;
}

BOOL TFSInfo::FileSystemObjectExists(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  CFStringRef v3 = (void *)*((void *)this + 2);
  uint64_t v7 = v3;
  if (v3) {
    CFRetain(v3);
  }
  os_unfair_lock_unlock(v2);
  int v4 = [v3 path];
  BOOL v5 = [v4 length] != 0;

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v7);
  return v5;
}

void sub_1D34485DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v11 = v10;
  os_unfair_lock_unlock(v11);
  _Unwind_Resume(a1);
}

void TNode::HandleListeners(TNode *a1, int a2)
{
  TNode::GetVolumeInfo(a1, &v5);
  if (v5) {
    TFSVolumeInfo::InvalidateFreeSpaceAndCapacityOfContainer(v5);
  }
  TNode::RequestSynchronize(a1, a2);
  int v4 = v6;
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_1D3448688(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void TFSVolumeInfo::InvalidateFreeSpaceAndCapacityOfContainer(TFSVolumeInfo *this)
{
  if (*((unsigned char *)this + 32))
  {
    uint64_t VolumeMap = GetVolumeMap();
    VolumeInfoLock();
    os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
    CFStringRef v3 = *(uint64_t **)(VolumeMap + 16);
    if (v3)
    {
      while (1)
      {
        int v4 = (const void *)v3[2];
        uint64_t v15 = v4;
        if (v4) {
          CFRetain(v4);
        }
        char v16 = *((unsigned char *)v3 + 24);
        BOOL v5 = (std::__shared_weak_count *)v3[5];
        uint64_t v17 = (unsigned __int8 *)v3[4];
        int v18 = v5;
        if (!v5) {
          goto LABEL_30;
        }
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        if (!v18) {
          goto LABEL_30;
        }
        int v6 = std::__shared_weak_count::lock(v18);
        if (v6) {
          break;
        }
LABEL_28:
        if (v18) {
          std::__shared_weak_count::__release_weak(v18);
        }
LABEL_30:
        TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v15);
        CFStringRef v3 = (uint64_t *)*v3;
        if (!v3) {
          goto LABEL_31;
        }
      }
      uint64_t v7 = v6;
      uint64_t v8 = (os_unfair_lock_s *)v17;
      if (v17 && v17[32])
      {
        uint64_t v9 = v17[23];
        if ((v9 & 0x80u) == 0) {
          uint64_t v10 = v17[23];
        }
        else {
          uint64_t v10 = *((void *)v17 + 1);
        }
        uint64_t v11 = *((unsigned __int8 *)this + 23);
        int v12 = (char)v11;
        if ((v11 & 0x80u) != 0) {
          uint64_t v11 = *((void *)this + 1);
        }
        if (v10 == v11)
        {
          if (v12 >= 0) {
            int v13 = this;
          }
          else {
            int v13 = *(TFSVolumeInfo **)this;
          }
          if ((v9 & 0x80) == 0)
          {
            if (v17[23])
            {
              uint64_t v14 = v17;
              while (*v14 == *(unsigned char *)v13)
              {
                ++v14;
                int v13 = (TFSVolumeInfo *)((char *)v13 + 1);
                if (!--v9) {
                  goto LABEL_26;
                }
              }
              goto LABEL_27;
            }
            goto LABEL_26;
          }
          if (!memcmp(*(const void **)v17, v13, *((void *)v17 + 1)))
          {
LABEL_26:
            os_unfair_lock_lock(v8 + 78);
            HIBYTE(v8[32]._os_unfair_lock_opaque) = 0;
            os_unfair_lock_unlock(v8 + 78);
          }
        }
      }
LABEL_27:
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
      goto LABEL_28;
    }
LABEL_31:
    os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 78);
    *((unsigned char *)this + 131) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
  }
}

void sub_1D3448850(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_emplace<std::vector<TNodePtr>>::__on_zero_shared(uint64_t a1)
{
  unsigned int v1 = (void **)(a1 + 24);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v1);
}

id TFSInfo::FetchISIcon(void)const::$_0::operator()(TFSInfo **a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    TFSInfo::GetFPItem(*a1);
    int v4 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
    __int16 v6 = TFSInfo::FPItemPermissionRestrictions(v4, v5);

    if ((v6 & 0x800) != 0)
    {
      uint64_t v7 = [v3 decorations];
      IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::NSForwardIterator<objc_object  {objcproto16ISIconDecoration}*>::NSForwardIterator((uint64_t)&v24, v7);
      IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::IDContainerIteratorAdaptor((uint64_t)v23, -1, v7);
      uint64_t v8 = (void *)*MEMORY[0x1E4F6F278];
      while (v24 != v23[0] || v29 != v23[16])
      {
        id v9 = *(id *)(v25[1] + 8 * v28);
        DecorationIdentifier(v9, &v30);
        char v10 = operator==((void **)&v30.fString.fRef, v8);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v30.fString.fRef);

        if (v10) {
          break;
        }
        uint64_t v11 = v28;
        if (v28 >= v27 - 1)
        {
          uint64_t v12 = [v24 countByEnumeratingWithState:v25 objects:v26 count:4];
          uint64_t v11 = -1;
          uint64_t v27 = v12;
          uint64_t v28 = -1;
        }
        if (v26[4] != *(void *)v25[2])
        {
          objc_enumerationMutation(v24);
          uint64_t v11 = v28;
        }
        uint64_t v28 = v11 + 1;
        ++v29;
      }
      IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::NSForwardIterator<objc_object  {objcproto16ISIconDecoration}*>::NSForwardIterator((uint64_t)v22, (uint64_t)&v24);

      IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::IDContainerIteratorAdaptor((uint64_t)&v24, -1, v7);
      if (v22[0] == v24)
      {
        id v13 = v22[16];
        id v14 = v29;

        if (v13 == v14)
        {

          id v15 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
          char v16 = [v3 decorations];
          [v15 addObjectsFromArray:v16];

          uint64_t v17 = (void *)[objc_alloc(MEMORY[0x1E4F6F250]) initWithType:v8];
          [v15 addObject:v17];
          id v18 = [v3 iconWithDecorations:v15];

          goto LABEL_18;
        }
      }
      else
      {
      }
      id v19 = v22[0];
      id v20 = *((id *)v22[2] + (uint64_t)v22[15]);
    }
  }
  id v18 = v3;
LABEL_18:

  return v18;
}

void sub_1D3448B1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TFSInfo::SetISIcon(uint64_t a1, void *a2)
{
  id v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  int v4 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = v3;

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
}

void TFSInfoOverflow::TakeFolderSizeRecord(uint64_t a1, uint64_t *a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  uint64_t v5 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  uint64_t v6 = *a2;
  *a2 = v5;
  if (v6) {
    MEMORY[0x1D9436740](v6, 0x1000C40E0EAB150);
  }
  os_unfair_lock_unlock(v4);
}

void TFSInfoOverflow::SetIFSymbol(uint64_t a1, void *a2)
{
  id v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  int v4 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v3;

  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 72));
}

void std::__shared_ptr_emplace<TVolumeSyncThread>::__on_zero_shared(uint64_t a1)
{
}

void TNode::Name(TNode *this@<X0>, TString *a2@<X8>)
{
  int v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = (TFSInfo *)*((void *)this + 2);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  TFSInfo::Name(v6, a2);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1D3448D60(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__1(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

__CFArray *TBusyFolders::CopyBusyFolders(TBusyFolders *this)
{
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  for (i = (const void **)*((void *)this + 2); i; i = (const void **)*i)
  {
    int v4 = RetainCF<__CFString const*>(i + 2);
    if (v4)
    {
      CFTypeRef v5 = CFAutorelease(v4);
      uint64_t v6 = static_cf_cast<__CFString const*,void const*>(v5);
    }
    else
    {
      uint64_t v6 = 0;
    }
    CFArrayAppendValue(Mutable, v6);
  }
  return Mutable;
}

const void **TSystemNotificationTask::HandleFSEvent(const void **this, const char **a2, int *a3, const unsigned int *a4)
{
  if (this)
  {
    uint64_t v6 = this;
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      int v9 = *a3++;
      int v8 = v9;
      if (v9 != 64)
      {
        TString::TString(&v15, *a2);
        TString::TString((TString *)&cf, "/private/var/tmp/com.apple.chrono/");
        BOOL v10 = TString::BeginsWith(&v15, (const TString *)&cf);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        if (!v10)
        {
          TString::TString((TString *)&cf, "/");
          BOOL v11 = TString::EndsWith(&v15, (const TString *)&cf);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          if (!v11)
          {
            fRef = v15.fString.fRef;
            CFTypeRef cf = &stru_1F2ABD380;
            CFRetain(&stru_1F2ABD380);
            MutableCFStringRef Copy = CFStringCreateMutableCopy(v7, 0, fRef);
            if (cf) {
              CFRelease(cf);
            }
            CFTypeRef cf = MutableCopy;
            TString::Append((TString *)&cf, (const __CFString *)"/");
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v15.fString.fRef, &cf);
            CFRetain(&stru_1F2ABD380);
            if (cf) {
              CFRelease(cf);
            }
            CFTypeRef cf = &stru_1F2ABD380;
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          }
          TNode::HandleChange(&v15, (4 * v8) & 0x200 | (((v8 & 0xF) != 0) << 24));
        }
        this = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
      }
      ++a2;
      uint64_t v6 = (const void **)((char *)v6 - 1);
    }
    while (v6);
  }
  return this;
}

void sub_1D3448F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

BOOL TString::EndsWith(TString *this, const TString *a2)
{
  CFIndex Length = CFStringGetLength(this->fString.fRef);
  CFIndex v5 = CFStringGetLength(a2->fString.fRef);
  BOOL v6 = Length < v5;
  CFIndex v7 = Length - v5;
  if (v6) {
    return 0;
  }
  CFIndex v9 = v5;
  BOOL v10 = RetainCF<__CFString const*>((const void **)&this->fString.fRef);
  if (v10)
  {
    CFTypeRef v11 = CFAutorelease(v10);
    CFStringRef v12 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v11);
  }
  else
  {
    CFStringRef v12 = 0;
  }
  id v13 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
  if (v13)
  {
    CFTypeRef v14 = CFAutorelease(v13);
    CFStringRef v15 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v14);
  }
  else
  {
    CFStringRef v15 = 0;
  }
  v16.id location = v7;
  v16.length = v9;
  return CFStringCompareWithOptions(v12, v15, v16, 0) == kCFCompareEqualTo;
}

const void *static_cf_cast<__CFString const*,void const*>(const void *result)
{
  if (result)
  {
    unsigned int v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID()) {
      return 0;
    }
    else {
      return v1;
    }
  }
  return result;
}

const void *RetainCF<__CFString const*>(const void **a1)
{
  uint64_t result = *a1;
  if (result)
  {
    CFTypeRef v2 = CFRetain(result);
    return static_cf_cast<__CFString const*,void const*>(v2);
  }
  return result;
}

uint64_t TNode::HandleChange(const TString *a1, uint64_t a2)
{
  uint64_t result = PathEligibleForSynching(a1);
  if (result)
  {
    CFIndex v5 = TPathName::TPathName((TPathName *)&v62, a1, TPathName::kPOSIXPathNameSeparator);
    TGlobalNodes::BootNode((uint64_t *)&v61, v5);
    uint64_t v58 = 0;
    uint64_t v59 = 0;
    uint64_t v60 = 0;
    if (v64 != v63)
    {
      BOOL v6 = (void *)(v63 + 8 * (v65 >> 9));
      CFIndex v7 = (TNode *)(*v6 + 8 * (v65 & 0x1FF));
      uint64_t v8 = *(void *)(v63 + (((v66 + v65) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v66 + v65) & 0x1FF);
      while (v7 != (TNode *)v8)
      {
        if (!TNodeFromFINode(v61)) {
          break;
        }
        uint64_t v9 = TNodeFromFINode(v61);
        BOOL v10 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
        os_unfair_lock_lock(v10);
        uint64_t v12 = *(void *)(v9 + 16);
        CFTypeRef v11 = *(std::__shared_weak_count **)(v9 + 24);
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v10);
        id v13 = (os_unfair_lock_s *)(v12 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
        int v14 = *(_DWORD *)(v12 + 115);
        os_unfair_lock_unlock(v13);
        if (v11) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v11);
        }
        if ((v14 & 0x20) != 0)
        {
          std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)&v58, (id *)&v61);
          uint64_t v15 = TNodeFromFINode(v61);
          CFRange v16 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v15);
          os_unfair_lock_lock(v16);
          TNodePtr::TNodePtr(&v67, *(const TNode **)(v15 + 48));
          os_unfair_lock_unlock(v16);
          uint64_t v17 = (TGlobalNodes *)TNodeFromFINode(v67.fFINode);
          TGlobalNodes::BootNode((uint64_t *)&cf2, v17);
          uint64_t v18 = TNodeFromFINode((FINode *)cf2);

          if (v17 == (TGlobalNodes *)v18)
          {
            uint64_t v29 = TNodeFromFINode(v61);
            TString v30 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v29);
            os_unfair_lock_lock(v30);
            uint64_t v32 = *(TFSInfo **)(v29 + 16);
            int v31 = *(std::__shared_weak_count **)(v29 + 24);
            if (v31) {
              atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            os_unfair_lock_unlock(v30);
            TFSInfo::Name(v32, (TString *)&v67);
            if (v31) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v31);
            }
            TPathName::UsersDirectory((TString *)&cf2);
            if (CFEqual(v67.fFINode, cf2))
            {
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v67.fFINode);
LABEL_37:
              if ((a2 & 0x200) != 0)
              {
                uint64_t v39 = TNodeFromFINode(v61);
                TNode::HandleSync(v39, 0x1000000u);
              }
              uint64_t v40 = (TNode *)TNodeFromFINode(v61);
              TNode::FindChild(v40, v7, 0, 0, (void **)&v67.fFINode);
              goto LABEL_12;
            }
            uint64_t v34 = TNodeFromFINode(v61);
            id v35 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v34);
            os_unfair_lock_lock(v35);
            unint64_t v37 = *(TFSInfo **)(v34 + 16);
            int v36 = *(std::__shared_weak_count **)(v34 + 24);
            if (v36) {
              atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            os_unfair_lock_unlock(v35);
            TFSInfo::Name(v37, &v56);
            if (v36) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v36);
            }
            TPathName::VolumesDirectory(&v55);
            int v38 = CFEqual(v56.fString.fRef, v55.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v55.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v56.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v67.fFINode);
            if (v38) {
              goto LABEL_37;
            }
          }
        }
        id v19 = (TNode *)TNodeFromFINode(v61);
        TNode::FindChildButDontSynchronize(v19, v7, (void **)&v67.fFINode);
LABEL_12:
        TNodePtr::operator=((void **)&v61, (void **)&v67.fFINode);

        uint64_t v20 = TNodeFromFINode(v61);
        if (v20 != TNodeFromFINode(0))
        {
          uint64_t v21 = TNodeFromFINode(v61);
          uint64_t v22 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v21);
          os_unfair_lock_lock(v22);
          uint64_t v24 = *(void *)(v21 + 16);
          uint64_t v23 = *(std::__shared_weak_count **)(v21 + 24);
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          os_unfair_lock_unlock(v22);
          int v25 = (os_unfair_lock_s *)(v24 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)(v24 + 100));
          int v26 = *(_DWORD *)(v24 + 115);
          os_unfair_lock_unlock(v25);
          if (v23) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v23);
          }
          if ((v26 & 0x40) != 0)
          {
            v67.fFINode = 0;
            uint64_t v27 = (TNode *)TNodeFromFINode(v61);
            CFTypeRef cf2 = 0;
            if (TNode::FollowAlias(v27, &v67, (TNodeRequest **)&cf2, 8)) {
              uint64_t v28 = 0;
            }
            else {
              uint64_t v28 = v67.fFINode;
            }
            CFTypeRef cf2 = v28;
            TNodePtr::operator=((void **)&v61, (void **)&cf2);
          }
        }
        CFIndex v7 = (TNode *)((char *)v7 + 8);
        if ((TNode *)((char *)v7 - *v6) == (TNode *)4096)
        {
          id v33 = (TNode *)v6[1];
          ++v6;
          CFIndex v7 = v33;
        }
      }
    }
    if (TNodeFromFINode(v61))
    {
      uint64_t v41 = TNodeFromFINode(v61);
      unint64_t v42 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v41);
      os_unfair_lock_lock(v42);
      uint64_t v44 = *(void *)(v41 + 16);
      int v43 = *(std::__shared_weak_count **)(v41 + 24);
      if (v43) {
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v42);
      uint64_t v45 = (os_unfair_lock_s *)(v44 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v44 + 100));
      int v46 = *(_DWORD *)(v44 + 115);
      os_unfair_lock_unlock(v45);
      if (v43) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v43);
      }
      if ((v46 & 0x20) != 0) {
        std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)&v58, (id *)&v61);
      }
      if ((a2 & 0x200) != 0)
      {
        uint64_t v48 = TNodeFromFINode(v61);
        uint64_t v49 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v48);
        os_unfair_lock_lock(v49);
        TNodePtr::TNodePtr(&v67, *(const TNode **)(v48 + 48));
        os_unfair_lock_unlock(v49);
        if (TNodeFromFINode(v67.fFINode))
        {
          uint64_t v50 = TNodeFromFINode(v67.fFINode);
          TNode::RequestSynchronize(v50, 0x1000000);
        }
      }
      else
      {
        uint64_t v47 = TNodeFromFINode(v61);
        TNode::HandleListeners(v47, a2);
      }
    }
    uint64_t v52 = v58;
    for (uint64_t i = v59; i != v52; i -= 8)
    {
      unsigned int v53 = *(FINode **)(i - 8);
      long long v54 = (TNode *)TNodeFromFINode(v53);
      TNode::HandleRecursiveListeners(v54);
    }
    v67.fFINode = (FINode *)&v58;
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v67);

    return std::deque<TString>::~deque[abi:ne180100](&v62);
  }
  return result;
}

void sub_1D34495E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
  os_unfair_lock_unlock(v16);
  *(void *)(v17 - 88) = &a12;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)(v17 - 88));

  std::deque<TString>::~deque[abi:ne180100](&a16);
  _Unwind_Resume(a1);
}

id std::vector<TNodePtr>::push_back[abi:ne180100](uint64_t a1, id *a2)
{
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v4 = a1 + 16;
  unint64_t v5 = v6;
  CFIndex v7 = *(void **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *(void *)a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - *(void *)a1;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    v16[4] = v4;
    if (v13) {
      int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    }
    else {
      int v14 = 0;
    }
    uint64_t v15 = &v14[8 * v10];
    v16[0] = v14;
    v16[1] = v15;
    v16[3] = &v14[8 * v13];
    *(void *)uint64_t v15 = *a2;
    v16[2] = v15 + 8;
    std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, v16);
    uint64_t v9 = *(void **)(a1 + 8);
    id result = (id)std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    id result = *a2;
    void *v7 = result;
    uint64_t v9 = v7 + 1;
    *(void *)(a1 + 8) = v9;
  }
  *(void *)(a1 + 8) = v9;
  return result;
}

void sub_1D34497DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t PathEligibleForSynching(const TString *a1)
{
  {
    {
      AllowedPaths(PathEligibleForSynching(TString const&)::allowedPaths);
    }
  }
  unint64_t v5 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&v5, (TString *)a1->fString.fRef);
  CFTypeRef v2 = (const TString *)PathEligibleForSynching(TString const&)::allowedPaths[0];
  id v3 = (const TString *)unk_1EC008EA0;
  v6.fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v6, (TString *)v5);
  while (1)
  {
    if (v2 == v3)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5);
      return MatchesEDSContainerPattern(a1);
    }
    if (TString::BeginsWith(&v6, v2)) {
      break;
    }
    ++v2;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5);
  return 1;
}

void sub_1D34498F0(_Unwind_Exception *a1)
{
}

BOOL TString::BeginsWith(TString *this, const TString *a2)
{
  CFIndex Length = CFStringGetLength(a2->fString.fRef);
  if (CFStringGetLength(this->fString.fRef) < Length) {
    return 0;
  }
  if (Length) {
    return CFStringHasPrefix(this->fString.fRef, a2->fString.fRef) != 0;
  }
  return 1;
}

FINode *TGlobalNodes::BootNode@<X0>(FINode **__return_ptr a1@<X8>, TNode *this@<X0>)
{
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  id v3 = (const TNodePtr *)TGlobalNodes::gGlobalNodes;
  char v11 = 0;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN12TGlobalNodes8BootNodeEv_block_invoke;
  block[3] = &__block_descriptor_48_ea8_32c37_ZTSKZN12TGlobalNodes8BootNodeEvE3__0_e5_v8__0l;
  block[4] = TGlobalNodes::gGlobalNodes;
  block[5] = &v11;
  if (TGlobalNodes::BootNode(void)::onceToken != -1) {
    dispatch_once(&TGlobalNodes::BootNode(void)::onceToken, block);
  }
  if (v11)
  {
    TNode::GetSuperRootNode((uint64_t *)&v9, this);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)v8, &v9, 0);
    BOOL v7 = 0;
    uint64_t v4 = (TChildrenList **)TNodeFromFINode(v9.fFINode);
    TNode::AddNewChild((FINode **)&v6, v4, v3 + 1, &v7, 1u);
    TNodePtr::operator=((void **)&v3[1].fFINode, &v6);

    TNode::StPopulating::~StPopulating((TNode::StPopulating *)v8);
  }
  id result = v3[1].fFINode;
  *a1 = result;
  return result;
}

void sub_1D3449AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t MatchesEDSContainerPattern(const TString *a1)
{
  CFTypeRef v2 = (void *)[objc_alloc(MEMORY[0x1E4F1CB10]) initFileURLWithPath:a1->fString.fRef];
  if (objc_opt_respondsToSelector())
  {
    uint64_t v3 = objc_msgSend(v2, "fp_matchesEDSLocation");
  }
  else
  {
    v11.fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v11, (TString *)a1->fString.fRef);
    TString::TString((TString *)&cf, "/private", 8uLL);
    RemovePrefix((const TString *)&cf, &v11);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    TString::TString((TString *)&cf, "/var/PersonaVolumes/", 0x14uLL);
    BOOL v4 = RemovePrefix((const TString *)&cf, &v11);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (!v4) {
      goto LABEL_13;
    }
    TString::TString((TString *)&cf, "/");
    CFIndex v5 = TString::IndexOf(&v11, (const TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v5 < 1) {
      goto LABEL_13;
    }
    TString::SubStringFrom(&v11, v5, (TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v11.fString.fRef, &cf);
    CFRetain(&stru_1F2ABD380);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = &stru_1F2ABD380;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    TString::TString((TString *)&cf, "/Containers/Data/InternalDaemon/", 0x20uLL);
    BOOL v6 = RemovePrefix((const TString *)&cf, &v11);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (!v6) {
      goto LABEL_13;
    }
    TString::TString((TString *)&cf, "/");
    CFIndex v7 = TString::IndexOf(&v11, (const TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v7 >= 1)
    {
      TString::SubStringFrom(&v11, v7, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v11.fString.fRef, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TString::TString((TString *)&cf, "/Library/Mobile Documents", 0x19uLL);
      if (RemovePrefix((const TString *)&cf, &v11))
      {
        uint64_t v3 = 1;
      }
      else
      {
        TString::TString(&v9, "/Library/CloudStorage", 0x15uLL);
        uint64_t v3 = RemovePrefix(&v9, &v11);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    else
    {
LABEL_13:
      uint64_t v3 = 0;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
  }

  return v3;
}

void sub_1D3449D74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  BOOL v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  BOOL v6 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);

  _Unwind_Resume(a1);
}

void TNode::HandleRecursiveListeners(TNode *this)
{
  CFTypeRef v2 = (os_unfair_lock_s *)TNode::ParentLock(this);
  os_unfair_lock_lock(v2);
  TNodePtr::TNodePtr(&v16, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v2);
  if (TNodeFromFINode(v16.fFINode))
  {
    uint64_t v3 = (TNode *)TNodeFromFINode(v16.fFINode);
    signed int v4 = atomic_load((unsigned int *)(TNode::GetNotifierList(v3) + 4));
    BOOL v5 = v4 > 0;
  }
  else
  {
    BOOL v5 = 0;
  }
  int v6 = atomic_load((unsigned int *)(TNode::GetNotifierList(this) + 4));
  char v7 = v6 > 0 || v5;
  if (v7)
  {
    LOBYTE(v8) = 1;
  }
  else
  {
    unsigned int v9 = atomic_load((unsigned __int16 *)this + 40);
    int v8 = (v9 >> 7) & 1;
  }
  TNode::SetSizesAreValid(this, 0);
  TString v11 = (os_unfair_lock_s *)TNode::InfoLock(v10);
  os_unfair_lock_lock(v11);
  uint64_t v13 = *((void *)this + 2);
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v11);
  int v14 = (os_unfair_lock_s *)(v13 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
  unsigned int v15 = *(_DWORD *)(v13 + 115);
  os_unfair_lock_unlock(v14);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  if ((v8 & (v15 >> 27)) != 0) {
    TNodeRequest::Make();
  }
}

void sub_1D3449FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, TNodeRequest *a15, id a16)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::GetNotifierList(TNode *this)
{
  CFTypeRef v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v3 = *((void *)this + 9);
  if (!v3) {
    operator new();
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1D344A13C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v2, 0x1020C40F61775ADLL);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TNode::SetSizesAreValid(TNode *this, int a2)
{
  signed int v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *((void *)this + 2);
  BOOL v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v4);
    char v7 = (os_unfair_lock_s *)(v6 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    unsigned int v9 = *(_DWORD *)(v6 + 115);
    uint64_t v8 = v6 + 115;
    unint64_t v10 = v9 | ((unint64_t)*(unsigned __int16 *)(v8 + 4) << 32);
    int v11 = 0x10000000;
    if (!a2) {
      int v11 = 0;
    }
    unint64_t v12 = v10 & 0xFFFFFFFFEFFFFFFFLL;
    *(_DWORD *)uint64_t v8 = v12 | v11;
    *(_WORD *)(v8 + 4) = WORD2(v12);
    os_unfair_lock_unlock(v7);
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    uint64_t v13 = (os_unfair_lock_s *)(v6 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    unsigned int v15 = *(_DWORD *)(v6 + 115);
    uint64_t v14 = v6 + 115;
    unint64_t v16 = v15 | ((unint64_t)*(unsigned __int16 *)(v14 + 4) << 32);
    int v17 = 0x10000000;
    if (!a2) {
      int v17 = 0;
    }
    unint64_t v18 = v16 & 0xFFFFFFFFEFFFFFFFLL;
    *(_DWORD *)uint64_t v14 = v18 | v17;
    *(_WORD *)(v14 + 4) = WORD2(v18);
    os_unfair_lock_unlock(v13);
  }
}

uint64_t std::vector<TNodePtr>::reserve(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t result = a1 + 16;
  if (a2 > (v4 - *(void *)a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = *(void *)(a1 + 8) - *(void *)a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 8 * v6;
    std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, v7);
    return std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1D344A2FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

id *std::vector<TNodePtr>::__swap_out_circular_buffer(id **a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = (id *)a2[1];
  while (v4 != v5)
    uint64_t result = (id *)TNodePtr::TNodePtr(result - 1, --v4);
  a2[1] = result;
  char v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = (id *)a2[2];
  a2[2] = v8;
  unsigned int v9 = a1[2];
  a1[2] = (id *)a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<TNodePtr>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<TNodePtr>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

void TNode::FindChild(TNode *this@<X0>, TNode *a2@<X1>, int a3@<W2>, char a4@<W3>, void **a5@<X8>)
{
  *a5 = 0;
  TGlobalNodes::RootNode((uint64_t *)&v38, (TGlobalNodes *)this);
  unint64_t v10 = (TNode *)TNodeFromFINode(v38.fFINode);

  if (v10 == this)
  {
    TNode::GetVolume(a2, &v38);
    TNodePtr::operator=(a5, (void **)&v38.fFINode);

    return;
  }
  unint64_t v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
  os_unfair_lock_lock(v12);
  uint64_t v14 = *((void *)this + 2);
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v12);
  unsigned int v15 = (os_unfair_lock_s *)(v14 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
  int v16 = *(_DWORD *)(v14 + 115);
  os_unfair_lock_unlock(v15);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  if ((v16 & 0x20) != 0 && CFStringGetLength(*(CFStringRef *)a2) >= 1)
  {
    TNodePtr::TNodePtr(&v36, this);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)&v38, &v36, 0);

    int v17 = (TChildrenList *)*((void *)this + 7);
    if (v17)
    {
      TChildrenList::Find(v17, (const TString *)a2, &v36);
      TNodePtr::operator=(a5, (void **)&v36.fFINode);
    }
    TNode::StPopulating::~StPopulating(&v38.fFINode);
    unint64_t v18 = (TNode *)TNodeFromFINode((FINode *)*a5);
    if (v18 || (a4 & 1) != 0)
    {
      if (!a3) {
        return;
      }
      uint64_t v23 = (os_unfair_lock_s *)TNode::ParentLock(v18);
      os_unfair_lock_lock(v23);
      TNodePtr::TNodePtr(&v38, *((const TNode **)this + 6));
      os_unfair_lock_unlock(v23);
      uint64_t v24 = (TNode *)TNodeFromFINode(v38.fFINode);
      if (v24)
      {
        int v25 = (os_unfair_lock_s *)TNode::ParentLock(v24);
        os_unfair_lock_lock(v25);
        TNodePtr::TNodePtr(&v36, *((const TNode **)this + 6));
        os_unfair_lock_unlock(v25);
        int v26 = (TNode *)TNodeFromFINode(v36.fFINode);
        int v27 = atomic_load((unsigned int *)TNode::GetNotifierList(v26));

        if (v27 > 0) {
          return;
        }
      }
      else
      {
      }
      uint64_t v33 = TNodeFromFINode((FINode *)*a5);
      TNode::HandleSync(v33, 0x10080000u);
      return;
    }
    id v19 = (os_unfair_lock_s *)TNode::InfoLock(0);
    os_unfair_lock_lock(v19);
    uint64_t v21 = *((void *)this + 2);
    uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v20)
    {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v19);
      int v22 = *(unsigned __int8 *)(v21 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v20);
      if (v22) {
        return;
      }
    }
    else
    {
      os_unfair_lock_unlock(v19);
      if (*(unsigned char *)(v21 + 112)) {
        return;
      }
    }
    if ((CFStringGetLength(*(CFStringRef *)a2) != 1
       || CFStringGetLength(*(CFStringRef *)a2) < 1
       || CFStringGetCharacterAtIndex(*(CFStringRef *)a2, 0) != 46)
      && (CFStringGetLength(*(CFStringRef *)a2) != 2
       || TString::GetUniChar((TString *)a2, 0) != 46
       || TString::GetUniChar((TString *)a2, 1) != 46))
    {
      uint64_t v28 = (TNode *)_ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v38);
      fFINode = v38.fFINode;
      TString v30 = (os_unfair_lock_s *)TNode::InfoLock(v28);
      os_unfair_lock_lock(v30);
      int v31 = (std::__shared_weak_count *)*((void *)this + 3);
      v36.fFINode = (FINode *)*((void *)this + 2);
      unint64_t v37 = v31;
      if (v31) {
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v30);
      int v32 = TFSInfo::Initialize((TFSInfo *)fFINode, (os_unfair_lock_s **)&v36, (const TString *)a2);
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      if (!v32)
      {
        TFSInfo::FetchEnumeratorProperties((TFSInfo *)v38.fFINode);
        uint64_t v34 = v38.fFINode;
        id v35 = v39;
        if (v39) {
          atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        TNode::FindOrCreateChild(this, (TFSInfo **)&v34, &v36);
        TNodePtr::operator=(a5, (void **)&v36.fFINode);

        if (v35) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v35);
        }
      }
      if (v39) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v39);
      }
    }
  }
}

void sub_1D344A7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }

  _Unwind_Resume(a1);
}

void **TNodePtr::operator=(void **a1, void **a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *a2;
    *a2 = 0;
    uint64_t v4 = *a1;
    *a1 = v3;
  }
  return a1;
}

void TNode::FindChildButDontSynchronize(TNode *this@<X0>, TNode *a2@<X1>, void **a3@<X8>)
{
  *a3 = 0;
  TGlobalNodes::RootNode((uint64_t *)v15, (TGlobalNodes *)this);
  uint64_t v6 = (TNode *)TNodeFromFINode(v15[0]);

  if (v6 == this)
  {
    TNode::GetVolume(a2, (TNodePtr *)v15);
    TNodePtr::operator=(a3, (void **)v15);
  }
  else
  {
    uint64_t v8 = (os_unfair_lock_s *)TNode::InfoLock(v7);
    os_unfair_lock_lock(v8);
    uint64_t v10 = *((void *)this + 2);
    unsigned int v9 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v8);
    int v11 = (os_unfair_lock_s *)(v10 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
    int v12 = *(_DWORD *)(v10 + 115);
    os_unfair_lock_unlock(v11);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
    if ((v12 & 0x20) != 0 && CFStringGetLength(*(CFStringRef *)a2) >= 1)
    {
      TNodePtr::TNodePtr(&v14, this);
      TNode::StPopulating::StPopulating((TNode::StPopulating *)v15, &v14, 0);

      uint64_t v13 = (TChildrenList *)*((void *)this + 7);
      if (v13)
      {
        TChildrenList::Find(v13, (const TString *)a2, &v14);
        TNodePtr::operator=(a3, (void **)&v14.fFINode);
      }
      TNode::StPopulating::~StPopulating(v15);
    }
  }
}

void sub_1D344AA34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TNode::StPopulating::~StPopulating((FINode **)va);

  _Unwind_Resume(a1);
}

BOOL TNode::IsContextOpen(TNode *this)
{
  ContextMutex();
  TDSMutex::lock(&ContextMutex(void)::mutex);
  int v1 = sContextOpenCount;
  TDSMutex::unlock(&ContextMutex(void)::mutex);
  return v1 > 0;
}

void TNode::StPopulating::~StPopulating(FINode **this)
{
  if (TNodeFromFINode(*this) && !this[1] && *(void *)(TNodeFromFINode(*this) + 56))
  {
    uint64_t v2 = TNodeFromFINode(*this);
    TChildrenList::Unlock(*(TChildrenList **)(v2 + 56));
  }
}

uint64_t TDSMutex::unlock(TDSMutex *this)
{
  uint64_t result = pthread_mutex_unlock(&this->fMutex);
  if (result) {
    abort();
  }
  return result;
}

TNode::StPopulating *TNode::StPopulating::StPopulating(TNode::StPopulating *this, const TNodePtr *a2, TNode::StPopulating *a3)
{
  uint64_t v5 = a2->fFINode;
  *(void *)this = v5;
  *((void *)this + 1) = a3;
  uint64_t v6 = TNodeFromFINode(v5);
  if (!a3 && v6 && *(void *)(TNodeFromFINode(*(FINode **)this) + 56))
  {
    uint64_t v7 = TNodeFromFINode(*(FINode **)this);
    TChildrenList::Lock(*(TChildrenList **)(v7 + 56));
    uint64_t v8 = TNodeFromFINode(*(FINode **)this);
    *((_DWORD *)this + 4) = TChildrenList::GenerationCount(*(TChildrenList **)(v8 + 56));
  }
  return this;
}

void sub_1D344ABC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TDSMutex::lock(TDSMutex *this)
{
  uint64_t result = pthread_mutex_lock(&this->fMutex);
  if (result) {
    abort();
  }
  return result;
}

uint64_t TChildrenList::GenerationCount(TChildrenList *this)
{
  return *((unsigned int *)this + 46);
}

void ContextMutex(void)
{
  {
    TDSMutex::TDSMutex(&ContextMutex(void)::mutex, 1);
  }
}

void sub_1D344AC78(_Unwind_Exception *a1)
{
}

void TChildrenList::Find(TChildrenList *this@<X0>, const TString *a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v6 = *((void *)this + 12);
  uint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)this);
  os_unfair_lock_lock(v7);
  uint64_t v9 = *(void *)(v6 + 16);
  uint64_t v8 = *(std::__shared_weak_count **)(v6 + 24);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v7);
    int v10 = *(unsigned __int8 *)(v9 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    if (v10)
    {
LABEL_3:
      int v11 = (FINode **)*((void *)this + 8);
      int v12 = (FINode **)*((void *)this + 9);
      if (v11 == v12) {
        goto LABEL_21;
      }
      while (1)
      {
        uint64_t v13 = (TNode *)TNodeFromFINode(*v11);
        if (TNode::Equal(v13, a2)) {
          break;
        }
        if (++v11 == v12)
        {
          int v11 = v12;
          break;
        }
      }
      if (v11 == *((FINode ***)this + 9)) {
        goto LABEL_21;
      }
LABEL_20:
      a3->fFINode = *v11;
      return;
    }
  }
  else
  {
    os_unfair_lock_unlock(v7);
    if (*(unsigned char *)(v9 + 112)) {
      goto LABEL_3;
    }
  }
  TChildrenList::SortListIfNeeded(this, 0);
  int v11 = (FINode **)*((void *)this + 8);
  uint64_t v14 = *((void *)this + 9) - (void)v11;
  if (v14)
  {
    unint64_t v15 = v14 >> 3;
    do
    {
      int v16 = &v11[v15 >> 1];
      unint64_t v18 = *v16;
      int v17 = v16 + 1;
      id v19 = (TNode *)TNodeFromFINode(v18);
      BOOL v20 = TNode::LessThan(v19, a2);
      if (v20) {
        v15 += ~(v15 >> 1);
      }
      else {
        v15 >>= 1;
      }
      if (v20) {
        int v11 = v17;
      }
    }
    while (v15);
    if (v11 != *((FINode ***)this + 9))
    {
      uint64_t v21 = (TNode *)TNodeFromFINode(*v11);
      if (TNode::Equal(v21, a2)) {
        goto LABEL_20;
      }
    }
  }
LABEL_21:
  TNodePtr::TNodePtr(a3, 0);
}

void TChildrenList::SortListIfNeeded(TChildrenList *this, unint64_t a2)
{
  uint64_t v2 = (char *)this + 64;
  uint64_t v3 = (FINode **)*((void *)this + 8);
  unint64_t v4 = *((void *)this + 19);
  uint64_t v5 = (void **)*((void *)this + 9);
  uint64_t v6 = ((char *)v5 - (char *)v3) >> 3;
  unint64_t v7 = v6 - v4;
  BOOL v8 = v6 != v4 && (unint64_t)((char *)v5 - (char *)v3) >= 0x10;
  if (v8
    && (a2 < 2
     || (float)((float)(log2f((float)(unint64_t)v6) + 1.0) * (float)a2) < (float)((float)a2
                                                                                       * (float)(unint64_t)v6)))
  {
    int v10 = &v3[v4];
    if (v7 == 1)
    {
      if (v4)
      {
        do
        {
          int v11 = &v3[v4 >> 1];
          BOOL v12 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v11, v10);
          if (v12) {
            v4 += ~(v4 >> 1);
          }
          else {
            v4 >>= 1;
          }
          if (v12) {
            uint64_t v3 = v11 + 1;
          }
        }
        while (v4);
      }
      else
      {
        v3 += v4;
      }
      if (v10 != v3)
      {
        uint64_t v21 = (uint64_t)v3 - *((void *)this + 8);
        int v22 = v10 + 1;
        *(void *)&long long v30 = *v10;
        uint64_t v23 = (FINode **)*((void *)this + 9);
        if (v10 + 1 != v23)
        {
          do
          {
            uint64_t v24 = v10 + 1;
            TNodePtr::operator=((void **)v10, (void **)v10 + 1);
            int v25 = v10 + 2;
            ++v10;
          }
          while (v25 != v23);
          int v22 = (FINode **)*((void *)this + 9);
          int v10 = v24;
        }
        while (v22 != v10)
        {
          int v26 = *--v22;
        }
        *((void *)this + 9) = v10;
        std::vector<TNodePtr>::insert((uint64_t)v2, (id *)(*((void *)this + 8) + 8 * (v21 >> 3)), (id *)&v30);
      }
    }
    else
    {
      unint64_t v13 = 126 - 2 * __clz(((char *)v5 - (char *)v10) >> 3);
      if (v5 == (void **)v10) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = v13;
      }
      std::__introsort<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,false>((id *)&v3[v4], v5, v14, 1);
      std::vector<TNodePtr>::vector(&v30, (uint64_t)(*((void *)this + 9) - *((void *)this + 8)) >> 3);
      uint64_t v15 = *((void *)this + 19);
      int v16 = (void **)*((void *)this + 8);
      int v17 = (void **)*((void *)this + 9);
      unint64_t v18 = &v16[v15];
      id v19 = (void **)v30;
      if (v15)
      {
        BOOL v20 = &v16[v15];
        while (v20 != v17)
        {
          if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v20, (FINode **)v16)) {
            TNodePtr::operator=(v19, v20++);
          }
          else {
            TNodePtr::operator=(v19, v16++);
          }
          ++v19;
          if (v16 == v18) {
            goto LABEL_38;
          }
        }
        uint64_t v27 = 0;
        do
        {
          TNodePtr::operator=(&v19[v27], &v16[v27]);
          ++v27;
        }
        while (&v16[v27] != v18);
      }
      else
      {
        BOOL v20 = (void **)*((void *)this + 8);
LABEL_38:
        while (v20 != v17)
          TNodePtr::operator=(v19++, v20++);
      }
      long long v28 = *((_OWORD *)this + 4);
      *((_OWORD *)this + 4) = v30;
      long long v30 = v28;
      uint64_t v29 = *((void *)this + 10);
      *((void *)this + 10) = v31;
      uint64_t v31 = v29;
      int v32 = (void **)&v30;
      std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v32);
    }
    *((void *)this + 19) = (uint64_t)(*((void *)this + 9) - *((void *)this + 8)) >> 3;
  }
}

void sub_1D344B0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

BOOL TNode::LessThan(TNode *this, const TString *a2)
{
  return TNode::Compare(this, a2) == -1;
}

BOOL TNode::Equal(TNode *this, const TString *a2)
{
  return TNode::Compare(this, a2) == 0;
}

void TNodeEvent::ForwardEventToParent(TNodeEvent *this)
{
  if (TNode::IsContextOpen((TNode *)this))
  {
    unsigned int fEventKind = this->fEventKind;
    uint64_t v3 = [this->fFINode nodeRef];
    uint64_t v5 = (const TNode *)TNode::NodeFromNodeRef((TNode *)v3, v4);
    TNodePtr::TNodePtr(&v41, v5);
    uint64_t v6 = TNodeFromFINode(v41.fFINode);
    unint64_t v7 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v6);
    os_unfair_lock_lock(v7);
    TNodePtr::TNodePtr(&v40, *(const TNode **)(v6 + 48));
    os_unfair_lock_unlock(v7);
    if (fEventKind == 2) {
      uint64_t v8 = 6;
    }
    else {
      uint64_t v8 = 4 * (fEventKind == 1);
    }
    uint64_t v9 = (TNode *)TNodeFromFINode(v40.fFINode);
    TNode::GetSuperRootNode((uint64_t *)v38, v9);
    uint64_t v10 = TNodeFromFINode(v38[0]);

    if (v9 == (TNode *)v10) {
      goto LABEL_11;
    }
    uint64_t v11 = TNodeFromFINode(v41.fFINode);
    BOOL v12 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v11);
    os_unfair_lock_lock(v12);
    uint64_t v14 = *(void *)(v11 + 16);
    unint64_t v13 = *(std::__shared_weak_count **)(v11 + 24);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v12);
    uint64_t v15 = (os_unfair_lock_s *)(v14 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
    int v16 = *(_DWORD *)(v14 + 115);
    os_unfair_lock_unlock(v15);
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
    }
    if ((v16 & 0x100) != 0)
    {
      uint64_t v18 = TNodeFromFINode(v41.fFINode);
      id v19 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v18);
      os_unfair_lock_lock(v19);
      uint64_t v21 = *(void *)(v18 + 16);
      BOOL v20 = *(std::__shared_weak_count **)(v18 + 24);
      if (v20)
      {
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(v19);
        int v22 = *(unsigned __int8 *)(v21 + 112);
        std::__shared_weak_count::__release_shared[abi:ne180100](v20);
      }
      else
      {
        os_unfair_lock_unlock(v19);
        int v22 = *(unsigned __int8 *)(v21 + 112);
      }
      if (v22) {
        BOOL v23 = 0;
      }
      else {
        BOOL v23 = fEventKind == 2;
      }
      int v17 = v23;
    }
    else
    {
LABEL_11:
      int v17 = 0;
    }
    uint64_t v24 = TNodeFromFINode(v40.fFINode);
    BOOL v25 = fEventKind - 1 >= 2 || v24 == 0;
    int v26 = !v25;
    if (v25) {
      int v27 = v17;
    }
    else {
      int v27 = 1;
    }
    if (v27 == 1)
    {
      TFSInfo::MarkAsUsed((TFSInfo *)v8);
      unsigned int fProperty = this->fProperty;
      v38[0] = 0;
      v38[1] = 0;
      v37.fFINode = 0;
      TNodeEvent::CreateNodeEvent(v8, (id *)&v41.fFINode, fProperty, &this->fPropertyValue, (uint64_t *)v38, (TDSNotifier **)&v37, &v39);
      uint64_t v29 = TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v37);
      long long v30 = v39;
      if (v26)
      {
        if (v39) {
          uint64_t v31 = (TNodeEvent *)(v39 + 8);
        }
        else {
          uint64_t v31 = 0;
        }
        TNodeEvent::NotifyNode(v36, v31, &v40, 1);
        v38[0] = (FINode *)v36;
        std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)v38);
        int v32 = (TNode *)TNodeFromFINode(v41.fFINode);
        TNode::SecondParent(v32, &v37);
        if (TNodeFromFINode(v37.fFINode))
        {
          TNodeEvent::NotifyNode(v35, v31, &v37, 1);
          v38[0] = (FINode *)v35;
          std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)v38);
        }
      }
      if (v17)
      {
        TNode::GetSuperRootNode((uint64_t *)&v37, (TNode *)v29);
        if (v30) {
          uint64_t v33 = (TNodeEvent *)(v30 + 8);
        }
        else {
          uint64_t v33 = 0;
        }
        TNodeEvent::NotifyNode(v34, v33, &v37, 1);
        v38[0] = (FINode *)v34;
        std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)v38);
      }
    }
  }
}

void sub_1D344B3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_1D344B46C()
{
}

void TNodePtr::TNodePtr(TNodePtr *this, const TNode *a2)
{
  this->fFINode = (FINode *)objc_claimAutoreleasedReturnValue();
}

const TNode *FIDSNodeFromTNode(TNode *a1)
{
  if (a1)
  {
    {
      uint64_t v5 = a1;
      a1 = (TNode *)v5;
      if (v2)
      {
        uint64_t v3 = (objc_class *)objc_opt_class();
        InstanceVariable = class_getInstanceVariable(v3, "_node");
        FIDSNodeFromTNode(TNode const*)::nodeOffset = ivar_getOffset(InstanceVariable);
        a1 = (TNode *)v5;
      }
    }
    static_objc_cast<DSFileServiceConnection,void *>((char *)a1 - FIDSNodeFromTNode(TNode const*)::nodeOffset);
    a1 = (TNode *)objc_claimAutoreleasedReturnValue();
  }
  return a1;
}

void sub_1D344B558(_Unwind_Exception *a1)
{
}

uint64_t *TGlobalNodes::RootNode@<X0>(uint64_t *__return_ptr a1@<X8>)
{
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  uint64_t v3 = (id *)TGlobalNodes::gGlobalNodes;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN12TGlobalNodes8RootNodeEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = TGlobalNodes::gGlobalNodes;
  if (TGlobalNodes::RootNode(void)::onceToken != -1) {
    dispatch_once(&TGlobalNodes::RootNode(void)::onceToken, block);
  }
  uint64_t result = (uint64_t *)*v3;
  *a1 = (uint64_t)result;
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a3 != a5)
  {
    uint64_t v10 = a3;
    uint64_t v11 = (void *)(a7 - 16);
    do
    {
      TNodePtr::TNodePtr(v11, (id *)(v10 - 16));
      v11[1] = *(id *)(v10 - 8);
      v7 -= 16;
      v11 -= 2;
      v10 -= 16;
    }
    while (v10 != a5);
  }
  return a6;
}

void *TNodePtr::TNodePtr(void *a1, id *a2)
{
  *a1 = *a2;
  id v4 = *a2;
  *a2 = 0;

  return a1;
}

uint64_t TFSInfo::TFSInfo(uint64_t a1, char a2, const TString *a3, unsigned __int8 *a4)
{
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  TFSInfo::TFSInfo((TFSInfo *)a1);
  *(unsigned char *)(v8 + 112) = a2;
  *(_DWORD *)(v8 + 115) |= 0x40000000u;
  TFSInfo::SetItemName((TFSInfo *)v8, a3);
  unsigned int v9 = *(_DWORD *)(a1 + 115) & 0xFFFFFFDF | (32 * *a4);
  *(_DWORD *)(a1 + 115) = v9;
  unsigned int v10 = v9 & 0xFFFFFEFF | (a4[1] << 8);
  *(_DWORD *)(a1 + 115) = v10;
  unsigned int v11 = v10 & 0xFFFFF7FF | (a4[2] << 11);
  *(_DWORD *)(a1 + 115) = v11;
  *(unsigned char *)(a1 + 114) = a4[3];
  *(_DWORD *)(a1 + 115) = v11 | 1;
  TFSInfo::SetIfVirtualAlias((TFSInfo *)a1);
  return a1;
}

void sub_1D344B7F8(_Unwind_Exception *a1)
{
  TFSInfo::~TFSInfo(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  int v2 = (char *)operator new(0x98uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceI7TFSInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_1D344B844(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceI7TFSInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F2ABB358;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24));
  return a1;
}

void sub_1D344B8C4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::TFSInfo(TFSInfo *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = &stru_1F2ABD380;
  *(void *)this = 0;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 4) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 5) = 0;
  *((void *)this + 6) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *(_OWORD *)((char *)this + 97) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_WORD *)((char *)this + 113) = 255;
  __int16 v2 = *(_WORD *)((char *)this + 119);
  *(_DWORD *)((char *)this + 115) = 67108872;
  *(_WORD *)((char *)this + 119) = v2 & 0xC000;
}

void sub_1D344B988(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v2);
  uint64_t v7 = *(const void ***)v1;
  *(void *)uint64_t v1 = 0;
  if (v7) {
    std::default_delete<TVersionData>::operator()[abi:ne180100](v1, v7);
  }
  _Unwind_Resume(a1);
}

void TFSInfo::SetIfVirtualAlias(TFSInfo *this)
{
  unsigned int v1 = *((unsigned __int8 *)this + 112);
  BOOL v2 = v1 > 7;
  int v3 = (1 << v1) & 0xA8;
  if (!v2 && v3 != 0)
  {
    uint64_t v6 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    *(_DWORD *)((char *)this + 115) |= 0x800u;
    os_unfair_lock_unlock(v6);
  }
}

TFSInfo *TFSInfo::FetchEnumeratorProperties(TFSInfo *this)
{
  CFURLRef v1 = (const __CFURL *)*((void *)this + 1);
  if (v1)
  {
    if (!*((unsigned char *)this + 112))
    {
      CFArrayRef v2 = (const __CFArray *)TFSInfo::IterationFullSetOfPropertyKeys(this);
      CFDictionaryRef v3 = CFURLCopyResourcePropertiesForKeys(v1, v2, 0);
      return (TFSInfo *)TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef((const void **)&v3);
    }
  }
  return this;
}

uint64_t TFSInfo::IterationFullSetOfPropertyKeys(TFSInfo *this)
{
  {
    TFSInfo::IterationFullSetOfPropertyKeys(void)::fullSetOfPropertyKeys = TFSInfo::IterationFullSetOfPropertyKeys(void)::$_0::operator()();
  }
  return TFSInfo::IterationFullSetOfPropertyKeys(void)::fullSetOfPropertyKeys;
}

void sub_1D344BB0C(_Unwind_Exception *a1)
{
}

CFIndex TFSInfo::Initialize(TFSInfo *a1, os_unfair_lock_s **a2, const TString *a3)
{
  return TFSInfo::Initialize(a1, *a2, a3);
}

CFIndex TFSInfo::Initialize(TFSInfo *this, os_unfair_lock_s *a2, const TString *a3)
{
  if (!a2) {
    return 4294959224;
  }
  uint64_t v6 = a2 + 25;
  os_unfair_lock_lock(a2 + 25);
  uint64_t v7 = *(const void **)&a2[4]._os_unfair_lock_opaque;
  uint64_t v14 = v7;
  if (v7)
  {
    CFRetain(v7);
    os_unfair_lock_unlock(v6);
    CFURLRef v8 = CFURLCreateFilePathURL(0, (CFURLRef)v7, 0);
    CFURLRef v13 = v8;
    if (v8)
    {
      URLAppendingNameToDirectoryCFURLRef URL = TCFURLInfo::CreateURLAppendingNameToDirectoryURL(v8, (const void **)&a3->fString.fRef, 0);
      CFURLRef v12 = URLAppendingNameToDirectoryURL;
      if (URLAppendingNameToDirectoryURL) {
        CFIndex v10 = TFSInfo::initialize((uint64_t)this, URLAppendingNameToDirectoryURL, 0, 1, 1, 1, 0);
      }
      else {
        CFIndex v10 = 4294959238;
      }
      TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v12);
    }
    else
    {
      CFIndex v10 = 4294959238;
    }
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v13);
  }
  else
  {
    os_unfair_lock_unlock(v6);
    CFIndex v10 = 4294959224;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v14);
  return v10;
}

void sub_1D344BC24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  CFDictionaryRef v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v5 = va_arg(va2, const void *);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va1);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(const void **a1)
{
  CFArrayRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void TNode::FindOrCreateChild(TNode *a1@<X0>, TFSInfo **a2@<X1>, TNodePtr *a3@<X8>)
{
  TNodePtr::TNodePtr(&v31, a1);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)&v34, &v31, 0);

  TChildrenList::FindRenamedChild(*((void *)a1 + 7), a2, a3);
  uint64_t v6 = TNodeFromFINode(a3->fFINode);
  fFINode = a3->fFINode;
  if (v6)
  {
    CFURLRef v8 = (TNode *)TNodeFromFINode(fFINode);
    TNode::FetchAdditionalPropertiesForSync(v8, a2, 1);
    v31.fFINode = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v9 = TNodeFromFINode(a3->fFINode);
    TNode::ReconcileInternalProperties(v9, a2, &v31, 1);
    TNodeEventPtrs::SendNotifications((id **)&v31);
    id v35 = (FINode *)&v31;
    std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v35);
    TNode::StPopulating::~StPopulating((FINode **)&v34);
    return;
  }

  TNode::StPopulating::~StPopulating((FINode **)&v34);
  TNodePtr::TNodePtr(&v31, a1);
  v34.fData.__impl_.__data = 0uLL;
  TNode::CreateNode(a3, &v31, a2, &v34);
  if (v34.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v34.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer);
  }

  TNode::AddChild(a1, a3);
  uint64_t v10 = TNodeFromFINode(a3->fFINode);
  unsigned int v11 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v10);
  os_unfair_lock_lock(v11);
  uint64_t v13 = *(void *)(v10 + 16);
  CFURLRef v12 = *(std::__shared_weak_count **)(v10 + 24);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v11);
  uint64_t v14 = (os_unfair_lock_s *)(v13 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
  int v15 = *(_DWORD *)(v13 + 115);
  os_unfair_lock_unlock(v14);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  int v16 = a3->fFINode;
  if ((v15 & 0x100) == 0)
  {
    uint64_t v17 = TNodeFromFINode(v16);
    uint64_t v18 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v17);
    os_unfair_lock_lock(v18);
    uint64_t v20 = *(void *)(v17 + 16);
    id v19 = *(std::__shared_weak_count **)(v17 + 24);
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v18);
      int v21 = *(unsigned __int8 *)(v20 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      if (!v21) {
        return;
      }
    }
    else
    {
      os_unfair_lock_unlock(v18);
      if (!*(unsigned char *)(v20 + 112)) {
        return;
      }
    }
    int v26 = (TNode *)TNodeFromFINode(a3->fFINode);
    v34.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = 0;
    int v27 = (TGlobalNodes *)TNode::CopyURL(v26, (const __CFURL **)&v34);
    v31.fFINode = (FINode *)v34.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
    TGlobalNodes::RootNode((uint64_t *)&v35, v27);
    uint64_t v28 = TNodeFromFINode(v35);
    TPropertyValue::TPropertyValue<__CFURL const*>((uint64_t)&v34, (const void **)&v31.fFINode);
    TNode::RequestInternalTask(v28, 1001, &v34, 0);
    TPropertyValue::~TPropertyValue(&v34);

    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v31.fFINode);
    return;
  }
  uint64_t v22 = TNodeFromFINode(v16);
  BOOL v23 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v22);
  os_unfair_lock_lock(v23);
  BOOL v25 = *(TFSInfo **)(v22 + 16);
  uint64_t v24 = *(std::__shared_weak_count **)(v22 + 24);
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v23);
  TFSInfo::GetVolumeID(v25, &v29);
  TNode::GetVolumeNode((TGlobalNodes *)&v29, &v30);

  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v29);
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
}

void sub_1D344BF50(_Unwind_Exception *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, TPropertyValue *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a15);

  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a12);
  _Unwind_Resume(a1);
}

void TNode::AddChild(TNode *this, TNodePtr *a2)
{
  BOOL v22 = 0;
  TNodePtr::TNodePtr(&v14, this);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)&v20, &v14, 0);

  TNode::AddNewChild((uint64_t *)&v14, this, a2, &v22, 0, 0);
  TNodePtr::operator=((void **)&a2->fFINode, (void **)&v14.fFINode);

  TNode::StPopulating::~StPopulating(&v20);
  if (!v22) {
    return;
  }
  uint64_t v4 = TNodeFromFINode(a2->fFINode);
  uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
  os_unfair_lock_lock(v5);
  uint64_t v7 = *(void *)(v4 + 16);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 24);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  if (*(unsigned char *)(v7 + 112) != 27)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v7 + 96));
    uint64_t v8 = *(void *)(v7 + 80);
    if (v8
      && (os_unfair_lock_lock((os_unfair_lock_t)(v8 + 72)),
          int v9 = *(unsigned __int8 *)(v8 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 72)),
          v9 == 1))
    {
      uint64_t v10 = (FIProviderDomain *)*(id *)(v8 + 24);
    }
    else
    {
      uint64_t v10 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 96));
    id v19 = v10;
    if (v10)
    {
      if ([(FIProviderDomain *)v10 isUsingFPFS])
      {
        unsigned int v11 = [(FIProviderDomain *)v10 rootURL];
        if (!v11)
        {
LABEL_20:

          goto LABEL_21;
        }
      }
      TGlobalNodes::AllProvidersNode(&v18);
      CFURLRef v12 = (TNode *)TNodeFromFINode(v18);
      if ((TNode::IsInitialPopulating(v12) & 1) == 0)
      {
        TFSInfo::GetFPItem((TFSInfo *)v7);
        uint64_t v17 = (FPItem *)objc_claimAutoreleasedReturnValue();
        LOBYTE(v16.fFINode) = 1;
        std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong}&,FPItem * {__strong}&,BOOL,void>(&v19, &v17, (unsigned __int8 *)&v16, &v20);
        v14.fFINode = 0;
        int v15 = 0;
        TNode::CreateNode(&v16, &v18, &v20, &v14);
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
        }
        uint64_t v13 = (TNode *)TNodeFromFINode(v18);
        TNode::AddChild(v13, &v16);

        if (v21) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v21);
        }
      }
      uint64_t v10 = v19;
      goto LABEL_20;
    }
  }
LABEL_21:
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  if (v22) {
    TNode::SendNotification(this, 3, (id *)&a2->fFINode, 0, 0);
  }
}

void sub_1D344C254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, void *a12, void *a13, void *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }

  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  _Unwind_Resume(a1);
}

const void **TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(const void **a1)
{
  CFArrayRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void TChildrenList::FindRenamedChild(uint64_t a1@<X0>, TFSInfo **a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v5 = *a2;
  if (*((unsigned char *)*a2 + 112))
  {
    IsFPCFArrayRef v2 = TFSInfo::IsFPv2(*a2, 1);
    uint64_t v8 = *a2;
    if (IsFPv2)
    {
      TFSInfo::GetFPItem(*a2);
      int v27 = (FPItem *)objc_claimAutoreleasedReturnValue();
      TChildrenList::FindByFPItem((TChildrenList *)a1, v27, a3);
LABEL_4:

      return;
    }
    if (*((unsigned char *)v8 + 112) == 27)
    {
      uint64_t v17 = (os_unfair_lock_s *)((char *)v8 + 96);
      os_unfair_lock_lock((os_unfair_lock_t)v8 + 24);
      uint64_t v18 = *((void *)v8 + 10);
      if (v18
        && (os_unfair_lock_lock((os_unfair_lock_t)(v18 + 72)),
            int v19 = *(unsigned __int8 *)(v18 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v18 + 72)),
            v19 == 1))
      {
        id v20 = *(id *)(v18 + 24);
      }
      else
      {
        id v20 = 0;
      }
      os_unfair_lock_unlock(v17);
      int v27 = [v20 domain];

      if ([(FPItem *)v27 isiCloudDriveProvider])
      {
        int v21 = *(FINode ***)(a1 + 64);
        BOOL v22 = *(FINode ***)(a1 + 72);
        while (v21 != v22)
        {
          BOOL v23 = (TNode *)TNodeFromFINode(*v21);
          uint64_t v24 = TNode::GetFIProvider(v23);
          BOOL v25 = [v24 domain];

          if ([v25 isiCloudDriveProvider])
          {
            int v26 = IsDefaultFPDomain(v27);
            if (v26 != IsDefaultFPDomain((FPProviderDomain *)v25))
            {
              a3->fFINode = *v21;

              goto LABEL_4;
            }
          }

          ++v21;
        }
      }
    }
    goto LABEL_32;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 25);
  int v9 = (const void *)*((void *)v5 + 2);
  CFTypeRef cf1 = v9;
  if (!v9)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)v5 + 25);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf1);
    goto LABEL_32;
  }
  CFRetain(v9);
  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 25);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf1);
  uint64_t v10 = *(FINode ***)(a1 + 64);
  unsigned int v11 = *(FINode ***)(a1 + 72);
  if (v10 == v11)
  {
LABEL_32:
    TNodePtr::TNodePtr(a3, 0);
    return;
  }
  while (1)
  {
    uint64_t v12 = TNodeFromFINode(*v10);
    uint64_t v13 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v12);
    os_unfair_lock_lock(v13);
    uint64_t v15 = *(void *)(v12 + 16);
    TNodePtr v14 = *(std::__shared_weak_count **)(v12 + 24);
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v13);
    os_unfair_lock_lock((os_unfair_lock_t)(v15 + 100));
    TNodePtr v16 = *(const void **)(v15 + 16);
    CFTypeRef cf1 = v16;
    if (v16) {
      CFRetain(v16);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v15 + 100));
    if (cf1)
    {
      if (CFEqual(cf1, v9)) {
        break;
      }
    }
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf1);
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
    if (++v10 == v11) {
      goto LABEL_32;
    }
  }
  a3->fFINode = *v10;
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf1);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
}

void sub_1D344C5E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, char a10)
{
  _Unwind_Resume(a1);
}

CFURLRef TCFURLInfo::CreateURLAppendingNameToDirectoryURL(TCFURLInfo *this, const void **a2, const TString *a3)
{
  Boolean v3 = a3;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!CFURLGetFileSystemRepresentation(this, 1u, buffer, 1024)) {
    return 0;
  }
  CFStringRef v5 = (const __CFString *)RetainCF<__CFString const*>(a2);
  if (v5)
  {
    CFTypeRef v6 = CFAutorelease(v5);
    CFStringRef v5 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v6);
  }
  if (!CFStringGetCString(v5, __source, 1024, 0x8000100u)
    || strlen((const char *)buffer) >= 2 && strlcat((char *)buffer, "/", 0x400uLL) > 0x3FF
    || strlcat((char *)buffer, __source, 0x400uLL) > 0x3FF)
  {
    return 0;
  }
  CFIndex v8 = strlen((const char *)buffer);
  return CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], buffer, v8, v3);
}

void TPathName::VolumesDirectory(TString *a1@<X8>)
{
  {
    operator new();
  }
  Boolean v3 = (TString **)TPathName::VolumesDirectory(void)::volumes;
  a1->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *v3);
}

void sub_1D344C81C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

void TPathName::UsersDirectory(TString *a1@<X8>)
{
  {
    operator new();
  }
  Boolean v3 = (TString **)TPathName::UsersDirectory(void)::users;
  a1->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *v3);
}

void sub_1D344C90C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

void TNode::SecondParent(TNode *this@<X0>, TNodePtr *a2@<X8>)
{
  char v3 = atomic_load((unsigned __int16 *)this + 40);
  if ((v3 & 2) != 0)
  {
    uint64_t v5 = TNode::FirmlinkParents(this);
    TNodePtr::TNodePtr(&v6, this);
    uint64_t v7 = &v6;
    a2->fFINode = (FINode *)*((id *)std::__hash_table<std::__hash_value_type<TNodePtr,TNodePtr>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,TNodePtr>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,TNodePtr>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,TNodePtr>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr&&>,std::tuple<>>(v5, &v6.fFINode, (uint64_t)&std::piecewise_construct, (id **)&v7)+ 3);
  }
  else
  {
    TNodePtr::TNodePtr(a2, 0);
  }
}

void sub_1D344CA0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void TNode::GetVolumeNode(TGlobalNodes *a1@<X0>, TNodePtr *a2@<X8>)
{
  TGlobalNodes::RootNode((uint64_t *)&v16, a1);
  if (TNodeFromFINode(v16.fFINode))
  {
    TNode::StPopulating::StPopulating((TNode::StPopulating *)v15, &v16, 0);
    uint64_t v4 = *(void *)(TNodeFromFINode(v16.fFINode) + 56);
    if (v4) {
      uint64_t v5 = (FINode ***)(v4 + 64);
    }
    else {
      uint64_t v5 = (FINode ***)&TNode::GetChildren(void)const::sEmptyList;
    }
    TNodePtr v6 = *v5;
    uint64_t v7 = v5[1];
    if (*v5 != v7)
    {
      do
      {
        uint64_t v8 = TNodeFromFINode(*v6);
        int v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
        os_unfair_lock_lock(v9);
        uint64_t v11 = *(TFSInfo **)(v8 + 16);
        uint64_t v10 = *(std::__shared_weak_count **)(v8 + 24);
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v9);
        TFSInfo::GetVolumeID(v11, &cf1);
        if (v10) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v10);
        }
        uint64_t v12 = (TNode *)TNodeFromFINode(*v6);
        if (!TNode::VirtualType(v12))
        {
          unint64_t v13 = *(void *)a1;
          if (cf1 && v13)
          {
            if (CFEqual(cf1, (CFTypeRef)v13)) {
              goto LABEL_20;
            }
          }
          else if (!((unint64_t)cf1 | v13))
          {
LABEL_20:
            a2->fFINode = *v6;
            TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf1);
            TNode::StPopulating::~StPopulating(v15);
            goto LABEL_19;
          }
        }
        TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf1);
        ++v6;
      }
      while (v6 != v7);
    }
    TNode::StPopulating::~StPopulating(v15);
  }
  TNodePtr::TNodePtr(a2, 0);
LABEL_19:
}

void sub_1D344CB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, FINode *a11, uint64_t a12, uint64_t a13, id a14)
{
  _Unwind_Resume(a1);
}

void sub_1D344CC70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<TNodePtr>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<TNodePtr>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1D344CCF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void std::__introsort<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,false>(id *a1, void **a2, uint64_t a3, char a4)
{
  uint64_t v8 = a2;
  int v9 = a1;
  TString v56 = a2;
  unsigned int v57 = a1;
  while (1)
  {
    uint64_t v10 = (char *)v8 - (char *)v9;
    uint64_t v11 = v8 - v9;
    if (!(!v5 & v4))
    {
      switch(v11)
      {
        case 0:
        case 1:
          return;
        case 2:
          TString v56 = v8 - 1;
          if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v8 - 1, (FINode **)v9)) {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v57, &v56);
          }
          break;
        case 3:
          TString v56 = v8 - 1;
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v9, v9 + 1, v8 - 1);
          break;
        case 4:
          TString v56 = v8 - 1;
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v9, v9 + 1, v9 + 2, v8 - 1);
          break;
        case 5:
          TString v56 = v8 - 1;
          std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,0>(v9, v9 + 1, v9 + 2, v9 + 3, v8 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v10 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v9 != v8)
      {
        TString v55 = v8;
        int64_t v34 = (unint64_t)(v11 - 2) >> 1;
        int64_t v35 = v34;
        do
        {
          int64_t v36 = v35;
          if (v34 >= v35)
          {
            uint64_t v37 = (2 * v35) | 1;
            TNodePtr v38 = &v9[v37];
            if (2 * v35 + 2 < v11
              && TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v9[v37], (FINode **)v38 + 1))
            {
              ++v38;
              uint64_t v37 = 2 * v36 + 2;
            }
            uint64_t v39 = &v9[v36];
            if (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v38, (FINode **)v39))
            {
              TNodePtr::TNodePtr(&v60, &v9[v36]);
              do
              {
                TNodePtr v40 = v38;
                TNodePtr::operator=(v39, v38);
                if (v34 < v37) {
                  break;
                }
                uint64_t v41 = (2 * v37) | 1;
                TNodePtr v38 = &v9[v41];
                uint64_t v37 = 2 * v37 + 2;
                if (v37 < v11)
                {
                  if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v9[v41], (FINode **)v38 + 1))
                  {
                    ++v38;
                  }
                  else
                  {
                    uint64_t v37 = v41;
                  }
                }
                else
                {
                  uint64_t v37 = v41;
                }
                uint64_t v39 = v40;
              }
              while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v38, (FINode **)&v60));
              TNodePtr::operator=(v40, (void **)&v60);
            }
          }
          int64_t v35 = v36 - 1;
        }
        while (v36);
        uint64_t v42 = (unint64_t)v10 >> 3;
        int v43 = v55;
        do
        {
          TNodePtr::TNodePtr(&v59, v9);
          uint64_t v44 = 0;
          uint64_t v45 = v9;
          do
          {
            int v46 = &v45[v44 + 1];
            uint64_t v47 = (2 * v44) | 1;
            uint64_t v48 = 2 * v44 + 2;
            if (v48 < v42
              && TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v45[v44 + 1], (FINode **)&v45[v44 + 2]))
            {
              ++v46;
              uint64_t v47 = v48;
            }
            TNodePtr::operator=(v45, v46);
            uint64_t v45 = v46;
            uint64_t v44 = v47;
          }
          while (v47 <= (uint64_t)((unint64_t)(v42 - 2) >> 1));
          if (v46 == --v43)
          {
            TNodePtr::operator=(v46, (void **)&v59);
          }
          else
          {
            TNodePtr::operator=(v46, v43);
            TNodePtr::operator=(v43, (void **)&v59);
            uint64_t v49 = (char *)v46 - (char *)v9 + 8;
            if (v49 >= 9)
            {
              unint64_t v50 = (((unint64_t)v49 >> 3) - 2) >> 1;
              uint64_t v51 = &v9[v50];
              if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v51, (FINode **)v46))
              {
                TNodePtr::TNodePtr(&v60, v46);
                do
                {
                  uint64_t v52 = v51;
                  TNodePtr::operator=(v46, v51);
                  if (!v50) {
                    break;
                  }
                  unint64_t v50 = (v50 - 1) >> 1;
                  uint64_t v51 = &v9[v50];
                  int v46 = v52;
                }
                while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v51, (FINode **)&v60));
                TNodePtr::operator=(v52, (void **)&v60);
              }
            }
          }
        }
        while (v42-- > 2);
      }
      return;
    }
    unint64_t v12 = (unint64_t)v11 >> 1;
    unint64_t v13 = v8 - 1;
    if ((unint64_t)v10 < 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(&v9[v12], v9, v13);
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v9, &v9[v12], v13);
      uint64_t v14 = 8 * v12 - 8;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v57 + 1, (id *)((char *)v57 + v14), v56 - 2);
      uint64_t v15 = 8 * v12 + 8;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v57 + 2, (id *)((char *)v57 + v15), v56 - 3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>((id *)((char *)v57 + v14), &v57[v12], (id *)((char *)v57 + v15));
      uint64_t v60 = &v57[v12];
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v57, &v60);
    }
    --a3;
    if (a4)
    {
      TNodePtr v16 = v56;
    }
    else
    {
      TNodePtr v16 = v56;
      if (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v57 - 1, (FINode **)v57))
      {
        int v21 = v57;
        uint64_t v59 = v56;
        uint64_t v60 = v57;
        TNodePtr::TNodePtr(&v58, v57);
        if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v58, (FINode **)v56 - 1))
        {
          BOOL v22 = v21;
          do
            uint64_t v60 = ++v22;
          while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v58, (FINode **)v22));
        }
        else
        {
          BOOL v23 = v21 + 1;
          do
          {
            BOOL v22 = v23;
            uint64_t v60 = v23;
            if (v23 >= v56) {
              break;
            }
            BOOL v24 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v58, (FINode **)v23);
            BOOL v23 = v22 + 1;
          }
          while (!v24);
        }
        if (v22 < v56)
        {
          do
            uint64_t v59 = --v16;
          while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v58, (FINode **)v16));
        }
        if (v22 < v16)
        {
          do
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v60, &v59);
            do
              ++v60;
            while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v58, (FINode **)v60));
            do
              --v59;
            while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v58, (FINode **)v59));
            BOOL v22 = v60;
          }
          while (v60 < v59);
        }
        if (v22 - 1 != v21) {
          TNodePtr::operator=(v21, v22 - 1);
        }
        TNodePtr::operator=(v22 - 1, &v58);
        int v9 = v60;

LABEL_49:
        a4 = 0;
LABEL_50:
        unsigned int v57 = v9;
        goto LABEL_51;
      }
    }
    uint64_t v17 = v57;
    uint64_t v59 = v16;
    TNodePtr::TNodePtr(&v58, v57);
    uint64_t v18 = 0;
    do
      uint64_t v60 = &v17[++v18];
    while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v60, (FINode **)&v58));
    int v19 = &v17[v18];
    if (v18 == 1)
    {
      do
      {
        if (v19 >= v16) {
          break;
        }
        uint64_t v59 = --v16;
      }
      while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v16, (FINode **)&v58));
    }
    else
    {
      do
        uint64_t v59 = --v16;
      while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v16, (FINode **)&v58));
    }
    int v9 = &v17[v18];
    if (v19 < v16)
    {
      do
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v60, &v59);
        do
          ++v60;
        while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v60, (FINode **)&v58));
        do
          --v59;
        while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)v59, (FINode **)&v58));
        int v9 = v60;
      }
      while (v60 < v59);
    }
    if (v9 - 1 != v17) {
      TNodePtr::operator=(v17, v9 - 1);
    }
    TNodePtr::operator=(v9 - 1, &v58);

    if (v19 < v16) {
      goto LABEL_35;
    }
    int v20 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v57, v9 - 1);
    if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(v9, v56))
    {
      if (!v20)
      {
LABEL_35:
        std::__introsort<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,false>(v57, v9 - 1, a3, a4 & 1);
        goto LABEL_49;
      }
      goto LABEL_50;
    }
    if (v20) {
      return;
    }
    TString v56 = v9 - 1;
    int v9 = v57;
LABEL_51:
    uint64_t v8 = v56;
  }
  BOOL v25 = (FINode **)(v9 + 1);
  BOOL v27 = v9 == v8 || v25 == (FINode **)v8;
  if (a4)
  {
    if (!v27)
    {
      uint64_t v28 = 0;
      uint64_t v29 = v9;
      do
      {
        TNodePtr v30 = (FINode **)v29;
        uint64_t v29 = (id *)v25;
        if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v25, v30))
        {
          TNodePtr::TNodePtr(&v60, v29);
          uint64_t v31 = v28;
          while (1)
          {
            TNodePtr::operator=((id *)((char *)v9 + v31 + 8), (id *)((char *)v9 + v31));
            if (!v31) {
              break;
            }
            BOOL v32 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v60, (FINode **)((char *)v9 + v31 - 8));
            v31 -= 8;
            if (!v32)
            {
              uint64_t v33 = (id *)((char *)v9 + v31 + 8);
              goto LABEL_73;
            }
          }
          uint64_t v33 = v9;
LABEL_73:
          TNodePtr::operator=(v33, (void **)&v60);
        }
        BOOL v25 = (FINode **)(v29 + 1);
        v28 += 8;
      }
      while (v29 + 1 != v8);
    }
  }
  else if (!v27)
  {
    do
    {
      long long v54 = (id *)v25;
      if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v25, (FINode **)v9))
      {
        TNodePtr::TNodePtr(&v60, v54);
        do
        {
          TNodePtr::operator=(v9 + 1, v9);
          --v9;
        }
        while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v60, (FINode **)v9));
        TNodePtr::operator=(v9 + 1, (void **)&v60);
      }
      BOOL v25 = (FINode **)(v54 + 1);
      int v9 = v54;
    }
    while (v54 + 1 != v8);
  }
}

void sub_1D344D494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

TDSNotifier **TNodeTask::GetNotifier@<X0>(TNodeTask *this@<X0>, TDSNotifier **a2@<X8>)
{
  *a2 = 0;
  char v3 = (TPropertyValue *)((char *)this + 24);
  uint64_t result = (TDSNotifier **)TPropertyValue::DataType((TPropertyValue *)this + 1);
  if (result == 1919247971)
  {
    uint64_t result = (TDSNotifier **)TPropertyValue::ReferenceCountedType(v3);
    if (result == 1852798054)
    {
      TPropertyValue::As<TDSNotifier *>(v3, (uint64_t)v5);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(a2, v5);
      return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v5);
    }
  }
  return result;
}

void sub_1D344D584(_Unwind_Exception *a1)
{
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t TNodeTask::GetNotificationOptions(TNodeTask *this)
{
  uint64_t v1 = (TPropertyValue *)((char *)this + 24);
  if (TPropertyValue::DataType((TPropertyValue *)this + 1) != 1919247971
    || TPropertyValue::ReferenceCountedType(v1) != 1852798054)
  {
    return 0;
  }
  TPropertyValue::As<TDSNotifier *>(v1, (uint64_t)v4);
  uint64_t v2 = *((unsigned int *)v4[0] + 8);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v4);
  return v2;
}

uint64_t TPropertyValue::DataType(TPropertyValue *this)
{
  unsigned int v1 = LOBYTE(this->fData.__impl_.__index) - 1;
  if (v1 > 0x16) {
    return 1853189228;
  }
  else {
    return *(unsigned int *)&aLoobynitrohsgn[4 * (char)v1];
  }
}

TDSNotifier **TPropertyValue::As<TDSNotifier *>@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  if (a1 && a1[4] == 19)
  {
    uint64_t v3 = *(void *)(*(void *)a1 + 8);
    if (v3) {
      TDSNotifier::AddPtrReference(*(TDSNotifier **)(*(void *)a1 + 8));
    }
    *(void *)a2 = v3;
    char v5 = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(void *)a2 = 0;
    char v5 = 0;
    *(_DWORD *)(a2 + 8) = -8050;
  }
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v5);
}

TPropertyValue *TPropertyValue::ReferenceCountedType(TPropertyValue *this)
{
  if (this)
  {
    if (this->fData.__impl_.__index == 19) {
      return (TPropertyValue *)*(unsigned int *)this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
    }
    else {
      return 0;
    }
  }
  return this;
}

void TFSVolumeInfo::CopyVolumeInfos(TFSVolumeInfo *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  uint64_t v3 = *(void **)(GetVolumeMap() + 16);
  if (v3)
  {
    while (1)
    {
      *(void *)&long long v6 = 0;
      char v4 = (std::__shared_weak_count *)v3[5];
      if (v4) {
        break;
      }
LABEL_10:
      uint64_t v3 = (void *)*v3;
      if (!v3) {
        goto LABEL_11;
      }
    }
    char v5 = std::__shared_weak_count::lock(v4);
    *((void *)&v6 + 1) = v5;
    if (v5)
    {
      *(void *)&long long v6 = v3[4];
      if (!(void)v6)
      {
LABEL_8:
        if (v5) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v5);
        }
        goto LABEL_10;
      }
    }
    else if (!(void)v6)
    {
      goto LABEL_8;
    }
    std::vector<std::shared_ptr<TFSVolumeInfo>>::push_back[abi:ne180100](a2, &v6);
    char v5 = (std::__shared_weak_count *)*((void *)&v6 + 1);
    goto LABEL_8;
  }
LABEL_11:
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
}

void sub_1D344D78C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void **std::vector<std::shared_ptr<TFSVolumeInfo>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<TFSVolumeInfo>>::__swap_out_circular_buffer(a1, v18);
    int v9 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer(v18);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    int v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1D344D8CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void **std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::shared_ptr<TCFURLInfo>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    char v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

uint64_t std::vector<std::shared_ptr<TFSVolumeInfo>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<TFSVolumeInfo>>,std::reverse_iterator<std::shared_ptr<TFSVolumeInfo>*>,std::reverse_iterator<std::shared_ptr<TFSVolumeInfo>*>,std::reverse_iterator<std::shared_ptr<TFSVolumeInfo>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<TFSVolumeInfo>>,std::reverse_iterator<std::shared_ptr<TFSVolumeInfo>*>,std::reverse_iterator<std::shared_ptr<TFSVolumeInfo>*>,std::reverse_iterator<std::shared_ptr<TFSVolumeInfo>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TFSVolumeInfo>>,std::reverse_iterator<std::shared_ptr<TFSVolumeInfo>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TFSVolumeInfo>>,std::reverse_iterator<std::shared_ptr<TFSVolumeInfo>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void TNodeEventPtrs::AddPropertyChanges(TNodeEventPtrs *a1, TNodePtr *a2, void *a3)
{
  uint64_t v3 = a3 + 1;
  char v4 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      TNodeEvent::CreateNodeEvent(2, (id *)&a2->fFINode, *((_DWORD *)v4 + 7), &v10);
      TNodeEventPtrs::AddEvent(a1, a2, &v10);

      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          char v4 = v8;
        }
        while (!v9);
      }
      char v4 = v8;
    }
    while (v8 != v3);
  }
}

void sub_1D344DB54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void TNodeEventPtrs::AddEvent(TNodeEventPtrs *this, const TNodePtr *a2, id *a3)
{
  uint64_t v8 = a2->fFINode;
  id v9 = *a3;
  unint64_t v5 = *((void *)this + 1);
  if (v5 >= *((void *)this + 2))
  {
    uint64_t v6 = std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__push_back_slow_path<std::pair<TNodePtr,TNodeEventPtr>>((uint64_t *)this, (id *)&v8);
  }
  else
  {
    TNodePtr::TNodePtr(*((void **)this + 1), (id *)&v8);
    *(void *)(v5 + 8) = v9;
    uint64_t v6 = v5 + 16;
  }
  *((void *)this + 1) = v6;
  id v7 = v9;
  id v9 = 0;
}

void sub_1D344DC04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
}

uint64_t std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__push_back_slow_path<std::pair<TNodePtr,TNodeEventPtr>>(uint64_t *a1, id *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  v14[4] = a1 + 2;
  if (v9) {
    id v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(v7, v9);
  }
  else {
    id v10 = 0;
  }
  unint64_t v11 = &v10[16 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v14[3] = &v10[16 * v9];
  TNodePtr::TNodePtr(v11, a2);
  *((void *)v11 + 1) = a2[1];
  v14[2] = v11 + 16;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1D344DCF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

uint64_t std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,TNodeEventPtr>,0>((void **)(i - 16));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,TNodeEventPtr>,0>(void **a1)
{
  uint64_t v2 = a1[1];
  a1[1] = 0;

  uint64_t v3 = *a1;
}

uint64_t std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void TNode::RequestSynchronize(const TNode *a1, int a2)
{
  int v5 = a2;
  TGlobalNodes::RootNode(&v4.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);
  uint64_t v3 = TNodeFromFINode((FINode *)v4.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);

  if ((const TNode *)v3 != a1)
  {
    v4.fData.__impl_.__index = 0;
    std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v4, &v5);
    TNode::RequestInternalTask(a1, 1000, &v4, 0);
    TPropertyValue::~TPropertyValue(&v4);
  }
}

void sub_1D344DECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
}

void ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2(uint64_t a1)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3321888768;
  v3[2] = ___ZZN21TClientChangeNotifier6WakeUpEvENK3__1clEv_block_invoke;
  v3[3] = &__block_descriptor_48_ea8_32c57_ZTSKZZN21TClientChangeNotifier6WakeUpEvENK3__1clEvEUlvE__e5_v8__0l;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v4 = v1;
    int v5 = v2;
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 32);
    int v5 = 0;
  }
  ExceptionSafeBlock(v3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1D344DF9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke(uint64_t a1)
{
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  v6[2] = ___ZZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEENK3__0clEv_block_invoke;
  v6[3] = &__block_descriptor_73_ea8_32c13_ZTS8TNodePtr40c47_ZTSRKNSt3__110shared_ptrI17TVolumeSyncThreadEE56c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE_e5_v8__0l;
  char v12 = *(unsigned char *)(a1 + 72);
  id v2 = *(id *)(a1 + 64);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  id v7 = v2;
  uint64_t v8 = v4;
  unint64_t v9 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v5 = *(std::__shared_weak_count **)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 48);
  unint64_t v11 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ExceptionSafeBlock(v6);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

void sub_1D344E098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, std::__shared_weak_count *a17)
{
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }

  _Unwind_Resume(a1);
}

void ExceptionSafeBlock(void *a1)
{
  id v2 = a1;
  uint64_t v1 = (void *)MEMORY[0x1D9436D80]();
  v2[2]();
}

TNodeTask *___ZZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEENK3__0clEv_block_invoke(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    id v2 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 32));
    TNode::ClearSyncRequested(v2);
  }
  uint64_t result = (TNodeTask *)TVolumeSyncThread::SynchingCanceled(*(TVolumeSyncThread **)(a1 + 40));
  if ((result & 1) == 0)
  {
    return TNode::HandleNodeRequest((id **)(a1 + 56));
  }
  return result;
}

TNodeTask *TNode::HandleNodeRequest(id **a1)
{
  id v2 = *a1;
  if (v2 && *((_DWORD *)v2 + 13) != 1003)
  {
    TNodeTask::SetRequestStatus((TNodeTask *)v2, 1002);
    uint64_t v4 = (FINode *)**a1;
    int v3 = 0;
    v10.fFINode = v4;
    int v5 = *((_DWORD *)*a1 + 4);
    int v6 = 1;
    switch(v5)
    {
      case 1000:
        TNode::HandleSync(a1, &v10.fFINode);
        goto LABEL_27;
      case 1001:
        int v6 = 0;
        goto LABEL_15;
      case 1002:
      case 1004:
      case 1005:
      case 1006:
      case 1013:
      case 1014:
      case 1015:
      case 1016:
      case 1017:
      case 1018:
      case 1020:
      case 1022:
      case 1025:
      case 1026:
      case 1027:
        break;
      case 1003:
        TNode::HandleRegisterForNotification((TNodeTask **)a1, &v10.fFINode);
        goto LABEL_27;
      case 1007:
        TNode::HandleMarkAsUsed((uint64_t)v4, &v10.fFINode);
        goto LABEL_27;
      case 1008:
        int Property = TNode::HandleSubscribeWithKQueue((uint64_t)v4, &v10.fFINode);
        goto LABEL_32;
      case 1009:
        int Property = TNode::HandleUnsubscribeWithKQueue((uint64_t)v4, &v10.fFINode);
        goto LABEL_32;
      case 1010:
        int Property = TNode::HandleVolumeDeleted((uint64_t)v4, &v10.fFINode);
        goto LABEL_32;
      case 1011:
        TNodeFromFINode(v4);
        goto LABEL_27;
      case 1012:
        TFSInfo::MarkAsUsed(0);
        int v3 = 0;
        break;
      case 1019:
        uint64_t v8 = (TNode *)TNodeFromFINode(v4);
        TNode::DoExternalUnRegistration(v8);
        goto LABEL_27;
      case 1021:
        TNode::HandleRegisterInternalNotificationTask((uint64_t)v4, &v10.fFINode);
        goto LABEL_27;
      case 1023:
        TNode::HandleSyncComputerName((TNode *)v4);
        goto LABEL_27;
      case 1024:
LABEL_15:
        int Property = TNode::HandleVolumeAdded((uint64_t)a1, v6);
LABEL_32:
        int v3 = Property;
        break;
      case 1028:
        TNode::HandleFPProviderError((uint64_t)v4, &v10.fFINode);
LABEL_27:
        int v3 = 0;
        break;
      default:
        switch(v5)
        {
          case 1:
            int Property = TNode::HandleFetchProperty((uint64_t)a1, &v10.fFINode);
            goto LABEL_32;
          case 2:
            int Property = TNode::HandleStoreProperty((uint64_t)a1, &v10.fFINode);
            goto LABEL_32;
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 9:
            goto LABEL_33;
          case 8:
            int Property = TNode::HandleFetchBookmarkData((uint64_t *)a1, &v10);
            goto LABEL_32;
          case 10:
            int Property = TNode::HandleResolveAlias(a1, &v10.fFINode);
            goto LABEL_32;
          case 11:
            int Property = TNode::HandleFetchNodeRequest(a1);
            goto LABEL_32;
          default:
            switch(v5)
            {
              case ' ':
                int Property = TNode::HandleOpenScreenShareRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              case '!':
                int Property = TNode::HandleOpenServerRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              case '""':
                int Property = TNode::HandleDisconnectShareRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              case '#':
                int Property = TNode::HandleAddServerToSidebarRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              case '$':
                int Property = TNode::HandleRemoveServerFromSidebarRequest((uint64_t)a1, &v10.fFINode);
                goto LABEL_32;
              default:
                goto LABEL_33;
            }
        }
    }
LABEL_33:

    id v2 = *a1;
  }
  else
  {
    int v3 = -128;
  }
  return TNodeTask::SetRequestStatus((TNodeTask *)v2, v3);
}

void sub_1D344E414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

TNodeTask *TNodeTask::SetRequestStatus(TNodeTask *this, int a2)
{
  if (*((int *)this + 13) >= 1) {
    *((_DWORD *)this + 13) = a2;
  }
  return this;
}

void TNode::RequestInternalTask(const TNode *a1, int a2, TPropertyValue *a3, int a4)
{
  v9.fFINode = 0;
  std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,decltype(nullptr),void>(&v10);
  uint64_t v8 = v10;
  TNodePtr::TNodePtr(&v9, a1);
  TNodeTask::SetRequest(v8, (id *)&v9.fFINode, a2, 0, a3, a4);

  TNode::PostNodeTaskRequest((uint64_t)a1, &v10);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
}

void sub_1D344E4E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,decltype(nullptr),void>@<X0>(void *a1@<X8>)
{
  id v2 = operator new(0x50uLL);
  uint64_t result = std::__shared_ptr_emplace<TNodeTask>::__shared_ptr_emplace[abi:ne180100]<decltype(nullptr),std::allocator<TNodeTask>,0>(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1D344E554(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TNodeTask>::__shared_ptr_emplace[abi:ne180100]<decltype(nullptr),std::allocator<TNodeTask>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB3C8;
  std::construct_at[abi:ne180100]<TNodeTask,decltype(nullptr),TNodeTask*>((uint64_t)(a1 + 3));
  return a1;
}

void sub_1D344E5B0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<TNodeTask,decltype(nullptr),TNodeTask*>(uint64_t a1)
{
  int v3 = 0;
  TNodeTask::TNodeTask(a1);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v3);
  return a1;
}

void sub_1D344E604(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  _Unwind_Resume(a1);
}

void TNode::PostNodeTaskRequest(uint64_t a1, void *a2)
{
  TNode::GetVolumeInfo((TNode *)a1, &v26);
  uint64_t v4 = v26;
  if (!v26) {
    goto LABEL_20;
  }
  int v5 = *(_DWORD *)(*a2 + 16);
  VolumeSyncThread = TFSVolumeInfo::GetVolumeSyncThread(v26, &v25);
  if ((v5 & 0xFFFFFFFD) == 1)
  {
LABEL_3:
    TFSVolumeInfo::GetPropertyUpdateThread(v4, &v24);
    long long v7 = v24;
    long long v24 = 0uLL;
    uint64_t v8 = (std::__shared_weak_count *)*((void *)&v25 + 1);
    long long v25 = v7;
    if (v8)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      if (*((void *)&v24 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v24 + 1));
      }
    }
    goto LABEL_16;
  }
  if (v5 != 1024 && v5 != 1001)
  {
    if (v5 != 1000) {
      goto LABEL_16;
    }
    TNodePtr v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)VolumeSyncThread);
    os_unfair_lock_lock(v9);
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v10 = *(std::__shared_weak_count **)(a1 + 24);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v9);
    char v12 = (os_unfair_lock_s *)(v11 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v11 + 100));
    int v13 = *(_DWORD *)(v11 + 115);
    os_unfair_lock_unlock(v12);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
    if ((v13 & 0x20) != 0) {
      goto LABEL_16;
    }
    goto LABEL_3;
  }
  long long v14 = (uint64_t *)(*a2 + 24);
  *(void *)&long long v24 = 0;
  long long v15 = TPropertyValue::As<__CFURL const*>(v14, (uint64_t **)&v24);
  if ((TCFURLInfo::GetBooleanProperty((TCFURLInfo *)v15, (const __CFString *)*MEMORY[0x1E4F1D870], v16) & 1) == 0)
  {
    {
      TNode::PostNodeTaskRequest(std::shared_ptr<TNodeTask> const&)const::remoteMountQueue = (uint64_t)dispatch_queue_create("Remote Volumes Mounts", 0);
    }
    long long v17 = TNode::PostNodeTaskRequest(std::shared_ptr<TNodeTask> const&)const::remoteMountQueue;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEE_block_invoke;
    block[3] = &__block_descriptor_56_ea8_32c75_ZTSKZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEEE3__0_e5_v8__0l;
    uint64_t v18 = *a2;
    int v19 = (std::__shared_weak_count *)a2[1];
    if (v19)
    {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v21 = v18;
      BOOL v22 = v19;
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      int v23 = v5;
      dispatch_async(v17, block);
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
    }
    else
    {
      uint64_t v21 = v18;
      BOOL v22 = 0;
      int v23 = v5;
      dispatch_async((dispatch_queue_t)TNode::PostNodeTaskRequest(std::shared_ptr<TNodeTask> const&)const::remoteMountQueue, block);
    }
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
    }
    goto LABEL_18;
  }
LABEL_16:
  if ((void)v25) {
    TNodeTask::PostNodeTaskRequest((uint64_t)a2, (uint64_t)&v25);
  }
LABEL_18:
  if (*((void *)&v25 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v25 + 1));
  }
LABEL_20:
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
}

void sub_1D344E870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  BOOL v22 = *(std::__shared_weak_count **)(v20 - 56);
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  }
  _Unwind_Resume(exception_object);
}

void TNode::GetVolumeInfo(TNode *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v5 = *((void *)this + 1);
  *a2 = *(void *)this;
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
}

TFSVolumeInfo *TFSVolumeInfo::GetVolumeSyncThread@<X0>(TFSVolumeInfo *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 41);
  *a2 = *((void *)this + 40);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t TNodeTask::TNodeTask(uint64_t a1, TDSNotifier **a2)
{
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 48) = 0x3E900000000;
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=((TDSNotifier **)(a1 + 8), *a2);
  return a1;
}

void sub_1D344E984(_Unwind_Exception *a1)
{
  TPropertyValue::~TPropertyValue(v1 + 1);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v2);

  _Unwind_Resume(a1);
}

void TNodeTask::PostNodeTaskRequest(uint64_t a1, uint64_t a2)
{
  if ((TVolumeSyncThread::SynchingCanceled(*(TVolumeSyncThread **)a2) & 1) == 0)
  {
    uint64_t v4 = (FINode *)**(id **)a1;
    uint64_t v5 = *(id **)a1;
    if (*(_DWORD *)(*(void *)a1 + 16) != 1000) {
      goto LABEL_9;
    }
    unsigned int v27 = 0;
    int v6 = TPropertyValue::As<NodeRequestOptions>((unsigned int *)v5 + 6, &v27);
    if ((v6 & 0x80000) != 0) {
      goto LABEL_9;
    }
    uint64_t v7 = TNodeFromFINode(v4);
    uint64_t v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v7);
    os_unfair_lock_lock(v8);
    uint64_t v10 = *(void *)(v7 + 16);
    TNodePtr v9 = *(std::__shared_weak_count **)(v7 + 24);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v8);
    uint64_t v11 = (os_unfair_lock_s *)(v10 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
    int v12 = *(_DWORD *)(v10 + 115);
    os_unfair_lock_unlock(v11);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
    if ((v12 & 0x20) != 0)
    {
      uint64_t v20 = TNodeFromFINode(v4);
      if (TNode::RedundantSync(v20, v6))
      {
LABEL_26:

        return;
      }
      char v13 = 1;
    }
    else
    {
LABEL_9:
      char v13 = 0;
    }
    long long v14 = NodeEventRefFromNodeEvent(*(id **)a2);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEE_block_invoke;
    block[3] = &__block_descriptor_80_ea8_32c98_ZTSKZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEE3__0_e5_v8__0l;
    CFStringRef v16 = *(id **)a2;
    long long v15 = *(std::__shared_weak_count **)(a2 + 8);
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v18 = *(id **)a1;
    long long v17 = *(std::__shared_weak_count **)(a1 + 8);
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v19 = v4;
    void block[4] = v16;
    BOOL v22 = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v23 = v18;
    long long v24 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v25 = v19;
    char v26 = v13;
    dispatch_async(v14, block);
    if (v17) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
    }
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }

    if (v24) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v24);
    }
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
    }
    goto LABEL_26;
  }
}

void sub_1D344EBB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TVolumeSyncThread::SynchingCanceled(TVolumeSyncThread *this)
{
  return *((unsigned __int8 *)this + 9);
}

id NodeEventRefFromNodeEvent(id *a1)
{
  return *a1;
}

unint64_t TPropertyValue::As<NodeRequestOptions>(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2 = a1[4];
  unsigned int v3 = v2;
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_47;
      }
      unsigned int v3 = *a2;
      unint64_t v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 2:
      if (v2 != 2) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 3:
      if (v2 != 3) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 4:
      if (v2 != 4) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 5:
      if (v2 != 5) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 6:
      if (v2 != 6) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 7:
      if (v2 != 7) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 8:
      if (v2 != 8) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 9:
      goto LABEL_42;
    case 10:
      if (v2 != 10) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 11:
      if (v2 != 11) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 12:
      if (v2 != 12) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 13:
      if (v2 != 13) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 14:
      if (v2 != 14) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 15:
      if (v2 != 15) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 16:
      if (v2 != 16) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 17:
      if (v2 != 17) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 18:
      if (v2 != 18) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 19:
      if (v2 != 19) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 20:
      if (v2 != 20) {
        goto LABEL_47;
      }
LABEL_42:
      unint64_t v4 = 0xFFFFE08E00000000;
      unsigned int v3 = *a2;
      break;
    case 21:
      if (v2 == 21) {
        goto LABEL_44;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 23:
      if (v2 != 23) {
LABEL_47:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_44:
      unint64_t v4 = 0;
      unsigned int v3 = *a1;
      break;
    default:
      unint64_t v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | v3;
}

TPropertyValue *TNodeTask::SetRequest(uint64_t a1, id *a2, int a3, int a4, TPropertyValue *a5, int a6)
{
  TNodeTask::ResetRequest((TNodeTask *)a1);
  objc_storeStrong((id *)a1, *a2);
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = a4;
  uint64_t result = TPropertyValue::operator=((TPropertyValue *)(a1 + 24), a5);
  *(_DWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 52) = 1001;
  return result;
}

void TNodeTask::ResetRequest(TNodeTask *this)
{
  TNodePtr::TNodePtr((TNodePtr *)&v3, 0);
  TNodePtr::operator=((void **)this, (void **)&v3);

  unsigned int v2 = (TDSNotifier *)*((void *)this + 1);
  if (v2) {
    TDSNotifier::RemovePtrReference(v2);
  }
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  memset(&v3, 0, sizeof(v3));
  TPropertyValue::operator=((TPropertyValue *)this + 1, (uint64_t)&v3);
  TPropertyValue::~TPropertyValue(&v3);
  *((void *)this + 6) = 0;
}

TPropertyValue *TPropertyValue::operator=(TPropertyValue *a1, uint64_t a2)
{
  if (a1 != (TPropertyValue *)a2) {
    TPropertyValue::MoveFrom(a1, a2);
  }
  return a1;
}

TPropertyValue *TPropertyValue::MoveFrom(TPropertyValue *result, uint64_t a2)
{
  if (result != (TPropertyValue *)a2)
  {
    uint64_t v3 = (uint64_t)result;
    TPropertyValue::Release(result);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>>(v3, a2);
    return (TPropertyValue *)std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>(a2);
  }
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 16);
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F2ABC010 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 16) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F2ABC0D0 + v4))(&v5, result, a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16)) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate>(result);
  }
  return result;
}

void __destroy_helper_block_ea8_32c98_ZTSKZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEE3__0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

uint64_t TNode::RedundantSync(uint64_t a1, int a2)
{
  if ((a2 & 0x400000) != 0) {
    return 0;
  }
  else {
    return (atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 4u) >> 2) & 1;
  }
}

TNode *TNode::ClearSyncRequested(TNode *this)
{
  return this;
}

uint64_t TNode::HandleSync(void *a1, FINode **a2)
{
  if (TNodeFromFINode(*a2))
  {
    uint64_t v4 = (unsigned int *)(*a1 + 24);
    unsigned int v35 = 0;
    unsigned int v5 = TPropertyValue::As<NodeRequestOptions>(v4, &v35);
    char v6 = (TNode *)TNodeFromFINode(*a2);
    int v7 = TNode::VirtualType(v6);
    uint64_t v8 = TNodeFromFINode(*a2);
    TNodePtr v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
    os_unfair_lock_lock(v9);
    uint64_t v11 = *(void *)(v8 + 16);
    uint64_t v10 = *(std::__shared_weak_count **)(v8 + 24);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v9);
    int v12 = (os_unfair_lock_s *)(v11 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v11 + 100));
    int v13 = *(_DWORD *)(v11 + 115);
    os_unfair_lock_unlock(v12);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
    if ((v13 & 0x20) == 0) {
      goto LABEL_7;
    }
    uint64_t v16 = TNodeFromFINode(*a2);
    long long v17 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v16);
    os_unfair_lock_lock(v17);
    int v19 = *(TFSInfo **)(v16 + 16);
    uint64_t v18 = *(std::__shared_weak_count **)(v16 + 24);
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v17);
    BOOL IsAlias = TFSInfo::IsAlias(v19);
    BOOL v21 = IsAlias;
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
    if (((v21 | ((v5 & 0x80000) >> 19)) & 1) != 0 || (v7 - 23) < 2)
    {
LABEL_7:
      uint64_t v14 = TNodeFromFINode(*a2);
      TNode::HandleSync(v14, v5);
      return 0;
    }
    uint64_t v22 = TTime::MicrosecondsSinceStartup((TTime *)IsAlias);
    uint64_t v23 = TNodeFromFINode(*a2);
    uint64_t SyncStartTime = TChildrenList::LastSyncStartTime(*(TChildrenList **)(v23 + 56));
    long long v25 = (TNode *)TNodeFromFINode(*a2);
    unint64_t v26 = TNode::AdjustedSyncQuanta(v25);
    uint64_t v27 = TNodeFromFINode(*a2);
    uint64_t v28 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v27);
    os_unfair_lock_lock(v28);
    uint64_t v30 = *(void *)(v27 + 16);
    uint64_t v29 = *(std::__shared_weak_count **)(v27 + 24);
    if (v29)
    {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v28);
      int v31 = *(unsigned __int8 *)(v30 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v29);
      if (!v31)
      {
LABEL_19:
        BOOL v32 = (TNode *)TNodeFromFINode(*a2);
        if (!TNode::IsSynchingAppropriate(v32))
        {
          if (v22 <= SyncStartTime + 20000000)
          {
            unint64_t v33 = v22 + 1000000;
            goto LABEL_21;
          }
          goto LABEL_7;
        }
      }
    }
    else
    {
      os_unfair_lock_unlock(v28);
      if (!*(unsigned char *)(v30 + 112)) {
        goto LABEL_19;
      }
    }
    unint64_t v33 = v26 + SyncStartTime;
    if (v33 > v22)
    {
LABEL_21:
      int64_t v34 = (TNode *)TNodeFromFINode(*a2);
      TNode::SetTimerToDispatchSyncRequest(v34, v33, v5);
      return 0;
    }
    goto LABEL_7;
  }
  return 0;
}

void sub_1D344F234(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

unint64_t TNode::AdjustedSyncQuanta(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  unsigned int v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  int v6 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if ((v6 & 0x20) != 0) {
    double v7 = (double)(unint64_t)(10 * TChildrenList::GetLastSyncDuration(*((TChildrenList **)this + 7)));
  }
  else {
    double v7 = 200000.0;
  }
  double v8 = fmax(v7, 500000.0);
  if ((unint64_t)v8 >= 0x4C4B40) {
    return 5000000;
  }
  else {
    return (unint64_t)v8;
  }
}

uint64_t TChildrenList::GetLastSyncDuration(TChildrenList *this)
{
  return *((void *)this + 14);
}

uint64_t TChildrenList::LastSyncStartTime(TChildrenList *this)
{
  return *((void *)this + 15);
}

void TNode::FindRegistration(TNode *a1@<X0>, uint64_t a2@<X1>, FINode **a3@<X2>, TDSNotifier **a4@<X8>)
{
  if (*(void *)(*(void *)a2 + 40))
  {
    TNode::Notifiers(a1, &v16);
    double v7 = v16;
    double v8 = v17;
    while (1)
    {
      if (v7 == v8)
      {
        uint64_t v18 = &v16;
        goto LABEL_13;
      }
      uint64_t v9 = *(void *)*v7;
      if (*(void *)(v9 + 16) == *(void *)(*(void *)a2 + 16)
        && *(void *)(v9 + 40) == *(void *)(*(void *)a2 + 40))
      {
        uint64_t v10 = (FINode *)*((id *)*v7 + 3);
        uint64_t v11 = TNodeFromFINode(v10);
        uint64_t v12 = TNodeFromFINode(*a3);

        if (v11 == v12) {
          break;
        }
      }
      ++v7;
    }
    long long v15 = *v7;
    *a4 = *v7;
    if (v15) {
      TDSNotifier::AddPtrReference(v15);
    }
LABEL_17:
    uint64_t v18 = &v16;
    std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
    return;
  }
  TNode::Notifiers(a1, &v16);
  int v13 = v16;
  if (v16 != v17)
  {
    while (1)
    {
      uint64_t v14 = *v13;
      if (*(void *)(*(void *)*v13 + 16) == *(void *)(*(void *)a2 + 16)) {
        break;
      }
      if (++v13 == v17) {
        goto LABEL_12;
      }
    }
    *a4 = v14;
    TDSNotifier::AddPtrReference(v14);
    goto LABEL_17;
  }
LABEL_12:
  uint64_t v18 = &v16;
LABEL_13:
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
  *a4 = 0;
}

void sub_1D344F478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void TNode::SendNotification(const TNode *a1, int a2, id *a3, int a4, int a5)
{
  int v16 = a5;
  v14.fData.__impl_.__index = 0;
  std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<int const&,0,int,4ul,0>(&v14, &v16);
  v12.fFINode = 0;
  int v13 = 0;
  uint64_t v11 = 0;
  TNodeEvent::CreateNodeEvent(a2, a3, a4, &v14, (uint64_t *)&v12, &v11, &v15);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v11);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  TPropertyValue::~TPropertyValue(&v14);
  uint64_t v9 = (TNodeEvent *)TNodeEventPtr::operator->(&v15);
  TNodePtr::TNodePtr(&v12, a1);
  TNodeEvent::NotifyNode(v10, v9, &v12, 1);
  v14.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v10;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v14);

  TNodeEventPtr::~TNodeEventPtr(&v15);
}

void sub_1D344F584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, TPropertyValue *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  TNodeEventPtr::~TNodeEventPtr((id *)(v14 - 48));
  _Unwind_Resume(a1);
}

void std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (TDSNotifier **)**a1;
  if (v2)
  {
    uint64_t v4 = (TDSNotifier **)v1[1];
    unsigned int v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v4 - 1);
      while (v4 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void TNodeEvent::NotifyNode(TDSNotifier ***__return_ptr a1@<X8>, TNodeEvent *this@<X0>, const TNodePtr *a3@<X1>, int a4@<W2>)
{
  double v7 = (TNode *)TNodeFromFINode(a3->fFINode);
  TNode::Notifiers(v7, a1);
  if (TNode::IsContextOpen(v8))
  {
    uint64_t v9 = *a1;
    uint64_t v10 = (uint64_t)a1[1];
    while (v9 != (TDSNotifier **)v10)
    {
      uint64_t v11 = *v9;
      TNodePtr v12 = v11;
      if (v11) {
        TDSNotifier::AddPtrReference(v11);
      }
      TNodeEvent::NotifyCommon(&this->fEventKind, &v12, a4);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v12);
      ++v9;
    }
    TNodeEvent::ForwardEventToParent(this);
  }
}

void sub_1D344F6F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void TNode::Notifiers(TNode *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  unsigned int v5 = (TNotifierList *)*((void *)this + 9);
  if (v5)
  {
    TNotifierList::Notifiers(v5, a2);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  os_unfair_lock_unlock(v4);
}

void sub_1D344F784(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<int const&,0,int,4ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 4) {
    *a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int const&>(a1, a2);
  }
  return a1;
}

void TNotifierList::Notifiers(TNotifierList *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__init_with_size[abi:ne180100]<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*>(a2, *((void *)this + 5), *((void *)this + 6), (uint64_t)(*((void *)this + 6) - *((void *)this + 5)) >> 3);
  os_unfair_lock_unlock(v4);
}

void sub_1D344F848(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void *std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__init_with_size[abi:ne180100]<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    std::vector<TNodePtr>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1D344F8C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      double v8 = *(TDSNotifier **)(a2 + v7);
      *(void *)(a4 + v7) = v8;
      if (v8) {
        TDSNotifier::AddPtrReference(v8);
      }
      v7 += 8;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1D344F948(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 8;
    do
    {
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)(v4 + v2));
      v2 -= 8;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

BOOL TRefCount::Retain<int>(unsigned int *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = atomic_load(a1);
  if ((v2 & 0x80000000) != 0)
  {
    LODWORD(v3) = v2;
LABEL_7:
    uint64_t v4 = LogObj(5);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      BOOL v5 = IsRedactionEnabled();
      if (v5)
      {
        int v6 = &stru_1F2ABD380;
      }
      else
      {
        uint64_t v1 = [MEMORY[0x1E4F29060] callStackSymbols];
        int v6 = [v1 description];
      }
      int v8 = 136446722;
      uint64_t v9 = "Retain";
      __int16 v10 = 2048;
      uint64_t v11 = (int)v3;
      __int16 v12 = 2114;
      int v13 = v6;
      _os_log_impl(&dword_1D343E000, v4, OS_LOG_TYPE_ERROR, "%{public}s on bad object. -- refCount: %ld\n%{public}@", (uint8_t *)&v8, 0x20u);
      if (!v5)
      {
      }
    }

    LODWORD(v2) = v3;
  }
  else
  {
    while (v2)
    {
      uint64_t v3 = v2;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)a1, (unsigned int *)&v3, v2 + 1, memory_order_release, memory_order_relaxed);
      if (v3 == v2) {
        break;
      }
      uint64_t v2 = v3;
      if ((v3 & 0x80000000) != 0) {
        goto LABEL_7;
      }
    }
  }
  return (int)v2 > 0;
}

void sub_1D344FAC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL TDSNotifier::AddPtrReference(TDSNotifier *this)
{
  return TRefCount::Retain<int>((unsigned int *)this + 9);
}

uint64_t TNodeEvent::RedispatchEventToNotifier(uint64_t a1, unsigned int a2, unint64_t a3, TDSNotifier **a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  int v6 = atomic_load((unsigned int *)*a4 + 11);
  if (v6 > 0 || a2 > 0x32 || ((1 << a2) & 0x4000000100358) == 0)
  {
    TBlockingEventQueue::EventQueueFromID(a3, &v41);
    if (v41)
    {
      TNodePtr v38 = 0;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      uint64_t v7 = [[FINodeEvent alloc] init:a1];
      int v8 = v7;
      if (v7) {
        uint64_t v9 = v7 + 8;
      }
      else {
        uint64_t v9 = 0;
      }
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=((TDSNotifier **)v9 + 8, *a4);
      __int16 v10 = *a4;
      v43.fFINode = (FINode *)v10;
      if (v10) {
        TDSNotifier::AddPtrReference(v10);
      }
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v43);
      if ((*(_DWORD *)v9 & 0xFFFFFFFD) == 4)
      {
        uint64_t v11 = (TNode *)[*((id *)v9 + 1) nodeRef];
        int v13 = (const TNode *)TNode::NodeFromNodeRef(v11, v12);
        TNodePtr::TNodePtr(&v43, v13);
        uint64_t v14 = (TNode *)TNodeFromFINode(v43.fFINode);
        TNode::CopyReplicas(v14, v15);
        long long v36 = 0u;
        long long v37 = 0u;
        long long v34 = 0u;
        long long v35 = 0u;
        id v16 = (id)objc_claimAutoreleasedReturnValue();
        uint64_t v17 = [v16 countByEnumeratingWithState:&v34 objects:v44 count:16];
        if (v17)
        {
          uint64_t v18 = *(void *)v35;
          do
          {
            for (uint64_t i = 0; i != v17; ++i)
            {
              if (*(void *)v35 != v18) {
                objc_enumerationMutation(v16);
              }
              uint64_t v20 = *(void **)(*((void *)&v34 + 1) + 8 * i);
              unint64_t v33 = [[FINodeEvent alloc] init:v9];
              BOOL v21 = (id *)(v33 + 8);
              if (!v33) {
                BOOL v21 = 0;
              }
              objc_storeStrong(v21 + 1, v20);
              std::vector<TNodeEventPtr>::push_back[abi:ne180100]((uint64_t *)&v38, (id *)&v33);
              uint64_t v22 = v33;
              unint64_t v33 = 0;
            }
            uint64_t v17 = [v16 countByEnumeratingWithState:&v34 objects:v44 count:16];
          }
          while (v17);
        }
      }
      uint64_t v23 = v41;
      long long v24 = v8;
      BOOL v32 = v24;
      TBlockingQueue<TNodeEventPtr>::Enqueue(v23, (id *)&v32);
      long long v25 = v32;
      BOOL v32 = 0;

      unint64_t v26 = v38;
      uint64_t v27 = v39;
      while (v26 != v27)
      {
        id v28 = *v26;
        id v31 = v28;
        TBlockingQueue<TNodeEventPtr>::Enqueue(v23, &v31);
        id v29 = v31;
        id v31 = 0;

        ++v26;
      }
      v43.fFINode = (FINode *)&v38;
      std::vector<TNodeEventPtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v43);
    }
    if (v42) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v42);
    }
  }
  return 0;
}

void sub_1D344FDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,void **a27)
{
  a27 = (void **)&a22;
  std::vector<TNodeEventPtr>::__destroy_vector::operator()[abi:ne180100](&a27);
  if (a26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a26);
  }
  _Unwind_Resume(a1);
}

void TNodeEvent::CreateNodeEvent(int a1@<W0>, id *a2@<X1>, int a3@<W2>, TPropertyValue *a4@<X3>, uint64_t *a5@<X4>, TDSNotifier **a6@<X5>, void *a7@<X8>)
{
  uint64_t v14 = [FINodeEvent alloc];
  TNodeEvent::TNodeEvent((uint64_t)&v15, a1, a2, a3, a4, a5, a6);
  *a7 = [(FINodeEvent *)v14 init:&v15];
  TNodeEvent::~TNodeEvent(&v15);
}

void sub_1D344FF28(_Unwind_Exception *a1, TNodeEvent *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_1D344FFF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

TDSNotifier **TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=(TDSNotifier **a1, TDSNotifier *this)
{
  if (this) {
    TDSNotifier::AddPtrReference(this);
  }
  if (*a1) {
    TDSNotifier::RemovePtrReference(*a1);
  }
  *a1 = this;
  return a1;
}

uint64_t TNodeEvent::TNodeEvent(uint64_t a1, int a2, id *a3, int a4, TPropertyValue *a5, uint64_t *a6, TDSNotifier **a7)
{
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  __int16 v12 = (TPropertyValue *)(a1 + 24);
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 64) = 0;
  int v13 = (TDSNotifier **)(a1 + 64);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)a1 = a2;
  objc_storeStrong((id *)(a1 + 8), *a3);
  *(_DWORD *)(a1 + 16) = a4;
  TPropertyValue::operator=(v12, a5);
  uint64_t v15 = *a6;
  uint64_t v14 = a6[1];
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  id v16 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = v15;
  *(void *)(a1 + 56) = v14;
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=(v13, *a7);
  return a1;
}

void sub_1D3450100(_Unwind_Exception *a1)
{
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v4);
  int v6 = *(std::__shared_weak_count **)(v3 + 56);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  TPropertyValue::~TPropertyValue(v2);

  _Unwind_Resume(a1);
}

void TNodeEvent::CreateNodeEvent(int a1@<W0>, id *a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  memset(&v6, 0, sizeof(v6));
  v5[0] = 0;
  v5[1] = 0;
  uint64_t v4 = 0;
  TNodeEvent::CreateNodeEvent(a1, a2, a3, &v6, v5, &v4, a4);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v4);
  TPropertyValue::~TPropertyValue(&v6);
}

void sub_1D3450184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, TPropertyValue *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TDSNotifier *a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void TNodeEvent::~TNodeEvent(TNodeEvent *this)
{
  fFINode = this->fFINode;
  this->fFINode = 0;

  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&this->fNotifier.fRef);
  cntrl = this->fTask.__cntrl_;
  if (cntrl) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)cntrl);
  }
  TPropertyValue::~TPropertyValue(&this->fPropertyValue);
}

TDSNotifier **TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(TDSNotifier **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    TDSNotifier::RemovePtrReference(v2);
  }
  return a1;
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v2))(&v4, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  return a1;
}

TPropertyValue *TPropertyValue::operator=(TPropertyValue *this, TPropertyValue *a2)
{
  if (this != a2) {
    TPropertyValue::CopyFrom(this, a2);
  }
  return this;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__generic_assign[abi:ne180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 16);
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t, uint64_t))*(&off_1F2ABC010 + v3))(&v6, result, a2);
    *(_DWORD *)(v2 + 16) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))*(&off_1F2ABC190 + v4))(&v5, result, a2);
}

TPropertyValue *TPropertyValue::CopyFrom(TPropertyValue *this, const TPropertyValue *a2)
{
  if (this != a2)
  {
    uint64_t v3 = this;
    this = (TPropertyValue *)TPropertyValue::Release(this);
    unsigned int index = a2->fData.__impl_.__index;
    if (index <= 0x17)
    {
      if (index == 9)
      {
        if (a2->fData.__impl_.__index != 9) {
          std::__throw_bad_variant_access[abi:ne180100]();
        }
        std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Blob const&,0,Blob,9ul,0>((uint64_t)v3, &kEmptyBlob);
        return (TPropertyValue *)TPropertyValue::CopyBlob(v3, (const Blob *)a2);
      }
      else
      {
        return (TPropertyValue *)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__generic_assign[abi:ne180100]<std::__variant_detail::__copy_assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1> const&>((uint64_t)v3, (uint64_t)a2);
      }
    }
  }
  return this;
}

void TPropertyValue::~TPropertyValue(TPropertyValue *this)
{
  TPropertyValue::Release(this);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)this);
}

uint64_t TPropertyValue::Release(TPropertyValue *this)
{
  unsigned int index = this->fData.__impl_.__index;
  switch((char)index)
  {
    case 9:
      if (index != 9) {
        goto LABEL_28;
      }
      buffer = this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
      if (buffer) {
        MEMORY[0x1D9436720](buffer, 0x1000C8077774924);
      }
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Blob const&,0,Blob,9ul,0>((uint64_t)this, &kEmptyBlob);
      return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
    case 10:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},decltype(nullptr)>((uint64_t)this, (void **)this);
      return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
    case 11:
      uint64_t v4 = TString::KEmptyString((TString *)this);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>((uint64_t)this, (TString *)this, (TString *)v4);
      return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
    case 12:
      if (index != 12) {
        goto LABEL_28;
      }
      goto LABEL_21;
    case 13:
      if (index != 13) {
        goto LABEL_28;
      }
      goto LABEL_21;
    case 14:
      if (index != 14) {
        goto LABEL_28;
      }
      goto LABEL_21;
    case 15:
      if (index != 15) {
        goto LABEL_28;
      }
      goto LABEL_21;
    case 16:
      if (index != 16) {
        goto LABEL_28;
      }
      goto LABEL_21;
    case 17:
      if (index == 17) {
        goto LABEL_21;
      }
      goto LABEL_28;
    case 18:
      if (index != 18) {
        goto LABEL_28;
      }
LABEL_21:
      value = (const void *)this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
      if (this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value) {
        CFRelease(value);
      }
      goto LABEL_23;
    case 19:
      if (index != 19) {
LABEL_28:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      uint64_t v7 = (TReferenceCounted *)this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
      if (this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value) {
        TReferenceCounted::RemovePtrReference(v7);
      }
LABEL_23:
      this->fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = 0;
      break;
    default:
      return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
  }
  return std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>((uint64_t)this);
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<std::monostate,0,std::monostate,0ul,0>(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16)) {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate>(a1);
  }
  return a1;
}

BOOL TDSNotifier::RemovePtrReference(TDSNotifier *this)
{
  BOOL result = TRefCount::Release<int>((unsigned int *)this + 9);
  if (this && result)
  {

    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 1);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    JUMPOUT(0x1D9436740);
  }
  return result;
}

BOOL TRefCount::Release<int>(unsigned int *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = atomic_load(a1);
  if ((int)v2 < 1)
  {
    LODWORD(v4) = v2;
LABEL_6:
    uint64_t v5 = LogObj(5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      BOOL v6 = IsRedactionEnabled();
      if (v6)
      {
        uint64_t v7 = &stru_1F2ABD380;
      }
      else
      {
        uint64_t v1 = [MEMORY[0x1E4F29060] callStackSymbols];
        uint64_t v7 = [v1 description];
      }
      int v10 = 136446722;
      uint64_t v11 = "Release";
      __int16 v12 = 2048;
      uint64_t v13 = (int)v4;
      __int16 v14 = 2114;
      uint64_t v15 = v7;
      _os_log_impl(&dword_1D343E000, v5, OS_LOG_TYPE_ERROR, "%{public}s overrelease -- refCount: %ld\n%{public}@", (uint8_t *)&v10, 0x20u);
      if (!v6)
      {
      }
    }

    int v3 = v4 - 1;
  }
  else
  {
    while (1)
    {
      int v3 = v2 - 1;
      uint64_t v4 = v2;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)a1, (unsigned int *)&v4, v2 - 1, memory_order_release, memory_order_relaxed);
      if (v4 == v2) {
        break;
      }
      uint64_t v2 = v4;
      if ((int)v4 < 1) {
        goto LABEL_6;
      }
    }
    LODWORD(v4) = v2;
  }
  return v4 == 1 && v3 == 0;
}

void sub_1D34507A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate>(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v2))(&v4, a1);
  }
  *(_DWORD *)(a1 + 16) = 0;
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16)) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate const&>(result);
  }
  return result;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 4;
  return a1;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 4) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

TReferenceCounted **TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef(TReferenceCounted **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    TReferenceCounted::RemovePtrReference(v2);
  }
  return a1;
}

uint64_t TNodeEvent::NotifyCommon(unsigned int *a1, TDSNotifier **a2, int a3)
{
  if (TNode::IsContextOpen((TNode *)a1))
  {
    uint64_t v7 = *(void *)*a2;
    char v6 = (std::__shared_weak_count *)*((void *)*a2 + 1);
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
      if (!v7) {
        return 0;
      }
      uint64_t v7 = *(void *)*a2;
    }
    else if (!v7)
    {
      return 0;
    }
    TNodeEvent::RedispatchEventToNotifier((uint64_t)a1, *a1, *(void *)(v7 + 40), a2);
    if (a3) {
      TDSNotifier::Tickle(*a2, *a1 == 8);
    }
  }
  return 0;
}

void TDSNotifier::Tickle(TDSNotifier *this, int a2)
{
  uint64_t v4 = TTime::MicrosecondsSinceStartup((TTime *)this);
  TickleLock();
  os_unfair_lock_lock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
  if (a2)
  {
    uint64_t v5 = 200000;
LABEL_15:
    *((void *)this + 8) = v4;
    *((void *)this + 9) = v5;
    os_unfair_lock_unlock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
    uint64_t v11 = *(TClientChangeNotifier **)this;
    TClientChangeNotifier::WakeUp(v11);
    return;
  }
  uint64_t v7 = *((void *)this + 8);
  uint64_t v6 = *((void *)this + 9);
  if (v4 - v7 >= v6)
  {
    if (v4 - v7 >= 2 * v6)
    {
      uint64_t v13 = (TDSNotifier *)(v6 >> 1);
      BOOL v10 = v6 >> 7 >= 0xC35;
      uint64_t v9 = (uint64_t *)&v13;
      if (!v10) {
        uint64_t v9 = (uint64_t *)&kMinimumTickleDelta;
      }
    }
    else
    {
      uint64_t v13 = (TDSNotifier *)(2 * v6);
      BOOL v8 = 2 * v6 > 0x3D0900;
      uint64_t v9 = (uint64_t *)&v13;
      if (v8) {
        uint64_t v9 = (uint64_t *)&kMaximumTickleDelta;
      }
    }
    uint64_t v5 = *v9;
    goto LABEL_15;
  }
  if (*((unsigned char *)this + 60))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
  }
  else
  {
    uint64_t v12 = v6 + v7;
    *((unsigned char *)this + 60) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
    uint64_t v13 = this;
    TRefCount::Retain<int>((unsigned int *)this + 9);
    TClientChangeNotifier::SetTimerToHandleTickle(*(TClientChangeNotifier **)this, this, v12);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v13);
  }
}

void sub_1D3450B08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  _Unwind_Resume(a1);
}

uint64_t TTime::MicrosecondsSinceStartup(TTime *this)
{
  mach_timebase_info(&info);
  return mach_absolute_time() * info.numer / info.denom / 0x3E8;
}

void TickleLock(void)
{
  {
    TickleLock(void)::sTickleLock = 0;
  }
}

void std::vector<TNodeEventPtr>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = (id **)*a1;
  if (*v2)
  {
    std::vector<TNodeEventPtr>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    int v3 = **a1;
    operator delete(v3);
  }
}

void TBlockingQueue<TNodeEventPtr>::Enqueue(uint64_t a1, id *a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  uint64_t v5 = *(void *)(a1 + 40);
  std::deque<TNodeEventPtr>::push_back((void *)a1, a2);
  if (!v5) {
    TConditionVariable::Signal((TConditionVariable *)(a1 + 112));
  }
  std::mutex::unlock(v4);
}

void sub_1D3450C84(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

id std::deque<TNodeEventPtr>::push_back(void *a1, id *a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = ((v5 - v4) << 6) - 1;
  if (v5 == v4) {
    uint64_t v6 = 0;
  }
  if (v6 == a1[5] + a1[4])
  {
    std::deque<TNodeEventPtr>::__add_back_capacity(a1);
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
  }
  if (v5 == v4)
  {
    BOOL v8 = 0;
  }
  else
  {
    unint64_t v7 = a1[5] + a1[4];
    BOOL v8 = (void *)(*(void *)(v4 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7 & 0x1FF));
  }
  id result = *a2;
  void *v8 = result;
  ++a1[5];
  return result;
}

BOOL TReferenceCounted::RemovePtrReference(TReferenceCounted *this)
{
  BOOL result = TRefCount::Release<int>((unsigned int *)this + 4);
  if (this && result)
  {
    TReferenceCounted::~TReferenceCounted(this);
    JUMPOUT(0x1D9436740);
  }
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm21ELm21EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  BOOL result = *a1;
  if (result[4] != 21) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 21) {
    *a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions const&>(a1, a2);
  }
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *a1 = *a2;
  a1[4] = 21;
  return a1;
}

TReferenceCounted **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm19EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, TReferenceCounted **a2)
{
  return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef(a2);
}

id TNode::CopyReplicas(TNode *this, const TNode *a2)
{
  uint64_t v2 = (TReplicaRegistry *)TNode::AsNodeRef(this, a2);
  return TReplicaRegistry::CopyReplicas(v2, v3);
}

uint64_t TNode::AsNodeRef(TNode *this, const TNode *a2)
{
  uint64_t v2 = FIDSNodeFromTNode(this);
  uint64_t v3 = [v2 nodeRef];

  return v3;
}

void sub_1D3450EDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id TReplicaRegistry::CopyReplicas(TReplicaRegistry *this, OpaqueNodeRef *a2)
{
  Mutex = (TDSMutex *)TReplicaRegistry::GetMutex(this);
  TDSMutex::lock(Mutex);
  if (TReplicaRegistry::gReplicaRegistry)
  {
    uint64_t v4 = TReplicaRegistry::CopyReplicaFINodes((TReplicaRegistry *)TReplicaRegistry::gReplicaRegistry, (OpaqueNodeRef *)this);
  }
  else
  {
    uint64_t v4 = 0;
  }
  TDSMutex::unlock(Mutex);
  return v4;
}

void sub_1D3450F58(_Unwind_Exception *a1)
{
  TDSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TReplicaRegistry::GetMutex(TReplicaRegistry *this)
{
  {
    operator new();
  }
  return TReplicaRegistry::GetMutex(void)::sReplicaRegistryMutex;
}

void sub_1D3450FF0(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x1000C40FA0F61DDLL);
  _Unwind_Resume(a1);
}

void ___ZZN21TClientChangeNotifier6WakeUpEvENK3__1clEv_block_invoke(uint64_t a1)
{
}

void TClientChangeNotifier::WakeUp(TClientChangeNotifier *this)
{
  std::shared_ptr<TClientChangeNotifier>::shared_ptr[abi:ne180100]<TClientChangeNotifier,void>(&v17, this);
  uint64_t v2 = *((void *)this + 6);
  if (v2)
  {
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3321888768;
    v11[2] = ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke_2;
    v11[3] = &__block_descriptor_48_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__1_e5_v8__0l;
    uint64_t v3 = v17;
    uint64_t v4 = v18;
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v12 = v3;
      uint64_t v13 = v4;
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      dispatch_async(v2, v11);
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
    else
    {
      uint64_t v12 = v17;
      uint64_t v13 = 0;
      dispatch_async(v2, v11);
    }
    uint64_t v9 = v13;
    if (v13) {
LABEL_8:
    }
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  else
  {
    Main = CFRunLoopGetMain();
    char v6 = (const void *)*MEMORY[0x1E4F1D410];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke;
    block[3] = &__block_descriptor_48_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__0_e5_v8__0l;
    uint64_t v7 = v17;
    BOOL v8 = v18;
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v15 = v7;
      uint64_t v16 = v8;
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    else
    {
      uint64_t v15 = v17;
      uint64_t v16 = 0;
    }
    CFRunLoopPerformBlock(Main, v6, block);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    BOOL v10 = CFRunLoopGetMain();
    CFRunLoopWakeUp(v10);
    uint64_t v9 = v16;
    if (v16) {
      goto LABEL_8;
    }
  }
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
}

void sub_1D34511A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20)
{
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(v21 - 24);
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v23);
  }
  _Unwind_Resume(exception_object);
}

void *std::shared_ptr<TClientChangeNotifier>::shared_ptr[abi:ne180100]<TClientChangeNotifier,void>(void *a1, void *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a1 = *a2;
  if (!v3)
  {
    a1[1] = 0;
LABEL_5:
    std::__throw_bad_weak_ptr[abi:ne180100]();
  }
  uint64_t v4 = std::__shared_weak_count::lock(v3);
  a1[1] = v4;
  if (!v4) {
    goto LABEL_5;
  }
  return a1;
}

void TConditionVariable::Signal(TConditionVariable *this)
{
  *((_DWORD *)this + 16) = 0;
  uint64_t v2 = (std::mutex *)*((void *)this + 6);
  std::mutex::lock(v2);
  std::mutex::unlock(v2);
  std::condition_variable::notify_all((std::condition_variable *)this);
}

void TNode::SetTimerToDispatchSyncRequest(TNode *a1, uint64_t a2, int a3)
{
  TNode::GetVolumeInfo(a1, &v8);
  if (v8)
  {
    TFSVolumeInfo::GetVolumeSyncThread(v8, &v6);
    if (v6) {
      TNode::SetTimerToDispatchSyncRequest((uint64_t)a1, (uint64_t)&v6, a2, a3);
    }
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

void sub_1D3451304(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void TNode::SetTimerToDispatchSyncRequest(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  BOOL v8 = (TNode *)TVolumeSyncThread::SynchingCanceled(*(TVolumeSyncThread **)a2);
  if ((v8 & 1) == 0)
  {
    if ((a4 & 0x80000) != 0) {
      goto LABEL_8;
    }
    uint64_t v9 = (os_unfair_lock_s *)TNode::InfoLock(v8);
    os_unfair_lock_lock(v9);
    uint64_t v11 = *(void *)(a1 + 16);
    BOOL v10 = *(std::__shared_weak_count **)(a1 + 24);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v9);
    uint64_t v12 = (os_unfair_lock_s *)(v11 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v11 + 100));
    int v13 = *(_DWORD *)(v11 + 115);
    os_unfair_lock_unlock(v12);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
    if ((v13 & 0x20) != 0)
    {
      if ((a4 & 0x400000) == 0 && (atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 4u) & 4) != 0) {
        return;
      }
      char v14 = 1;
    }
    else
    {
LABEL_8:
      char v14 = 0;
    }
    uint64_t v15 = NodeEventRefFromNodeEvent(*(id **)a2);
    dispatch_source_t v16 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 1uLL, v15);

    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 3321888768;
    handler[2] = ___ZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptions_block_invoke;
    handler[3] = &__block_descriptor_72_ea8_32c114_ZTSKZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsE3__0_e5_v8__0l;
    uint64_t v17 = *(std::__shared_weak_count **)(a2 + 8);
    uint64_t v22 = *(TVolumeSyncThread **)a2;
    uint64_t v23 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v18 = v16;
    TNodePtr::TNodePtr(&v24, (const TNode *)a1);
    LOBYTE(v25) = v14;
    HIDWORD(v25) = a4;
    handler[4] = v22;
    uint64_t v27 = v23;
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    id v28 = v18;
    id v29 = v24.fFINode;
    uint64_t v30 = v25;
    dispatch_source_set_event_handler(v18, handler);

    int v19 = (TTime *)v23;
    if (v23) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v23);
    }
    uint64_t v20 = TTime::MicrosecondsSinceStartup(v19);
    dispatch_time_t v21 = dispatch_time(0, 1000 * (a3 - v20));
    dispatch_source_set_timer(v18, v21, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(v18);

    if (v27) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v27);
    }
  }
}

void sub_1D3451568(_Unwind_Exception *a1)
{
  CopyURLForFPItem(FPItem *,BOOL)::$_0::~$_0(v1);

  _Unwind_Resume(a1);
}

TReferenceCounted **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm19ELm19EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, TReferenceCounted **a2, uint64_t *a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(*a1, a2, a3);
}

BOOL TNode::IsSynchingAppropriate(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::OperationLockLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v3 = (os_unfair_lock_s *)*((void *)this + 5);
  if (v3)
  {
    os_unfair_lock_lock(v3);
    uint32_t os_unfair_lock_opaque = v3[5]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v3);
    if (os_unfair_lock_opaque)
    {
      BOOL v5 = 0;
    }
    else
    {
      os_unfair_lock_lock(v3);
      BOOL v5 = !v3[1]._os_unfair_lock_opaque && !v3[4]._os_unfair_lock_opaque && v3[3]._os_unfair_lock_opaque == 0;
      os_unfair_lock_unlock(v3);
    }
  }
  else
  {
    BOOL v5 = 1;
  }
  os_unfair_lock_unlock(v2);
  return v5;
}

int *TNode::OperationLockLock(TNode *this)
{
  {
    TNode::OperationLockLock(void)::sOperationLockLock = 0;
  }
  return &TNode::OperationLockLock(void)::sOperationLockLock;
}

void ___ZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEv_block_invoke(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64)) {
    atomic_fetch_and((atomic_ushort *volatile)(TNodeFromFINode(*(FINode **)(a1 + 48)) + 80), 0xFFFBu);
  }
  if ((TVolumeSyncThread::SynchingCanceled(*(TVolumeSyncThread **)(a1 + 32)) & 1) == 0)
  {
    uint64_t v2 = TNodeFromFINode(*(FINode **)(a1 + 48));
    TNode::RequestSynchronize(v2, *(unsigned int *)(a1 + 68));
  }
  uint64_t v3 = *(NSObject **)(a1 + 56);
  dispatch_source_cancel(v3);
}

void TClientChangeNotifier::SetTimerToHandleTickle(TClientChangeNotifier *this, TDSNotifier *a2, uint64_t a3)
{
  BOOL v5 = *((void *)this + 6);
  if (v5)
  {
    dispatch_source_t v6 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 1uLL, v5);
    RetainNotifier((unsigned int *)a2);
    handler[0] = MEMORY[0x1E4F143A8];
    handler[1] = 3221225472;
    handler[2] = ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke;
    handler[3] = &unk_1E6990200;
    int v19 = a2;
    uint64_t v7 = v6;
    uint64_t v18 = v7;
    dispatch_source_set_event_handler(v7, handler);
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    v16[2] = ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke_3;
    v16[3] = &__block_descriptor_40_e5_v8__0l;
    v16[4] = a2;
    dispatch_source_set_cancel_handler(v7, v16);
    uint64_t v9 = TTime::MicrosecondsSinceStartup(v8);
    dispatch_time_t v10 = dispatch_time(0, 1000 * (a3 - v9));
    dispatch_source_set_timer(v7, v10, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_resume(v7);
  }
  else
  {
    context.version = 0;
    context.mach_timebase_info info = a2;
    context.retain = (const void *(__cdecl *)(const void *))RetainNotifier;
    context.release = (void (__cdecl *)(const void *))ReleaseNotifier;
    context.copyDescription = 0;
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t v14 = TTime::MicrosecondsSinceStartup(v13);
    CFRunLoopTimerRef timer = CFRunLoopTimerCreate(v11, Current + (double)(a3 - v14) / 1000000.0, 0.0, 0, 0, (CFRunLoopTimerCallBack)TDSNotifier::HandleDeferredTickleOnMainRunLoop, &context);
    Main = CFRunLoopGetMain();
    CFRunLoopAddTimer(Main, timer, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
    TAutoRef<__CFRunLoopTimer *,CFRetainReleasePolicy>::~TAutoRef((const void **)&timer);
  }
}

void sub_1D34518F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

unsigned int *RetainNotifier(unsigned int *a1)
{
  if (a1) {
    TRefCount::Retain<int>(a1 + 9);
  }
  uint64_t v3 = 0;
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v3);
  return a1;
}

void ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke_2(uint64_t a1)
{
}

void TDSNotifier::HandleDeferredTickle(TDSNotifier *this)
{
  unint64_t v2 = *(void *)(*(void *)this + 40);
  TBlockingEventQueue::EventQueueFromID(v2, &v4);
  uint64_t v3 = v4;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  if (v3)
  {
    TickleLock();
    os_unfair_lock_lock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
    *((unsigned char *)this + 60) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&TickleLock(void)::sTickleLock);
    std::function<void ()(OpaqueEventQueue *)>::operator()(*(void *)this + 56, v2);
  }
}

void std::deque<TNodeEventPtr>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    dispatch_source_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)BOOL v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      long long v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v5, v33);
      long long v35 = &v34[8 * (v33 >> 2)];
      long long v37 = &v34[8 * v36];
      TNodePtr v38 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        BOOL v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    int v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    BOOL v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    BOOL v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      long long v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v46);
      long long v35 = &v34[8 * (v46 >> 2)];
      long long v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      BOOL v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        BOOL v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      TNodePtr v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        BOOL v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  TString v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unsigned int v53 = operator new(0x1000uLL);
  std::__split_buffer<TNodeEventPtr *>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)&v54, v27);
  }
  id v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1D3451CC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__1(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void TDSMutex::~TDSMutex(TDSMutex *this)
{
}

{
  pthread_mutex_destroy(&this->fMutex);
}

const void **TSystemNotificationTask::HandleAllFileChanges(TSystemNotificationTask *this, const __FSEventStream *a2, const void **a3, const char **a4, int *a5, const unsigned int *a6, const unint64_t *a7)
{
  return TSystemNotificationTask::HandleFSEvent(a3, a4, a5, 0);
}

void TPropertyRecordSet::TPropertyRecordSet(TPropertyRecordSet *this)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  memcpy(v3, aManp, sizeof(v3));
  std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<true>((uint64_t)this, 0x4DuLL);
  for (uint64_t i = 0; i != 3080; i += 40)
    std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::__emplace_unique_key_args<TPropertyRecord,TPropertyRecord const&>((uint64_t)this, (unsigned int *)&v3[i], (uint64_t)&v3[i]);
}

void sub_1D3451E90(_Unwind_Exception *a1)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::__emplace_unique_key_args<TPropertyRecord,TPropertyRecord const&>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x38uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  long long v12 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v10 + 1) = *(_OWORD *)a3;
  *((_OWORD *)v10 + 2) = v12;
  v10[6] = *(void *)(a3 + 32);
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 40);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<true>(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v19 = *(void *)a1;
  int64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    *uint64_t v10 = *v20;
LABEL_38:
    void *v20 = v10;
    goto LABEL_39;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v21 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    int64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1D34520BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 40));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__do_rehash<true>(a1, prime);
    }
  }
}

BOOL NodeIteratorFullyPopulated(uint64_t a1)
{
  return !a1 || *(unsigned char *)(a1 + 40) != 0;
}

id __copy_helper_block_ea8_32c98_ZTSKZN9TNodeTask19PostNodeTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I17TVolumeSyncThreadEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  id result = *(id *)(a2 + 64);
  *(void *)(a1 + 64) = result;
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  return result;
}

void iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::end(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::IDContainerIteratorAdaptor((uint64_t)v5, -1, **(void ***)a1);
  uint64_t v4 = *(void **)(*(void *)(a1 + 8) + 8);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v6, (uint64_t)v5);
  v6[17] = v4;
  iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::ZipIterator(a2, (uint64_t)v6);
}

void sub_1D34522F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::ZipIterator(uint64_t a1, uint64_t a2)
{
  uint64_t result = IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator(a1, a2);
  *(void *)(result + 136) = *(void *)(a2 + 136);
  return result;
}

void sub_1D34523C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, id **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0x28uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  void *v8 = 0;
  v8[1] = a2;
  uint64_t result = std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::pair[abi:ne180100]<FPProviderDomain * const&>(v8 + 2, *a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D345243C(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void *std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::pair[abi:ne180100]<FPProviderDomain * const&>(void *a1, id *a2)
{
  *a1 = *a2;
  fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::optional_err(a1 + 1);
  return a1;
}

void sub_1D3452490(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c174_ZTSKZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEEE3__1(void *a1, uint64_t a2)
{
  a1[4] = *(id *)(a2 + 32);
  a1[5] = *(id *)(a2 + 40);
  uint64_t result = std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)(a1 + 6), a2 + 48);
  uint64_t v5 = *(void *)(a2 + 88);
  a1[10] = *(void *)(a2 + 80);
  a1[11] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a2 + 104);
  a1[12] = *(void *)(a2 + 96);
  a1[13] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_1D345251C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c174_ZTSKZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEEE3__1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::~__value_func[abi:ne180100]((void *)(a1 + 48));

  uint64_t v4 = *(void **)(a1 + 32);
}

void TNode::AddNewChild(FINode **__return_ptr a1@<X8>, TChildrenList **this@<X0>, const TNodePtr *a3@<X1>, BOOL *a4@<X2>, unsigned int a5@<W4>)
{
  TChildrenList::AddNewChild(this[7], a3, a4, a1);
  if (*a4) {
    goto LABEL_11;
  }
  uint64_t v9 = TNodeFromFINode(*a1);
  if (v9 != TNodeFromFINode(a3->fFINode))
  {
    uint64_t v10 = (TNode *)TNodeFromFINode(a3->fFINode);
    TNode::RemoveSelf(v10, 0);
  }
  if (*a4)
  {
LABEL_11:
    if (pthread_main_np())
    {
      unint64_t v11 = sFPItemsFetchingFromMainQueue;
      if (sFPItemsFetchingFromMainQueue)
      {
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3321888768;
        block[2] = ___ZN5TNode11AddNewChildERK8TNodePtrRbbb_block_invoke;
        block[3] = &__block_descriptor_40_ea8_32c47_ZTSKZN5TNode11AddNewChildERK8TNodePtrRbbbE3__0_e5_v8__0l;
        BOOL v15 = a3->fFINode;
        long long v12 = v15;
        dispatch_async(v11, block);
      }
    }
    else
    {
      float v13 = (TNode *)TNodeFromFINode(a3->fFINode);
      TNode::AttachCreateFPItemIfNeeded(v13, a5);
    }
  }
}

void sub_1D34526B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::AttachCreateFPItemIfNeeded(TNode *this, unsigned int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *((void *)this + 2);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v4);
    int v7 = *(unsigned __int8 *)(v6 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    if (v7) {
      return;
    }
  }
  else
  {
    os_unfair_lock_unlock(v4);
    if (*(unsigned char *)(v6 + 112)) {
      return;
    }
  }
  if (FPProviderDomainClass())
  {
    uint8x8_t v8 = (TNode *)UseFileProviderFramework();
    if (v8)
    {
      uint64_t v9 = (os_unfair_lock_s *)TNode::InfoLock(v8);
      os_unfair_lock_lock(v9);
      unint64_t v11 = (TFSInfo *)*((void *)this + 2);
      uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v9);
      long long v12 = TFSInfo::GetFPItem(v11);
      if (v10) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v10);
      }

      if (!v12)
      {
        TNodePtr::TNodePtr(&v14, this);
        uint64_t v13 = 0x4014000000000000;
        TNode::UpdateFPItemIfNeeded((id *)&v14.fFINode, (double *)&v13, 1, 1u, a2, v15);
      }
    }
  }
}

void sub_1D34527F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t FPProviderDomainClass(void)
{
  return objc_opt_class();
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPProviderDomain *>>::NSForwardIterator<NSMutableArray<FPProviderDomain *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34528D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPProviderDomain *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D3452954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::UpdateFPItemIfNeeded(id *a1@<X0>, double *a2@<X1>, int a3@<W2>, unsigned int a4@<W3>, unsigned int a5@<W4>, void *a6@<X8>)
{
  id v11 = *a1;
  size_t v18 = 0;
  uint64_t v19 = 0;
  unint64_t v17 = 0;
  unint64_t v21 = &v17;
  char v22 = 0;
  long long v12 = (void **)operator new(8uLL);
  unint64_t v17 = v12;
  size_t v18 = v12;
  uint64_t v19 = v12 + 1;
  id v13 = v11;
  *long long v12 = v13;
  size_t v18 = v12 + 1;
  TNode::UpdateFPItemsIfNeeded((FINode ***)&v17, a2, a3, a4, a5, v20);
  unint64_t v21 = &v17;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v21);

  uint64_t v14 = v20[0];
  if (v20[0] == v20[1])
  {
    id v15 = 0;
    id v16 = 0;
  }
  else
  {
    id v15 = *(id *)v20[0];
    id v16 = *(id *)(v14 + 8);
  }
  *a6 = v15;
  a6[1] = v16;
  unint64_t v17 = (void **)v20;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&v17);
}

void sub_1D3452A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

uint64_t TNode::UpdateFPItemsIfNeeded@<X0>(FINode ***a1@<X0>, double *a2@<X1>, int a3@<W2>, unsigned int a4@<W3>, unsigned int a5@<W4>, uint64_t *a6@<X8>)
{
  id v136 = (id)*MEMORY[0x1E4F143B8];
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::vector(a6, a1[1] - *a1);
  long long v111 = 0u;
  long long v112 = 0u;
  int v113 = 1065353216;
  long long v108 = 0u;
  long long v109 = 0u;
  int v110 = 1065353216;
  uint64_t v9 = *a1;
  v101 = a1;
  if (*a1 != a1[1])
  {
    int v94 = a2;
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = TNodeFromFINode(*v9);
      long long v12 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v11);
      os_unfair_lock_lock(v12);
      uint64_t v14 = *(TFSInfo **)(v11 + 16);
      id v13 = *(std::__shared_weak_count **)(v11 + 24);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v12);
      TFSInfo::GetFPItem(v14);
      id v15 = (id)objc_claimAutoreleasedReturnValue();
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      }
      uint64_t v16 = TNodeFromFINode(*v9);
      unint64_t v17 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v16);
      os_unfair_lock_lock(v17);
      TNodePtr::TNodePtr((TNodePtr *)&location, *(const TNode **)(v16 + 48));
      os_unfair_lock_unlock(v17);
      if (v15) {
        break;
      }
      if (!TNodeFromFINode((FINode *)location) || !ICloudDriveFPFSEnabled()) {
        goto LABEL_27;
      }
      uint64_t v20 = TNodeFromFINode(*v9);
      unint64_t v21 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v20);
      os_unfair_lock_lock(v21);
      uint64_t v23 = *(TFSInfo **)(v20 + 16);
      char v22 = *(std::__shared_weak_count **)(v20 + 24);
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v21);
      TFSInfo::Name(v23, (TString *)&cf1);
      if (v22) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v22);
      }
      TString::TString((TString *)cf2, "Documents", 9uLL);
      int v24 = CFEqual(cf1, cf2[0]);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
      if (!v24)
      {
LABEL_27:

LABEL_28:
        unint64_t v33 = (TNode *)TNodeFromFINode(*v9);
        int v34 = TNode::VirtualType(v33);
        uint64_t v35 = TNodeFromFINode(*v9);
        uint64_t v36 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v35);
        os_unfair_lock_lock(v36);
        uint64_t v38 = *(void *)(v35 + 16);
        long long v37 = *(std::__shared_weak_count **)(v35 + 24);
        if (v37) {
          atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v36);
        uint64_t v39 = (os_unfair_lock_s *)(v38 + 96);
        os_unfair_lock_lock((os_unfair_lock_t)(v38 + 96));
        uint64_t v40 = *(unsigned __int8 **)(v38 + 80);
        if (v40)
        {
          os_unfair_lock_lock((os_unfair_lock_t)v40 + 18);
          int v41 = v40[76];
          os_unfair_lock_unlock((os_unfair_lock_t)v40 + 18);
          if (v41 == 1) {
            uint64_t v40 = (unsigned __int8 *)*((id *)v40 + 3);
          }
          else {
            uint64_t v40 = 0;
          }
        }
        os_unfair_lock_unlock(v39);
        v134 = [v40 domain];

        if (v37) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v37);
        }
        if (v34 == 27 && v134)
        {
          objc_initWeak(&location, *v9);
          uint64_t v121 = v10;
          p_id location = (id *)&v134;
          uint64_t v42 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>((uint64_t)&v111, (id *)&v134, (uint64_t)&std::piecewise_construct, &p_location);
          std::pair<FINode * {__weak},unsigned long>::operator=[abi:ne180100]((uint64_t)(v42 + 3), &location);
          objc_destroyWeak(&location);
        }
        else
        {
          TNodePtr v43 = (TNode *)TNodeFromFINode(*v9);
          id location = 0;
          TNode::CopyURL(v43, (const __CFURL **)&location);
          id v119 = location;
          if (location)
          {
            objc_initWeak(&location, *v9);
            uint64_t v121 = v10;
            p_id location = &v119;
            uint64_t v44 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>,std::tuple<>>((uint64_t)&v108, (CFTypeRef *)&v119, (uint64_t)&std::piecewise_construct, (const void ***)&p_location);
            std::pair<FINode * {__weak},unsigned long>::operator=[abi:ne180100]((uint64_t)(v44 + 3), &location);
            objc_destroyWeak(&location);
          }
          else
          {
            uint64_t v45 = *a6;
            unint64_t v46 = *(void **)(*a6 + 16 * (void)v10);
            *(void *)(*a6 + 16 * (void)v10) = 0;

            uint64_t v47 = v45 + 16 * (void)v10;
            uint64_t v48 = *(void **)(v47 + 8);
            *(void *)(v47 + 8) = 0;
          }
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v119);
        }

        id v15 = 0;
        goto LABEL_44;
      }
      unint64_t v25 = +[FIPresentationNodeMap presentationNodeForKeyNode:*v9];
      uint64_t v26 = static_objc_cast<NSString,objc_object * {__strong}>(v25);

      if (v26
        && (uint64_t v27 = (TNode *)[v26 asTNode], (v28 = v27) != 0)
        && (id v29 = (TNode *)TNode::VirtualType(v27), v29 == 25))
      {
        long long v30 = (os_unfair_lock_s *)TNode::InfoLock(v29);
        os_unfair_lock_lock(v30);
        long long v32 = (TFSInfo *)*((void *)v28 + 2);
        long long v31 = (std::__shared_weak_count *)*((void *)v28 + 3);
        if (v31) {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v30);
        TFSInfo::GetFPItem(v32);
        id v15 = (id)objc_claimAutoreleasedReturnValue();
        if (v31) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v31);
        }

        if (v15) {
          break;
        }
      }
      else
      {
      }
      uint64_t v49 = (TNode *)TNodeFromFINode(*v9);
      uint64_t v50 = TNode::GetFIProvider(v49);
      unint64_t v95 = v50;
      uint64_t v51 = TNodeFromFINode((FINode *)location);
      uint64_t v52 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v51);
      os_unfair_lock_lock(v52);
      long long v54 = *(TFSInfo **)(v51 + 16);
      unsigned int v53 = *(std::__shared_weak_count **)(v51 + 24);
      if (v53) {
        atomic_fetch_add_explicit(&v53->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v52);
      int v99 = TFSInfo::GetFPItem(v54);
      if (v53) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v53);
      }
      if (objc_msgSend(v99, "isContainer", v93)
        && (long long v55 = (TCachedAppLibraryCollections *)[v50 isiCloudDriveProvider], v55))
      {
        TString v56 = (TCachedAppLibraryCollections *)TCachedAppLibraryCollections::Singleton(v55);
        unsigned int v57 = [v50 identifier];
        CFTypeRef cf1 = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable((TString *)&cf1, v57);

        uint64_t v93 = TCachedAppLibraryCollections::CachedCollection(v56, (const TString *)&cf1, 0);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);

        *(_OWORD *)CFTypeRef cf2 = 0u;
        long long v115 = 0u;
        long long v116 = 0u;
        long long v117 = 0u;
        id obj = [v93 items];
        uint64_t v58 = [obj countByEnumeratingWithState:cf2 objects:&cf1 count:16];
        if (v58)
        {
          uint64_t v59 = *(void *)v115;
LABEL_55:
          uint64_t v60 = 0;
          while (1)
          {
            if (*(void *)v115 != v59) {
              objc_enumerationMutation(obj);
            }
            id v15 = *((id *)cf2[1] + v60);
            uint64_t v61 = objc_msgSend(v15, "fp_appContainerBundleIdentifier");
            uint64_t v62 = objc_msgSend(v99, "fp_appContainerBundleIdentifier");
            char v63 = [v61 isEqualToString:v62];

            if (v63) {
              break;
            }

            if (v58 == ++v60)
            {
              uint64_t v58 = [obj countByEnumeratingWithState:cf2 objects:&cf1 count:16];
              if (v58) {
                goto LABEL_55;
              }
              goto LABEL_61;
            }
          }
        }
        else
        {
LABEL_61:
          id v15 = 0;
        }
      }
      else
      {
        id v15 = 0;
      }

      if (!v15) {
        goto LABEL_28;
      }
LABEL_9:
      uint64_t v18 = *a6 + 16 * (void)v10;
      objc_storeStrong((id *)v18, v15);
      uint64_t v19 = *(void **)(v18 + 8);
      *(void *)(v18 + 8) = 0;

      if (a3)
      {
        v134 = *v9;
        id v15 = v15;
        id v135 = v15;
        uint64_t v121 = 0;
        unsigned int v122 = 0;
        id location = 0;
        p_id location = &location;
        char v124 = 0;
        id location = operator new(0x10uLL);
        uint64_t v121 = location;
        unsigned int v122 = (char *)location + 16;
        uint64_t v121 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v122, (id *)&v134, &v136, location);
        TNode::AttachFPItemsMetadata(&location, a4, a5);
        p_id location = &location;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&p_location);
      }
LABEL_44:

      ++v9;
      uint64_t v10 = (char *)v10 + 1;
      if (v9 == v101[1])
      {
        uint64_t v64 = *((void *)&v112 + 1);
        uint64_t v65 = *((void *)&v109 + 1);
        a2 = v94;
        goto LABEL_68;
      }
    }

    goto LABEL_9;
  }
  uint64_t v65 = 0;
  uint64_t v64 = 0;
LABEL_68:
  if (v64 | v65)
  {
    double v66 = *a2;
    id v67 = objc_alloc(MEMORY[0x1E4F1CA48]);
    uint64_t v68 = (void *)[v67 initWithCapacity:*((void *)&v112 + 1)];
    uint64_t v69 = (uint64_t **)v112;
    for (i = v68; v69; uint64_t v69 = (uint64_t **)*v69)
    {
      v71 = v69[2];
      [i addObject:v71];
    }
    *(double *)CFTypeRef cf2 = v66 / (double)(unint64_t)(v64 + v65) * (double)*((unint64_t *)&v112 + 1);
    std::unordered_map<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>::unordered_map((uint64_t)v105, (uint64_t)&v111);
    LOBYTE(v106) = a3;
    HIBYTE(v106) = a4;
    char v107 = a5;
    long long v128 = 0;
    uint64_t v72 = operator new(0x38uLL);
    *(void *)uint64_t v72 = &unk_1F2ABAC38;
    std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__hash_table((uint64_t)(v72 + 4), v105);
    v72[24] = v106;
    *((unsigned char *)v72 + 50) = v107;
    long long v128 = v72;
    TNode::RootFPItemsForDomainsWithTimeout(i, (double *)cf2, (uint64_t)&cf1, (uint64_t)&location);
    std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::~__value_func[abi:ne180100](&cf1);
    std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)v105);
    IDContainerIteratorAdaptor<NSMutableArray<FPProviderDomain *>>::NSForwardIterator<NSMutableArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)&cf1, i);
    for (j = (id *)location; ; j += 2)
    {
      IDContainerIteratorAdaptor<NSMutableArray<FPProviderDomain *>>::IDContainerIteratorAdaptor((uint64_t)cf2, -1, i);
      if (cf1 == cf2[0])
      {
        BOOL v74 = v133 == v118;

        if (v74)
        {

          CFTypeRef cf1 = &location;
          std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&cf1);

          id v79 = objc_alloc(MEMORY[0x1E4F1CA48]);
          int v80 = (void *)[v79 initWithCapacity:*((void *)&v109 + 1)];
          v81 = (uint64_t **)v109;
          for (id k = v80; v81; v81 = (uint64_t **)*v81)
          {
            v83 = v81[2];
            [k addObject:v83];
          }
          std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>::unordered_map((uint64_t)v102, (uint64_t)&v108);
          LOBYTE(v103) = a3;
          HIBYTE(v103) = a4;
          char v104 = a5;
          long long v128 = 0;
          CFIndex v84 = operator new(0x38uLL);
          *(void *)CFIndex v84 = &unk_1F2ABAC90;
          std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__hash_table((uint64_t)(v84 + 4), v102);
          v84[24] = v103;
          *((unsigned char *)v84 + 50) = v104;
          long long v128 = v84;
          TNode::FPItemsFromURLsWithTimeout((const __CFArray *)k, (uint64_t)&cf1, (uint64_t)&location);
          std::__function::__value_func<void ()(__CFURL const*,FPItem *,NSError *)>::~__value_func[abi:ne180100](&cf1);
          std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)v102);
          IDContainerIteratorAdaptor<NSMutableArray<NSURL *>>::NSForwardIterator<NSMutableArray<NSURL *>>::NSForwardIterator((uint64_t)&cf1, k);
          for (m = (id *)location; ; m += 2)
          {
            IDContainerIteratorAdaptor<NSMutableArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)cf2, -1, k);
            if (cf1 == cf2[0])
            {
              BOOL v86 = v133 == v118;

              if (v86)
              {

                CFTypeRef cf1 = &location;
                std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&cf1);

                goto LABEL_94;
              }
            }
            else
            {
            }
            id v87 = *(id *)(v127 + 8 * v132);
            unint64_t v88 = v87;
            cf2[0] = v87;
            if (v87) {
              CFRetain(v87);
            }
            p_id location = (id *)cf2;
            int v89 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>((uint64_t)&v108, cf2, (uint64_t)&std::piecewise_construct, &p_location);
            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(cf2);
            fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::operator=((id *)(*a6 + 16 * v89[4]), m);

            uint64_t v90 = v132;
            if (v132 >= v131 - 1)
            {
              uint64_t v91 = [(id)cf1 countByEnumeratingWithState:&v126 objects:v129 count:4];
              uint64_t v90 = -1;
              uint64_t v131 = v91;
              uint64_t v132 = -1;
            }
            if (v130 != *v128)
            {
              objc_enumerationMutation((id)cf1);
              uint64_t v90 = v132;
            }
            ++v133;
            uint64_t v132 = v90 + 1;
          }
        }
      }
      else
      {
      }
      unint64_t v75 = (FINode *)*(id *)(v127 + 8 * v132);
      v134 = v75;
      p_id location = (id *)&v134;
      v76 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>((uint64_t)&v111, (id *)&v134, (uint64_t)&std::piecewise_construct, &p_location);
      fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::operator=((id *)(*a6 + 16 * (void)v76[4]), j);

      uint64_t v77 = v132;
      if (v132 >= v131 - 1)
      {
        uint64_t v78 = [(id)cf1 countByEnumeratingWithState:&v126 objects:v129 count:4];
        uint64_t v77 = -1;
        uint64_t v131 = v78;
        uint64_t v132 = -1;
      }
      if (v130 != *v128)
      {
        objc_enumerationMutation((id)cf1);
        uint64_t v77 = v132;
      }
      ++v133;
      uint64_t v132 = v77 + 1;
    }
  }
LABEL_94:
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)&v108);
  return std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)&v111);
}

void sub_1D345368C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,id location)
{
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)&a31);
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)&a37);
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a37);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__deallocate_node(uint64_t a1, id *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      id v3 = (id *)*v2;
      objc_destroyWeak(v2 + 3);

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)uint64_t result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  id v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    *id v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<NSURL *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D3453B28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(__CFURL const*,FPItem *,NSError *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::destroy_deallocate(void *a1)
{
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)a1 + 8);
  operator delete(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      id v3 = *(id *)v2;
      objc_destroyWeak((id *)v2 + 3);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)v2 + 2);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t ICloudDriveFPFSEnabled(void)
{
  {
    ICloudDriveFPFSEnabled(void)::enabled = UseFileProviderFramework();
  }
  return ICloudDriveFPFSEnabled(void)::enabled;
}

void sub_1D3453CF0(_Unwind_Exception *a1)
{
}

void TNode::RootFPItemsForDomainsWithTimeout(void *a1@<X0>, double *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  id v6 = a1;
  unint64_t v7 = (char *)operator new(0x40uLL);
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = 0;
  *(void *)unint64_t v7 = &unk_1F2ABB400;
  *(_OWORD *)(v7 + 24) = 0u;
  unint64_t v8 = v7 + 24;
  *(_OWORD *)(v7 + 40) = 0u;
  *((_DWORD *)v7 + 14) = 1065353216;
  uint64_t v9 = (char *)operator new(0x58uLL);
  *((void *)v9 + 2) = 0;
  *((void *)v9 + 1) = 0;
  *(void *)uint64_t v9 = &unk_1F2ABB438;
  *((void *)v9 + 3) = 850045863;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *((_OWORD *)v9 + 4) = 0u;
  *((void *)v9 + 10) = 0;
  id v32 = v6;
  v54[0] = v32;
  v54[1] = v7 + 24;
  v54[2] = v7;
  v54[3] = v9 + 24;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
  uint64_t v39 = (std::__shared_weak_count *)v7;
  uint64_t v40 = (std::mutex *)(v9 + 24);
  v54[4] = v9;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v9 + 1, 1uLL, memory_order_relaxed);
  uint64_t v38 = (std::__shared_weak_count *)v9;
  uint64_t v10 = FPItemManagerInstance();
  if (v10 && [v32 count])
  {
    uint64_t v31 = a4;
    uint64_t v36 = v10;
    group = dispatch_group_create();
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    id obj = v32;
    uint64_t v11 = [obj countByEnumeratingWithState:&v46 objects:v68 count:16];
    if (v11)
    {
      uint64_t v35 = *(void *)v47;
      do
      {
        for (uint64_t i = 0; i != v11; ++i)
        {
          if (*(void *)v47 != v35) {
            objc_enumerationMutation(obj);
          }
          id v13 = *(void **)(*((void *)&v46 + 1) + 8 * i);
          dispatch_group_enter(group);
          v61[0] = MEMORY[0x1E4F143A8];
          v61[1] = 3321888768;
          v61[2] = ___ZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEE_block_invoke;
          v61[3] = &__block_descriptor_112_ea8_32c174_ZTSKZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEEE3__1_e28_v24__0__FPItem_8__NSError_16l;
          id v14 = v13;
          __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
          __p[0].__r_.__value_.__l.__size_ = (std::string::size_type)group;
          std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)&__p[0].__r_.__value_.__r.__words[2], a3);
          unsigned int v57 = v7 + 24;
          uint64_t v58 = (std::__shared_weak_count *)v7;
          atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
          uint64_t v59 = v9 + 24;
          uint64_t v60 = (std::__shared_weak_count *)v9;
          atomic_fetch_add_explicit((atomic_ullong *volatile)v9 + 1, 1uLL, memory_order_relaxed);
          uint64_t v62 = __p[0].__r_.__value_.__l.__data_;
          id v63 = (id)__p[0].__r_.__value_.__l.__size_;
          std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)v64, (uint64_t)&__p[0].__r_.__value_.__r.__words[2]);
          v64[4] = v57;
          uint64_t v65 = v58;
          if (v58) {
            atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          double v66 = v59;
          id v67 = v60;
          if (v60) {
            atomic_fetch_add_explicit(&v60->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          [v36 fetchRootItemForProviderDomain:v14 completionHandler:v61];
          if (v60) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v60);
          }
          if (v58) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v58);
          }
          std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::~__value_func[abi:ne180100](&__p[0].__r_.__value_.__r.__words[2]);

          if (v67) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v67);
          }
          if (v65) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v65);
          }
          std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::~__value_func[abi:ne180100](v64);
        }
        uint64_t v11 = [obj countByEnumeratingWithState:&v46 objects:v68 count:16];
      }
      while (v11);
    }

    dispatch_time_t v15 = dispatch_time(0, (uint64_t)(*a2 * 1000000000.0));
    if (dispatch_group_wait(group, v15))
    {
      std::mutex::lock(v40);
      long long v41 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      id v16 = obj;
      uint64_t v17 = [v16 countByEnumeratingWithState:&v41 objects:v55 count:16];
      if (v17)
      {
        uint64_t v18 = *(void *)v42;
        do
        {
          for (uint64_t j = 0; j != v17; ++j)
          {
            if (*(void *)v42 != v18) {
              objc_enumerationMutation(v16);
            }
            uint64_t v45 = *(void **)(*((void *)&v41 + 1) + 8 * j);
            if (!std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::find<FPProviderDomain * {__strong}>(v8, &v45))
            {
              *(void *)&long long buf = "Timed out (%fs) fetching root item for domain: %{public}@";
              *((void *)&buf + 1) = 57;
              FormatDetails<std::chrono::duration<double,std::ratio<1l,1l>>,FPProviderDomain * {__strong}>(&buf, a2, &v45, __p);
              uint64_t v20 = LogObj(4);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  unint64_t v21 = __p;
                }
                else {
                  unint64_t v21 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
                }
                LODWORD(buf) = 136446210;
                *(void *)((char *)&buf + 4) = v21;
                _os_log_impl(&dword_1D343E000, v20, OS_LOG_TYPE_ERROR, "RootFPItemsForDomainsWithTimeout - %{public}s", (uint8_t *)&buf, 0xCu);
              }

              if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                char v22 = __p;
              }
              else {
                char v22 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
              }
              objc_msgSend(MEMORY[0x1E4F28C58], "fp_errorWithPOSIXCode:description:", 100060, @"%s", v22);
              uint64_t v23 = (uint64_t *)(id)objc_claimAutoreleasedReturnValue();
              *(void *)&long long buf = &v45;
              int v24 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>((uint64_t)v8, &v45, (uint64_t)&std::piecewise_construct, (id **)&buf);
              unint64_t v25 = v24[3];
              v24[3] = 0;

              uint64_t v26 = v24[4];
              v24[4] = v23;

              if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p[0].__r_.__value_.__l.__data_);
              }
            }
          }
          uint64_t v17 = [v16 countByEnumeratingWithState:&v41 objects:v55 count:16];
        }
        while (v17);
      }

      TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)v54, v31);
    }
    else
    {
      std::mutex::lock(v40);
      TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)v54, a4);
    }
    std::mutex::unlock(v40);

    uint64_t v10 = v36;
  }
  else
  {
    if (*(void *)(a3 + 24))
    {
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      id v27 = v32;
      uint64_t v28 = [v27 countByEnumeratingWithState:&v50 objects:v69 count:16];
      if (v28)
      {
        uint64_t v29 = *(void *)v51;
        do
        {
          for (uint64_t k = 0; k != v28; ++k)
          {
            if (*(void *)v51 != v29) {
              objc_enumerationMutation(v27);
            }
            std::function<void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(a3, *(void **)(*((void *)&v50 + 1) + 8 * k), 0, 0);
          }
          uint64_t v28 = [v27 countByEnumeratingWithState:&v50 objects:v69 count:16];
        }
        while (v28);
      }
    }
    std::mutex::lock(v40);
    TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)v54, a4);
    std::mutex::unlock(v40);
  }

  std::__shared_weak_count::__release_shared[abi:ne180100](v38);
  std::__shared_weak_count::__release_shared[abi:ne180100](v39);

  std::__shared_weak_count::__release_shared[abi:ne180100](v38);
  std::__shared_weak_count::__release_shared[abi:ne180100](v39);
}

void sub_1D34543D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,std::__shared_weak_count *a22,std::__shared_weak_count *a23,std::mutex *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::~$_0((uint64_t)&a51);
  std::__shared_weak_count::__release_shared[abi:ne180100](a22);
  std::__shared_weak_count::__release_shared[abi:ne180100](a23);

  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void TNode::FPItemsFromURLsWithTimeout(__CFArray const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&)::$_0::operator()(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  id v4 = **(id **)(a1 + 32);
  uint64_t v6 = *(void *)a1;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)v34, v4);
  IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor((uint64_t)v33, -1, v4);
  unint64_t v7 = std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray>>((uint64_t)v34, (uint64_t)v33);

  type_traits_extras::CopyAsHelper<std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::MakeWithCapacity(v7, (uint64_t)&v31);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)&obj, v4);
  IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor((uint64_t)v35, -1, v4);
  long long v30 = v4;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v29 = v5;
  while (obj != v35[0] || v41 != v35[16])
  {
    id v8 = *(id *)(v37[1] + 8 * v40);
    uint64_t v9 = v8;
    v43[0] = v8;
    if (v8) {
      CFRetain(v8);
    }
    v42[0] = v43;
    uint64_t v10 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>(v6, v43, (uint64_t)&std::piecewise_construct, v42);
    uint64_t v11 = (uint64_t)(v10 + 3);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v43);
    uint64_t v12 = (uint64_t)(v10 + 5);
    uint64_t v13 = (uint64_t)v10[7];
    if (v13)
    {
      v42[0] = 0;
      id v14 = std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v11);
      v43[0] = 0;
      dispatch_time_t v15 = std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v12);
      std::function<void ()(__CFURL const*,FPItem *,NSError *)>::operator()(v13, (uint64_t)v9, v14, v15);
    }
    v42[0] = 0;
    uint64_t v16 = std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v11);
    v43[0] = 0;
    uint64_t v17 = std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(v12);

    uint64_t v18 = *((void *)&v31 + 1);
    if (*((void *)&v31 + 1) >= v32[0])
    {
      uint64_t v20 = (uint64_t)(*((void *)&v31 + 1) - v31) >> 4;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 60) {
        std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v22 = v32[0] - v31;
      if ((uint64_t)(v32[0] - v31) >> 3 > v21) {
        unint64_t v21 = v22 >> 3;
      }
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v23 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v21;
      }
      v42[4] = v32;
      int v24 = std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)v32, v23);
      unint64_t v25 = &v24[2 * v20];
      v42[0] = v24;
      v42[1] = v25;
      v42[3] = &v24[2 * v26];
      uint64_t *v25 = v16;
      v25[1] = v17;
      v42[2] = v25 + 2;
      std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__swap_out_circular_buffer((uint64_t *)&v31, v42);
      uint64_t v19 = *((void *)&v31 + 1);
      std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)v42);
    }
    else
    {
      **((void **)&v31 + 1) = v16;
      *(void *)(v18 + 8) = v17;
      uint64_t v19 = v18 + 16;
    }
    *((void *)&v31 + 1) = v19;

    uint64_t v27 = v40;
    if (v40 >= v39 - 1)
    {
      uint64_t v28 = [obj countByEnumeratingWithState:v37 objects:v38 count:4];
      uint64_t v27 = -1;
      uint64_t v39 = v28;
      uint64_t v40 = -1;
    }
    if (v38[4] != *(void *)v37[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v27 = v40;
    }
    ++v41;
    uint64_t v40 = v27 + 1;
  }
  if (v29)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);

    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
  else
  {
  }
  *(_OWORD *)a2 = v31;
  *(void *)(a2 + 16) = v32[0];
  v32[0] = 0;
  long long v31 = 0uLL;
  id obj = &v31;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&obj);
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
}

void sub_1D3454A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (v69) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v69);
  }
  *(void *)(v70 - 96) = &a13;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v70 - 96));
  if (v69) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v69);
  }

  _Unwind_Resume(a1);
}

id std::optional<FPItem * {__strong}>::value_or[abi:ne180100]<decltype(nullptr)>(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    return *(id *)a1;
  }
  else {
    return 0;
  }
}

uint64_t IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D3454B78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D3454C3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::operator()(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *(void **)(a1 + 8);
  id v4 = *(std::__shared_weak_count **)(a1 + 16);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v26, *(void **)a1);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::IDContainerIteratorAdaptor((uint64_t)v25, -1, *(void **)a1);
  unint64_t v6 = std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>>((uint64_t)v26, (uint64_t)v25);

  type_traits_extras::CopyAsHelper<std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::MakeWithCapacity(v6, (uint64_t)&v23);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)&obj, *(void **)a1);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::IDContainerIteratorAdaptor((uint64_t)v27, -1, *(void **)a1);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = v4;
  while (obj != v27[0] || v33 != v27[16])
  {
    id v7 = *(id *)(v29[1] + 8 * v32);
    id v34 = v7;
    if (std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::find<FPProviderDomain * {__strong}>(v5, &v34))
    {
      v35[0] = &v34;
      id v8 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>((uint64_t)v5, &v34, (uint64_t)&std::piecewise_construct, v35);
      uint64_t v9 = v8[3];
      uint64_t v10 = v8[4];
    }
    else
    {
      uint64_t v10 = 0;
      uint64_t v9 = 0;
    }

    uint64_t v11 = *((void *)&v23 + 1);
    if (*((void *)&v23 + 1) >= v24)
    {
      uint64_t v13 = (uint64_t)(*((void *)&v23 + 1) - v23) >> 4;
      unint64_t v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) >> 60) {
        std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v15 = v24 - v23;
      if ((uint64_t)(v24 - v23) >> 3 > v14) {
        unint64_t v14 = v15 >> 3;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v14;
      }
      v35[4] = (id *)&v24;
      uint64_t v17 = (id *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)&v24, v16);
      uint64_t v18 = &v17[2 * v13];
      v35[0] = v17;
      v35[1] = v18;
      uint64_t v35[3] = &v17[2 * v19];
      *uint64_t v18 = v9;
      v18[1] = v10;
      v35[2] = v18 + 2;
      std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__swap_out_circular_buffer((uint64_t *)&v23, v35);
      uint64_t v12 = *((void *)&v23 + 1);
      std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)v35);
    }
    else
    {
      **((void **)&v23 + 1) = v9;
      *(void *)(v11 + 8) = v10;
      uint64_t v12 = v11 + 16;
    }
    *((void *)&v23 + 1) = v12;

    uint64_t v20 = v32;
    if (v32 >= v31 - 1)
    {
      uint64_t v21 = [obj countByEnumeratingWithState:v29 objects:v30 count:4];
      uint64_t v20 = -1;
      uint64_t v31 = v21;
      uint64_t v32 = -1;
    }
    if (v30[4] != *(void *)v29[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v20 = v32;
    }
    ++v33;
    uint64_t v32 = v20 + 1;
  }
  if (v22)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);

    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  }
  else
  {
  }
  *(_OWORD *)a2 = v23;
  *(void *)(a2 + 16) = v24;
  unint64_t v24 = 0;
  long long v23 = 0uLL;
  id obj = &v23;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&obj);
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  }
}

void sub_1D3454F74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (v65) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v65);
  }
  *(void *)(v66 - 96) = &a11;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v66 - 96));
  if (v65) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v65);
  }
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34550A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D3455168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void type_traits_extras::CopyAsHelper<std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::MakeWithCapacity(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::reserve((uint64_t *)&v3, a1);
  *(_OWORD *)a2 = v3;
  *(void *)(a2 + 16) = v4;
  uint64_t v4 = 0;
  long long v3 = 0uLL;
  uint64_t v5 = (void **)&v3;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void sub_1D34551E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = (uint64_t *)*a1;
  if (*v2)
  {
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    long long v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 16)
  {

    uint64_t v5 = *(void **)(i - 16);
  }
  *(void *)(a1 + 8) = a2;
}

uint64_t std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 16 * v6;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1D3455324(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  uint64_t v5 = (void *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  uint64_t v6 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 128) = -1;
  if (v4 && [v4 count] && (uint64_t v7 = *(void *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    uint64_t v8 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    uint64_t *v6 = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v9 = *(void *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            void *v5 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            uint64_t v11 = -1;
            uint64_t *v6 = -1;
          }
          if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            uint64_t v11 = *v6;
          }
          uint64_t v13 = *(void *)(a1 + 128) + 1;
          *(void *)(a1 + 120) = ++v11;
          *(void *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(void *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(void *)(a1 + 120) = *(void *)(a2 + 120);
      *(void *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1D34554A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  uint64_t v5 = (void *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  uint64_t v6 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 128) = -1;
  if (v4 && [v4 count] && (uint64_t v7 = *(void *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    uint64_t v8 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    uint64_t *v6 = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v9 = *(void *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            void *v5 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            uint64_t v11 = -1;
            uint64_t *v6 = -1;
          }
          if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            uint64_t v11 = *v6;
          }
          uint64_t v13 = *(void *)(a1 + 128) + 1;
          *(void *)(a1 + 120) = ++v11;
          *(void *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(void *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(void *)(a1 + 120) = *(void *)(a2 + 120);
      *(void *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1D3455630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>>(uint64_t a1, uint64_t a2)
{
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v7, a2);
  uint64_t v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    uint64_t v4 = v12;
    if (v12 >= v11 - 1)
    {
      uint64_t v5 = [obj countByEnumeratingWithState:v9 objects:v10 count:4];
      uint64_t v4 = -1;
      uint64_t v11 = v5;
      uint64_t v12 = -1;
    }
    if (v10[4] != *(void *)v9[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v4 = v12;
    }
    uint64_t v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1D3455730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = a7;
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *a3 = 0;
      a3[1] = 0;
      *(_OWORD *)(v8 - 16) = v9;
      v8 -= 16;
      v7 -= 16;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v8;
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::reverse_iterator<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
  }
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray>>(uint64_t a1, uint64_t a2)
{
  IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)v7, a2);
  uint64_t v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    uint64_t v4 = v12;
    if (v12 >= v11 - 1)
    {
      uint64_t v5 = [obj countByEnumeratingWithState:v9 objects:v10 count:4];
      uint64_t v4 = -1;
      uint64_t v11 = v5;
      uint64_t v12 = -1;
    }
    if (v10[4] != *(void *)v9[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v4 = v12;
    }
    uint64_t v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1D3455A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

void *std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (void *)a1[1];
    uint64_t v5 = &v4[2 * a2];
    uint64_t v6 = 16 * a2;
    do
    {
      fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::optional_err(v4);
      v4 += 2;
      v6 -= 16;
    }
    while (v6);
    a1[1] = v5;
  }
  return a1;
}

void sub_1D3455AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void *fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::optional_err(void *a1)
{
  *a1 = 0;
  a1[1] = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F28760] code:-1 userInfo:0];
  return a1;
}

void sub_1D3455B1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

uint64_t std::pair<FINode * {__weak},unsigned long>::operator=[abi:ne180100](uint64_t a1, id *location)
{
  id WeakRetained = objc_loadWeakRetained(location);
  objc_storeWeak((id *)a1, WeakRetained);

  *(void *)(a1 + 8) = location[1];
  return a1;
}

uint64_t std::unordered_map<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(id **)(a2 + 16); i; uint64_t i = (id *)*i)
    std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::pair<FPProviderDomain * const {__strong},std::pair<FINode * {__weak},unsigned long>> const&>(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_1D3455C28(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>,std::tuple<>>(uint64_t a1, CFTypeRef *a2, uint64_t a3, const void ***a4)
{
  CFHashCode v8 = CFHash(*a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      CFHashCode v4 = v8;
      if (v8 >= v10) {
        CFHashCode v4 = v8 % v10;
      }
    }
    else
    {
      CFHashCode v4 = (v10 - 1) & v8;
    }
    uint64_t v13 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (IsEqual(i[2], *a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>,std::tuple<>>(a1, v9, a4, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        CFHashCode v4 = v9 % v10;
      }
      else {
        CFHashCode v4 = v9;
      }
    }
    else
    {
      CFHashCode v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *uint64_t v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (uint64_t **)v25[0];
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D3455EA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

const void **std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const void ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  CFHashCode v8 = operator new(0x28uLL);
  *(void *)(a4 + 8) = v7;
  *(void *)a4 = v8;
  *(unsigned char *)(a4 + 16) = 0;
  *(void *)CFHashCode v8 = 0;
  *((void *)v8 + 1) = a2;
  uint64_t result = std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>>::pair[abi:ne180100]<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>((const void **)v8 + 2, *a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D3455F30(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

const void **std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>>::pair[abi:ne180100]<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(const void **a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    CFRetain(v3);
  }
  a1[1] = 0;
  a1[2] = 0;
  return a1;
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::destroy_deallocate(void *a1)
{
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::function<void ()(__CFURL const*,FPItem *,NSError *)>::operator()(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v9 = a2;
  id v8 = a3;
  id v7 = a4;
  uint64_t v6 = *(void *)(a1 + 24);
  if (!v6) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, uint64_t *, id *, id *))(*(void *)v6 + 48))(v6, &v9, &v8, &v7);
}

void sub_1D3456050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::operator()(unsigned char *a1, void ***a2, id *a3, void **a4)
{
  id v21 = (id)*MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v6 = *a4;
  id v7 = *a3;
  id v8 = v6;
  float v17 = (void ****)v5;
  if (v5) {
    CFRetain(v5);
  }
  long long v14 = (void ***)&v17;
  uint64_t v9 = (id *)std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>((uint64_t)(a1 + 8), (CFTypeRef *)&v17, (uint64_t)&std::piecewise_construct, &v14);
  id WeakRetained = (FINode *)objc_loadWeakRetained(v9 + 3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v17);
  if (WeakRetained)
  {
    id v11 = [(FINode *)WeakRetained fpItem];
    if (v11 == v7)
    {
    }
    else
    {
      BOOL v12 = a1[48] == 0;

      if (!v12)
      {
        uint64_t v13 = (const TNode *)TNodeFromFINode(WeakRetained);
        TNodePtr::TNodePtr(&v19, v13);
        id v20 = v7;
        unint64_t v15 = 0;
        float v16 = 0;
        long long v14 = 0;
        float v17 = &v14;
        char v18 = 0;
        long long v14 = (void ***)operator new(0x10uLL);
        unint64_t v15 = v14;
        float v16 = v14 + 2;
        unint64_t v15 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v16, (id *)&v19.fFINode, &v21, v14);
        TNode::AttachFPItemsMetadata((id **)&v14, a1[49], a1[50]);
        float v17 = &v14;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);
      }
    }
  }
}

void sub_1D3456208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, id a14, id a15)
{
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a12);

  _Unwind_Resume(a1);
}

id *fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::operator=(id *a1, id *a2)
{
  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<NSURL *>>::NSForwardIterator<NSMutableArray<NSURL *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFHashCode v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D3456364(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>(uint64_t a1, id *a2, id *a3, void *a4)
{
  CFHashCode v4 = a4;
  id v11 = a4;
  BOOL v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  if (a2 == a3)
  {
    id v7 = a4;
  }
  else
  {
    uint64_t v6 = a2;
    id v7 = v12;
    do
    {
      void *v4 = *v6;
      v4[1] = v6[1];
      v7 += 2;
      v6 += 2;
      CFHashCode v4 = v7;
    }
    while (v6 != a3);
    BOOL v12 = v7;
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v7;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>(*(void *)a1, **(void **)(a1 + 16), **(void **)(a1 + 16), **(void **)(a1 + 8), **(void **)(a1 + 8));
  }
  return a1;
}

void TNodeEvent::HandleInternalEvent(unint64_t a1)
{
  for (uint64_t i = 0; ; i)
  {
    long long v44 = i;
    int NextEvent = NodeEventGetNextEvent(&v44, a1);
    CFHashCode v4 = v44;

    if (!NextEvent) {
      break;
    }
    uint64_t v5 = v4;
    uint64_t i = v5;
    if (v5) {
      uint64_t v6 = v5 + 8;
    }
    else {
      uint64_t v6 = 0;
    }
    id v7 = (TDSNotifier *)*((void *)v6 + 8);
    v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v7;
    if (v7
      && (TDSNotifier::AddPtrReference(v7), v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value))
    {
      long long v42 = (TDSNotifier *)*((void *)v6 + 8);
      TDSNotifier::AddPtrReference(v42);
      v43.fFINode = (FINode *)*((id *)v42 + 3);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v42);
    }
    else
    {
      TNodePtr::TNodePtr(&v43, 0);
    }
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v41);
    if (!TNodeFromFINode(v43.fFINode)) {
      goto LABEL_38;
    }
    uint64_t v8 = TNodeFromFINode(v43.fFINode);
    uint64_t v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
    os_unfair_lock_lock(v9);
    uint64_t v11 = *(void *)(v8 + 16);
    char v10 = *(std::__shared_weak_count **)(v8 + 24);
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v9);
      int v12 = *(unsigned __int8 *)(v11 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
      if (!v12) {
        goto LABEL_15;
      }
    }
    else
    {
      os_unfair_lock_unlock(v9);
      if (!*(unsigned char *)(v11 + 112))
      {
LABEL_15:
        uint64_t v13 = TNodeFromFINode(v43.fFINode);
        long long v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v13);
        os_unfair_lock_lock(v14);
        float v16 = *(TFSInfo **)(v13 + 16);
        unint64_t v15 = *(std::__shared_weak_count **)(v13 + 24);
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v14);
        BOOL IsAlias = TFSInfo::IsAlias(v16);
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
        }
        if (!IsAlias) {
          goto LABEL_38;
        }
      }
    }
    char v18 = (TNode *)TNodeFromFINode(v43.fFINode);
    TNode::GetAliasTarget(v18, &v41);
    uint64_t v19 = TNodeFromFINode((FINode *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);

    if (!v19) {
      goto LABEL_38;
    }
    int v20 = *(_DWORD *)v6;
    if (*(_DWORD *)v6 == 1 || v20 == 4)
    {
      long long v37 = (TNode *)TNodeFromFINode(v43.fFINode);
      TNode::ClearAliasTarget(v37, 0);
    }
    else if (v20 == 5)
    {
      uint64_t v21 = TNodeFromFINode(v43.fFINode);
      uint64_t v22 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v21);
      os_unfair_lock_lock(v22);
      uint64_t v24 = *(void *)(v21 + 16);
      unint64_t v23 = *(std::__shared_weak_count **)(v21 + 24);
      if (v23) {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v22);
      unint64_t v25 = (os_unfair_lock_s *)(v24 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v24 + 100));
      int v26 = *(_DWORD *)(v24 + 115);
      os_unfair_lock_unlock(v25);
      if (v23) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v23);
      }
      fFINode = v43.fFINode;
      if ((v26 & 0x40) != 0) {
        goto LABEL_36;
      }
      uint64_t v28 = TNodeFromFINode(v43.fFINode);
      uint64_t v29 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v28);
      os_unfair_lock_lock(v29);
      uint64_t v31 = *(TFSInfo **)(v28 + 16);
      long long v30 = *(std::__shared_weak_count **)(v28 + 24);
      if (v30) {
        atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v29);
      BOOL v32 = TFSInfo::IsAlias(v31);
      if (v30) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v30);
      }
      if (v32)
      {
        unint64_t v33 = (TNode *)TNodeFromFINode(v43.fFINode);
        TNode::GetAliasTarget(v33, &v41);
        id v34 = (TNode *)TNodeFromFINode((FINode *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);
        BOOL v35 = TNode::IsInTrash(v34);

        if (v35)
        {
          fFINode = v43.fFINode;
LABEL_36:
          uint64_t v36 = (TNode *)TNodeFromFINode(fFINode);
          TNode::ClearAliasTarget(v36, 1);
        }
      }
    }
    else
    {
      int v38 = *((_DWORD *)v6 + 4);
      LODWORD(v42) = v38;
      if (v38)
      {
        if (v38 == 1936225392)
        {
          uint64_t v39 = (const TNode *)TNodeFromFINode(v43.fFINode);
          TNode::SendNotification(v39, 2, (id *)&v43.fFINode, 1768124270, 0);
        }
        else
        {
          uint64_t v40 = (const TNode *)TNodeFromFINode(v43.fFINode);
          v41.fData.__impl_.__unsigned int index = 0;
          std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Property const&,0,Property,20ul,0>(&v41, &v42);
          TNode::RequestInternalTask(v40, 1011, &v41, 0);
          TPropertyValue::~TPropertyValue(&v41);
        }
      }
    }
LABEL_38:
  }
}

void sub_1D34567C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a9);

  _Unwind_Resume(a1);
}

void ___ZN10TNodeEvent25GetInternalClientNotifierEv_block_invoke()
{
  EventQueue = (TNode *)TNodeEvent::CreateEventQueue(0);
  TNode::GetSuperRootNode((uint64_t *)v6, EventQueue);
  uint64_t v1 = (FINode *)TNodeFromFINode(v6[0]);

  v6[1] = 0;
  v6[2] = 0;
  v6[0] = v1;
  id v3 = TSystemNotificationTask::SystemNotificationQueue(v2);
  TClientChangeNotifier::Make(v6, (uint64_t)EventQueue, (uint64_t)TNodeEvent::HandleInternalEvent, v3, 0, (uint64_t)&v7);

  TNode::GetSuperRootNode(&v5, v4);
  TDSNotifier::Make();
}

void sub_1D3456948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  uint64_t v13 = *(std::__shared_weak_count **)(v11 - 24);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  _Unwind_Resume(a1);
}

uint64_t TNodeEvent::CreateEventQueue(void *a1)
{
  id v8 = a1;
  EventQueueSpinLock();
  os_unfair_lock_lock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);
  ++sEventQueueSerial;
  std::allocate_shared[abi:ne180100]<TBlockingEventQueue,std::allocator<TBlockingEventQueue>,void({block_pointer} {__strong}&)(OpaqueEventQueue *),unsigned long long &,void>(&v8, &sEventQueueSerial, &v7);
  uint64_t v1 = EventQueues();
  uint64_t v9 = &sEventQueueSerial;
  uint64_t v2 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v1, (unint64_t *)&sEventQueueSerial, (uint64_t)&std::piecewise_construct, &v9);
  long long v3 = v7;
  long long v7 = 0uLL;
  CFHashCode v4 = (std::__shared_weak_count *)v2[4];
  *(_OWORD *)(v2 + 3) = v3;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    if (*((void *)&v7 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
    }
  }
  uint64_t v5 = sEventQueueSerial;
  os_unfair_lock_unlock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);

  return v5;
}

void sub_1D3456A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void TClientChangeNotifier::HandleEvents(TClientChangeNotifier *this)
{
  unint64_t v2 = *((void *)this + 5);
  TBlockingEventQueue::EventQueueFromID(v2, &v4);
  uint64_t v3 = v4;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  if (v3) {
    std::function<void ()(OpaqueEventQueue *)>::operator()((uint64_t)this + 56, v2);
  }
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::operator()(uint64_t a1, unint64_t *a2)
{
  TBlockingEventQueue::EventQueueFromID(*a2, &v2);
  if (v2) {
    TBlockingEventQueue::Tickle(v2);
  }
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void sub_1D3456B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<void ()(OpaqueEventQueue *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

uint64_t TBlockingEventQueue::Tickle(TBlockingEventQueue *this)
{
  return std::function<void ()(OpaqueEventQueue *)>::operator()((uint64_t)this + 184, *((void *)this + 27));
}

void PullEventsFromQueue(unint64_t a1)
{
  uint64_t v2 = 0;
  while (1)
  {
    id v5 = v2;
    int NextEvent = NodeEventGetNextEvent(&v5, a1);
    id v4 = v5;

    if (!NextEvent) {
      break;
    }
    uint64_t v2 = v4;
    NodeDispatchEvent(v4);
  }
}

void sub_1D3456C38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void NodeDispatchEvent(void *a1)
{
  uint64_t v1 = a1;
  NodeEventFromNodeEventRef(v1, &v12);
  unsigned int v2 = *(_DWORD *)TNodeEventPtr::operator->(&v12) - 100;
  BOOL v3 = v2 > 0xB;
  int v4 = (1 << v2) & 0xC1F;
  if (v3 || v4 == 0)
  {
    uint64_t v8 = *(void *)(TNodeEventPtr::operator->(&v12) + 64);
    uint64_t v11 = (TDSNotifier *)v8;
    if (v8) {
      TDSNotifier::AddPtrReference((TDSNotifier *)v8);
    }
    uint64_t v9 = *(TClientChangeNotifier **)v8;
    char v10 = *(std::__shared_weak_count **)(v8 + 8);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    TClientChangeNotifier::DispatchEvent(v9, v1);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v11);
  }
  else
  {
    uint64_t v6 = (TNodeEvent *)TNodeEventPtr::operator->(&v12);
    uint64_t Monitor = TNodeEvent::GetMonitor(v6);
    (*(void (**)(void))(*(void *)(Monitor + 64) + 16))();
  }
  TNodeEventPtr::~TNodeEventPtr((id *)&v12);
}

void sub_1D3456D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TDSNotifier *a9, id a10)
{
  int v12 = v11;
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a9);
  TNodeEventPtr::~TNodeEventPtr(&a10);

  _Unwind_Resume(a1);
}

void std::function<void ()(FINodeEvent *)>::operator()(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, id *))(*(void *)v3 + 48))(v3, &v4);
}

void sub_1D3456DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D3456E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 16))();
}

void TClientChangeNotifier::DispatchEvent(TClientChangeNotifier *this, FINodeEvent *a2)
{
}

void sub_1D34572D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v6 = v5;

  TNodeEventPtr::~TNodeEventPtr((id *)va);
  _Unwind_Resume(a1);
}

FINodeEvent *NodeEventFromNodeEventRef@<X0>(FINodeEvent *a1@<X0>, FINodeEvent **a2@<X8>)
{
  uint64_t result = a1;
  *a2 = result;
  return result;
}

uint64_t NodeEventGetNextEvent(void *a1, unint64_t a2)
{
  TBlockingEventQueue::EventQueueFromID(a2, &v13);
  unsigned __int8 v4 = 0;
  if (a1 && a2 && v13)
  {
    unsigned __int8 v4 = 0;
    while (1)
    {
      TNodeEventPtr::TNodeEventPtr((TNodeEventPtr *)&v12, 0);
      TBlockingQueue<TNodeEventPtr>::Dequeue(v13, &v12, 0);
      if (!TNodeEventPtr::operator->(&v12)) {
        break;
      }
      id v5 = *(TDSNotifier **)(TNodeEventPtr::operator->(&v12) + 64);
      uint64_t v11 = v5;
      if (v5) {
        TDSNotifier::AddPtrReference(v5);
      }
      uint64_t v6 = (TNodeEvent *)TNodeEventPtr::operator->(&v12);
      if (TNodeEvent::GetMonitor(v6) || !v11 || (int v8 = atomic_load((unsigned int *)v11 + 10), v8 > 0))
      {
        id v10 = v12;
        NodeEventRefFromNodeEvent(&v10);
        *a1 = (id)objc_claimAutoreleasedReturnValue();
        TNodeEventPtr::~TNodeEventPtr(&v10);
        char v7 = 0;
        unsigned __int8 v4 = 1;
      }
      else
      {
        TDSNotifier::RemovePtrReference(v11);
        uint64_t v11 = 0;
        char v7 = 1;
      }
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v11);
      TNodeEventPtr::~TNodeEventPtr(&v12);
      if ((v7 & 1) == 0) {
        goto LABEL_16;
      }
    }
    TNodeEventPtr::~TNodeEventPtr(&v12);
  }
LABEL_16:
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  return v4;
}

void sub_1D34574CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, id a10, TDSNotifier *a11, id a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(a1);
}

uint64_t TNodeEventPtr::operator->(void *a1)
{
  if (*a1) {
    return *a1 + 8;
  }
  else {
    return 0;
  }
}

void TBlockingEventQueue::EventQueueFromID(unint64_t a1@<X0>, void *a2@<X8>)
{
  EventQueueSpinLock();
  os_unfair_lock_lock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);
  unint64_t v8 = a1;
  unsigned __int8 v4 = (void *)EventQueues();
  if (std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>(v4, &v8))
  {
    uint64_t v5 = EventQueues();
    uint64_t v9 = &v8;
    uint64_t v6 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v5, &v8, (uint64_t)&std::piecewise_construct, &v9);
    uint64_t v7 = v6[4];
    *a2 = v6[3];
    a2[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&EventQueueSpinLock(void)::sEventQueueSpinLock);
}

void sub_1D34575CC(_Unwind_Exception *a1)
{
}

uint64_t EventQueues(void)
{
  {
    operator new();
  }
  return EventQueues(void)::map;
}

void sub_1D3457664(_Unwind_Exception *a1)
{
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    id v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v13 = (void *)(a1 + 16);
  uint64_t i = operator new(0x28uLL);
  void *i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  i[4] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  uint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    void *i = *v21;
LABEL_38:
    void *v21 = i;
    goto LABEL_39;
  }
  void *i = *v13;
  *uint64_t v13 = i;
  *(void *)(v20 + 8 * v4) = v13;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    uint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34578B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void EventQueueSpinLock(void)
{
  {
    EventQueueSpinLock(void)::sEventQueueSpinLocuint64_t k = 0;
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  uint64_t v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v3 == v8)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

BOOL TBlockingQueue<TNodeEventPtr>::Dequeue(uint64_t a1, id *a2, int a3)
{
  uint64_t v6 = (std::mutex *)(a1 + 48);
  std::mutex::lock((std::mutex *)(a1 + 48));
  if (!a3)
  {
LABEL_5:
    BOOL v7 = 1;
    goto LABEL_9;
  }
  if (a3 == 0x7FFFFFFF)
  {
    if (!*(void *)(a1 + 40)) {
      TConditionVariable::Wait((TConditionVariable *)(a1 + 112), v6);
    }
    goto LABEL_5;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  if (!v8)
  {
    TConditionVariable::WaitWithTimeout((TConditionVariable *)(a1 + 112), v6, 1000 * a3);
    uint64_t v8 = *(void *)(a1 + 40);
  }
  BOOL v7 = v8 != 0;
LABEL_9:
  if (*(void *)(a1 + 40))
  {
    objc_storeStrong(a2, *(id *)(*(void *)(*(void *)(a1 + 8) + ((*(void *)(a1 + 32) >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * (*(void *)(a1 + 32) & 0x1FFLL)));
    std::deque<TNodeEventPtr>::pop_front((int64x2_t *)a1);
  }
  else
  {
    id v9 = *a2;
    *a2 = 0;
  }
  std::mutex::unlock(v6);
  return v7;
}

void sub_1D3457AC0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void TNodeEventPtr::TNodeEventPtr(TNodeEventPtr *this, FINodeEvent *a2)
{
  *(void *)this = a2;
}

uint64_t std::deque<TNodeEventPtr>::pop_front(int64x2_t *a1)
{
  unint64_t v2 = a1[2].u64[0];
  uint64_t v3 = *(void *)(a1->i64[1] + ((v2 >> 6) & 0x3FFFFFFFFFFFFF8));
  unint64_t v4 = v2 & 0x1FF;
  unint64_t v5 = *(void **)(v3 + 8 * v4);
  *(void *)(v3 + 8 * v4) = 0;

  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1D350A8D0);
  return std::deque<TNodeEventPtr>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

uint64_t std::deque<TNodeEventPtr>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x200) {
    a2 = 1;
  }
  if (v2 < 0x400) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
  return v4 ^ 1u;
}

uint64_t TNodeEvent::GetMonitor(TNodeEvent *this)
{
  return 0;
}

void std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__base_destruct_at_end[abi:ne180100](uint64_t a1, id *a2)
{
  int v4 = *(id **)(a1 + 8);
  if (v4 != a2)
  {
    unint64_t v5 = v4 - 1;
    do
    {
      TNodeEventPtr::~TNodeEventPtr(v5);
      BOOL v7 = *(v5 - 1);
      uint64_t v6 = v5 - 1;

      BOOL v8 = v6 == a2;
      unint64_t v5 = v6 - 1;
    }
    while (!v8);
  }
  *(void *)(a1 + 8) = a2;
}

void TNodeEventPtr::~TNodeEventPtr(id *this)
{
  id v2 = *this;
  *this = 0;
}

void *std::allocate_shared[abi:ne180100]<TBlockingEventQueue,std::allocator<TBlockingEventQueue>,void({block_pointer} {__strong}&)(OpaqueEventQueue *),unsigned long long &,void>@<X0>(void **a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xF8uLL);
  uint64_t result = std::__shared_ptr_emplace<TBlockingEventQueue>::__shared_ptr_emplace[abi:ne180100]<void({block_pointer} {__strong}&)(OpaqueEventQueue *),unsigned long long &,std::allocator<TBlockingEventQueue>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1D3457CD4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TBlockingEventQueue>::__shared_ptr_emplace[abi:ne180100]<void({block_pointer} {__strong}&)(OpaqueEventQueue *),unsigned long long &,std::allocator<TBlockingEventQueue>,0>(void *a1, void **a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB240;
  TBlockingEventQueue::TBlockingEventQueue((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1D3457D38(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t TBlockingEventQueue::TBlockingEventQueue(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 48) = 850045863;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 1018212795;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  uint64_t v6 = operator new(0x58uLL);
  v6[1] = 0;
  v6[2] = 0;
  void *v6 = &unk_1F2ABB438;
  v6[3] = 850045863;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  v6[10] = 0;
  *(void *)(a1 + 160) = v6 + 3;
  *(void *)(a1 + 168) = v6;
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 208) = 0;
  if (v5)
  {
    *(void *)(a1 + 184) = &unk_1F2ABAAD8;
    *(void *)(a1 + 192) = MEMORY[0x1D9436FC0](v5);
    *(void *)(a1 + 208) = a1 + 184;
  }
  *(void *)(a1 + 216) = a3;

  return a1;
}

void sub_1D3457E5C(_Unwind_Exception *a1)
{
  std::condition_variable::~condition_variable(v4);
  std::mutex::~mutex(v3);
  std::deque<TNodeEventPtr>::~deque[abi:ne180100](v1);

  _Unwind_Resume(a1);
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::operator()(uint64_t a1, unint64_t *a2)
{
  unint64_t v3 = *a2;
  TBlockingEventQueue::EventQueueFromID(*a2, &v4);
  if (v4) {
    (*(void (**)(unint64_t))(a1 + 8))(v3);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1D3457EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

id TSystemNotificationTask::SystemNotificationQueue(TSystemNotificationTask *this)
{
  return (id)gSystemNotificationGCDQueue;
}

uint64_t **std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::find<FPProviderDomain * {__strong}>(void *a1, id *a2)
{
  unint64_t v4 = [*a2 hash];
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  id v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v13 = (unint64_t)v11[1];
      if (v6 == v13)
      {
        if (std::equal_to<FPProviderDomain * {__strong}>::operator()(v12, v11[2], *a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }
        else
        {
          v13 &= *(void *)&v5 - 1;
        }
        if (v13 != v9) {
          return 0;
        }
      }
      uint64_t v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  return v11;
}

void ___ZN5TNode32RootFPItemsForDomainsWithTimeoutEP7NSArrayIP16FPProviderDomainERKNSt3__16chrono8durationIdNS5_5ratioILl1ELl1EEEEERKNS5_8functionIFvS2_P6FPItemP7NSErrorEEE_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = v5;
  id v8 = v6;
  if (v8)
  {
    unint64_t v9 = LogObj(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138543618;
      *(void *)&buf[4] = v8;
      __int16 v19 = 2114;
      uint64_t v20 = v10;
      _os_log_impl(&dword_1D343E000, v9, OS_LOG_TYPE_ERROR, "fetchRootItemForProviderDomain error: %{public}@ for %{public}@", buf, 0x16u);
    }
  }
  uint64_t v11 = *(std::mutex **)(a1 + 96);
  std::mutex::lock(v11);
  uint64_t v12 = (uint64_t *)v7;
  unint64_t v13 = (uint64_t *)v8;
  uint64_t v14 = *(void *)(a1 + 80);
  *(void *)long long buf = a1 + 32;
  float v15 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(v14, (id *)(a1 + 32), (uint64_t)&std::piecewise_construct, (id **)buf);
  BOOL v16 = v15[3];
  v15[3] = v12;

  unint64_t v17 = v15[4];
  v15[4] = v13;

  std::mutex::unlock(v11);
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  if (*(void *)(a1 + 72)) {
    std::function<void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(a1 + 48, *(void **)(a1 + 32), v12, v13);
  }
}

void sub_1D3458194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, uint64_t a3, id **a4)
{
  unint64_t v8 = [*a2 hash];
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
    unint64_t v13 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (std::equal_to<FPProviderDomain * {__strong}>::operator()(a1 + 32, i[2], *a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(a1, v9, a4, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *unint64_t v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (uint64_t **)v25[0];
  v25[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1D3458450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::equal_to<FPProviderDomain * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  if (v4 == v5) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = [v4 isEqual:v5];
  }

  return v6;
}

void sub_1D34584CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  id v2 = *(void ***)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<FPProviderDomain * const {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>,0>(v2 + 2);
    }
    operator delete(v2);
  }
}

uint64_t TFSInfo::PersonEqual(TFSInfo *this, NSPersonNameComponents *a2, NSPersonNameComponents *a3)
{
  id v4 = this;
  id v5 = a2;
  uint64_t v6 = [(TFSInfo *)v4 givenName];
  id v7 = [(NSPersonNameComponents *)v5 givenName];
  if (IsEqual(v6, v7))
  {
    unint64_t v8 = [(TFSInfo *)v4 familyName];
    unint64_t v9 = [(NSPersonNameComponents *)v5 familyName];
    if (IsEqual(v8, v9))
    {
      unint64_t v10 = [(TFSInfo *)v4 middleName];
      uint8x8_t v11 = [(NSPersonNameComponents *)v5 middleName];
      if (IsEqual(v10, v11))
      {
        unint64_t v19 = [(TFSInfo *)v4 namePrefix];
        BOOL v18 = [(NSPersonNameComponents *)v5 namePrefix];
        if (IsEqual(v19, v18))
        {
          float v17 = [(TFSInfo *)v4 nameSuffix];
          float v16 = [(NSPersonNameComponents *)v5 nameSuffix];
          if (IsEqual(v17, v16))
          {
            unint64_t v15 = [(TFSInfo *)v4 nickname];
            uint64_t v14 = [(NSPersonNameComponents *)v5 nickname];
            uint64_t v12 = IsEqual(v15, v14);
          }
          else
          {
            uint64_t v12 = 0;
          }
        }
        else
        {
          uint64_t v12 = 0;
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }

  return v12;
}

void sub_1D3458730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void TFSInfo::SynchronizeCatalog(TFSInfo *this, TFSInfo **a2, uint64_t **a3)
{
  int v6 = *((unsigned __int8 *)this + 112);
  if (!*((unsigned char *)this + 112))
  {
    if (*((_DWORD *)this + 26) == 1651666795) {
      goto LABEL_3;
    }
    if (TFSInfo::GetCreationDate(this) != -534528000.0)
    {
LABEL_19:
      int v6 = *((unsigned __int8 *)this + 112);
      goto LABEL_20;
    }
    if (*((unsigned char *)this + 112))
    {
      unint64_t v9 = *a2;
      if (*((unsigned char *)*a2 + 112) || *((_DWORD *)v9 + 26) != 1651666795 && TFSInfo::GetCreationDate(v9) != -534528000.0) {
        goto LABEL_66;
      }
      goto LABEL_19;
    }
    if (*((_DWORD *)this + 26) == 1651666795) {
LABEL_3:
    }
      BOOL v7 = 1;
    else {
      BOOL v7 = TFSInfo::GetCreationDate(this) == -534528000.0;
    }
    unint64_t v8 = *a2;
    if (*((unsigned char *)*a2 + 112))
    {
      if (!v7) {
        goto LABEL_66;
      }
    }
    else if (*((_DWORD *)v8 + 26) == 1651666795)
    {
      if (v7) {
        goto LABEL_66;
      }
    }
    else if (v7 == (TFSInfo::GetCreationDate(v8) == -534528000.0))
    {
      goto LABEL_66;
    }
    goto LABEL_19;
  }
LABEL_20:
  if (v6 == 21) {
    int v10 = 0;
  }
  else {
    int v10 = *((_DWORD *)this + 26);
  }
  if (*((unsigned char *)*a2 + 112) == 21) {
    int v11 = 0;
  }
  else {
    int v11 = *((_DWORD *)*a2 + 26);
  }
  if (v10 != v11)
  {
    unsigned int v69 = 1634956409;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    unsigned int v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    unsigned int v69 = 1883665005;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    int v6 = *((unsigned __int8 *)this + 112);
  }
  if (v6 == 21) {
    int v12 = 0;
  }
  else {
    int v12 = *((_DWORD *)this + 27);
  }
  if (*((unsigned char *)*a2 + 112) == 21) {
    int v13 = 0;
  }
  else {
    int v13 = *((_DWORD *)*a2 + 27);
  }
  if (v12 != v13)
  {
    unsigned int v69 = 1717793396;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    unsigned int v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  double ModificationDate = TFSInfo::GetModificationDate(this);
  if (ModificationDate != TFSInfo::GetModificationDate(*a2))
  {
    unsigned int v69 = 1836016740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    int v15 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v15 & 2) != 0
      || (float v16 = *a2,
          float v17 = (os_unfair_lock_s *)((char *)*a2 + 100),
          os_unfair_lock_lock(v17),
          LODWORD(v16) = *(_DWORD *)((char *)v16 + 115),
          os_unfair_lock_unlock(v17),
          (v16 & 2) != 0))
    {
      unsigned int v69 = 1819240307;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
      unsigned int v69 = 1885895027;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
  }
  double DateAddedDate = TFSInfo::GetDateAddedDate(this);
  if (DateAddedDate != TFSInfo::GetDateAddedDate(*a2))
  {
    unsigned int v69 = 1883333732;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  int IsLocked = TFSInfo::IsLocked(this);
  if (IsLocked != TFSInfo::IsLocked(*a2))
  {
    unsigned int v69 = 1634954347;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    unsigned int v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  CFStringRef v21 = (const __CFString *)*MEMORY[0x1E4F1CE50];
  Booleanint Property = TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E4F1CE50], v20);
  if (BooleanProperty != TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)*a2 + 1), v21, v23))
  {
    unsigned int v69 = 1970170987;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  TFSInfo::GetFinderInfo(this);
  uint64_t v25 = (v24 >> 11) & 1;
  TFSInfo::GetFinderInfo(*a2);
  if (v25 != ((v26 >> 11) & 1))
  {
    unsigned int v69 = 1886613604;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  int HasCustomIcon = TFSInfo::HasCustomIcon(this);
  if (HasCustomIcon != TFSInfo::HasCustomIcon(*a2))
  {
    unsigned int v69 = 1667851118;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    unsigned int v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  BOOL IsAlias = TFSInfo::IsAlias(this);
  if (IsAlias != TFSInfo::IsAlias(*a2))
  {
    unsigned int v69 = 1769169260;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v29 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 9) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  long long v30 = *a2;
  uint64_t v31 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v31);
  unint64_t v32 = ((unint64_t)*(unsigned int *)((char *)v30 + 115) >> 9) & 1;
  os_unfair_lock_unlock(v31);
  if (v29 != v32)
  {
    unsigned int v69 = 1668246896;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v33 = *(_DWORD *)((char *)this + 115) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  id v34 = *a2;
  BOOL v35 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v35);
  LODWORD(v34) = *(_DWORD *)((char *)v34 + 115) & 1;
  os_unfair_lock_unlock(v35);
  if (v33 != v34)
  {
    unsigned int v69 = 1987273324;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  if (*((unsigned char *)this + 112) == 28)
  {
    uint64_t v36 = TFSInfo::GetFPItem(this);
    long long v37 = [v36 itemID];
    int v38 = TFSInfo::GetFPItem(*a2);
    uint64_t v39 = [v38 itemID];
    char v40 = [v37 isEqualToItemID:v39];

    if (v40) {
      goto LABEL_66;
    }
LABEL_65:
    unsigned int v69 = 1868720740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    goto LABEL_66;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v41 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 8) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  long long v42 = *a2;
  TNodePtr v43 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v43);
  unint64_t v44 = ((unint64_t)*(unsigned int *)((char *)v42 + 115) >> 8) & 1;
  os_unfair_lock_unlock(v43);
  if (v41 != v44)
  {
    unsigned int v69 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    unsigned int v69 = 1987013741;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  uint64_t VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
  if (VolumeIdentifier != TFSInfo::GetVolumeIdentifier(*a2)) {
    goto LABEL_65;
  }
  uint64_t ObjectIdentifier = TFSInfo::GetObjectIdentifier(this);
  if (ObjectIdentifier != TFSInfo::GetObjectIdentifier(*a2))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    int v47 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v47 & 0x8000) == 0) {
      goto LABEL_65;
    }
    long long v48 = *a2;
    long long v49 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v49);
    LODWORD(v48) = *(_DWORD *)((char *)v48 + 115);
    os_unfair_lock_unlock(v49);
    if (((unsigned __int16)v48 & 0x8000) == 0) {
      goto LABEL_65;
    }
  }
LABEL_66:
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v50 = (*(unsigned __int16 *)((char *)this + 119) >> 9) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  long long v51 = *a2;
  long long v52 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v52);
  LODWORD(v51) = (*(unsigned __int16 *)((char *)v51 + 119) >> 9) & 1;
  os_unfair_lock_unlock(v52);
  if (v50 != v51)
  {
    unsigned int v69 = 1883665005;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  if (*((unsigned char *)this + 112))
  {
    long long v53 = *a2;
    if (*((unsigned char *)*a2 + 112)) {
      goto LABEL_78;
    }
    if (*((_DWORD *)v53 + 26) != 1651666795)
    {
      double CreationDate = TFSInfo::GetCreationDate(v53);
      goto LABEL_76;
    }
LABEL_77:
    unsigned int v69 = 1883665005;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    goto LABEL_78;
  }
  if (*((_DWORD *)this + 26) == 1651666795)
  {
    long long v55 = *a2;
    if (*((unsigned char *)*a2 + 112)) {
      goto LABEL_77;
    }
    BOOL v56 = 1;
  }
  else
  {
    double CreationDate = TFSInfo::GetCreationDate(this);
    BOOL v56 = CreationDate == -534528000.0;
    long long v55 = *a2;
    if (*((unsigned char *)*a2 + 112))
    {
LABEL_76:
      if (CreationDate != -534528000.0) {
        goto LABEL_78;
      }
      goto LABEL_77;
    }
  }
  if (*((_DWORD *)v55 + 26) == 1651666795)
  {
    if (!v56) {
      goto LABEL_77;
    }
  }
  else if (v56 != (TFSInfo::GetCreationDate(v55) == -534528000.0))
  {
    goto LABEL_77;
  }
LABEL_78:
  double v57 = TFSInfo::GetCreationDate(this);
  if (v57 != TFSInfo::GetCreationDate(*a2))
  {
    if (!*((unsigned char *)this + 112)
      && (*((_DWORD *)this + 26) == 1651666795 || TFSInfo::GetCreationDate(this) == -534528000.0))
    {
      unsigned int v69 = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
    unsigned int v69 = 1634952036;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t v58 = *((void *)this + 10);
  double v59 = 0.0;
  double v60 = 0.0;
  if (v58)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v58 + 72));
    double v60 = *(double *)(v58 + 48);
    os_unfair_lock_unlock((os_unfair_lock_t)(v58 + 72));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  uint64_t v61 = *a2;
  uint64_t v62 = (os_unfair_lock_s *)((char *)*a2 + 96);
  os_unfair_lock_lock(v62);
  uint64_t v63 = *((void *)v61 + 10);
  if (v63)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v63 + 72));
    double v59 = *(double *)(v63 + 48);
    os_unfair_lock_unlock((os_unfair_lock_t)(v63 + 72));
  }
  os_unfair_lock_unlock(v62);
  if (v60 != v59)
  {
    unsigned int v69 = 1768845426;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v64 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if ((v64 & 0x20) == 0)
  {
    uint64_t DataLogicalSize = TFSInfo::GetDataLogicalSize(this);
    if (DataLogicalSize != TFSInfo::GetDataLogicalSize(*a2))
    {
      unsigned int v69 = 1819240307;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
    uint64_t ResourceLogicalSize = TFSInfo::GetResourceLogicalSize(this);
    if (ResourceLogicalSize != TFSInfo::GetResourceLogicalSize(*a2))
    {
      unsigned int v69 = 1819240307;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
    uint64_t DataPhysicalSize = TFSInfo::GetDataPhysicalSize(this);
    if (DataPhysicalSize != TFSInfo::GetDataPhysicalSize(*a2))
    {
      unsigned int v69 = 1885895027;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
    uint64_t ResourcePhysicalSize = TFSInfo::GetResourcePhysicalSize(this);
    if (ResourcePhysicalSize != TFSInfo::GetResourcePhysicalSize(*a2))
    {
      unsigned int v69 = 1885895027;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v69, &v69);
    }
  }
}

void sub_1D34591D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetBooleanProperty(TCFURLInfo *this, const __CFString *a2, const __CFString *a3)
{
  if (!this) {
    return 0;
  }
  CFTypeRef propertyValueTypeRefPtr = 0;
  if (CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0) && propertyValueTypeRefPtr) {
    uint64_t v3 = IsEqual(propertyValueTypeRefPtr, (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  else {
    uint64_t v3 = 0;
  }
  TAutoRef<__CFBoolean const*,TRetainReleasePolicy<__CFBoolean const*>>::~TAutoRef(&propertyValueTypeRefPtr);
  return v3;
}

void sub_1D3459274(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFBoolean const*,TRetainReleasePolicy<__CFBoolean const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetFinderInfo(TFSInfo *this)
{
  if (*((unsigned char *)this + 112) != 28) {
    TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
  }
  return 0;
}

uint64_t TFSInfo::GetVolumeIdentifier(TFSInfo *this)
{
  int v1 = TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
  uint64_t result = 0;
  if (!v1) {
    return 0;
  }
  return result;
}

const void **TAutoRef<__CFBoolean const*,TRetainReleasePolicy<__CFBoolean const*>>::~TAutoRef(const void **a1)
{
  id v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

unint64_t TFSInfo::IsLocked(TFSInfo *this)
{
  id v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x80) != 0) {
    return 1;
  }
  os_unfair_lock_lock(v2);
  unint64_t v4 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 16) & 1;
  os_unfair_lock_unlock(v2);
  return v4;
}

double TFSInfo::GetModificationDate(TFSInfo *this)
{
  double v1 = -6.31140768e10;
  if (*((unsigned char *)this + 112) != 34)
  {
    int v3 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    int v4 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock(v3);
    if ((v4 & 0x2000000) == 0)
    {
      int v5 = *((unsigned __int8 *)this + 112);
      if ((v5 - 27) >= 2)
      {
        if (v5 == 25)
        {
          if (ICloudDriveFPFSEnabled())
          {
            unint64_t v8 = TFSInfo::GetFPItem(this);
            unint64_t v9 = [v8 contentModificationDate];

            if (v9) {
              double v1 = MEMORY[0x1D9435A50](v9);
            }
            else {
              double v1 = -6.31140768e10;
            }
          }
        }
        else
        {
          double v1 = -6.31140768e10;
          TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
        }
      }
      else
      {
        int v6 = TFSInfo::GetFPItem(this);
        BOOL v7 = [v6 contentModificationDate];

        if (v7) {
          double v1 = MEMORY[0x1D9435A50](v7);
        }

        if (!v7) {
          return -6.31140768e10;
        }
      }
    }
  }
  return v1;
}

void sub_1D34595B0(_Unwind_Exception *a1)
{
  id v2 = v1;

  _Unwind_Resume(a1);
}

double TFSInfo::GetDateAddedDate(TFSInfo *this)
{
  if (*((unsigned char *)this + 112) == 34) {
    return -6.31140768e10;
  }
  id v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0) {
    return -6.31140768e10;
  }
  int v5 = (TCFURLInfo *)*((void *)this + 1);
  CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1D550];
  return TCFURLInfo::GetDateProperty(v5, v6, v4);
}

unint64_t TFSInfo::HasCustomIcon(TFSInfo *this)
{
  id v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0) {
    return 0;
  }
  TFSInfo::GetFinderInfo(this);
  return (v4 >> 10) & 1;
}

double TCFURLInfo::GetDateProperty(TCFURLInfo *this, const __CFString *a2, const __CFString *a3)
{
  double v3 = -*MEMORY[0x1E4F1CF68];
  if (this)
  {
    CFTypeRef propertyValueTypeRefPtr = 0;
    if (CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0))
    {
      if (propertyValueTypeRefPtr)
      {
        CFTypeID v4 = CFGetTypeID(propertyValueTypeRefPtr);
        if (v4 == CFDateGetTypeID()) {
          double v3 = MEMORY[0x1D9435A50](propertyValueTypeRefPtr);
        }
      }
    }
    TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(&propertyValueTypeRefPtr);
  }
  return v3;
}

void sub_1D3459750(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::ApplyFPItemRestrictions(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFTypeID v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  int v5 = *(TFSInfo **)(a1 + 16);
  CFStringRef v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  TFSInfo::GetFPItem(v5);
  unint64_t v8 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  uint64_t v9 = a2 & ~TFSInfo::FPItemPermissionRestrictions(v8, v7);
  if ((a2 & 0x10000) != 0 && (v9 & 0x10000) == 0)
  {
    int v10 = [(TFSInfo *)v8 creationDate];
    if ([v10 isEqualToDate:TCFURLInfo::GetMagicBusyCreationDate((TCFURLInfo *)v10)])
    {
      int v11 = LogObj(2);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = 138412290;
        uint64_t v14 = v8;
        _os_log_impl(&dword_1D343E000, v11, OS_LOG_TYPE_DEFAULT, "Unreadable FPItem found with busy creation date, forcing read capability to match local file: %@", (uint8_t *)&v13, 0xCu);
      }

      uint64_t v9 = v9 | 0x10000;
    }
    else
    {
    }
  }

  return v9;
}

void sub_1D34598AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::FPItemPermissionRestrictions(TFSInfo *this, FPItem *a2)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  id v2 = this;
  if (v2)
  {
    double v3 = FPItemManagerInstance();
    v17[0] = v2;
    CFTypeID v4 = [MEMORY[0x1E4F1C978] arrayWithObjects:v17 count:1];
    int v5 = [v3 eligibleActionsForItems:v4];

    if ([(TFSInfo *)v2 isFolder]) {
      char v6 = 1;
    }
    else {
      char v6 = [(TFSInfo *)v2 isPackage];
    }
    {
      _ZGRZN7TFSInfo28FPItemPermissionRestrictionsEP6FPItemE22sFPActionToPermissions_ = FP_ActionImportHere();
      dword_1EA6AC0E0 = 20484;
      qword_1EA6AC0E8 = FP_ActionReparent();
      dword_1EA6AC0F0 = 2;
      qword_1EA6AC0F8 = FP_ActionCopy();
      dword_1EA6AC100 = 0x10000;
      qword_1EA6AC108 = FP_ActionRename();
      dword_1EA6AC110 = 1;
      qword_1EA6AC118 = FP_ActionDelete();
      dword_1EA6AC120 = 0x400000;
      qword_1EA6AC128 = FP_ActionTrash();
      dword_1EA6AC130 = 0x200000;
      qword_1EA6AC138 = FP_ActionUntrash();
      dword_1EA6AC140 = 0x800000;
      qword_1EA6AC148 = FP_ActionTag();
      dword_1EA6AC150 = 0x100000;
      qword_1EA6AC158 = FP_ActionModifyFlags();
      dword_1EA6AC160 = 0x2000;
      TFSInfo::FPItemPermissionRestrictions(FPItem *)::sFPActionToPermissions = (uint64_t)&_ZGRZN7TFSInfo28FPItemPermissionRestrictionsEP6FPItemE22sFPActionToPermissions_;
      qword_1EA6AC0C8 = 9;
    }
    if (qword_1EA6AC0C8)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 16 * qword_1EA6AC0C8;
      uint64_t v9 = (_DWORD *)(TFSInfo::FPItemPermissionRestrictions(FPItem *)::sFPActionToPermissions + 8);
      do
      {
        if (([v5 containsObject:*((void *)v9 - 1)] & 1) == 0) {
          uint64_t v7 = *v9 | v7;
        }
        v9 += 4;
        v8 -= 16;
      }
      while (v8);
      if ((v6 & 1) == 0)
      {
LABEL_18:
        char v12 = [(TFSInfo *)v2 capabilities];
        if (v12)
        {
          if (v6)
          {
LABEL_28:

            goto LABEL_29;
          }
        }
        else
        {
          int v13 = [(TFSInfo *)v2 itemIdentifier];
          uint64_t v14 = NS_FileProviderRootContainerItemIdentifier();
          int v15 = [v13 isEqualToString:v14];

          if (v15) {
            uint64_t v7 = v7;
          }
          else {
            uint64_t v7 = v7 | 0x80800;
          }
          if (v6) {
            goto LABEL_28;
          }
          LODWORD(v7) = v7 | 0x10000;
        }
        if ((v12 & 2) != 0) {
          uint64_t v7 = v7;
        }
        else {
          uint64_t v7 = v7 | 0xD004;
        }
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v7 = 0;
      if ((v6 & 1) == 0) {
        goto LABEL_18;
      }
    }
    int v10 = FP_ActionImportHere();
    int v11 = [v5 containsObject:v10];

    if (v11) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = v7 | 0x8000;
    }
    goto LABEL_18;
  }
  uint64_t v7 = 0;
LABEL_29:

  return v7;
}

void sub_1D3459C04(_Unwind_Exception *a1)
{
  int v5 = &qword_1EA6AC158;
  do
  {
    char v6 = (void *)*(v5 - 2);
    v5 -= 2;
  }
  while (v5 != v3);

  _Unwind_Resume(a1);
}

id FP_ActionImportHere(void)
{
  return (id)*MEMORY[0x1E4F25928];
}

void TNode::FPItemsFromURLsWithTimeout(const __CFArray *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  CFArrayRef v4 = a1;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  CFArrayRef theArray = a1;
  int v5 = (char *)operator new(0x58uLL);
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = 0;
  *((void *)v5 + 3) = 850045863;
  int v38 = (std::mutex *)(v5 + 24);
  *(void *)int v5 = &unk_1F2ABB438;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  int v33 = (std::__shared_weak_count *)v5;
  *((void *)v5 + 10) = 0;
  char v6 = (char *)operator new(0x40uLL);
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)char v6 = &unk_1F2AB9AB0;
  *(_OWORD *)(v6 + 24) = 0u;
  uint64_t v7 = v6 + 24;
  *(_OWORD *)(v6 + 40) = 0u;
  id v34 = v6;
  *((_DWORD *)v6 + 14) = 1065353216;
  if (*(void *)(a2 + 24))
  {
    std::allocate_shared[abi:ne180100]<std::function<void ()(__CFURL const*,FPItem *,NSError *)>,std::allocator<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&,void>(a2, &v55);
    CFArrayRef v4 = theArray;
  }
  else
  {
    long long v55 = 0;
    BOOL v56 = 0;
  }
  CFIndex Count = CFArrayGetCount(v4);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>((uint64_t)v7, vcvtps_u32_f32((float)(unint64_t)Count / *((float *)v34 + 14)));
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  CFArrayRef v9 = theArray;
  uint64_t v10 = [(__CFArray *)v9 countByEnumeratingWithState:&v51 objects:v65 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v52;
    do
    {
      for (uint64_t i = 0; i != v10; ++i)
      {
        if (*(void *)v52 != v11) {
          objc_enumerationMutation(v9);
        }
        id v13 = *(id *)(*((void *)&v51 + 1) + 8 * i);
        uint64_t v14 = v13;
        LOBYTE(v45) = 0;
        LOBYTE(v46) = 0;
        LOBYTE(v47) = 0;
        LOBYTE(v48) = 0;
        p_CFArrayRef theArray = v55;
        int v50 = v56;
        if (v56) {
          atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *(void *)long long buf = v13;
        if (v13) {
          CFRetain(v13);
        }
        v44[0] = buf;
        int v15 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>((uint64_t)v7, (CFTypeRef *)buf, (uint64_t)&std::piecewise_construct, v44);
        std::__memberwise_forward_assign[abi:ne180100]<std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>,std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,0ul,1ul,2ul>((uint64_t)(v15 + 3), (uint64_t)&v45);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)buf);
        if (v50) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v50);
        }
        if ((_BYTE)v48) {

        }
        if ((_BYTE)v46) {
      }
        }
      uint64_t v10 = [(__CFArray *)v9 countByEnumeratingWithState:&v51 objects:v65 count:16];
    }
    while (v10);
  }

  id v45 = v7;
  long long v46 = v34;
  atomic_fetch_add_explicit((atomic_ullong *volatile)v34 + 1, 1uLL, memory_order_relaxed);
  int v47 = v38;
  long long v48 = v33;
  atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
  p_CFArrayRef theArray = &theArray;
  if (theArray
    && Count
    && (FPItemManagerInstance(),
        float v16 = objc_claimAutoreleasedReturnValue(),
        BOOL v17 = v16 == 0,
        v16,
        !v17))
  {
    v44[0] = v7;
    v44[1] = v34;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v34 + 1, 1uLL, memory_order_relaxed);
    v44[2] = &v38->__m_.__sig;
    v44[3] = &v33->__vftable;
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    CFArrayRef obj = theArray;
    uint64_t v18 = [(__CFArray *)obj countByEnumeratingWithState:&v40 objects:v64 count:16];
    if (v18)
    {
      uint64_t v36 = *(void *)v41;
      do
      {
        for (uint64_t j = 0; j != v18; ++j)
        {
          if (*(void *)v41 != v36) {
            objc_enumerationMutation(obj);
          }
          id v20 = *(id *)(*((void *)&v40 + 1) + 8 * j);
          CFStringRef v21 = FPItemManagerInstance();
          id v22 = v20;
          id v39 = 0;
          long long v37 = [v21 itemForURL:v22 error:&v39];
          id v23 = v39;

          if (v23)
          {
            unint64_t v24 = LogObj(4);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              uint64_t v25 = (NSURL *)v22;
              unint64_t v26 = SanitizedURL(v25);
              *(_DWORD *)long long buf = 138543618;
              *(void *)&buf[4] = v23;
              __int16 v62 = 2114;
              uint64_t v63 = v26;
              _os_log_impl(&dword_1D343E000, v24, OS_LOG_TYPE_ERROR, "Failed to get FPItem error: %{public}@ for %{public}@", buf, 0x16u);
            }
          }
          id v27 = v37;
          id v28 = v23;

          id v29 = v27;
          id v60 = v29;
          id v30 = v28;
          id v59 = v30;
          std::mutex::lock(v38);
          uint64_t v58 = v22;
          if (v22) {
            CFRetain(v22);
          }
          *(void *)long long buf = &v58;
          uint64_t v31 = std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>((uint64_t)v7, &v58, (uint64_t)&std::piecewise_construct, (void **)buf);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v58);
          std::optional<FPItem * {__strong}>::operator=[abi:ne180100]<FPItem * {__strong}&,void>((uint64_t)(v31 + 3), &v60);
          std::optional<FPItem * {__strong}>::operator=[abi:ne180100]<FPItem * {__strong}&,void>((uint64_t)(v31 + 5), &v59);
          std::mutex::unlock(v38);
        }
        uint64_t v18 = [(__CFArray *)obj countByEnumeratingWithState:&v40 objects:v64 count:16];
      }
      while (v18);
    }

    std::mutex::lock(v38);
    TNode::FPItemsFromURLsWithTimeout(__CFArray const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)&v45, a3);
    std::mutex::unlock(v38);
    std::__shared_weak_count::__release_shared[abi:ne180100](v33);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v34);
  }
  else
  {
    TNode::FPItemsFromURLsWithTimeout(__CFArray const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&)::$_0::operator()((uint64_t)&v45, a3);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v33);
  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v34);
  if (v56) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v56);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v34);
  std::__shared_weak_count::__release_shared[abi:ne180100](v33);
}

void sub_1D345A2D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::mutex *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,std::__shared_weak_count *a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (a49) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a49);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  _Unwind_Resume(a1);
}

uint64_t FPItemManagerInstance(void)
{
  unsigned __int8 v0 = objc_opt_class();
  return [v0 defaultManager];
}

uint64_t **std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>(uint64_t a1, CFTypeRef *a2, uint64_t a3, void **a4)
{
  CFHashCode v8 = CFHash(*a2);
  CFHashCode v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      CFHashCode v4 = v8;
      if (v8 >= v10) {
        CFHashCode v4 = v8 % v10;
      }
    }
    else
    {
      CFHashCode v4 = (v10 - 1) & v8;
    }
    id v13 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (IsEqual(i[2], *a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  float v16 = operator new(0x48uLL);
  v27[0] = v16;
  v27[1] = a1 + 16;
  void *v16 = 0;
  v16[1] = v9;
  BOOL v17 = *a4;
  v16[2] = **a4;
  void *v17 = 0;
  *((unsigned char *)v16 + 24) = 0;
  *((unsigned char *)v16 + 32) = 0;
  *((unsigned char *)v16 + 40) = 0;
  *((unsigned char *)v16 + 48) = 0;
  v16[7] = 0;
  v16[8] = 0;
  char v28 = 1;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    BOOL v20 = 1;
    if (v10 >= 3) {
      BOOL v20 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v10);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v23);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        CFHashCode v4 = v9 % v10;
      }
      else {
        CFHashCode v4 = v9;
      }
    }
    else
    {
      CFHashCode v4 = (v10 - 1) & v9;
    }
  }
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *(void *)v27[0] = *v24;
    *unint64_t v24 = v27[0];
  }
  else
  {
    *(void *)v27[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v27[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v27[0])
    {
      unint64_t v25 = *(void *)(*(void *)v27[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v25 >= v10) {
          v25 %= v10;
        }
      }
      else
      {
        v25 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v25) = v27[0];
    }
  }
  uint64_t i = (uint64_t **)v27[0];
  v27[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v27, 0);
  return i;
}

void sub_1D345A6C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::optional<FPItem * {__strong}>::operator=[abi:ne180100]<FPItem * {__strong}&,void>(uint64_t a1, id *a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 8);
  id v4 = *a2;
  if (v3)
  {
    int v5 = *(void **)a1;
    *(void *)a1 = v4;
  }
  else
  {
    *(void *)a1 = v4;
    *(unsigned char *)(a1 + 8) = 1;
  }
  return a1;
}

uint64_t std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(CFTypeRef **)(a2 + 16); i; uint64_t i = (CFTypeRef *)*i)
    std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>> const&>(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_1D345A78C(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      uint8x8_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            void *v7 = *v11;
            *uint8x8_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint8x8_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint8x8_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t **std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>> const&>(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  CFHashCode v7 = CFHash(*a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      CFHashCode v3 = v7;
      if (v7 >= v9) {
        CFHashCode v3 = v7 % v9;
      }
    }
    else
    {
      CFHashCode v3 = (v9 - 1) & v7;
    }
    unint64_t v12 = *(uint64_t ****)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v14 = (unint64_t)i[1];
        if (v14 == v8)
        {
          if (IsEqual(i[2], *a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>> const&>(a1, v8, a3, (uint64_t)v24);
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        CFHashCode v3 = v8 % v9;
      }
      else {
        CFHashCode v3 = v8;
      }
    }
    else
    {
      CFHashCode v3 = (v9 - 1) & v8;
    }
  }
  unint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    void *v21 = v24[0];
  }
  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v22 >= v9) {
          v22 %= v9;
        }
      }
      else
      {
        v22 &= v9 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }
  uint64_t i = (uint64_t **)v24[0];
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D345AC38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x28uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  void *v8 = 0;
  v8[1] = a2;
  uint64_t result = std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>>::pair[abi:ne180100]((uint64_t)(v8 + 2), a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D345ACCC(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::pair<FINode * {__weak},unsigned long>>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  int8x8_t v4 = *(const void **)a2;
  *(void *)a1 = *(void *)a2;
  if (v4) {
    CFRetain(v4);
  }
  objc_copyWeak((id *)(a1 + 8), (id *)(a2 + 8));
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  return a1;
}

void *std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::piecewise_construct_t const&,std::tuple<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>&&>,std::tuple<>>(uint64_t a1, CFTypeRef *a2, uint64_t a3, void **a4)
{
  CFHashCode v8 = CFHash(*a2);
  CFHashCode v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      CFHashCode v4 = v8;
      if (v8 >= v10) {
        CFHashCode v4 = v8 % v10;
      }
    }
    else
    {
      CFHashCode v4 = (v10 - 1) & v8;
    }
    id v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(void **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if (IsEqual(*((const void **)i + 2), *a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  float v16 = (void *)(a1 + 16);
  uint64_t i = operator new(0x28uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v9;
  BOOL v17 = *a4;
  *((void *)i + 2) = **a4;
  void *v17 = 0;
  *((void *)i + 3) = 0;
  *((void *)i + 4) = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    BOOL v20 = 1;
    if (v10 >= 3) {
      BOOL v20 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v10);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v23);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        CFHashCode v4 = v9 % v10;
      }
      else {
        CFHashCode v4 = v9;
      }
    }
    else
    {
      CFHashCode v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v24 = *(void *)a1;
  unint64_t v25 = *(void **)(*(void *)a1 + 8 * v4);
  if (v25)
  {
    *(void *)uint64_t i = *v25;
LABEL_38:
    void *v25 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *v16;
  void *v16 = i;
  *(void *)(v24 + 8 * v4) = v16;
  if (*(void *)i)
  {
    unint64_t v26 = *(void *)(*(void *)i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v26 >= v10) {
        v26 %= v10;
      }
    }
    else
    {
      v26 &= v10 - 1;
    }
    unint64_t v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D345AF84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t IsEqual(const void *a1, const void *a2)
{
  if (a1 == a2 || a1 && a2 && CFEqual(a1, a2)) {
    return 1;
  }
  CFURLRef v5 = (const __CFURL *)cf_cast<__CFURL const*,void const*>(a1);
  CFURLRef v6 = (const __CFURL *)cf_cast<__CFURL const*,void const*>(a2);
  uint64_t v4 = 0;
  if (v5)
  {
    CFURLRef v7 = v6;
    if (v6)
    {
      CFTypeRef cf2 = 0;
      CFTypeRef cf1 = 0;
      CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1D608];
      if (CFURLCopyResourcePropertyForKey(v5, (CFStringRef)*MEMORY[0x1E4F1D608], &cf1, 0)
        && CFURLCopyResourcePropertyForKey(v7, v8, &cf2, 0)
        && cf1)
      {
        uint64_t v4 = IsEqual(cf1, cf2);
      }
      else
      {
        uint64_t v4 = 0;
      }
      TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&cf2);
      TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&cf1);
    }
  }
  return v4;
}

void sub_1D345B090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void *cf_cast<__CFURL const*,void const*>(const void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }
    else
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFURLGetTypeID()) {
        return v1;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

void std::__memberwise_forward_assign[abi:ne180100]<std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>,std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,0ul,1ul,2ul>(uint64_t a1, uint64_t a2)
{
  std::__optional_storage_base<FPItem * {__strong},false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<FPItem * {__strong},false>>(a1, (uint64_t *)a2);
  std::__optional_storage_base<FPItem * {__strong},false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<FPItem * {__strong},false>>(a1 + 16, (uint64_t *)(a2 + 16));
  long long v4 = *(_OWORD *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  CFURLRef v5 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v4;
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void std::__optional_storage_base<FPItem * {__strong},false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<FPItem * {__strong},false>>(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned __int8 *)(a1 + 8) == *((unsigned __int8 *)a2 + 8))
  {
    if (*(unsigned char *)(a1 + 8))
    {
      uint64_t v3 = *a2;
      *a2 = 0;
      id v4 = *(id *)a1;
      *(void *)a1 = v3;
    }
  }
  else if (*(unsigned char *)(a1 + 8))
  {

    *(unsigned char *)(a1 + 8) = 0;
  }
  else
  {
    uint64_t v5 = *a2;
    *a2 = 0;
    *(void *)a1 = v5;
    *(unsigned char *)(a1 + 8) = 1;
  }
}

void *std::allocate_shared[abi:ne180100]<std::function<void ()(__CFURL const*,FPItem *,NSError *)>,std::allocator<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&,void>@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  id v4 = operator new(0x38uLL);
  uint64_t result = std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::__shared_ptr_emplace[abi:ne180100]<std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&,std::allocator<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1D345B248(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::__shared_ptr_emplace[abi:ne180100]<std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&,std::allocator<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>,0>(void *a1, uint64_t a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2AB9AE8;
  std::__function::__value_func<void ()(__CFURL const*,FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1D345B2A4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  CFTypeID v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

uint64_t std::__function::__value_func<void ()(__CFURL const*,FPItem *,NSError *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

_WORD *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = operator new(0x38uLL);
  *(void *)uint64_t v3 = &unk_1F2ABAC90;
  std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>::unordered_map((uint64_t)(v3 + 4), v2);
  v3[24] = *(_WORD *)(a1 + 48);
  *((unsigned char *)v3 + 50) = *(unsigned char *)(a1 + 50);
  return v3;
}

void sub_1D345B418(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

id NS_FileProviderRootContainerItemIdentifier(void)
{
  return (id)*MEMORY[0x1E4F25C70];
}

const void **TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t TNode::GetNodeFromURL(CFURLRef *a1, TNodePtr *a2, unsigned int a3)
{
  TNodePtr::TNodePtr((TNodePtr *)&v17, 0);
  TNodePtr::operator=((void **)&a2->fFINode, (void **)&v17.fString.fRef);

  if (*a1)
  {
    CFURLRef v6 = (TString *)CFURLCopyScheme(*a1);
    BOOL v20 = v6;
    v17.fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v17, v6);
    LODWORD(v6) = TFSInfo::IsNetworkScheme((TFSInfo *)&v17, v7);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17.fString.fRef);
    if (v6)
    {
      char v19 = 0;
      unint64_t v14 = (TFSInfo *)TFSInfo::SFNodeFromURL((uint64_t)*a1, (a3 & 2) == 0, &v19);
      if (v14)
      {
        std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>> &,void>(&v19, (uint64_t *)&v14, &v17);
        uint64_t NodeFromFSInfo = TNode::GetNodeFromFSInfo((TFSInfo **)&v17, (void **)&a2->fFINode);
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      else
      {
        uint64_t NodeFromFSInfo = 4294959236;
      }
      TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TAutoRef((const void **)&v14);
      if (NodeFromFSInfo) {
        goto LABEL_17;
      }
    }
    else
    {
      if (IsAppInbox((NSURL *)*a1))
      {
        uint64_t NodeFromFSInfo = 4294959238;
LABEL_17:
        TNodePtr::TNodePtr((TNodePtr *)&v17, 0);
        TNodePtr::operator=((void **)&a2->fFINode, (void **)&v17.fString.fRef);

LABEL_23:
        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v20);
        return NodeFromFSInfo;
      }
      TCFURLInfo::FileSystemRepresentation(*a1, (const __CFURL *)1, (TString *)&theString);
      if (CFStringGetLength(theString))
      {
        uint64_t NodeFromFSInfo = TNode::GetNodeFromPath((TString *)&theString, a2, a3);
        if (!NodeFromFSInfo)
        {
          if ((a3 & 0x80) != 0) {
            goto LABEL_42;
          }
          _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v17);
          CFHashCode v9 = (TNode *)TNodeFromFINode(a2->fFINode);
          TNode::GetFSInfo(v9, &v14);
          uint64_t NodeFromFSInfo = TFSInfo::initialize((uint64_t)v17.fString.fRef, *a1, 1, 1, 1, 1, 0);
          if (!NodeFromFSInfo)
          {
            if (TFSInfo::Equal((TFSInfo *)v17.fString.fRef, &v14))
            {
              uint64_t NodeFromFSInfo = 0;
            }
            else
            {
              uint64_t v11 = TNodeFromFINode(a2->fFINode);
              uint64_t NodeFromFSInfo = TNode::HandleSync(v11, 0x80000u);
            }
          }
          if (v15) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v15);
          }
          if (v18) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v18);
          }
          if (!NodeFromFSInfo)
          {
LABEL_42:
            if (TNodeFromFINode(a2->fFINode))
            {
              unint64_t v12 = (TNode *)TNodeFromFINode(a2->fFINode);
              TNode::GetFSInfo(v12, &v17);
              uint64_t NodeFromFSInfo = TFSInfo::IsMountTrigger((TFSInfo *)v17.fString.fRef);
              if (v18) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v18);
              }
              if (NodeFromFSInfo)
              {
                id v13 = (TNode *)TNodeFromFINode(a2->fFINode);
                TNode::GetFSInfo(v13, &v17);
                uint64_t NodeFromFSInfo = TFSInfo::TriggerMount((TFSInfo *)v17.fString.fRef);
                if (v18) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v18);
                }
                if (!NodeFromFSInfo) {
                  uint64_t NodeFromFSInfo = TNode::GetNodeFromPath((TString *)&theString, a2, a3);
                }
              }
            }
            else
            {
              uint64_t NodeFromFSInfo = 0;
            }
          }
        }
      }
      else
      {
        uint64_t NodeFromFSInfo = 4294959236;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      if (NodeFromFSInfo) {
        goto LABEL_17;
      }
    }
    if (TNodeFromFINode(a2->fFINode)) {
      uint64_t NodeFromFSInfo = 0;
    }
    else {
      uint64_t NodeFromFSInfo = 4294959238;
    }
    goto LABEL_23;
  }
  return 4294959236;
}

void sub_1D345B72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)(v14 - 40));
  _Unwind_Resume(a1);
}

void TNode::GetFSInfo(TNode *this@<X0>, void *a2@<X8>)
{
  id v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v5 = *((void *)this + 3);
  *a2 = *((void *)this + 2);
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
}

uint64_t TFSInfo::Equal(TFSInfo *this, TFSInfo **a2)
{
  int v4 = *((unsigned __int8 *)this + 112);
  if (v4 == 25)
  {
    TFSInfo::GetFPItem(this);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    CFURLRef v6 = [v5 itemIdentifier];
    CFURLRef v7 = TFSInfo::GetFPItem(*a2);
    CFStringRef v8 = [v7 itemIdentifier];
    uint64_t v9 = [v6 compare:v8] == 0;

LABEL_31:
    return v9;
  }
  if ((v4 - 23) <= 1) {
    return v4 == *((unsigned __int8 *)*a2 + 112);
  }
  if (v4 == 28)
  {
    TFSInfo::GetFPItem(this);
    id v5 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v13 = TFSInfo::GetFPItem(*a2);
    id v14 = (id)v13;
    if (!v5 && v13)
    {
      uint64_t v9 = 1;
LABEL_30:

      goto LABEL_31;
    }
    if (v13)
    {
      uint64_t v9 = [v5 isEqualToItem:v13];
      goto LABEL_30;
    }
LABEL_29:
    uint64_t v9 = 0;
    goto LABEL_30;
  }
  if (v4 == 27)
  {
    unint64_t v10 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    uint64_t v11 = *((void *)this + 10);
    if (v11
      && (os_unfair_lock_lock((os_unfair_lock_t)(v11 + 72)),
          int v12 = *(unsigned __int8 *)(v11 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 72)),
          v12 == 1))
    {
      id v5 = *(id *)(v11 + 24);
    }
    else
    {
      id v5 = 0;
    }
    os_unfair_lock_unlock(v10);
    float v18 = *a2;
    char v19 = (os_unfair_lock_s *)((char *)v18 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)v18 + 24);
    uint64_t v20 = *((void *)v18 + 10);
    if (v20
      && (os_unfair_lock_lock((os_unfair_lock_t)(v20 + 72)),
          int v21 = *(unsigned __int8 *)(v20 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v20 + 72)),
          v21 == 1))
    {
      id v14 = *(id *)(v20 + 24);
    }
    else
    {
      id v14 = 0;
    }
    os_unfair_lock_unlock(v19);
    if ((v5 != 0) != (v14 == 0))
    {
      unint64_t v22 = [v5 identifier];
      size_t v23 = [v14 identifier];
      uint64_t v9 = [v22 compare:v23] == 0;

      goto LABEL_30;
    }
    goto LABEL_29;
  }
  if (!*((void *)this + 1)) {
    return 0;
  }
  if (!*((void *)*a2 + 1)) {
    return 0;
  }
  uint64_t ObjectIdentifier = TFSInfo::GetObjectIdentifier(this);
  if (ObjectIdentifier != TFSInfo::GetObjectIdentifier(*a2)) {
    return 0;
  }
  uint64_t VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
  if (VolumeIdentifier != TFSInfo::GetVolumeIdentifier(*a2)) {
    return 0;
  }
  TFSInfo::Name(this, &v26);
  TFSInfo::Name(*a2, &v25);
  uint64_t v9 = CFEqual(v26.fString.fRef, v25.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v25.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v26.fString.fRef);
  if (v9)
  {
    IsSymlinuint64_t k = TFSInfo::IsSymlink(this);
    return IsSymlink ^ TFSInfo::IsSymlink(*a2) ^ 1;
  }
  return v9;
}

void sub_1D345BB10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

unint64_t TFSInfo::IsSymlink(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 6) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

unint64_t TFSInfo::IsMountTrigger(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 15) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

BOOL TFSInfo::IsNetworkScheme(TFSInfo *this, const TString *a2)
{
  {
    operator new();
  }
  {
    operator new();
  }
  return CFEqual(*(CFTypeRef *)this, *(CFTypeRef *)TFSInfo::IsNetworkScheme(TString const&)::networkScheme)
      || CFEqual(*(CFTypeRef *)this, *(CFTypeRef *)TFSInfo::IsNetworkScheme(TString const&)::altNetworkScheme) != 0;
}

void sub_1D345BD24(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t IsAppInbox(NSURL *a1)
{
  uint64_t v1 = a1;
  if (UseFileProviderFramework())
  {
    uint64_t v2 = [(NSURL *)v1 lastPathComponent];
    TString::TString(&v17, "Inbox", 5uLL);
    uint64_t v3 = operator==((void **)&v17.fString.fRef, v2);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17.fString.fRef);

    if (v3)
    {
      int v4 = [(NSURL *)v1 path];
      id v5 = [v4 stringByStandardizingPath];
      id v13 = [v5 pathComponents];

      id v12 = &unk_1F2AC3800;
      uint64_t v6 = [v13 count];
      if (v6 == [&unk_1F2AC3800 count])
      {
        v11[0] = &v13;
        v11[1] = &v12;
        iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::cbegin<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>>(v11, (uint64_t)&v17);
        iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::cend<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>>(v11, (uint64_t)v14);
        while ((v17.fString.fRef != v14[0] || v18 != v14[16]) && (v19 != v15 || v20 != v16))
        {
          iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>,std::tuple<NSString * {__strong},NSString * {__strong}>>::operator*(&v17, &v21);
          CFURLRef v7 = (TString *)v21;
          v23.fString.fRef = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          TString::SetStringRefAsImmutable(&v23, v7);

          id v8 = v22;
          if ([v8 length])
          {
            char v9 = operator==((void **)&v23.fString.fRef, v8);

            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
            if ((v9 & 1) == 0)
            {
              uint64_t v3 = 0;
              goto LABEL_17;
            }
          }
          else
          {

            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
          }
          iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>,std::tuple<NSString * {__strong},NSString * {__strong}>>::operator++((uint64_t)&v17);
        }
        uint64_t v3 = 1;
LABEL_17:
      }
      else
      {
        uint64_t v3 = 0;
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_1D345BFD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Unwind_Resume(a1);
}

uint64_t operator==(void **a1, void *a2)
{
  id v3 = a2;
  int v4 = *a1;
  if (v3) {
    uint64_t v5 = [v4 isEqualToString:v3];
  }
  else {
    uint64_t v5 = [v4 isEqualToString:&stru_1F2ABD380];
  }
  uint64_t v6 = v5;

  return v6;
}

void sub_1D345C100(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id FP_ActionModifyFlags(void)
{
  return (id)*MEMORY[0x1E4F25930];
}

id FP_ActionReparent(void)
{
  return (id)*MEMORY[0x1E4F25940];
}

id FP_ActionUntrash(void)
{
  return (id)*MEMORY[0x1E4F25958];
}

id FP_ActionRename(void)
{
  return (id)*MEMORY[0x1E4F25938];
}

id FP_ActionDelete(void)
{
  return (id)*MEMORY[0x1E4F25920];
}

id FP_ActionTrash(void)
{
  return (id)*MEMORY[0x1E4F25950];
}

id FP_ActionCopy(void)
{
  return (id)*MEMORY[0x1E4F25918];
}

id FP_ActionTag(void)
{
  return (id)*MEMORY[0x1E4F25948];
}

void TChildrenList::~TChildrenList(TChildrenList *this)
{
  TChildrenList::DetachChildren(this);

  uint64_t v2 = (void **)((char *)this + 64);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v2);
  TDSMutex::~TDSMutex((TDSMutex *)this);
}

void TChildrenList::DetachChildren(TChildrenList *this)
{
  uint64_t v1 = (FINode **)*((void *)this + 8);
  uint64_t v2 = (FINode **)*((void *)this + 9);
  if (v1 != v2)
  {
    uint64_t v3 = *((void *)this + 12);
    do
    {
      uint64_t v4 = TNodeFromFINode(*v1);
      uint64_t v5 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v4);
      os_unfair_lock_lock(v5);
      if (*(void *)(v4 + 48) == v3) {
        *(void *)(v4 + 48) = 0;
      }
      os_unfair_lock_unlock(v5);
      uint64_t v6 = *v1++;
      CFURLRef v7 = (TNode *)TNodeFromFINode(v6);
      TNode::ClearAliasTarget(v7, 0);
    }
    while (v1 != v2);
  }
}

const void **___ZN12TGlobalNodes8RootNodeEv_block_invoke(uint64_t a1)
{
  TString::TString(&v10, "Computer", 8uLL);
  int v9 = 83886081;
  LOBYTE(obj) = 1;
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,TString &,TCatalogInfo &,void>((char *)&obj, &v10, (unsigned __int8 *)&v9, &v7);
  TNodePtr::TNodePtr(&v5, 0);
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  TNode::CreateNode((uint64_t)&v5, (uint64_t)&v7, (uint64_t)&v3, (TNodePtr *)&obj);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }

  objc_storeStrong(*(id **)(a1 + 32), obj);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
}

void sub_1D345C36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, void *a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }

  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v14 - 24));
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,TString &,TCatalogInfo &,void>@<X0>(char *a1@<X1>, const TString *a2@<X2>, unsigned __int8 *a3@<X3>, void *a4@<X8>)
{
  id v8 = operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,TString &,TCatalogInfo &,std::allocator<TFSInfo>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1D345C410(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,TString &,TCatalogInfo &,std::allocator<TFSInfo>,0>(void *a1, char *a2, const TString *a3, unsigned __int8 *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, a3, a4);
  return a1;
}

void sub_1D345C470(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

BOOL ___ZN13TFSVolumeInfo9LoadPrefsEv_block_invoke()
{
  TFSVolumeInfo::gNoNetworkPropertyStores = PrefsBool(@"DSDontWriteNetworkStores", 0);
  TFSVolumeInfo::gCanUseReadDir = PrefsBool(@"UseBareEnumeration", 1);
  TFSVolumeInfo::gTimeIterations = PrefsBool(@"RecordIterationTimes", 0);
  BOOL result = PrefsBool(@"SkipLSProperties", 1);
  TFSVolumeInfo::gSkipLSCFIndex Properties = result;
  return result;
}

void TBusyFolders::TBusyFolders(TBusyFolders *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  TString::TString(&v2, "/dev/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/mobile/tmp/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/db/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/tmp/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/mobile/Library/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
  TString::TString(&v2, "/private/var/logs/");
  TBusyFolders::AddPath(this, (TString **)&v2, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v2.fString.fRef);
}

void sub_1D345C63C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

uint64_t TBusyFolders::AddPath(TBusyFolders *this, TString **a2, char a3)
{
  uint64_t result = CFStringGetLength((CFStringRef)*a2);
  if (result)
  {
    uint64_t v7 = a2;
    uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)this, (TString *)a2, (uint64_t)&std::piecewise_construct, &v7);
    *(void *)(result + 24) = 0;
    *(_DWORD *)(result + 32) = 0;
    *(unsigned char *)(result + 36) = a3;
  }
  return result;
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(uint64_t a1, TString *this, uint64_t a3, TString ***a4)
{
  unint64_t v8 = FowlerNollVoHash::hash(this, this);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
    id v13 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (CFEqual(i[2], this->fString.fRef)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(a1, (__CFString *)v9, a4, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  id v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *id v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (uint64_t **)v25[0];
  v25[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1D345C968(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t FowlerNollVoHash::hash(TString *this, const TString *a2)
{
  uint64_t v2 = 0xCBF29CE484222325;
  uint64_t v3 = (const char *)TString::c_str(this);
  for (size_t i = strlen(v3); i; --i)
  {
    uint64_t v5 = *v3++;
    uint64_t v2 = 0x100000001B3 * (v2 ^ v5);
  }
  return v2;
}

TString *std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, __CFString *a2@<X1>, TString ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = (TString *)operator new(0x28uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  v8->fString.fRef = 0;
  v8[1].fString.fRef = a2;
  uint64_t result = std::pair<TString const,TBusyFolders::TSpecialFolderStream>::pair[abi:ne180100]<TString const&>(v8 + 2, *a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D345CA34(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

TString *std::pair<TString const,TBusyFolders::TSpecialFolderStream>::pair[abi:ne180100]<TString const&>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.fRef = 0;
  a1[2].fString.fRef = 0;
  return a1;
}

void sub_1D345CA94(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const void ***)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2 + 2);
    }
    operator delete(v2);
  }
}

void TFolderSizingThread::TFolderSizingThread(TFolderSizingThread *this, const TFSVolumeInfo *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  v39.fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  unint64_t v4 = (TFSInfo *)*((void *)a2 + 7);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)a2 + 8);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v4)
  {
    TFSInfo::Path(v4, (CFTypeRef *)&v34.fString.fRef);
    SanitizedPath(&v34);
    uint64_t v6 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    if ((TString *)v39.fString.fRef != v6) {
      TString::SetStringRefAsImmutable(&v39, v6);
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v34);
  uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v35, (uint64_t)"Slow TFolderSizingThread::GetFolderSizingQueue: '", 49);
  unint64_t v8 = (const char *)TString::c_str(&v39);
  size_t v9 = strlen(v8);
  unint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)v8, v9);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"'", 1);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v36, __p);
  if (v30 >= 0) {
    uint8x8_t v11 = __p;
  }
  else {
    uint8x8_t v11 = (void **)__p[0];
  }
  dispatch_queue_t v12 = dispatch_queue_create((const char *)v11, 0);
  id v13 = *(void **)this;
  *(void *)this = v12;

  if (SHIBYTE(v30) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = *(NSObject **)this;
  unint64_t v15 = dispatch_get_global_queue(-32768, 0);
  dispatch_set_target_queue(v14, v15);

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__p);
  float v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v30, (uint64_t)"Fast TFolderSizingThread::GetFolderSizingQueue: '", 49);
  float v17 = (const char *)TString::c_str(&v39);
  size_t v18 = strlen(v17);
  unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"'", 1);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v31, v27);
  if (v28 >= 0) {
    unint64_t v20 = v27;
  }
  else {
    unint64_t v20 = (void **)v27[0];
  }
  dispatch_queue_t v21 = dispatch_queue_create((const char *)v20, 0);
  id v22 = (void *)*((void *)this + 1);
  *((void *)this + 1) = v21;

  if (v28 < 0) {
    operator delete(v27[0]);
  }
  __p[0] = *(void **)MEMORY[0x1E4FBA408];
  unint64_t v23 = (__CFString *)__p[0];
  uint64_t v24 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  TString v25 = *(__CFString **)(MEMORY[0x1E4FBA408] + 64);
  *(void **)((char *)__p + *((void *)__p[0] - 3)) = v25;
  uint64_t v26 = v24;
  uint64_t v30 = v24;
  v31[0] = MEMORY[0x1E4FBA470] + 16;
  if (v32 < 0) {
    operator delete((void *)v31[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D94366B0](&v33);
  v34.fString.fRef = v23;
  *(__CFString **)((char *)&v34.fString.fRef + v23[-1].info) = v25;
  uint64_t v35 = v26;
  v36[0] = MEMORY[0x1E4FBA470] + 16;
  if (v37 < 0) {
    operator delete((void *)v36[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D94366B0](&v38);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39.fString.fRef);
}

void sub_1D345CF04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,const void *a47)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a47);
  if (v48) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v48);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v50 - 104));

  _Unwind_Resume(a1);
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1D94364E0](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      unint64_t v10 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1D94364F0](v13);
  return a1;
}

void sub_1D345D0CC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x1D94364F0](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1D345D0ACLL);
}

void sub_1D345D120(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      id v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_1D345D2A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TString::c_str(TString *this)
{
  uint64_t v1 = objc_retainAutorelease(this->fString.fRef);
  return [(__CFString *)v1 UTF8String];
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  uint64_t v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  int v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1D345D59C(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x1D94366B0](v1);
  _Unwind_Resume(a1);
}

uint64_t std::stringbuf::str[abi:ne180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = std::stringbuf::view[abi:ne180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v5 = (const void *)result;
  size_t v6 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((unsigned char *)a2 + 23) = v4;
    if (!v4) {
      goto LABEL_9;
    }
  }
  uint64_t result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((unsigned char *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:ne180100](uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    unint64_t v3 = *(void *)(a1 + 48);
    if (*(void *)(a1 + 88) < v3) {
      *(void *)(a1 + 88) = v3;
    }
    return *(void *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(void *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

void TFSVolumeInfo::SetDeviceThreads(TFSVolumeInfo *this)
{
  if (!TFSVolumeInfo::gFullEnvironment) {
    return;
  }
  if (!*((unsigned char *)this + 48))
  {
    if (*((unsigned char *)this + 107))
    {
      TFSVolumeInfo::CopyVolumeInfos(this, (uint64_t *)v39);
      uint64_t v12 = v39[0];
      if (v39[0] != v39[1])
      {
        while (!*(unsigned char *)(*(void *)v12 + 107)
             || *(unsigned __int8 *)(*(void *)v12 + 48) != *((unsigned __int8 *)this + 48))
        {
          uint64_t v12 = (TFSVolumeInfo *)((char *)v12 + 16);
          if (v12 == v39[1]) {
            goto LABEL_47;
          }
        }
      }
      if (v12 != v39[1])
      {
        uint64_t v14 = *(void **)v12;
        id v13 = (std::__shared_weak_count *)*((void *)v12 + 1);
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        char v37 = (void **)v39;
        std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v37);
        if (v14)
        {
          uint64_t v15 = v14[40];
          uint64_t v16 = v14[41];
          if (v16) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
          }
          float v17 = (std::__shared_weak_count *)*((void *)this + 41);
          *((void *)this + 40) = v15;
          *((void *)this + 41) = v16;
          if (v17)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v17);
            uint64_t v15 = *((void *)this + 40);
          }
          if (!v15)
          {
            char v37 = (void **)this;
            std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v37, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kSynchingQueueName, v39);
            long long v30 = *(_OWORD *)v39;
            v39[0] = 0;
            v39[1] = 0;
            uint64_t v31 = (std::__shared_weak_count *)*((void *)this + 41);
            *((_OWORD *)this + 20) = v30;
            if (v31)
            {
              std::__shared_weak_count::__release_shared[abi:ne180100](v31);
              if (v39[1]) {
                std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v39[1]);
              }
            }
          }
          uint64_t v18 = v14[42];
          uint64_t v19 = v14[43];
          if (v19) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v20 = (std::__shared_weak_count *)*((void *)this + 43);
          *((void *)this + 42) = v18;
          *((void *)this + 43) = v19;
          if (v20)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v20);
            uint64_t v18 = *((void *)this + 42);
          }
          if (!v18)
          {
            char v37 = (void **)this;
            std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v37, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kPropertyQueueName, v39);
            long long v32 = *(_OWORD *)v39;
            v39[0] = 0;
            v39[1] = 0;
            uint64_t v33 = (std::__shared_weak_count *)*((void *)this + 43);
            *((_OWORD *)this + 21) = v32;
            if (v33)
            {
              std::__shared_weak_count::__release_shared[abi:ne180100](v33);
              if (v39[1]) {
                std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v39[1]);
              }
            }
          }
          uint64_t v21 = v14[44];
          uint64_t v22 = v14[45];
          if (v22) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v23 = (std::__shared_weak_count *)*((void *)this + 45);
          *((void *)this + 44) = v21;
          *((void *)this + 45) = v22;
          if (v23)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v23);
            uint64_t v21 = *((void *)this + 44);
          }
          if (v21) {
            goto LABEL_58;
          }
          goto LABEL_55;
        }
LABEL_49:
        char v37 = (void **)this;
        std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v37, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kSynchingQueueName, v39);
        long long v24 = *(_OWORD *)v39;
        v39[0] = 0;
        v39[1] = 0;
        TString v25 = (std::__shared_weak_count *)*((void *)this + 41);
        *((_OWORD *)this + 20) = v24;
        if (v25)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v25);
          if (v39[1]) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v39[1]);
          }
        }
        char v37 = (void **)this;
        std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v37, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kPropertyQueueName, v39);
        long long v26 = *(_OWORD *)v39;
        v39[0] = 0;
        v39[1] = 0;
        id v27 = (std::__shared_weak_count *)*((void *)this + 43);
        *((_OWORD *)this + 21) = v26;
        if (v27)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v27);
          if (v39[1]) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v39[1]);
          }
        }
LABEL_55:
        char v37 = (void **)this;
        std::allocate_shared[abi:ne180100]<TFolderSizingThread,std::allocator<TFolderSizingThread>,TFSVolumeInfo *,void>((const TFSVolumeInfo **)&v37, v39);
        long long v28 = *(_OWORD *)v39;
        v39[0] = 0;
        v39[1] = 0;
        id v29 = (std::__shared_weak_count *)*((void *)this + 45);
        *((_OWORD *)this + 22) = v28;
        if (v29)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v29);
          if (v39[1]) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v39[1]);
          }
        }
LABEL_58:
        if (!v13) {
          return;
        }
        uint64_t v11 = v13;
        goto LABEL_60;
      }
LABEL_47:
      char v37 = (void **)v39;
      std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v37);
    }
    id v13 = 0;
    goto LABEL_49;
  }
  char v37 = (void **)this;
  std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>((const TFSVolumeInfo **)&v37, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kSynchingQueueName, v39);
  unint64_t v3 = v39[0];
  uint64_t v2 = v39[1];
  if (v39[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v39[1] + 1, 1uLL, memory_order_relaxed);
  }
  unint64_t v4 = (std::__shared_weak_count *)*((void *)this + 41);
  *((void *)this + 40) = v3;
  *((void *)this + 41) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v35 = this;
  std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>(&v35, (const char **)&TFSVolumeInfo::SetDeviceThreads(void)::kPropertyQueueName, &v37);
  size_t v6 = v37;
  uint64_t v5 = v38;
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 43);
  *((void *)this + 42) = v6;
  *((void *)this + 43) = v5;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  TString v34 = this;
  std::allocate_shared[abi:ne180100]<TFolderSizingThread,std::allocator<TFolderSizingThread>,TFSVolumeInfo *,void>(&v34, &v35);
  uint64_t v9 = v35;
  uint64_t v8 = v36;
  if (v36) {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 45);
  *((void *)this + 44) = v9;
  *((void *)this + 45) = v8;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  if (v36) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v36);
  }
  if (v38) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v38);
  }
  uint64_t v11 = (std::__shared_weak_count *)v39[1];
  if (v39[1]) {
LABEL_60:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
}

void sub_1D345DA44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  _Unwind_Resume(exception_object);
}

void *std::allocate_shared[abi:ne180100]<TVolumeSyncThread,std::allocator<TVolumeSyncThread>,TFSVolumeInfo *,char const*&,void>@<X0>(const TFSVolumeInfo **a1@<X1>, const char **a2@<X2>, void *a3@<X8>)
{
  size_t v6 = operator new(0x28uLL);
  uint64_t result = std::__shared_ptr_emplace<TVolumeSyncThread>::__shared_ptr_emplace[abi:ne180100]<TFSVolumeInfo *,char const*&,std::allocator<TVolumeSyncThread>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1D345DAE4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TVolumeSyncThread>::__shared_ptr_emplace[abi:ne180100]<TFSVolumeInfo *,char const*&,std::allocator<TVolumeSyncThread>,0>(void *a1, const TFSVolumeInfo **a2, const char **a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB208;
  TVolumeSyncThread::TVolumeSyncThread((TVolumeSyncThread *)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1D345DB48(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void TVolumeSyncThread::TVolumeSyncThread(TVolumeSyncThread *this, const TFSVolumeInfo *a2, const char *a3)
{
  *(_DWORD *)((char *)this + 7) = 0;
  *(void *)this = 0;
  *((unsigned char *)this + 8) = *((unsigned char *)a2 + 48);
  *((unsigned char *)this + 10) = *((unsigned char *)a2 + 120);
  v31.fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  size_t v6 = (TFSInfo *)*((void *)a2 + 7);
  uint64_t v7 = (std::__shared_weak_count *)*((void *)a2 + 8);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v6)
  {
    TFSInfo::Path(v6, (CFTypeRef *)&v26.fString.fRef);
    SanitizedPath(&v26);
    uint64_t v8 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    if ((TString *)v31.fString.fRef != v8) {
      TString::SetStringRefAsImmutable(&v31, v8);
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v26.fString.fRef);
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  unsigned int v9 = *((unsigned __int8 *)this + 8);
  if (v9 <= 0x21 && ((1 << v9) & 0x39DE00000) != 0)
  {
    uint64_t v10 = TFSVolumeInfo::GetDedicatedGCDQueue(v9);
    uint64_t v11 = *(void **)this;
    *(void *)this = v10;
  }
  else
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v26);
    size_t v12 = strlen(a3);
    id v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v27, (uint64_t)a3, v12);
    if (*((unsigned char *)this + 10)) {
      uint64_t v14 = " (boot) '";
    }
    else {
      uint64_t v14 = " '";
    }
    if (*((unsigned char *)this + 10)) {
      uint64_t v15 = 9;
    }
    else {
      uint64_t v15 = 2;
    }
    uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)v14, v15);
    float v17 = (const char *)TString::c_str(&v31);
    size_t v18 = strlen(v17);
    uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"'", 1);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v28, __p);
    if (v25 >= 0) {
      unint64_t v20 = __p;
    }
    else {
      unint64_t v20 = (void **)__p[0];
    }
    dispatch_queue_t v21 = dispatch_queue_create((const char *)v20, 0);
    uint64_t v22 = *(void **)this;
    *(void *)this = v21;

    if (v25 < 0) {
      operator delete(__p[0]);
    }
    v26.fString.fRef = (__CFString *)*MEMORY[0x1E4FBA408];
    uint64_t v23 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(TString *)((char *)&v26 + v26.fString.fRef[-1].info) = *(TString *)(MEMORY[0x1E4FBA408] + 64);
    uint64_t v27 = v23;
    v28[0] = MEMORY[0x1E4FBA470] + 16;
    if (v29 < 0) {
      operator delete((void *)v28[8]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1D94366B0](&v30);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v31.fString.fRef);
}

void sub_1D345DE54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v5 - 64));

  _Unwind_Resume(a1);
}

const void **TFSInfo::Path@<X0>(TFSInfo *this@<X0>, CFTypeRef *a2@<X8>)
{
  TFSInfo::GetPath(this, (uint64_t)v5);
  TString::TString(&v4, "", 0);
  fstd::optional_err<TString,int>::value_or<TString>((uint64_t)v5, (CFTypeRef *)&v4.fString.fRef, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
}

void sub_1D345DF28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  unint64_t v3 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

CFTypeRef *fstd::optional_err<TString,int>::value_or<TString>@<X0>(uint64_t a1@<X0>, CFTypeRef *a2@<X1>, CFTypeRef *a3@<X8>)
{
  if (*(_DWORD *)(a1 + 8))
  {
    *a3 = *a2;
    *a2 = 0;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
  }
  else
  {
    *a3 = *(CFTypeRef *)a1;
    *(void *)a1 = 0;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, &stru_1F2ABD380);
  }
}

__CFString *SanitizedPath(TString *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (IsRedactionEnabled())
  {
    uint64_t v14 = a1;
    unint64_t v3 = [MEMORY[0x1E4F1CA48] array];
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    TString v4 = [(__CFString *)v14->fString.fRef pathComponents];
    uint64_t v5 = [v4 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v19;
      do
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          if (*(void *)v19 != v6) {
            objc_enumerationMutation(v4);
          }
          uint64_t v8 = *(void **)(*((void *)&v18 + 1) + 8 * i);
          AcceptableNames();
          unsigned int v9 = v8;
          id v17 = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          TString::SetStringRefAsImmutable((TString *)&v17, v9);

          uint64_t v10 = std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::find<TString>(AcceptableNames(void)::sNames, (TString *)&v17);
          if (!v10)
          {
            uint64_t v11 = v9;
            v15.fString.fRef = &stru_1F2ABD380;
            CFRetain(&stru_1F2ABD380);
            TString::SetStringRefAsImmutable(&v15, v11);

            RedactedStr(&v15, (TString *)&v16);
            int v1 = (TString *)v16;
            unsigned int v9 = v1;
          }
          [v3 addObject:v9];
          if (!v10)
          {

            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17);
        }
        uint64_t v5 = [v4 countByEnumeratingWithState:&v18 objects:v22 count:16];
      }
      while (v5);
    }

    if ([v3 count])
    {
      size_t v12 = [NSString pathWithComponents:v3];
    }
    else
    {
      RedactedStr(v14, (TString *)&v17);
      size_t v12 = (__CFString *)v17;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17);
    }
  }
  else
  {
    size_t v12 = a1->fString.fRef;
  }
  return v12;
}

void sub_1D345E224(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL PrefsBool(const __CFString *a1, BOOL a2)
{
  CFStringRef v3 = (const __CFString *)CFPreferencesCopyAppValue(a1, @"com.apple.desktopservices");
  CFStringRef theString1 = v3;
  if (v3)
  {
    CFTypeID v4 = CFGetTypeID(v3);
    if (v4 == CFStringGetTypeID())
    {
      if (CFStringCompare(theString1, @"true", 1uLL) == kCFCompareEqualTo
        || CFStringCompare(theString1, @"1", 1uLL) == kCFCompareEqualTo)
      {
        a2 = 1;
        goto LABEL_14;
      }
      BOOL v5 = CFStringCompare(theString1, @"YES", 1uLL) == kCFCompareEqualTo;
    }
    else
    {
      CFTypeID v6 = CFGetTypeID(theString1);
      if (v6 == CFBooleanGetTypeID())
      {
        a2 = CFEqual(theString1, (CFTypeRef)*MEMORY[0x1E4F1CFD0]) != 0;
        goto LABEL_14;
      }
      CFTypeID v7 = CFGetTypeID(theString1);
      if (v7 != CFNumberGetTypeID()) {
        goto LABEL_14;
      }
      BOOL v5 = CFEqual(theString1, &unk_1F2AC3848) == 0;
    }
    a2 = v5;
  }
LABEL_14:
  TRef<void const*,TRetainReleasePolicy<void const*>>::~TRef((const void **)&theString1);
  return a2;
}

void sub_1D345E3E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<void const*,TRetainReleasePolicy<void const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TRef<void const*,TRetainReleasePolicy<void const*>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

BOOL IsRedactionEnabled(void)
{
  {
    IsRedactionEnabled(void)::isAppleInternal = os_variant_has_internal_ui();
  }
  if (!IsRedactionEnabled(void)::isAppleInternal) {
    return 1;
  }
  if (TCFURLInfo::gDSHelperRunning) {
    return 0;
  }
  return PrefsBool(@"EnableRedactionOnInternal", 0);
}

void sub_1D345E4E4(_Unwind_Exception *a1)
{
}

void *std::allocate_shared[abi:ne180100]<TFolderSizingThread,std::allocator<TFolderSizingThread>,TFSVolumeInfo *,void>@<X0>(const TFSVolumeInfo **a1@<X1>, void *a2@<X8>)
{
  CFTypeID v4 = operator new(0x28uLL);
  uint64_t result = std::__shared_ptr_emplace<TFolderSizingThread>::__shared_ptr_emplace[abi:ne180100]<TFSVolumeInfo *,std::allocator<TFolderSizingThread>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1D345E548(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFolderSizingThread>::__shared_ptr_emplace[abi:ne180100]<TFSVolumeInfo *,std::allocator<TFolderSizingThread>,0>(void *a1, const TFSVolumeInfo **a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB278;
  TFolderSizingThread::TFolderSizingThread((TFolderSizingThread *)(a1 + 3), *a2);
  return a1;
}

void sub_1D345E5A8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

id TFSVolumeInfo::GetDedicatedGCDQueue(int a1)
{
  if (TFSVolumeInfo::GetDedicatedGCDQueue(FSInfoVirtualType)::once != -1) {
    dispatch_once(&TFSVolumeInfo::GetDedicatedGCDQueue(FSInfoVirtualType)::once, &__block_literal_global_6);
  }
  char v2 = a1 - 21;
  if ((a1 - 21) >= 0xD || ((0x1CEFu >> v2) & 1) == 0) {
    abort();
  }
  CFStringRef v3 = (void *)*off_1E6990220[v2];
  return v3;
}

const void **TFSVolumeInfo::CreateHiddenList(TFSVolumeInfo *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t result = (const void **)TFSVolumeInfo::MayHaveHiddenList(this);
  if (result)
  {
    TString::TString(&v9, "mach (Mac OS 9)", 0xFuLL);
    TString::TString(&v10, "mach.sym (Mac OS 9)", 0x13uLL);
    TString::TString(&v11, "mach", 4uLL);
    TString::TString(&v12, "mach.sym", 8uLL);
    TString::TString(&v13, "automount", 9uLL);
    TString::TString(&v14, "Network Trash Folder", 0x14uLL);
    TString::TString(&v15, "TheVolumeSettingsFolder", 0x17uLL);
    TString::TString(&v16, "Temporary Items", 0xFuLL);
    CFTypeID v4 = 0;
    uint64_t v5 = 0;
    CFTypeID v6 = 0;
    CFTypeID v7 = &v4;
    char v8 = 0;
    CFTypeID v4 = (char *)operator new(0x40uLL);
    uint64_t v5 = (uint64_t)v4;
    CFTypeID v6 = v4 + 64;
    uint64_t v5 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString const*,TString const*,TString*>((uint64_t)&v6, (uint64_t)&v9, (uint64_t)&v17, (uint64_t)v4);
    std::optional<std::vector<TString>>::operator=[abi:ne180100]<std::vector<TString>,void>((uint64_t)this + 192, (uint64_t)&v4);
    CFTypeID v7 = &v4;
    std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
    for (uint64_t i = 56; i != -8; i -= 8)
      uint64_t result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)((char *)&v9.fString.fRef + i));
  }
  return result;
}

void sub_1D345E7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, char a14)
{
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&a12);
  for (uint64_t i = 56; i != -8; i -= 8)
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(&a14 + i));
  _Unwind_Resume(a1);
}

void TString::TString(TString *this, const UInt8 *a2, CFIndex a3)
{
  this->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, &stru_1F2ABD380);
  if (a2) {
    TString::SetFromUTF8(this, a2, a3);
  }
}

void sub_1D345E8CC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

BOOL TFSVolumeInfo::MayHaveHiddenList(TFSVolumeInfo *this)
{
  uint64_t v1 = *((void *)this + 7);
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v1 + 100));
    CFStringRef v3 = *(const void **)(v1 + 16);
    CFTypeID v6 = v3;
    if (v3)
    {
      CFRetain(v3);
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 100));
      if (!*((unsigned char *)this + 127) && !*((unsigned char *)this + 108))
      {
        BOOL v4 = *((unsigned char *)this + 48) == 0;
LABEL_9:
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v6);
        return v4;
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 100));
    }
    BOOL v4 = 0;
    goto LABEL_9;
  }
  return 0;
}

void sub_1D345E980(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::vector<TString>>::operator=[abi:ne180100]<std::vector<TString>,void>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    std::vector<TString>::__vdeallocate((void **)a1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 16) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString const*,TString const*,TString*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      std::construct_at[abi:ne180100]<TString,TString const&,TString*>((TString *)(a4 + v7), (TString **)(a2 + v7));
      v7 += 8;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1D345EA70(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 8;
    do
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v4 + v2));
      v2 -= 8;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D345EAE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  TString v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)FINodeIterator;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

uint64_t NodeDisposeIterator(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (id *)result;
    uint64_t v2 = (void **)(result + 16);
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v2);

    return MEMORY[0x1D9436740](v1, 0x10E0C40DDD8502FLL);
  }
  return result;
}

void TNodeIterator::GetVisibleChildrenAndSortProperties(const TNodePtr *a1@<X1>, int a2@<W2>, int a3@<W3>, uint64_t a4@<X8>)
{
  TString v9 = (TNode *)TNodeFromFINode(a1->fFINode);
  TNode::GetSuperRootNode((uint64_t *)&v46, v9);
  uint64_t v10 = TNodeFromFINode(v46);

  TString v11 = (TNode *)TNodeFromFINode(a1->fFINode);
  TNode::CopyChildren(v11, (uint64_t)&v46);
  memset(v45, 0, sizeof(v45));
  std::vector<TNodePtr>::reserve((uint64_t)v45, v47 - v46);
  memset(v44, 0, sizeof(v44));
  memset(&v43, 0, sizeof(v43));
  if (a2)
  {
    std::vector<TString>::reserve((uint64_t)v44, v47 - v46);
    std::vector<int>::reserve(&v43, v47 - v46);
  }
  uint64_t v39 = a4;
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v42, a1, 0);
  TString v13 = (FINode **)v46;
  TString v12 = (FINode **)v47;
  if (v46 != v47)
  {
    while (1)
    {
      if (!a3) {
        goto LABEL_14;
      }
      TString v14 = (TNode *)TNodeFromFINode(*v13);
      int IsVisible = TNode::IsVisible(v14);
      int v16 = v9 == (TNode *)v10 ? IsVisible : 0;
      if (v16 == 1) {
        break;
      }
      if (IsVisible) {
        goto LABEL_14;
      }
LABEL_40:
      if (++v13 == v12) {
        goto LABEL_41;
      }
    }
    uint64_t v17 = (TNode *)TNodeFromFINode(*v13);
    TNode::GetVolumeInfo(v17, &v40);
    int v18 = BYTE2(v40.fString.fRef[3].data);
    if (v41) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v41);
    }
    if (v18) {
      goto LABEL_40;
    }
LABEL_14:
    std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)v45, (id *)v13);
    if (a2)
    {
      uint64_t v19 = TNodeFromFINode(*v13);
      long long v20 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v19);
      os_unfair_lock_lock(v20);
      uint64_t v22 = *(TFSInfo **)(v19 + 16);
      long long v21 = *(std::__shared_weak_count **)(v19 + 24);
      if (v21) {
        atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v20);
      int Index = TFSInfo::GetIndex(v22);
      int v24 = Index;
      std::vector<int>::pointer end = v43.__end_;
      if (v43.__end_ >= v43.__end_cap_.__value_)
      {
        std::vector<int>::pointer begin = v43.__begin_;
        int64_t v28 = v43.__end_ - v43.__begin_;
        unint64_t v29 = v28 + 1;
        if ((unint64_t)(v28 + 1) >> 62) {
          std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
        }
        int64_t v30 = (char *)v43.__end_cap_.__value_ - (char *)v43.__begin_;
        if (((char *)v43.__end_cap_.__value_ - (char *)v43.__begin_) >> 1 > v29) {
          unint64_t v29 = v30 >> 1;
        }
        if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v31 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v31 = v29;
        }
        if (v31)
        {
          long long v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v43.__end_cap_, v31);
          std::vector<int>::pointer begin = v43.__begin_;
          std::vector<int>::pointer end = v43.__end_;
        }
        else
        {
          long long v32 = 0;
        }
        uint64_t v33 = (int *)&v32[4 * v28];
        int *v33 = v24;
        TString v26 = v33 + 1;
        while (end != begin)
        {
          int v34 = *--end;
          *--uint64_t v33 = v34;
        }
        v43.__begin_ = v33;
        v43.__end_ = v26;
        v43.__end_cap_.__value_ = (int *)&v32[4 * v31];
        if (begin) {
          operator delete(begin);
        }
      }
      else
      {
        *v43.__end_ = Index;
        TString v26 = end + 1;
      }
      v43.__end_ = v26;
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v21);
      }
      uint64_t v35 = TNodeFromFINode(*v13);
      uint64_t v36 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v35);
      os_unfair_lock_lock(v36);
      uint64_t v38 = *(TFSInfo **)(v35 + 16);
      char v37 = *(std::__shared_weak_count **)(v35 + 24);
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v36);
      TFSInfo::Name(v38, &v40);
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      std::vector<TString>::push_back[abi:ne180100]((uint64_t)v44, (CFTypeRef *)&v40.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40.fString.fRef);
    }
    goto LABEL_40;
  }
LABEL_41:
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorI8TNodePtrNS_9allocatorIS4_EEEENS3_I7TStringNS5_IS8_EEEENS3_IiNS5_IiEEEEEEC2B8ne180100IJLm0ELm1ELm2EEJS7_SA_SC_EJEJEJRS7_RSA_RSC_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSJ_IJDpT2_EEEDpOT3_(v39, v45, (uint64_t *)v44, (uint64_t)&v43);
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)v42);
  if (v43.__begin_)
  {
    v43.__end_ = v43.__begin_;
    operator delete(v43.__begin_);
  }
  v43.__begin_ = (std::vector<int>::pointer)v44;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)&v43);
  v44[0] = (void **)v45;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v44);
  v45[0] = (void **)&v46;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v45);
}

void sub_1D345EE9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t **__p, uint64_t **a17, uint64_t a18, uint64_t *a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)&a13);
  if (__p)
  {
    a17 = __p;
    operator delete(__p);
  }
  __p = &a19;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  a19 = &a22;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  a22 = v22 - 112;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a22);
  _Unwind_Resume(a1);
}

void TChildrenList::AddNewChild(TChildrenList *this@<X0>, const TNodePtr *a2@<X1>, BOOL *a3@<X2>, void *a4@<X8>)
{
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  std::vector<TNodePtr>::vector(v8, 1uLL, (id *)&a2->fFINode);
  *a3 = TChildrenList::AddNewChildren((uint64_t)this, (TNodePtr **)v8, 1, (uint64_t)v11, (uint64_t *)v10, (uint64_t *)v9);
  TString v12 = v8;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v12);
  if (*a3) {
    uint64_t v7 = (id **)v11;
  }
  else {
    uint64_t v7 = v9;
  }
  *a4 = **v7;
  v8[0] = (void **)v9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v8);
  v9[0] = (void **)v10;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v9);
  v10[0] = (void **)v11;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v10);
}

void sub_1D345F03C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void ****a10, uint64_t a11, uint64_t a12, void ***a13, uint64_t a14, uint64_t a15, void **a16, uint64_t a17, uint64_t a18, char a19)
{
  *(void *)(v20 - 72) = v19;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)(v20 - 72));
  a10 = &a13;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  a13 = &a16;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  a16 = (void **)&a19;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a16);
  _Unwind_Resume(a1);
}

void std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        CFTypeID v6 = (void *)*((void *)v4 - 1);
        v4 -= 8;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t TChildrenList::AddNewChildren(uint64_t a1, TNodePtr **a2, int a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v10 = *(void ***)a4;
  for (uint64_t i = *(void ***)(a4 + 8); i != v10; --i)
  {
    TString v12 = *(i - 1);
  }
  *(void *)(a4 + 8) = v10;
  uint64_t v13 = *a6;
  for (uint64_t j = a6[1]; j != v13; j -= 8)
  {
    TString v15 = *(void **)(j - 8);
  }
  a6[1] = v13;
  uint64_t v16 = *a5;
  for (uint64_t k = a5[1]; k != v16; k -= 8)
  {
    int v18 = *(void **)(k - 8);
  }
  a5[1] = v16;
  if (*a2 == a2[1]) {
    return 0;
  }
  uint64_t v19 = *(void *)(a1 + 96);
  TNode::GetSuperRootNode((uint64_t *)&v49, (TNode *)a1);
  uint64_t v20 = TNodeFromFINode(v49.fFINode);

  if (v19 == v20) {
    int v21 = 0;
  }
  else {
    int v21 = a3;
  }
  std::vector<TNodePtr>::reserve(a1 + 64, a2[1] - *a2 + ((uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 3));
  std::vector<TNodePtr>::reserve(a4, a2[1] - *a2);
  uint64_t v23 = *a2;
  uint64_t v22 = a2[1];
  while (v23 != v22)
  {
    int v24 = TChildrenList::LowerBounds((TChildrenList *)a1, v23);
    if (*(FINode ***)(a1 + 72) != v24)
    {
      char v25 = v24;
      uint64_t v26 = TNodeFromFINode(v23->fFINode);
      uint64_t v27 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v26);
      os_unfair_lock_lock(v27);
      uint64_t v29 = *(void *)(v26 + 16);
      int64_t v28 = *(std::__shared_weak_count **)(v26 + 24);
      if (v28) {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v27);
      uint64_t v30 = TNodeFromFINode(*v25);
      unint64_t v31 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v30);
      os_unfair_lock_lock(v31);
      long long v32 = *(std::__shared_weak_count **)(v30 + 24);
      v49.fFINode = *(FINode **)(v30 + 16);
      uint64_t v50 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v31);
      if (TFSInfo::Equal((TFSInfo *)v29, (TFSInfo **)&v49))
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v29 + 100));
        int v33 = *(_DWORD *)(v29 + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)(v29 + 100));
        if ((v33 & 0x1000000) != 0)
        {
          os_unfair_lock_lock((os_unfair_lock_t)(v29 + 100));
          uint64_t v35 = *(objc_class **)(v29 + 16);
          Class v48 = v35;
          if (v35) {
            CFRetain(v35);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)(v29 + 100));
          fFINode = v49.fFINode;
          char v37 = (os_unfair_lock_s *)&v49.fFINode[12].super.isa + 1;
          os_unfair_lock_lock((os_unfair_lock_t)&v49.fFINode[12].super.isa + 1);
          Class isa = fFINode[2].super.isa;
          Class v47 = isa;
          if (isa) {
            CFRetain(isa);
          }
          os_unfair_lock_unlock(v37);
          BOOL v34 = v48 != v47;
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v47);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v48);
        }
        else
        {
          BOOL v34 = 0;
        }
      }
      else
      {
        BOOL v34 = 1;
      }
      if (v50) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v50);
      }
      if (v28)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v28);
        if (!v34) {
          goto LABEL_37;
        }
      }
      else if (!v34)
      {
LABEL_37:
        std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)a6, (id *)v25);
        uint64_t v39 = (uint64_t)a5;
        goto LABEL_38;
      }
    }
    uint64_t v39 = a4;
    if (v21)
    {
      uint64_t v40 = TNodeFromFINode(v23->fFINode);
      TNodePtr::TNodePtr(&v49, *(const TNode **)(a1 + 96));
      long long v42 = (os_unfair_lock_s *)TNode::ParentLock(v41);
      os_unfair_lock_lock(v42);
      *(void *)(v40 + 48) = TNodeFromFINode(v49.fFINode);
      os_unfair_lock_unlock(v42);

      uint64_t v39 = a4;
    }
LABEL_38:
    std::vector<TNodePtr>::push_back[abi:ne180100](v39, (id *)&v23->fFINode);
    ++v23;
  }
  std::vector<int> v43 = *(void ***)(a4 + 8);
  if (*(void ***)a4 != v43)
  {
    std::vector<TNodePtr>::__insert_with_size[abi:ne180100]<std::__wrap_iter<TNodePtr*>,std::__wrap_iter<TNodePtr*>>(a1 + 64, *(id **)(a1 + 72), *(void ***)a4, v43, ((uint64_t)v43 - *(void *)a4) >> 3);
    atomic_store((uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 3, (unint64_t *)(a1 + 160));
    ++*(_DWORD *)(a1 + 184);
    return 1;
  }
  return 0;
}

void sub_1D345F44C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void *std::vector<TNodePtr>::vector(void *a1, unint64_t a2, id *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<TNodePtr>::__vallocate[abi:ne180100](a1, a2);
    CFTypeID v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1D345F548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

id *std::vector<TNodePtr>::__insert_with_size[abi:ne180100]<std::__wrap_iter<TNodePtr*>,std::__wrap_iter<TNodePtr*>>(uint64_t a1, id *a2, void **a3, void **a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = a3;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    uint64_t v13 = *(id **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = a2 - v13;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    v33[4] = v9;
    if (v17) {
      int v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v9, v17);
    }
    else {
      int v18 = 0;
    }
    uint64_t v27 = &v18[8 * v15];
    v33[0] = v18;
    v33[1] = v27;
    v33[3] = &v18[8 * v17];
    uint64_t v28 = 8 * a5;
    uint64_t v29 = &v27[8 * a5];
    do
    {
      uint64_t v30 = *v7++;
      *(void *)uint64_t v27 = v30;
      v27 += 8;
      v28 -= 8;
    }
    while (v28);
    v33[2] = v29;
    uint64_t v5 = std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, v33, v5);
    std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v33);
    return v5;
  }
  uint64_t v19 = v12 - (void)a2;
  uint64_t v20 = (uint64_t)(v12 - (void)a2) >> 3;
  if (v20 >= a5)
  {
    uint64_t v26 = &a3[a5];
LABEL_18:
    std::vector<TNodePtr>::__move_range(a1, (uint64_t)v5, v12, (uint64_t)&v5[a5]);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TNodePtr *,TNodePtr *,TNodePtr *>((int)v33, v7, v26, v5);
    return v5;
  }
  uint64_t v22 = &a3[v20];
  long long v32 = v22;
  uint64_t v23 = *(void *)(v9 - 8);
  if (v22 != a4)
  {
    int v24 = *(void **)(v9 - 8);
    do
    {
      char v25 = *v22++;
      *v24++ = v25;
      v23 += 8;
    }
    while (v22 != a4);
  }
  *(void *)(a1 + 8) = v23;
  uint64_t v26 = v32;
  if (v19 >= 1) {
    goto LABEL_18;
  }
  return v5;
}

void sub_1D345F6FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

FINode **TChildrenList::LowerBounds(TChildrenList *this, const TNodePtr *a2)
{
  uint64_t v3 = TNodeFromFINode(a2->fFINode);
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
  os_unfair_lock_lock(v4);
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 24);
  uint64_t v8 = *(TFSInfo **)(v3 + 16);
  uint64_t v9 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  CFTypeID v6 = TChildrenList::LowerBounds((uint64_t)this, &v8);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  return v6;
}

void sub_1D345F798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

FINode **TChildrenList::LowerBounds(uint64_t a1, TFSInfo **a2)
{
  TChildrenList::SortListIfNeeded((TChildrenList *)a1, 0);
  uint64_t v5 = *(FINode ***)(a1 + 64);
  uint64_t result = *(FINode ***)(a1 + 72);
  if (result != v5)
  {
    unint64_t v6 = result - v5;
    do
    {
      uint64_t v7 = &v5[v6 >> 1];
      uint64_t v8 = TNodeFromFINode(*v7);
      uint64_t v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
      os_unfair_lock_lock(v9);
      uint64_t v11 = *(TFSInfo **)(v8 + 16);
      uint64_t v10 = *(std::__shared_weak_count **)(v8 + 24);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v9);
      BOOL v12 = TFSInfo::LessThan(v11, a2);
      if (v10) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v10);
      }
      if (v12) {
        v6 += ~(v6 >> 1);
      }
      else {
        v6 >>= 1;
      }
      if (v12) {
        uint64_t v5 = v7 + 1;
      }
    }
    while (v6);
    return v5;
  }
  return result;
}

void sub_1D345F884(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void TNode::CopyChildren(TNode *this@<X0>, uint64_t a2@<X8>)
{
  TNodePtr::TNodePtr(&v6, this);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v7, &v6, 0);

  uint64_t v4 = *((void *)this + 7);
  if (v4) {
    uint64_t v5 = (void ***)(v4 + 64);
  }
  else {
    uint64_t v5 = (void ***)&TNode::GetChildren(void)const::sEmptyList;
  }
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)a2, *v5, v5[1], v5[1] - *v5);
  TNode::StPopulating::~StPopulating(v7);
}

void sub_1D345F930(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TNode::StPopulating::~StPopulating((FINode **)va);
  _Unwind_Resume(a1);
}

char *std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>(char *result, void **a2, void **a3, unint64_t a4)
{
  if (a4)
  {
    TNodePtr v6 = result;
    uint64_t result = std::vector<TNodePtr>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (char **)*((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2++;
      uint64_t result = v8;
      *v7++ = result;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1D345F9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_6vectorI8TNodePtrNS_9allocatorIS4_EEEENS3_I7TStringNS5_IS8_EEEENS3_IiNS5_IiEEEEEEC2B8ne180100IJLm0ELm1ELm2EEJS7_SA_SC_EJEJEJRS7_RSA_RSC_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSJ_IJDpT2_EEEDpOT3_(uint64_t a1, void ***a2, uint64_t *a3, uint64_t a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)a1, *a2, a2[1], a2[1] - *a2);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  std::vector<TString>::__init_with_size[abi:ne180100]<TString*,TString*>((void *)(a1 + 24), *a3, a3[1], (a3[1] - *a3) >> 3);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)(a1 + 48), *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2);
  return a1;
}

void sub_1D345FA68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void *std::vector<TString>::__init_with_size[abi:ne180100]<TString*,TString*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    TNodePtr v6 = result;
    std::vector<TNodePtr>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString*,TString*,TString*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1D345FAFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    TNodePtr v6 = result;
    uint64_t result = std::vector<int>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1D345FB7C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void TNodeIterator::TNodeIterator(TNodeIterator *this, const TNodePtr *a2, int a3)
{
  *((_OWORD *)this + 1) = 0u;
  uint64_t v5 = (void ***)((char *)this + 16);
  *((void *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  objc_storeStrong((id *)this, a2->fFINode);
  *((_DWORD *)this + 11) = 0;
  *((unsigned char *)this + 40) = 0;
  if (TNodeFromFINode(*(FINode **)this))
  {
    uint64_t v6 = TNodeFromFINode(*(FINode **)this);
    uint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v6);
    os_unfair_lock_lock(v7);
    uint64_t v9 = *(TFSInfo **)(v6 + 16);
    size_t v8 = *(std::__shared_weak_count **)(v6 + 24);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v7);
    int IsIndexSorted = TFSInfo::IsIndexSorted(v9);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    TNodeIterator::GetVisibleChildrenAndSortProperties((const TNodePtr *)this, IsIndexSorted, a3, (uint64_t)&v21);
    if (IsIndexSorted)
    {
      memset(&v20, 0, sizeof(v20));
      std::vector<int>::resize(&v20, v22 - v21);
      std::vector<int>::pointer begin = v20.__begin_;
      if (v22 != v21)
      {
        uint64_t v12 = 0;
        unint64_t v13 = v22 - v21;
        do
        {
          begin[v12] = v12;
          ++v12;
        }
        while (v13 > v12);
      }
      unint64_t v14 = 126 - 2 * __clz(v20.__end_ - begin);
      v25[0] = &v21;
      v25[1] = __p;
      v25[2] = v23;
      if (v20.__end_ == begin) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = v14;
      }
      std::__introsort<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,false>((unint64_t)begin, v20.__end_, v25, v15, 1);
      std::vector<TNodePtr>::resize(v5, v22 - v21);
      uint64_t v16 = v21;
      if (v22 != v21)
      {
        unint64_t v17 = 0;
        unsigned int v18 = 1;
        do
        {
          objc_storeStrong(&(*v5)[v17], v16[v20.__begin_[v17]]);
          unint64_t v17 = v18;
          uint64_t v16 = v21;
          ++v18;
        }
        while (v17 < v22 - v21);
      }
      if (v20.__begin_)
      {
        v20.__end_ = v20.__begin_;
        operator delete(v20.__begin_);
      }
    }
    else if (v5 != &v21)
    {
      std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((uint64_t)v5, v21, v22, v22 - v21);
    }
    uint64_t v19 = (TNode *)TNodeFromFINode(*(FINode **)this);
    *((unsigned char *)this + 40) = TNode::IsPopulated(v19);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v25[0] = v23;
    std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)v25);
    v25[0] = &v21;
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)v25);
  }
  *((void *)this + 1) = *((void *)this + 2);
}

{
  TNodeIterator::TNodeIterator(this, a2, a3);
}

void sub_1D345FDC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);

  _Unwind_Resume(a1);
}

void std::vector<TString>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (const void **)**a1;
  if (v2)
  {
    uint64_t v4 = (const void **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        uint64_t v4 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4 - 1);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>(uint64_t a1, void **a2, void **a3, unint64_t a4)
{
  uint64_t v6 = a2;
  size_t v8 = *(id **)a1;
  if (a4 <= (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)
  {
    unint64_t v14 = (uint64_t)(*(void *)(a1 + 8) - (void)v8) >> 3;
    if (v14 >= a4)
    {
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TNodePtr *,TNodePtr *,TNodePtr *>((int)&v24, a2, a3, v8);
      uint64_t v20 = v19;
      uint64_t v21 = *(void *)(a1 + 8);
      if (v21 != v19)
      {
        do
        {
          uint64_t v22 = *(void **)(v21 - 8);
          v21 -= 8;
        }
        while (v21 != v20);
      }
      *(void *)(a1 + 8) = v20;
    }
    else
    {
      uint64_t v15 = &a2[v14];
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TNodePtr *,TNodePtr *,TNodePtr *>((int)&v23, a2, v15, v8);
      uint64_t v16 = *(void *)(a1 + 8);
      if (v15 != a3)
      {
        unint64_t v17 = *(void **)(a1 + 8);
        do
        {
          unsigned int v18 = *v15++;
          *v17++ = v18;
          v16 += 8;
        }
        while (v15 != a3);
      }
      *(void *)(a1 + 8) = v16;
    }
  }
  else
  {
    std::vector<TNodePtr>::__vdeallocate((void **)a1);
    if (a4 >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = *(void *)(a1 + 16) - *(void *)a1;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<TNodePtr>::__vallocate[abi:ne180100]((void *)a1, v11);
    uint64_t v12 = *(void **)(a1 + 8);
    while (v6 != a3)
    {
      unint64_t v13 = *v6++;
      *v12++ = v13;
    }
    *(void *)(a1 + 8) = v12;
  }
}

void std::vector<TNodePtr>::__vdeallocate(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 1);
        v3 -= 8;
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t TFSInfo::IsIndexSorted(TFSInfo *this)
{
  return (*((unsigned __int8 *)this + 112) < 0x24uLL) & (0xF803E0000uLL >> *((unsigned char *)this + 112));
}

void **std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<TNodePtr *,TNodePtr *,TNodePtr *>(int a1, void **a2, void **a3, id *location)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      uint64_t v7 = *v5++;
      objc_storeStrong(location++, v7);
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString*,TString*,TString*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      std::construct_at[abi:ne180100]<TString,TString&,TString*>((TString *)(a4 + v7), (TString **)(a2 + v7));
      v7 += 8;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_1D3460140(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 8;
    do
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v4 + v2));
      v2 -= 8;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

TString *std::construct_at[abi:ne180100]<TString,TString&,TString*>(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *a2);
  return a1;
}

void sub_1D34601A8(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void sub_1D3460240(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34602A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::AddVolume(TCFURLInfo *a1, char a2, uint64_t *a3)
{
  _ZNSt3__115allocate_sharedB8ne180100I13TFSVolumeInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v27);
  TCFURLInfo::GetVolumeID(a1, v6, &cf);
  CFTypeRef v25 = cf;
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v7 = TFSVolumeInfo::InitializeFileSystemVolume();
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v25);
  if (v7)
  {
    uint64_t v9 = v27;
    size_t v8 = v28;
    if (v28) {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v10 = (std::__shared_weak_count *)a3[1];
    *a3 = v9;
    a3[1] = (uint64_t)v8;
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
    goto LABEL_30;
  }
  CFTypeRef v23 = cf;
  if (cf) {
    CFRetain(cf);
  }
  TFSVolumeInfo::GetMapKey(&v23, a2, (uint64_t)v24);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v23);
  uint64_t VolumeMap = (void *)GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  uint64_t v12 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::find<VolumeKey>(VolumeMap, v24);
  unint64_t v13 = (std::__shared_weak_count *)a3[1];
  *a3 = 0;
  a3[1] = 0;
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  if (v12)
  {
    unint64_t v14 = (std::__shared_weak_count *)v12[5];
    if (v14 && (unint64_t v14 = std::__shared_weak_count::lock(v14)) != 0) {
      uint64_t v15 = v12[4];
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = (std::__shared_weak_count *)a3[1];
    *a3 = v15;
    a3[1] = (uint64_t)v14;
    if (!v16) {
      goto LABEL_20;
    }
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  uint64_t v15 = *a3;
LABEL_20:
  if (!v15)
  {
    uint64_t v29 = (const void **)v24;
    unint64_t v17 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__emplace_unique_key_args<VolumeKey,std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>((uint64_t)VolumeMap, v24, (uint64_t)&std::piecewise_construct, (uint64_t *)&v29);
    uint64_t v18 = v27;
    uint64_t v19 = v28;
    if (v28) {
      atomic_fetch_add_explicit(&v28->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v20 = (std::__shared_weak_count *)v17[5];
    v17[4] = v18;
    v17[5] = v19;
    if (v20)
    {
      std::__shared_weak_count::__release_weak(v20);
      uint64_t v18 = v27;
      uint64_t v19 = v28;
    }
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v21 = (std::__shared_weak_count *)a3[1];
    *a3 = v18;
    a3[1] = (uint64_t)v19;
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)v24);
LABEL_30:
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf);
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
  return v7;
}

void sub_1D346049C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(a1);
}

void TNode::CreateCustomNode(TNode *this, FIDSNode *a2)
{
  uint64_t v2 = this;
  int v10 = 1;
  char v7 = 4;
  ClassName = object_getClassName(v2);
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,char const*,TCatalogInfo &,void>(&v7, &ClassName, (unsigned __int8 *)&v10, &v8);
  uint64_t v3 = [(TNode *)v2 asTNode];
  TNodePtr::TNodePtr(&v6, 0);
  ClassName = 0;
  uint64_t v5 = 0;
  TNode::TNode(v3, &v6, &v8, &ClassName);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }

  +[FINode trackNodeCreated:v2];
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

void sub_1D34605C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }

  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }

  _Unwind_Resume(a1);
}

void TFSVolumeInfo::TFSVolumeInfo(TFSVolumeInfo *this)
{
  *(unsigned char *)this = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 10) = &stru_1F2ABD380;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 11) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 12) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((unsigned char *)this + 192) = 0;
  *((void *)this + 23) = 0;
  *((unsigned char *)this + 216) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(void *)((char *)this + 133) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 44) = 0;
  TDSMutex::TDSMutex((TDSMutex *)((char *)this + 224), 0);
  *((unsigned char *)this + 288) = 0;
  *((unsigned char *)this + 296) = 0;
  *((unsigned char *)this + 304) = 0;
  *((_DWORD *)this + 78) = 0;
  *((void *)this + 47) = 0;
  *((unsigned char *)this + 384) = 0;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_WORD *)this + 184) = 0;
  *((void *)this + 49) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((unsigned char *)this + 400) = 0;
  *((unsigned char *)this + 408) = 0;
  *((void *)this + 52) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
}

void sub_1D3460730(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(unsigned char *)(v2 + 408)) {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v9);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v8);
  unint64_t v11 = *(std::__shared_weak_count **)(v2 + 360);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(v2 + 344);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  unint64_t v13 = *(std::__shared_weak_count **)(v2 + 328);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  if (*(unsigned char *)(v2 + 304)) {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v2 + 296));
  }
  TDSMutex::~TDSMutex(v7);
  if (*(unsigned char *)(v2 + 216)) {
    std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  unint64_t v14 = *(std::__shared_weak_count **)(v2 + 64);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v3);
  if (*(unsigned char *)(v2 + 32))
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
  }
  _Unwind_Resume(a1);
}

void sub_1D3460808()
{
}

void TNode::CreateNode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, TNodePtr *a4@<X8>)
{
  FIDSNodeSubclassForVirtualType(*(unsigned __int8 *)(*(void *)a2 + 112));
  int v10 = (objc_class *)objc_claimAutoreleasedReturnValue();
  id v8 = objc_alloc_init(v10);
  +[FINode trackNodeCreated:v8];
  uint64_t v9 = (TNode *)[v8 asTNode];
  TNode::TNode(v9, a1, a2, a3);
  if (*(unsigned char *)(*(void *)a2 + 112) == 27) {
    TNode::UpdateOnDiskProviderRoot(v9);
  }
  TNodePtr::TNodePtr(a4, v9);
}

void sub_1D3460910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::TNode(uint64_t a1, FINode **a2, os_unfair_lock_s **a3, uint64_t *a4)
{
  *(_WORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v7 = *a4;
  if (!*a4)
  {
    TNode::VolumeInfoFor(a2, a3, (uint64_t *)&v19);
    long long v10 = v19;
    long long v19 = 0uLL;
    unint64_t v11 = *(std::__shared_weak_count **)(a1 + 8);
    *(_OWORD *)a1 = v10;
    if (!v11) {
      goto LABEL_9;
    }
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)&v19 + 1);
    if (!*((void *)&v19 + 1)) {
      goto LABEL_9;
    }
LABEL_7:
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    goto LABEL_9;
  }
  uint64_t v8 = a4[1];
  if (!v8)
  {
    *(void *)a1 = v7;
    *(void *)(a1 + 8) = 0;
    goto LABEL_9;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 8);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v8;
  if (v9) {
    goto LABEL_7;
  }
LABEL_9:
  *(void *)(a1 + 48) = TNodeFromFINode(*a2);
  unint64_t v13 = *a3;
  uint64_t v12 = a3[1];
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)&v12[2], 1uLL, memory_order_relaxed);
  }
  unint64_t v14 = *(std::__shared_weak_count **)(a1 + 24);
  *(void *)(a1 + 16) = v13;
  *(void *)(a1 + 24) = v12;
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x100u);
  uint64_t v15 = *a3;
  uint64_t v16 = *a3 + 25;
  os_unfair_lock_lock(v16);
  LODWORD(v15) = *(os_unfair_lock_s *)((char *)v15 + 115);
  os_unfair_lock_unlock(v16);
  if ((v15 & 0x20) != 0) {
    operator new();
  }
  if (TNode::IsDeferredForSymlink(a1, (uint64_t (*)(void *))TFSInfo::IsApplication, 0)) {
    TDeviceManagementMonitor::RegisterApp((TNode *)a1, v17);
  }
  return a1;
}

void sub_1D3460AB0(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v1 + 72);
  *(void *)(v1 + 72) = 0;
  if (v4) {
    std::default_delete<TNotifierList>::operator()[abi:ne180100](v1 + 72, v4);
  }
  std::unique_ptr<TChildrenList>::reset[abi:ne180100](v2, 0);
  uint64_t v5 = *(void *)(v1 + 40);
  *(void *)(v1 + 40) = 0;
  if (v5) {
    MEMORY[0x1D9436740](v5, 0x1020C40A5B76CDFLL);
  }

  TNodePtr v6 = *(std::__shared_weak_count **)(v1 + 24);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(v1 + 8);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  _Unwind_Resume(a1);
}

uint64_t TNode::IsDeferredForSymlink(uint64_t a1, uint64_t (*a2)(void *), uint64_t a3)
{
  TNodePtr v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v6);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v6);
  uint64_t v9 = (os_unfair_lock_s *)(v8 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
  int v10 = *(_DWORD *)(v8 + 115);
  os_unfair_lock_unlock(v9);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  if ((v10 & 0x40) != 0)
  {
    TNode::GetAliasTarget((TNode *)a1, &v30);
    unint64_t v17 = (os_unfair_lock_s *)TNode::InfoLock(v16);
    os_unfair_lock_lock(v17);
    uint64_t v19 = *(void *)(a1 + 16);
    uint64_t v18 = *(std::__shared_weak_count **)(a1 + 24);
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v17);
    uint64_t v20 = (os_unfair_lock_s *)(v19 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 100));
    unint64_t v21 = *(unsigned int *)(v19 + 115) | ((unint64_t)*(unsigned __int16 *)(v19 + 119) << 32);
    os_unfair_lock_unlock(v20);
    if ((v21 & 0x200000000) != 0 || (uint64_t v22 = v30, !TNodeFromFINode(v30)))
    {
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v23 = TNodeFromFINode(v22);
      char v24 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v23);
      os_unfair_lock_lock(v24);
      uint64_t v26 = *(void *)(v23 + 16);
      CFTypeRef v25 = *(std::__shared_weak_count **)(v23 + 24);
      if (v25) {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v24);
      uint64_t v27 = (void *)(v26 + (a3 >> 1));
      if (a3) {
        a2 = *(uint64_t (**)(void *))(*v27 + a2);
      }
      uint64_t v28 = a2(v27);
      if (v25) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v25);
      }
    }
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
  }
  else
  {
    uint64_t v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
    os_unfair_lock_lock(v12);
    uint64_t v14 = *(void *)(a1 + 16);
    unint64_t v13 = *(std::__shared_weak_count **)(a1 + 24);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v12);
    uint64_t v15 = (void *)(v14 + (a3 >> 1));
    if (a3) {
      a2 = *(uint64_t (**)(void *))(*v15 + a2);
    }
    uint64_t v28 = a2(v15);
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
    }
  }
  return v28;
}

void sub_1D3460D2C(_Unwind_Exception *a1)
{
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }

  _Unwind_Resume(a1);
}

const void **TNode::VolumeInfoFor@<X0>(FINode **a1@<X0>, os_unfair_lock_s **a2@<X1>, uint64_t *a3@<X8>)
{
  TNodePtr v6 = *a2;
  uint64_t v7 = *a2 + 25;
  os_unfair_lock_lock(v7);
  int v8 = *(uint32_t *)((char *)&v6[28]._os_unfair_lock_opaque + 3);
  os_unfair_lock_unlock(v7);
  uint64_t v9 = *a2;
  int os_unfair_lock_opaque_low = LOBYTE((*a2)[28]._os_unfair_lock_opaque);
  if ((v8 & 0x100) == 0)
  {
    uint64_t v11 = TNodeFromFINode(*a1);
    if (os_unfair_lock_opaque_low)
    {
      if (v11)
      {
        uint64_t v12 = (TNode *)TNodeFromFINode(*a1);
        unsigned int v13 = TNode::VirtualType(v12);
      }
      else
      {
        unsigned int v13 = LOBYTE((*a2)[28]._os_unfair_lock_opaque);
      }
      uint64_t v14 = a3;
      goto LABEL_17;
    }
    if (v11)
    {
      uint64_t v15 = *a2;
      uint64_t v16 = *a2 + 25;
      os_unfair_lock_lock(v16);
      LODWORD(v15) = *(os_unfair_lock_s *)((char *)v15 + 115);
      os_unfair_lock_unlock(v16);
      if (((unsigned __int16)v15 & 0x8000) != 0)
      {
        CFTypeRef v25 = (TNode *)TNodeFromFINode(*a1);
        TNode::CFURL(v25, &v26);
      }
      else
      {
        unint64_t v17 = *a2;
        uint64_t v18 = *a2 + 25;
        os_unfair_lock_lock(v18);
        uint64_t v19 = *(TFSVolumeInfo **)&v17[4]._os_unfair_lock_opaque;
        uint64_t v26 = v19;
        if (v19) {
          CFRetain(v19);
        }
        os_unfair_lock_unlock(v18);
      }
      TFSVolumeInfo::GetVolumeInfoFor(v26, v20, a3);
    }
    else
    {
      TCFURLInfo::BootURL(&v26);
      TFSVolumeInfo::GetVolumeInfoFor(v26, v24, a3);
    }
    return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v26);
  }
  if (!LOBYTE((*a2)[28]._os_unfair_lock_opaque))
  {
    os_unfair_lock_lock(v9 + 25);
    unint64_t v21 = *(TFSVolumeInfo **)&v9[4]._os_unfair_lock_opaque;
    uint64_t v26 = v21;
    if (v21) {
      CFRetain(v21);
    }
    os_unfair_lock_unlock(v9 + 25);
    TFSVolumeInfo::GetVolumeInfoFor(v21, v22, a3);
    return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v26);
  }
  uint64_t v14 = a3;
  unsigned int v13 = LOBYTE((*a2)[28]._os_unfair_lock_opaque);
LABEL_17:
  return TFSVolumeInfo::GetVolumeInfoFor(v13, v14);
}

void sub_1D3460F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

TChildrenList *std::unique_ptr<TChildrenList>::reset[abi:ne180100](TChildrenList **a1, TChildrenList *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    TChildrenList::~TChildrenList(result);
    JUMPOUT(0x1D9436740);
  }
  return result;
}

unint64_t TFSInfo::IsApplication(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 2) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

void TChildrenList::TChildrenList(TChildrenList *this, const TNode *a2)
{
  TDSMutex::TDSMutex((TDSMutex *)this, 1);
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(void *)(v3 + 96) = a2;
  *(_OWORD *)(v3 + 104) = 0u;
  *(_OWORD *)(v3 + 120) = 0u;
  *(_OWORD *)(v3 + 136) = 0u;
  *(_OWORD *)(v3 + 152) = 0u;
  *(_OWORD *)(v3 + 168) = 0u;
  *(_OWORD *)(v3 + 184) = 0u;
  *(_WORD *)(v3 + 200) = 0;
}

void TDSMutex::TDSMutex(TDSMutex *this, int a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    pthread_mutexattr_init(&v3);
    pthread_mutexattr_settype(&v3, 2);
    pthread_mutex_init(&this->fMutex, &v3);
    pthread_mutexattr_destroy(&v3);
  }
  else
  {
    pthread_mutex_init(&this->fMutex, 0);
  }
}

id FIDSNodeSubclassForVirtualType(unsigned int a1)
{
  if (a1 <= 0x23 && ((0xFFFFF18FFuLL >> a1) & 1) != 0)
  {
    uint64_t v2 = objc_opt_class();
  }
  else
  {
    uint64_t v2 = 0;
  }
  return v2;
}

const void **TFSVolumeInfo::GetVolumeInfoFor@<X0>(unsigned int a1@<W0>, uint64_t *a2@<X8>)
{
  uint64_t v5 = 0;
  char v6 = 0;
  uint64_t v7 = 0;
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::operator=<__CFData const*,TRetainReleasePolicy<__CFData const*>>(&v5, &v7);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v7);
  char v6 = a1;
  TFSVolumeInfo::GetVolumeInfoForNoSync((id *)&v5, a2);
  uint64_t result = TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v5);
  if (!*a2) {
    return (const void **)TFSVolumeInfo::AddVirtualVolume(a1, a2);
  }
  return result;
}

void sub_1D34611B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(exception_object);
}

const void **TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::operator=<__CFData const*,TRetainReleasePolicy<__CFData const*>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

const void **TFSVolumeInfo::GetVolumeInfoFor@<X0>(TFSVolumeInfo *this@<X0>, const __CFURL *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  TCFURLInfo::GetVolumeID((TCFURLInfo *)this, a2, &v16);
  TFSVolumeInfo::VolumeInfoFor(&v16, a3);
  uint64_t result = TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v16);
  if (!*a3)
  {
    CFURLRef propertyValueTypeRefPtr = 0;
    CFURLCopyResourcePropertyForKey((CFURLRef)this, (CFStringRef)*MEMORY[0x1E4F1D980], &propertyValueTypeRefPtr, 0);
    if (!propertyValueTypeRefPtr) {
      return TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
    }
    CFURLRef v6 = CFURLCreateFileReferenceURL(0, propertyValueTypeRefPtr, 0);
    CFTypeRef cf = v6;
    if (v6)
    {
      uint64_t v7 = [(__CFURL *)v6 path];
      BOOL v8 = v7 == 0;

      if (v8)
      {
        uint64_t v10 = LogObj(7);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          uint64_t v11 = propertyValueTypeRefPtr;
          uint64_t v12 = (id)cf;
          unsigned int v13 = SanitizedURL(v11);
          *(_DWORD *)long long buf = 138543618;
          uint64_t v18 = v12;
          __int16 v19 = 2114;
          CFURLRef v20 = v13;
          _os_log_impl(&dword_1D343E000, v10, OS_LOG_TYPE_ERROR, "Can't get path of fileRefURL %{public}@ for volume %{public}@ using path url instead", buf, 0x16u);
        }
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = 0;
      }
      else
      {
        uint64_t v9 = (TCFURLInfo *)cf;
        if (cf)
        {
LABEL_13:
          TFSVolumeInfo::AddVolume(v9, 0, a3);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&cf);
          return TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
        }
      }
    }
    uint64_t v9 = propertyValueTypeRefPtr;
    goto LABEL_13;
  }
  return result;
}

void sub_1D34613D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v9 = va_arg(va1, const void *);
  CFURLRef v6 = v4;

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va1);
  BOOL v8 = *(std::__shared_weak_count **)(v2 + 8);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  _Unwind_Resume(a1);
}

CFTypeRef TCFURLInfo::GetVolumeID@<X0>(TCFURLInfo *this@<X0>, const __CFURL *a2@<X1>, void *a3@<X8>)
{
  CFTypeRef result = TCFURLInfo::GetVolumeIdentifier(this, a2);
  *a3 = result;
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

const void **TFSVolumeInfo::VolumeInfoFor@<X0>(const void **a1@<X0>, void *a2@<X8>)
{
  pthread_mutexattr_t v3 = *a1;
  uint64_t v7 = v3;
  if (v3) {
    CFRetain(v3);
  }
  TFSVolumeInfo::GetMapKey(&v7, 0, (uint64_t)&cf);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v7);
  CFTypeRef v5 = cf;
  if (cf) {
    CFRetain(cf);
  }
  char v6 = v9;
  TFSVolumeInfo::GetVolumeInfoForNoSync((id *)&v5, a2);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v5);
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf);
}

void sub_1D3461508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

CFTypeRef *TFSVolumeInfo::GetMapKey@<X0>(CFTypeRef *a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0;
  *(unsigned char *)(a3 + 8) = 0;
  CFTypeRef result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a3, *a1);
  *(unsigned char *)(a3 + 8) = a2;
  return result;
}

void sub_1D3461574(_Unwind_Exception *a1)
{
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__emplace_unique_key_args<VolumeKey,std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>(uint64_t a1, id *this, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = ROSPVolumeID::Hash(this);
  uint64_t v9 = *((unsigned __int8 *)this + 8);
  unint64_t v10 = v8 ^ v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v8 ^ v9;
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
    uint64_t v14 = *(void **)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      uint64_t v15 = (void *)*v14;
      if (*v14)
      {
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v10)
          {
            if (VolumeKey::operator==((uint64_t)(v15 + 2), (uint64_t)this)) {
              return v15;
            }
          }
          else
          {
            if (v13 > 1)
            {
              if (v16 >= v11) {
                v16 %= v11;
              }
            }
            else
            {
              v16 &= v11 - 1;
            }
            if (v16 != v4) {
              break;
            }
          }
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
    }
  }
  std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }
    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *uint64_t v23 = v26[0];
  }
  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }
      else
      {
        v24 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }
  uint64_t v15 = (void *)v26[0];
  v26[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100]((uint64_t)v26, 0);
  return v15;
}

void sub_1D34617FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::GetVolumeInfoForNoSync(id *a1@<X0>, void *a2@<X8>)
{
  uint64_t VolumeMap = (void *)GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  CFTypeRef v5 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::find<VolumeKey>(VolumeMap, a1);
  char v6 = v5;
  if (!v5) {
    goto LABEL_9;
  }
  *a2 = 0;
  a2[1] = 0;
  uint64_t v7 = (std::__shared_weak_count *)v5[5];
  if (!v7) {
    goto LABEL_9;
  }
  uint64_t v8 = std::__shared_weak_count::lock(v7);
  a2[1] = v8;
  if (!v8) {
    goto LABEL_9;
  }
  uint64_t v9 = v6[4];
  *a2 = v9;
  if (!v9)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
LABEL_9:
    os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
    *a2 = 0;
    a2[1] = 0;
    return;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
}

void sub_1D34618CC(_Unwind_Exception *a1)
{
}

void VolumeInfoLock(void)
{
  {
    VolumeInfoLock(void)::sVolumeInfoLocuint64_t k = 0;
  }
}

uint64_t GetVolumeMap(void)
{
  {
    operator new();
  }
  return GetVolumeMap(void)::map;
}

void sub_1D34619C4(_Unwind_Exception *a1)
{
}

void *std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::find<VolumeKey>(void *a1, id *this)
{
  uint64_t v4 = ROSPVolumeID::Hash(this);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4 ^ *((unsigned __int8 *)this + 8);
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v9 = v4 ^ *((unsigned __int8 *)this + 8);
    if (v6 >= *(void *)&v5) {
      uint64_t v9 = v6 % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v9 = (*(void *)&v5 - 1) & v6;
  }
  unint64_t v10 = *(void **)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  unint64_t v11 = (void *)*v10;
  if (*v10)
  {
    do
    {
      unint64_t v12 = v11[1];
      if (v12 == v6)
      {
        if (VolumeKey::operator==((uint64_t)(v11 + 2), (uint64_t)this)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v12 >= *(void *)&v5) {
            v12 %= *(void *)&v5;
          }
        }
        else
        {
          v12 &= *(void *)&v5 - 1;
        }
        if (v12 != v9) {
          return 0;
        }
      }
      unint64_t v11 = (void *)*v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t ROSPVolumeID::Hash(id *this)
{
  return [*this hash];
}

uint64_t VolumeKey::operator==(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)a1;
  unint64_t v5 = *(void *)a2;
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 | v5) {
      return 0;
    }
    return *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
  }
  uint64_t result = CFEqual((CFTypeRef)v4, (CFTypeRef)v5);
  if (result) {
    return *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
  }
  return result;
}

CFTypeRef std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x30uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  void *v8 = 0;
  v8[1] = a2;
  uint64_t v9 = *a3;
  CFTypeRef result = *(CFTypeRef *)v9;
  v8[2] = *(void *)v9;
  if (result) {
    CFTypeRef result = CFRetain(result);
  }
  *((unsigned char *)v8 + 24) = *(unsigned char *)(v9 + 8);
  v8[4] = 0;
  v8[5] = 0;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D3461BC0(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::pair<VolumeKey const,std::weak_ptr<TFSVolumeInfo>>::~pair((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
}

uint64_t TFSVolumeInfo::AddVirtualVolume(unsigned int a1, uint64_t *a2)
{
  _ZNSt3__115allocate_sharedB8ne180100I13TFSVolumeInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v18);
  TFSVolumeInfo::InitializeVirtualVolume(v18, a1);
  unint64_t v16 = 0;
  char v17 = 0;
  unint64_t v20 = 0;
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::operator=<__CFData const*,TRetainReleasePolicy<__CFData const*>>(&v16, (const void **)&v20);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v20);
  char v17 = a1;
  uint64_t VolumeMap = (void *)GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  unint64_t v5 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::find<VolumeKey>(VolumeMap, (id *)&v16);
  BOOL v6 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v7 = (std::__shared_weak_count *)v5[5];
  if (v7 && (uint64_t v7 = std::__shared_weak_count::lock(v7)) != 0) {
    uint64_t v8 = v5[4];
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (std::__shared_weak_count *)a2[1];
  *a2 = v8;
  a2[1] = (uint64_t)v7;
  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
LABEL_10:
    uint64_t v8 = *a2;
  }
  if (!v8)
  {
    unint64_t v20 = &v16;
    unint64_t v10 = std::__hash_table<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::__unordered_map_hasher<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,VolumeKeyHasher,std::equal_to<VolumeKey>,true>,std::__unordered_map_equal<VolumeKey,std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,std::equal_to<VolumeKey>,VolumeKeyHasher,true>,std::allocator<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>>>::__emplace_unique_key_args<VolumeKey,std::piecewise_construct_t const&,std::tuple<VolumeKey const&>,std::tuple<>>((uint64_t)VolumeMap, (id *)&v16, (uint64_t)&std::piecewise_construct, (uint64_t *)&v20);
    uint64_t v11 = v18;
    unint64_t v12 = v19;
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v13 = (std::__shared_weak_count *)v10[5];
    v10[4] = v11;
    void v10[5] = v12;
    if (v13)
    {
      std::__shared_weak_count::__release_weak(v13);
      uint64_t v11 = v18;
      unint64_t v12 = v19;
    }
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v14 = (std::__shared_weak_count *)a2[1];
    *a2 = v11;
    a2[1] = (uint64_t)v12;
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v16);
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
  return 0;
}

void sub_1D3461DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__115allocate_sharedB8ne180100I13TFSVolumeInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0x1C0uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceI13TFSVolumeInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_1D3461E1C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceI13TFSVolumeInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F2ABB160;
  TFSVolumeInfo::TFSVolumeInfo((TFSVolumeInfo *)(a1 + 24));
  return a1;
}

void sub_1D3461E78(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::InitializeVirtualVolume(uint64_t a1, unsigned int a2)
{
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  *(unsigned char *)(a1 + 48) = a2;
  if (a2 > 0x21) {
    goto LABEL_12;
  }
  if (((1 << a2) & 0x5800000) != 0)
  {
    TFSVolumeInfo::SetRootDirectoryForSidebarInfo(a1, a2);
    *(unsigned char *)(a1 + 132) = 1;
    goto LABEL_13;
  }
  if (((1 << a2) & 0x380000000) == 0)
  {
LABEL_12:
    TFSVolumeInfo::SetRootDirectoryForSidebarInfo(a1, a2);
    goto LABEL_13;
  }
  CFTypeRef SFBrowser = TFSInfo::CreateSFBrowser(a2);
  if (!SFBrowser) {
    abort();
  }
  uint64_t RootNode = SFBrowserGetRootNode();
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,__SFNode *&,void>((char *)(a1 + 48), &RootNode, &v7);
  long long v5 = v7;
  long long v7 = 0uLL;
  BOOL v6 = *(std::__shared_weak_count **)(a1 + 64);
  *(_OWORD *)(a1 + 56) = v5;
  if (v6)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    if (*((void *)&v7 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v7 + 1));
    }
  }
  TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef(&SFBrowser);
LABEL_13:
  TFSVolumeInfo::SetDeviceThreads((TFSVolumeInfo *)a1);
}

void sub_1D3461F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::SetRootDirectoryForSidebarInfo(uint64_t a1, unsigned __int8 a2)
{
  unsigned __int8 v6 = a2;
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,void>(&v6, &v5);
  long long v3 = v5;
  long long v5 = 0uLL;
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 64);
  *(_OWORD *)(a1 + 56) = v3;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    if (*((void *)&v5 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v5 + 1));
    }
  }
}

void *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,void>@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,std::allocator<TFSInfo>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1D3462058(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,std::allocator<TFSInfo>,0>(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2);
  return a1;
}

void sub_1D34620B8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::TFSInfo(uint64_t a1, int a2)
{
  VirtualContainerName(a2, (const void **)&v14.fString.fRef);
  if (a2 == 26) {
    int v4 = 67109121;
  }
  else {
    int v4 = 117440769;
  }
  LODWORD(v13.fString.fRef) = v4;
  TFSInfo::TFSInfo(a1, a2, &v14, (unsigned __int8 *)&v13);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14.fString.fRef);
  if ((a2 - 23) < 2u)
  {
    if (a2 == 23)
    {
      TString::TString(&v13, "");
      GetICloudContainerURL(&v13, (CFURLRef *)&v14);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::operator=<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>((const void **)(a1 + 16), (const void **)&v14.fString.fRef);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v14.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
    }
    if (ICloudDriveFPFSEnabled())
    {
      uint64_t v5 = iCloudDriveDomainIDForDataSeparated(a2 == 24);
      unsigned __int8 v6 = (void *)v5;
      if (a2 == 24 && v5)
      {
        long long v7 = +[FIProviderDomain providerDomainForID:v5 cachePolicy:1 error:0];
        uint64_t v8 = [v7 domain];
        uint64_t v9 = [v8 identifier];
        unint64_t v10 = v9;
        if (!v9)
        {
          unint64_t v10 = [v6 lastPathComponent];
        }
        uint64_t v11 = v10;
        v13.fString.fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v13, v11);

        GetICloudContainerURL(&v13, (CFURLRef *)&v14);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::operator=<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>((const void **)(a1 + 16), (const void **)&v14.fString.fRef);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v14.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
        if (!v9) {
      }
        }
    }
  }
  return a1;
}

void sub_1D3462290(_Unwind_Exception *a1)
{
  TFSInfo::~TFSInfo(v1);
  _Unwind_Resume(a1);
}

const void **VirtualContainerName@<X0>(int a1@<W0>, const void **a2@<X8>)
{
  *a2 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  switch(a1)
  {
    case 6:
      TString::TString((TString *)&cf, "Hits container");
      if (&cf != a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
        CFRetain(&stru_1F2ABD380);
        CFTypeRef v4 = cf;
        if (!cf) {
          goto LABEL_45;
        }
        goto LABEL_44;
      }
      return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 25:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
      goto LABEL_9;
    case 17:
      TString::TString((TString *)&cf, "Devices");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 18:
      TString::TString((TString *)&cf, "Places");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 19:
      TString::TString((TString *)&cf, "Searches");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 20:
      TString::TString((TString *)&cf, "Published Folders");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 21:
      TString::TString((TString *)&cf, "Sidebar Tags");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 22:
      TString::TString((TString *)&cf, "All Tags");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 23:
      TString::TString((TString *)&cf, "iCloud app libraries");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 24:
      TString::TString((TString *)&cf, "DataSeparated iCloud app libraries");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 26:
      TString::TString((TString *)&cf, "Cloud Storage");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 34:
      TString::TString((TString *)&cf, "Recent Documents");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    case 35:
      TString::TString((TString *)&cf, "iCloud Drive");
      if (&cf == a2) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v4 = cf;
      if (cf) {
        goto LABEL_44;
      }
      goto LABEL_45;
    default:
      if (a1 == 1)
      {
        TString::TString((TString *)&cf, "Computer");
        if (&cf == a2) {
          return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
        CFRetain(&stru_1F2ABD380);
        CFTypeRef v4 = cf;
        if (cf) {
LABEL_44:
        }
          CFRelease(v4);
      }
      else
      {
LABEL_9:
        TString::TString((TString *)&cf, "virtual");
        if (&cf == a2) {
          return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
        CFRetain(&stru_1F2ABD380);
        CFTypeRef v4 = cf;
        if (cf) {
          goto LABEL_44;
        }
      }
LABEL_45:
      CFTypeRef cf = &stru_1F2ABD380;
      return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
}

void sub_1D34627A0(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    CFTypeRef v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

void *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,char const*,TCatalogInfo &,void>@<X0>(char *a1@<X1>, const char **a2@<X2>, unsigned __int8 *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,char const*,TCatalogInfo &,std::allocator<TFSInfo>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1D34628C8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,char const*,TCatalogInfo &,std::allocator<TFSInfo>,0>(void *a1, char *a2, const char **a3, unsigned __int8 *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB358;
  std::construct_at[abi:ne180100]<TFSInfo,FSInfoVirtualType,char const*,TCatalogInfo &,TFSInfo*>((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_1D3462924(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<TFSInfo,FSInfoVirtualType,char const*,TCatalogInfo &,TFSInfo*>(uint64_t a1, char *a2, const char **a3, unsigned __int8 *a4)
{
  char v6 = *a2;
  TString::TString(&v8, *a3);
  TFSInfo::TFSInfo(a1, v6, &v8, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
  return a1;
}

void sub_1D346299C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::UpdateOnDiskProviderRoot(TNode *this)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (UseFileProviderFramework())
  {
    uint64_t v2 = (TNode *)TNode::VirtualType(this);
    if (v2 == 27)
    {
      long long v3 = (os_unfair_lock_s *)TNode::InfoLock(v2);
      os_unfair_lock_lock(v3);
      uint64_t v5 = *((void *)this + 2);
      CFTypeRef v4 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v3);
      char v6 = (os_unfair_lock_s *)(v5 + 96);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 96));
      uint64_t v7 = *(void *)(v5 + 80);
      if (v7
        && (os_unfair_lock_lock((os_unfair_lock_t)(v7 + 72)),
            int v8 = *(unsigned __int8 *)(v7 + 76),
            os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72)),
            v8 == 1))
      {
        id v9 = *(id *)(v7 + 24);
      }
      else
      {
        id v9 = 0;
      }
      os_unfair_lock_unlock(v6);
      if ([v9 isUsingFPFS])
      {
        unint64_t v10 = [v9 rootURL];
        if (v10)
        {
          int v11 = [v9 isiCloudDriveProvider];
          if (v11)
          {
            uint64_t v12 = [v10 URLByAppendingPathComponent:@"com~apple~CloudDocs"];

            unint64_t v10 = (void *)v12;
          }
          id v33 = 0;
          *(void *)long long buf = v10;
          TNode::GetNodeFromURL((CFURLRef *)buf, (TNodePtr *)&v33, 0);
          if (!TNodeFromFINode((FINode *)v33)
            || (uint64_t v13 = TNodeFromFINode((FINode *)v33),
                TString v14 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v13),
                os_unfair_lock_lock(v14),
                TNodePtr::TNodePtr((TNodePtr *)buf, *(const TNode **)(v13 + 48)),
                os_unfair_lock_unlock(v14),
                LOBYTE(v14) = TNodeFromFINode(*(FINode **)buf) == 0,
                *(id *)buf,
                (v14 & 1) != 0))
          {
            char v17 = LogObj(4);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138543362;
              *(void *)&uint8_t buf[4] = v9;
              _os_log_impl(&dword_1D343E000, v17, OS_LOG_TYPE_ERROR, "No root node found for domain %{public}@", buf, 0xCu);
            }
          }
          else
          {
            if (v11)
            {
              uint64_t v15 = (TNode *)TNodeFromFINode((FINode *)v33);
              TNode::GetParent(v15, (TNodePtr *)buf);
              unint64_t v16 = *(FINode **)buf;
            }
            else
            {
              unint64_t v16 = (FINode *)v33;
              *(void *)long long buf = v16;
            }
            uint64_t v18 = TNodeFromFINode(v16);
            BOOL v19 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v18);
            os_unfair_lock_lock(v19);
            unint64_t v21 = *(TFSInfo **)(v18 + 16);
            unint64_t v20 = *(std::__shared_weak_count **)(v18 + 24);
            if (v20) {
              atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            os_unfair_lock_unlock(v19);
            TFSInfo::UpdateFileProvider(v21, 0);
            if (v20) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v20);
            }
            uint64_t v22 = TNodeFromFINode(*(FINode **)buf);
            uint64_t v23 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v22);
            os_unfair_lock_lock(v23);
            uint64_t v25 = *(void *)(v22 + 16);
            unint64_t v24 = *(std::__shared_weak_count **)(v22 + 24);
            if (v24) {
              atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            os_unfair_lock_unlock(v23);
            uint64_t v26 = (os_unfair_lock_s *)(v25 + 96);
            os_unfair_lock_lock((os_unfair_lock_t)(v25 + 96));
            uint64_t v27 = *(void *)(v25 + 80);
            if (v27
              && (os_unfair_lock_lock((os_unfair_lock_t)(v27 + 72)),
                  int v28 = *(unsigned __int8 *)(v27 + 76),
                  os_unfair_lock_unlock((os_unfair_lock_t)(v27 + 72)),
                  v28 == 1))
            {
              id v29 = *(id *)(v27 + 24);
            }
            else
            {
              id v29 = 0;
            }
            os_unfair_lock_unlock(v26);
            if (v24) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v24);
            }
            if (v29)
            {
              uint64_t v30 = TNodeFromFINode((FINode *)v33);
              if (v30 != TNodeFromFINode(*(FINode **)buf))
              {
                unint64_t v31 = (TNode *)TNodeFromFINode((FINode *)v33);
                TNode::AttachCreateFPItemIfNeeded(v31, 1u);
              }
              long long v32 = (TNode *)TNodeFromFINode(*(FINode **)buf);
              TNode::AttachCreateFPItemIfNeeded(v32, 1u);
            }
          }
        }
      }

      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }
    }
  }
}

void sub_1D3462D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }

  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::InitializeFileSystemVolume()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  uint64_t v4 = v0;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!*v2)
  {
    TFSVolumeInfo::SetDeviceThreads((TFSVolumeInfo *)v0);
    return 4294967261;
  }
  uint64_t v5 = v2;
  CFURLRef v6 = v1;
  *(unsigned char *)(v0 + 48) = v3;
  _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v40);
  long long v7 = *(_OWORD *)&v40.f_bsize;
  *(void *)&v40.__int16 f_bsize = 0;
  v40.f_blocks = 0;
  int v8 = *(std::__shared_weak_count **)(v4 + 64);
  *(_OWORD *)(v4 + 56) = v7;
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    if (v40.f_blocks) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v40.f_blocks);
    }
  }
  CFIndex VolumeInfoRecord = TFSInfo::initialize(*(void *)(v4 + 56), v6, 0, 1, 1, 0, 0);
  if (VolumeInfoRecord)
  {
    TFSVolumeInfo::SetDeviceThreads((TFSVolumeInfo *)v4);
    return VolumeInfoRecord;
  }
  uint64_t v35 = 0;
  unint64_t v36 = 0;
  if (_CFURLGetVolumePropertyFlags())
  {
    unint64_t v11 = v36;
    *(unsigned char *)(v4 + 108) = (v36 & 2) != 0;
    *(unsigned char *)(v4 + 109) = (v11 & 0x40) != 0;
    *(unsigned char *)(v4 + 107) = v11 & 1;
    *(unsigned char *)(v4 + 111) = (v11 & 0x20000000000) == 0;
    *(unsigned char *)(v4 + 112) = (v11 & 0x80000000000) != 0;
    *(unsigned char *)(v4 + 113) = (v11 & 0x2000000000000) != 0;
    *(unsigned char *)(v4 + 114) = (v11 & 4) != 0;
    *(unsigned char *)(v4 + 115) = (v11 & 0x100000000000000) == 0;
    *(unsigned char *)(v4 + 116) = (v11 & 0x400000000000) != 0;
    *(unsigned char *)(v4 + 134) = (v11 & 0x2000000000000000) != 0;
    CFURLRef v12 = v6;
    BOOL v13 = statfs((const char *)[(__CFURL *)v12 fileSystemRepresentation], &v40) == 0;

    if (v13) {
      *(unsigned char *)(v4 + 135) = (v40.f_flags & 0x80) != 0;
    }
    CFIndex VolumeInfoRecord = 0;
    unint64_t v15 = v36;
    uint64_t v16 = (v36 >> 57) & 1;
    if (*(unsigned char *)(v4 + 108)) {
      LOBYTE(v16) = 0;
    }
    *(unsigned char *)(v4 + 126) = v16;
    *(unsigned char *)(v4 + 117) = (v15 & 0x80) != 0;
    *(unsigned char *)(v4 + 118) = (v15 & 0x800000000000) != 0;
    *(unsigned char *)(v4 + 104) = (v15 & 8) != 0;
    *(unsigned char *)(v4 + 110) = (v15 & 0x20000000000000) != 0;
    *(unsigned char *)(v4 + 119) = (v15 & 0x200) != 0;
  }
  else
  {
    CFIndex VolumeInfoRecord = TCFURLInfo::TranslateCFError(v35, v10);
  }
  *(unsigned char *)(v4 + 136) = TCFURLInfo::GetBooleanProperty(v6, (const __CFString *)*MEMORY[0x1E4F1D918], v14);
  *(unsigned char *)(v4 + 137) = TCFURLInfo::GetBooleanProperty(v6, (const __CFString *)*MEMORY[0x1E4F1D8C8], v17);
  if (!VolumeInfoRecord)
  {
    int v18 = TFSInfo::CopyPathToCBuffer(*(TFSInfo **)(v4 + 56), __source, 1024);
    if (v18 || statfs(__source, &v40)) {
      goto LABEL_46;
    }
    if ((v40.f_flags & 0x40000000) != 0) {
      *(unsigned char *)(v4 + 138) = 1;
    }
    *(void *)&__p.__int16 f_bsize = &v40;
    TFSVolumeInfo::InitializeFileSystemVolume(__CFURL const*,ROSPVolumeID,FSInfoVirtualType)::$_0::operator()((uint64_t *)&__p, v33);
    *(unsigned char *)(v4 + 127) = std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v33, "autofs");
    if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v33, "apfs"))
    {
      *(_DWORD *)(v4 + 72) = 20;
      std::string::basic_string[abi:ne180100]<0>(&v32, v40.f_mntfromname);
      ParseDeviceName(&v32, (std::string *)&__p);
      std::__optional_storage_base<std::pair<std::string,unsigned char>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::pair<std::string,unsigned char>,false>>(v4, (__n128 *)&__p);
      if (LOBYTE(__p.f_files) && SHIBYTE(__p.f_bfree) < 0) {
        operator delete(*(void **)&__p.f_bsize);
      }
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      if (*(unsigned char *)(v4 + 32))
      {
        *(void *)&__p.__int16 f_bsize = 0;
        __p.f_blocks = 0;
        uuid_clear((unsigned __int8 *)&__p);
        BOOL v19 = (const char *)v4;
        if (*(char *)(v4 + 23) < 0) {
          BOOL v19 = *(const char **)v4;
        }
        TString::operator=((TString *)(v4 + 80), v19);
      }
      else
      {
        unint64_t v21 = LogObj(5);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          TString::TString(__dst, v40.f_mntfromname);
          uint64_t v22 = SanitizedStr(__dst);
          __p.__int16 f_bsize = 138543362;
          *(void *)&__p.f_iosize = v22;
          _os_log_impl(&dword_1D343E000, v21, OS_LOG_TYPE_ERROR, "Couldn't find device for %{public}@", (uint8_t *)&__p, 0xCu);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&__dst[0].fString.fRef);
        }
      }
      goto LABEL_40;
    }
    if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v33, "exfat"))
    {
      int v20 = 21;
    }
    else if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v33, "msdos"))
    {
      int v20 = 8;
    }
    else
    {
      if (!std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v33, "smbfs")) {
        goto LABEL_40;
      }
      int v20 = 22;
    }
    *(_DWORD *)(v4 + 72) = v20;
LABEL_40:
    if (*(unsigned char *)(v4 + 119))
    {
      strlcpy((char *)__dst, __source, 0x400uLL);
      if (strlcat((char *)__dst, "/Backups.backupdb", 0x400uLL) <= 0x3FF && !statfs((const char *)__dst, &__p)) {
        *(unsigned char *)(v4 + 130) = 1;
      }
    }
    if (v34 < 0) {
      operator delete(v33[0]);
    }
LABEL_46:
    TFSVolumeInfo::CreateHiddenList((TFSVolumeInfo *)v4);
    *(void *)(v4 + 376) = TFSInfo::GetParentObjectIdentifier(*(TFSInfo **)(v4 + 56));
    uint64_t v23 = (const void **)(v4 + 40);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(v4 + 40), *v5);
    *(void *)&long long v24 = -1;
    *((void *)&v24 + 1) = -1;
    *(_OWORD *)(v4 + 144) = v24;
    *(_OWORD *)(v4 + 160) = v24;
    atomic_store(0, (unsigned int *)(v4 + 176));
    *(void *)(v4 + 184) = 0;
    *(_WORD *)(v4 + 123) = 256;
    *(unsigned char *)(v4 + 128) = 0;
    CFIndex VolumeInfoRecord = TCFURLInfo::GetVolumeInfoRecord(v6, &v40);
    if (VolumeInfoRecord)
    {
LABEL_67:
      if (!v18)
      {
        TFSInfo::VolumeUUID(*(TFSInfo **)(v4 + 56), (TString *)&__p);
        if ((statfs *)(v4 + 392) != &__p)
        {
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(v4 + 392), (const void **)&__p);
          CFRetain(&stru_1F2ABD380);
          if (*(void *)&__p.f_bsize) {
            CFRelease(*(CFTypeRef *)&__p.f_bsize);
          }
          *(void *)&__p.__int16 f_bsize = &stru_1F2ABD380;
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&__p);
      }
      goto LABEL_73;
    }
    __int16 f_bsize = v40.f_bsize;
    *(unsigned char *)(v4 + 129) = (v40.f_bsize & 0x800) != 0;
    if ((f_bsize & 0x800) != 0) {
      *(unsigned char *)(v4 + 126) = 0;
    }
    if (*(unsigned char *)(v4 + 107))
    {
      unsigned int v26 = *(_DWORD *)(v4 + 72);
      if (v26 <= 0x15 && ((1 << v26) & 0x240101) != 0)
      {
        *(unsigned char *)(v4 + 132) = 0;
        goto LABEL_58;
      }
      char v27 = 1;
    }
    else
    {
      if (TFSVolumeInfo::LoadPrefs(void)::once != -1) {
        dispatch_once(&TFSVolumeInfo::LoadPrefs(void)::once, &__block_literal_global_16);
      }
      char v27 = TFSVolumeInfo::gNoNetworkPropertyStores ^ 1;
    }
    *(unsigned char *)(v4 + 132) = v27;
LABEL_58:
    TFSVolumeInfo::SetMountPoint((TFSVolumeInfo *)v4);
    *(unsigned char *)(v4 + 133) = (v40.f_bsize & 0x4000) != 0;
    ROSPVolumeID::BootVolumeID(&__p);
    int v28 = *v23;
    BOOL v29 = (*(void *)&__p.f_bsize | (unint64_t)*v23) == 0;
    if (*(void *)&__p.f_bsize && v28) {
      BOOL v29 = CFEqual(*(CFTypeRef *)&__p.f_bsize, v28) != 0;
    }
    *(unsigned char *)(v4 + 121) = v29;
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&__p);
    if (*(unsigned char *)(v4 + 121)) {
      *(unsigned char *)(v4 + 120) = 1;
    }
    *(unsigned char *)(v4 + 122) = 0;
    *(unsigned char *)(v4 + 131) = 0;
    *(int64x2_t *)(v4 + 144) = vdupq_n_s64(0xFFFFFFFFFFFFFFFELL);
    *(void *)(v4 + 168) = -2;
    if (IsRunningInFinder()) {
      TFSVolumeInfo::RecalculateFreeSpaceAndCapacity((TFSVolumeInfo *)v4, 0);
    }
    if (*(unsigned char *)(v4 + 121)) {
      TFSVolumeInfo::SystemBuildVersion((TFSVolumeInfo *)v4);
    }
    goto LABEL_67;
  }
LABEL_73:
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v35);
  TFSVolumeInfo::SetDeviceThreads((TFSVolumeInfo *)v4);
  if (!VolumeInfoRecord)
  {
    if (!*(unsigned char *)(v4 + 120) && !*(unsigned char *)(v4 + 48))
    {
      ROSPVolumeID::BootVolumeID(&v31);
      TFSVolumeInfo::VolumeInfoFor(&v31, &v40);
      TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v31);
      *(unsigned char *)(v4 + 120) = TFSVolumeInfo::SamePhysicalDevice(*(TFSVolumeInfo **)&v40.f_bsize, (const TFSVolumeInfo *)v4);
      if (v40.f_blocks) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v40.f_blocks);
      }
    }
    return 0;
  }
  return VolumeInfoRecord;
}

void sub_1D34634C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, void *__p, uint64_t a8, int a9, __int16 a10, char a11, char a12, ...)
{
  va_start(va, a12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&STACK[0x8D0]);

  if (a12 < 0) {
    operator delete(__p);
  }
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(const void **a1, char *__s)
{
  int v4 = *((char *)a1 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (v5 != strlen(__s)) {
    return 0;
  }
  if (v4 >= 0) {
    CFURLRef v6 = a1;
  }
  else {
    CFURLRef v6 = *a1;
  }
  return memcmp(v6, __s, v5) == 0;
}

uint64_t IsRunningInFinder(void)
{
  return 0;
}

void *TFSVolumeInfo::InitializeFileSystemVolume(__CFURL const*,ROSPVolumeID,FSInfoVirtualType)::$_0::operator()@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  v6[2] = *MEMORY[0x1E4F143B8];
  v6[0] = 0;
  v6[1] = 0;
  int v4 = (char *)v6;
  if (_FSGetTypeInfoFromStatfs(*a1, (char *)v6, 0x10uLL, 0)) {
    int v4 = (char *)(*a1 + 72);
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v4);
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    CFURLRef v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    CFURLRef v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

__n128 std::__optional_storage_base<std::pair<std::string,unsigned char>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::pair<std::string,unsigned char>,false>>(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 32) == a2[2].n128_u8[0])
  {
    if (*(unsigned char *)(a1 + 32))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      __n128 result = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = result;
      a2[1].n128_u8[7] = 0;
      a2->n128_u8[0] = 0;
      *(unsigned char *)(a1 + 24) = a2[1].n128_u8[8];
    }
  }
  else if (*(unsigned char *)(a1 + 32))
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 32) = 0;
  }
  else
  {
    __n128 result = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    *(__n128 *)a1 = result;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    a2->n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = a2[1].n128_u8[8];
    *(unsigned char *)(a1 + 32) = 1;
  }
  return result;
}

uint64_t TFSInfo::GetParentObjectIdentifier(TFSInfo *this)
{
  _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v4);
  if (TFSInfo::GetParent((uint64_t)this, (uint64_t *)&v4) || !v4) {
    uint64_t ObjectIdentifier = 0;
  }
  else {
    uint64_t ObjectIdentifier = TFSInfo::GetObjectIdentifier(v4);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return ObjectIdentifier;
}

void sub_1D3463878(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TFSInfo::GetParent(uint64_t a1, uint64_t *a2)
{
  size_t v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  int v5 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x100) == 0)
  {
    os_unfair_lock_lock(v4);
    CFURLRef v6 = *(os_unfair_lock_s **)(a1 + 16);
    BOOL v13 = v6;
    if (v6)
    {
      CFRetain(v6);
      os_unfair_lock_unlock(v4);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v13);
      os_unfair_lock_lock(v4);
      int v7 = *(_DWORD *)(a1 + 115);
      os_unfair_lock_unlock(v4);
      if ((v7 & 0x100) == 0)
      {
        uint64_t v8 = TFSInfo::CopyParentPathURL((TFSInfo *)a1);
        BOOL v13 = v8;
        if (v8) {
          CFIndex v9 = TFSInfo::initialize(*a2, (const __CFURL *)v8, 1, 1, 1, 1, 0);
        }
        else {
          CFIndex v9 = 4294959224;
        }
        TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v13);
        return v9;
      }
      unint64_t v11 = (std::__shared_weak_count *)a2[1];
      *a2 = 0;
      a2[1] = 0;
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      }
    }
    else
    {
      os_unfair_lock_unlock(v4);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v13);
    }
    return 4294959224;
  }
  unint64_t v10 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  return 0;
}

void sub_1D34639BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::CopyPathToCBuffer(TFSInfo *this, char *a2, CFIndex a3)
{
  TFSInfo::GetPath(this, (uint64_t)&cf);
  uint64_t v5 = v11;
  if (!v11)
  {
    CFStringRef v6 = (const __CFString *)cf;
    if (cf)
    {
      CFTypeRef v7 = CFRetain(cf);
      CFStringRef v6 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v7);
      if (v6)
      {
        CFTypeRef v8 = CFAutorelease(v6);
        CFStringRef v6 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v8);
      }
    }
    if (CFStringGetCString(v6, a2, a3, 0x8000100u)) {
      uint64_t v5 = v11;
    }
    else {
      uint64_t v5 = 4294959236;
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  return v5;
}

void sub_1D3463A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **TFSInfo::VolumeUUID@<X0>(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  return TCFURLInfo::StringProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E4F1D988], a2);
}

TString *TString::operator=(TString *a1, const char *a2)
{
  TString::SetStringRefAsImmutable(a1, 0);
  if (a2)
  {
    CFIndex v4 = strlen(a2);
    TString::SetFromUTF8(a1, (const UInt8 *)a2, v4);
  }
  return a1;
}

const void **TFSVolumeInfo::SetMountPoint(TFSVolumeInfo *this)
{
  CFErrorRef error = 0;
  uint64_t v2 = (TFSInfo *)*((void *)this + 7);
  char v3 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v2)
  {
    CFURLRef CFURLRef = TFSInfo::CreateCFURLRef(v2);
    CFURLRef v7 = CFURLRef;
    if (CFURLRef)
    {
      CFURLRef propertyValueTypeRefPtr = 0;
      if (CFURLCopyResourcePropertyForKey(CFURLRef, (CFStringRef)*MEMORY[0x1E4F1CF48], &propertyValueTypeRefPtr, &error))
      {
        os_unfair_lock_lock((os_unfair_lock_t)this + 78);
        if (*((TString **)this + 11) != propertyValueTypeRefPtr) {
          TString::SetStringRefAsImmutable((TString *)this + 11, propertyValueTypeRefPtr);
        }
        if (*((unsigned char *)this + 408))
        {
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 50);
          *((unsigned char *)this + 408) = 0;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
      }
      TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
    }
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v7);
  }
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
}

void sub_1D3463BC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, const void *a12)
{
  os_unfair_lock_unlock(v13);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&a10);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a11);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&a12);
  _Unwind_Resume(a1);
}

CFURLRef TFSInfo::CreateCFURLRef(TFSInfo *this)
{
  CFURLRef v1 = (const __CFURL *)*((void *)this + 1);
  if (v1) {
    return CFURLCreateFileReferenceURL(0, v1, 0);
  }
  else {
    return 0;
  }
}

uint64_t TCFURLInfo::GetVolumeInfoRecord(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a1)
  {
    id v3 = a1;
    memset(&propertyValueTypeRefPtr, 0, 36);
    uint64_t v26 = 0;
    CFErrorRef error = (CFErrorRef)5;
    uint64_t v25 = 0x20000;
    if (getattrlist((const char *)[v3 fileSystemRepresentation], &error, &propertyValueTypeRefPtr, 0x24uLL, 0))
    {
      CFIndex v4 = __error();
      unsigned int v6 = TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v4, 0, v5);

      if (v6)
      {
        unsigned int v7 = *(_DWORD *)a2 & 0xFFF9FFFF;
LABEL_15:
        *(_DWORD *)a2 = v7;
LABEL_16:
        *(_DWORD *)a2 = v7 & 0xFFFFF6FF;
        unint64_t v23 = 0;
        CFErrorRef error = 0;
        if (!_CFURLGetVolumePropertyFlags())
        {
          CFIndex v8 = TCFURLInfo::TranslateCFError(error, v16);
LABEL_28:
          TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
          return v8;
        }
        *(_DWORD *)a2 = ((v23 >> 29) & 0x80 | *(_DWORD *)a2 & 0xFFFF9905 | (v23 >> 37) & 0x4000 | (v23 >> 34) & 0x200 | (v23 >> 35) & 8 | (v23 >> 57) & 0x10 | (v23 >> 44) & 0x20 | (v23 >> 37) & 0x400 | (v23 >> 43) & 0x2000 | (2 * (v23 & 1)) | (v23 >> 52) & 0x40) ^ 0x2000;
        *(void *)&propertyValueTypeRefPtr.__int16 f_bsize = 0;
        if (!CFURLCopyResourcePropertyForKey((CFURLRef)v3, (CFStringRef)*MEMORY[0x1E4F1D828], &propertyValueTypeRefPtr, &error)|| (CFNumberRef v18 = *(const __CFNumber **)&propertyValueTypeRefPtr.f_bsize) == 0)
        {
          CFIndex v8 = TCFURLInfo::TranslateCFError(error, v17);
          goto LABEL_27;
        }
        a2[1] = 4096;
        unint64_t valuePtr = 0;
        CFNumberGetValue(v18, kCFNumberSInt64Type, &valuePtr);
        unint64_t v19 = valuePtr;
        unint64_t v20 = a2[1];
        if (!__CFADD__(valuePtr, v20))
        {
          if (!v20)
          {
LABEL_25:
            CFIndex v8 = 0;
            a2[2] = v20;
LABEL_27:
            TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
            goto LABEL_28;
          }
          unint64_t v19 = valuePtr + v20 - 1;
        }
        v20 *= v19 / v20;
        goto LABEL_25;
      }
      unsigned int f_blocks = 0;
    }
    else
    {
      unsigned int f_blocks = propertyValueTypeRefPtr.f_blocks;
    }
    unsigned int v7 = *(_DWORD *)a2 & 0xFFFDFFFF | (((f_blocks >> 6) & 1) << 17);
    *(_DWORD *)a2 = v7;
    if ((f_blocks & 2) == 0) {
      goto LABEL_16;
    }
    id v10 = v3;
    unsigned int v11 = (const char *)[v10 fileSystemRepresentation];
    memset(&propertyValueTypeRefPtr, 0, 44);
    uint64_t v26 = 0;
    CFErrorRef error = (CFErrorRef)5;
    uint64_t v25 = 0x40000000;
    if (getattrlist(v11, &error, &propertyValueTypeRefPtr, 0x2CuLL, 0x21u))
    {
      CFURLRef v12 = __error();
      unsigned int v14 = TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v12, 0, v13);

      if (v14)
      {
        unsigned int v7 = *(_DWORD *)a2 & 0xFFFBFFFF;
        goto LABEL_15;
      }
      unsigned int f_bavail = 0;
    }
    else
    {
      unsigned int f_bavail = propertyValueTypeRefPtr.f_bavail;
    }
    unsigned int v7 = *(_DWORD *)a2 & 0xFFFBFFFF | (((f_bavail >> 28) & 1) << 18);
    goto LABEL_15;
  }
  return 4294959238;
}

void sub_1D3463FA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

void ParseDeviceName(std::string *this@<X0>, std::string *a2@<X8>)
{
  std::string::size_type v4 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v5 = (std::string *)this->__r_.__value_.__r.__words[0];
    std::string::size_type size = this->__r_.__value_.__l.__size_;
  }
  else
  {
    uint64_t v5 = this;
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
  }
  unsigned int v7 = (char *)&v5[-1].__r_.__value_.__r.__words[2] + 7;
  do
  {
    if (!size) {
      goto LABEL_13;
    }
    int v8 = v7[size--];
  }
  while (v8 != 47);
  if (size == -1)
  {
LABEL_13:
    std::string::size_type v10 = 0;
    goto LABEL_14;
  }
  std::string::size_type v9 = size + 1;
  if ((v4 & 0x80) != 0) {
    std::string::size_type v4 = this->__r_.__value_.__l.__size_;
  }
  if (v9 >= v4) {
    std::string::size_type v10 = 0;
  }
  else {
    std::string::size_type v10 = v9;
  }
LABEL_14:
  std::string::size_type v11 = std::string::find(this, 115, v10 + 3);
  if (v11 == -1) {
    goto LABEL_18;
  }
  std::string::size_type v12 = v11;
  std::string::basic_string(&__p, this, v11 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v15);
  unint64_t v13 = std::stoul(&__p, 0, 10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v13 > 0xFF)
  {
LABEL_18:
    a2->__r_.__value_.__s.__data_[0] = 0;
    a2[1].__r_.__value_.__s.__data_[8] = 0;
  }
  else
  {
    std::string::basic_string(&v15, this, v10, v12 - v10, (std::allocator<char> *)&__p);
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, v15.__r_.__value_.__l.__data_, v15.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v15;
    }
    *a2 = __p;
    a2[1].__r_.__value_.__s.__data_[0] = v13;
    a2[1].__r_.__value_.__s.__data_[8] = 1;
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1D346416C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  __cxa_begin_catch(a1);
  *uint64_t v22 = 0;
  v22[32] = 0;
  __cxa_end_catch();
  JUMPOUT(0x1D3464154);
}

BOOL TFSVolumeInfo::SamePhysicalDevice(TFSVolumeInfo *this, const TFSVolumeInfo *a2)
{
  uint64_t v3 = *((void *)this + 40);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 41);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *((void *)a2 + 40);
  std::string::size_type v4 = (std::__shared_weak_count *)*((void *)a2 + 41);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return v3 == v5;
}

void TNode::GetParent(TNode *this@<X0>, TNodePtr *a2@<X8>)
{
  std::string::size_type v4 = (os_unfair_lock_s *)TNode::ParentLock(this);
  os_unfair_lock_lock(v4);
  TNodePtr::TNodePtr(a2, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v4);
}

void sub_1D3464274(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::UpdateFileProvider(TFSInfo *this, FIProviderDomain *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a2;
  uint64_t v4 = TFSInfo::GetFPItem(this);
  if (v4)
  {
    uint64_t v5 = (void *)v4;
    id v22 = 0;
    unsigned int v6 = +[FIProviderDomain providerDomainForItem:v4 cachePolicy:0 error:&v22];
    id v7 = v22;
    if (v7)
    {
      int v8 = LogObj(4);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543618;
        long long v24 = v5;
        __int16 v25 = 2114;
        id v26 = v7;
        _os_log_impl(&dword_1D343E000, v8, OS_LOG_TYPE_ERROR, "Failed to get the domain from the FPItem. Falling back to URL: %{public}@, error: %{public}@", buf, 0x16u);
      }
    }
    if (v6)
    {
      std::string::size_type v9 = (os_unfair_lock_s *)((char *)this + 96);
      os_unfair_lock_lock((os_unfair_lock_t)this + 24);
      int v10 = 1;
      goto LABEL_20;
    }
  }
  else
  {
    id v7 = 0;
  }
  if (v3)
  {
    std::string::size_type v11 = v3;
    if (!v7) {
      goto LABEL_16;
    }
  }
  else
  {
    id v12 = *((id *)this + 2);
    id v21 = v7;
    uint64_t v13 = +[FIProviderDomain providerDomainForURL:v12 cachePolicy:1 error:&v21];
    id v14 = v21;

    std::string::size_type v11 = (FIProviderDomain *)v13;
    id v7 = v14;
    if (!v14) {
      goto LABEL_16;
    }
  }
  std::string v15 = LogObj(4);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    uint64_t v16 = (NSURL *)*((id *)this + 2);
    CFStringRef v17 = SanitizedURL(v16);
    *(_DWORD *)long long buf = 138543618;
    long long v24 = v17;
    __int16 v25 = 2114;
    id v26 = v7;
    _os_log_impl(&dword_1D343E000, v15, OS_LOG_TYPE_ERROR, "Failed to get the domain from the URL: %{public}@, error: %{public}@", buf, 0x16u);
  }
LABEL_16:
  std::string::size_type v9 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  if (v11)
  {
    int v10 = 1;
    unsigned int v6 = v11;
  }
  else
  {
    unsigned int v6 = 0;
    if (!*((void *)this + 10)) {
      goto LABEL_27;
    }
    int v10 = 0;
  }
LABEL_20:
  uint64_t Overflow = TFSInfo::GetOrCreateOverflow(this);
  os_unfair_lock_lock((os_unfair_lock_t)(Overflow + 72));
  if (v10)
  {
    int v19 = *(unsigned __int8 *)(Overflow + 76);
    if (v19 == 2)
    {
      TFSInfoOverflow::MigrateToType(Overflow, 1);
    }
    else if (v19 == 3)
    {
      *(unsigned char *)(Overflow + 76) = 1;
      *(void *)(Overflow + 32) = 0;
      *(_OWORD *)uint64_t Overflow = 0u;
      *(_OWORD *)(Overflow + 16) = 0u;
      *(_DWORD *)(Overflow + 32) = 0x80000000;
    }
  }
  int v20 = *(unsigned __int8 *)(Overflow + 76);
  os_unfair_lock_unlock((os_unfair_lock_t)(Overflow + 72));
  if (v20 == 1) {
    objc_storeStrong((id *)(Overflow + 24), v6);
  }
LABEL_27:
  os_unfair_lock_unlock(v9);
}

void sub_1D3464568(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3464664(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

unint64_t TFSInfo::IsPackage(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 1) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

const void **TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::operator=<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

const void **GetICloudContainerURL@<X0>(const TString *a1@<X0>, CFURLRef *a2@<X8>)
{
  TString::TString(&v9, "x-apple-finder:icloud", 0x15uLL);
  AppendPath(&v9, a1, (TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  if (cf && (v4 = CFRetain(cf), (uint64_t v5 = static_cf_cast<__CFString const*,void const*>(v4)) != 0))
  {
    CFTypeRef v6 = CFAutorelease(v5);
    CFStringRef v7 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v6);
  }
  else
  {
    CFStringRef v7 = 0;
  }
  *a2 = CFURLCreateWithString(0, v7, 0);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1D34647C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

const void **__destroy_helper_block_ea8_32c44_ZTSKZN12TBusyFolders14StartObservingEvE3__0(uint64_t a1)
{
  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(a1 + 40));
}

void TReferenceCounted::~TReferenceCounted(TReferenceCounted *this)
{
  CFURLRef v1 = (void *)((char *)this + 24);
  std::function<void ()(void *)>::operator()((uint64_t)this + 24, *((void *)this + 1));
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v1);
}

void *std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::function<void ()(void *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

TDSNotifier *std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, TDSNotifier **a2)
{
  __n128 result = *a2;
  if (*a2) {
    return (TDSNotifier *)TDSNotifier::RemovePtrReference(result);
  }
  return result;
}

void __copy_helper_block_ea8_32c62_ZTSKZ49__FINodeObserver_observerForFINode_withObserver__E3__2(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  objc_copyWeak((id *)(a1 + 40), (id *)(a2 + 40));
}

uint64_t __copy_helper_block_ea8_32c30_ZTSKZ16CloudDocsRootURLvE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

void sub_1D34649FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<OpaqueNodeRef *,TRetainReleasePolicy<OpaqueNodeRef *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

TNodeIterator *NodeIteratorFirst(TNodeIterator *this)
{
  CFURLRef v1 = this;
  if (this)
  {
    TNodeIterator::First(this, &v10);
    while (TNodeFromFINode(v10.fFINode))
    {
      uint64_t v2 = TNodeFromFINode(v10.fFINode);
      unint64_t v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
      os_unfair_lock_lock(v3);
      uint64_t v5 = *(void *)(v2 + 16);
      uint64_t v4 = *(std::__shared_weak_count **)(v2 + 24);
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v3);
      CFTypeRef v6 = (os_unfair_lock_s *)(v5 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
      unint64_t v7 = *(unsigned int *)(v5 + 115) | ((unint64_t)*(unsigned __int16 *)(v5 + 119) << 32);
      os_unfair_lock_unlock(v6);
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }
      if ((v7 & 0x100000000) == 0) {
        break;
      }
      TNodeIterator::Next(v1, &v9);
      TNodePtr::operator=((void **)&v10.fFINode, (void **)&v9.fFINode);
    }
    CFURLRef v1 = (TNodeIterator *)TNodePtr::CopyAsNodeRef(&v10);
  }
  return v1;
}

void sub_1D3464B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D3464B88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<OpaqueNodeRef *,TRetainReleasePolicy<OpaqueNodeRef *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

OpaqueNodeRef *NodeIteratorNext(TNodeIterator *a1)
{
  v11.fFINode = 0;
  if (a1)
  {
    TNodeIterator::Next(a1, &v10);
    TNodePtr::operator=((void **)&v11.fFINode, (void **)&v10.fFINode);

    while (TNodeFromFINode(v11.fFINode))
    {
      uint64_t v2 = TNodeFromFINode(v11.fFINode);
      unint64_t v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
      os_unfair_lock_lock(v3);
      uint64_t v5 = *(void *)(v2 + 16);
      uint64_t v4 = *(std::__shared_weak_count **)(v2 + 24);
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v3);
      CFTypeRef v6 = (os_unfair_lock_s *)(v5 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
      unint64_t v7 = *(unsigned int *)(v5 + 115) | ((unint64_t)*(unsigned __int16 *)(v5 + 119) << 32);
      os_unfair_lock_unlock(v6);
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }
      if ((v7 & 0x100000000) == 0) {
        break;
      }
      TNodeIterator::Next(a1, &v10);
      TNodePtr::operator=((void **)&v11.fFINode, (void **)&v10.fFINode);
    }
  }
  int v8 = TNodePtr::CopyAsNodeRef(&v11);

  return v8;
}

void sub_1D3464CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void TNodeIterator::Next(TNodeIterator *this@<X0>, TNodePtr *a2@<X8>)
{
  while (1)
  {
    uint64_t v4 = (id *)*((void *)this + 1);
    if (v4 == *((id **)this + 3)) {
      break;
    }
    uint64_t v5 = (FINode *)*v4;
    *((void *)this + 1) = v4 + 1;
    uint64_t v6 = TNodeFromFINode(v5);
    unint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v6);
    os_unfair_lock_lock(v7);
    uint64_t v9 = *(void *)(v6 + 16);
    int v8 = *(std::__shared_weak_count **)(v6 + 24);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v7);
    TNodePtr v10 = (os_unfair_lock_s *)(v9 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
    uint64_t v11 = *(unsigned __int16 *)(v9 + 119);
    uint64_t v12 = *(unsigned int *)(v9 + 115);
    os_unfair_lock_unlock(v10);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    if (((v12 | (v11 << 32)) & 0x100000000) == 0)
    {
      a2->fFINode = (FINode *)*v4;
      return;
    }
  }
  TNodePtr::TNodePtr(a2, 0);
}

void TNodeIterator::First(TNodeIterator *this@<X0>, TNodePtr *a2@<X8>)
{
  *((void *)this + 1) = *((void *)this + 2);
  TNodeIterator::Next(this, a2);
}

id __copy_helper_block_ea8_32c114_ZTSKZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsE3__0(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  a1[6] = *(id *)(a2 + 48);
  id result = *(id *)(a2 + 56);
  a1[7] = result;
  a1[8] = *(void *)(a2 + 64);
  return result;
}

uint64_t TFSInfo::SynchronizeProperties(TFSInfo *this, TFSInfo **a2, uint64_t a3)
{
  if (*((unsigned char *)this + 112) == 7) {
    goto LABEL_35;
  }
  TFSInfo::SynchronizeNames((uint64_t)this, a2, (uint64_t **)a3);
  TFSInfo::SynchronizeCatalog(this, a2, (uint64_t **)a3);
  TFSInfo::SynchronizeFPItemProperties(this, a2, (uint64_t **)a3);
  TFSInfo::SynchronizeFPProviderProperties((uint64_t)this, (uint64_t *)a2, (uint64_t **)a3);
  uint64_t v6 = TFSInfo::OriginatorInfo(this);

  if (v6)
  {
    unsigned int v36 = 1869769063;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>((uint64_t **)a3, &v36, &v36);
  }
  unint64_t v7 = TFSInfo::GetISIcon(this);

  if (!v7) {
    goto LABEL_33;
  }
  id v8 = TFSInfo::FetchISIcon(*a2);
  uint64_t v9 = TFSInfo::GetISIcon(this);
  TNodePtr v10 = TFSInfo::GetISIcon(*a2);
  id v11 = v9;
  id v12 = v10;
  if ([v11 isEqual:v12])
  {

    goto LABEL_11;
  }
  {
    ISIconsAreEqual(ISIcon *,ISIcon *)::disableWorkaround = PrefsBool(@"DISABLE_75276146_WORKAROUND", 0);
  }
  if (ISIconsAreEqual(ISIcon *,ISIcon *)::disableWorkaround) {
    goto LABEL_9;
  }
  {
    ISIconsAreEqual(ISIcon *,ISIcon *)::customIconClass = NSClassFromString(&cfstr_Iscustomicon.isa);
  }
  {
    ISIconsAreEqual(ISIcon *,ISIcon *)::hasBookmarkSelector = [(id)ISIconsAreEqual(ISIcon *,ISIcon *)::customIconClass instancesRespondToSelector:sel_bookmark];
  }
  if (!ISIconsAreEqual(ISIcon *,ISIcon *)::hasBookmarkSelector
    || (objc_opt_isKindOfClass() & 1) == 0
    || (objc_opt_isKindOfClass() & 1) == 0)
  {
LABEL_9:

LABEL_10:
    unsigned int v36 = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>((uint64_t **)a3, &v36, &v36);
    goto LABEL_11;
  }
  id v25 = v12;
  id v26 = [v11 bookmark];
  uint64_t v27 = [v25 bookmark];
  char v28 = [v26 isEqual:v27];

  if ((v28 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_11:
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t v13 = (TFSInfoOverflow *)*((void *)this + 10);
  if (v13)
  {
    id v14 = TFSInfoOverflow::GetIFSymbol(v13);
  }
  else
  {
    id v14 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  if (v14)
  {
    id v15 = TFSInfo::FetchIFSymbol(*a2);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    uint64_t v16 = (TFSInfoOverflow *)*((void *)this + 10);
    if (v16)
    {
      CFStringRef v17 = TFSInfoOverflow::GetIFSymbol(v16);
    }
    else
    {
      CFStringRef v17 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
    CFNumberRef v18 = *a2;
    int v19 = (os_unfair_lock_s *)((char *)*a2 + 96);
    os_unfair_lock_lock(v19);
    int v20 = (TFSInfoOverflow *)*((void *)v18 + 10);
    if (v20)
    {
      id v21 = TFSInfoOverflow::GetIFSymbol(v20);
    }
    else
    {
      id v21 = 0;
    }
    os_unfair_lock_unlock(v19);
    unint64_t v22 = v17;
    unint64_t v23 = v21;
    if (v22 | v23)
    {
      long long v24 = (void *)v23;
      if ((v22 == 0) != (v23 == 0))
      {
      }
      else
      {
        BOOL v29 = [(id)v22 name];
        uint64_t v30 = [v24 name];
        char v31 = [v29 isEqualToString:v30];

        if (v31) {
          goto LABEL_33;
        }
      }
      unsigned int v36 = 1768323437;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>((uint64_t **)a3, &v36, &v36);
      unsigned int v36 = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>((uint64_t **)a3, &v36, &v36);
    }
  }
LABEL_33:
  if (!*((unsigned char *)this + 112))
  {
    TFSInfo::SynchronizeLaunchServices((uint64_t)this, (os_unfair_lock_s **)a2, (uint64_t **)a3);
    TFSInfo::SynchronizePermissions((uint64_t)this, a2, (uint64_t **)a3);
    TFSInfo::SynchronizeKinds(this, a2, (uint64_t **)a3);
    TFSInfo::SynchronizeVersions((uint64_t)this, (uint64_t *)a2, (uint64_t **)a3);
    TFSInfo::SynchronizeTags(this, a2, (uint64_t **)a3);
  }
LABEL_35:
  if (*(void *)(a3 + 16)) {
    return 1;
  }
  id v33 = TFSInfo::GetFPItem(this);
  char v34 = TFSInfo::GetFPItem(*a2);
  uint64_t v32 = IsEqual(v33, v34) ^ 1;

  return v32;
}

void sub_1D3465320(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id TFSInfo::GetISIcon(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  id v3 = *((id *)this + 7);
  os_unfair_lock_unlock(v2);
  return v3;
}

id TFSInfo::OriginatorInfo(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v3 + 72));
    int v4 = *(unsigned __int8 *)(v3 + 76);
    os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 72));
    if (v4 == 2)
    {
LABEL_5:
      id v7 = *(id *)v3;
      goto LABEL_7;
    }
    uint64_t v5 = *((void *)this + 10);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72));
    int v6 = *(unsigned __int8 *)(v5 + 76);
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72));
    if (v6 == 1)
    {
      uint64_t v3 = v5 + 16;
      goto LABEL_5;
    }
  }
  id v7 = 0;
LABEL_7:
  os_unfair_lock_unlock(v2);
  return v7;
}

void TFSInfo::SynchronizeFPProviderProperties(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  int v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t v7 = *(void *)(a1 + 80);
  if (v7
    && (os_unfair_lock_lock((os_unfair_lock_t)(v7 + 72)),
        int v8 = *(unsigned __int8 *)(v7 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72)),
        v8 == 1))
  {
    unint64_t v17 = (unint64_t)*(id *)(v7 + 24);
  }
  else
  {
    unint64_t v17 = 0;
  }
  os_unfair_lock_unlock(v6);
  uint64_t v9 = *a2;
  TNodePtr v10 = (os_unfair_lock_s *)(v9 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 96));
  uint64_t v11 = *(void *)(v9 + 80);
  if (v11
    && (os_unfair_lock_lock((os_unfair_lock_t)(v11 + 72)),
        int v12 = *(unsigned __int8 *)(v11 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 72)),
        v12 == 1))
  {
    unint64_t v13 = (unint64_t)*(id *)(v11 + 24);
  }
  else
  {
    unint64_t v13 = 0;
  }
  os_unfair_lock_unlock(v10);
  id v14 = (id)v17;
  if (v17 | v13)
  {
    id v15 = [(id)v17 domain];
    uint64_t v16 = [(id)v13 domain];
    TFSInfo::ChangesForFPDomain(v15, v16, a3);

    id v14 = (id)v17;
  }
  id v18 = v14;
}

void sub_1D3465648(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void TFSInfo::ChangesForFPDomain(void *a1, void *a2, uint64_t **a3)
{
  uint64_t v5 = a1;
  int v6 = a2;
  int v7 = [(TFSInfo *)v5 isEnabled];
  if (v7 == [(TFSInfo *)v6 isEnabled])
  {
    int v8 = [(TFSInfo *)v5 isHidden];
    if (v8 == [(TFSInfo *)v6 isHidden])
    {
      int v9 = [(TFSInfo *)v5 needsAuthentication];
      if (v9 == [(TFSInfo *)v6 needsAuthentication])
      {
        BOOL IsDisconnectedDomain = TFSInfo::IsDisconnectedDomain(v5, v10);
        if (IsDisconnectedDomain != TFSInfo::IsDisconnectedDomain(v6, v12))
        {
          LODWORD(v18.fString.fRef) = 1987273324;
          std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
          LODWORD(v18.fString.fRef) = 1886549619;
          std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
          LODWORD(v18.fString.fRef) = 1853121395;
          std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
        }
      }
      else
      {
        LODWORD(v18.fString.fRef) = 1987273324;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
        LODWORD(v18.fString.fRef) = 1718641013;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
      }
    }
    else
    {
      LODWORD(v18.fString.fRef) = 1987273324;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
    }
  }
  else
  {
    LODWORD(v18.fString.fRef) = 1987273324;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
    LODWORD(v18.fString.fRef) = 1883665005;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
  }
  unint64_t v13 = [(TFSInfo *)v5 identifier];
  id v14 = [(TFSInfo *)v6 identifier];
  char v15 = [v13 isEqualToString:v14];

  if ((v15 & 1) == 0)
  {
    LODWORD(v18.fString.fRef) = 1868720740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
  }
  if (v5 != v6)
  {
    uint64_t v16 = [(TFSInfo *)v6 identifier];
    v18.fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v18, v16);

    BOOL v17 = IsLocalStorageDomainID(&v18);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);

    if (!v17)
    {
      LODWORD(v18.fString.fRef) = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v18, &v18);
    }
  }
}

void sub_1D34658FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsDisconnectedDomain(TFSInfo *this, FPProviderDomain *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = v2;
  if (v2) {
    BOOL v4 = [(TFSInfo *)v2 disconnectionState] != 1;
  }
  else {
    BOOL v4 = 0;
  }

  return v4;
}

void sub_1D34659CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **TFSInfo::CheckiCloudFlags(uint64_t a1, TFSInfo **a2, uint64_t **a3)
{
  int BladeRunnerFlags = TFSInfo::GetBladeRunnerFlags((TFSInfo *)a1);
  id result = (uint64_t **)TFSInfo::GetBladeRunnerFlags(*a2);
  if (BladeRunnerFlags != result)
  {
    int v8 = TFSInfo::GetBladeRunnerFlags((TFSInfo *)a1);
    if ((TFSInfo::GetBladeRunnerFlags(*a2) ^ v8))
    {
      unsigned int v14 = 1685548132;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v14, &v14);
      int v9 = (os_unfair_lock_s *)(a1 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
      int v11 = *(_DWORD *)(a1 + 115);
      uint64_t v10 = a1 + 115;
      __int16 v12 = *(_WORD *)(v10 + 4);
      *(_DWORD *)uint64_t v10 = v11 & 0xEFFFFFFF;
      *(_WORD *)(v10 + 4) = v12;
      os_unfair_lock_unlock(v9);
    }
    unsigned int v13 = 1969385844;
    return std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v13, &v13);
  }
  return result;
}

uint64_t TFSInfo::GetBladeRunnerFlags(TFSInfo *this)
{
  if (*((unsigned char *)this + 112))
  {
    uint64_t v2 = TFSInfo::GetFPItem(this);

    if (!v2) {
      return 0;
    }
  }
  uint64_t v3 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t v4 = *((void *)this + 10);
  if (v4
    && (os_unfair_lock_lock((os_unfair_lock_t)(v4 + 72)),
        int v5 = *(unsigned __int8 *)(v4 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 72)),
        v5 == 1))
  {
    uint64_t v6 = *(unsigned int *)(v4 + 32);
  }
  else
  {
    uint64_t v6 = 0x80000000;
  }
  os_unfair_lock_unlock(v3);
  return v6;
}

void TFSInfo::SynchronizeFPItemProperties(TFSInfo *a1, TFSInfo **a2, uint64_t **a3)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  TFSInfo::GetFPItem(a1);
  uint64_t v6 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
  uint64_t v7 = TFSInfo::GetFPItem(*a2);
  int v8 = (FPItem *)v7;
  if (v6 && !v7)
  {
    int v9 = *a2;
    uint64_t v10 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v10);
    int v11 = (const void *)*((void *)v9 + 2);
    *(void *)long long buf = v11;
    if (v11)
    {
      CFRetain(v11);
      __int16 v12 = *(void **)buf;
    }
    else
    {
      __int16 v12 = 0;
    }
    os_unfair_lock_unlock(v10);
    unsigned int v13 = v12;
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)buf);
    unsigned int v14 = FPItemManagerInstance();
    id v78 = 0;
    int v8 = [v14 itemForURL:v13 error:&v78];
    id v15 = v78;

    if (v15)
    {
      uint64_t v16 = LogObj(4);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        BOOL v17 = SanitizedURL(v13);
        *(_DWORD *)long long buf = 138543618;
        *(void *)&uint8_t buf[4] = v15;
        __int16 v82 = 2114;
        *(void *)v83 = v17;
        _os_log_impl(&dword_1D343E000, v16, OS_LOG_TYPE_ERROR, "itemForURL error: %{public}@ for %{public}@", buf, 0x16u);
      }
    }
    TFSInfo::SetFPItem(*a2, v8);
  }
  TString v18 = [(FPItem *)v8 providerDomainID];
  *(void *)long long buf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)buf, v18);

  BOOL v76 = IsLocalStorageDomainID((const TString *)buf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);

  if (!v8)
  {
    if (!v6) {
      goto LABEL_77;
    }
LABEL_16:
    *(_DWORD *)long long buf = 1868720740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    long long v24 = *a2;
    id v25 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v25);
    LODWORD(v24) = *(_DWORD *)((char *)v24 + 115);
    os_unfair_lock_unlock(v25);
    if ((v24 & 0x20) != 0)
    {
      *(_DWORD *)long long buf = 1667785588;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    goto LABEL_18;
  }
  TFSInfo::FetchBladeRunnerProperties(*a2, v19, v20);
  if (!v6)
  {
    Class v47 = [(FPItem *)v8 itemDecorations];
    BOOL v48 = [v47 count] == 0;

    if (!v48)
    {
      *(_DWORD *)long long buf = 1684366194;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      *(_DWORD *)long long buf = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    *(_DWORD *)long long buf = 1868720740;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    TNodePtr v49 = *a2;
    uint64_t v50 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v50);
    LODWORD(v49) = *(_DWORD *)((char *)v49 + 115);
    os_unfair_lock_unlock(v50);
    if ((v49 & 0x20) != 0)
    {
      *(_DWORD *)long long buf = 1667785588;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    if (!v76)
    {
      TFSInfo::CheckiCloudFlags((uint64_t)a1, a2, a3);
      if (TFSInfo::IsTopLevelSharedItem(*a2))
      {
        *(_DWORD *)long long buf = 1936225392;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      }
      int IsAppLibrary = TFSInfo::IsAppLibrary(a1);
      if (IsAppLibrary != TFSInfo::IsAppLibrary(*a2))
      {
        *(_DWORD *)long long buf = 1768124270;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      }
      *(_DWORD *)long long buf = 1819501924;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      *(_DWORD *)long long buf = 1769171056;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      *(_DWORD *)long long buf = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    goto LABEL_77;
  }
  id v21 = [(TFSInfo *)v6 itemIdentifier];
  unint64_t v22 = [(FPItem *)v8 itemIdentifier];
  BOOL v23 = [v21 compare:v22] == 0;

  if (!v23) {
    goto LABEL_16;
  }
LABEL_18:
  if (!TFSInfo::IsFPv2(a1, 1))
  {
    id v26 = [(TFSInfo *)v6 fileURL];
    uint64_t v27 = [(FPItem *)v8 fileURL];
    char v28 = IsEqual(v26, v27);

    if ((v28 & 1) == 0)
    {
      *(_DWORD *)long long buf = 1868720740;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      BOOL v29 = *a2;
      uint64_t v30 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v30);
      LODWORD(v29) = *(_DWORD *)((char *)v29 + 115);
      os_unfair_lock_unlock(v30);
      if ((v29 & 0x20) != 0)
      {
        *(_DWORD *)long long buf = 1667785588;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
      }
    }
  }
  int v31 = [(TFSInfo *)v6 isPending];
  if (v31 != [(FPItem *)v8 isPending])
  {
    *(_DWORD *)long long buf = 1886549619;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
  }
  uint64_t v32 = *a2;
  id v33 = (os_unfair_lock_s *)((char *)*a2 + 100);
  os_unfair_lock_lock(v33);
  LODWORD(v32) = *(_DWORD *)((char *)v32 + 115);
  os_unfair_lock_unlock(v33);
  if ((v32 & 0x20) != 0)
  {
    char v34 = [(TFSInfo *)v6 childItemCount];
    uint64_t v35 = [(FPItem *)v8 childItemCount];
    char v36 = IsEqual(v34, v35);

    if ((v36 & 1) == 0)
    {
      *(_DWORD *)long long buf = 1667785588;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
  }
  char v37 = [(TFSInfo *)v6 itemDecorations];
  uint64_t v38 = [(FPItem *)v8 itemDecorations];
  char v39 = IsEqual(v37, v38);

  if ((v39 & 1) == 0)
  {
    *(_DWORD *)long long buf = 1684366194;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    *(_DWORD *)long long buf = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    FP_ItemDecorationTypeSharing();
    uint64_t v41 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    v77.fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v77, v41);

    unint64_t v75 = [(FPItem *)v8 itemDecorations];
    IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::NSForwardIterator<NSArray<FPItemDecoration *>>::NSForwardIterator((uint64_t)buf, v75);
    IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::IDContainerIteratorAdaptor((uint64_t)v79, -1, v75);
    while (*(id *)buf != v79[0] || v89 != v80)
    {
      id v42 = *(id *)(*(void *)&v83[2] + 8 * v88);
      std::vector<int> v43 = [v42 type];
      int v44 = operator==((void **)&v77.fString.fRef, v43);

      if (v44)
      {

LABEL_58:
        *(_DWORD *)long long buf = 1819501924;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
        *(_DWORD *)long long buf = 1769171056;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
        goto LABEL_59;
      }
      uint64_t v45 = v88;
      if (v88 >= v87 - 1)
      {
        uint64_t v46 = [*(id *)buf countByEnumeratingWithState:&buf[8] objects:v85 count:4];
        uint64_t v45 = -1;
        uint64_t v87 = v46;
        uint64_t v88 = -1;
      }
      if (v86 != *v84)
      {
        objc_enumerationMutation(*(id *)buf);
        uint64_t v45 = v88;
      }
      uint64_t v88 = v45 + 1;
      ++v89;
    }

    BOOL v74 = [(TFSInfo *)v6 itemDecorations];
    IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::NSForwardIterator<NSArray<FPItemDecoration *>>::NSForwardIterator((uint64_t)buf, v74);
    IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::IDContainerIteratorAdaptor((uint64_t)v79, -1, v74);
    while (*(id *)buf != v79[0] || v89 != v80)
    {
      id v52 = *(id *)(*(void *)&v83[2] + 8 * v88);
      long long v53 = [v52 type];
      int v54 = operator==((void **)&v77.fString.fRef, v53);

      if (v54)
      {

        goto LABEL_58;
      }
      uint64_t v55 = v88;
      if (v88 >= v87 - 1)
      {
        uint64_t v56 = objc_msgSend(*(id *)buf, "countByEnumeratingWithState:objects:count:", &buf[8], v85, 4, v74, v75);
        uint64_t v55 = -1;
        uint64_t v87 = v56;
        uint64_t v88 = -1;
      }
      if (v86 != *v84)
      {
        objc_enumerationMutation(*(id *)buf);
        uint64_t v55 = v88;
      }
      uint64_t v88 = v55 + 1;
      ++v89;
    }

LABEL_59:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v77.fString.fRef);
  }
  int v57 = TFSInfo::FPItemPermissionRestrictions(v6, v40);
  int v59 = TFSInfo::FPItemPermissionRestrictions((TFSInfo *)v8, v58);
  if (v57 != v59)
  {
    *(_DWORD *)long long buf = 1886549619;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    if (((v59 ^ v57) & 0x98801) != 0)
    {
      *(_DWORD *)long long buf = 1970495843;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
  }
  if (!v76)
  {
    TFSInfo::CheckiCloudFlags((uint64_t)a1, a2, a3);
    id v60 = [(TFSInfo *)v6 downloadingError];
    uint64_t v61 = [(FPItem *)v8 downloadingError];
    char v62 = NSObjectsAreEqual(v60, v61);

    if ((v62 & 1) == 0)
    {
      *(_DWORD *)long long buf = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    uint64_t v63 = [(TFSInfo *)v6 uploadingError];
    int v64 = [(FPItem *)v8 uploadingError];
    char v65 = NSObjectsAreEqual(v63, v64);

    if ((v65 & 1) == 0)
    {
      *(_DWORD *)long long buf = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    int v66 = [(TFSInfo *)v6 isItemPinned];
    if (v66 != [(FPItem *)v8 isItemPinned]
      || (int v67 = [(TFSInfo *)v6 isPinnedSubitem],
          v67 != [(FPItem *)v8 isPinnedSubitem]))
    {
      *(_DWORD *)long long buf = 1969385844;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    int IsTopLevelSharedItem = TFSInfo::IsTopLevelSharedItem(a1);
    if (IsTopLevelSharedItem != TFSInfo::IsTopLevelSharedItem(*a2))
    {
      *(_DWORD *)long long buf = 1936225392;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    TFSInfo::CopyICloudSharePerson(a1);
    unsigned int v69 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
    TFSInfo::CopyICloudSharePerson(*a2);
    uint64_t v70 = (NSPersonNameComponents *)objc_claimAutoreleasedReturnValue();
    char v72 = TFSInfo::PersonEqual(v69, v70, v71);

    if ((v72 & 1) == 0)
    {
      *(_DWORD *)long long buf = 1769171056;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
    int v73 = TFSInfo::IsAppLibrary(a1);
    if (v73 != TFSInfo::IsAppLibrary(*a2))
    {
      *(_DWORD *)long long buf = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)buf, buf);
    }
  }
LABEL_77:
}

void sub_1D3466680(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<Property>::__emplace_unique_key_args<Property,Property>(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        int v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      int v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  int v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  id result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), int v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            unsigned int v9 = (uint64_t **)a2[2];
          }
          else
          {
            unsigned int v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *unsigned int v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), int v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t TFSInfo::IsAppLibrary(TFSInfo *this)
{
  if (!UseFileProviderFramework()) {
    return 0;
  }
  uint64_t v2 = TFSInfo::GetFPItem(this);
  uint64_t v3 = [v2 isContainer];

  return v3;
}

void sub_1D3466C04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::ComputeBladeRunnerFlags(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)&v39[7] = 0;
  id v40 = 0;
  uint64_t v41 = 0;
  *(void *)char v39 = 0;
  if ((TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E4F1CDC8], a3) & 0x40000000) != 0)v39[0] = 1; {
  uint64_t v4 = TFSInfo::GetFPItem(this);
  }
  char v37 = v4;
  int v5 = UseFileProviderFramework();
  if (v4) {
    int v6 = v5;
  }
  else {
    int v6 = 0;
  }
  if (v6 == 1)
  {
    uint64_t v7 = [v4 providerDomainID];
    *(void *)id v60 = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)v60, v7);

    BOOL v8 = IsLocalStorageDomainID((const TString *)v60);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v60);

    if (v8)
    {
      id v33 = 0;
      unsigned int v34 = 0;
      goto LABEL_36;
    }
    ComputeBRFlagsFromFPItem((FPItem *)v4, (uint64_t)v60);
    unsigned int v9 = v61;
    *(void *)char v39 = *(void *)v60;
    *(_DWORD *)&v39[7] = *(_DWORD *)&v60[7];
    uint64_t v10 = v62;
    uint64_t v61 = 0;
    char v62 = 0;
    id v33 = v10;
    id v40 = v9;
    uint64_t v41 = v10;
  }
  else
  {
    id v33 = 0;
  }
  unsigned int v34 = BRFlagsFromState(v39);
  if ((v34 & 0x2000) != 0
    && v4
    && [v4 isCloudItem]
    && ICloudDriveFPFSEnabled())
  {
    uint64_t v11 = LogObj(4);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      TFSInfo::Name(this, (TString *)&v38);
      id v31 = v38;
      TFSInfo::GetFPItem(this);
      id v32 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v30 = [NSNumber numberWithUnsignedInt:v34];
      uint64_t v12 = TFSInfo::GetFPItem(this);
      id v51 = &stru_1F2ABD380;
      uint64_t v35 = v12;
      CFRetain(&stru_1F2ABD380);
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      uint64_t v13 = [v12 itemDecorations];
      uint64_t v14 = [v13 countByEnumeratingWithState:&v47 objects:v60 count:16];
      if (v14)
      {
        uint64_t v15 = *(void *)v48;
        CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        id obj = v13;
        do
        {
          for (uint64_t i = 0; i != v14; ++i)
          {
            if (*(void *)v48 != v15) {
              objc_enumerationMutation(obj);
            }
            TString v18 = *(void **)(*((void *)&v47 + 1) + 8 * i);
            if ([v18 requiresFetchingInfoFirst])
            {
              TString::TString(&v44, "\t", 1uLL);
              TString::TString(&v43, "{requiresFetchingInfoFirst} ", 0x1CuLL);
              fRef = v44.fString.fRef;
              CFTypeRef cf = &stru_1F2ABD380;
              CFRetain(&stru_1F2ABD380);
              MutableCFStringRef Copy = CFStringCreateMutableCopy(v16, 0, fRef);
              if (cf) {
                CFRelease(cf);
              }
              CFTypeRef cf = MutableCopy;
              TString::Append((TString *)&cf, &v43);
              uint64_t v4 = v37;
              id v21 = [v18 description];
              v42.fString.fRef = &stru_1F2ABD380;
              CFRetain(&stru_1F2ABD380);
              TString::SetStringRefAsImmutable(&v42, v21);

              CFStringRef v22 = (const __CFString *)cf;
              CFTypeRef v46 = &stru_1F2ABD380;
              CFRetain(&stru_1F2ABD380);
              CFMutableStringRef v23 = CFStringCreateMutableCopy(v16, 0, v22);
              if (v46) {
                CFRelease(v46);
              }
              CFTypeRef v46 = v23;
              TString::Append((TString *)&v46, &v42);
              TString::Append((TString *)&v51, (const TString *)&v46);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v46);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v42.fString.fRef);

              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v43.fString.fRef);
              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44.fString.fRef);
            }
            else
            {
              long long v24 = [v18 labelsWithItem:v35 error:0];
              if ([v24 count])
              {
                TString::TString((TString *)&cf, "\t", 1uLL);
                id v25 = [v24 componentsJoinedByString:@", "];
                v44.fString.fRef = &stru_1F2ABD380;
                CFRetain(&stru_1F2ABD380);
                TString::SetStringRefAsImmutable(&v44, v25);

                CFStringRef v26 = (const __CFString *)cf;
                CFTypeRef v46 = &stru_1F2ABD380;
                CFRetain(&stru_1F2ABD380);
                CFMutableStringRef v27 = CFStringCreateMutableCopy(v16, 0, v26);
                if (v46) {
                  CFRelease(v46);
                }
                CFTypeRef v46 = v27;
                TString::Append((TString *)&v46, &v44);
                uint64_t v4 = v37;
                TString::Append((TString *)&v51, (const TString *)&v46);
                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v46);
                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44.fString.fRef);

                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
              }
            }
            TString::Append((TString *)&v51, (const __CFString *)"\n");
          }
          uint64_t v13 = obj;
          uint64_t v14 = [obj countByEnumeratingWithState:&v47 objects:v60 count:16];
        }
        while (v14);
      }

      id v28 = v51;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v51);
      *(_DWORD *)long long buf = 138544130;
      id v53 = v31;
      __int16 v54 = 2114;
      id v55 = v32;
      __int16 v56 = 2114;
      int v57 = v30;
      __int16 v58 = 2114;
      id v59 = v28;
      _os_log_impl(&dword_1D343E000, v11, OS_LOG_TYPE_DEBUG, "item '%{public}@' state is 'waiting to update'\nfpItem=%{public}@\nflags=%{public}@\ndecorations=[%{public}@]\n", buf, 0x2Au);

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38);
    }
  }
LABEL_36:

  return v34;
}

void sub_1D34671DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, void *a16, uint64_t a17, void *a18, const void *a19, uint64_t a20,uint64_t a21,id a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,const void *a38)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a38);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a19);

  _Unwind_Resume(a1);
}

BOOL IsLocalStorageDomainID(const TString *a1)
{
  {
    TString::TString((TString *)&IsLocalStorageDomainID(TString const&)::kLocalStorageID, "com.apple.FileProvider.LocalStorage");
  }
  return CFEqual(a1->fString.fRef, (CFTypeRef)IsLocalStorageDomainID(TString const&)::kLocalStorageID) != 0;
}

void sub_1D3467458(_Unwind_Exception *a1)
{
}

const __CFURL *TCFURLInfo::GetNumericalProperty(const __CFURL *this, const __CFString *a2, const __CFString *a3)
{
  uint64_t valuePtr = 0;
  if (this)
  {
    CFErrorRef error = 0;
    CFNumberRef propertyValueTypeRefPtr = 0;
    if (CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, &error))
    {
      if (propertyValueTypeRefPtr) {
        CFNumberGetValue(propertyValueTypeRefPtr, kCFNumberSInt64Type, &valuePtr);
      }
      goto LABEL_14;
    }
    Domain = (TString *)CFErrorGetDomain(error);
    CFTypeRef cf1 = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&cf1, Domain);
    if (*MEMORY[0x1E4F1D148]) {
      int v5 = (__CFString *)*MEMORY[0x1E4F1D148];
    }
    else {
      int v5 = &stru_1F2ABD380;
    }
    if (CFEqual(cf1, v5))
    {
      CFIndex Code = CFErrorGetCode(error);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
      if (Code == 260)
      {
LABEL_14:
        TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
        TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
        return (const __CFURL *)valuePtr;
      }
    }
    else
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E4F1CF50])) {
      uint64_t valuePtr = 0;
    }
    goto LABEL_14;
  }
  return this;
}

void sub_1D3467578(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11)
{
}

const void **TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void TFSInfo::FetchBladeRunnerProperties(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  int v4 = TFSInfo::ComputeBladeRunnerFlags(this, a2, a3);
  __int16 v5 = v4;
  TFSInfo::SetBladeRunnerFlags((uint64_t)this, v4);
  if ((v5 & 0x180) != 0)
  {
    if (UseFileProviderFramework())
    {
      TFSInfo::GetFPItem(this);
      int v6 = (FPItem *)objc_claimAutoreleasedReturnValue();
      uint64_t v7 = v6;
      if (v6 && [(FPItem *)v6 isShared])
      {
        if ((v5 & 0x100) != 0)
        {
          uint64_t v10 = 0;
        }
        else
        {
          FPSharedItemCreator(v7);
          uint64_t v10 = (NSPersonNameComponents *)objc_claimAutoreleasedReturnValue();
        }
        unsigned int v9 = [(FPItem *)v7 mostRecentEditorNameComponents];
      }
      else
      {
        uint64_t v10 = 0;
        unsigned int v9 = 0;
      }

      BOOL v8 = v10;
    }
    else
    {
      BOOL v8 = 0;
      unsigned int v9 = 0;
    }
    uint64_t v11 = v8;
    TFSInfo::SetICloudSharePerson(this, v8);
  }
}

void sub_1D34676E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void TFSInfo::SetBladeRunnerFlags(uint64_t a1, int a2)
{
  int v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (a2 != 0x80000000 || *(void *)(a1 + 80))
  {
    uint64_t Overflow = TFSInfo::GetOrCreateOverflow((TFSInfo *)a1);
    os_unfair_lock_lock((os_unfair_lock_t)(Overflow + 72));
    if (a2 != 0x80000000)
    {
      int v6 = *(unsigned __int8 *)(Overflow + 76);
      if (v6 == 2)
      {
        TFSInfoOverflow::MigrateToType(Overflow, 1);
      }
      else if (v6 == 3)
      {
        *(unsigned char *)(Overflow + 76) = 1;
        *(void *)(Overflow + 32) = 0;
        *(_OWORD *)uint64_t Overflow = 0u;
        *(_OWORD *)(Overflow + 16) = 0u;
        *(_DWORD *)(Overflow + 32) = 0x80000000;
      }
    }
    int v7 = *(unsigned __int8 *)(Overflow + 76);
    os_unfair_lock_unlock((os_unfair_lock_t)(Overflow + 72));
    if (v7 == 1) {
      *(_DWORD *)(Overflow + 32) = a2;
    }
  }
  os_unfair_lock_unlock(v4);
}

void sub_1D34677F0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsTopLevelSharedItem(TFSInfo *this)
{
  if (!UseFileProviderFramework()) {
    return 0;
  }
  uint64_t v2 = TFSInfo::GetFPItem(this);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = [v2 isTopLevelSharedItem];

  return v4;
}

void sub_1D3467858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ComputeBRFlagsFromFPItem(FPItem *a1@<X0>, uint64_t a2@<X8>)
{
  TString v18 = a1;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 7) = 0;
  *(void *)(a2 + 24) = 0;
  int v3 = UseFileProviderFramework() ^ 1;
  if (!v18) {
    LOBYTE(v3) = 1;
  }
  uint64_t v4 = v18;
  if ((v3 & 1) == 0)
  {
    if ([(FPItem *)v18 isCloudItem])
    {
      if (([(FPItem *)v18 isFolder] & 1) != 0 || [(FPItem *)v18 isPackage]) {
        char v5 = [(FPItem *)v18 isRecursivelyDownloaded];
      }
      else {
        char v5 = [(FPItem *)v18 isDownloaded];
      }
      char v6 = v5 ^ 1;
    }
    else
    {
      char v6 = 0;
    }
    *(unsigned char *)a2 = v6;
    *(unsigned char *)(a2 + 1) = [(FPItem *)v18 isUploaded];
    *(unsigned char *)(a2 + 2) = [(FPItem *)v18 isUploading];
    *(unsigned char *)(a2 + 3) = [(FPItem *)v18 isDownloading];
    char v7 = [(FPItem *)v18 isMostRecentVersionDownloaded];
    *(unsigned char *)(a2 + 4) = v7;
    char v8 = [(FPItem *)v18 isExcludedFromSync];
    *(unsigned char *)(a2 + 6) = v8;
    uint64_t v9 = [(FPItem *)v18 downloadingError];
    *(void *)(a2 + 16) = v9;
    uint64_t v10 = [(FPItem *)v18 uploadingError];
    *(void *)(a2 + 24) = v10;
    BOOL v11 = (v8 & 1) == 0 && (v10 | v9) != 0;
    *(unsigned char *)(a2 + 5) = v11;
    uint64_t v12 = static_objc_cast<NSString,objc_object * {__strong}>(v18);
    uint64_t v13 = [v12 isDownloadRequested];
    *(unsigned char *)(a2 + 7) = [v13 BOOLValue] & (v7 ^ 1);

    uint64_t v14 = [(FPItem *)v18 uploadingError];
    *(unsigned char *)(a2 + 8) = BladeRunnerOutOfSpaceError(v14);

    if ([(FPItem *)v18 isShared])
    {
      uint64_t v15 = FPSharedItemCreator(v18);
      *(unsigned char *)(a2 + 9) = v15 != 0;
    }
    else
    {
      *(unsigned char *)(a2 + 9) = 0;
    }
    char v16 = [(FPItem *)v18 isShared];
    if (*(unsigned char *)(a2 + 9)) {
      char v17 = 0;
    }
    else {
      char v17 = v16;
    }
    *(unsigned char *)(a2 + 10) = v17;
    uint64_t v4 = v18;
  }
}

void sub_1D3467A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  BRFlagsRecord::~BRFlagsRecord(v10);
  _Unwind_Resume(a1);
}

uint64_t BladeRunnerOutOfSpaceError(NSError *a1)
{
  CFURLRef v1 = a1;
  uint64_t v2 = v1;
  if (!v1) {
    goto LABEL_6;
  }
  int v3 = [(NSError *)v1 domain];
  if (![v3 isEqualToString:*MEMORY[0x1E4F281F8]])
  {

    goto LABEL_6;
  }
  uint64_t v4 = [(NSError *)v2 code];

  if (v4 != 4354)
  {
LABEL_6:
    uint64_t v5 = 0;
    goto LABEL_7;
  }
  uint64_t v5 = 1;
LABEL_7:

  return v5;
}

void sub_1D3467B0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t BRFlagsFromState(unsigned __int8 *a1)
{
  int v1 = *a1;
  LODWORD(v2) = v1 | 2;
  if (!a1[2]) {
    LODWORD(v2) = *a1;
  }
  if (a1[3]) {
    LODWORD(v2) = v2 | 8;
  }
  if (a1[5]) {
    LODWORD(v2) = v2 | 0x10;
  }
  if (a1[6]) {
    LODWORD(v2) = v2 | 0x20;
  }
  if (a1[9]) {
    LODWORD(v2) = v2 | 0x80;
  }
  if (a1[10]) {
    LODWORD(v2) = v2 | 0x100;
  }
  if (a1[8]) {
    uint64_t v2 = v2 | 0x800;
  }
  else {
    uint64_t v2 = v2;
  }
  if (!a1[6])
  {
    if (a1[2] || !a1[4] || a1[1])
    {
      if (*a1 && !a1[3] && a1[7])
      {
        return v2 | 0x400;
      }
      else if (a1[2] | v1 | a1[3] | a1[4])
      {
        return v2;
      }
      else
      {
        return v2 | 0x2000;
      }
    }
    else
    {
      return v2 | 0x200;
    }
  }
  return v2;
}

id TFSInfo::CopyICloudSharePerson(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t v3 = *((void *)this + 10);
  if (v3
    && (os_unfair_lock_lock((os_unfair_lock_t)(v3 + 72)),
        int v4 = *(unsigned __int8 *)(v3 + 76),
        os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 72)),
        v4 == 1))
  {
    id v5 = *(id *)v3;
  }
  else
  {
    id v5 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v5;
}

uint64_t TFSInfo::Fetch(TFSInfo *this, TFSInfo **a2, int a3)
{
  if (!a3) {
    return 0;
  }
  __int16 v3 = a3;
  if (a3)
  {
    char v6 = TFSInfo::FetchISIcon(this);
    id v7 = [v6 symbol];
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    if (v7)
    {
      uint64_t Overflow = TFSInfo::GetOrCreateOverflow(this);
      TFSInfoOverflow::SetIFSymbol(Overflow, v7);
    }
    else
    {
      uint64_t v9 = *((void *)this + 10);
      if (v9) {
        TFSInfoOverflow::SetIFSymbol(v9, 0);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  }
  if ((v3 & 2) != 0)
  {
    id location = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TFSInfo::GetKindWithoutPlatform(this, (TString *)&location, 0, &v24);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&location);
  }
  if ((v3 & 0x200) != 0)
  {
    id location = 0;
    TFSInfo::GetUTType(this, &location, 0, &v24);
  }
  if ((v3 & 4) != 0)
  {
    id location = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TFSInfo::GetShortVersion((uint64_t)this, (const void **)&location);
    TFSInfo::GetLongVersion((uint64_t)this, (TString *)&location);
    TFSInfo::GetSystemVersion((uint64_t)this, (TString *)&location);
    TFSInfo::GetCopyrightString((uint64_t)this, (TString *)&location);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&location);
  }
  if ((v3 & 0x20) == 0)
  {
    if ((v3 & 0x10) == 0) {
      goto LABEL_16;
    }
LABEL_27:
    TFSInfo::SetExtendedUserAccess(this);
    if ((v3 & 0x80) == 0) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  id location = (id)TFSInfo::CopyPermissions(this);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&location);
  if ((v3 & 0x10) != 0) {
    goto LABEL_27;
  }
LABEL_16:
  if ((v3 & 0x80) != 0)
  {
LABEL_17:
    id location = TFSInfo::CopyTagsAndAttributes(this, 1);
    TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&location);
  }
LABEL_18:
  int v10 = UseFileProviderFramework();
  if ((v3 & 0x800) != 0 && v10)
  {
    uint64_t v13 = TFSInfo::GetFPItem(*a2);
    if (v13)
    {
      uint64_t v14 = TFSInfo::GetFPItem(this);

      if (!v14) {
        TFSInfo::CopyFPItemIfNeeded((uint64_t)this, a2);
      }
    }

    uint64_t v15 = *a2;
    char v16 = (os_unfair_lock_s *)((char *)v15 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)v15 + 24);
    uint64_t v17 = *((void *)v15 + 10);
    if (v17
      && (os_unfair_lock_lock((os_unfair_lock_t)(v17 + 72)),
          int v18 = *(unsigned __int8 *)(v17 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 72)),
          v18 == 1))
    {
      uint64_t v19 = (FIProviderDomain *)*(id *)(v17 + 24);
    }
    else
    {
      uint64_t v19 = 0;
    }
    os_unfair_lock_unlock(v16);
    if (([(FIProviderDomain *)v19 disconnectionState] & 0xFFFFFFFFFFFFFFFELL) == 6)
    {
      TFSInfo::GetFPItem(this);
      id v20 = (id)objc_claimAutoreleasedReturnValue();
      if (v20
        || ((os_unfair_lock_lock((os_unfair_lock_t)this + 24), (uint64_t v21 = *((void *)this + 10)) == 0)
         || (os_unfair_lock_lock((os_unfair_lock_t)(v21 + 72)),
             int v22 = *(unsigned __int8 *)(v21 + 76),
             os_unfair_lock_unlock((os_unfair_lock_t)(v21 + 72)),
             v22 != 1)
          ? (id v20 = 0)
          : (id v20 = *(id *)(v21 + 24)),
            os_unfair_lock_unlock((os_unfair_lock_t)this + 24),
            v20))
      {
      }
      else if (![(FIProviderDomain *)v19 asyncResultAvailable])
      {
        TFSInfo::UpdateFileProvider(this, v19);
LABEL_40:

        goto LABEL_41;
      }
    }
    if ([(FIProviderDomain *)v19 asyncResultAvailable]) {
      TFSInfo::UpdateFileProvider(this, 0);
    }
    goto LABEL_40;
  }
LABEL_41:
  if ((v3 & 0x900) != 0) {
    TFSInfo::FetchBladeRunnerProperties(this, v11, v12);
  }
  return 0;
}

void sub_1D3467FA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetCopyrightString(uint64_t a1, TString *a2)
{
  uint64_t VersionMetaData = TFSInfo::FetchVersionMetaData(a1);
  id v5 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  TString::SetStringRefAsImmutable(a2, 0);
  uint64_t v6 = *(void *)a1;
  if (v6)
  {
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&cf, *(TString **)(v6 + 24));
    if (&cf != (CFTypeRef *)a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  os_unfair_lock_unlock(v5);
  return VersionMetaData;
}

void sub_1D34680CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetSystemVersion(uint64_t a1, TString *a2)
{
  uint64_t VersionMetaData = TFSInfo::FetchVersionMetaData(a1);
  id v5 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  TString::SetStringRefAsImmutable(a2, 0);
  uint64_t v6 = *(void *)a1;
  if (v6)
  {
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&cf, *(TString **)(v6 + 16));
    if (&cf != (CFTypeRef *)a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  os_unfair_lock_unlock(v5);
  return VersionMetaData;
}

void sub_1D34681C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetShortVersion(uint64_t a1, const void **a2)
{
  uint64_t VersionMetaData = TFSInfo::FetchVersionMetaData(a1);
  id v5 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  CFTypeRef cf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  if (&cf != a2)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
    CFRetain(&stru_1F2ABD380);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = &stru_1F2ABD380;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  uint64_t v6 = *(TString ***)a1;
  if (v6)
  {
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&cf, *v6);
    if (&cf != a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  os_unfair_lock_unlock(v5);
  return VersionMetaData;
}

void sub_1D3468300(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::FetchVersionMetaData(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  int v3 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x20000000) == 0) {
    std::make_unique[abi:ne180100]<TVersionData>();
  }
  return 0;
}

void sub_1D34684A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **a10)
{
  uint64_t v11 = a10;
  a10 = 0;
  if (v11) {
    std::default_delete<TVersionData>::operator()[abi:ne180100]((uint64_t)&a10, v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TFSInfo::GetLongVersion(uint64_t a1, TString *a2)
{
  uint64_t VersionMetaData = TFSInfo::FetchVersionMetaData(a1);
  id v5 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  TString::SetStringRefAsImmutable(a2, 0);
  uint64_t v6 = *(void *)a1;
  if (v6)
  {
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&cf, *(TString **)(v6 + 8));
    if (&cf != (CFTypeRef *)a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  os_unfair_lock_unlock(v5);
  return VersionMetaData;
}

void sub_1D3468590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  os_unfair_lock_unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t NSObjectsAreEqual(NSObject *a1, NSObject *a2)
{
  int v3 = a1;
  int v4 = a2;
  id v5 = v4;
  if (v3) {
    uint64_t v6 = [v3 isEqual:v4];
  }
  else {
    uint64_t v6 = v4 == 0;
  }

  return v6;
}

void sub_1D346861C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SynchronizeLaunchServices(uint64_t a1, os_unfair_lock_s **a2, uint64_t **a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  unint64_t v7 = ((unint64_t)*(unsigned int *)(a1 + 115) >> 2) & 1;
  os_unfair_lock_unlock(v6);
  char v8 = *a2;
  uint64_t v9 = *a2 + 25;
  os_unfair_lock_lock(v9);
  unint64_t v10 = ((unint64_t)*(unsigned int *)((char *)&v8[28]._os_unfair_lock_opaque + 3) >> 2) & 1;
  os_unfair_lock_unlock(v9);
  if (v7 != v10)
  {
    unsigned int v28 = 1769169264;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
  }
  os_unfair_lock_lock(v6);
  unint64_t v11 = ((unint64_t)*(unsigned int *)(a1 + 115) >> 1) & 1;
  os_unfair_lock_unlock(v6);
  CFStringRef v12 = *a2;
  uint64_t v13 = *a2 + 25;
  os_unfair_lock_lock(v13);
  unint64_t v14 = ((unint64_t)*(unsigned int *)((char *)&v12[28]._os_unfair_lock_opaque + 3) >> 1) & 1;
  os_unfair_lock_unlock(v13);
  if (v11 != v14)
  {
    unsigned int v28 = 1769173099;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
    unsigned int v28 = 1819240307;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
    unsigned int v28 = 1885895027;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
  }
  os_unfair_lock_lock(v6);
  unint64_t v15 = ((unint64_t)*(unsigned int *)(a1 + 115) >> 4) & 1;
  os_unfair_lock_unlock(v6);
  char v16 = *a2;
  uint64_t v17 = *a2 + 25;
  os_unfair_lock_lock(v17);
  unint64_t v18 = ((unint64_t)*(unsigned int *)((char *)&v16[28]._os_unfair_lock_opaque + 3) >> 4) & 1;
  os_unfair_lock_unlock(v17);
  if (v15 != v18)
  {
    os_unfair_lock_lock(v6);
    unint64_t v19 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
    os_unfair_lock_unlock(v6);
    if ((v19 & 0x80000000000) != 0)
    {
      unsigned int v28 = 1668506984;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
    }
  }
  os_unfair_lock_lock(v6);
  int v20 = (*(unsigned __int16 *)(a1 + 119) >> 12) & 1;
  os_unfair_lock_unlock(v6);
  uint64_t v21 = *a2;
  int v22 = *a2 + 25;
  os_unfair_lock_lock(v22);
  LODWORD(v21) = (*(unsigned __int16 *)((char *)&v21[29]._os_unfair_lock_opaque + 3) >> 12) & 1;
  os_unfair_lock_unlock(v22);
  if (v20 != v21)
  {
    unsigned int v28 = 1920167267;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
  }
  os_unfair_lock_lock(v6);
  unint64_t v23 = ((unint64_t)*(unsigned int *)(a1 + 115) >> 3) & 1;
  os_unfair_lock_unlock(v6);
  char v24 = *a2;
  id v25 = *a2 + 25;
  os_unfair_lock_lock(v25);
  unint64_t v26 = ((unint64_t)*(unsigned int *)((char *)&v24[28]._os_unfair_lock_opaque + 3) >> 3) & 1;
  os_unfair_lock_unlock(v25);
  if (v23 != v26)
  {
    unsigned int v28 = 1751480436;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
    unsigned int v28 = 1684955501;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v28, &v28);
  }
  uint64_t result = TFSInfo::ApplicationDMFPolicy((TFSInfo *)a1);
  if (result != -1) {
    BYTE1((*a2)[28]._os_unfair_lock_opaque) = result;
  }
  return result;
}

uint64_t TFSInfo::ApplicationDMFPolicy(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 4) == 0) {
    return 0;
  }
  id v5 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  uint64_t v4 = *((char *)this + 113);
  os_unfair_lock_unlock(v5);
  return v4;
}

BOOL TFSInfo::SynchronizeVersions(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  int v7 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v6);
  if ((v7 & 0x20000000) == 0) {
    return 0;
  }
  v16.fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  unint64_t v15 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  if (TFSInfo::GetShortVersion(a1, (const void **)&v16.fString.fRef)
    || TFSInfo::GetShortVersion(*a2, (const void **)&v15)
    || CFEqual(v16.fString.fRef, v15))
  {
    int v9 = 0;
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    uint64_t v13 = *(TString **)a1;
    if (!*(void *)a1) {
      std::make_unique[abi:ne180100]<TVersionData>();
    }
    if (v13 != (TString *)&v15) {
      TString::SetStringRefAsImmutable(v13, (TString *)v15);
    }
    LODWORD(v14) = 1936225906;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v14, &v14);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    int v9 = 1;
  }
  if (!TFSInfo::GetLongVersion(a1, &v16)
    && !TFSInfo::GetLongVersion(*a2, (TString *)&v15)
    && !CFEqual(v16.fString.fRef, v15))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    unint64_t v10 = *(TString **)a1;
    if (!*(void *)a1) {
      std::make_unique[abi:ne180100]<TVersionData>();
    }
    if (&v10[1] != (TString *)&v15) {
      TString::SetStringRefAsImmutable(v10 + 1, (TString *)v15);
    }
    LODWORD(v14) = 1986359923;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v14, &v14);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    int v9 = 1;
  }
  if (!TFSInfo::GetSystemVersion(a1, &v16)
    && !TFSInfo::GetSystemVersion(*a2, (TString *)&v15)
    && !CFEqual(v16.fString.fRef, v15))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    unint64_t v11 = *(TString **)a1;
    if (!*(void *)a1) {
      std::make_unique[abi:ne180100]<TVersionData>();
    }
    if (&v11[2] != (TString *)&v15) {
      TString::SetStringRefAsImmutable(v11 + 2, (TString *)v15);
    }
    LODWORD(v14) = 1937340018;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v14, &v14);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    int v9 = 1;
  }
  if (!TFSInfo::GetCopyrightString(a1, &v16)
    && !TFSInfo::GetCopyrightString(*a2, (TString *)&v15)
    && !CFEqual(v16.fString.fRef, v15))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    CFStringRef v12 = *(TString **)a1;
    if (!*(void *)a1) {
      std::make_unique[abi:ne180100]<TVersionData>();
    }
    if (&v12[3] != (TString *)&v15) {
      TString::SetStringRefAsImmutable(v12 + 3, (TString *)v15);
    }
    LODWORD(v14) = 1668313715;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v14, &v14);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    int v9 = 1;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16.fString.fRef);
  return v9 != 0;
}

void sub_1D3468D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, const void *a12)
{
  os_unfair_lock_unlock(v12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);
  _Unwind_Resume(a1);
}

id TFSInfoOverflow::GetIFSymbol(TFSInfoOverflow *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 72);
  os_unfair_lock_lock((os_unfair_lock_t)this + 18);
  id v3 = *((id *)this + 8);
  os_unfair_lock_unlock(v2);
  return v3;
}

id TFSInfo::FetchIFSymbol(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  id v3 = (TFSInfoOverflow *)*((void *)this + 10);
  if (v3)
  {
    TFSInfoOverflow::GetIFSymbol(v3);
    id v4 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  if (!v4)
  {
    id v5 = TFSInfo::FetchISIcon(this);
    id v4 = [v5 symbol];
    os_unfair_lock_lock(v2);
    if (v4)
    {
      uint64_t Overflow = TFSInfo::GetOrCreateOverflow(this);
      TFSInfoOverflow::SetIFSymbol(Overflow, v4);
    }
    else
    {
      uint64_t v7 = *((void *)this + 10);
      if (v7) {
        TFSInfoOverflow::SetIFSymbol(v7, 0);
      }
    }
    os_unfair_lock_unlock(v2);
  }
  return v4;
}

void sub_1D3468EAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **FileSuffix@<X0>(const TString *a1@<X0>, TString *a2@<X8>)
{
  id v3 = [(__CFString *)a1->fString.fRef pathExtension];
  CFStringRef theString = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&theString, v3);

  if (CFStringGetLength(theString))
  {
    TString::TString(&v7, ".", 1uLL);
    fRef = v7.fString.fRef;
    a2->fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, fRef);
    CFRelease(&stru_1F2ABD380);
    a2->fString.fRef = MutableCopy;
    TString::Append(a2, (const TString *)&theString);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  }
  else
  {
    a2->fString.fRef = (__CFString *)theString;
    CFStringRef theString = 0;
    CFRetain(&stru_1F2ABD380);
    if (theString) {
      CFRelease(theString);
    }
    CFStringRef theString = &stru_1F2ABD380;
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1D3469024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

void TFSInfo::SynchronizePermissions(uint64_t a1, TFSInfo **a2, uint64_t **a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  unint64_t v7 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
  os_unfair_lock_unlock(v6);
  if ((v7 & 0x2000000000) != 0)
  {
    char v39 = (__CFFileSecurity *)TFSInfo::CopyPermissions((TFSInfo *)a1);
    id v38 = (__CFFileSecurity *)TFSInfo::CopyPermissions(*a2);
    __s1 = CopyACLToText(v39);
    char v8 = CopyACLToText(v38);
    char v36 = v8;
    if ((v8 == 0) != (__s1 == 0) || __s1 && strcmp(__s1, v8))
    {
      unsigned int v35 = 1768124270;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v35, &v35);
      unsigned int v35 = 1886549619;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v35, &v35);
    }
    TACLRef<char *>::~TACLRef((void **)&v36);
    TACLRef<char *>::~TACLRef((void **)&__s1);
    TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&v38);
    TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&v39);
  }
  int Owner = TFSInfo::GetOwner((TFSInfo *)a1);
  if (Owner != TFSInfo::GetOwner(*a2))
  {
    LODWORD(v39) = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
    LODWORD(v39) = 1870098034;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
  }
  int UserGroups = TFSInfo::GetUserGroups((TFSInfo *)a1);
  if (UserGroups != TFSInfo::GetUserGroups(*a2))
  {
    LODWORD(v39) = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
    LODWORD(v39) = 1970497394;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
  }
  int Mode = TFSInfo::GetMode((TFSInfo *)a1);
  if (Mode != TFSInfo::GetMode(*a2))
  {
    LODWORD(v39) = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
    LODWORD(v39) = 1886549619;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
  }
  int UserAccess = TFSInfo::GetUserAccess((TFSInfo *)a1);
  if (UserAccess != TFSInfo::GetUserAccess(*a2))
  {
    LODWORD(v39) = 1970495843;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
    LODWORD(v39) = 1768124270;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
  }
  os_unfair_lock_lock(v6);
  int v13 = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v6);
  if (v13 < 0)
  {
    os_unfair_lock_lock(v6);
    int v14 = *(_DWORD *)(a1 + 115);
    os_unfair_lock_unlock(v6);
    if ((v14 & 0x20) != 0)
    {
      unint64_t v15 = *a2;
      TString v16 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v16);
      LODWORD(v15) = *(_DWORD *)((char *)v15 + 115);
      os_unfair_lock_unlock(v16);
      if ((v15 & 0x80000000) == 0) {
        TFSInfo::SetExtendedUserAccess(*a2);
      }
      os_unfair_lock_lock(v6);
      unsigned int v18 = *(_DWORD *)(a1 + 115);
      uint64_t v17 = (unsigned int *)(a1 + 115);
      unint64_t v34 = v18;
      os_unfair_lock_unlock(v6);
      unint64_t v19 = *a2;
      int v20 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v20);
      unint64_t v33 = *(unsigned int *)((char *)v19 + 115);
      os_unfair_lock_unlock(v20);
      os_unfair_lock_lock(v6);
      unint64_t v21 = *v17;
      os_unfair_lock_unlock(v6);
      int v22 = *a2;
      unint64_t v23 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v23);
      unint64_t v24 = *(unsigned int *)((char *)v22 + 115);
      os_unfair_lock_unlock(v23);
      os_unfair_lock_lock(v6);
      unint64_t v25 = *v17;
      os_unfair_lock_unlock(v6);
      unint64_t v26 = *a2;
      CFMutableStringRef v27 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v27);
      unint64_t v28 = *(unsigned int *)((char *)v26 + 115);
      os_unfair_lock_unlock(v27);
      os_unfair_lock_lock(v6);
      unint64_t v29 = ((unint64_t)*v17 >> 23) & 1;
      os_unfair_lock_unlock(v6);
      uint64_t v30 = *a2;
      id v31 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v31);
      unint64_t v32 = ((unint64_t)*(unsigned int *)((char *)v30 + 115) >> 23) & 1;
      os_unfair_lock_unlock(v31);
      if (v29 != v32
        || ((v25 >> 22) & 1) != ((v28 >> 22) & 1)
        || ((v21 >> 21) & 1) != ((v24 >> 21) & 1)
        || ((v34 >> 20) & 1) != ((v33 >> 20) & 1))
      {
        LODWORD(v39) = 1970495843;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
        LODWORD(v39) = 1768124270;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v39, &v39);
      }
    }
  }
}

void sub_1D346947C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va3, a5);
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void *);
  va_copy(va2, va1);
  char v8 = va_arg(va2, void *);
  va_copy(va3, va2);
  unint64_t v10 = va_arg(va3, const void *);
  TACLRef<char *>::~TACLRef((void **)va);
  TACLRef<char *>::~TACLRef((void **)va1);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va2);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va3);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetOwner(TFSInfo *this)
{
  uid_t owner = 0;
  int v1 = (void *)TFSInfo::CopyPermissions(this);
  id v4 = v1;
  if (v1)
  {
    CFFileSecurityGetOwner((CFFileSecurityRef)v1, &owner);
    uint64_t v2 = owner;
  }
  else
  {
    uint64_t v2 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&v4);
  return v2;
}

void sub_1D3469518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t TFSInfo::GetMode(TFSInfo *this)
{
  mode_t mode = 0;
  int v1 = (void *)TFSInfo::CopyPermissions(this);
  id v4 = v1;
  if (v1)
  {
    CFFileSecurityGetMode((CFFileSecurityRef)v1, &mode);
    uint64_t v2 = mode;
  }
  else
  {
    uint64_t v2 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&v4);
  return v2;
}

void sub_1D3469580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t TFSInfo::CopyPermissions(TFSInfo *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int v1 = (const void *)*((void *)this + 1);
  char v8 = v1;
  if (v1)
  {
    uint64_t v2 = this;
    CFRetain(v1);
    uint64_t v9 = 0;
    TCFURLInfo::CopyPropertyValues((uint64_t)v1);
    id v3 = (os_unfair_lock_s *)((char *)v2 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)v2 + 25);
    unsigned int v4 = *(_DWORD *)((char *)v2 + 115);
    uint64_t v2 = (TFSInfo *)((char *)v2 + 115);
    unint64_t v5 = v4 | ((unint64_t)*((unsigned __int16 *)v2 + 2) << 32) | 0x2000000000;
    *(_DWORD *)uint64_t v2 = v4;
    *((_WORD *)v2 + 2) = WORD2(v5);
    os_unfair_lock_unlock(v3);
    uint64_t v6 = v9;
  }
  else
  {
    uint64_t v6 = 0;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v8);
  return v6;
}

void sub_1D3469660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetUserGroups(TFSInfo *this)
{
  gid_t group = 0;
  int v1 = (void *)TFSInfo::CopyPermissions(this);
  unsigned int v4 = v1;
  if (v1)
  {
    CFFileSecurityGetGroup((CFFileSecurityRef)v1, &group);
    uint64_t v2 = group;
  }
  else
  {
    uint64_t v2 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef(&v4);
  return v2;
}

void sub_1D34696C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t TFSInfo::GetUserAccess(TFSInfo *this)
{
  int v1 = this;
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unsigned int v3 = *(_DWORD *)((char *)v1 + 115);
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock(v2);
  unsigned int v4 = *(_DWORD *)((char *)v1 + 115);
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock(v2);
  LODWORD(v1) = *(_DWORD *)((char *)v1 + 115);
  os_unfair_lock_unlock(v2);
  return (v4 >> 12) & 2 | (v3 >> 14) & 1 | (v1 >> 10) & 4;
}

void sub_1D3469ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  CFStringRef v12 = va_arg(va1, const void *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  va_copy(va2, va1);
  TString v16 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);

  _Unwind_Resume(a1);
}

void sub_1D346A250()
{
}

void sub_1D346A424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

TNodeRequest **TRef<OpaqueNodeRequest *,TRetainReleasePolicy<OpaqueNodeRequest *>>::~TRef(TNodeRequest **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    NodeDisposeRequest(v2);
  }
  return a1;
}

uint64_t TNode::GetProperty(uint64_t a1, uint64_t a2, TPropertyReference *a3, TNodeRequest **a4, unsigned int a5)
{
  unsigned int v34 = a5;
  if (*a4) {
    uint64_t v9 = a5 | 0x82;
  }
  else {
    uint64_t v9 = a5;
  }
  int Property = (TNode *)TNode::GetProperty(a1, a2, a3, v9);
  unint64_t v11 = Property;
  int v12 = 0;
  if ((int)a2 > 1819240306)
  {
    if (a2 != 1885895027)
    {
      int v13 = 1819240307;
LABEL_9:
      if (a2 != v13) {
        goto LABEL_13;
      }
    }
  }
  else if (a2 != 1667330145)
  {
    int v13 = 1718776688;
    goto LABEL_9;
  }
  int Property = (TNode *)TNode::IsDeferredForSymlink(a1, (uint64_t (*)(void *))TFSInfo::IsPackage, 0);
  if (Property) {
    atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x80u);
  }
  int v12 = 1;
LABEL_13:
  if (v11 == -8053)
  {
    unint64_t v21 = (os_unfair_lock_s *)TNode::InfoLock(Property);
    os_unfair_lock_lock(v21);
    uint64_t v23 = *(void *)(a1 + 16);
    int v22 = *(std::__shared_weak_count **)(a1 + 24);
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v21);
      int v24 = *(unsigned __int8 *)(v23 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
      if (!v24) {
        goto LABEL_34;
      }
    }
    else
    {
      os_unfair_lock_unlock(v21);
      if (!*(unsigned char *)(v23 + 112)) {
        goto LABEL_34;
      }
    }
    return 4294959243;
  }
  if (v11 != -8074)
  {
    if (v11 != -8086) {
      return (uint64_t)v11;
    }
    if (a2 == 1668506984)
    {
LABEL_19:
      uint64_t v14 = (os_unfair_lock_s *)TNode::InfoLock(Property);
      os_unfair_lock_lock(v14);
      uint64_t v16 = *(void *)(a1 + 16);
      uint64_t v15 = *(std::__shared_weak_count **)(a1 + 24);
      if (v15) {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v14);
      uint64_t v17 = (os_unfair_lock_s *)(v16 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v16 + 100));
      int v18 = *(_DWORD *)(v16 + 115);
      os_unfair_lock_unlock(v17);
      if (v15) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v15);
      }
      if ((v18 & 0x40000000) == 0)
      {
        LODWORD(v32) = 0x80000;
        v33.fData.__impl_.__unsigned int index = 0;
        std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v33, &v32);
        TNode::RequestInternalTask(a1, 1000, &v33, 0);
        TPropertyValue::~TPropertyValue(&v33);
      }
      return 0;
    }
    if (a2 == 1684955501)
    {
      if (*a4) {
        goto LABEL_19;
      }
      return 0;
    }
    uint64_t v20 = v34;
    if ((v34 & 0x80) != 0)
    {
      if (TPropertyReference::IsValid(a3)) {
        return 0;
      }
      goto LABEL_45;
    }
    goto LABEL_35;
  }
LABEL_34:
  uint64_t v20 = v34;
  if ((v34 & 0x80) != 0)
  {
LABEL_45:
    TPropertyReference::Clear((void ***)a3);
    return (uint64_t)v11;
  }
LABEL_35:
  if (*a4)
  {
    if (!v12) {
      goto LABEL_42;
    }
    unint64_t v25 = (os_unfair_lock_s *)TNode::InfoLock(Property);
    os_unfair_lock_lock(v25);
    uint64_t v27 = *(void *)(a1 + 16);
    unint64_t v26 = *(std::__shared_weak_count **)(a1 + 24);
    if (v26) {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v25);
    unint64_t v28 = (os_unfair_lock_s *)(v27 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v27 + 100));
    int v29 = *(_DWORD *)(v27 + 115);
    os_unfair_lock_unlock(v28);
    if (v26) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v26);
    }
    if ((v29 & 0x20) != 0)
    {
      v33.fData.__impl_.__unsigned int index = 0;
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v33, &v34);
      id v31 = *a4;
      unint64_t v32 = v31;
      if (v31) {
        TNodeRequest::AddPtrReference(v31);
      }
      TNode::RequestTask(a1, 102, a2, &v33, (uint64_t *)&v32, 0);
    }
    else
    {
LABEL_42:
      v33.fData.__impl_.__unsigned int index = 0;
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v33, &v34);
      uint64_t v30 = *a4;
      unint64_t v32 = v30;
      if (v30) {
        TNodeRequest::AddPtrReference(v30);
      }
      TNode::RequestTask(a1, 1, a2, &v33, (uint64_t *)&v32, 0);
    }
    TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&v32);
    TPropertyValue::~TPropertyValue(&v33);
    if (v11 == -8053) {
      return 4294959243;
    }
    else {
      return 0;
    }
  }
  else
  {
    TNode::UpdatePropertySynchronous((TNode *)a1);
    TPropertyReference::Clear((void ***)a3);
    return TNode::GetProperty(a1, a2, a3, v20);
  }
}

void sub_1D346A830(_Unwind_Exception *a1, char a2, TPropertyValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t TNode::GetProperty(uint64_t a1, signed int a2, uint64_t a3, uint64_t a4)
{
  char v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v8);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
  int v11 = *(_DWORD *)(v10 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 100));
  BOOL IsAlias = (std::__shared_weak_count *)TFSInfo::IsAlias((TFSInfo *)v10);
  char v13 = (char)IsAlias;
  long long v47 = 0uLL;
  if (a2 == 1802071652) {
    a2 = 1802072172;
  }
  if (a2 > 1819240306)
  {
    if (a2 > 1836016739)
    {
      if (a2 == 1836016740) {
        goto LABEL_17;
      }
      int v14 = 1920167267;
    }
    else
    {
      if (a2 == 1819240307) {
        goto LABEL_17;
      }
      int v14 = 1819632756;
    }
LABEL_16:
    if (a2 != v14) {
      goto LABEL_27;
    }
    goto LABEL_17;
  }
  if (a2 > 1769171298)
  {
    if (a2 == 1769171299) {
      goto LABEL_17;
    }
    int v14 = 1802072172;
    goto LABEL_16;
  }
  if (a2 != 1634952036)
  {
    int v14 = 1768124270;
    goto LABEL_16;
  }
LABEL_17:
  TNodePtr::TNodePtr(&v41, (const TNode *)a1);
  TempPropertiesLock();
  os_unfair_lock_lock((os_unfair_lock_t)&TempPropertiesLock(void)::sTempPropertiesLock);
  uint64_t v15 = (void *)TempProperties();
  v49[0].fString.fRef = (__CFString *)TNodeFromFINode(v41.fFINode);
  uint64_t v16 = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(v15, v49);
  TempProperties();
  if (v16)
  {
    LOBYTE(v49[0].fString.fRef) = 1;
    std::pair<TTempProperties,BOOL>::pair[abi:ne180100]<TTempProperties&,BOOL,0>((uint64_t)v42, (long long *)(v16 + 3), v49);
  }
  else
  {
    v49[0].fString.fRef = 0;
    v49[1].fString.fRef = 0;
    v49[2].fString.fRef = (__CFString *)-1;
    long long v50 = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    id v51 = 0;
    char v48 = 0;
    std::pair<TTempProperties,BOOL>::pair[abi:ne180100]<true,0>((uint64_t)v42, (long long *)v49, &v48);

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v50);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&TempPropertiesLock(void)::sTempPropertiesLock);

  if (v46)
  {
    if (a2 <= 1819240306)
    {
      if (a2 != 1634952036)
      {
        if (a2 == 1769171299)
        {
          TPropertyReference::SetAs<ISIcon * {__strong}>(a3, &v45);
        }
        else if (a2 == 1802072172)
        {
          TPropertyReference::SetAs<TString>(a3, &v44);
        }
        goto LABEL_64;
      }
      uint64_t v17 = &v42[1];
    }
    else
    {
      uint64_t v17 = v42;
      if (a2 > 1836016739)
      {
        if (a2 != 1836016740)
        {
          if (a2 == 1920167267)
          {
            LOBYTE(v49[0].fString.fRef) = 0;
            TPropertyReference::SetAs<BOOL>(a3, v49);
          }
          goto LABEL_64;
        }
      }
      else
      {
        if (a2 == 1819240307)
        {
          TPropertyReference::SetAs<long long>(a3, &v43);
LABEL_64:

          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44);
          uint64_t Property = 0;
          goto LABEL_65;
        }
        if (a2 != 1819632756) {
          goto LABEL_64;
        }
      }
    }
    TPropertyReference::SetAs<double>(a3, v17);
    goto LABEL_64;
  }

  BOOL IsAlias = (std::__shared_weak_count *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44);
LABEL_27:
  if ((v11 & 0x100) != 0) {
    char v18 = v13;
  }
  else {
    char v18 = 1;
  }
  if (v18)
  {
    if (a2 == 1987273324) {
      goto LABEL_42;
    }
  }
  else
  {
    switch(a2)
    {
      case 1819240307:
        goto LABEL_40;
      case 1987273324:
LABEL_42:
        LOBYTE(v42[0].fFINode) = TNode::IsVisible((TNode *)a1);
        uint64_t v21 = TPropertyReference::SetAs<BOOL>(a3, v42);
LABEL_43:
        uint64_t Property = v21;
        goto LABEL_65;
      case 1885895027:
LABEL_40:
        TNode::GetVolumeInfo((TNode *)a1, v42);
        unint64_t v19 = (std::__shared_weak_count *)*((void *)&v47 + 1);
        long long v47 = *(_OWORD *)&v42[0].fFINode;
        if (v19)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v19);
          fFINode = (FINode *)v47;
        }
        else
        {
          fFINode = v42[0].fFINode;
        }
        v42[0].fFINode = 0;
        if (fFINode)
        {
          uint64_t v27 = (FINode *)TFSVolumeInfo::VolumeSize((TFSVolumeInfo *)fFINode);
          v42[0].fFINode = v27;
          if (v27 == (FINode *)-1)
          {
            TPropertyReference::SetAs<long long>(a3, v42);
            uint64_t Property = 4294959210;
            goto LABEL_65;
          }
          if (v27 != (FINode *)-2)
          {
            uint64_t v21 = TPropertyReference::SetAs<long long>(a3, v42);
            goto LABEL_43;
          }
        }
        else
        {
          v42[0].fFINode = (FINode *)-2;
        }
        TPropertyReference::SetAs<long long>(a3, v42);
        uint64_t Property = 4294959222;
        goto LABEL_65;
    }
  }
  if (a2 == 1684955501 && (v11 & 0x100) != 0)
  {
    TNode::GetVolumeInfo((TNode *)a1, v42);
    BOOL IsAlias = (std::__shared_weak_count *)*((void *)&v47 + 1);
    long long v47 = *(_OWORD *)&v42[0].fFINode;
    if (IsAlias) {
      std::__shared_weak_count::__release_shared[abi:ne180100](IsAlias);
    }
    if (!*(unsigned char *)(v47 + 108))
    {
      char v48 = 0;
      goto LABEL_106;
    }
LABEL_55:
    uint64_t v23 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsAlias);
    os_unfair_lock_lock(v23);
    unint64_t v25 = *(TFSInfo **)(a1 + 16);
    int v24 = *(std::__shared_weak_count **)(a1 + 24);
    if (v24) {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v23);
    TFSInfo::Name(v25, v49);
    if (v24) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v24);
    }
    ColonsToSlashes(v49, (TString *)v42);
    uint64_t Property = TPropertyReference::SetAs<TString>(a3, (TString **)v42);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v42[0].fFINode);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v49[0].fString.fRef);
    goto LABEL_65;
  }
  if (a2 == 1869769063)
  {
    unint64_t v28 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsAlias);
    os_unfair_lock_lock(v28);
    uint64_t v30 = *(TFSInfo **)(a1 + 16);
    int v29 = *(std::__shared_weak_count **)(a1 + 24);
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v28);
    char HaveOriginatorInfo = TFSInfo::CanHaveOriginatorInfo(v30);
    if (v29) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v29);
    }
    if ((HaveOriginatorInfo & 1) == 0)
    {
      v42[0].fFINode = 0;
      uint64_t Property = TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a3, (id *)&v42[0].fFINode);
      goto LABEL_114;
    }
  }
  else if (a2 == 1886282093)
  {
    goto LABEL_55;
  }
  if (!(void)v47)
  {
    TNode::GetVolumeInfo((TNode *)a1, v42);
    unint64_t v32 = (std::__shared_weak_count *)*((void *)&v47 + 1);
    long long v47 = *(_OWORD *)&v42[0].fFINode;
    if (v32) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v32);
    }
  }
  char v48 = 0;
  if (a2 > 1819501923)
  {
    if (a2 == 1819501924 || a2 == 1936225392)
    {
LABEL_103:
      if ((TFSInfo::GetBladeRunnerFlags((TFSInfo *)v10) & 0x80000000) != 0
        && ((a4 & 0x40000) != 0 || !pthread_main_np()))
      {
        char v37 = TNode::GetFIProvider((TNode *)a1);
        char v38 = [v37 isLocalStorageDomain];

        if ((v38 & 1) == 0)
        {
          TFSInfo::FetchBladeRunnerProperties((TFSInfo *)v10, v39, v40);
          TNodePtr::TNodePtr(v42, (const TNode *)a1);
          TNode::SendNotification((const TNode *)a1, 2, (id *)&v42[0].fFINode, 1969385844, 0);
        }
      }
      if ((TFSInfo::GetBladeRunnerFlags((TFSInfo *)v10) & 0x180) == 0 && *(unsigned char *)(v10 + 112) != 7)
      {
        uint64_t Property = 0;
        goto LABEL_107;
      }
LABEL_106:
      uint64_t Property = TFSInfo::GetProperty(v10, a2, a3, (uint64_t)&v47, a4, (uint64_t)&v48);
LABEL_107:
      if (a2 == 1668505966 || a2 == 1634758244) {
        TNode::AddToAppNapCache((TNode *)a1);
      }
      goto LABEL_110;
    }
    if (a2 != 1969385844) {
      goto LABEL_106;
    }
    if ((TFSInfo::GetBladeRunnerFlags((TFSInfo *)v10) & 0x80000000) != 0 && ((a4 & 0x40000) != 0 || !pthread_main_np()))
    {
      TFSInfo::FetchBladeRunnerProperties((TFSInfo *)v10, v33, v34);
      char v48 = 1;
    }
    LODWORD(v42[0].fFINode) = TFSInfo::GetBladeRunnerFlags((TFSInfo *)v10);
    char v35 = atomic_load((unsigned __int16 *)(a1 + 80));
    if (v35) {
      LODWORD(v42[0].fFINode) |= 0x1000u;
    }
    unsigned int v36 = TPropertyReference::SetAs<DSBladeRunnerFlags>(a3, v42);
    if (v36) {
      uint64_t Property = v36;
    }
    else {
      uint64_t Property = (SLODWORD(v42[0].fFINode) >> 31) & 0xFFFFE06A;
    }
  }
  else
  {
    if (a2 != 1667785588)
    {
      if (a2 == 1768845426)
      {
        v49[0].fString.fRef = (__CFString *)TNode::CopyInlineProgress((TNode *)a1);
        v42[0] = (TNodePtr)v49[0].fString.fRef;
        uint64_t Property = TPropertyReference::SetAs<__CFDictionary const*>(a3, (id *)&v42[0].fFINode);
        TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&v49[0].fString.fRef);
        goto LABEL_110;
      }
      if (a2 != 1769171056) {
        goto LABEL_106;
      }
      goto LABEL_103;
    }
    if ((a4 & 0x40000000) != 0 && *(void *)(a1 + 56) && TNode::NeedsChildReconcile((TNode *)a1))
    {
      v42[0].fFINode = (FINode *)TChildrenList::ChildrenCount(*(TChildrenList **)(a1 + 56));
      uint64_t v21 = TPropertyReference::SetAs<long long>(a3, v42);
      goto LABEL_43;
    }
    uint64_t Property = TFSInfo::GetProperty(v10, 1667785588, a3, (uint64_t)&v47, a4, (uint64_t)&v48);
  }
LABEL_110:
  if (!Property && v48)
  {
    TNodePtr::TNodePtr(v42, (const TNode *)a1);
    TNode::SendNotification((const TNode *)a1, 2, (id *)&v42[0].fFINode, a2, 0);
LABEL_114:
  }
LABEL_65:
  if (*((void *)&v47 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v47 + 1));
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  return Property;
}

void sub_1D346B0B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::__shared_weak_count *a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a18);
  }
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TFSInfo::GetProperty(uint64_t a1, signed int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!GetPropertyRecord(a2, (uint64_t)v18)) {
    return 4294959245;
  }
  int v12 = v19;
  char v13 = (void *)(a1 + (v20 >> 1));
  if (v20) {
    int v12 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(*v13 + v19);
  }
  uint64_t result = v12(v13, a3, a4, a5, a6);
  if (!result)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
    int v15 = *(_DWORD *)(a1 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
    if ((v15 & 0x2000000) == 0)
    {
      if (a2 == 1684955501) {
        goto LABEL_10;
      }
LABEL_9:
      if (a2 == 1668506984)
      {
LABEL_10:
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
        int v16 = *(_DWORD *)(a1 + 115);
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
        if ((v16 & 0x40000000) != 0) {
          return 0;
        }
        else {
          return 4294959210;
        }
      }
      return 0;
    }
    uint64_t result = 4294959210;
    if (a2 <= 1819240306)
    {
      if (a2 <= 1684108402)
      {
        if (a2 == 1634952036) {
          return result;
        }
        goto LABEL_9;
      }
      if (a2 == 1684108403) {
        return result;
      }
      if (a2 == 1684955501) {
        goto LABEL_10;
      }
      int v17 = 1818321516;
LABEL_26:
      if (a2 == v17) {
        return result;
      }
      return 0;
    }
    if (a2 <= 1883333731)
    {
      if (a2 == 1819240307) {
        return result;
      }
      int v17 = 1836016740;
      goto LABEL_26;
    }
    if (a2 != 1883333732 && a2 != 1885895027)
    {
      int v17 = 1919251315;
      goto LABEL_26;
    }
  }
  return result;
}

uint64_t TFSInfo::GetDisplayName(TFSInfo *a1, uint64_t a2)
{
  TFSInfo::DisplayName(a1, &v5);
  uint64_t v3 = TPropertyReference::SetAs<TString>(a2, (TString **)&v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1D346B408(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<TString>(uint64_t a1, TString **a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_47;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_47;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_47;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_47;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_47;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_47;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_47;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_47;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_47;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_47;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_47;
      }
      uint64_t v3 = *(TString **)a1;
      if (v3 != (TString *)a2) {
        TString::SetStringRefAsImmutable(v3, *a2);
      }
      return 0;
    case 12:
      if (v2 != 12) {
        goto LABEL_47;
      }
      SetAsPriv<TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>((const void **)a2, *(CFTypeRef **)a1);
      return 0;
    case 13:
      if (v2 != 13) {
        goto LABEL_47;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_47;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_47;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_47;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_47;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_47;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_47;
      }
      TString v5 = *(CFTypeRef **)a1;
      return TPropertyValue::SetAs<TString>((uint64_t)v5, (TString *)a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_47;
    case 21:
      if (v2 != 21) {
        goto LABEL_47;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_47;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_47:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

CFTypeRef *SetAsPriv<TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(const void **a1, CFTypeRef *a2)
{
  uint64_t v3 = RetainCF<__CFString const*>(a1);
  if (v3)
  {
    CFTypeRef v4 = CFAutorelease(v3);
    TString v5 = static_cf_cast<__CFString const*,void const*>(v4);
  }
  else
  {
    TString v5 = 0;
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v5);
}

BOOL GetPropertyRecord(unsigned int a1, uint64_t a2)
{
  {
    operator new();
  }
  uint64_t v8 = a1;
  long long v9 = 0u;
  long long v10 = 0u;
  CFTypeRef v4 = std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::find<TPropertyRecord>((void *)GetPropertyRecord(Property,TPropertyRecord &)::records, (unsigned int *)&v8);
  if (v4)
  {
    long long v5 = *((_OWORD *)v4 + 1);
    long long v6 = *((_OWORD *)v4 + 2);
    *(void *)(a2 + 32) = v4[6];
    *(_OWORD *)a2 = v5;
    *(_OWORD *)(a2 + 16) = v6;
  }
  return v4 != 0;
}

void sub_1D346B6CC(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x10A0C404A63E237);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::find<TPropertyRecord>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  long long v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

TNodeRequest **NodeDisposeRequest(TNodeRequest *a1)
{
  int8x8_t v2 = a1;
  return TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&v2);
}

void NodeCreateNewRequest(OpaqueEventNotifier *a1)
{
  ClientNotifierFromNodeNotifier(a1, &v1);
  TNodeRequest::Make();
}

void sub_1D346B838(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

TNodeRequest **TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(TNodeRequest **a1)
{
  int8x8_t v2 = *a1;
  if (v2) {
    TNodeRequest::RemovePtrReference(v2);
  }
  return a1;
}

void ClientNotifierFromNodeNotifier(OpaqueEventNotifier *a1@<X0>, void *a2@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  long long v9 = a1;
  if (a1)
  {
    unint64_t v3 = NodeChangeNotifierRegistry();
    unint64_t v5 = v4;
    std::mutex::lock(v4);
    long long v6 = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(v3, &v9);
    if (v6)
    {
      uint64_t v7 = v6[4];
      *a2 = v6[3];
      a2[1] = v7;
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      unint64_t v8 = LogObj(5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134349056;
        int v11 = v9;
        _os_log_impl(&dword_1D343E000, v8, OS_LOG_TYPE_ERROR, "Requested client notifier for node notifier not being tracked: %{public}p", buf, 0xCu);
      }

      *a2 = 0;
      a2[1] = 0;
    }
    std::mutex::unlock(v5);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1D346B994(_Unwind_Exception *exception_object)
{
}

void TNodeRequest::Make()
{
}

void sub_1D346BA08(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x1020C403A6C1BAELL);
  _Unwind_Resume(a1);
}

void TNodeRequest::TNodeRequest(uint64_t a1)
{
  *(_DWORD *)a1 = 1;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  TNodePtr::TNodePtr(&v2, 0);
  TNodePtr::TNodePtr(&v1, 0);
  TDSNotifier::Make();
}

void sub_1D346BAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 16);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(a1);
}

void TDSNotifier::Make()
{
}

void sub_1D346BB4C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x10A0C40FAC576B1);
  _Unwind_Resume(a1);
}

uint64_t TDSNotifier::TDSNotifier(uint64_t a1, uint64_t *a2, id *a3, id *a4)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0x100000000;
  *(void *)(a1 + 53) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  if (v7)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    long long v9 = *(std::__shared_weak_count **)(a1 + 8);
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v7;
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
  }
  else
  {
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = 0;
  }
  objc_storeStrong((id *)(a1 + 16), *a3);
  objc_storeStrong((id *)(a1 + 24), *a4);
  *(void *)(a1 + 72) = 200000;
  return a1;
}

BOOL TNodeRequest::RemovePtrReference(TNodeRequest *this)
{
  BOOL result = TRefCount::Release<int>((unsigned int *)this);
  if (result)
  {
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)this + 3);
    unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    JUMPOUT(0x1D9436740);
  }
  return result;
}

const void **TFSInfo::SynchronizeNames(uint64_t a1, TFSInfo **a2, uint64_t **a3)
{
  TFSInfo::DisplayName((TFSInfo *)a1, &v11);
  TFSInfo::Name((TFSInfo *)a1, &v10);
  TFSInfo::Name(*a2, &v9);
  int v6 = CFEqual(v10.fString.fRef, v9.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
  if (!v6)
  {
    LODWORD(v10.fString.fRef) = 1886282093;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v10, &v10);
  }
  if (*(unsigned char *)(a1 + 112) != 18)
  {
    TFSInfo::DisplayName(*a2, &v10);
    int v7 = CFEqual(v11.fString.fRef, v10.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
    if (!v7)
    {
      LODWORD(v10.fString.fRef) = 1684955501;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, (unsigned int *)&v10, &v10);
    }
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
}

void sub_1D346BD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFSInfo::DisplayName(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  uint8x8_t v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  TFSInfo::GetDisplayNameWhileLocked(this, a2);
  os_unfair_lock_unlock(v4);
}

void sub_1D346BE18(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::GetDisplayNameWhileLocked(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  if (CFStringGetLength(*((CFStringRef *)this + 4)))
  {
    a2->fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, *((TString **)this + 4));
  }
  else if (CFStringGetLength(*((CFStringRef *)this + 3)))
  {
    a2->fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, *((TString **)this + 3));
  }
  else
  {
    uint8x8_t v4 = TString::KEmptyString(0);
    a2->fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, (TString *)*v4);
  }
}

void sub_1D346BECC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

__CFString *SanitizedStr(TString *a1)
{
  if (IsRedactionEnabled()
    && (AcceptableNames(),
        !std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::find<TString>(AcceptableNames(void)::sNames, a1)))
  {
    RedactedStr(a1, (TString *)&v4);
    TNodePtr v2 = (__CFString *)v4;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4);
  }
  else
  {
    TNodePtr v2 = a1->fString.fRef;
  }
  return v2;
}

TString *Description@<X0>(unsigned int a1@<W0>, TString *a2@<X8>)
{
  uint64_t v2 = a1;
  BOOL result = a2;
  switch(v2)
  {
    case 1:
      id v4 = "computer";
      goto LABEL_33;
    case 2:
      id v4 = "virtual folder";
      goto LABEL_19;
    case 3:
      id v4 = "virtual alias";
      goto LABEL_30;
    case 4:
      id v4 = "virtual document";
      goto LABEL_36;
    case 5:
      id v4 = "query alias";
      goto LABEL_38;
    case 6:
      id v4 = "query hits container";
      goto LABEL_24;
    case 7:
      id v4 = "query hit";
      unint64_t v5 = 9;
      return TString::TString(a2, v4, v5);
    case 8:
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
      __break(1u);
      return result;
    case 11:
      id v4 = "desktop";
      goto LABEL_27;
    case 12:
      id v4 = "trash";
      unint64_t v5 = 5;
      return TString::TString(a2, v4, v5);
    case 16:
      id v4 = "unresolved alias";
      goto LABEL_36;
    case 17:
      id v4 = "Devices";
      goto LABEL_27;
    case 18:
      id v4 = "Places";
      unint64_t v5 = 6;
      return TString::TString(a2, v4, v5);
    case 19:
      id v4 = "Saved Searches";
      goto LABEL_19;
    case 20:
      id v4 = "Published folders";
      unint64_t v5 = 17;
      return TString::TString(a2, v4, v5);
    case 21:
      id v4 = "Tags";
      unint64_t v5 = 4;
      return TString::TString(a2, v4, v5);
    case 22:
      id v4 = "All Tags";
LABEL_33:
      unint64_t v5 = 8;
      return TString::TString(a2, v4, v5);
    case 23:
      id v4 = "All Cloud Libraries";
      unint64_t v5 = 19;
      return TString::TString(a2, v4, v5);
    case 24:
      id v4 = "All Data Separated Cloud Libraries";
      unint64_t v5 = 34;
      return TString::TString(a2, v4, v5);
    case 25:
      id v4 = "Cloud Library";
      goto LABEL_30;
    case 26:
      id v4 = "File Provider Domains Container";
      unint64_t v5 = 31;
      return TString::TString(a2, v4, v5);
    case 27:
      id v4 = "File Provider Domain";
LABEL_24:
      unint64_t v5 = 20;
      return TString::TString(a2, v4, v5);
    case 28:
      id v4 = "File Provider v2 Item";
      unint64_t v5 = 21;
      return TString::TString(a2, v4, v5);
    case 29:
      id v4 = "iTunes devices container";
      unint64_t v5 = 24;
      return TString::TString(a2, v4, v5);
    case 30:
      id v4 = "iTunes device";
LABEL_30:
      unint64_t v5 = 13;
      return TString::TString(a2, v4, v5);
    case 31:
      id v4 = "Network nearby";
LABEL_19:
      unint64_t v5 = 14;
      return TString::TString(a2, v4, v5);
    case 32:
      id v4 = "Network sidebar";
      unint64_t v5 = 15;
      return TString::TString(a2, v4, v5);
    case 33:
      id v4 = "AirDrop";
LABEL_27:
      unint64_t v5 = 7;
      return TString::TString(a2, v4, v5);
    case 34:
      id v4 = "Recent Documents";
LABEL_36:
      unint64_t v5 = 16;
      return TString::TString(a2, v4, v5);
    case 35:
      id v4 = "iCloudDrive";
      goto LABEL_38;
    default:
      id v4 = "non virtual";
LABEL_38:
      unint64_t v5 = 11;
      return TString::TString(a2, v4, v5);
  }
}

void sub_1D346C1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  os_unfair_lock_unlock(v12);
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(a1);
}

void sub_1D346C410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18, id a19)
{
  _Unwind_Resume(a1);
}

unint64_t NodeNewChangeHandlerOnQueue(uint64_t a1, void *a2, void *a3)
{
  memset(v5, 0, sizeof(v5));
  TClientChangeNotifier::Make(v5, a1, 0, a3, a2, (uint64_t)&v6);
  unint64_t v3 = v6;
  AddToNodeChangeNotifierRegistry(v6, (uint64_t *)&v6);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  return v3;
}

void sub_1D346C4E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void TClientChangeNotifier::Make(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, void *a5@<X4>, uint64_t a6@<X8>)
{
  id v11 = a4;
  uint64_t v12 = a5;
  RegistrationLocuint64_t k = (TDSMutex *)TDSNotifier::GetRegistrationLock(v12);
  TDSMutex::lock(RegistrationLock);
  if (*a1)
  {
    int v14 = (void *)TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList;
    uint64_t v15 = qword_1EA6AC3B0;
    while (v14 != (void *)v15)
    {
      *(void *)a6 = 0;
      *(void *)(a6 + 8) = 0;
      int v16 = (std::__shared_weak_count *)v14[1];
      if (v16)
      {
        int v17 = std::__shared_weak_count::lock(v16);
        *(void *)(a6 + 8) = v17;
        if (v17)
        {
          char v18 = (void *)*v14;
          *(void *)a6 = *v14;
          if (v18 && v18[2] == *a1 && v18[5] == a2 && (id)v18[6] == v11) {
            goto LABEL_24;
          }
          std::__shared_weak_count::__release_shared[abi:ne180100](v17);
        }
      }
      v14 += 2;
    }
  }
  else
  {
    *a1 = ++TClientChangeNotifier::Make(NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::sListenerSerialID;
  }
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  unint64_t v19 = (std::__shared_weak_count *)operator new(0x90uLL);
  v19->__shared_owners_ = 0;
  v19->__shared_weak_owners_ = 0;
  v19->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9B20;
  long long v28 = *(_OWORD *)a1;
  uint64_t v29 = a1[2];
  TClientChangeNotifier::TClientChangeNotifier((uint64_t)&v19[1], v20, (uint64_t)&v28, a2, a3, v11, v12);
  shared_owners = (std::__shared_weak_count *)v19[1].__shared_owners_;
  if (!shared_owners)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v19[1].__vftable = (std::__shared_weak_count_vtbl *)&v19[1];
    v19[1].__shared_owners_ = (uint64_t)v19;
    goto LABEL_17;
  }
  if (shared_owners->__shared_owners_ == -1)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    v19[1].__vftable = (std::__shared_weak_count_vtbl *)&v19[1];
    v19[1].__shared_owners_ = (uint64_t)v19;
    std::__shared_weak_count::__release_weak(shared_owners);
LABEL_17:
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
  for (uint64_t i = v25; i != v26; i += 32)
  {
    uint64_t v23 = *(void *)(i + 24);
    if (!v23) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t))(*(void *)v23 + 48))(v23);
  }
  *(void *)a6 = v19 + 1;
  *(void *)(a6 + 8) = v19;
  *(void *)&long long v28 = &v25;
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v28);
  if (a2) {
    std::vector<std::weak_ptr<TClientChangeNotifier>>::emplace_back<std::shared_ptr<TClientChangeNotifier> &>(&TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList, (long long *)a6);
  }
LABEL_24:
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&v24);
}

void sub_1D346C72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
  int v16 = *(std::__shared_weak_count **)(v14 + 8);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&a12);

  _Unwind_Resume(a1);
}

void std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    id v4 = v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        id v4 = std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v4 - 4);
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::vector<std::weak_ptr<TClientChangeNotifier>>::emplace_back<std::shared_ptr<TClientChangeNotifier> &>(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  id v4 = a1 + 2;
  unint64_t v5 = v6;
  int v7 = (void *)*(v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v19[4] = v4;
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)v4, v13);
    uint64_t v15 = &v14[16 * v10];
    v19[0] = v14;
    v19[1] = v15;
    v19[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 16), 1uLL, memory_order_relaxed);
    }
    v19[2] = v15 + 16;
    std::vector<std::weak_ptr<TClientChangeNotifier>>::__swap_out_circular_buffer(a1, v19);
    TString v9 = (void *)a1[1];
    std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::~__split_buffer(v19);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 16), 1uLL, memory_order_relaxed);
    }
    TString v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return v9 - 2;
}

void sub_1D346C92C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::weak_ptr<TClientChangeNotifier>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t TClientChangeNotifier::TClientChangeNotifier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7)
{
  v18[4] = *MEMORY[0x1E4F143B8];
  id v12 = a6;
  id v13 = a7;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t v14 = *(void *)(a3 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
  *(void *)(a1 + 32) = v14;
  *(void *)(a1 + 40) = a4;
  id v15 = v12;
  *(void *)(a1 + 48) = v15;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 112) = 0;
  if (v13)
  {
    *(void *)(a1 + 88) = &unk_1F2ABAA80;
    *(void *)(a1 + 96) = MEMORY[0x1D9436FC0](v13);
    *(void *)(a1 + 112) = a1 + 88;
    v18[0] = &unk_1F2AB97F0;
  }
  else
  {
    v18[0] = &unk_1F2AB9798;
    v18[1] = a5;
  }
  v18[3] = v18;
  std::__function::__value_func<void ()(OpaqueEventQueue *)>::swap[abi:ne180100](v18, (void *)(a1 + 56));
  std::__function::__value_func<void ()(OpaqueEventQueue *)>::~__value_func[abi:ne180100](v18);
  uint64_t v16 = *(void (**)(void))(a1 + 24);
  if (v16 && *(void *)(a1 + 16)) {
    v16();
  }

  return a1;
}

void sub_1D346CAAC(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(FINodeEvent *)>::~__value_func[abi:ne180100](v5);
  std::__function::__value_func<void ()(OpaqueEventQueue *)>::~__value_func[abi:ne180100](v4);

  int v7 = *(std::__shared_weak_count **)(v1 + 8);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }

  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(OpaqueEventQueue *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(OpaqueEventQueue *)>::swap[abi:ne180100](void *result, void *a2)
{
  void v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    unint64_t v3 = result;
    id v4 = (void *)result[3];
    unint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        BOOL result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1D346CDD0(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::vector<std::weak_ptr<TClientChangeNotifier>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2AB97F0;
}

void AddToNodeChangeNotifierRegistry(unint64_t a1, uint64_t *a2)
{
  unint64_t v6 = a1;
  unint64_t v3 = NodeChangeNotifierRegistry();
  uint64_t v5 = v4;
  std::mutex::lock(v4);
  std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__emplace_multi<OpaqueEventNotifier *&,std::shared_ptr<TClientChangeNotifier> const&>(v3, &v6, a2);
  std::mutex::unlock(v5);
}

void sub_1D346CFA4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

long long *NodeChangeNotifierRegistry(void)
{
  {
    NodeChangeNotifierRegistry(void)::sRegistry = 0u;
    unk_1EA6AC240 = 0u;
    dword_1EA6AC250 = 1065353216;
  }
  return &NodeChangeNotifierRegistry(void)::sRegistry;
}

void *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__emplace_multi<OpaqueEventNotifier *&,std::shared_ptr<TClientChangeNotifier> const&>(void *a1, unint64_t *a2, uint64_t *a3)
{
  std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__construct_node<OpaqueEventNotifier *&,std::shared_ptr<TClientChangeNotifier> const&>((uint64_t)a1, a2, a3, (uint64_t)&v5);
  return std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__node_insert_multi(a1, v5);
}

void sub_1D346D060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__node_insert_multi(void *a1, void *a2)
{
  id v4 = a2 + 2;
  unint64_t v5 = a2[2];
  unint64_t v6 = HIDWORD(v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * v5) + 8) ^ HIDWORD(v5));
  unint64_t v8 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  a2[1] = v8;
  inserted = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__node_insert_multi_prepare((uint64_t)a1, v8, v4);
  std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_perform(a1, a2, inserted);
  return a2;
}

void *std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_perform(void *result, void *a2, void *a3)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(void *)(*result + 8 * v4) = result + 2;
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
LABEL_18:
    *(void *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
    if (v6 != v4) {
      goto LABEL_18;
    }
  }
LABEL_19:
  ++result[3];
  return result;
}

void *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  float v7 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    uint64_t v9 = 2 * v6;
    BOOL v10 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    size_t v11 = v10 | v9;
    unint64_t v12 = vcvtps_u32_f32(v7 / v8);
    if (v11 <= v12) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = v11;
    }
    std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__rehash<false>(a1, v13);
    unint64_t v6 = *(void *)(a1 + 8);
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v15 = a2;
    if (v6 <= a2) {
      unint64_t v15 = a2 % v6;
    }
  }
  else
  {
    unint64_t v15 = (v6 - 1) & a2;
  }
  uint64_t v16 = *(void **)(*(void *)a1 + 8 * v15);
  if (!v16) {
    return 0;
  }
  int v17 = 0;
  do
  {
    uint64_t result = v16;
    uint64_t v16 = (void *)*v16;
    if (!v16) {
      break;
    }
    unint64_t v19 = v16[1];
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v20 = v16[1];
      if (v19 >= v6) {
        unint64_t v20 = v19 % v6;
      }
    }
    else
    {
      unint64_t v20 = v19 & (v6 - 1);
    }
    if (v20 != v15) {
      break;
    }
    BOOL v21 = v19 == a2 && v16[2] == *a3;
    int v22 = v17 & !v21;
    v17 |= v21;
  }
  while (v22 != 1);
  return result;
}

void *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__construct_node<OpaqueEventNotifier *&,std::shared_ptr<TClientChangeNotifier> const&>@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t result = operator new(0x28uLL);
  *(void *)a4 = result;
  *(void *)(a4 + 8) = v7;
  void *result = 0;
  result[1] = 0;
  unint64_t v9 = *a2;
  uint64_t v11 = *a3;
  uint64_t v10 = a3[1];
  result[2] = *a2;
  result[3] = v11;
  result[4] = v10;
  if (v10)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    unint64_t v9 = result[2];
  }
  *(unsigned char *)(a4 + 16) = 1;
  unint64_t v12 = HIDWORD(v9);
  unint64_t v13 = 0x9DDFEA08EB382D69 * (((8 * v9) + 8) ^ HIDWORD(v9));
  result[1] = 0x9DDFEA08EB382D69
            * ((0x9DDFEA08EB382D69 * (v12 ^ (v13 >> 47) ^ v13)) ^ ((0x9DDFEA08EB382D69 * (v12 ^ (v13 >> 47) ^ v13)) >> 47));
  return result;
}

void std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__rehash<false>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__do_rehash<false>(a1, prime);
    }
  }
}

void *std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  float v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    unint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      for (uint64_t i = (void *)*v7; *v7; uint64_t i = (void *)*v7)
      {
        unint64_t v12 = i[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v12 >= a2) {
            v12 %= a2;
          }
        }
        else
        {
          v12 &= a2 - 1;
        }
        if (v12 == v8)
        {
          unint64_t v7 = i;
        }
        else
        {
          unint64_t v13 = i;
          if (*(void *)(*(void *)a1 + 8 * v12))
          {
            do
            {
              uint8x8_t v14 = v13;
              unint64_t v13 = (void *)*v13;
            }
            while (v13 && i[2] == v13[2]);
            void *v7 = v13;
            *uint8x8_t v14 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = i;
          }
          else
          {
            *(void *)(*(void *)a1 + 8 * v12) = v7;
            unint64_t v7 = i;
            unint64_t v8 = v12;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

const void **TNode::Path@<X0>(TNode *this@<X0>, CFTypeRef *a2@<X8>)
{
  TNode::GetPath(this, (uint64_t)v5);
  TString::TString(&v4, "", 0);
  fstd::optional_err<TString,int>::value_or<TString>((uint64_t)v5, (CFTypeRef *)&v4.fString.fRef, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
}

void sub_1D346D7A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  unint64_t v3 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2AB9798;
  a2[1] = v2;
  return result;
}

void __destroy_helper_block_ea8_32c114_ZTSKZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsE3__0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void sub_1D346D90C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

TString *TFSVolumeInfo::SystemBuildVersion(TFSVolumeInfo *this)
{
  uint64_t v1 = (TString *)((char *)this + 296);
  if (!*((unsigned char *)this + 304))
  {
    v21.fString.fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    std::optional<TString>::operator=[abi:ne180100]<TString,void>((uint64_t)v1, (const void **)&v21.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
    if (!*((unsigned char *)this + 127) && !*((unsigned char *)this + 108) && !*((unsigned char *)this + 48))
    {
      unsigned int v3 = *((_DWORD *)this + 18);
      if (v3 <= 0x14 && ((1 << v3) & 0x10000C) != 0)
      {
        TString v4 = (TFSInfo *)*((void *)this + 7);
        unint64_t v5 = (std::__shared_weak_count *)*((void *)this + 8);
        if (v5) {
          atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v6 = (void *)MEMORY[0x1E4F1CB10];
        TFSInfo::CFURL(v4, &v21);
        unint64_t v7 = NodeEventRefFromNodeEvent((id *)&v21.fString.fRef);
        unint64_t v8 = [v6 fileURLWithPath:@"System/Library/CoreServices/SystemVersion.plist" isDirectory:0 relativeToURL:v7];

        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v21.fString.fRef);
        uint8x8_t v9 = [MEMORY[0x1E4F1C9E8] dictionaryWithContentsOfURL:v8 error:0];
        if (v9)
        {
          unint64_t v10 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CD20]);
          uint64_t v11 = [v9 objectForKeyedSubscript:v10];
          objc_cast<NSString,objc_object * {__strong}>(v11);
          unint64_t v12 = (NSString *)objc_claimAutoreleasedReturnValue();

          TString::TString(&v21, v12);
          TString::Append(v1, &v21);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
          if (v12 && os_variant_has_internal_ui())
          {
            unint64_t v13 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CD10]);
            uint8x8_t v14 = [v9 objectForKeyedSubscript:v13];
            unint64_t v15 = (TString *)static_cf_cast<__CFString const*,void const*>(v14);

            TString::TString(&v19, " (", 2uLL);
            TString::TString(&v18, v15);
            TString::operator+((const __CFString **)&v19.fString.fRef, &v18, &v20);
            TString::TString(&v17, ")", 1uLL);
            TString::operator+((const __CFString **)&v20.fString.fRef, &v17, &v21);
            TString::Append(v1, &v21);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
          }
        }
        if (v5) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v5);
        }
      }
    }
  }
  return v1;
}

void sub_1D346DBA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  unint64_t v7 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint8x8_t v9 = va_arg(va2, const void *);
  va_copy(va3, va2);
  uint64_t v11 = va_arg(va3, const void *);
  va_copy(va4, va3);
  unint64_t v13 = va_arg(va4, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);

  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  _Unwind_Resume(a1);
}

uint64_t std::optional<TString>::operator=[abi:ne180100]<TString,void>(uint64_t a1, const void **a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if ((const void **)a1 != a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)a1, a2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
    }
  }
  else
  {
    std::construct_at[abi:ne180100]<TString,TString,TString*>((CFTypeRef *)a1, a2);
    *(unsigned char *)(a1 + 8) = 1;
  }
  return a1;
}

void TFSInfo::CFURL(TFSInfo *this@<X0>, void *a2@<X8>)
{
  TString v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v5 = (const void *)*((void *)this + 2);
  *a2 = v5;
  if (v5) {
    CFRetain(v5);
  }
  os_unfair_lock_unlock(v4);
}

void sub_1D346DD70(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TString::TString(TString *this, NSString *a2)
{
  unsigned int v3 = a2;
  this->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(this, v3);
}

void sub_1D346DDE0(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

id objc_cast<NSString,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void *AllowedPaths@<X0>(void *a1@<X8>)
{
  {
    AllowedPaths(void)::$_0::operator()();
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = AllowedPaths(void)::allowedPaths;
  uint64_t v3 = unk_1EC008E50;
  unint64_t v4 = (unk_1EC008E50 - AllowedPaths(void)::allowedPaths) >> 3;
  return std::vector<TString>::__init_with_size[abi:ne180100]<TString*,TString*>(a1, v2, v3, v4);
}

void sub_1D346DEE0(_Unwind_Exception *a1)
{
}

const void **AllowedPaths(void)::$_0::operator()()
{
  AllowedPaths(void)::allowedPaths = 0;
  unk_1EC008E50 = 0;
  qword_1EC008E58 = 0;
  CFErrorRef error = 0;
  SecTaskRef v0 = SecTaskCreateFromSelf(0);
  CFTypeRef cf = v0;
  if (v0)
  {
    CFTypeRef v24 = SecTaskCopyValueForEntitlement(v0, @"com.apple.security.exception.files.home-relative-path.read-write", &error);
    uint64_t v1 = (void *)cf_cast<__CFArray const*,void const*>(v24);
    if (v1)
    {
      id v2 = v1;
      IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)&obj, v2);
      IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor((uint64_t)theString, -1, v2);
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (obj != theString[0] || v37 != v28)
      {
        id v4 = *(id *)(v31 + 8 * v36);
        TString::TString(&v40, "/private/var/mobile", 0x13uLL);
        unint64_t v5 = (TString *)v4;
        v39.fString.fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v39, v5);

        fRef = v40.fString.fRef;
        v38.fString.fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        MutableCFStringRef Copy = CFStringCreateMutableCopy(v3, 0, fRef);
        CFRelease(&stru_1F2ABD380);
        v38.fString.fRef = MutableCopy;
        TString::Append(&v38, &v39);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40.fString.fRef);

        std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&v38.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);

        uint64_t v8 = v36;
        if (v36 >= v35 - 1)
        {
          uint64_t v9 = [obj countByEnumeratingWithState:&v30 objects:v33 count:4];
          uint64_t v8 = -1;
          uint64_t v35 = v9;
          uint64_t v36 = -1;
        }
        if (v34 != *v32)
        {
          objc_enumerationMutation(obj);
          uint64_t v8 = v36;
        }
        uint64_t v36 = v8 + 1;
        ++v37;
      }

      id v10 = v2;
      IDContainerIteratorAdaptor<NSArray>::NSForwardIterator<NSArray>::NSForwardIterator((uint64_t)&obj, v10);
      IDContainerIteratorAdaptor<NSArray>::IDContainerIteratorAdaptor((uint64_t)theString, -1, v10);
      while (obj != theString[0] || v37 != v28)
      {
        id v11 = *(id *)(v31 + 8 * v36);
        TString::TString(&v40, "/var/mobile", 0xBuLL);
        unint64_t v12 = (TString *)v11;
        v39.fString.fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v39, v12);

        unint64_t v13 = v40.fString.fRef;
        v38.fString.fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        uint8x8_t v14 = CFStringCreateMutableCopy(v3, 0, v13);
        CFRelease(&stru_1F2ABD380);
        v38.fString.fRef = v14;
        TString::Append(&v38, &v39);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v39.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40.fString.fRef);

        std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&v38.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);

        uint64_t v15 = v36;
        if (v36 >= v35 - 1)
        {
          uint64_t v16 = [obj countByEnumeratingWithState:&v30 objects:v33 count:4];
          uint64_t v15 = -1;
          uint64_t v35 = v16;
          uint64_t v36 = -1;
        }
        if (v34 != *v32)
        {
          objc_enumerationMutation(obj);
          uint64_t v15 = v36;
        }
        uint64_t v36 = v15 + 1;
        ++v37;
      }
    }
    TString v17 = CloudDocsRootURL();
    TString v18 = [v17 path];
    theString[0] = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)theString, v18);

    if (CFStringGetLength(theString[0]))
    {
      TString::TString((TString *)&obj, "/private/");
      BOOL v19 = TString::BeginsWith((TString *)theString, (const TString *)&obj);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
      TString::TString((TString *)&obj, "/private", 8uLL);
      if (v19)
      {
        CFIndex Length = CFStringGetLength((CFStringRef)obj);
        TString::SubStringFrom((TString *)theString, Length, &v40);
      }
      else
      {
        CFStringRef v21 = (const __CFString *)obj;
        v40.fString.fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        int v22 = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v21);
        CFRelease(&stru_1F2ABD380);
        v40.fString.fRef = v22;
        TString::Append(&v40, (const TString *)theString);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
      std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (TString **)theString);
      std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (TString **)&v40);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v40.fString.fRef);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)theString);
    TString::TString((TString *)&obj, "/private/var/mobile/Containers/Shared/AppGroup", 0x2EuLL);
    std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&obj);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
    TString::TString((TString *)&obj, "/var/mobile/Containers/Shared/AppGroup", 0x26uLL);
    std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&obj);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
    TString::TString((TString *)&obj, "/private/var/mobile/Library/LiveFiles", 0x25uLL);
    std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&obj);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
    TString::TString((TString *)&obj, "/var/mobile/Library/LiveFiles", 0x1DuLL);
    std::vector<TString>::push_back[abi:ne180100]((uint64_t)&AllowedPaths(void)::allowedPaths, (CFTypeRef *)&obj);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&obj);
    TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&v24);
  }
  return TRef<__SecTask *,CFRetainReleasePolicy>::~TRef(&cf);
}

void sub_1D346E4C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, const void *a11, uint64_t a12, const void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,const void *a30)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v31 - 96));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a30);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a13);
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&a10);
  TRef<__SecTask *,CFRetainReleasePolicy>::~TRef(&a11);
  *(void *)(v31 - 96) = v30;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100]((void ***)(v31 - 96));
  _Unwind_Resume(a1);
}

TString *TString::Append(TString *this, const TString *a2)
{
  if (CFStringGetLength(this->fString.fRef)) {
    goto LABEL_5;
  }
  unsigned int IsMutable = (unsigned __int16)TString::IsMutable((TString *)this->fString.fRef, v4);
  if (IsMutable <= 0x100) {
    LOBYTE(IsMutable) = 0;
  }
  if ((_BYTE)IsMutable)
  {
LABEL_5:
    uint64_t v6 = (__CFString *)TString::MutableRef(this, v4);
    CFStringAppend(v6, a2->fString.fRef);
  }
  else
  {
    MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, a2->fString.fRef);
    if (this->fString.fRef) {
      CFRelease(this->fString.fRef);
    }
    this->fString.fRef = MutableCopy;
  }
  return this;
}

const void *TString::MutableRef(TString *this, const __CFString *a2)
{
  unsigned int IsMutable = (unsigned __int16)TString::IsMutable((TString *)this->fString.fRef, a2);
  if (IsMutable <= 0x100) {
    LOBYTE(IsMutable) = 0;
  }
  fRef = this->fString.fRef;
  if (!(_BYTE)IsMutable)
  {
    fRef = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, this->fString.fRef);
    if (this->fString.fRef) {
      CFRelease(this->fString.fRef);
    }
    this->fString.fRef = fRef;
  }
  return static_cf_cast<__CFString const*,void const*>(fRef);
}

uint64_t std::vector<TString>::push_back[abi:ne180100](uint64_t a1, CFTypeRef *a2)
{
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v4 = a1 + 16;
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *(void *)a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - *(void *)a1;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      uint8x8_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    }
    else {
      uint8x8_t v14 = 0;
    }
    uint64_t v15 = v14;
    uint64_t v16 = (CFTypeRef *)&v14[8 * v10];
    TString v18 = &v14[8 * v13];
    std::construct_at[abi:ne180100]<TString,TString,TString*>(v16, a2);
    TString v17 = v16 + 1;
    std::vector<TString>::__swap_out_circular_buffer((CFTypeRef *)a1, &v15);
    unint64_t v9 = *(void *)(a1 + 8);
    uint64_t result = std::__split_buffer<TString>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t result = (uint64_t)std::construct_at[abi:ne180100]<TString,TString,TString*>(*(CFTypeRef **)(v4 - 8), a2);
    unint64_t v9 = v7 + 8;
    *(void *)(a1 + 8) = v7 + 8;
  }
  *(void *)(a1 + 8) = v9;
  return result;
}

void sub_1D346E8A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TString>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

CFTypeRef *std::vector<TString>::__swap_out_circular_buffer(CFTypeRef *result, void *a2)
{
  CFAllocatorRef v3 = (uint64_t *)result;
  unint64_t v5 = (CFTypeRef *)*result;
  uint64_t v4 = (CFTypeRef *)result[1];
  unint64_t v6 = (CFTypeRef *)a2[1];
  while (v4 != v5)
    uint64_t result = std::construct_at[abi:ne180100]<TString,TString,TString*>(--v6, --v4);
  a2[1] = v6;
  uint64_t v7 = *v3;
  *CFAllocatorRef v3 = (uint64_t)v6;
  a2[1] = v7;
  uint64_t v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

CFTypeRef *std::construct_at[abi:ne180100]<TString,TString,TString*>(CFTypeRef *a1, CFTypeRef *a2)
{
  *a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
  return a1;
}

uint64_t std::__split_buffer<TString>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

unint64_t UserDefaultsKey_(const __CFString *a1)
{
  CFPropertyListRef v4 = CFPreferencesCopyAppValue(a1, @"com.apple.desktopservices");
  CFStringRef v1 = (const __CFString *)cf_cast<__CFString const*,void const*>(v4);
  unint64_t v2 = (unint64_t)v1;
  if (v1) {
    unint64_t v2 = CFStringCompare(v1, @"true", 1uLL) == kCFCompareEqualTo
  }
      || CFStringCompare((CFStringRef)v2, @"1", 1uLL) == kCFCompareEqualTo
      || CFStringCompare((CFStringRef)v2, @"YES", 1uLL) == kCFCompareEqualTo;
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&v4);
  return v2;
}

void sub_1D346EA88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(const void **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void *cf_cast<__CFString const*,void const*>(const void *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }
    else
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFStringGetTypeID()) {
        return v1;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t std::vector<TString>::push_back[abi:ne180100](uint64_t a1, TString **a2)
{
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v4 = a1 + 16;
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *(void *)a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - *(void *)a1;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      uint8x8_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    }
    else {
      uint8x8_t v14 = 0;
    }
    uint64_t v15 = v14;
    uint64_t v16 = (TString *)&v14[8 * v10];
    TString v18 = &v14[8 * v13];
    std::construct_at[abi:ne180100]<TString,TString const&,TString*>(v16, a2);
    TString v17 = v16 + 1;
    std::vector<TString>::__swap_out_circular_buffer((CFTypeRef *)a1, &v15);
    unint64_t v9 = *(void *)(a1 + 8);
    uint64_t result = std::__split_buffer<TString>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t result = (uint64_t)std::construct_at[abi:ne180100]<TString,TString const&,TString*>(*(TString **)(v4 - 8), a2);
    unint64_t v9 = v7 + 8;
    *(void *)(a1 + 8) = v7 + 8;
  }
  *(void *)(a1 + 8) = v9;
  return result;
}

void sub_1D346EC20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void TString::SubStringFrom(TString *this@<X0>, uint64_t a2@<X1>, TString *a3@<X8>)
{
  if (a2 == -1) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = a2;
  }
  uint64_t v6 = CFStringGetLength(this->fString.fRef) - v5;
  TString::SubString(this, v5, v6, a3);
}

const void **TRef<__SecTask *,CFRetainReleasePolicy>::~TRef(const void **a1)
{
  CFTypeID v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void *cf_cast<__CFArray const*,void const*>(const void *result)
{
  if (result)
  {
    CFStringRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }
    else
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFArrayGetTypeID()) {
        return v1;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

id CloudDocsRootURL(void)
{
  id v3 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3321888768;
  v4[2] = ___ZZ16CloudDocsRootURLvENK3__0cvU13block_pointerFvP5NSURLP7NSErrorEEv_block_invoke;
  v4[3] = &__block_descriptor_40_ea8_32c30_ZTSKZ16CloudDocsRootURLvE3__0_e27_v24__0__NSURL_8__NSError_16l;
  v4[4] = &v3;
  SecTaskRef v0 = (void *)MEMORY[0x1D9436FC0](v4);
  BRGetCloudDocsRootURL();

  id v1 = v3;
  return v1;
}

void sub_1D346EDD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_1D346EEE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D346F318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)(v15 - 240));

  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSString *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D346F4A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D346F568(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfoSynchronizer::FetchChildren(uint64_t a1, uint64_t a2, const __CFString *a3, uint64_t a4)
{
  v142[125] = *(const void **)MEMORY[0x1E4F143B8];
  unsigned __int8 v133 = a3;
  uint64_t v6 = (TFSInfo **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 32);
  if (!v5) {
    return 0;
  }
  unsigned __int8 v132 = *(unsigned char *)(v5 + 112);
  if (v132 == 26)
  {
    int v22 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 24));
    uint64_t NotifierList = TNode::GetNotifierList(v22);
    uint64_t v25 = *(void *)(NotifierList + 24);
    CFTypeRef v24 = *(std::__shared_weak_count **)(NotifierList + 32);
    if (v24) {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_lock((os_unfair_lock_t)v25);
    id v26 = *(id *)(v25 + 8);
    os_unfair_lock_unlock((os_unfair_lock_t)v25);
    if (v24) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v24);
    }
    if (([v26 populated] & 1) == 0)
    {
      uint64_t v71 = LogObj(4);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v140.f_bsize) = 0;
        _os_log_impl(&dword_1D343E000, v71, OS_LOG_TYPE_DEBUG, "FPProviders not fetched", (uint8_t *)&v140, 2u);
      }

      return 4294959279;
    }
    long long v128 = [v26 providers];
    *(void *)__dst = 0x4008000000000000;
    v140.unsigned int f_bavail = 0;
    TNode::RootFPItemsForDomainsWithTimeout(v128, (double *)__dst, (uint64_t)&v140, (uint64_t)theArray);
    std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::~__value_func[abi:ne180100](&v140);
    v126[0] = (uint64_t)&v128;
    v126[1] = (uint64_t)theArray;
    iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::begin((uint64_t)v126, (uint64_t)&v140);
    iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::end((uint64_t)v126, (uint64_t)__dst);
    while (1)
    {
      uint64_t v27 = *(void **)&v140.f_bsize;
      if (*(void *)&v140.f_bsize == *(void *)__dst && *(const void **)&v140.f_mntonname[40] == v142[13]) {
        break;
      }
      if (*(const void **)&v140.f_mntonname[48] == v142[14])
      {
        uint64_t v27 = *(void **)__dst;
        break;
      }
      id v28 = *(id *)(v140.f_bfree + 8 * *(void *)&v140.f_mntonname[32]);
      uint64_t v29 = *(void *)&v140.f_mntonname[48];
      char v124 = +[FIProviderDomain providerDomainForDomain:v28];
      v134[0] = 0;
      fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::value_or<decltype(nullptr)>(v29);
      v123 = (FPItem *)objc_claimAutoreleasedReturnValue();
      unsigned __int8 v122 = 0;
      std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},FPItem * {__strong},BOOL,void>(&v124, &v123, &v122, &v125);

      uint64_t v31 = *(_OWORD **)(a1 + 8);
      unint64_t v30 = *(void *)(a1 + 16);
      if ((unint64_t)v31 >= v30)
      {
        uint64_t v32 = ((uint64_t)v31 - *(void *)a1) >> 4;
        unint64_t v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 60) {
          std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v34 = v30 - *(void *)a1;
        if (v34 >> 3 > v33) {
          unint64_t v33 = v34 >> 3;
        }
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v35 = v33;
        }
        uint64_t v137 = a1 + 16;
        uint64_t v36 = (TFSInfo *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(a1 + 16, v35);
        uint64_t v37 = (TFSInfo *)((char *)v36 + 16 * v32);
        v134[0] = v36;
        v134[1] = v37;
        id v136 = (char *)v36 + 16 * v38;
        *(_OWORD *)uint64_t v37 = v125;
        long long v125 = 0uLL;
        id v135 = (char *)v37 + 16;
        std::vector<std::shared_ptr<TFSInfo>>::__swap_out_circular_buffer((uint64_t *)a1, v134);
        uint64_t v39 = *(void *)(a1 + 8);
        std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)v134);
        TString v40 = (std::__shared_weak_count *)*((void *)&v125 + 1);
        *(void *)(a1 + 8) = v39;
        if (v40) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v40);
        }
      }
      else
      {
        _OWORD *v31 = v125;
        *(void *)(a1 + 8) = v31 + 1;
      }

      iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::operator++((uint64_t)&v140);
    }

    *(void *)&v140.__int16 f_bsize = theArray;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v140);

    return 0;
  }
  if (v132)
  {
    TNodePtr v41 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 24));
    if (TNode::IsFPv2(v41, 1))
    {
      uint64_t v42 = TNodeFromFINode(*(FINode **)(a1 + 24));
      uint64_t v43 = TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(v42 + 56));
      long long v120 = 0u;
      long long v121 = 0u;
      long long v118 = 0u;
      long long v119 = 0u;
      TString v44 = [v43 fpItems];
      uint64_t v45 = [v44 countByEnumeratingWithState:&v118 objects:v139 count:16];
      if (v45)
      {
        uint64_t v46 = *(void *)v119;
        do
        {
          for (uint64_t i = 0; i != v45; ++i)
          {
            if (*(void *)v119 != v46) {
              objc_enumerationMutation(v44);
            }
            char v48 = *(FPItem **)(*((void *)&v118 + 1) + 8 * i);
            if (([(FPItem *)v48 isTrashed] & 1) == 0)
            {
              _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v140);
              if (!TFSInfo::Initialize(*(TFSInfo **)&v140.f_bsize, v48, 0)) {
                std::vector<std::shared_ptr<TFSInfo>>::push_back[abi:ne180100]((uint64_t *)a1, (long long *)&v140);
              }
              if (v140.f_blocks) {
                std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v140.f_blocks);
              }
            }
          }
          uint64_t v45 = [v44 countByEnumeratingWithState:&v118 objects:v139 count:16];
        }
        while (v45);
      }
    }
    else if (v132 - 23 > 1)
    {
      char v72 = (TFSInfo *)TFSInfo::CopySFBrowserRef(*v6);
      v134[0] = v72;
      if (v72 && TFSInfo::IsBrowserOpen(v72))
      {
        CFArrayRef v73 = (const __CFArray *)SFBrowserCopyChildren();
        theArray[0] = v73;
        if (v73)
        {
          CFIndex Count = CFArrayGetCount(v73);
          std::vector<std::shared_ptr<TFSInfo>>::reserve((uint64_t *)a1, Count);
          if (Count >= 1)
          {
            for (CFIndex j = 0; j != Count; ++j)
            {
              v126[0] = 0;
              v126[0] = (uint64_t)CFArrayGetValueAtIndex(theArray[0], j);
              if (v126[0])
              {
                std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType const&,__SFNode *&,void>((char *)&v132, v126, __dst);
                TFSInfo::MarkAsUsed(*(TFSInfo **)__dst);
                TString v77 = *(_OWORD **)(a1 + 8);
                unint64_t v76 = *(void *)(a1 + 16);
                if ((unint64_t)v77 >= v76)
                {
                  uint64_t v78 = ((uint64_t)v77 - *(void *)a1) >> 4;
                  unint64_t v79 = v78 + 1;
                  if ((unint64_t)(v78 + 1) >> 60) {
                    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
                  }
                  uint64_t v80 = v76 - *(void *)a1;
                  if (v80 >> 3 > v79) {
                    unint64_t v79 = v80 >> 3;
                  }
                  if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v81 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v81 = v79;
                  }
                  v140.f_files = a1 + 16;
                  __int16 v82 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(a1 + 16, v81);
                  v83 = &v82[16 * v78];
                  *(void *)&v140.__int16 f_bsize = v82;
                  v140.unsigned int f_blocks = (uint64_t)v83;
                  v140.unsigned int f_bavail = (uint64_t)&v82[16 * v84];
                  *(_OWORD *)v83 = *(_OWORD *)__dst;
                  memset(__dst, 0, sizeof(__dst));
                  v140.f_bfree = (uint64_t)(v83 + 16);
                  std::vector<std::shared_ptr<TFSInfo>>::__swap_out_circular_buffer((uint64_t *)a1, &v140);
                  uint64_t v85 = *(void *)(a1 + 8);
                  std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)&v140);
                  uint64_t v86 = *(std::__shared_weak_count **)&__dst[8];
                  *(void *)(a1 + 8) = v85;
                  if (v86) {
                    std::__shared_weak_count::__release_shared[abi:ne180100](v86);
                  }
                }
                else
                {
                  _OWORD *v77 = *(_OWORD *)__dst;
                  *(void *)(a1 + 8) = v77 + 1;
                }
              }
            }
          }
        }
        TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)theArray);
      }
      TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)v134);
    }
    else if (ICloudDriveFPFSEnabled())
    {
      uint64_t v64 = TNodeFromFINode(*(FINode **)(a1 + 24));
      char v65 = TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(v64 + 56));
      long long v116 = 0u;
      long long v117 = 0u;
      long long v114 = 0u;
      long long v115 = 0u;
      int v66 = [v65 fpItems];
      uint64_t v67 = [v66 countByEnumeratingWithState:&v114 objects:v138 count:16];
      if (v67)
      {
        uint64_t v68 = *(void *)v115;
        do
        {
          for (uint64_t k = 0; k != v67; ++k)
          {
            if (*(void *)v115 != v68) {
              objc_enumerationMutation(v66);
            }
            uint64_t v70 = *(FPItem **)(*((void *)&v114 + 1) + 8 * k);
            _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v140);
            if (!TFSInfo::Initialize(*(TFSInfo **)&v140.f_bsize, v70, 1)) {
              std::vector<std::shared_ptr<TFSInfo>>::push_back[abi:ne180100]((uint64_t *)a1, (long long *)&v140);
            }
            if (v140.f_blocks) {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v140.f_blocks);
            }
          }
          uint64_t v67 = [v66 countByEnumeratingWithState:&v114 objects:v138 count:16];
        }
        while (v67);
      }
    }
    return 0;
  }
  if (a2)
  {
    unsigned int v7 = TFSInfo::CopyPathToCBuffer((TFSInfo *)v5, __dst, 1024);
    if (!v7)
    {
      uint64_t v8 = opendir(__dst);
      if (v8)
      {
        statfs(__dst, &v140);
        strlcat(__dst, "/", 0x400uLL);
        *__error() = 0;
        for (m = readdir(v8); m; m = readdir(v8))
        {
          LOBYTE(v126[0]) = 0;
          LOBYTE(v125) = 0;
          unsigned int d_type = m->d_type;
          if (d_type > 0xE) {
            goto LABEL_16;
          }
          if (((1 << d_type) & 0x5047) == 0)
          {
            if (d_type != 4)
            {
              LOBYTE(v125) = d_type == 10;
LABEL_16:
              std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,std::shared_ptr<TFSInfo> &,char (&)[1024],char (&)[1024],fsid &,unsigned long long &,BOOL &,BOOL &,BOOL &,void>((os_unfair_lock_s **)v6, __dst, m->d_name, (uint64_t *)&v140.f_fsid, (uint64_t *)m, &v133, (unsigned __int8 *)v126, theArray, (char *)&v125);
              uint64_t v12 = *(_OWORD **)(a1 + 8);
              unint64_t v11 = *(void *)(a1 + 16);
              if ((unint64_t)v12 >= v11)
              {
                uint64_t v13 = ((uint64_t)v12 - *(void *)a1) >> 4;
                unint64_t v14 = v13 + 1;
                if ((unint64_t)(v13 + 1) >> 60) {
                  std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v15 = v11 - *(void *)a1;
                if (v15 >> 3 > v14) {
                  unint64_t v14 = v15 >> 3;
                }
                if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v16 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v16 = v14;
                }
                uint64_t v137 = a1 + 16;
                TString v17 = (TFSInfo *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(a1 + 16, v16);
                TString v18 = (TFSInfo *)((char *)v17 + 16 * v13);
                v134[0] = v17;
                v134[1] = v18;
                id v136 = (char *)v17 + 16 * v19;
                *(_OWORD *)TString v18 = *(_OWORD *)theArray;
                theArray[0] = 0;
                theArray[1] = 0;
                id v135 = (char *)v18 + 16;
                std::vector<std::shared_ptr<TFSInfo>>::__swap_out_circular_buffer((uint64_t *)a1, v134);
                uint64_t v20 = *(void *)(a1 + 8);
                std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)v134);
                CFStringRef v21 = (std::__shared_weak_count *)theArray[1];
                *(void *)(a1 + 8) = v20;
                if (v21) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v21);
                }
              }
              else
              {
                *uint64_t v12 = *(_OWORD *)theArray;
                *(void *)(a1 + 8) = v12 + 1;
              }
              goto LABEL_10;
            }
            LOBYTE(v126[0]) = 1;
            if (strcmp(m->d_name, ".") && strcmp(m->d_name, "..")) {
              goto LABEL_16;
            }
          }
LABEL_10:
          *__error() = 0;
        }
        closedir(v8);
        unsigned int v7 = -8086;
      }
      else
      {
        long long v109 = __error();
        unsigned int v112 = TCFURLInfo::TranslateXAttrError(*v109, v110, v111);
        if (v112 == -5000) {
          unsigned int v7 = 0;
        }
        else {
          unsigned int v7 = v112;
        }
      }
    }
    goto LABEL_138;
  }
  if (!TFSInfo::IsDataless((TFSInfo *)v5, a2, a3)) {
    goto LABEL_110;
  }
  long long v50 = NewFileCoordinator();
  dispatch_time_t v51 = dispatch_time(0, 10000000000);
  id v52 = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN19TFSInfoSynchronizer13FetchChildrenEbb12LSProperties_block_invoke;
  block[3] = &__block_descriptor_40_ea8_32c65_ZTSKZN19TFSInfoSynchronizer13FetchChildrenEbb12LSPropertiesE3__0_e5_v8__0l;
  id v53 = v50;
  id v131 = v53;
  dispatch_after(v51, v52, block);

  __int16 v54 = *v6;
  id v55 = (os_unfair_lock_s *)((char *)*v6 + 100);
  os_unfair_lock_lock(v55);
  __int16 v56 = (const void *)*((void *)v54 + 2);
  *(void *)&v140.__int16 f_bsize = v56;
  if (v56) {
    CFRetain(v56);
  }
  os_unfair_lock_unlock(v55);
  CFIndex v57 = (CFIndex)*(id *)&v140.f_bsize;
  id v129 = 0;
  [v53 coordinateReadingItemAtURL:v57 options:1 error:&v129 byAccessor:&__block_literal_global_4];
  __int16 v58 = (TCFURLInfo *)v129;

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v140);
  if (!v58) {
    goto LABEL_108;
  }
  id v59 = LogObj(4);
  if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
  {
    v140.__int16 f_bsize = 138412290;
    *(void *)&v140.f_iostd::string::size_type size = v58;
    _os_log_impl(&dword_1D343E000, v59, OS_LOG_TYPE_ERROR, "Synchronizer coordinateReadingItemAtURL error: %@", (uint8_t *)&v140, 0xCu);
  }

  TFSInfo::InitializeAndGetPath((uint64_t *)__dst, *v6);
  id v60 = (const char *)TString::c_str((TString *)__dst);
  CFIndex v57 = stat(v60, (stat *)&v140);
  int v61 = *(_DWORD *)&v140.f_mntonname[28];
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)__dst);
  if (!v57 && (v61 & 0x40000000) != 0)
  {
    CFIndex v57 = TCFURLInfo::TranslateCFError(v58, v62);
    char v63 = 0;
  }
  else
  {
LABEL_108:
    char v63 = 1;
  }

  if (v63)
  {
LABEL_110:
    uint64_t v87 = *v6;
    uint64_t v88 = (os_unfair_lock_s *)((char *)*v6 + 100);
    os_unfair_lock_lock(v88);
    uint64_t v89 = (const void *)*((void *)v87 + 2);
    *(void *)&v140.__int16 f_bsize = v89;
    if (v89) {
      CFRetain(v89);
    }
    os_unfair_lock_unlock(v88);
    uint64_t v91 = *(void *)&v140.f_bsize;
    if (a4) {
      uint64_t v92 = TFSInfo::IterationInfoPropertyKeys(v90);
    }
    else {
      uint64_t v92 = TFSInfo::IterationFullSetOfPropertyKeys(v90);
    }
    uint64_t v93 = v92;
    int v94 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 24));
    unint64_t v95 = TNode::GetFIProvider(v94);
    TFSIterator::TFSIterator(__dst, v91, v93, a4, v95 != 0);

    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v140);
    do
    {
      _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(v134);
      unsigned int v7 = TFSIterator::Next((uint64_t)__dst, (uint64_t *)v134);
      if (!v7)
      {
        int v96 = v134[0];
        unsigned int v97 = (os_unfair_lock_s *)((char *)v134[0] + 100);
        os_unfair_lock_lock((os_unfair_lock_t)v134[0] + 25);
        unint64_t v98 = *(unsigned int *)((char *)v96 + 115) | ((unint64_t)*(unsigned __int16 *)((char *)v96 + 119) << 32);
        os_unfair_lock_unlock(v97);
        if ((v98 & 0x20000000000) != 0)
        {
          v140.unsigned int f_blocks = 0;
          *(void *)&v140.__int16 f_bsize = 0;
          TFSInfo::Fetch(v134[0], (TFSInfo **)&v140, 1);
          if (v140.f_blocks) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v140.f_blocks);
          }
        }
        uint64_t v100 = *(_OWORD **)(a1 + 8);
        unint64_t v99 = *(void *)(a1 + 16);
        if ((unint64_t)v100 >= v99)
        {
          uint64_t v102 = ((uint64_t)v100 - *(void *)a1) >> 4;
          if ((unint64_t)(v102 + 1) >> 60) {
            std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v103 = v99 - *(void *)a1;
          uint64_t v104 = v103 >> 3;
          if (v103 >> 3 <= (unint64_t)(v102 + 1)) {
            uint64_t v104 = v102 + 1;
          }
          if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v105 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v105 = v104;
          }
          v140.f_files = a1 + 16;
          __int16 v106 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(a1 + 16, v105);
          char v107 = &v106[16 * v102];
          *(void *)&v140.__int16 f_bsize = v106;
          v140.unsigned int f_blocks = (uint64_t)v107;
          v140.unsigned int f_bavail = (uint64_t)&v106[16 * v108];
          *(_OWORD *)char v107 = *(_OWORD *)v134;
          v134[0] = 0;
          v134[1] = 0;
          v140.f_bfree = (uint64_t)(v107 + 16);
          std::vector<std::shared_ptr<TFSInfo>>::__swap_out_circular_buffer((uint64_t *)a1, &v140);
          v101 = *(_OWORD **)(a1 + 8);
          std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)&v140);
        }
        else
        {
          *uint64_t v100 = *(_OWORD *)v134;
          v101 = v100 + 1;
          v134[0] = 0;
          v134[1] = 0;
          *(void *)(a1 + 8) = v101;
        }
        *(void *)(a1 + 8) = v101;
      }
      if (v134[1]) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v134[1]);
      }
    }
    while (!v7);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(v142);
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)&__dst[8]);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)__dst);
LABEL_138:
    if (v7 == -1417) {
      return 0;
    }
    else {
      return v7;
    }
  }
  return v57;
}

void sub_1D34701C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,const void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,const void *a47)
{
}

void sub_1D3470498(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::shared_ptr<TFSInfo>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<TFSInfo>>,std::reverse_iterator<std::shared_ptr<TFSInfo>*>,std::reverse_iterator<std::shared_ptr<TFSInfo>*>,std::reverse_iterator<std::shared_ptr<TFSInfo>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<TFSInfo>>,std::reverse_iterator<std::shared_ptr<TFSInfo>*>,std::reverse_iterator<std::shared_ptr<TFSInfo>*>,std::reverse_iterator<std::shared_ptr<TFSInfo>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TFSInfo>>,std::reverse_iterator<std::shared_ptr<TFSInfo>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TFSInfo>>,std::reverse_iterator<std::shared_ptr<TFSInfo>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},FPItem * {__strong},BOOL,void>@<X0>(FIProviderDomain **a1@<X1>, FPItem **a2@<X2>, unsigned __int8 *a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = (char *)operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},FPItem * {__strong},BOOL,std::allocator<TFSInfo>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1D347064C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},FPItem * {__strong},BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, FPItem **a3, unsigned __int8 *a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), *a2, *a3, *a4);
  return a1;
}

void sub_1D34706B4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

id fstd::optional_err<FPItem * {__strong},NSError * {__strong}>::value_or<decltype(nullptr)>(uint64_t a1)
{
  if (*(void *)(a1 + 8)) {
    id v1 = 0;
  }
  else {
    id v1 = *(id *)a1;
  }
  return v1;
}

uint64_t iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::operator++(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if (v2 >= *(void *)(a1 + 112) - 1)
  {
    uint64_t v3 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    uint64_t v2 = -1;
    *(void *)(a1 + 112) = v3;
    *(void *)(a1 + 120) = -1;
  }
  if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
  {
    objc_enumerationMutation(*(id *)a1);
    uint64_t v2 = *(void *)(a1 + 120);
  }
  uint64_t v4 = *(void *)(a1 + 136);
  uint64_t v5 = *(void *)(a1 + 128) + 1;
  *(void *)(a1 + 120) = v2 + 1;
  *(void *)(a1 + 128) = v5;
  *(void *)(a1 + 136) = v4 + 16;
  return a1;
}

void sub_1D34707E0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::begin(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v5, **(void ***)a1);
  uint64_t v4 = **(void ***)(a1 + 8);
  IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>::NSForwardIterator<NSArray<FPProviderDomain *>>::NSForwardIterator((uint64_t)v6, (uint64_t)v5);
  v6[17] = v4;
  iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<FPProviderDomain *> * {__strong}&,std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>> &>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<FPProviderDomain *>>,std::__wrap_iter<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>*>>,std::tuple<objc_object * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>&>>::ZipIterator(a2, (uint64_t)v6);
}

void sub_1D347087C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id TChildrenList::GetCollectionStatusObserver(TChildrenList *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TChildrenList::InternalLock(this);
  os_unfair_lock_lock(v2);
  id v3 = *((id *)this + 13);
  os_unfair_lock_unlock(v2);
  return v3;
}

int *TChildrenList::InternalLock(TChildrenList *this)
{
  {
    TChildrenList::InternalLock(void)::sChildrenListsLocuint64_t k = 0;
  }
  return &TChildrenList::InternalLock(void)::sChildrenListsLock;
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<NSString *>>>(uint64_t a1, uint64_t a2)
{
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator((uint64_t)v7, a2);
  uint64_t v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    uint64_t v4 = v12;
    if (v12 >= v11 - 1)
    {
      uint64_t v5 = [obj countByEnumeratingWithState:v9 objects:v10 count:4];
      uint64_t v4 = -1;
      uint64_t v11 = v5;
      uint64_t v12 = -1;
    }
    if (v10[4] != *(void *)v9[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v4 = v12;
    }
    uint64_t v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1D3470A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  uint64_t v5 = (void *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  uint64_t v6 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 128) = -1;
  if (v4 && [v4 count] && (uint64_t v7 = *(void *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    uint64_t v8 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    uint64_t *v6 = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v9 = *(void *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            void *v5 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            uint64_t v11 = -1;
            uint64_t *v6 = -1;
          }
          if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            uint64_t v11 = *v6;
          }
          uint64_t v13 = *(void *)(a1 + 128) + 1;
          *(void *)(a1 + 120) = ++v11;
          *(void *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(void *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(void *)(a1 + 120) = *(void *)(a2 + 120);
      *(void *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1D3470BB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id type_traits_extras::CopyAsHelper<NSMutableArray<FPProviderDomain *> * {__strong}>::MakeWithCapacity(uint64_t a1)
{
  id v1 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:a1];
  return v1;
}

void sub_1D3470D08(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

TDSNotifier **___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = *(TDSNotifier **)(a1 + 32);
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v2);
}

void TFSInfoOverflow::~TFSInfoOverflow(TFSInfoOverflow *this)
{
  int v2 = *((unsigned __int8 *)this + 76);
  if (v2 == 2) {
    goto LABEL_7;
  }
  if (v2 == 1)
  {

LABEL_7:
    goto LABEL_8;
  }
  if (!*((unsigned char *)this + 76))
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 1);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
LABEL_8:

  std::unique_ptr<TFileDescriptor>::reset[abi:ne180100]((TFileDescriptor **)this + 7, 0);
  uint64_t v4 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v4) {
    MEMORY[0x1D9436740](v4, 0x1000C40E0EAB150);
  }
}

TFileDescriptor *std::unique_ptr<TFileDescriptor>::reset[abi:ne180100](TFileDescriptor **a1, TFileDescriptor *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    TFileDescriptor::~TFileDescriptor(result);
    JUMPOUT(0x1D9436740);
  }
  return result;
}

uint64_t std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__push_back_slow_path<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  v14[4] = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v14[3] = &v10[24 * v9];
  TNodePtr::TNodePtr(v11, (id *)a2);
  *(_OWORD *)(v11 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  v14[2] = v11 + 24;
  std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1D3470F48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  uint64_t v6 = (void *)a2[1];
  if (v5 == *a1)
  {
    uint64_t result = (void *)a2[1];
  }
  else
  {
    do
    {
      uint64_t result = TNodePtr::TNodePtr(v6 - 3, (id *)(v5 - 24));
      *((_OWORD *)v6 - 1) = *(_OWORD *)(v5 - 16);
      *(void *)(v5 - 16) = 0;
      *(void *)(v5 - 8) = 0;
      v5 -= 24;
      uint64_t v6 = result;
    }
    while (v5 != v4);
  }
  a2[1] = result;
  uint64_t v8 = *a1;
  *a1 = (uint64_t)result;
  a2[1] = v8;
  uint64_t v9 = a1[1];
  a1[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = a1[2];
  a1[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>,0>(i - 24);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  id v1 = *a1;
  int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 24;
        std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>,0>(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *(void **)a1;
}

CFTypeRef __copy_helper_block_ea8_32c44_ZTSKZN12TBusyFolders14StartObservingEvE3__0(uint64_t a1, uint64_t a2)
{
  CFTypeRef result = *(CFTypeRef *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = result;
  if (result) {
    return CFRetain(result);
  }
  return result;
}

uint64_t _FSGetTypeInfoFromStatfs(uint64_t a1, char *a2, size_t a3, _DWORD *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!check_mntfromname((const char *)(a1 + 72)))
  {
    __strlcpy_chk();
    if (!a2) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v8 = a1 + 1112;
  uint64_t v9 = strstr((char *)(a1 + 1112), "://");
  if (!v9) {
    return 22;
  }
  if ((unint64_t)&v9[-v8] >= 0xF) {
    uint64_t v10 = 15;
  }
  else {
    uint64_t v10 = (uint64_t)&v9[-v8];
  }
  __memcpy_chk();
  __source[v10] = 0;
  if (a2) {
LABEL_9:
  }
    strlcpy(a2, __source, a3);
LABEL_10:
  uint64_t result = 0;
  if (a4) {
    *a4 = *(_DWORD *)(a1 + 68);
  }
  return result;
}

BOOL check_mntfromname(const char *a1)
{
  return !strcmp(a1, "lifs") || strcmp(a1, "fskit") == 0;
}

uint64_t TFSInfo::IterationFullSetOfPropertyKeys(void)::$_0::operator()()
{
  SecTaskRef v0 = objc_opt_new();
  if (TFSInfo::IterationInfoPropertyKeys(void)::once != -1) {
    dispatch_once(&TFSInfo::IterationInfoPropertyKeys(void)::once, &__block_literal_global_32);
  }
  [v0 addObjectsFromArray:TFSInfo::IterationInfoPropertyKeys(void)::basicKeys];
  if (TFSInfo::LSPropertyKeys(void)::once != -1) {
    dispatch_once(&TFSInfo::LSPropertyKeys(void)::once, &__block_literal_global_34);
  }
  [v0 addObjectsFromArray:TFSInfo::LSPropertyKeys(void)::LSPropertyKeys];
  id v1 = [MEMORY[0x1E4F6F270] sharedInstance];
  int v2 = [v1 generalProperties];

  [v0 addObjectsFromArray:v2];
  uint64_t v3 = [v0 allObjects];

  return v3;
}

void sub_1D347138C(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void TNode::HandleRegisterForNotification(TNodeTask **a1, FINode **a2)
{
  TNodeTask::GetClientChangeNotifier(*a1, &v14);
  if ((TNodeTask::GetNotificationOptions(*a1) & 2) != 0)
  {
    int v4 = *((_DWORD *)*a1 + 12);
    uint64_t v13 = 0;
    StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v12);
    uint64_t v5 = (TNode *)TNodeFromFINode(*a2);
    TNode::FindRegistration(v5, (uint64_t)&v14, a2, &v11);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(&v13, &v11);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v11);
    StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v12);
    if (v13)
    {
      uint64_t v6 = (TNode *)TNodeFromFINode(*a2);
      unsigned __int8 v7 = atomic_exchange((atomic_uchar *volatile)(TNode::GetNotifierList(v6) + 20), 0);
      uint64_t v8 = TNodeFromFINode(*a2);
      int v9 = v7 & 1;
      TNode::DoExternalRegistration(v8, &v13, v9);
      if ((v4 & 0x40000) != 0 || v9)
      {
        uint64_t v10 = (TNode *)TNodeFromFINode(*a2);
        TNode::HandlePopulate(v10, 0, 0);
      }
    }
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v13);
  }
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
}

void sub_1D34714B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, TDSNotifier *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(a1);
}

TDSNotifier **TNodeTask::GetClientChangeNotifier@<X0>(TNodeTask *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  TNodeTask::GetNotifier(this, &v6);
  if (v6)
  {
    uint64_t v4 = *(void *)v6;
    uint64_t v3 = *((void *)v6 + 1);
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
    *a2 = v4;
    a2[1] = v3;
  }
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v6);
}

uint64_t TNode::DoExternalRegistration(uint64_t a1, TDSNotifier **a2, int a3)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a2;
  id v59 = (id *)v4;
  if (!v4)
  {
    uint64_t v19 = 0;
    goto LABEL_39;
  }
  TDSNotifier::AddPtrReference(v4);
  uint64_t NotifierList = TNode::GetNotifierList((TNode *)a1);
  uint64_t v8 = *(void *)(NotifierList + 24);
  unsigned __int8 v7 = *(std::__shared_weak_count **)(NotifierList + 32);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v9 = (TNode *)TNode::VirtualType((TNode *)a1);
  int v10 = (int)v9;
  uint64_t v11 = (os_unfair_lock_s *)TNode::InfoLock(v9);
  os_unfair_lock_lock(v11);
  uint64_t v13 = *(void *)(a1 + 16);
  char v12 = *(std::__shared_weak_count **)(a1 + 24);
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v11);
    int v14 = *(unsigned __int8 *)(v13 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    if (v14) {
      goto LABEL_6;
    }
LABEL_11:
    os_unfair_lock_lock((os_unfair_lock_t)v8);
    int v20 = *(unsigned __int8 *)(v8 + 4);
    os_unfair_lock_unlock((os_unfair_lock_t)v8);
    if (!v20 && TNode::FSNotificationsSupported((TNode *)a1))
    {
      TNode::SubscribeForFSNotification((TNode *)a1);
      os_unfair_lock_lock((os_unfair_lock_t)v8);
      *(unsigned char *)(v8 + 4) = 1;
      os_unfair_lock_unlock((os_unfair_lock_t)v8);
    }
    if (a3)
    {
      *(void *)&long long buf = v59[3];
      TProgressMap::AddSubscriberForExternalProgress((const TNodePtr *)&buf, v21);
    }
    goto LABEL_36;
  }
  os_unfair_lock_unlock(v11);
  if (!*(unsigned char *)(v13 + 112)) {
    goto LABEL_11;
  }
LABEL_6:
  if (v10 == 26)
  {
    if (a3)
    {
      unint64_t v16 = (void **)objc_opt_new();
      TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);
      TNodePtr::operator=(v16 + 1, (void **)&buf);

      TString v17 = v16;
      os_unfair_lock_lock((os_unfair_lock_t)v8);
      TString v18 = *(void **)(v8 + 8);
      *(void *)(v8 + 8) = v17;

      os_unfair_lock_unlock((os_unfair_lock_t)v8);
      [v17 startObserving];
    }
    goto LABEL_36;
  }
  int v22 = (os_unfair_lock_s *)TNode::InfoLock(v15);
  os_unfair_lock_lock(v22);
  CFTypeRef v24 = *(TFSInfo **)(a1 + 16);
  uint64_t v23 = *(std::__shared_weak_count **)(a1 + 24);
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v22);
  IsFPint v2 = TFSInfo::IsFPv2(v24, 1);
  BOOL v26 = IsFPv2;
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v23);
  }
  if (v26)
  {
    if (a3)
    {
      uint64_t v27 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsFPv2);
      os_unfair_lock_lock(v27);
      uint64_t v29 = *(TFSInfo **)(a1 + 16);
      id v28 = *(std::__shared_weak_count **)(a1 + 24);
      if (v28) {
        atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v27);
      TFSInfo::GetFPItem(v29);
      unint64_t v30 = (FPItem *)objc_claimAutoreleasedReturnValue();
      if (v28) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v28);
      }
      uint64_t v31 = TNode::FPItemsCollection((TNode *)a1, v30);

      uint64_t v32 = *(void *)(a1 + 56);
      TNodePtr::TNodePtr(&v56, (const TNode *)a1);
      TNode::GetVolumeInfo((TNode *)a1, &buf);
      unint64_t v33 = TFSVolumeInfo::GetSynchingGCDQueue((TFSVolumeInfo *)buf);
      TChildrenList::StartCollectionStatusObserver(v32, v31, (uint64_t)&v56, v33, 0);

      if (*((void *)&buf + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
      }
    }
    goto LABEL_36;
  }
  if ((v10 - 23) > 1u)
  {
    __int16 v58 = 0;
    uint64_t IsNetworkNode = TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E74776B);
    if ((IsNetworkNode & 1) != 0
      || (uint64_t IsNetworkNode = TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E747362), (IsNetworkNode & 1) != 0)
      || (uint64_t IsNetworkNode = TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6D74726D), IsNetworkNode))
    {
      uint64_t v42 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsNetworkNode);
      os_unfair_lock_lock(v42);
      TString v44 = *(TFSInfo **)(a1 + 16);
      uint64_t v43 = *(std::__shared_weak_count **)(a1 + 24);
      if (v43) {
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v42);
      uint64_t v45 = (TFSInfo *)TFSInfo::CopySFBrowserRef(v44);
      __int16 v58 = v45;
      if (v43) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v43);
      }
      if (v45)
      {
        uint64_t RootNode = SFBrowserGetRootNode();
        if ((ExternalRegistration::IsNetworkOpened((os_unfair_lock_s *)v8) & 1) == 0)
        {
          LOBYTE(v56.fFINode) = 0;
          atomic_fetch_and((atomic_ushort *volatile)(a1 + 80), 0xFFF7u);
          atomic_fetch_and((atomic_ushort *volatile)(a1 + 80), 0xFFEFu);
          TNode::HandleSyncStarted(a1, 276824064, (BOOL *)&v56);
          BOOL v55 = 0;
          int v47 = TFSInfo::BrowserOpenNode(v58, RootNode, 0, 0, &v55);
          if (LOBYTE(v56.fFINode))
          {
            atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x20u);
            if (v55)
            {
              dispatch_time_t v48 = dispatch_time(0, 3000000000);
              long long v49 = dispatch_get_global_queue(0, 0);
              v53[0] = MEMORY[0x1E4F143A8];
              v53[1] = 3321888768;
              v53[2] = ___ZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEb_block_invoke;
              v53[3] = &__block_descriptor_40_ea8_32c94_ZTSKZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEbE3__0_e5_v8__0l;
              TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);
              id v54 = (id)buf;
              dispatch_after(v48, v49, v53);
            }
            else if ((atomic_fetch_and((atomic_ushort *volatile)(a1 + 80), 0xFFDFu) & 0x20) != 0)
            {
              TNode::HandleSync(a1, 0x1400000u);
            }
          }
          if (v47)
          {
            uint64_t v19 = 4294959241;
LABEL_72:
            TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)&v58);
            goto LABEL_37;
          }
          os_unfair_lock_lock((os_unfair_lock_t)v8);
          *(unsigned char *)(v8 + 5) = 1;
          os_unfair_lock_unlock((os_unfair_lock_t)v8);
          int v52 = TNode::VirtualType((TNode *)a1);
          TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);
          TNode::AddNWNode(v52, RootNode, (FINode **)&buf);
        }
      }
    }
    else
    {
      TNode::GetFSInfo((TNode *)a1, &buf);
      TNode::GetFSInfo((TNode *)a1, &v56);
      if (v57) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v57);
      }
      if (*((void *)&buf + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
      }
    }
    uint64_t v19 = 0;
    goto LABEL_72;
  }
  if (!ICloudDriveFPFSEnabled())
  {
LABEL_36:
    uint64_t v19 = 0;
    goto LABEL_37;
  }
  iCloudDriveDomainIDForDataSeparated(v10 == 24);
  uint64_t v34 = (TCachedAppLibraryCollections *)objc_claimAutoreleasedReturnValue();
  unint64_t v35 = (NSString *)v34;
  if (!v34)
  {
    if (v10 == 24)
    {
      uint64_t v37 = LogObj(3);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        goto LABEL_76;
      }
      LOWORD(buf) = 0;
      long long v50 = "No domain id found for enterprise iCloud libraries collection";
    }
    else
    {
      uint64_t v37 = LogObj(4);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        goto LABEL_76;
      }
      LOWORD(buf) = 0;
      long long v50 = "No domain id found for iCloud libraries collection";
    }
    _os_log_impl(&dword_1D343E000, v37, OS_LOG_TYPE_ERROR, v50, (uint8_t *)&buf, 2u);
    goto LABEL_76;
  }
  uint64_t v36 = (TCachedAppLibraryCollections *)TCachedAppLibraryCollections::Singleton(v34);
  TString::TString((TString *)&buf, v35);
  uint64_t v37 = TCachedAppLibraryCollections::CachedCollection(v36, (const TString *)&buf, 1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&buf);
  if (v37)
  {
    uint64_t v38 = *(void *)(a1 + 56);
    TNodePtr::TNodePtr(&v56, (const TNode *)a1);
    TNode::GetVolumeInfo((TNode *)a1, &buf);
    uint64_t v39 = TFSVolumeInfo::GetSynchingGCDQueue((TFSVolumeInfo *)buf);
    TChildrenList::StartCollectionStatusObserver(v38, v37, (uint64_t)&v56, v39, 0);

    if (*((void *)&buf + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
    }

    uint64_t v19 = 0;
    goto LABEL_77;
  }
  if (v10 == 24)
  {
    dispatch_time_t v51 = LogObj(3);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v35;
      _os_log_impl(&dword_1D343E000, v51, OS_LOG_TYPE_ERROR, "No app libraries collection found skipping start observing accountID='%@'", (uint8_t *)&buf, 0xCu);
    }
  }
  else
  {
    dispatch_time_t v51 = LogObj(4);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v35;
      _os_log_impl(&dword_1D343E000, v51, OS_LOG_TYPE_ERROR, "No app libraries collection found skipping start observing accountID='%@'", (uint8_t *)&buf, 0xCu);
    }
  }

LABEL_76:
  uint64_t v19 = 4294959240;
LABEL_77:

LABEL_37:
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
LABEL_39:
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v59);
  return v19;
}

void sub_1D3471CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);

  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  _Unwind_Resume(a1);
}

void sub_1D347203C(_Unwind_Exception *a1)
{
  objc_sync_exit(v3);
  _Unwind_Resume(a1);
}

os_log_t LogObj(int a1)
{
  if ((a1 - 1) > 7) {
    id v1 = "ArchiveService";
  }
  else {
    id v1 = off_1E698FD28[a1 - 1];
  }
  os_log_t v2 = os_log_create("com.apple.DesktopServices", v1);
  return v2;
}

TString *ShortDescription(uint64_t a1)
{
  if (!a1)
  {
    TString v17 = @"Invalid";
LABEL_38:
    return (TString *)v17;
  }
  int v1 = a1;
  int v2 = 1;
  int v3 = a1;
  do
  {
    if ((v2 & ~v3) == 0) {
      break;
    }
    v3 &= ~v2;
    v2 *= 2;
  }
  while (v3);
  unint64_t end_iter = bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(a1);
  int v5 = end_iter;
  int v7 = v6;
  unint64_t v8 = HIDWORD(end_iter);
  int v9 = &stru_1F2ABD380;
  CFStringRef theString = &stru_1F2ABD380;
  uint64_t result = (TString *)CFRetain(&stru_1F2ABD380);
  if (v5 == v1 && v3 == v8 && v2 == v7)
  {
LABEL_37:
    TString v17 = v9;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    goto LABEL_38;
  }
  while (1)
  {
    int v11 = v3 & v2;
    if ((v3 & v2) <= 15) {
      break;
    }
    long long v15 = "PrefetchChildrenProperties";
    if (v11 != 32) {
      long long v15 = "SelfSpotlight";
    }
    uint64_t v16 = 26;
    if (v11 != 32) {
      uint64_t v16 = 13;
    }
    if (v11 == 16) {
      uint64_t v13 = "UbiquityStatus";
    }
    else {
      uint64_t v13 = v15;
    }
    if (v11 == 16) {
      unint64_t v12 = 14;
    }
    else {
      unint64_t v12 = v16;
    }
LABEL_24:
    TString::TString((TString *)&v19, v13, v12);
LABEL_25:
    if (CFStringGetLength(theString) && CFStringGetLength(v19)) {
      TString::Append((TString *)&theString, (const __CFString *)" | ");
    }
    TString::Append((TString *)&theString, (const TString *)&v19);
    uint64_t result = (TString *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19);
    if (v3)
    {
      do
      {
        v3 &= ~v2;
        v2 *= 2;
      }
      while (v3 && (v2 & ~v3) != 0);
    }
    if (v5 == v1 && v3 == v8 && v2 == v7)
    {
      int v9 = (__CFString *)theString;
      goto LABEL_37;
    }
  }
  unint64_t v12 = 4;
  uint64_t v13 = "Self";
  switch(v11)
  {
    case 1:
      goto LABEL_24;
    case 2:
      uint64_t v13 = "Child";
      unint64_t v12 = 5;
      goto LABEL_24;
    case 3:
    case 5:
    case 6:
    case 7:
      __break(1u);
      break;
    case 4:
      uint64_t v13 = "ChildDeep";
      unint64_t v12 = 9;
      goto LABEL_24;
    case 8:
      uint64_t v13 = "ChildSpotlight";
      unint64_t v12 = 14;
      goto LABEL_24;
    default:
      int v14 = TString::KEmptyString(result);
      CFStringRef v19 = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable((TString *)&v19, (TString *)*v14);
      goto LABEL_25;
  }
  return result;
}

void sub_1D347232C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_1D347248C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void NodeObservedOptionsCountRegistry::StartedObserving(void *a1, uint64_t a2)
{
  id v19 = a1;
  std::mutex::lock(&NodeObservedOptionsCountRegistry::gRegistryLock);
  if (!NodeObservedOptionsCountRegistry::gRegistry)
  {
    memset(v20, 0, sizeof(v20));
    operator new();
  }
  v20[0] = &v19;
  int v3 = std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::__emplace_unique_key_args<FINode * {__strong},std::piecewise_construct_t const&,std::tuple<FINode * const {__strong}&>,std::tuple<>>(NodeObservedOptionsCountRegistry::gRegistry, &v19, (uint64_t)&std::piecewise_construct, v20);
  if (a2)
  {
    int v4 = 1;
    uint64_t v5 = a2;
    do
    {
      if ((v4 & ~v5) == 0) {
        break;
      }
      uint64_t v5 = v5 & ~v4;
      v4 *= 2;
    }
    while (v5);
  }
  else
  {
    uint64_t v5 = 0;
    int v4 = 1;
  }
  unint64_t end_iter = bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(a2);
  int v8 = end_iter;
  uint64_t v9 = (uint64_t)(v3 + 24);
  unint64_t v10 = a2 | (unint64_t)(v5 << 32);
  unint64_t v11 = HIDWORD(end_iter);
  unint64_t v18 = HIDWORD(end_iter);
LABEL_10:
  uint64_t v12 = v7;
  BOOL v14 = HIDWORD(v10) != v11 || v4 != v7;
  while (v10 != v8 || v14)
  {
    v21[0] = v4 & HIDWORD(v10);
    v20[0] = (id *)v21;
    uint64_t v16 = std::__hash_table<std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::__unordered_map_hasher<NodeNotificationOptions,std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::hash<NodeNotificationOptions>,std::equal_to<NodeNotificationOptions>,true>,std::__unordered_map_equal<NodeNotificationOptions,std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::equal_to<NodeNotificationOptions>,std::hash<NodeNotificationOptions>,true>,std::allocator<std::__hash_value_type<NodeNotificationOptions,unsigned long>>>::__emplace_unique_key_args<NodeNotificationOptions,std::piecewise_construct_t const&,std::tuple<NodeNotificationOptions const&>,std::tuple<>>(v9, v21, (uint64_t)&std::piecewise_construct, (_DWORD **)v20);
    ++v16[3];
    if (HIDWORD(v10))
    {
      unsigned int v17 = HIDWORD(v10) & ~v4;
      unint64_t v10 = v10 | ((unint64_t)v17 << 32);
      v4 *= 2;
      uint64_t v7 = v12;
      for (LODWORD(v11) = v18; v17; v4 *= 2)
      {
        if ((v4 & ~v17) == 0) {
          break;
        }
        v17 &= ~v4;
        unint64_t v10 = v10 | ((unint64_t)v17 << 32);
      }
      goto LABEL_10;
    }
  }
  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);
}

void sub_1D3472704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, char a12, uint64_t a13, uint64_t a14, void **a15)
{
  a15 = (void **)&a12;
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:ne180100](&a15);
  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);

  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::__unordered_map_hasher<NodeNotificationOptions,std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::hash<NodeNotificationOptions>,std::equal_to<NodeNotificationOptions>,true>,std::__unordered_map_equal<NodeNotificationOptions,std::__hash_value_type<NodeNotificationOptions,unsigned long>,std::equal_to<NodeNotificationOptions>,std::hash<NodeNotificationOptions>,true>,std::allocator<std::__hash_value_type<NodeNotificationOptions,unsigned long>>>::__emplace_unique_key_args<NodeNotificationOptions,std::piecewise_construct_t const&,std::tuple<NodeNotificationOptions const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      unint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  unint64_t v11 = operator new(0x20uLL);
  *unint64_t v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  void v11[3] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  int v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *unint64_t v11 = *v20;
LABEL_38:
    void *v20 = v11;
    goto LABEL_39;
  }
  *unint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    int v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_1D3472974(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::__emplace_unique_key_args<FINode * {__strong},std::piecewise_construct_t const&,std::tuple<FINode * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, uint64_t a3, id **a4)
{
  unint64_t v8 = [*a2 hash];
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
    float v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      float v14 = (char *)*v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v9)
          {
            if (std::equal_to<FINode * {__strong}>::operator()(a1 + 32, *((void **)v14 + 2), *a2)) {
              return v14;
            }
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10) {
                v15 %= v10;
              }
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v4) {
              break;
            }
          }
          float v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
  unint64_t v16 = (void *)(a1 + 16);
  float v14 = (char *)operator new(0x40uLL);
  *(void *)float v14 = 0;
  *((void *)v14 + 1) = v9;
  *((void *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v23 = *(void *)a1;
  CFTypeRef v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *(void *)float v14 = *v24;
LABEL_38:
    *CFTypeRef v24 = v14;
    goto LABEL_39;
  }
  *(void *)float v14 = *v16;
  void *v16 = v14;
  *(void *)(v23 + 8 * v4) = v16;
  if (*(void *)v14)
  {
    unint64_t v25 = *(void *)(*(void *)v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }
    else
    {
      v25 &= v10 - 1;
    }
    CFTypeRef v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_1D3472BF0(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

uint64_t NodeRegisterChangeNotification(TNode *a1, OpaqueNodeRef *a2, uint64_t a3)
{
  uint64_t v3 = 4294959224;
  if (a1)
  {
    if (a2)
    {
      unint64_t v7 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
      uint64_t v3 = TNode::WeakValidate(v7, v8);
      if (!v3)
      {
        [(TNode *)a1 registeringChangeNotification:a3];
        ClientNotifierFromNodeNotifier((OpaqueEventNotifier *)a2, &v10);
        if (v10) {
          uint64_t v3 = TNode::RegisterChangeNotification(v7, (TDSNotifier *)&v10, a3);
        }
        else {
          uint64_t v3 = 4294959224;
        }
        if (v11) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v11);
        }
      }
    }
  }
  return v3;
}

void sub_1D3472CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::RegisterChangeNotification(TNode *a1, TDSNotifier *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if ((a3 & 0xE) != 0)
  {
    int v6 = (os_unfair_lock_s *)TNode::InfoLock(a1);
    os_unfair_lock_lock(v6);
    uint64_t v8 = *((void *)a1 + 2);
    unint64_t v7 = (std::__shared_weak_count *)*((void *)a1 + 3);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v6);
    unint64_t v9 = (os_unfair_lock_s *)(v8 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
    int v10 = *(_DWORD *)(v8 + 115);
    os_unfair_lock_unlock(v9);
    if (v7) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    }
    if ((v10 & 0x20) == 0) {
      goto LABEL_12;
    }
    unint64_t v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
    os_unfair_lock_lock(v12);
    float v14 = (TFSInfo *)*((void *)a1 + 2);
    float v13 = (std::__shared_weak_count *)*((void *)a1 + 3);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v12);
    BOOL IsAlias = TFSInfo::IsAlias(v14);
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
    }
    if (IsAlias) {
LABEL_12:
    }
      uint64_t v3 = v3 & 0xFFFFFFF1;
  }
  TNodePtr::TNodePtr(&v18, a1);
  TNodePtr::TNodePtr(&v17, a1);
  TDSNotifier::Register(a2, &v18.fFINode, &v17.fFINode, v3);

  return 0;
}

void sub_1D3472E00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void TDSNotifier::Register(TDSNotifier *a1, FINode **a2, FINode **a3, uint64_t a4)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  RegistrationLocuint64_t k = (TDSMutex *)TDSNotifier::GetRegistrationLock(a1);
  TDSMutex::lock(RegistrationLock);
  unint64_t v9 = (TNode *)TNodeFromFINode(*a2);
  TNode::FindRegistration(v9, (uint64_t)a1, a3, &v61);
  if (!v61) {
    operator new();
  }
  if (a4)
  {
    uint64_t v10 = TNodeFromFINode(*a2);
    uint8x8_t v11 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v10);
    os_unfair_lock_lock(v11);
    TNodePtr::TNodePtr((TNodePtr *)&buf, *(const TNode **)(v10 + 48));
    os_unfair_lock_unlock(v11);
    if (TNodeFromFINode((FINode *)buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value))
    {
      uint64_t v12 = TNodeFromFINode((FINode *)buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value);
      TChildrenList::IncrementRegisteredChildrenCount(*(TChildrenList **)(v12 + 56));
    }
  }
  if ((a4 & 0x40) != 0
    && (float v13 = (TNode *)TNodeFromFINode(*a2),
        !atomic_fetch_add((atomic_uint *volatile)(TNode::GetNotifierList(v13) + 16), 1u)))
  {
    unint64_t v25 = (const TNode *)TNodeFromFINode(*a2);
    memset(&buf, 0, sizeof(buf));
    TNode::RequestInternalTask(v25, 1004, &buf, 0);
    TPropertyValue::~TPropertyValue(&buf);
    if ((a4 & 2) == 0) {
      goto LABEL_30;
    }
  }
  else if ((a4 & 2) == 0)
  {
    goto LABEL_30;
  }
  uint64_t v14 = TNodeFromFINode(*a2);
  unint64_t v15 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v14);
  os_unfair_lock_lock(v15);
  uint64_t v17 = *(void *)(v14 + 16);
  unint64_t v16 = *(std::__shared_weak_count **)(v14 + 24);
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v15);
  TNodePtr v18 = (os_unfair_lock_s *)(v17 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v17 + 100));
  int v19 = *(_DWORD *)(v17 + 115);
  os_unfair_lock_unlock(v18);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  if ((v19 & 0x20) != 0 || (unint64_t v20 = (TNode *)TNodeFromFINode(*a2), TNode::AliasIsContainer(v20)))
  {
    unsigned int v21 = atomic_load((unsigned int *)v61 + 11);
    atomic_fetch_add((atomic_uint *volatile)v61 + 11, 1u);
    size_t v22 = (TNode *)TNodeFromFINode(*a2);
    uint64_t NotifierList = TNode::GetNotifierList(v22);
    unsigned int add = atomic_fetch_add((atomic_uint *volatile)NotifierList, 1u);
    if ((add & 0x80000000) != 0)
    {
      BOOL v26 = LogObj(5);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = add + 1;
        _os_log_impl(&dword_1D343E000, v26, OS_LOG_TYPE_ERROR, "Incorrect childRegistrations when incrementing: %d", (uint8_t *)&buf, 8u);
      }
    }
    else if (!add)
    {
      atomic_store(1u, (unsigned __int8 *)(NotifierList + 20));
    }
    if (!v21)
    {
      uint64_t v27 = (TNode *)TNodeFromFINode(*a2);
      if ((TNode::AliasIsContainer(v27) & 1) == 0)
      {
        id v28 = (TNode *)TNodeFromFINode(*a2);
        if ((TNode::IsPopulated(v28) & 1) == 0)
        {
          uint64_t v29 = (TNode *)TNodeFromFINode(*a2);
          if (TNode::IsInitialPopulating(v29))
          {
            TNodeFromFINode(*a2);
            TFSInfo::MarkAsUsed((TFSInfo *)9);
            TNodeEvent::CreateNodeEvent(9, (id *)a2, 0, &buf);
            unint64_t v30 = (TNodeEvent *)TNodeEventPtr::operator->(&buf);
            TNodeEvent::Notify(v30, &v61, 1);
            TNodeEventPtr::~TNodeEventPtr((id *)&buf);
          }
        }
        *((_DWORD *)v61 + 8) = a4;
        TReferenceCounted::Make<TDSNotifier *>();
      }
    }
  }
LABEL_30:
  if ((a4 & 4) != 0)
  {
    uint64_t v31 = TNodeFromFINode(*a2);
    uint64_t v32 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v31);
    os_unfair_lock_lock(v32);
    uint64_t v34 = *(void *)(v31 + 16);
    unint64_t v33 = *(std::__shared_weak_count **)(v31 + 24);
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v32);
    unint64_t v35 = (os_unfair_lock_s *)(v34 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v34 + 100));
    int v36 = *(_DWORD *)(v34 + 115);
    os_unfair_lock_unlock(v35);
    if (v33) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v33);
    }
    if ((v36 & 0x20) != 0 || (uint64_t v37 = (TNode *)TNodeFromFINode(*a2), TNode::AliasIsContainer(v37)))
    {
      ++*((_DWORD *)v61 + 12);
      uint64_t v38 = (TNode *)TNodeFromFINode(*a2);
      unsigned int v39 = atomic_fetch_add((atomic_uint *volatile)(TNode::GetNotifierList(v38) + 4), 1u);
      if ((v39 & 0x80000000) != 0)
      {
        TNodePtr v41 = LogObj(5);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
          buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v39 + 1;
          _os_log_impl(&dword_1D343E000, v41, OS_LOG_TYPE_ERROR, "Incorrect deepChildRegistrations when incrementing: %d", (uint8_t *)&buf, 8u);
        }
      }
      else if (!v39)
      {
        uint64_t v40 = TNodeFromFINode(*a2);
        TNode::GetPath(v40, 1, (uint64_t)&buf);
        TString::TString(&v59, "", 0);
        fstd::optional_err<TString,int>::value_or<TString>((uint64_t)&buf, (CFTypeRef *)&v59.fString.fRef, &v60);
        TSystemNotificationTask::StartObservingDirectory((TString **)&v60, (const TString *)1);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v60.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v59.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&buf);
      }
    }
  }
  if ((a4 & 8) != 0)
  {
    uint64_t v42 = TNodeFromFINode(*a2);
    uint64_t v43 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v42);
    os_unfair_lock_lock(v43);
    uint64_t v45 = *(void *)(v42 + 16);
    TString v44 = *(std::__shared_weak_count **)(v42 + 24);
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v43);
    uint64_t v46 = (os_unfair_lock_s *)(v45 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v45 + 100));
    int v47 = *(_DWORD *)(v45 + 115);
    os_unfair_lock_unlock(v46);
    if (v44) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v44);
    }
    if ((v47 & 0x20) != 0 || (dispatch_time_t v48 = (TNode *)TNodeFromFINode(*a2), TNode::AliasIsContainer(v48)))
    {
      long long v49 = (TNode *)TNodeFromFINode(*a2);
      unsigned int v50 = atomic_load((unsigned int *)(TNode::GetNotifierList(v49) + 8));
      dispatch_time_t v51 = (TNode *)TNodeFromFINode(*a2);
      unsigned int v52 = atomic_fetch_add((atomic_uint *volatile)(TNode::GetNotifierList(v51) + 8), 1u);
      if ((v52 & 0x80000000) != 0)
      {
        id v53 = LogObj(5);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        {
          buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
          buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v52 + 1;
          _os_log_impl(&dword_1D343E000, v53, OS_LOG_TYPE_ERROR, "Incorrect spotlightRegistrations when incrementing: %d", (uint8_t *)&buf, 8u);
        }
      }
      ++*((_DWORD *)v61 + 13);
      if (!v50)
      {
        id v54 = (TFSInfo *)TNodeFromFINode(*a2);
        TFSInfo::MarkAsUsed(v54);
      }
    }
  }
  if ((a4 & 0x10) != 0)
  {
    ++*((_DWORD *)v61 + 14);
    BOOL v55 = (TNode *)TNodeFromFINode(*a2);
    unsigned int v56 = atomic_fetch_add((atomic_uint *volatile)(TNode::GetNotifierList(v55) + 12), 1u);
    if ((v56 & 0x80000000) != 0)
    {
      __int16 v58 = LogObj(4);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v56 + 1;
        _os_log_impl(&dword_1D343E000, v58, OS_LOG_TYPE_ERROR, "Incorrect ubiquityRegistrations when incrementing: %d", (uint8_t *)&buf, 8u);
      }
    }
    else if (!v56)
    {
      CFIndex v57 = (TNode *)TNodeFromFINode(*a2);
      TNode::SetShouldSyncUbiquityAttributes(v57, 1);
    }
  }
  atomic_fetch_add((atomic_uint *volatile)v61 + 10, TDSNotifier::CountForOptions(a4));
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v61);
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&v62);
}

void sub_1D3473564(_Unwind_Exception *a1, char a2, int a3, __int16 a4, char a5, char a6, int a7, int a8, __int16 a9, char a10, char a11, TPropertyValue *a12, TDSNotifier *a13, int a14, __int16 a15, char a16, char a17)
{
}

TDSNotifier **TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(TDSNotifier **a1, TDSNotifier **a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *a1;
    if (*a1) {
      TDSNotifier::RemovePtrReference(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

unint64_t TNode::NodeIs(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  int v6 = *(TFSInfo **)(a1 + 16);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  unint64_t v7 = TFSInfo::InfoIs(v6, a2);
  if ((a2 & 0x200000) != 0) {
    TNode::AliasIsContainer((TNode *)a1);
  }
  if ((a2 & 0x800000) != 0)
  {
    if (TNode::IsInTrash((TNode *)a1)) {
      uint64_t v8 = 0x800000;
    }
    else {
      uint64_t v8 = 0;
    }
    if ((a2 & 0x40000000) == 0) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v8 = 0;
    if ((a2 & 0x40000000) == 0) {
      goto LABEL_15;
    }
  }
  if ((TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E74776B) & 1) != 0
    || TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E747362))
  {
    v8 |= 0x40000000uLL;
  }
LABEL_15:
  if ((a2 & 0x800000000000) != 0 && TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6E74776B)) {
    v8 |= 0x800000000000uLL;
  }
  if ((a2 & 0x40000000000) != 0 && TNode::IsNetworkNode((TNode *)a1, (TGlobalNodes *)0x6D74726D)) {
    v8 |= 0x40000000000uLL;
  }
  if ((a2 & 0x2000000000) != 0)
  {
    char v9 = atomic_load((unsigned __int16 *)(a1 + 80));
    v8 |= (unint64_t)(v9 & 2) << 36;
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return v8 | v7;
}

void sub_1D3473864(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

unint64_t TFSInfo::InfoIs(TFSInfo *this, uint64_t a2)
{
  uint64_t v3 = this;
  if (a2)
  {
    unint64_t v4 = *((unsigned char *)this + 112) != 0;
    if ((a2 & 2) == 0) {
      goto LABEL_8;
    }
  }
  else
  {
    unint64_t v4 = 0;
    if ((a2 & 2) == 0) {
      goto LABEL_8;
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v5 = *(_DWORD *)((char *)v3 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  if ((v5 & 0x20) != 0
    || (os_unfair_lock_lock((os_unfair_lock_t)v3 + 25),
        int v6 = *(_DWORD *)((char *)v3 + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25),
        (v6 & 0x20000) != 0))
  {
    v4 |= 2uLL;
  }
LABEL_8:
  if ((a2 & 4) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
    int v7 = *(_DWORD *)((char *)v3 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
    if ((v7 & 0x100) != 0 && *((unsigned __int8 *)v3 + 112) - 23 >= 2) {
      v4 |= 4uLL;
    }
  }
  if ((a2 & 8) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
    int v8 = *(_DWORD *)((char *)v3 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
    unint64_t v4 = v4 & 0xFFFFFFFFFFFFFFF7 | (8 * (v8 & 1));
    if ((a2 & 0x10) == 0)
    {
LABEL_14:
      if ((a2 & 0x20) == 0) {
        goto LABEL_15;
      }
      goto LABEL_26;
    }
  }
  else if ((a2 & 0x10) == 0)
  {
    goto LABEL_14;
  }
  this = (TFSInfo *)TFSInfo::IsAlias(v3);
  if (this) {
    v4 |= 0x10uLL;
  }
  if ((a2 & 0x20) == 0)
  {
LABEL_15:
    if ((a2 & 0x40) == 0) {
      goto LABEL_16;
    }
    goto LABEL_27;
  }
LABEL_26:
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
  unint64_t v9 = *(unsigned int *)((char *)v3 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  v4 |= (v9 >> 1) & 0x20;
  if ((a2 & 0x40) == 0)
  {
LABEL_16:
    if ((a2 & 0x80) == 0) {
      goto LABEL_17;
    }
    goto LABEL_28;
  }
LABEL_27:
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
  unint64_t v10 = (unint64_t)*(unsigned int *)((char *)v3 + 115) >> 2;
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  unint64_t v4 = v4 & 0xFFFFFFFFFFFFFFBFLL | ((v10 & 1) << 6);
  if ((a2 & 0x80) == 0)
  {
LABEL_17:
    if ((a2 & 0x200) == 0) {
      goto LABEL_18;
    }
    goto LABEL_29;
  }
LABEL_28:
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
  unint64_t v11 = (unint64_t)*(unsigned int *)((char *)v3 + 115) >> 1;
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  unint64_t v4 = v4 & 0xFFFFFFFFFFFFFF7FLL | ((v11 & 1) << 7);
  if ((a2 & 0x200) == 0)
  {
LABEL_18:
    if ((a2 & 0x400) == 0) {
      goto LABEL_19;
    }
    goto LABEL_32;
  }
LABEL_29:
  this = (TFSInfo *)TFSInfo::IsLocation(v3);
  if (this) {
    v4 |= 0x200uLL;
  }
  if ((a2 & 0x400) == 0)
  {
LABEL_19:
    if ((a2 & 0x800) == 0) {
      goto LABEL_20;
    }
    goto LABEL_35;
  }
LABEL_32:
  this = (TFSInfo *)TFSInfo::HasCustomIcon(v3);
  if (this) {
    v4 |= 0x400uLL;
  }
  if ((a2 & 0x800) == 0)
  {
LABEL_20:
    if ((a2 & 0x1000) == 0) {
      goto LABEL_42;
    }
    goto LABEL_38;
  }
LABEL_35:
  int UserID = TFSInfo::GetUserID(this);
  if (UserID == TFSInfo::GetOwner(v3)) {
    v4 |= 0x800uLL;
  }
  if ((a2 & 0x1000) != 0)
  {
LABEL_38:
    if (*((unsigned char *)v3 + 112) || *((_DWORD *)v3 + 26) != 1651666795 && TFSInfo::GetCreationDate(v3) != -534528000.0) {
      v4 |= 0x1000uLL;
    }
  }
LABEL_42:
  if ((a2 & 0x4000) != 0)
  {
    if (*((unsigned char *)v3 + 112) == 1) {
      v4 |= 0x4000uLL;
    }
    if ((a2 & 0x10000) == 0)
    {
LABEL_44:
      if ((a2 & 0x20000) == 0) {
        goto LABEL_45;
      }
      goto LABEL_55;
    }
  }
  else if ((a2 & 0x10000) == 0)
  {
    goto LABEL_44;
  }
  if (*((unsigned char *)v3 + 112) == 5) {
    v4 |= 0x10000uLL;
  }
  if ((a2 & 0x20000) == 0)
  {
LABEL_45:
    if ((a2 & 0x40000) == 0) {
      goto LABEL_46;
    }
    goto LABEL_56;
  }
LABEL_55:
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
  unint64_t v13 = (unint64_t)*(unsigned __int16 *)((char *)v3 + 119) >> 6;
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
  unint64_t v4 = v4 & 0xFFFFFFFFFFFDFFFFLL | ((v13 & 1) << 17);
  if ((a2 & 0x40000) == 0)
  {
LABEL_46:
    if ((a2 & 0x80000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_59;
  }
LABEL_56:
  if (*((unsigned char *)v3 + 112) == 7) {
    v4 |= 0x40000uLL;
  }
  if ((a2 & 0x80000) == 0)
  {
LABEL_47:
    if ((a2 & 0x200000) == 0) {
      goto LABEL_67;
    }
    goto LABEL_62;
  }
LABEL_59:
  if (*((unsigned char *)v3 + 112) == 6) {
    v4 |= 0x80000uLL;
  }
  if ((a2 & 0x200000) != 0)
  {
LABEL_62:
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
    int v14 = *(_DWORD *)((char *)v3 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
    if ((v14 & 0x20) != 0
      || (os_unfair_lock_lock((os_unfair_lock_t)v3 + 25),
          int v15 = *(_DWORD *)((char *)v3 + 115),
          os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25),
          (v15 & 0x20000) != 0))
    {
      os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
      int v16 = *(_DWORD *)((char *)v3 + 115);
      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
      if ((v16 & 2) == 0)
      {
        os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
        unint64_t v17 = *(unsigned int *)((char *)v3 + 115) | ((unint64_t)*(unsigned __int16 *)((char *)v3 + 119) << 32);
        os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
        if ((v17 & 0x4000000000) == 0) {
          v4 |= 0x200000uLL;
        }
      }
    }
  }
LABEL_67:
  if ((a2 & 0x2000000) != 0)
  {
    if (*((unsigned char *)v3 + 112) == 20) {
      v4 |= 0x2000000uLL;
    }
    if ((a2 & 0x4000000000000) == 0)
    {
LABEL_69:
      if ((a2 & 0x40000000000) == 0) {
        goto LABEL_70;
      }
      goto LABEL_80;
    }
  }
  else if ((a2 & 0x4000000000000) == 0)
  {
    goto LABEL_69;
  }
  if (*((unsigned char *)v3 + 112) == 34) {
    v4 |= 0x4000000000000uLL;
  }
  if ((a2 & 0x40000000000) == 0)
  {
LABEL_70:
    if ((a2 & 0x8000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_83;
  }
LABEL_80:
  if (*((unsigned char *)v3 + 112) == 33) {
    v4 |= 0x40000000000uLL;
  }
  if ((a2 & 0x8000000) == 0)
  {
LABEL_71:
    if ((a2 & 0x100000000000) == 0) {
      goto LABEL_72;
    }
LABEL_86:
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
    uint64_t v18 = *(unsigned __int16 *)((char *)v3 + 119);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
    v4 |= (v18 << 35) & 0x100000000000;
    if ((a2 & 0x20000000000000) == 0) {
      goto LABEL_93;
    }
    goto LABEL_87;
  }
LABEL_83:
  if (*((unsigned char *)v3 + 112) == 16) {
    v4 |= 0x8000000uLL;
  }
  if ((a2 & 0x100000000000) != 0) {
    goto LABEL_86;
  }
LABEL_72:
  if ((a2 & 0x20000000000000) == 0) {
    goto LABEL_93;
  }
LABEL_87:
  int v19 = *((unsigned __int8 *)v3 + 112);
  if ((v19 - 26) < 3)
  {
    v4 |= 0x20000000000000uLL;
    if ((a2 & 0x40000000000000) == 0) {
      goto LABEL_97;
    }
    goto LABEL_94;
  }
  if (*((unsigned char *)v3 + 112))
  {
    if (v19 == 35)
    {
      os_unfair_lock_lock((os_unfair_lock_t)v3 + 25);
      unint64_t v20 = (unint64_t)*(unsigned __int16 *)((char *)v3 + 119) >> 7;
      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25);
      unint64_t v4 = v4 & 0xFFDFFFFFFFFFFFFFLL | ((v20 & 1) << 53);
    }
LABEL_93:
    if ((a2 & 0x40000000000000) == 0) {
      goto LABEL_97;
    }
    goto LABEL_94;
  }
  uint64_t v23 = TFSInfo::GetFPItem(v3);

  if (v23) {
    v4 |= 0x20000000000000uLL;
  }
  if ((a2 & 0x40000000000000) != 0)
  {
LABEL_94:
    if (*((unsigned __int8 *)v3 + 112) - 29 < 2
      || (os_unfair_lock_lock((os_unfair_lock_t)v3 + 25),
          unint64_t v21 = *(unsigned int *)((char *)v3 + 115) | ((unint64_t)*(unsigned __int16 *)((char *)v3 + 119) << 32),
          os_unfair_lock_unlock((os_unfair_lock_t)v3 + 25),
          (v21 & 0x10000000000) != 0))
    {
      v4 |= 0x40000000000000uLL;
    }
  }
LABEL_97:
  if ((a2 & 0x2000000000000) != 0 && *((unsigned __int8 *)v3 + 112) - 23 < 2) {
    v4 |= 0x2000000000000uLL;
  }
  if ((a2 & 0x1000000000000) != 0 && *((unsigned char *)v3 + 112) == 25) {
    v4 |= 0x1000000000000uLL;
  }
  return v4;
}

unint64_t TNode::AliasIsContainer(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  int v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  int v6 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if ((v6 & 0x40) != 0)
  {
    int v8 = (os_unfair_lock_s *)TNode::InfoLock(v7);
    os_unfair_lock_lock(v8);
    uint64_t v10 = *((void *)this + 2);
    unint64_t v9 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v8);
    unint64_t v11 = (os_unfair_lock_s *)(v10 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
    unint64_t v12 = *(unsigned int *)(v10 + 115) | ((unint64_t)*(unsigned __int16 *)(v10 + 119) << 32);
    os_unfair_lock_unlock(v11);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
    if ((v12 & 0x200000000) != 0)
    {
      unint64_t v13 = FINodeFromTNode(this);
      int v14 = dispatch_get_global_queue(0, 0);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = ___ZNK5TNode16AliasIsContainerEv_block_invoke;
      block[3] = &unk_1E698FD98;
      id v23 = v13;
      id v15 = v13;
      dispatch_async(v14, block);
    }
  }
  int v16 = (os_unfair_lock_s *)TNode::InfoLock(v7);
  os_unfair_lock_lock(v16);
  uint64_t v18 = *((void *)this + 2);
  unint64_t v17 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v16);
  int v19 = (os_unfair_lock_s *)(v18 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v18 + 100));
  unint64_t v20 = *(unsigned int *)(v18 + 115) | ((unint64_t)*(unsigned __int16 *)(v18 + 119) << 32);
  os_unfair_lock_unlock(v19);
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  return (v20 >> 17) & 1;
}

void TNotifierList::AddNotifier(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  int v5 = *(uint64_t **)(a1 + 48);
  if ((unint64_t)v5 >= *(void *)(a1 + 56))
  {
    int v7 = std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__push_back_slow_path<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>((char **)(a1 + 40), a2);
  }
  else
  {
    uint64_t v6 = *a2;
    uint64_t *v5 = *a2;
    if (v6) {
      TRefCount::Retain<int>((unsigned int *)(v6 + 36));
    }
    int v7 = (char *)(v5 + 1);
    *(void *)(a1 + 48) = v5 + 1;
  }
  *(void *)(a1 + 48) = v7;
  os_unfair_lock_unlock(v4);
}

void sub_1D3473F90(_Unwind_Exception *a1)
{
  *(void *)(v2 + 48) = v3;
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

char *std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__push_back_slow_path<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>(char **a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  CFTypeRef v24 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = &v10[8 * v4];
  unint64_t v21 = v10;
  v22.i64[0] = (uint64_t)v11;
  v22.i64[1] = (uint64_t)v11;
  id v23 = &v10[8 * v9];
  uint64_t v12 = *a2;
  *(void *)unint64_t v11 = *a2;
  if (v12)
  {
    TRefCount::Retain<int>((unsigned int *)(v12 + 36));
    unint64_t v13 = (char *)v22.i64[1];
    unint64_t v11 = (char *)v22.i64[0];
  }
  else
  {
    unint64_t v13 = &v10[8 * v4];
  }
  int v14 = v13 + 8;
  v22.i64[1] = (uint64_t)(v13 + 8);
  int v16 = *a1;
  id v15 = a1[1];
  if (v15 == *a1)
  {
    int64x2_t v18 = vdupq_n_s64((unint64_t)v15);
  }
  else
  {
    do
    {
      uint64_t v17 = *((void *)v15 - 1);
      v15 -= 8;
      *((void *)v11 - 1) = v17;
      v11 -= 8;
      *(void *)id v15 = 0;
    }
    while (v15 != v16);
    int64x2_t v18 = *(int64x2_t *)a1;
    int v14 = (char *)v22.i64[1];
  }
  *a1 = v11;
  a1[1] = v14;
  int64x2_t v22 = v18;
  int v19 = a1[2];
  a1[2] = v23;
  id v23 = v19;
  unint64_t v21 = (char *)v18.i64[0];
  std::__split_buffer<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::~__split_buffer((uint64_t)&v21);
  return v14;
}

void sub_1D34740D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t TDSNotifier::CountForOptions(uint64_t a1)
{
  if (a1)
  {
    int v1 = 1;
    uint64_t v2 = a1;
    do
    {
      if ((v1 & ~v2) == 0) {
        break;
      }
      uint64_t v2 = v2 & ~v1;
      v1 *= 2;
    }
    while (v2);
  }
  else
  {
    uint64_t v2 = 0;
    int v1 = 1;
  }
  unint64_t v3 = a1 | (unint64_t)(v2 << 32);
  uint64_t end_iter = bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(a1);
  uint64_t v6 = 0;
  while (v3 != end_iter || v1 != v5)
  {
    unsigned int v7 = (v1 & HIDWORD(v3)) - 1;
    BOOL v8 = v7 > 0x3F;
    unint64_t v9 = (1 << v7) & 0x800000000000808BLL;
    if (v8 || v9 == 0) {
      uint64_t v6 = v6;
    }
    else {
      uint64_t v6 = (v6 + 1);
    }
    if (HIDWORD(v3))
    {
      unsigned int v11 = HIDWORD(v3) & ~v1;
      unint64_t v3 = v3 | ((unint64_t)v11 << 32);
      for (v1 *= 2; v11; v1 *= 2)
      {
        if ((v1 & ~v11) == 0) {
          break;
        }
        v11 &= ~v1;
        unint64_t v3 = v3 | ((unint64_t)v11 << 32);
      }
    }
  }
  return v6;
}

uint64_t bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(uint64_t result)
{
  int v1 = 1;
  if (result)
  {
    int v2 = result;
    while ((v1 & ~v2) != 0)
    {
      v2 &= ~v1;
      v1 *= 2;
      if (!v2) {
        return result;
      }
    }
    do
    {
      v2 &= ~v1;
      v1 *= 2;
    }
    while (v2);
  }
  return result;
}

void sub_1D34742DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
}

uint64_t NodeNewSortedIterator(TNode *a1, OpaqueNodeRef *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v10 = a3;
  if (!a2) {
    return 4294959224;
  }
  *(void *)a2 = 0;
  uint64_t v6 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
  if (TNode::WeakValidate(v6, v7)) {
    return 4294959224;
  }
  uint64_t v9 = 0;
  uint64_t result = TNode::NewNodeIterator((uint64_t)v6, &v9, &v10, a4);
  if (!result) {
    *(void *)a2 = v9;
  }
  return result;
}

uint64_t TNode::NewNodeIterator(uint64_t a1, void *a2, void *a3, unsigned int a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  unsigned int v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v7);
  uint64_t v9 = *(void *)(a1 + 16);
  BOOL v8 = *(std::__shared_weak_count **)(a1 + 24);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v7);
  uint64_t v10 = (os_unfair_lock_s *)(v9 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
  int v11 = *(_DWORD *)(v9 + 115);
  os_unfair_lock_unlock(v10);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  if ((v11 & 0x20) != 0)
  {
    TNodePtr::TNodePtr((TNodePtr *)buf, (const TNode *)a1);
    uint64_t v17 = (TNode *)TNodeFromFINode(*(FINode **)buf);
    if (!TNode::LowLevelIsLockFile(v17))
    {
      int64x2_t v18 = (TNode *)TNodeFromFINode(*(FINode **)buf);
      if ((TNode::IsPopulated(v18) & 1) == 0)
      {
        uint64_t v19 = TNodeFromFINode(*(FINode **)buf);
        unint64_t v20 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v19);
        os_unfair_lock_lock(v20);
        uint64_t v22 = *(void *)(v19 + 16);
        unint64_t v21 = *(std::__shared_weak_count **)(v19 + 24);
        if (v21)
        {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v20);
          int v23 = *(unsigned __int8 *)(v22 + 112);
          std::__shared_weak_count::__release_shared[abi:ne180100](v21);
        }
        else
        {
          os_unfair_lock_unlock(v20);
          int v23 = *(unsigned __int8 *)(v22 + 112);
        }
        if (v23 != 5)
        {
          uint64_t v24 = TNodeFromFINode(*(FINode **)buf);
          unint64_t v25 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v24);
          os_unfair_lock_lock(v25);
          uint64_t v27 = *(void *)(v24 + 16);
          BOOL v26 = *(std::__shared_weak_count **)(v24 + 24);
          if (v26)
          {
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
            os_unfair_lock_unlock(v25);
            int v28 = *(unsigned __int8 *)(v27 + 112);
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          else
          {
            os_unfair_lock_unlock(v25);
            int v28 = *(unsigned __int8 *)(v27 + 112);
          }
          if (v28 != 6)
          {
            if (*a3)
            {
              uint64_t v29 = (const TNode *)TNodeFromFINode(*(FINode **)buf);
              TNode::RequestSynchronize(v29, a4 | 0x1000000);
            }
            else
            {
              id v33 = *(id *)buf;
              v30.fFINode = (FINode *)&v33;
              StFirstPopulationLock::StFirstPopulationLock((StFirstPopulationLock *)&v34, v30);

              uint64_t v31 = (TNode *)TNodeFromFINode(*(FINode **)buf);
              if ((TNode::IsPopulated(v31) & 1) == 0)
              {
                uint64_t v32 = (TNode *)TNodeFromFINode(*(FINode **)buf);
                TNode::HandlePopulate(v32, 0, HIBYTE(a4) & 1);
              }
              StFirstPopulationLock::~StFirstPopulationLock((StFirstPopulationLock *)&v34);
            }
          }
        }
      }
    }
    TNode::VirtualType((TNode *)a1);
    operator new();
  }
  if (!TNode::Validate((TNode *)a1, v12))
  {
    unint64_t v13 = LogObj(5);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      TNode::CFURL((TNode *)a1, &v34);
      int v14 = v34;
      id v15 = SanitizedURL(v14);
      *(_DWORD *)TPropertyValue buf = 138412290;
      *(void *)&uint8_t buf[4] = v15;
      _os_log_impl(&dword_1D343E000, v13, OS_LOG_TYPE_ERROR, "Failed to get node iterator for node that doesn't support container %@", buf, 0xCu);

      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v34);
    }
  }
  return 4294959224;
}

void sub_1D347467C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

unint64_t TNode::IsPopulated(TNode *this)
{
  char v1 = atomic_load((unsigned __int16 *)this + 40);
  if ((v1 & 0x10) == 0) {
    return 0;
  }
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *((void *)this + 2);
  int v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  unsigned int v7 = (os_unfair_lock_s *)(v6 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  unint64_t v8 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
  os_unfair_lock_unlock(v7);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return (v8 >> 5) & 1;
}

void TReferenceCounted::Make<TDSNotifier *>()
{
}

void sub_1D3474840(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x10A0C40554B57A3);
  _Unwind_Resume(a1);
}

uint64_t TReferenceCounted::TReferenceCounted<TDSNotifier *>(uint64_t a1, int a2, uint64_t a3)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 16) = 1;
  *(void *)(a1 + 24) = &unk_1F2ABABE0;
  *(void *)(a1 + 48) = a1 + 24;
  if (a3) {
    TRefCount::Retain<int>((unsigned int *)(a3 + 36));
  }
  return a1;
}

void sub_1D34748C8(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::TPropertyValue<TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(a1, (TReferenceCounted **)a1, a2);
  return a1;
}

void sub_1D3474910(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

TReferenceCounted **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(uint64_t a1, TReferenceCounted **a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 16) == 19)
  {
    uint64_t v4 = *a3;
    return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=(a2, v4);
  }
  else
  {
    v6[0] = a1;
    v6[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(std::__variant_detail::__alt<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>> &,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v6);
  }
}

TReferenceCounted **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&>(std::__variant_detail::__alt<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>> &,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = **(void **)(a1 + 8);
  uint64_t v4 = (TReferenceCounted *)v2;
  if (v2) {
    TRefCount::Retain<int>((unsigned int *)(v2 + 16));
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(v1, &v4);
  return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef(&v4);
}

void sub_1D34749D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::~TRef((TReferenceCounted **)va);
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 19;
  return a1;
}

BOOL TNode::IsInTrash(TNode *this)
{
  TNode::GetPath((uint64_t)this, 1, (uint64_t)&theString);
  BOOL v2 = 0;
  if (!v10)
  {
    TNode::TrashPathForNode(this, &v7);
    if (v8)
    {
      BOOL v2 = 0;
      if (TString::BeginsWith((TString *)&theString, (const TString *)&v7))
      {
        CFIndex Length = CFStringGetLength(theString);
        if (Length == CFStringGetLength(v7)
          || ((CFIndex v5 = CFStringGetLength(v7), v5 < 0) || CFStringGetLength(theString) <= v5
            ? (int CharacterAtIndex = 0)
            : (int CharacterAtIndex = CFStringGetCharacterAtIndex(theString, v5)),
              CharacterAtIndex == (unsigned __int16)TPathName::kPOSIXPathNameSeparator))
        {
          BOOL v2 = 1;
        }
      }
      if (v8) {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7);
      }
    }
    else
    {
      BOOL v2 = 0;
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v2;
}

void sub_1D3474BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TNode::GetPath@<X0>(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  v13.fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  int FullPOSIXPathDetails = TNode::GetFullPOSIXPathDetails(a1, &v13);
  if (!FullPOSIXPathDetails && (a2 & 1) == 0)
  {
    char v6 = TPathName::TPathName((TPathName *)v11, &v13, TPathName::kPOSIXPathNameSeparator);
    TGlobalNodes::BootNode((uint64_t *)&v9, v6);
    CFStringRef v7 = (TNode *)TNodeFromFINode(v9);
    TNode::DisplayName(v7, &v10);
    int FullPOSIXPathDetails = TPathName::AsOldStyleFullPath((TPathName *)v11, &v10, &v13);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);

    std::deque<TString>::~deque[abi:ne180100](v11);
  }
  fstd::optional_err<TString,int>::optional_err(a3, (TString **)&v13, &FullPOSIXPathDetails);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
}

void sub_1D3474CCC(_Unwind_Exception *a1, void *a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  std::deque<TString>::~deque[abi:ne180100]((uint64_t *)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v2 - 40));
  _Unwind_Resume(a1);
}

const void **TNode::GetPath@<X0>(TNode *this@<X0>, uint64_t a2@<X8>)
{
  v6.fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  int FullPOSIXPathDetails = TNode::GetFullPOSIXPathDetails((uint64_t)this, &v6);
  fstd::optional_err<TString,int>::optional_err(a2, (TString **)&v6, &FullPOSIXPathDetails);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
}

void sub_1D3474D7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::GetFullPOSIXPathDetails(uint64_t a1, TString *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *(void *)(a1 + 16);
  CFIndex v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  CFStringRef v7 = (os_unfair_lock_s *)(v6 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  char v8 = *(void **)(v6 + 16);
  TString v13 = v8;
  if (v8) {
    CFRetain(v8);
  }
  os_unfair_lock_unlock(v7);
  id v9 = v8;
  TString v10 = [v9 path];
  if ((TString *)a2->fString.fRef != v10) {
    TString::SetStringRefAsImmutable(a2, v10);
  }

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v13);
  CFIndex Length = CFStringGetLength(a2->fString.fRef);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  if (Length) {
    return 0;
  }
  else {
    return 4294967253;
  }
}

void sub_1D3474E7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  _Unwind_Resume(a1);
}

uint64_t fstd::optional_err<TString,int>::optional_err(uint64_t a1, TString **a2, _DWORD *a3)
{
  *(void *)a1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  *(_DWORD *)(a1 + 8) = *a3;
  return a1;
}

void sub_1D3474F20(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

unint64_t TNode::IsInitialPopulating(TNode *this)
{
  char v1 = atomic_load((unsigned __int16 *)this + 40);
  if ((v1 & 8) == 0) {
    return 0;
  }
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *((void *)this + 2);
  CFIndex v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  CFStringRef v7 = (os_unfair_lock_s *)(v6 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  unint64_t v8 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
  os_unfair_lock_unlock(v7);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return (v8 >> 5) & 1;
}

uint64_t *_ZNSt3__110unique_ptrIZL10MakeUniqueI32NodeObservedOptionsCountRegistryJEENS0_IT_NS_14default_deleteIS3_EEEEDpOT0_E19MakeInstanceEnablerNS4_ISA_EEED1B8ne180100Ev(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::~__hash_table(v2);
    MEMORY[0x1D9436740](v3, 0x10A0C408EF24B1CLL);
  }
  return a1;
}

uint64_t std::unique_ptr<NodeObservedOptionsCountRegistry>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::~__hash_table(result);
    JUMPOUT(0x1D9436740);
  }
  return result;
}

uint64_t std::equal_to<FINode * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  if (v4 == v5) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = [v4 isEqual:v5];
  }

  return v6;
}

void sub_1D34750C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::HandlePopulate(TNode *this, int a2, int a3)
{
  unint64_t IsInitialPopulationDeferred = TNode::IsInitialPopulationDeferred(this);
  if ((IsInitialPopulationDeferred & 1) == 0)
  {
    TGlobalNodes::RootNode((uint64_t *)&v10, (TGlobalNodes *)IsInitialPopulationDeferred);
    CFStringRef v7 = (TNode *)TNodeFromFINode(v10);

    if (v7 != this)
    {
      if (a2) {
        int v8 = 83886080;
      }
      else {
        int v8 = 0x1000000;
      }
      if (a3) {
        unsigned int v9 = v8 | 0x40000000;
      }
      else {
        unsigned int v9 = v8;
      }
      TNode::HandleSync((uint64_t)this, v9);
    }
  }
}

void sub_1D3475160(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

unint64_t TNode::IsInitialPopulationDeferred(TNode *this)
{
  char v1 = atomic_load((unsigned __int16 *)this + 40);
  if ((v1 & 0x20) == 0) {
    return 0;
  }
  id v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *((void *)this + 2);
  id v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  CFStringRef v7 = (os_unfair_lock_s *)(v6 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  unint64_t v8 = *(unsigned int *)(v6 + 115) | ((unint64_t)*(unsigned __int16 *)(v6 + 119) << 32);
  os_unfair_lock_unlock(v7);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return (v8 >> 5) & 1;
}

TChildrenList *TChildrenList::IncrementRegisteredChildrenCount(TChildrenList *this)
{
  return this;
}

void sub_1D347531C(_Unwind_Exception *a1, uint64_t a2, TPropertyValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  _Unwind_Resume(a1);
}

const void **TFSInfo::SynchronizeTags(TFSInfo *a1, TFSInfo **a2, uint64_t **a3)
{
  unint64_t v8 = TFSInfo::CopyTagsAndAttributes(a1, 0);
  CFStringRef v7 = TFSInfo::CopyTagsAndAttributes(*a2, 0);
  if ((IsEqual(v8, v7) & 1) == 0)
  {
    unsigned int v6 = 1718903156;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v6, &v6);
  }
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&v7);
  return TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&v8);
}

void sub_1D3475414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  id v4 = va_arg(va1, const void *);
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

__CFArray *TFSInfo::CopyTagsAndAttributes(TFSInfo *this, int a2)
{
  v44[2] = *MEMORY[0x1E4F143B8];
  CFArrayRef theArray = 0;
  if (a2)
  {
    locuint64_t k = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    uint64_t v3 = (void *)*((void *)this + 2);
    id obj = v3;
    if (v3)
    {
      CFRetain(v3);
      id v4 = obj;
    }
    else
    {
      id v4 = 0;
    }
    os_unfair_lock_unlock(lock);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&obj);
    if (v4)
    {
      CFArrayRef v9 = (const __CFArray *)TFSInfo::CopyTagsForPath(this);
      CFArrayRef theArray = v9;
    }
    else
    {
      id v15 = TFSInfo::GetFPItem(this);
      uint64_t v31 = [v15 tags];

      if ([v31 count] && objc_opt_class())
      {
        TNodePtr v30 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithCapacity:", objc_msgSend(v31, "count"));
        IDContainerIteratorAdaptor<NSArray<FPTag *>>::NSForwardIterator<NSArray<FPTag *>>::NSForwardIterator((uint64_t)&obj, v31);
        IDContainerIteratorAdaptor<NSArray<FPTag *>>::IDContainerIteratorAdaptor((uint64_t)v35, -1, v31);
        id v33 = v30;
        while (obj != v35[0] || v41 != v35[16])
        {
          int v16 = *(&v37[1]->isa + v40);
          uint64_t v17 = [v16 label];
          if ([v17 length])
          {
            __int16 v42 = [v16 color];
            int64x2_t v18 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v42 length:2];
            uint64_t v19 = @"TagName";
            v43[0] = v19;
            v44[0] = v17;
            unint64_t v20 = @"TagColor";
            v43[1] = v20;
            v44[1] = v18;
            uint64_t v21 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v44 forKeys:v43 count:2];

            id v22 = v33;
            [v22 addObject:v21];

            int v16 = (void *)v21;
          }
          else
          {
          }
          uint64_t v23 = v40;
          if (v40 >= v39 - 1)
          {
            uint64_t v24 = [obj countByEnumeratingWithState:v37 objects:v38 count:4];
            uint64_t v23 = -1;
            uint64_t v39 = v24;
            uint64_t v40 = -1;
          }
          if ((void *)v38[4] != v37[2]->isa)
          {
            objc_enumerationMutation(obj);
            uint64_t v23 = v40;
          }
          uint64_t v40 = v23 + 1;
          ++v41;
        }

        CFArrayRef theArray = (CFArrayRef)v33;
      }

      CFArrayRef v9 = theArray;
    }
    unint64_t v25 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)this + 11, v9);
    os_unfair_lock_lock(lock);
    unsigned int v27 = *(_DWORD *)((char *)this + 115);
    BOOL v26 = (char *)this + 115;
    unint64_t v28 = v27 | ((unint64_t)*((unsigned __int16 *)v26 + 2) << 32) | 0x40000000000;
    *(_DWORD *)BOOL v26 = v27;
    *((_WORD *)v26 + 2) = WORD2(v28);
    os_unfair_lock_unlock(lock);
    os_unfair_lock_unlock(v25);
    os_unfair_lock_lock(lock);
    *((_WORD *)v26 + 2) |= 0x400u;
    os_unfair_lock_unlock(lock);
    CFArrayRef v8 = theArray;
    if (!theArray) {
      goto LABEL_32;
    }
  }
  else
  {
    id v5 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    unsigned int v6 = (const void *)*((void *)this + 11);
    if (v6)
    {
      CFTypeRef v7 = CFRetain(v6);
      CFArrayRef v8 = (const __CFArray *)static_cf_cast<__CFString const*,void const*>(v7);
    }
    else
    {
      CFArrayRef v8 = 0;
    }
    os_unfair_lock_unlock(v5);
    CFArrayRef theArray = v8;
    if (!v8)
    {
LABEL_32:
      Mutable = 0;
      goto LABEL_33;
    }
  }
  CFIndex Count = CFArrayGetCount(v8);
  Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E4F1D510]);
  for (CFIndex i = 0; i < CFArrayGetCount(theArray); ++i)
  {
    ValueAtint Index = (TCFURLInfo *)CFArrayGetValueAtIndex(theArray, i);
    TCFURLInfo::DecodeEncodedTagString(ValueAtIndex, (uint64_t *)&obj);
    if (obj)
    {
      v35[0] = TCFURLInfo::CreateTagDictionary((TCFURLInfo *)obj, v37[0], v14);
      CFArrayAppendValue(Mutable, v35[0]);
      TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef(v35);
    }
  }
LABEL_33:
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&theArray);
  return Mutable;
}

void sub_1D3475884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, os_unfair_lock_t lock, uint64_t a13, uint64_t a14, const void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34)
{
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef(&a15);
  _Unwind_Resume(a1);
}

const void **TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void TNode::AttachFPItemsMetadata(id **a1, int a2, char a3)
{
  memset(v22, 0, sizeof(v22));
  uint64_t v3 = *a1;
  id v4 = a1[1];
  if (*a1 != v4)
  {
    do
    {
      unsigned int v6 = (FINode *)*v3;
      uint64_t v7 = TNodeFromFINode(v6);
      CFArrayRef v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v7);
      os_unfair_lock_lock(v8);
      TString v10 = *(TFSInfo **)(v7 + 16);
      CFArrayRef v9 = *(std::__shared_weak_count **)(v7 + 24);
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v8);
      TFSInfo::GetFPItem(v10);
      int v11 = (FPItem *)objc_claimAutoreleasedReturnValue();
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      }
      uint64_t v12 = (FPItem *)v3[1];
      if (v11 != v12)
      {
        uint64_t v13 = TNodeFromFINode(v6);
        CFDataRef v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v13);
        os_unfair_lock_lock(v14);
        int v16 = *(const TFSInfo **)(v13 + 16);
        id v15 = *(std::__shared_weak_count **)(v13 + 24);
        if (v15) {
          atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v14);
        TFSInfo::MarkAsUsed((TFSInfo *)&v23);
        std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,TFSInfo&,void>(v16, &v20);
        TFSInfo::MarkAsUsed((TFSInfo *)&v23);
        TFSInfo::SetFPItem(v20, v12);
        uint64_t v17 = (TNode *)TNodeFromFINode(v6);
        TNode::FetchAdditionalPropertiesForSync(v17, &v20, a2);
        uint64_t v18 = TNodeFromFINode(v6);
        TNode::ReconcileInternalProperties(v18, &v20, (TNodeEventPtrs *)v22, a2);
        if (v21) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v21);
        }
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
        }
      }

      v3 += 2;
    }
    while (v3 != v4);
  }
  if (a3) {
    TNodeEventPtrs::SendNotifications(v22);
  }
  unint64_t v20 = (TFSInfo *)v22;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);
}

void sub_1D3475B70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, uint64_t a12, char a13)
{
  a11 = (void **)&a13;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100](&a11);
  _Unwind_Resume(a1);
}

CFIndex TNode::HandleSync(uint64_t a1, unsigned int a2)
{
  memset(v4, 0, sizeof(v4));
  CFIndex v2 = TNode::HandleSync(a1, a2, (uint64_t)v4);
  TNodeEventPtrs::SendNotifications(v4);
  id v5 = v4;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v5);
  return v2;
}

void sub_1D3475C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

CFIndex TNode::HandleSync(uint64_t a1, unsigned int a2, uint64_t a3)
{
  BOOL v78 = 0;
  IsFPCFIndex v2 = (TNode *)TNode::VirtualType((TNode *)a1);
  if (IsFPv2 == 26 || (IsFPv2 = (TNode *)TNode::IsFPv2((TNode *)a1, 1), int v7 = a2, IsFPv2)) {
    int v7 = a2 | 0x800000;
  }
  CFArrayRef v8 = (os_unfair_lock_s *)TNode::InfoLock(IsFPv2);
  os_unfair_lock_lock(v8);
  TString v10 = *(TFSInfo **)(a1 + 16);
  CFArrayRef v9 = *(std::__shared_weak_count **)(a1 + 24);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  int IsDataless = TFSInfo::IsDataless(v10, v11, v12);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  CFDataRef v14 = (TNode *)TNode::HandleSyncStarted(a1, v7, &v78);
  id v15 = v14;
  int v16 = !v78 & (a2 >> 19);
  memset(v77, 0, sizeof(v77));
  if ((a2 & 0x100) != 0) {
    goto LABEL_13;
  }
  uint64_t v17 = (os_unfair_lock_s *)TNode::InfoLock(v14);
  os_unfair_lock_lock(v17);
  uint64_t v19 = *(void *)(a1 + 16);
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v18)
  {
    os_unfair_lock_unlock(v17);
    if (*(unsigned char *)(v19 + 112)) {
      goto LABEL_11;
    }
LABEL_15:
    if ((v16 & 1) == 0)
    {
      uint64_t v24 = (os_unfair_lock_s *)TNode::InfoLock(v21);
      os_unfair_lock_lock(v24);
      uint64_t v26 = *(void *)(a1 + 16);
      unint64_t v25 = *(std::__shared_weak_count **)(a1 + 24);
      if (v25) {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v24);
      os_unfair_lock_lock((os_unfair_lock_t)(v26 + 100));
      int v27 = *(_DWORD *)(v26 + 115);
      os_unfair_lock_unlock((os_unfair_lock_t)(v26 + 100));
      if ((v27 & 0x8000) != 0) {
        uint64_t v21 = (TNode *)TFSInfo::TriggerMount((TFSInfo *)v26);
      }
      if (v25) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v25);
      }
    }
    unint64_t v28 = (os_unfair_lock_s *)TNode::ParentLock(v21);
    os_unfair_lock_lock(v28);
    TNodePtr::TNodePtr(&v76, *(const TNode **)(a1 + 48));
    os_unfair_lock_unlock(v28);
    TNodePtr v30 = (os_unfair_lock_s *)TNode::InfoLock(v29);
    os_unfair_lock_lock(v30);
    uint64_t v32 = *(TFSInfo **)(a1 + 16);
    uint64_t v31 = *(std::__shared_weak_count **)(a1 + 24);
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v30);
    TFSInfo::Name(v32, &v75);
    if (v31) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v31);
    }
    _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v73);
    id v33 = (TNode *)TNodeFromFINode(v76.fFINode);
    if (v33)
    {
      uint64_t v34 = v73;
      uint64_t v35 = TNodeFromFINode(v76.fFINode);
      uint64_t v36 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v35);
      os_unfair_lock_lock(v36);
      uint64_t v37 = *(std::__shared_weak_count **)(v35 + 24);
      uint64_t v71 = *(os_unfair_lock_s **)(v35 + 16);
      char v72 = (TNode *)v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v36);
      CFIndex AdditionalPropertiesForSync = TFSInfo::Initialize(v34, &v71, &v75);
      id v33 = v72;
      if (v72) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v72);
      }
      if (!AdditionalPropertiesForSync) {
        goto LABEL_46;
      }
    }
    else
    {
      CFIndex AdditionalPropertiesForSync = 4294959236;
    }
    uint64_t v38 = (os_unfair_lock_s *)TNode::InfoLock(v33);
    os_unfair_lock_lock(v38);
    uint64_t v40 = *(void *)(a1 + 16);
    uint64_t v39 = *(std::__shared_weak_count **)(a1 + 24);
    if (v39)
    {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v38);
      int v41 = *(unsigned __int8 *)(v40 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v39);
      if (!v41)
      {
LABEL_39:
        __int16 v42 = (TNode *)TNodeFromFINode(v76.fFINode);
        if (v42) {
          goto LABEL_64;
        }
      }
    }
    else
    {
      os_unfair_lock_unlock(v38);
      if (!*(unsigned char *)(v40 + 112)) {
        goto LABEL_39;
      }
    }
    uint64_t v43 = (os_unfair_lock_s *)TNode::InfoLock(v42);
    os_unfair_lock_lock(v43);
    uint64_t v45 = *(TFSInfo **)(a1 + 16);
    TString v44 = *(std::__shared_weak_count **)(a1 + 24);
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v43);
    CFURLRef CFURLRef = (os_unfair_lock_s *)TFSInfo::CreateCFURLRef(v45);
    uint64_t v71 = CFURLRef;
    if (v44)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v44);
      CFURLRef CFURLRef = v71;
    }
    if (CFURLRef)
    {
      CFIndex AdditionalPropertiesForSync = TFSInfo::initialize((uint64_t)v73, (const __CFURL *)CFURLRef, 0, 1, 1, 1, 0);
      TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v71);
      if (!AdditionalPropertiesForSync)
      {
LABEL_46:
        EnumeratorCFIndex Properties = TFSInfo::FetchEnumeratorProperties(v73);
        dispatch_time_t v48 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)EnumeratorProperties);
        os_unfair_lock_lock(v48);
        uint64_t v50 = *(void *)(a1 + 16);
        long long v49 = *(std::__shared_weak_count **)(a1 + 24);
        if (v49) {
          atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v48);
        if ((a2 & 0x8000) != 0)
        {
          dispatch_time_t v51 = (os_unfair_lock_s *)(v50 + 96);
          os_unfair_lock_lock((os_unfair_lock_t)(v50 + 96));
          uint64_t v52 = *(void *)(v50 + 80);
          if (v52
            && (os_unfair_lock_lock((os_unfair_lock_t)(v52 + 72)),
                int v53 = *(unsigned __int8 *)(v52 + 76),
                os_unfair_lock_unlock((os_unfair_lock_t)(v52 + 72)),
                v53 == 1))
          {
            id v54 = *(id *)(v52 + 24);
          }
          else
          {
            id v54 = 0;
          }
          os_unfair_lock_unlock(v51);
          if (v54) {
            TFSInfo::UpdateFileProvider(v73, 0);
          }
        }
        CFIndex AdditionalPropertiesForSync = TNode::FetchAdditionalPropertiesForSync((TNode *)a1, &v73, 1);
        if (v49) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v49);
        }
        if (!AdditionalPropertiesForSync)
        {
          if (TNode::ReconcileInternalProperties(a1, &v73, v77, 1) && TNodeFromFINode(v76.fFINode))
          {
            TNodeFromFINode(v76.fFINode);
            TNode::AttachCreateFPItemIfNeeded((TNode *)a1, 1u);
          }
          CFIndex AdditionalPropertiesForSync = 0;
        }
      }
    }
    else
    {
      TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v71);
    }
LABEL_64:
    if (v74) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v74);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v75.fString.fRef);

    goto LABEL_67;
  }
  atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  os_unfair_lock_unlock(v17);
  int v20 = *(unsigned __int8 *)(v19 + 112);
  std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  if (!v20) {
    goto LABEL_15;
  }
LABEL_11:
  id v22 = (os_unfair_lock_s *)TNode::InfoLock(v21);
  os_unfair_lock_lock(v22);
  CFIndex AdditionalPropertiesForSync = *(void *)(a1 + 24);
  if (AdditionalPropertiesForSync)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(AdditionalPropertiesForSync + 8), 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v22);
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)AdditionalPropertiesForSync);
LABEL_13:
    CFIndex AdditionalPropertiesForSync = 0;
    goto LABEL_67;
  }
  os_unfair_lock_unlock(v22);
LABEL_67:
  BOOL v55 = (os_unfair_lock_s *)TNode::InfoLock(v14);
  os_unfair_lock_lock(v55);
  uint64_t v57 = *(void *)(a1 + 16);
  unsigned int v56 = *(std::__shared_weak_count **)(a1 + 24);
  if (v56) {
    atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v55);
  __int16 v58 = (os_unfair_lock_s *)(v57 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v57 + 100));
  int v59 = *(_DWORD *)(v57 + 115);
  os_unfair_lock_unlock(v58);
  if (v56) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v56);
  }
  if ((v59 & 0x20) != 0) {
    char v61 = v16;
  }
  else {
    char v61 = 1;
  }
  if ((v61 & 1) == 0)
  {
    char v62 = FIDSNodeFromTNode((TNode *)a1);
    [v62 synchronizeChildren:v15 events:v77];
  }
  if (IsDataless)
  {
    char v63 = (os_unfair_lock_s *)TNode::InfoLock(v60);
    os_unfair_lock_lock(v63);
    char v65 = *(TFSInfo **)(a1 + 16);
    uint64_t v64 = *(std::__shared_weak_count **)(a1 + 24);
    if (v64) {
      atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v63);
    char IsDatalessNow = TFSInfo::IsDatalessNow(v65);
    if (v64) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v64);
    }
    if ((IsDatalessNow & 1) == 0) {
      LODWORD(v15) = v15 | 0x800000;
    }
  }
  int v67 = TNode::VirtualType((TNode *)a1);
  int v68 = ICloudDriveFPFSEnabled();
  if ((v67 - 23) < 2) {
    int v69 = v68;
  }
  else {
    int v69 = 0;
  }
  if (v69 == 1 && !TNode::IsPopulated((TNode *)a1)) {
    LODWORD(v15) = v15 | 0x800000;
  }
  TNode::HandleSyncCompleted(a1, (int)v15);
  TNodeEventPtrs::AddEvents(a3, v77);
  CFArrayRef v73 = (TFSInfo *)v77;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v73);
  return AdditionalPropertiesForSync;
}

void sub_1D3476248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, std::__shared_weak_count *a12, const void *a13, id a14, char a15)
{
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a13);

  a11 = (void **)&a15;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100](&a11);
  _Unwind_Resume(a1);
}

void std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  CFIndex v2 = (id **)*a1;
  if (*v2)
  {
    std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

id *std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>,std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>>(uint64_t a1, id *a2, id *a3, id *a4, uint64_t a5)
{
  id v5 = a2;
  if (a5 >= 1)
  {
    int v7 = a3;
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v9 = a1 + 16;
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 4)
    {
      uint64_t v19 = v12 - (void)a2;
      uint64_t v20 = (uint64_t)(v12 - (void)a2) >> 4;
      if (v20 >= a5)
      {
        uint64_t v21 = &a3[2 * a5];
      }
      else
      {
        uint64_t v21 = &a3[2 * v20];
        *(void *)(a1 + 8) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::pair<TNodePtr,TNodeEventPtr> const*,std::pair<TNodePtr,TNodeEventPtr> const*,std::pair<TNodePtr,TNodeEventPtr>*>(v9, v21, a4, *(void **)(v9 - 8));
        if (v19 < 1) {
          return v5;
        }
      }
      std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__move_range((void **)a1, (uint64_t)v5, v12, &v5[2 * a5]);
      if (v21 != v7)
      {
        id v22 = v5;
        do
        {
          std::pair<TNodePtr,TNodeEventPtr>::operator=[abi:ne180100](v22, v7);
          v7 += 2;
          v22 += 2;
        }
        while (v7 != v21);
      }
    }
    else
    {
      uint64_t v13 = *(unsigned char **)a1;
      unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
      if (v14 >> 60) {
        std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v15 = ((char *)a2 - v13) >> 4;
      uint64_t v16 = v10 - (void)v13;
      if (v16 >> 3 > v14) {
        unint64_t v14 = v16 >> 3;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v14;
      }
      uint64_t v28 = v9;
      if (v17) {
        uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(v9, v17);
      }
      else {
        uint64_t v18 = 0;
      }
      uint64_t v24 = v18;
      unint64_t v25 = &v18[16 * v15];
      uint64_t v26 = v25;
      int v27 = &v18[16 * v17];
      std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::__construct_at_end_with_size<std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>>(&v24, v7, a5);
      id v5 = (id *)std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__swap_out_circular_buffer(a1, &v24, v5);
      std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::~__split_buffer((uint64_t)&v24);
    }
  }
  return v5;
}

void sub_1D3476530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

id *TNodeEventPtrs::AddEvents(uint64_t a1, id **a2)
{
  return std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__insert_with_size[abi:ne180100]<std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>,std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>>(a1, *(id **)(a1 + 8), *a2, a2[1], ((char *)a2[1] - (char *)*a2) >> 4);
}

uint64_t TNode::HandleSyncStarted(uint64_t a1, int a2, BOOL *a3)
{
  *a3 = 0;
  StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v14);
  int v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v7);
  uint64_t v9 = *(void *)(a1 + 16);
  CFArrayRef v8 = *(std::__shared_weak_count **)(a1 + 24);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v7);
  uint64_t v10 = (os_unfair_lock_s *)(v9 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
  int v11 = *(_DWORD *)(v9 + 115);
  os_unfair_lock_unlock(v10);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  BOOL v12 = 0;
  if ((a2 & 0x1800000) != 0 && (v11 & 0x20) != 0) {
    BOOL v12 = (atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 8u) & 8) == 0;
  }
  *a3 = v12;
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v14);
  if (*a3)
  {
    TNodePtr::TNodePtr(&v14, (const TNode *)a1);
    TNode::SendNotification((const TNode *)a1, 9, (id *)&v14.fFINode, 0, 0);
  }
  else
  {
    if ((a2 & 0x800000) != 0) {
      return a2 & 0xFF7FFFFF;
    }
    TNodePtr::TNodePtr(&v14, (const TNode *)a1);
  }

  if (*a3) {
    return a2 | 0x4800000u;
  }
  return a2 & 0xFF7FFFFF;
}

void sub_1D34766A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

unint64_t TFSInfo::IsDataless(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  return ((unint64_t)TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E4F1CDC8], a3) >> 30) & 1;
}

void TNode::SynchronizeChildren(uint64_t a1, int a2, TNodeEventPtrs *a3)
{
  id v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v5);
  uint64_t v7 = *(void *)(a1 + 16);
  unsigned int v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v5);
    int v8 = *(unsigned __int8 *)(v7 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    if (v8) {
      goto LABEL_8;
    }
  }
  else
  {
    os_unfair_lock_unlock(v5);
    if (*(unsigned char *)(v7 + 112)) {
      goto LABEL_8;
    }
  }
  TNode::CFURL((TNode *)a1, &v166);
  uint64_t v9 = v166;
  uint64_t v10 = [v9 path];
  v169.fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v169, v10);

  fRef = v169.fString.fRef;
  *(void *)TPropertyValue buf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, fRef);
  if (*(void *)buf) {
    CFRelease(*(CFTypeRef *)buf);
  }
  *(void *)TPropertyValue buf = MutableCopy;
  TString::Append((TString *)buf, (const __CFString *)"/");
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v169.fString.fRef);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v166);
  char v13 = PathEligibleForSynching((const TString *)buf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
  if (v13)
  {
LABEL_8:
    TNodePtr v14 = (TNode *)TNode::VirtualType((TNode *)a1);
    int v146 = (int)v14;
    if (v14 == 29)
    {
      uint64_t v15 = LogObj(6);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)TPropertyValue buf = 0;
        _os_log_impl(&dword_1D343E000, v15, OS_LOG_TYPE_DEFAULT, "Synching iTunes device list", buf, 2u);
      }
    }
    uint64_t v16 = (os_unfair_lock_s *)TNode::InfoLock(v14);
    os_unfair_lock_lock(v16);
    uint64_t v18 = *(void *)(a1 + 16);
    unint64_t v17 = *(std::__shared_weak_count **)(a1 + 24);
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v16);
    uint64_t v19 = (os_unfair_lock_s *)(v18 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v18 + 100));
    int v20 = *(_DWORD *)(v18 + 115);
    os_unfair_lock_unlock(v19);
    if (v17) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
    }
    if ((v20 & 0x100) != 0)
    {
      TNode::GetVolumeInfo((TNode *)a1, buf);
      TFSVolumeInfo::ReadHiddenListFile(*(TFSVolumeInfo **)buf);
      if (v173) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v173);
      }
    }
    BOOL v21 = 0;
    int v149 = a2 & 0xC00000;
    int v22 = a2 & 0xA00000;
    int v148 = a2 & 0x1200000;
    int v142 = a2 & 0x1C00000;
    int v143 = a2 & 0xA00000;
    BOOL v23 = (a2 & 0x1200000) == 0x200000 || v22 == 10485760;
    int v24 = v23;
    int v144 = a2;
    int v145 = v24;
    while (1)
    {
      BOOL v25 = TNode::NeedsChildReconcile((TNode *)a1);
      if (v22 != 10485760 && v148 != 0x200000 && !v142 && !v25) {
        return;
      }
      uint64_t v26 = TTime::MicrosecondsSinceStartup((TTime *)v25);
      TNodePtr::TNodePtr((TNodePtr *)&v169, (const TNode *)a1);
      TNode::StPopulating::StPopulating((TNode::StPopulating *)buf, (const TNodePtr *)&v169, 0);

      int v27 = v174;
      TNode::StPopulating::~StPopulating((FINode **)buf);
      if ((a2 & 0x40000000) != 0) {
        TNode::SetPrefetchPropertiesOnSync((TNode *)a1);
      }
      unint64_t v151 = v26;
      BOOL Dir = TFSVolumeInfo::ShouldUseReadDir(*(TFSVolumeInfo **)a1);
      if (Dir)
      {
        BOOL Dir = TNode::ShouldUseReadDir((TNode *)a1);
        uint64_t v29 = (const TString *)Dir;
      }
      else
      {
        uint64_t v29 = 0;
      }
      if ((TFSVolumeInfo::ShouldSkipLSProperties((TFSVolumeInfo *)Dir) & 1) == 0) {
        atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x1000u);
      }
      TNodePtr::TNodePtr((TNodePtr *)&v169, (const TNode *)a1);
      TFSInfoSynchronizer::TFSInfoSynchronizer((TFSInfoSynchronizer *)buf, (const TNodePtr *)&v169);

      double Current = CFAbsoluteTimeGetCurrent();
      CFStringRef v31 = (const __CFString *)*(unsigned __int8 *)(*(void *)a1 + 133);
      unsigned __int16 v32 = atomic_load((unsigned __int16 *)(a1 + 80));
      int Children = TFSInfoSynchronizer::FetchChildren((uint64_t)buf, (uint64_t)v29, v31, (v32 & 0x1000) == 0);
      int v34 = Children;
      if (Children == -8086 || !Children)
      {
        BOOL v21 = Children == -8086;
        if (Children != -8086) {
          atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x1000u);
        }
        double v35 = CFAbsoluteTimeGetCurrent();
        if (TFSVolumeInfo::ShouldRecordIterationTimes(v36))
        {
          TNode::Path((TNode *)a1, (CFTypeRef *)&v169.fString.fRef);
          if (CFStringGetLength(v169.fString.fRef)) {
            TFSVolumeInfo::UpdateIterationPerfData((TFSVolumeInfo *)&v169, v29, v35 - Current, v34 == -8086, ((uint64_t)v173 - *(void *)buf) >> 4);
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v169.fString.fRef);
        }
      }
      if (!v34 || v34 == -8086) {
        break;
      }
      char v39 = 1;
      int v38 = 1;
LABEL_210:
      if (v176) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v176);
      }

      v169.fString.fRef = (__CFString *)buf;
      std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v169);
      if ((v38 | 4) != 4 || (v39 & 1) == 0) {
        return;
      }
    }
    uint64_t v37 = (std::__shared_weak_count *)operator new(0x30uLL);
    v37->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB4A8;
    v37->__shared_owners_ = 0;
    v37->__shared_weak_owners_ = 0;
    v37[1].__vftable = 0;
    v37[1].__shared_owners_ = 0;
    v37[1].__shared_weak_owners_ = 0;
    v169.fString.fRef = 0;
    uint64_t v170 = 0;
    uint64_t v171 = 0;
    v166 = 0;
    v167 = 0;
    uint64_t v168 = 0;
    v163 = 0;
    v164 = 0;
    unint64_t v165 = 0;
    TNodePtr::TNodePtr(v159, (const TNode *)a1);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)v161, v159, 0);

    BOOL v150 = v162 != v27;
    if (v162 != v27)
    {
      TNode::StPopulating::~StPopulating((FINode **)v161);
      int v38 = 4;
LABEL_209:
      v161[0] = (void **)&v163;
      std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__destroy_vector::operator()[abi:ne180100](v161);
      v163 = &v166;
      std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v163);
      v166 = &v169;
      std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v166);
      std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      char v39 = v150;
      goto LABEL_210;
    }
    if (v146)
    {
      BOOL v40 = 0;
    }
    else
    {
      TNode::CFURL((TNode *)a1, v159);
      BOOL v40 = URLMightBeInFileProvider((uint64_t)v159[0].fFINode) != 0;
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v159[0].fFINode);
    }
    uint64_t v41 = *(void *)(a1 + 56);
    __int16 v42 = (void *)(v41 + 64);
    BOOL v23 = v41 == 0;
    uint64_t v43 = &TNode::GetChildren(void)const::sEmptyList;
    if (!v23) {
      uint64_t v43 = v42;
    }
    uint64_t v46 = v43;
    uint64_t v44 = *v43;
    uint64_t v45 = v46[1];
    uint64_t v47 = v45 - v44;
    if (((v45 != v44) & ~v145) != 0)
    {
      v159[0].fFINode = 0;
      v159[1].fFINode = 0;
      uint64_t v160 = 0;
      TNode::UnmarkChildren((TNode *)a1);
      TFSInfoSynchronizer::Next((uint64_t *)buf, v158);
      if (v158[0].fFINode)
      {
        uint64_t v62 = *(void *)(a1 + 56);
        if (v62) {
          char v63 = (FINode ***)(v62 + 64);
        }
        else {
          char v63 = (FINode ***)&TNode::GetChildren(void)const::sEmptyList;
        }
        do
        {
          while (1)
          {
            uint64_t v64 = TChildrenList::LowerBounds(v62, (TFSInfo **)v158);
            char v65 = (id *)v64;
            if (v63[1] == v64) {
              goto LABEL_216;
            }
            uint64_t v66 = TNodeFromFINode(*v64);
            int v67 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v66);
            os_unfair_lock_lock(v67);
            int v69 = *(TFSInfo **)(v66 + 16);
            int v68 = *(std::__shared_weak_count **)(v66 + 24);
            if (v68) {
              atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            os_unfair_lock_unlock(v67);
            char v70 = TFSInfo::SameIdentity(v69, (TFSInfo **)v158);
            if (v68) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v68);
            }
            if ((v70 & 1) == 0)
            {
LABEL_216:
              v153.fFINode = 0;
              TChildrenList::FindRenamedChild(v62, (TFSInfo **)v158, (TNodePtr *)cf);
              TNodePtr::operator=((void **)&v153.fFINode, (void **)cf);

              if (!TNodeFromFINode(v153.fFINode)
                || (unsigned __int16 v77 = atomic_load((unsigned __int16 *)(TNodeFromFINode(v153.fFINode) + 80)), (v77 & 0x100) != 0))
              {
                fFINode = v158[0].fFINode;
                uint64_t v80 = (os_unfair_lock_s *)&v158[0].fFINode[12].super.isa + 1;
                os_unfair_lock_lock((os_unfair_lock_t)&v158[0].fFINode[12].super.isa + 1);
                LODWORD(fFINode) = *(_DWORD *)((char *)&fFINode[14].super.isa + 3);
                os_unfair_lock_unlock(v80);
                if (((unsigned __int16)fFINode & 0x100) != 0 && !LOBYTE(v158[0].fFINode[14].super.isa)) {
                  unint64_t v81 = (uint64_t *)&v169;
                }
                else {
                  unint64_t v81 = (uint64_t *)v159;
                }
                std::vector<std::shared_ptr<TFSInfo>>::push_back[abi:ne180100](v81, (long long *)v158);
              }
              else
              {
                cf[0] = v153.fFINode;
                cf[1] = v158[0].fFINode;
                cf[2] = v158[1].fFINode;
                if (v158[1].fFINode) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)&v158[1].fFINode[1], 1uLL, memory_order_relaxed);
                }
                if ((unint64_t)v164 >= v165)
                {
                  v164 = (void **)std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__push_back_slow_path<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>((uint64_t *)&v163, (uint64_t)cf);
                  if (cf[2]) {
                    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)cf[2]);
                  }
                }
                else
                {
                  BOOL v78 = TNodePtr::TNodePtr(v164, (id *)cf);
                  *(_OWORD *)(v78 + 1) = *(_OWORD *)&cf[1];
                  cf[1] = 0;
                  cf[2] = 0;
                  v164 = (void **)(v78 + 3);
                }

                atomic_fetch_or((atomic_ushort *volatile)(TNodeFromFINode(v153.fFINode) + 80), 0x100u);
              }
            }
            else
            {
              uint64_t v71 = (FINode *)*v65;
              uint64_t v72 = TNodeFromFINode(v71);
              CFArrayRef v73 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v72);
              os_unfair_lock_lock(v73);
              uint64_t v75 = *(void *)(v72 + 16);
              BOOL v74 = *(std::__shared_weak_count **)(v72 + 24);
              if (v74)
              {
                atomic_fetch_add_explicit(&v74->__shared_owners_, 1uLL, memory_order_relaxed);
                os_unfair_lock_unlock(v73);
                int v76 = *(unsigned __int8 *)(v75 + 112);
                std::__shared_weak_count::__release_shared[abi:ne180100](v74);
              }
              else
              {
                os_unfair_lock_unlock(v73);
                int v76 = *(unsigned __int8 *)(v75 + 112);
              }
              if (v76 != 7)
              {
                cf[0] = v71;
                cf[1] = v158[0].fFINode;
                cf[2] = v158[1].fFINode;
                if (v158[1].fFINode) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)&v158[1].fFINode[1], 1uLL, memory_order_relaxed);
                }
                if ((unint64_t)v164 >= v165)
                {
                  v164 = (void **)std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__push_back_slow_path<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>((uint64_t *)&v163, (uint64_t)cf);
                  if (cf[2]) {
                    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)cf[2]);
                  }
                }
                else
                {
                  __int16 v82 = TNodePtr::TNodePtr(v164, (id *)cf);
                  *(_OWORD *)(v82 + 1) = *(_OWORD *)&cf[1];
                  cf[1] = 0;
                  cf[2] = 0;
                  v164 = (void **)(v82 + 3);
                }
              }
              atomic_fetch_or((atomic_ushort *volatile)(TNodeFromFINode(v71) + 80), 0x100u);
            }
            TFSInfoSynchronizer::Next((uint64_t *)buf, cf);
            long long v83 = *(_OWORD *)cf;
            cf[0] = 0;
            cf[1] = 0;
            uint64_t v84 = v158[1].fFINode;
            *(_OWORD *)&v158[0].fFINode = v83;
            if (v84) {
              break;
            }
            if (!(void)v83) {
              goto LABEL_118;
            }
          }
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v84);
          if (cf[1]) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)cf[1]);
          }
        }
        while (v158[0].fFINode);
      }
LABEL_118:
      uint64_t v86 = v159[0].fFINode;
      uint64_t v85 = v159[1].fFINode;
      while (v86 != v85)
      {
        v153.fFINode = 0;
        if (v21)
        {
          TNodePtr::TNodePtr(&v177, (const TNode *)a1);
          TNode::CreateNode(v87, (uint64_t)v86, a1, (TNodePtr *)cf);
          TNodePtr::operator=((void **)&v153.fFINode, (void **)cf);

          uint64_t v88 = v177.fFINode;
        }
        else
        {
          TNodePtr::TNodePtr(&v156, (const TNode *)a1);
          cf[0] = 0;
          cf[1] = 0;
          TNode::CreateNode((uint64_t)&v156, (uint64_t)v86, (uint64_t)cf, &v177);
          TNodePtr::operator=((void **)&v153.fFINode, (void **)&v177.fFINode);

          if (cf[1]) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)cf[1]);
          }
          uint64_t v88 = v156.fFINode;
        }

        if (TNodeFromFINode(v153.fFINode)) {
          std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)&v166, (id *)&v153.fFINode);
        }

        v86 += 2;
      }
      memset(cf, 0, 24);
      v153.fFINode = 0;
      v154 = 0;
      uint64_t v155 = 0;
      unsigned int v94 = TNode::AddNewChildren(a1, (TNodePtr **)&v166, 0, (uint64_t)cf, (uint64_t *)&v153);
      unsigned int v95 = v94;
      if (!v149 && ((v94 ^ 1) & 1) == 0)
      {
        int v96 = (FINode **)cf[0];
        unsigned int v97 = (FINode **)cf[1];
        while (v96 != v97)
        {
          uint64_t v98 = TNodeFromFINode(*v96);
          unint64_t v99 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v98);
          os_unfair_lock_lock(v99);
          TNodePtr::TNodePtr(&v177, *(const TNode **)(v98 + 48));
          os_unfair_lock_unlock(v99);
          uint64_t v100 = TNodeFromFINode(v177.fFINode);

          if (v100)
          {
            TNodePtr::TNodePtr(&v177, (const TNode *)a1);
            TNodeEvent::CreateNodeEvent(3, (id *)v96, 0, &v156);
            TNodeEventPtrs::AddEvent(a3, &v177, (id *)&v156.fFINode);
            TNodeEventPtr::~TNodeEventPtr((id *)&v156.fFINode);
          }
          ++v96;
        }
      }
      v101 = (FINode **)v153.fFINode;
      uint64_t v102 = v154;
      while (v101 != v102)
        atomic_fetch_or((atomic_ushort *volatile)(TNodeFromFINode(*v101++) + 80), 0x100u);
      unsigned int v103 = TNode::RemoveUnmarkedChildren((TNode *)a1, a3);
      if (v40) {
        TNode::UpdateFPItemsMetadata(a1, (void ***)cf);
      }
      v177.fFINode = (FINode *)&v153;
      std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v177);
      v153.fFINode = (FINode *)cf;
      std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v153);
      if (v158[1].fFINode) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v158[1].fFINode);
      }
      unint64_t v147 = __PAIR64__(v95, v103);
      cf[0] = v159;
      std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)cf);
      goto LABEL_166;
    }
    TFSInfoSynchronizer::Next((uint64_t *)buf, v159);
    while (1)
    {
      dispatch_time_t v48 = v159[0].fFINode;
      if (!v159[0].fFINode)
      {
        TNode::ReplaceChildrenWith(a1, (void ***)&v166, 0);
        if (!v149)
        {
          if ((v145 & 1) == 0)
          {
            uint64_t v104 = v166;
            unint64_t v105 = (TString *)v167;
            while (v104 != v105)
            {
              cf[0] = v104->fString.fRef;
              TNodePtr::TNodePtr(&v153, (const TNode *)a1);
              TNodeEvent::CreateNodeEvent(3, (id *)cf, 0, v158);
              TNodeEventPtrs::AddEvent(a3, &v153, (id *)&v158[0].fFINode);
              TNodeEventPtr::~TNodeEventPtr((id *)&v158[0].fFINode);

              ++v104;
            }
          }
          uint64_t v90 = (os_unfair_lock_s *)TNode::InfoLock(v89);
          os_unfair_lock_lock(v90);
          uint64_t v92 = *(void *)(a1 + 16);
          uint64_t v91 = *(std::__shared_weak_count **)(a1 + 24);
          if (v91)
          {
            atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
            os_unfair_lock_unlock(v90);
            int v93 = *(unsigned __int8 *)(v92 + 112);
            std::__shared_weak_count::__release_shared[abi:ne180100](v91);
            if (!v93) {
              goto LABEL_156;
            }
          }
          else
          {
            os_unfair_lock_unlock(v90);
            if (!*(unsigned char *)(v92 + 112)) {
              goto LABEL_156;
            }
          }
          if (v146 != 26 && v146 != 29 && v166 != (TString *)v167)
          {
            TNodePtr::TNodePtr((TNodePtr *)cf, (const TNode *)a1);
            TNodePtr::TNodePtr(v158, (const TNode *)a1);
            TNodeEvent::CreateNodeEvent(20, (id *)&v158[0].fFINode, 0, &v153);
            TNodeEventPtrs::AddEvent(a3, (const TNodePtr *)cf, (id *)&v153.fFINode);
            TNodeEventPtr::~TNodeEventPtr((id *)&v153.fFINode);
          }
LABEL_156:
          uint64_t v106 = *(void *)(a1 + 56);
          char v107 = (void *)(v106 + 64);
          BOOL v23 = v106 == 0;
          uint64_t v108 = &TNode::GetChildren(void)const::sEmptyList;
          if (!v23) {
            uint64_t v108 = v107;
          }
          if (v108[1] - *v108 != v47)
          {
            TNodePtr::TNodePtr((TNodePtr *)cf, (const TNode *)a1);
            TNodePtr::TNodePtr(v158, (const TNode *)a1);
            TNodeEvent::CreatePropertyChangedNodeEvent((id *)&v158[0].fFINode, 1667785588, &v153);
            TNodeEventPtrs::AddEvent(a3, (const TNodePtr *)cf, (id *)&v153.fFINode);
            TNodeEventPtr::~TNodeEventPtr((id *)&v153.fFINode);
          }
        }
        if (v40)
        {
          long long v109 = TNode::GetFIProvider((TNode *)a1);
          char v110 = [v109 isLocalStorageDomain];

          if ((v110 & 1) == 0) {
            TNode::UpdateFPItemsMetadata(a1, (void ***)(*(void *)(a1 + 56) + 64));
          }
        }
        if (v159[1].fFINode) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v159[1].fFINode);
        }
        unint64_t v147 = 0;
LABEL_166:
        TNode::StPopulating::~StPopulating((FINode **)v161);
        v161[0] = 0;
        v161[1] = 0;
        uint64_t v162 = 0;
        long long v111 = v164;
        if (v163 == (TString **)v164)
        {
LABEL_205:
          statfs v140 = TNodeEventPtrs::AddEvents((uint64_t)a3, v161);
          int v22 = v143;
          a2 = v144;
          if (!v149 && v147)
          {
            TNodePtr::TNodePtr(v159, (const TNode *)a1);
            TNodePtr::TNodePtr(&v153, (const TNode *)a1);
            TNodeEvent::CreatePropertyChangedNodeEvent((id *)&v153.fFINode, 1667785588, cf);
            TNodeEventPtrs::AddEvent(a3, v159, (id *)cf);
            TNodeEventPtr::~TNodeEventPtr((id *)cf);
          }
          uint64_t v141 = TTime::MicrosecondsSinceStartup((TTime *)v140);
          TChildrenList::SetLastSyncTime(*(TChildrenList **)(a1 + 56), v151);
          TChildrenList::SetLastSyncDuration(*(TChildrenList **)(a1 + 56), v141 - v151);
          v159[0].fFINode = (FINode *)v161;
          std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)v159);
          int v38 = 0;
          goto LABEL_209;
        }
        unsigned int v112 = (uint64_t *)(v163 + 1);
        while (2)
        {
          uint64_t v113 = TNodeFromFINode((FINode *)*(v112 - 1));
          long long v114 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v113);
          os_unfair_lock_lock(v114);
          uint64_t v115 = *(void *)(v113 + 16);
          long long v116 = *(std::__shared_weak_count **)(v113 + 24);
          if (v116) {
            atomic_fetch_add_explicit(&v116->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          os_unfair_lock_unlock(v114);
          os_unfair_lock_lock((os_unfair_lock_t)(v115 + 100));
          int v117 = *(_DWORD *)(v115 + 115);
          os_unfair_lock_unlock((os_unfair_lock_t)(v115 + 100));
          if ((v117 & 0x2000000) == 0)
          {
            uint64_t v118 = *v112;
            long long v119 = (os_unfair_lock_s *)(*v112 + 100);
            os_unfair_lock_lock(v119);
            LODWORD(v118) = *(_DWORD *)(v118 + 115);
            os_unfair_lock_unlock(v119);
            if ((v118 & 0x2000000) != 0)
            {
              uint64_t v120 = *v112;
              long long v121 = (os_unfair_lock_s *)(*v112 + 100);
              os_unfair_lock_lock(v121);
              unsigned __int8 v122 = *(const void **)(v120 + 16);
              cf[0] = v122;
              if (v122) {
                CFRetain(v122);
              }
              os_unfair_lock_unlock(v121);
              v159[0] = (TNodePtr)cf[0];
              if (cf[0]) {
                CFRetain(cf[0]);
              }
              TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(cf);
              if (v159[0].fFINode) {
                TFSInfo::initialize(*v112, (const __CFURL *)v159[0].fFINode, 0, 1, 1, 1, 0);
              }
              TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v159[0].fFINode);
            }
            os_unfair_lock_lock((os_unfair_lock_t)(v115 + 100));
            v123 = *(FINode **)(v115 + 16);
            v159[0].fFINode = v123;
            if (v123) {
              CFRetain(v123);
            }
            os_unfair_lock_unlock((os_unfair_lock_t)(v115 + 100));
            if (v159[0].fFINode)
            {
              TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v159[0].fFINode);
              goto LABEL_184;
            }
            char v124 = TFSInfo::GetFPItem((TFSInfo *)v115);

            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v159[0].fFINode);
            if (v124)
            {
LABEL_184:
              long long v125 = (TNode *)TNodeFromFINode((FINode *)*(v112 - 1));
              TNode::FetchAdditionalPropertiesForSync(v125, (TFSInfo **)v112, 1);
            }
          }
          os_unfair_lock_lock((os_unfair_lock_t)(v115 + 100));
          int v126 = *(_DWORD *)(v115 + 115);
          os_unfair_lock_unlock((os_unfair_lock_t)(v115 + 100));
          if ((v126 & 0x40000000) != 0)
          {
            uint64_t v127 = *v112;
            long long v128 = (os_unfair_lock_s *)(*v112 + 100);
            os_unfair_lock_lock(v128);
            LODWORD(v127) = *(_DWORD *)(v127 + 115);
            os_unfair_lock_unlock(v128);
            if ((v127 & 0x40000000) == 0)
            {
              uint64_t v129 = *v112;
              uint64_t v130 = (os_unfair_lock_s *)(*v112 + 100);
              os_unfair_lock_lock(v130);
              id v131 = *(const void **)(v129 + 16);
              cf[0] = v131;
              if (v131) {
                CFRetain(v131);
              }
              os_unfair_lock_unlock(v130);
              v159[0] = (TNodePtr)cf[0];
              if (cf[0]) {
                CFRetain(cf[0]);
              }
              TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(cf);
              unsigned __int8 v132 = (TFSInfo *)*v112;
              if (v159[0].fFINode)
              {
                TFSInfo::initialize((uint64_t)v132, (const __CFURL *)v159[0].fFINode, 0, 1, 1, 1, 0);
              }
              else if (TFSInfo::IsFPv2(v132, 0))
              {
                unsigned __int8 v133 = (TFSInfo *)*v112;
                TFSInfo::GetFPItem((TFSInfo *)*v112);
                v134 = (FPItem *)objc_claimAutoreleasedReturnValue();
                TFSInfo::Initialize(v133, v134, 0);
              }
              TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v159[0].fFINode);
            }
            os_unfair_lock_lock((os_unfair_lock_t)(v115 + 100));
            id v135 = *(FINode **)(v115 + 16);
            v159[0].fFINode = v135;
            if (v135) {
              CFRetain(v135);
            }
            os_unfair_lock_unlock((os_unfair_lock_t)(v115 + 100));
            if (v159[0].fFINode)
            {
              TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v159[0].fFINode);
              goto LABEL_201;
            }
            id v136 = TFSInfo::GetFPItem((TFSInfo *)v115);

            TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v159[0].fFINode);
            if (v136)
            {
LABEL_201:
              uint64_t v137 = (TNode *)TNodeFromFINode((FINode *)*(v112 - 1));
              TNode::FetchAdditionalPropertiesForSync(v137, (TFSInfo **)v112, 1);
            }
          }
          uint64_t v138 = TNodeFromFINode((FINode *)*(v112 - 1));
          TNode::ReconcileInternalProperties(v138, (TFSInfo **)v112, (TNodeEventPtrs *)v161, 1);
          if (v116) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v116);
          }
          v139 = (void **)(v112 + 2);
          v112 += 3;
          if (v139 == v111) {
            goto LABEL_205;
          }
          continue;
        }
      }
      long long v49 = (os_unfair_lock_s *)&v159[0].fFINode[12].super.isa + 1;
      os_unfair_lock_lock((os_unfair_lock_t)&v159[0].fFINode[12].super.isa + 1);
      int v50 = *(_DWORD *)((char *)&v48[14].super.isa + 3);
      os_unfair_lock_unlock(v49);
      if ((v50 & 0x100) != 0)
      {
        dispatch_time_t v51 = v159[0].fFINode;
        if (!LOBYTE(v159[0].fFINode[14].super.isa))
        {
          uint64_t v52 = (os_unfair_lock_s *)&v159[0].fFINode[12].super.isa + 1;
          os_unfair_lock_lock((os_unfair_lock_t)&v159[0].fFINode[12].super.isa + 1);
          int v53 = *(_DWORD *)((char *)&v51[14].super.isa + 3);
          os_unfair_lock_unlock(v52);
          if ((v53 & 0x8000) == 0) {
            std::vector<std::shared_ptr<TFSInfo>>::push_back[abi:ne180100]((uint64_t *)&v169, (long long *)v159);
          }
        }
      }
      if (v21)
      {
        TNodePtr::TNodePtr((TNodePtr *)cf, (const TNode *)a1);
        TNode::CreateNode((uint64_t)cf, (uint64_t)v159, a1, &v153);
        id v54 = (FINode *)cf[0];
      }
      else
      {
        TNodePtr::TNodePtr(v158, (const TNode *)a1);
        cf[0] = 0;
        cf[1] = 0;
        TNode::CreateNode((uint64_t)v158, (uint64_t)v159, (uint64_t)cf, &v153);
        if (cf[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)cf[1]);
        }
        id v54 = v158[0].fFINode;
      }

      if (LOBYTE(v159[0].fFINode[14].super.isa) != 25) {
        goto LABEL_70;
      }
      BOOL v55 = (TNode *)TNodeFromFINode(v153.fFINode);
      TNode::ResolveBRContainer(v55);
      unsigned int v56 = (TNode *)TNodeFromFINode(v153.fFINode);
      TNode::GetAliasTarget(v56, cf);
      uint64_t v57 = (void *)cf[0];
      uint64_t v58 = TNodeFromFINode((FINode *)cf[0]);

      if (v58) {
        break;
      }
LABEL_71:
      TFSInfoSynchronizer::Next((uint64_t *)buf, cf);
      long long v60 = *(_OWORD *)cf;
      cf[0] = 0;
      cf[1] = 0;
      char v61 = v159[1].fFINode;
      *(_OWORD *)&v159[0].fFINode = v60;
      if (v61)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v61);
        if (cf[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)cf[1]);
        }
      }
    }
    int v59 = (TNode *)TNodeFromFINode(v153.fFINode);
    TNode::SetShouldSyncUbiquityAttributes(v59, 1);
LABEL_70:
    std::vector<TNodePtr>::push_back[abi:ne180100]((uint64_t)&v166, (id *)&v153.fFINode);
    goto LABEL_71;
  }
}

void sub_1D34778D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21,uint64_t a22,uint64_t a23,uint64_t a24,id a25,uint64_t a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,uint64_t a30,void ****a31,uint64_t a32,uint64_t a33,void ***a34,uint64_t a35,uint64_t a36,void **a37)
{
  TNodeEventPtr::~TNodeEventPtr(&a17);

  if (a28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a28);
  }
  TNode::StPopulating::~StPopulating((FINode **)&a31);
  a31 = &a34;
  std::vector<std::pair<TNodePtr,std::shared_ptr<TFSInfo>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a31);
  a34 = &a37;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&a34);
  a37 = (void **)(v38 - 200);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&a37);
  std::__shared_weak_count::__release_shared[abi:ne180100](v37);
  TFSInfoSynchronizer::~TFSInfoSynchronizer((TFSInfoSynchronizer *)(v38 - 176));
  _Unwind_Resume(a1);
}

void std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  CFIndex v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<TCFURLInfoList>>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t *TFSInfoSynchronizer::Next@<X0>(uint64_t *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  unint64_t v2 = *((unsigned int *)this + 12);
  uint64_t v3 = *this;
  if (v2 < (this[1] - *this) >> 4)
  {
    long long v4 = *(_OWORD *)(v3 + 16 * v2);
    uint64_t v5 = *(void *)(v3 + 16 * v2 + 8);
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)a2 = v4;
    ++*((_DWORD *)this + 12);
  }
  return this;
}

uint64_t TNode::FetchAdditionalPropertiesForSync(TNode *this, TFSInfo **a2, int a3)
{
  if (a3)
  {
    uint64_t v5 = TNode::GetFIProvider(this);
    BOOL v6 = v5 != 0;
  }
  else
  {
    BOOL v6 = 0;
  }
  uint64_t v7 = *a2;
  int v8 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v8);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 3);
  BOOL v12 = (TFSInfo *)*((void *)this + 2);
  char v13 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  AdditionalCFIndex Properties = TFSInfo::FetchAdditionalProperties(v7, &v12, v6);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  return AdditionalProperties;
}

void sub_1D3477E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TFSInfo::FetchAdditionalProperties(TFSInfo *this, TFSInfo **a2, int a3)
{
  int v3 = *((unsigned __int8 *)this + 112);
  if (v3 != 7)
  {
    if (v3 != 27) {
      goto LABEL_8;
    }
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    uint64_t v7 = *((void *)this + 10);
    if (v7
      && (os_unfair_lock_lock((os_unfair_lock_t)(v7 + 72)),
          int v8 = *(unsigned __int8 *)(v7 + 76),
          os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72)),
          v8 == 1))
    {
      id v9 = *(id *)(v7 + 24);
    }
    else
    {
      id v9 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
    char v10 = [v9 isUsingFPFS];

    if ((v10 & 1) == 0)
    {
LABEL_8:
      CFIndex Properties = (TFSInfo *)TFSInfo::FetchProperties(this, 1);
      CFURLRef v12 = (const __CFURL *)*((void *)this + 1);
      if (v12)
      {
        CFArrayRef v13 = (const __CFArray *)TFSInfo::IterationFullSetOfPropertyKeys(Properties);
        CFStringRef theString = (CFStringRef)CFURLCopyResourcePropertiesForKeys(v12, v13, 0);
        TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&theString);
      }
      TNodePtr v14 = TFSInfo::GetUTType(this);

      TFSInfo::LocalizedTypeDescription(this, (TString *)&theString);
      CFIndex Length = CFStringGetLength(theString);
      int v16 = v14 != 0;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      if (Length) {
        int v17 = ((v16 & 1) << 9) | 2;
      }
      else {
        int v17 = v16 << 9;
      }
      uint64_t v18 = *a2;
      uint64_t v19 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v19);
      LODWORD(v18) = *(_DWORD *)((char *)v18 + 115);
      os_unfair_lock_unlock(v19);
      int v20 = *a2;
      BOOL v21 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v21);
      LOWORD(v20) = *(_WORD *)((char *)v20 + 119);
      os_unfair_lock_unlock(v21);
      unsigned int v22 = (v18 >> 27) & 4 | v17 | v20 & 0x20;
      BOOL v23 = *a2;
      int v24 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v24);
      LODWORD(v20) = *(_DWORD *)((char *)v23 + 115);
      os_unfair_lock_unlock(v24);
      if ((v20 & 0x80000000) != 0)
      {
        os_unfair_lock_lock(v24);
        unsigned int v25 = *(_DWORD *)((char *)v23 + 115);
        os_unfair_lock_unlock(v24);
        v22 |= (v25 >> 1) & 0x10;
      }
      uint64_t v26 = *a2;
      int v27 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v27);
      LODWORD(v26) = *(unsigned __int16 *)((char *)v26 + 119);
      os_unfair_lock_unlock(v27);
      unsigned int v28 = (v26 >> 3) & 0x80 | v22;
      if ((int)TFSInfo::GetBladeRunnerFlags(*a2) >= 0) {
        v28 |= 0x100u;
      }
      if (a3)
      {
        uint64_t v29 = TFSInfo::GetFPItem(*a2);
        if (v29)
        {

LABEL_25:
          v28 |= 0x800u;
LABEL_27:
          TFSInfo::Fetch(this, a2, v28);
          return 0;
        }
        TNodePtr v30 = *a2;
        CFStringRef v31 = (os_unfair_lock_s *)((char *)*a2 + 96);
        os_unfair_lock_lock(v31);
        uint64_t v32 = *((void *)v30 + 10);
        if (v32
          && (os_unfair_lock_lock((os_unfair_lock_t)(v32 + 72)),
              int v33 = *(unsigned __int8 *)(v32 + 76),
              os_unfair_lock_unlock((os_unfair_lock_t)(v32 + 72)),
              v33 == 1))
        {
          id v34 = *(id *)(v32 + 24);
        }
        else
        {
          id v34 = 0;
        }
        os_unfair_lock_unlock(v31);

        if (v34) {
          goto LABEL_25;
        }
      }
      if (v28) {
        goto LABEL_27;
      }
    }
  }
  return 0;
}

void sub_1D34780C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TFSInfo::LocalizedTypeDescription(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  long long v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  a2->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 6));
  os_unfair_lock_unlock(v4);
}

void sub_1D3478150(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id TFSInfo::GetUTType(TFSInfo *this)
{
  unint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  id v3 = *((id *)this + 5);
  os_unfair_lock_unlock(v2);
  return v3;
}

void std::vector<std::shared_ptr<TCFURLInfoList>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    long long v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

BOOL TNode::NeedsChildReconcile(TNode *this)
{
  int v6 = 2048;
  TNode::GetPermissions((uint64_t)this, &v6);
  if (!v6) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 7);
  int v3 = atomic_load((unsigned int *)TNode::GetNotifierList(this));
  if (v3 > 0) {
    return 1;
  }
  if (!v2) {
    return 0;
  }
  unsigned int v5 = atomic_load((unsigned int *)(v2 + 192));
  return v5 != 0;
}

uint64_t TNode::GetPermissions(uint64_t a1, int *a2)
{
  long long v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *(void *)(a1 + 16);
  unsigned int v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  int v8 = (os_unfair_lock_s *)TNode::ParentLock(v7);
  os_unfair_lock_lock(v8);
  TNodePtr::TNodePtr(&v99, *(const TNode **)(a1 + 48));
  os_unfair_lock_unlock(v8);
  int v9 = *(unsigned __int8 *)(v6 + 112);
  if (v9 == 34 || v9 == 29 || v9 == 26)
  {
    int v10 = *a2;
    int v11 = 2147462040;
LABEL_7:
    int v12 = v10 & v11;
    goto LABEL_8;
  }
  TNode::GetVolumeInfo((TNode *)a1, &v97);
  uint64_t IsLocked = (uint64_t)v98;
  int v15 = *((unsigned __int8 *)v97 + 104);
  if (v98) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v98);
  }
  if (v15)
  {
    int v16 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v16);
    int v17 = *(std::__shared_weak_count **)(a1 + 24);
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v16);
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
    }
    else
    {
      os_unfair_lock_unlock(v16);
    }
    int v10 = *a2;
    int v11 = 2145978372;
    goto LABEL_7;
  }
  if ((*a2 & 0x10000) != 0)
  {
    uint64_t IsLocked = TNode::UserCanRead((TNode *)a1);
    if (IsLocked) {
      int v18 = 0x10000;
    }
    else {
      int v18 = 0;
    }
    if ((*a2 & 0x2000) == 0) {
      goto LABEL_21;
    }
  }
  else
  {
    int v18 = 0;
    if ((*a2 & 0x2000) == 0)
    {
LABEL_21:
      int v19 = 0;
      goto LABEL_33;
    }
  }
  uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
  if (IsLocked & 1) != 0 || (uint64_t IsLocked = IsRunningInFinder(), (IsLocked))
  {
    int v19 = 0x2000;
  }
  else
  {
    uint64_t IsLocked = TNode::UserCanChangePermissions((TNode *)a1);
    int v19 = 0;
    if (IsLocked) {
      v18 |= 0x2000u;
    }
  }
LABEL_33:
  if ((*(unsigned char *)a2 & 8) != 0)
  {
    uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
    if ((IsLocked & 1) != 0 || (uint64_t IsLocked = IsRunningInFinder(), IsLocked))
    {
      v19 |= 8u;
    }
    else
    {
      uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
      if (IsLocked) {
        v18 |= 8u;
      }
    }
  }
  if ((*((unsigned char *)a2 + 2) & 0x10) != 0)
  {
    uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
    if ((IsLocked & 1) != 0
      || (uint64_t IsLocked = TFSInfo::LowLevelIsLockFile((TFSInfo *)v6), (IsLocked & 1) != 0)
      || (uint64_t IsLocked = IsRunningInFinder(), (IsLocked & 1) != 0)
      || (char v20 = atomic_load((unsigned __int16 *)(a1 + 80)), (v20 & 2) != 0))
    {
      v19 |= 0x100000u;
    }
    else
    {
      uint64_t IsLocked = TNode::IsSymlink((TNode *)a1);
      if ((IsLocked & 1) == 0)
      {
        if (TNode::UserCanWriteDataFork((TNode *)a1))
        {
          uint64_t IsLocked = TNode::IsVolume((TNode *)a1);
          if (!IsLocked || (uint64_t IsLocked = TNode::IsLocalVolume((TNode *)a1), IsLocked)) {
            v18 |= 0x100000u;
          }
        }
        else
        {
          uint64_t IsLocked = TNode::IsLocalVolume((TNode *)a1);
          if (IsLocked) {
            v18 |= 0x100000u;
          }
        }
      }
    }
  }
  if ((*(unsigned char *)a2 & 0x10) != 0)
  {
    uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
    if ((IsLocked & 1) != 0 || (uint64_t IsLocked = IsRunningInFinder(), IsLocked))
    {
      v19 |= 0x10u;
    }
    else if (*(unsigned char *)(v6 + 112) == 21 {
           || (uint64_t IsLocked = TNode::IsSymlink((TNode *)a1), (IsLocked & 1) == 0)
    }
           && (uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1), IsLocked)
           && ((uint64_t IsLocked = TNode::IsVolume((TNode *)a1), !IsLocked)
            || (uint64_t IsLocked = TNode::IsLocalVolume((TNode *)a1), IsLocked)))
    {
      v18 |= 0x10u;
    }
  }
  if ((*(unsigned char *)a2 & 0x20) != 0)
  {
    TNode::GetVolumeInfo((TNode *)a1, &v97);
    if (*((unsigned char *)v97 + 136))
    {
      BOOL v21 = TFSInfo::UserCanChangeLock((TFSInfo *)v6);
      uint64_t IsLocked = (uint64_t)v98;
      if (v98) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v98);
      }
      if (v21) {
        v18 |= 0x20u;
      }
    }
    else
    {
      uint64_t IsLocked = (uint64_t)v98;
      if (v98) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v98);
      }
    }
  }
  if ((*((unsigned char *)a2 + 1) & 2) != 0)
  {
    uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
    if ((IsLocked & 1) != 0 || (uint64_t IsLocked = IsRunningInFinder(), IsLocked))
    {
      v19 |= 0x200u;
    }
    else
    {
      uint64_t IsLocked = TNode::IsDeferredForSymlink(a1, (uint64_t (*)(void *))TFSInfo::IsApplication, 0);
      if ((IsLocked & 1) == 0)
      {
        uint64_t IsLocked = TNode::IsAlias((TNode *)a1);
        if ((IsLocked & 1) == 0)
        {
          uint64_t IsLocked = TNode::IsContainer((TNode *)a1);
          if ((IsLocked & 1) == 0)
          {
            uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
            if (IsLocked) {
              v18 |= 0x200u;
            }
          }
        }
      }
    }
  }
  if ((*((unsigned char *)a2 + 2) & 2) != 0)
  {
    uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
    if ((IsLocked & 1) != 0 || (uint64_t IsLocked = IsRunningInFinder(), IsLocked))
    {
      v19 |= 0x20000u;
    }
    else
    {
      uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
      if (IsLocked) {
        v18 |= 0x20000u;
      }
    }
  }
  if (*((unsigned char *)a2 + 1))
  {
    uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
    if ((IsLocked & 1) != 0 || (uint64_t IsLocked = IsRunningInFinder(), IsLocked))
    {
      v19 |= 0x100u;
    }
    else
    {
      uint64_t IsLocked = TNode::IsDeferredForSymlink(a1, (uint64_t (*)(void *))TFSInfo::IsApplication, 0);
      if (IsLocked)
      {
        uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
        if (IsLocked) {
          v18 |= 0x100u;
        }
      }
    }
  }
  if ((*((unsigned char *)a2 + 1) & 0x80) != 0)
  {
    uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
    if ((IsLocked & 1) != 0 || (uint64_t IsLocked = IsRunningInFinder(), IsLocked))
    {
      v19 |= 0x8000u;
    }
    else
    {
      uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
      if (IsLocked) {
        v18 |= 0x8000u;
      }
    }
  }
  if ((*((unsigned char *)a2 + 1) & 4) != 0)
  {
    unsigned int v22 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v22);
    int v24 = *(TFSInfo **)(a1 + 16);
    BOOL v23 = *(std::__shared_weak_count **)(a1 + 24);
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v22);
    uint64_t IsLocked = TFSInfo::IsAlias(v24);
    int v25 = IsLocked;
    if (v23) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v23);
    }
    if (v25)
    {
      uint64_t IsLocked = TNode::IsSymlink((TNode *)a1);
      if ((IsLocked & 1) == 0)
      {
        uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
        if (IsLocked)
        {
          uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
          if (IsLocked) {
            v18 |= 0x400u;
          }
        }
      }
    }
  }
  if ((*(unsigned char *)a2 & 0x40) != 0)
  {
    uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
    if ((IsLocked & 1) != 0
      || (uint64_t v26 = (TGlobalNodes *)IsRunningInFinder(), v26)
      && (TGlobalNodes::BootNode((uint64_t *)&v97, v26),
          uint64_t v27 = TNodeFromFINode((FINode *)v97),
          v97,
          v27 != a1))
    {
      v19 |= 0x40u;
    }
    else
    {
      uint64_t IsLocked = TNode::IsContainer((TNode *)a1);
      if (IsLocked)
      {
        v18 |= 0x40u;
      }
      else
      {
        uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
        if (IsLocked)
        {
          uint64_t IsLocked = TNode::UserCanWriteDataFork((TNode *)a1);
          if (IsLocked) {
            v18 |= 0x40u;
          }
        }
      }
    }
  }
  if ((*((unsigned char *)a2 + 1) & 8) != 0)
  {
    unsigned int v28 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v28);
    uint64_t v30 = *(void *)(a1 + 16);
    uint64_t v29 = *(std::__shared_weak_count **)(a1 + 24);
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v28);
    CFStringRef v31 = (os_unfair_lock_s *)(v30 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v30 + 100));
    int v32 = *(_DWORD *)(v30 + 115);
    os_unfair_lock_unlock(v31);
    if (v29) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v29);
    }
    if ((v32 & 0x20) != 0 || (uint64_t IsLocked = TNode::AliasIsContainer((TNode *)a1), IsLocked))
    {
      uint64_t IsLocked = TNode::UserCanBrowse((TNode *)a1);
      if (IsLocked) {
        v18 |= 0x800u;
      }
    }
  }
  int v33 = *a2;
  if ((*a2 & 0x80000) != 0)
  {
    id v34 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v34);
    uint64_t v36 = *(void *)(a1 + 16);
    double v35 = *(std::__shared_weak_count **)(a1 + 24);
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v34);
    uint64_t v37 = (os_unfair_lock_s *)(v36 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v36 + 100));
    int v38 = *(_DWORD *)(v36 + 115);
    os_unfair_lock_unlock(v37);
    if (v35) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v35);
    }
    if ((v38 & 0x20) != 0 || (uint64_t IsLocked = TNode::AliasIsContainer((TNode *)a1), IsLocked))
    {
      uint64_t IsLocked = TNode::UserCanListContent((TNode *)a1);
      if (IsLocked) {
        v18 |= 0x80000u;
      }
    }
    int v33 = *a2;
  }
  if ((v33 & 0x5004) != 0)
  {
    if (v33 < 0)
    {
      uint64_t IsLocked = IsRunningInFinder();
      char v39 = IsLocked ^ 1;
    }
    else
    {
      char v39 = 0;
    }
    BOOL v40 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v40);
    uint64_t v42 = *(void *)(a1 + 16);
    uint64_t v41 = *(std::__shared_weak_count **)(a1 + 24);
    if (v41) {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v40);
    uint64_t v43 = (os_unfair_lock_s *)(v42 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v42 + 100));
    int v44 = *(_DWORD *)(v42 + 115);
    os_unfair_lock_unlock(v43);
    if (v41) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v41);
    }
    if ((v44 & 0x20) != 0 || (uint64_t IsLocked = TNode::AliasIsContainer((TNode *)a1), IsLocked))
    {
      uint64_t IsLocked = TFSInfo::IsLocked((TFSInfo *)v6);
      if ((IsLocked & 1) == 0)
      {
        uint64_t IsLocked = IsRunningInFinder();
        if ((IsLocked & 1) == 0 && *(unsigned char *)(v6 + 112) != 5)
        {
          uint64_t IsLocked = TFSInfo::IsResumableCopyTarget((TFSInfo *)v6);
          if ((IsLocked & 1) == 0)
          {
            int v45 = *a2 & 0x1000;
            int v46 = *a2 & 0x4000;
            int v47 = *a2 & 4;
            if (v39)
            {
              uint64_t IsLocked = TNode::IsLocalVolume((TNode *)a1);
              if (!IsLocked) {
                v19 |= 0x5004u;
              }
            }
            else
            {
              uint64_t IsLocked = TNode::FetchExtendedUserAccess((TNode *)a1);
              if (IsLocked)
              {
                if (TNode::IsContainer((TNode *)a1)) {
                  int CanAddFile = TFSInfo::UserCanAddFile((TFSInfo *)v6);
                }
                else {
                  int CanAddFile = 0;
                }
                uint64_t IsLocked = TNode::IsContainer((TNode *)a1);
                if (IsLocked) {
                  uint64_t IsLocked = TFSInfo::UserCanAddFolder((TFSInfo *)v6);
                }
                int v49 = CanAddFile & IsLocked;
                if (!v45) {
                  int v49 = 1;
                }
                if (v49) {
                  int v50 = v19;
                }
                else {
                  int v50 = v19 | 0x1000;
                }
                if (v46) {
                  int v51 = IsLocked;
                }
                else {
                  int v51 = 1;
                }
                if (!v51) {
                  v50 |= 0x4000u;
                }
                if (v47) {
                  int v52 = CanAddFile;
                }
                else {
                  int v52 = 1;
                }
                if (v52) {
                  int v19 = v50;
                }
                else {
                  int v19 = v50 | 4;
                }
              }
            }
            v18 |= v45 | v46 | v47;
            if (v46 && (v19 & 0x4000) == 0 || v47 && (v19 & 4) == 0)
            {
              uint64_t IsLocked = TNode::IsInTrash((TNode *)a1);
              if (IsLocked) {
                v19 |= 0x4004u;
              }
            }
          }
        }
      }
    }
  }
  if ((*((unsigned char *)a2 + 2) & 0x60) != 0)
  {
    int v53 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v53);
    uint64_t v55 = *(void *)(a1 + 16);
    id v54 = *(std::__shared_weak_count **)(a1 + 24);
    if (v54) {
      atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v18 |= 0x600000u;
    os_unfair_lock_unlock(v53);
    unsigned int v56 = (os_unfair_lock_s *)(v55 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v55 + 100));
    int v57 = *(_DWORD *)(v55 + 115);
    os_unfair_lock_unlock(v56);
    if (v54) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v54);
    }
    if ((v57 & 0x100) != 0 || (uint64_t IsLocked = TFSInfo::IsNoUnlinkEffective((TFSInfo *)v6, v58, v59), IsLocked)) {
      v19 |= 0x600000u;
    }
  }
  int v60 = *a2;
  if ((*a2 & 0x800000) != 0)
  {
    unsigned int v94 = 0;
    LODWORD(v98) = 12;
    int v96 = 0;
    unsigned int v97 = (TFSInfo *)&v94;
    int Property = TNode::GetProperty(a1, 1886675532, (TPropertyReference *)&v97, &v96, 0);
    if (v94) {
      BOOL v62 = Property == 0;
    }
    else {
      BOOL v62 = 0;
    }
    if (v62) {
      v18 |= 0x800000u;
    }
    uint64_t IsLocked = (uint64_t)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v94);
    int v60 = *a2;
  }
  if (v60)
  {
    char v63 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocked);
    os_unfair_lock_lock(v63);
    uint64_t v65 = *(void *)(a1 + 16);
    uint64_t v64 = *(std::__shared_weak_count **)(a1 + 24);
    if (v64) {
      atomic_fetch_add_explicit(&v64->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v63);
    uint64_t v66 = (os_unfair_lock_s *)(v65 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v65 + 100));
    int v67 = *(_DWORD *)(v65 + 115);
    os_unfair_lock_unlock(v66);
    if (v64) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v64);
    }
    if ((v67 & 0x100) != 0)
    {
      TNode::GetVolumeInfo((TNode *)a1, &v97);
      int v69 = *((unsigned __int8 *)v97 + 111);
      if (v98) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v98);
      }
      v19 |= v69;
    }
    else if ((TFSInfo::IsLocked((TFSInfo *)v6) & 1) != 0 {
           || TNode::LowLevelIsLockFile((TNode *)a1)
    }
           || (char v68 = atomic_load((unsigned __int16 *)(a1 + 80)), (v68 & 2) != 0))
    {
      v19 |= 1u;
    }
    v18 |= 1u;
    if ((*a2 & 0x80000000) == 0 || (TNode::IsLocalVolume((TNode *)a1) & 1) == 0)
    {
      if (!TNode::UserCanDelete((TNode *)a1)
        || TNode::IsContainer((TNode *)a1) && (TFSInfo::UserCanWrite((TFSInfo *)v6) & 1) == 0)
      {
        int v75 = TNode::IsLocalVolume((TNode *)a1) ^ 1;
LABEL_228:
        v19 |= v75;
        goto LABEL_229;
      }
      if (TNodeFromFINode(v99.fFINode))
      {
        char v70 = (TNode *)TNodeFromFINode(v99.fFINode);
        if (TNode::FetchExtendedUserAccess(v70))
        {
          uint64_t v71 = (TNode *)TNodeFromFINode(v99.fFINode);
          TNode::GetFSInfo(v71, &v97);
          if (TFSInfo::UserCanAddDeleteChild(v97))
          {
            uint64_t v72 = (TNode *)TNodeFromFINode(v99.fFINode);
            TNode::GetFSInfo(v72, &v94);
            if ((TFSInfo::IsLocked(v94) & 1) != 0 || !TNode::IsLocalVolume((TNode *)a1))
            {
              int IsSticky = 0;
            }
            else
            {
              CFArrayRef v73 = (TNode *)TNodeFromFINode(v99.fFINode);
              int IsSticky = TNode::IsSticky(v73);
            }
            if (v95) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v95);
            }
          }
          else
          {
            int IsSticky = 0;
          }
          uint64_t v92 = (TFSInfo *)v98;
          if (v98) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v98);
          }
          if (IsSticky)
          {
            BOOL IsRoot = TFSInfo::UserIsRoot(v92);
            int v75 = (IsRoot | TNode::UserIsOwner((TNode *)a1)) ^ 1;
            goto LABEL_228;
          }
        }
      }
    }
  }
LABEL_229:
  if ((*(unsigned char *)a2 & 2) != 0)
  {
    int v76 = (TNode *)TNodeFromFINode(v99.fFINode);
    v18 |= 2u;
    if (!v76) {
      goto LABEL_249;
    }
    unsigned __int16 v77 = (os_unfair_lock_s *)TNode::InfoLock(v76);
    os_unfair_lock_lock(v77);
    uint64_t v79 = *(void *)(a1 + 16);
    BOOL v78 = *(std::__shared_weak_count **)(a1 + 24);
    if (v78) {
      atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v77);
    uint64_t v80 = (os_unfair_lock_s *)(v79 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v79 + 100));
    int v81 = *(_DWORD *)(v79 + 115);
    os_unfair_lock_unlock(v80);
    if (v78) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v78);
    }
    if ((v81 & 0x100) != 0
      || (TFSInfo::IsLocked((TFSInfo *)v6) & 1) != 0
      || (IsRunningInFinder() & 1) != 0
      || (TFSInfo::IsNoUnlinkEffective((TFSInfo *)v6, v82, v83) & 1) != 0)
    {
      goto LABEL_249;
    }
    uint64_t v84 = (TNode *)TNodeFromFINode(v99.fFINode);
    TNode::GetFSInfo(v84, &v97);
    int v85 = TFSInfo::IsLocked(v97);
    if (v98) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v98);
    }
    if (v85) {
      goto LABEL_249;
    }
    if (*a2 < 0)
    {
      if (!TNode::IsLocalVolume((TNode *)a1)) {
        v19 |= 2u;
      }
      goto LABEL_250;
    }
    if (!TNode::UserCanDelete((TNode *)a1)
      || (uint64_t v86 = (TNode *)TNodeFromFINode(v99.fFINode), (TNode::UserCanDeleteChild(v86) & 1) == 0))
    {
LABEL_249:
      v19 |= 2u;
    }
    else
    {
      uint64_t v87 = (TNode *)TNodeFromFINode(v99.fFINode);
      if (TNode::IsSticky(v87))
      {
        IsLocalVolume = (TFSInfo *)TNode::IsLocalVolume((TNode *)a1);
        if (IsLocalVolume)
        {
          BOOL v89 = TFSInfo::UserIsRoot(IsLocalVolume);
          if (!(v89 | TNode::UserIsOwner((TNode *)a1))) {
            v19 |= 2u;
          }
        }
      }
    }
  }
LABEL_250:
  if ((*((unsigned char *)a2 + 2) & 4) != 0)
  {
    if (TNodeFromFINode(v99.fFINode))
    {
      uint64_t v90 = (TNode *)TNodeFromFINode(v99.fFINode);
      if (TNode::UserCanDeleteChild(v90))
      {
        uint64_t v91 = (TNode *)TNodeFromFINode(v99.fFINode);
        if (TNode::IsSticky(v91))
        {
          if (TNode::UserCanDelete((TNode *)a1)) {
            v19 |= 0x40000u;
          }
        }
      }
    }
  }
  int v12 = v18 & ~v19 & *a2;
LABEL_8:
  *a2 = v12;
  *a2 = TNode::ApplyFPItemRestrictions(a1, v12);
  if (TFSInfo::IsReadOnlyShare((TFSInfo *)v6))
  {
    *a2 &= 0xFFDF2FFF;
    if ((TFSInfo::IsTopLevelSharedItem((TFSInfo *)v6) & 1) == 0) {
      *a2 &= 0xFFADFDDC;
    }
  }
  TNode::ModifyPermissionsIfBusy(a1, a2);
  *a2 &= ~0x80000000;

  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return 0;
}

void sub_1D3478F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsReadOnlyShare(TFSInfo *this)
{
  if (!UseFileProviderFramework()) {
    return 0;
  }
  uint64_t v2 = TFSInfo::GetFPItem(this);
  if (!v2) {
    return 0;
  }
  int v3 = v2;
  long long v4 = [v2 sharingPermissions];
  CFStringRef theString = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&theString, v4);

  int v5 = [v3 isSharedByCurrentUser];
  if (CFStringGetLength(theString))
  {
    FileProviderSharedItemPermissionsReadOnly(&v8);
    if (CFEqual(theString, v8.fString.fRef)) {
      uint64_t v6 = v5 ^ 1u;
    }
    else {
      uint64_t v6 = 0;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
  }
  else
  {
    uint64_t v6 = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);

  return v6;
}

void sub_1D3479128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);

  _Unwind_Resume(a1);
}

void TNode::ModifyPermissionsIfBusy(uint64_t a1, _DWORD *a2)
{
  long long v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *(void *)(a1 + 16);
  int v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v4);
    int v7 = *(unsigned __int8 *)(v6 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    if (v7) {
      return;
    }
  }
  else
  {
    os_unfair_lock_unlock(v4);
    if (*(unsigned char *)(v6 + 112)) {
      return;
    }
  }
  int v9 = (os_unfair_lock_s *)TNode::InfoLock(v8);
  os_unfair_lock_lock(v9);
  int v11 = *(TFSInfo **)(a1 + 16);
  int v10 = *(std::__shared_weak_count **)(a1 + 24);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v9);
  int Type = TFSInfo::GetType(v11);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  if (Type == 1651666795 || (Type & 0xFFFFFFE0) == 0x627A7920) {
    *a2 &= 0xFFFC081A;
  }
}

void sub_1D3479278(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

id **TNodeEventPtrs::SendNotifications(id **this)
{
  char v1 = *this;
  uint64_t v2 = this[1];
  if (*this != v2)
  {
    int v3 = this;
    long long v16 = 0u;
    long long v17 = 0u;
    int v18 = 1065353216;
    do
    {
      v15.fFINode = (FINode *)*v1;
      long long v4 = (char *)v1[1];
      int v5 = v4;
      if (v4) {
        uint64_t v6 = (TNodeEvent *)(v4 + 8);
      }
      else {
        uint64_t v6 = 0;
      }
      TFSInfo::MarkAsUsed((TFSInfo *)v6->fEventKind);
      TNodeEvent::NotifyNode((TDSNotifier ***)v14, v6, &v15, 0);
      int v7 = v14[0];
      TString v8 = v14[1];
      while (v7 != v8)
      {
        int v9 = *(void ***)v7;
        int v19 = (TDSNotifier **)v9;
        if (v9) {
          TDSNotifier::AddPtrReference((TDSNotifier *)v9);
        }
        std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__emplace_unique_key_args<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>((uint64_t)&v16, &v19, (TDSNotifier **)&v19);
        TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v19);
        int v7 = (TDSNotifier *)((char *)v7 + 8);
      }
      int v19 = v14;
      std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v19);

      v1 += 2;
    }
    while (v1 != v2);
    int v11 = *v3;
    for (uint64_t i = v3[1]; i != v11; std::__destroy_at[abi:ne180100]<std::pair<TNodePtr,TNodeEventPtr>,0>(i))
      i -= 2;
    v3[1] = v11;
    for (CFIndex j = (void *)v17; j; CFIndex j = (void *)*j)
    {
      CFArrayRef v13 = (TDSNotifier *)j[2];
      v14[0] = v13;
      if (v13)
      {
        TDSNotifier::AddPtrReference(v13);
        CFArrayRef v13 = v14[0];
      }
      TDSNotifier::Tickle(v13, 0);
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v14);
    }
    return (id **)std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::~__hash_table((uint64_t)&v16);
  }
  return this;
}

void sub_1D34793F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t TNode::UserCanBrowse(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  int v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    int v5 = *(unsigned __int8 *)(v4 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    os_unfair_lock_unlock(v2);
    int v5 = *(unsigned __int8 *)(v4 + 112);
  }
  int v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v7);
  uint64_t v9 = *((void *)this + 2);
  TString v8 = (std::__shared_weak_count *)*((void *)this + 3);
  if (!v5)
  {
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v7);
    CFArrayRef v13 = (os_unfair_lock_s *)(v9 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
    int v14 = *(_DWORD *)(v9 + 115);
    os_unfair_lock_unlock(v13);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    if ((v14 & 0x20) == 0) {
      return 0;
    }
    long long v17 = (os_unfair_lock_s *)TNode::InfoLock(v15);
    os_unfair_lock_lock(v17);
    uint64_t v19 = *((void *)this + 2);
    int v18 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v17);
    char v20 = (os_unfair_lock_s *)(v19 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 100));
    int v21 = *(_DWORD *)(v19 + 115);
    os_unfair_lock_unlock(v20);
    if ((v21 & 0x1000) != 0)
    {
      BOOL v23 = (os_unfair_lock_s *)TNode::InfoLock(v22);
      os_unfair_lock_lock(v23);
      uint64_t v25 = *((void *)this + 2);
      int v24 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v23);
      os_unfair_lock_lock((os_unfair_lock_t)(v25 + 100));
      unint64_t v16 = ((unint64_t)*(unsigned int *)(v25 + 115) >> 14) & 1;
      os_unfair_lock_unlock((os_unfair_lock_t)(v25 + 100));
      if (v24) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v24);
      }
    }
    else
    {
      unint64_t v16 = 0;
    }
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
    return v16;
  }
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v7);
  int v10 = (os_unfair_lock_s *)(v9 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
  int v11 = *(_DWORD *)(v9 + 115);
  os_unfair_lock_unlock(v10);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  if ((v11 & 0x20) != 0) {
    return 1;
  }
  return TNode::AliasIsContainer(this);
}

void sub_1D3479674(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void TFSInfo::SetFPItem(TFSInfo *this, FPItem *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v3 = a2;
  if ((UseFileProviderFramework() & 1) == 0) {
    goto LABEL_23;
  }
  if (!v3) {
    goto LABEL_9;
  }
  uint64_t v4 = [(FPItem *)v3 itemIdentifier];
  *(void *)TPropertyValue buf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)buf, v4);

  int v5 = NS_FileProviderRootContainerItemIdentifier();
  int v6 = operator==((void **)buf, v5);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
  if (v6)
  {
    id v18 = 0;
    int v7 = +[FIProviderDomain providerDomainForItem:v3 cachePolicy:1 error:&v18];
    id v8 = v18;
    BOOL v9 = v7 != 0;
    if (!v7)
    {
      int v10 = LogObj(4);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)TPropertyValue buf = 138543618;
        *(void *)&uint8_t buf[4] = v3;
        __int16 v20 = 2114;
        id v21 = v8;
        _os_log_impl(&dword_1D343E000, v10, OS_LOG_TYPE_ERROR, "Found root item identifier but unable to get provider. item: %{public}@ error: %{public}@", buf, 0x16u);
      }

      int v3 = 0;
    }
  }
  else
  {
LABEL_9:
    int v7 = 0;
    BOOL v9 = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  objc_storeStrong((id *)this + 8, v3);
  if (v7) {
    BOOL v11 = v9;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    uint64_t Overflow = TFSInfo::GetOrCreateOverflow(this);
    CFArrayRef v13 = (os_unfair_lock_s *)(Overflow + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(Overflow + 72));
    int v14 = *(unsigned __int8 *)(Overflow + 76);
    if (v14 == 2)
    {
      TFSInfoOverflow::MigrateToType(Overflow, 1);
      int v14 = *(unsigned __int8 *)(Overflow + 76);
    }
    else if (v14 == 3)
    {
      *(unsigned char *)(Overflow + 76) = 1;
      *(void *)(Overflow + 32) = 0;
      *(_OWORD *)uint64_t Overflow = 0u;
      *(_OWORD *)(Overflow + 16) = 0u;
      *(_DWORD *)(Overflow + 32) = 0x80000000;
      os_unfair_lock_unlock(v13);
LABEL_19:
      objc_storeStrong((id *)(Overflow + 24), v7);
      goto LABEL_20;
    }
    os_unfair_lock_unlock(v13);
    if (v14 == 1) {
      goto LABEL_19;
    }
  }
LABEL_20:
  os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
  TNodePtr v15 = [v7 domain];
  BOOL v16 = v15 == 0;

  if (!v16)
  {
    long long v17 = [v7 domain];
    ProviderDisplayName(v17, (TString *)buf);
    TFSInfo::SetDisplayName(this, (const TString *)buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
  }
LABEL_23:
}

void sub_1D3479930(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetType(TFSInfo *this)
{
  if (*((unsigned char *)this + 112) == 21) {
    return 0;
  }
  else {
    return *((unsigned int *)this + 26);
  }
}

void TNode::CFURL(TNode *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *((void *)this + 2);
  int v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  int v7 = *(const void **)(v6 + 16);
  *a2 = v7;
  if (v7) {
    CFRetain(v7);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 100));
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1D3479AA0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(a1);
}

unint64_t TNode::IsContainer(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  int v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  int v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  unint64_t v6 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return (v6 >> 5) & 1;
}

const void **TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t TFSInfo::SameIdentity(TFSInfo *this, TFSInfo **a2)
{
  if (*a2 == this) {
    return 1;
  }
  if (*((unsigned __int8 *)this + 112) - 27 > 1)
  {
    uint64_t VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
    if (VolumeIdentifier != TFSInfo::GetVolumeIdentifier(*a2)) {
      return 0;
    }
    int v7 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    unint64_t v8 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 5) & 1;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    BOOL v9 = *a2;
    int v10 = (os_unfair_lock_s *)((char *)*a2 + 100);
    os_unfair_lock_lock(v10);
    unint64_t v11 = ((unint64_t)*(unsigned int *)((char *)v9 + 115) >> 5) & 1;
    os_unfair_lock_unlock(v10);
    if (v8 != v11) {
      return 0;
    }
    TFSInfo::Name(this, &v17);
    TFSInfo::Name(*a2, &v16);
    if (CFEqual(v17.fString.fRef, v16.fString.fRef))
    {
      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
      BOOL v12 = (*(_DWORD *)((char *)this + 115) & 0x40) == 0;
      os_unfair_lock_unlock(v7);
      CFArrayRef v13 = *a2;
      int v14 = (os_unfair_lock_s *)((char *)*a2 + 100);
      os_unfair_lock_lock(v14);
      unint64_t v15 = ((unint64_t)*(unsigned int *)((char *)v13 + 115) >> 6) & 1;
      os_unfair_lock_unlock(v14);
      uint64_t v5 = v12 ^ v15;
    }
    else
    {
      uint64_t v5 = 0;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17.fString.fRef);
    return v5;
  }
  return TFSInfo::Equal(this, a2);
}

void sub_1D3479CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

BOOL TFSVolumeInfo::ShouldUseReadDir(TFSVolumeInfo *this)
{
  if (TFSVolumeInfo::LoadPrefs(void)::once != -1) {
    dispatch_once(&TFSVolumeInfo::LoadPrefs(void)::once, &__block_literal_global_16);
  }
  if (!TFSVolumeInfo::gCanUseReadDir) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 7);
  if (!v2 || *(unsigned char *)(v2 + 112)) {
    return 0;
  }
  BOOL result = 0;
  int v4 = *((_DWORD *)this + 18);
  if (v4 && v4 != 5)
  {
    if (!*((unsigned char *)this + 127))
    {
      if (!*((unsigned char *)this + 107))
      {
        if (TFSVolumeInfo::gNoNetworkPropertyStores) {
          return 1;
        }
        int v4 = *((_DWORD *)this + 18);
      }
      return (v4 - 1) < 3;
    }
    return 0;
  }
  return result;
}

void TFSInfoSynchronizer::TFSInfoSynchronizer(TFSInfoSynchronizer *this, const TNodePtr *a2)
{
  *((_DWORD *)this + 12) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  objc_storeStrong((id *)this + 3, a2->fFINode);
  uint64_t v4 = TNodeFromFINode(a2->fFINode);
  uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
  os_unfair_lock_lock(v5);
  uint64_t v7 = *(void *)(v4 + 16);
  uint64_t v6 = *(void *)(v4 + 24);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  unint64_t v8 = (std::__shared_weak_count *)*((void *)this + 5);
  *((void *)this + 4) = v7;
  *((void *)this + 5) = v6;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_1D3479E6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  BOOL v12 = *(std::__shared_weak_count **)(v10 + 40);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }

  a10 = (void **)v10;
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::ShouldRecordIterationTimes(TFSVolumeInfo *this)
{
  if (TFSVolumeInfo::LoadPrefs(void)::once != -1) {
    dispatch_once(&TFSVolumeInfo::LoadPrefs(void)::once, &__block_literal_global_16);
  }
  return TFSVolumeInfo::gTimeIterations;
}

uint64_t TFSVolumeInfo::ShouldSkipLSProperties(TFSVolumeInfo *this)
{
  if (TFSVolumeInfo::LoadPrefs(void)::once != -1) {
    dispatch_once(&TFSVolumeInfo::LoadPrefs(void)::once, &__block_literal_global_16);
  }
  return TFSVolumeInfo::gSkipLSProperties;
}

TChildrenList *TChildrenList::SetLastSyncDuration(TChildrenList *this, uint64_t a2)
{
  *((void *)this + 14) = a2;
  return this;
}

TChildrenList *TChildrenList::SetLastSyncTime(TChildrenList *this, uint64_t a2)
{
  *((void *)this + 15) = a2;
  return this;
}

uint64_t std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__swap_out_circular_buffer(uint64_t a1, void *a2, id *a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = a1 + 16;
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>,std::reverse_iterator<std::pair<TNodePtr,TNodeEventPtr>*>>(a1 + 16, (uint64_t)a3, (uint64_t)a3, *(void *)a1, *(void *)a1, v6, v6);
  a2[1] = v8;
  a2[2] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::pair<TNodePtr,TNodeEventPtr>*,std::pair<TNodePtr,TNodeEventPtr>*,std::pair<TNodePtr,TNodeEventPtr>*>(v7, a3, *(id **)(a1 + 8), (void *)a2[2]);
  uint64_t v9 = *(void *)a1;
  *(void *)a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[2];
  a2[2] = v10;
  uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

void *std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::pair<TNodePtr,TNodeEventPtr>*,std::pair<TNodePtr,TNodeEventPtr>*,std::pair<TNodePtr,TNodeEventPtr>*>(uint64_t a1, id *a2, id *a3, void *a4)
{
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      TNodePtr::TNodePtr(a4, v6);
      a4[1] = v6[1];
      v6 += 2;
      a4 += 2;
    }
    while (v6 != a3);
  }
  return a4;
}

void *std::__split_buffer<std::pair<TNodePtr,TNodeEventPtr>>::__construct_at_end_with_size<std::__wrap_iter<std::pair<TNodePtr,TNodeEventPtr> const*>>(void *result, id *a2, uint64_t a3)
{
  int v3 = result;
  uint64_t v4 = (void *)result[2];
  if (a3)
  {
    uint64_t v6 = &v4[2 * a3];
    do
    {
      void *v4 = *a2;
      BOOL result = a2[1];
      v4[1] = result;
      v4 += 2;
      a2 += 2;
    }
    while (v4 != v6);
    uint64_t v4 = v6;
  }
  v3[2] = v4;
  return result;
}

void TNode::ReplaceChildrenWith(uint64_t a1, void ***a2, int a3)
{
  uint64_t v4 = *(void *)(a1 + 56);
  TChildrenList::ReplaceChildrenWith(v4, a2, a3);
  uint64_t v5 = *(FINode ***)(v4 + 64);
  uint64_t v6 = *(FINode ***)(v4 + 72);
  while (v5 != v6)
  {
    uint64_t v7 = TNodeFromFINode(*v5);
    TNodePtr::TNodePtr(&v10, (const TNode *)a1);
    uint64_t v9 = (os_unfair_lock_s *)TNode::ParentLock(v8);
    os_unfair_lock_lock(v9);
    *(void *)(v7 + 48) = TNodeFromFINode(v10.fFINode);
    os_unfair_lock_unlock(v9);

    ++v5;
  }
}

void sub_1D347A14C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  os_unfair_lock_unlock(v10);

  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::ReadHiddenListFile(TFSVolumeInfo *this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t result = TFSVolumeInfo::MayHaveHiddenList(this);
  if (result)
  {
    TDSMutex::lock((TDSMutex *)((char *)this + 224));
    if (!*((unsigned char *)this + 288))
    {
      int v3 = (TFSInfo *)*((void *)this + 7);
      if (v3)
      {
        if (!TFSInfo::CopyPathToCBuffer(v3, __dst, 1024)
          && strlcat(__dst, "/.hidden", 0x400uLL) <= 0x3FF)
        {
          ReadHiddenList((uint64_t)this + 192, __dst);
        }
        *((unsigned char *)this + 288) = 1;
      }
    }
    return TDSMutex::unlock((TDSMutex *)((char *)this + 224));
  }
  return result;
}

void sub_1D347A238(_Unwind_Exception *a1)
{
  TDSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

void TChildrenList::ReplaceChildrenWith(uint64_t a1, void ***a2, int a3)
{
  uint64_t v7 = *(FINode ***)(a1 + 64);
  uint64_t v8 = *(FINode ***)(a1 + 72);
  uint64_t v6 = a1 + 64;
  if (v7 == v8)
  {
    uint64_t v12 = *(void *)(a1 + 64);
  }
  else
  {
    do
    {
      uint64_t v9 = TNodeFromFINode(*v7);
      TNodePtr::TNodePtr(&v16, 0);
      uint64_t v11 = (os_unfair_lock_s *)TNode::ParentLock(v10);
      os_unfair_lock_lock(v11);
      *(void *)(v9 + 48) = TNodeFromFINode(v16.fFINode);
      os_unfair_lock_unlock(v11);

      ++v7;
    }
    while (v7 != v8);
    uint64_t v7 = *(FINode ***)(a1 + 64);
    uint64_t v12 = *(void *)(a1 + 72);
  }
  uint64_t v13 = v12 - (void)v7;
  std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>(v6, *a2, a2[1], a2[1] - *a2);
  uint64_t v14 = *(void *)(a1 + 72) - *(void *)(a1 + 64);
  if (a3) {
    uint64_t v15 = v14 >> 3;
  }
  else {
    uint64_t v15 = 0;
  }
  *(void *)(a1 + 152) = v15;
  if (v13 != v14)
  {
    atomic_store(v14 >> 3, (unint64_t *)(a1 + 160));
    ++*(_DWORD *)(a1 + 184);
  }
}

void sub_1D347A360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  os_unfair_lock_unlock(v10);

  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__deallocate_node(a1, *(TDSNotifier ***)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__deallocate_node(uint64_t a1, TDSNotifier **a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      int v3 = *v2;
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v2 + 2);
      operator delete(v2);
      uint64_t v2 = (TDSNotifier **)v3;
    }
    while (v3);
  }
}

uint64_t TFSInfo::IsResumableCopyTarget(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  uint64_t v3 = (*(unsigned __int16 *)((char *)this + 119) >> 12) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

unint64_t TFSInfo::UserCanAddFolder(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 21) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

unint64_t TFSInfo::UserCanAddFile(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 20) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

unint64_t TNode::UserCanWriteDataFork(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  unint64_t v6 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return (v6 >> 13) & 1;
}

TNode *TNode::UnmarkChildren(TNode *this)
{
  uint64_t v1 = *((void *)this + 7);
  if (v1)
  {
    uint64_t v2 = *(FINode ***)(v1 + 64);
    unint64_t v3 = *(FINode ***)(v1 + 72);
    while (v2 != v3)
    {
      uint64_t v4 = *v2++;
      this = (TNode *)TNodeFromFINode(v4);
      atomic_fetch_and((atomic_ushort *volatile)this + 40, 0xFEFFu);
    }
  }
  return this;
}

uint64_t TNode::RemoveUnmarkedChildren(TNode *this, TNodeEventPtrs *a2)
{
  TNodePtr::TNodePtr(&v40, this);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v39, &v40, 0);

  uint64_t v4 = *((void *)this + 7);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 64);
    uint64_t v6 = *(void *)(v4 + 72);
    if (v6 == v5)
    {
      char v7 = 0;
    }
    else
    {
      char v7 = 0;
      uint64_t v8 = *(void *)(v4 + 72);
      do
      {
        uint64_t v9 = *(FINode **)(v8 - 8);
        v8 -= 8;
        uint64_t v10 = TNodeFromFINode(v9);
        uint64_t v11 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v10);
        os_unfair_lock_lock(v11);
        uint64_t v13 = *(void *)(v10 + 16);
        uint64_t v12 = *(std::__shared_weak_count **)(v10 + 24);
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v11);
        os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
        unint64_t v14 = *(unsigned int *)(v13 + 115) | ((unint64_t)*(unsigned __int16 *)(v13 + 119) << 32);
        os_unfair_lock_unlock((os_unfair_lock_t)(v13 + 100));
        if ((v14 & 0x100000000) == 0)
        {
          unsigned __int16 v15 = atomic_load((unsigned __int16 *)(TNodeFromFINode(*(FINode **)(v6 - 8)) + 80));
          if ((v15 & 0x100) == 0)
          {
            if (*(unsigned char *)(v13 + 112) == 27)
            {
              TNodePtr v16 = (os_unfair_lock_s *)(v13 + 96);
              os_unfair_lock_lock((os_unfair_lock_t)(v13 + 96));
              uint64_t v17 = *(void *)(v13 + 80);
              if (v17
                && (os_unfair_lock_lock((os_unfair_lock_t)(v17 + 72)),
                    int v18 = *(unsigned __int8 *)(v17 + 76),
                    os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 72)),
                    v18 == 1))
              {
                id v19 = *(id *)(v17 + 24);
              }
              else
              {
                id v19 = 0;
              }
              os_unfair_lock_unlock(v16);
              int v38 = 0;
              __int16 v20 = [v19 rootURL];
              id v21 = v20;
              if (v20)
              {
                v40.fFINode = v20;
                TNode::GetNodeFromURL((CFURLRef *)&v40, (TNodePtr *)&v38, 0x80u);
              }

              if (TNodeFromFINode(v38))
              {
                uint64_t v22 = (TNode *)TNodeFromFINode(v38);
                TNode::DetachFPItemsMetadata(v22);
                uint64_t v23 = TNodeFromFINode(v38);
                TNode::HandleSync(v23, 0x1040000u);
                uint64_t v24 = TNodeFromFINode(v38);
                uint64_t v25 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v24);
                os_unfair_lock_lock(v25);
                uint64_t v27 = *(TFSInfo **)(v24 + 16);
                uint64_t v26 = *(std::__shared_weak_count **)(v24 + 24);
                if (v26) {
                  atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                os_unfair_lock_unlock(v25);
                unsigned int v28 = TFSInfo::GetFPItem(v27);
                if (v26) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v26);
                }

                if (v28)
                {
                  uint64_t v29 = TNodeFromFINode(v38);
                  uint64_t v30 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v29);
                  os_unfair_lock_lock(v30);
                  int v32 = *(TFSInfo **)(v29 + 16);
                  CFStringRef v31 = *(std::__shared_weak_count **)(v29 + 24);
                  if (v31) {
                    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  os_unfair_lock_unlock(v30);
                  TFSInfo::SetFPItem(v32, 0);
                  if (v31) {
                    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
                  }
                }
              }
              if ([v19 isiCloudDriveProvider])
              {
                if ([v19 isDataSeparatedDomain]) {
                  TGlobalNodes::DataSeparatedICloudLibrariesContainerNode(&v40);
                }
                else {
                  TGlobalNodes::iCloudLibrariesContainerNode(&v40);
                }
                if (TNodeFromFINode(v40.fFINode))
                {
                  int v33 = (TNode *)TNodeFromFINode(v40.fFINode);
                  TNode::RemoveAllChildren(v33, 0, 0);
                  atomic_fetch_and((atomic_ushort *volatile)(TNodeFromFINode(v40.fFINode) + 80), 0xFFF7u);
                  atomic_fetch_and((atomic_ushort *volatile)(TNodeFromFINode(v40.fFINode) + 80), 0xFFEFu);
                }
              }
            }
            id v34 = (TNode *)TNodeFromFINode(*(FINode **)(v6 - 8));
            TNode::CloseNodeBrowserIfNecessary(v34, 0);
            double v35 = (TNode *)TNodeFromFINode(*(FINode **)(v6 - 8));
            TNode::Remove(v35, 0, a2);
            char v7 = 1;
          }
        }
        if (v12) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v12);
        }
        uint64_t v6 = v8;
      }
      while (v8 != v5);
    }
    uint64_t v36 = v7 & 1;
  }
  else
  {
    uint64_t v36 = 0;
  }
  TNode::StPopulating::~StPopulating(v39);
  return v36;
}

void sub_1D347A8C8(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  va_start(va, a3);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }

  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  TNode::StPopulating::~StPopulating((FINode **)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::AddNewChildren(uint64_t a1, TNodePtr **a2, int a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v5 = TChildrenList::AddNewChildren(*(void *)(a1 + 56), a2, a3, a4, (uint64_t *)&v10, a5);
  uint64_t v6 = v10;
  char v7 = v11;
  while (v6 != v7)
  {
    uint64_t v8 = (TNode *)TNodeFromFINode(*v6);
    TNode::RemoveSelf(v8, 0);
    ++v6;
  }
  uint64_t v13 = &v10;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v13);
  return v5;
}

void sub_1D347A9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c50_ZTSKZ37__DSProvidersObserver_startObserving_E3__6(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

const void **TFSInfo::SynchronizeKinds(TFSInfo *this, TFSInfo **a2, uint64_t **a3)
{
  if (!*((unsigned char *)this + 112) && *((void *)this + 5))
  {
    CFTypeRef cf2 = 0;
    TFSInfo::GetUTType(this, (id *)&cf2, 128, &v11);
    CFTypeRef cf1 = 0;
    TFSInfo::GetUTType(*a2, (id *)&cf1, 0, &v11);
    uint64_t v6 = (void *)cf1;
    char v7 = (void *)cf2;
    if (([(id)cf1 isEqual:cf2] & 1) == 0)
    {
      unsigned int v9 = 1970566256;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v9, &v9);
      unsigned int v9 = 1970563428;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v9, &v9);
    }
  }
  id result = (const void **)TFSInfo::KindWithoutPlatformFetched(this);
  if (result)
  {
    CFTypeRef cf2 = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TFSInfo::GetKindWithoutPlatform(this, (TString *)&cf2, 128, &v11);
    CFTypeRef cf1 = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TFSInfo::GetKindWithoutPlatform(*a2, (TString *)&cf1, 0, &v11);
    if (!CFEqual(cf1, cf2))
    {
      unsigned int v9 = 1802072172;
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v9, &v9);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
  }
  return result;
}

void sub_1D347AB90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

BOOL TFSInfo::KindWithoutPlatformFetched(TFSInfo *this)
{
  if (*((unsigned char *)this + 112)) {
    return 0;
  }
  TFSInfo::LocalizedTypeDescription(this, (TString *)&theString);
  BOOL v1 = CFStringGetLength(theString) != 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v1;
}

void sub_1D347AC40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

id TFSInfo::ISIconRefFromTypeInfo(TFSInfo *this)
{
  id location = 0;
  TFSInfo::GetUTType(this, &location, 128, &v9);
  id v2 = location;
  if (location)
  {
    id v3 = objc_alloc(MEMORY[0x1E4F6F248]);
    uint64_t v4 = [v2 identifier];
    uint64_t v5 = (void *)[v3 initWithType:v4];
  }
  else
  {
    TFSInfo::ActualSuffix(this, (TString *)&v8);
    id v6 = objc_alloc(MEMORY[0x1E4F6F248]);
    uint64_t v5 = (void *)[v6 initWithFileExtension:v8];
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v8);
  }

  return v5;
}

void sub_1D347AD1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetUTType(TFSInfo *this, id *location, char a3, unsigned char *a4)
{
  *a4 = 0;
  uint64_t v6 = 0;
  switch(*((unsigned char *)this + 112))
  {
    case 0:
      uint64_t v13 = TFSInfo::GetUTType(this);
      unint64_t v14 = (UTType *)*location;
      *id location = v13;

      if (*location) {
        return 0;
      }
      if (a3 < 0)
      {
        __int16 v20 = TFSInfo::ApproximateUTType(this);
        id v21 = (UTType *)*location;
        *id location = v20;

        id v19 = (UTType *)*location;
        if (*location) {
          uint64_t v6 = 4294959210;
        }
        else {
          uint64_t v6 = 4294959222;
        }
      }
      else
      {
        os_unfair_lock_lock((os_unfair_lock_t)this + 25);
        unsigned __int16 v15 = (void *)*((void *)this + 2);
        uint64_t v22 = v15;
        if (v15) {
          CFRetain(v15);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
        TNodePtr v16 = TCFURLInfo::ObjectProperty((TCFURLInfo *)v15, (const __CFString *)*MEMORY[0x1E4F1C538], (const __CFString *)1);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v22);
        uint64_t v17 = static_objc_cast<NSString,objc_object * {__strong}>(v16);
        int v18 = (UTType *)*location;
        *id location = v17;

        uint64_t v6 = 0;
        id v19 = (UTType *)*location;
      }
      TFSInfo::SetUTType(this, v19, v6 != 0);
      return v6;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 0xB:
    case 0xC:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x1A:
    case 0x1D:
    case 0x22:
    case 0x23:
      char v7 = (UTType *)*location;
      *id location = 0;

      return 0;
    case 0x1B:
    case 0x1C:
      char v9 = TFSInfo::GetFPItem(this);
      uint64_t v10 = [v9 contentType];
      char v11 = (UTType *)*location;
      *id location = v10;

      return 0;
    case 0x1F:
    case 0x20:
    case 0x21:
      return v6;
    default:
      objc_storeStrong(location, (id)*MEMORY[0x1E4F44408]);
      return 0;
  }
}

void sub_1D347AEFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

TString *std::deque<TString>::__append_with_size[abi:ne180100]<std::__deque_iterator<TString,TString const*,TString const&,TString const* const*,long,512l>>(void *a1, void *a2, TString **a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    std::deque<TString>::__add_back_capacity(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }
  uint64_t v13 = (TString *)(v8 + 8 * (v11 >> 9));
  if (v9 == v8) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = (uint64_t)v13->fString.fRef + 8 * (v11 & 0x1FF);
  }
  v23[0] = v8 + 8 * (v11 >> 9);
  v23[1] = v14;
  id result = (TString *)std::__deque_iterator<TString,TString*,TString&,TString**,long,512l>::operator+[abi:ne180100]((uint64_t)v23, a4);
  if (v14 != v16)
  {
    uint64_t v17 = result;
    uint64_t v18 = v16;
    do
    {
      if (v13 == v17) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = (uint64_t)&v13->fString.fRef[128];
      }
      if (v14 == v19)
      {
        uint64_t v19 = v14;
      }
      else
      {
        uint64_t v20 = 0;
        do
        {
          id result = std::construct_at[abi:ne180100]<TString,TString const&,TString*>((TString *)(v14 + v20), a3++);
          if ((TString **)((char *)a3 - *a2) == (TString **)4096)
          {
            id v21 = (TString **)a2[1];
            ++a2;
            a3 = v21;
          }
          v20 += 8;
        }
        while (v14 + v20 != v19);
      }
      a1[5] += (v19 - v14) >> 3;
      if (v13 == v17) {
        break;
      }
      uint64_t fRef = (uint64_t)v13[1].fString.fRef;
      ++v13;
      uint64_t v14 = fRef;
    }
    while (fRef != v18);
  }
  return result;
}

void sub_1D347B094(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) += v2 >> 3;
  _Unwind_Resume(a1);
}

void std::deque<TString>::__add_back_capacity(void *a1, unint64_t a2)
{
  id v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    for (a1[4] = v7 - (v8 << 9); v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          if (v3 == (char *)*a1) {
            unint64_t v28 = 1;
          }
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          uint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v28);
          CFStringRef v31 = &v29[8 * (v28 >> 2)];
          int v32 = (uint64_t *)a1[1];
          id v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            id v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v34 = 8 * (v33 >> 3);
            double v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)double v35 = v36;
              v35 += 8;
              v34 -= 8;
            }
            while (v34);
          }
          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            id v3 = (char *)a1[2];
          }
        }
        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          uint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            id v3 = (char *)a1[1];
          }
          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          id v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }
      *(void *)id v3 = v18;
      id v3 = (char *)(a1[2] + 8);
      a1[2] = v3;
    }
  }
  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0x1000uLL);
          std::__split_buffer<TNodeEventPtr *>::push_back(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }
        for (uint64_t i = 0; i != v9; ++i)
        {
          __p[0] = operator new(0x1000uLL);
          std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8) {
            uint64_t v64 = 511;
          }
          else {
            uint64_t v64 = 512;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }
        unint64_t v8 = v6;
      }
      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }
      a1[4] = v65 - (v8 << 9);
      if (v8)
      {
        uint64_t v66 = (char *)a1[2];
        do
        {
          int v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          char v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              if (v66 == (char *)*a1) {
                unint64_t v78 = 1;
              }
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              uint64_t v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v78);
              int v81 = &v79[8 * (v78 >> 2)];
              uint64_t v82 = (uint64_t *)a1[1];
              uint64_t v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                uint64_t v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v84 = 8 * (v83 >> 3);
                int v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)int v85 = v86;
                  v85 += 8;
                  v84 -= 8;
                }
                while (v84);
              }
              uint64_t v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                uint64_t v66 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              int v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                uint64_t v66 = (char *)a1[1];
              }
              unsigned __int16 v77 = &v66[-8 * (v74 >> 1)];
              uint64_t v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }
          *(void *)uint64_t v66 = v69;
          uint64_t v66 = (char *)(a1[2] + 8);
          a1[2] = v66;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      uint64_t v91 = a1 + 3;
      if (v13) {
        unsigned __int16 v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v13);
      }
      else {
        unsigned __int16 v15 = 0;
      }
      uint64_t v38 = v8 << 9;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&long long v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        uint64_t v88 = operator new(0x1000uLL);
        std::__split_buffer<TNodeEventPtr *>::push_back(__p, &v88);
        --v9;
      }
      while (v9);
      if (v8)
      {
        char v39 = (void *)a1[1];
        TNodePtr v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              int v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)v91, v48);
              int v51 = (uint64_t *)__p[1];
              TNodePtr v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                TNodePtr v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v53 = 8 * (v52 >> 3);
                id v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)id v54 = v55;
                  v54 += 8;
                  v53 -= 8;
                }
                while (v53);
              }
              unsigned int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&long long v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                TNodePtr v40 = (char *)v90;
              }
            }
            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              int v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                TNodePtr v40 = (char *)__p[1];
              }
              int v47 = &v40[-8 * (v44 >> 1)];
              TNodePtr v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&long long v90 = &v45[v46];
            }
          }
          *(void *)TNodePtr v40 = *v39;
          TNodePtr v40 = (char *)(v90 + 8);
          *(void *)&long long v90 = v90 + 8;
          char v39 = (void *)(a1[1] + 8);
          a1[1] = v39;
          --v8;
        }
        while (v8);
      }
      int v57 = (void *)a1[2];
      uint64_t v58 = -7 - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8;
        std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)__p, v57);
      }
      CFStringRef v59 = (char *)*a1;
      long long v60 = *(_OWORD *)__p;
      long long v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      long long v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      long long v90 = v62;
      a1[4] -= v38;
      if (v57 != (void *)v62) {
        *(void *)&long long v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }
}

void sub_1D347B5BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__deque_iterator<TString,TString*,TString&,TString**,long,512l>::operator+[abi:ne180100](uint64_t a1, uint64_t a2)
{
  id result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 3);
    if (v4 < 1) {
      result -= (unint64_t)(511 - v4) >> 9;
    }
    else {
      result += (unint64_t)v4 >> 9;
    }
  }
  return result;
}

void NodeContextOpen()
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  TString::TString(&v7, "DS Context");
  TString::TString(&v6, "Open");
  uint64_t v1 = StSignpostMacroHelper::GetOrCreateFinderLog(&v7, v0);
  ISignpostInterval::ISignpostInterval((uint64_t)&v9, v1);

  os_signpost_id_t SignpostID = ISignpostInterval::MakeSignpostID((ISignpostInterval *)&v9, 0);
  v11[0] = &unk_1F2AB9638;
  void v11[3] = v11;
  void v11[4] = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  std::mutex::lock(&v9);
  os_signpost_id_t v8 = SignpostID;
  *(void *)TPropertyValue buf = &unk_1F2AB98A0;
  unint64_t v13 = &v8;
  unint64_t v14 = buf;
  ISignpostInterval::BeginPriv((uint64_t)&v9, SignpostID, (uint64_t)buf);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](buf);
  std::mutex::unlock(&v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  if (gNodeContextCloseAsyncGroup)
  {
    std::mutex::lock(&gNodeContextCloseAsyncSignpostLock);
    if (gNodeContextCloseAsyncSignpost) {
      AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(gNodeContextCloseAsyncSignpost, (uint64_t)"Waiting for previous context close to complete");
    }
    std::mutex::unlock(&gNodeContextCloseAsyncSignpostLock);
    dispatch_group_wait((dispatch_group_t)gNodeContextCloseAsyncGroup, 0xFFFFFFFFFFFFFFFFLL);
  }
  ContextMutex();
  TDSMutex::lock(&ContextMutex(void)::mutex);
  int v2 = sContextOpenCount++;
  if (v2 <= 0)
  {
    id v3 = LogObj(5);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)TPropertyValue buf = 0;
      _os_log_impl(&dword_1D343E000, v3, OS_LOG_TYPE_DEFAULT, "DS Opened", buf, 2u);
    }

    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3321888768;
    uint64_t v5[2] = __NodeContextOpen_block_invoke;
    void v5[3] = &__block_descriptor_33_ea8_32c28_ZTSKZ15NodeContextOpenE3__2_e5_v8__0l;
    if (NodeContextOpen::once != -1) {
      dispatch_once(&NodeContextOpen::once, v5);
    }
    TSystemNotificationTask::MakeSystemNotificationTask(v4);
  }
  TDSMutex::unlock(&ContextMutex(void)::mutex);
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&v9);
}

void sub_1D347B910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, int a7, __int16 a8, char a9, char a10, uint64_t a11, std::mutex *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
}

void TNode::SynchronizeVolumes(TNode *this)
{
  TGlobalNodes::RootNode((uint64_t *)&v4);
  uint64_t v1 = TNodeFromFINode(v4);
  BOOL v5 = 0;
  int v2 = TNode::HandleSyncStarted(v1, 285212672, &v5);
  uint64_t v3 = TNodeFromFINode(v4);
  TNode::HandleSyncCompleted(v3, v2);
}

void sub_1D347BA58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void TSystemNotificationTask::MakeSystemNotificationTask(TSystemNotificationTask *this)
{
  if (!TSystemNotificationTask::gBusyFolders) {
    operator new();
  }
  operator new();
}

void sub_1D347BB04(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;
  MEMORY[0x1D9436740](v2, 0x10A0C4035A50E9BLL);
  std::mutex::unlock(&gBusyFoldersLock);
  _Unwind_Resume(a1);
}

const void **TBusyFolders::StartObserving(TBusyFolders *this)
{
  uint64_t v2 = (id)gSystemNotificationStreamGCDQueue;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders14StartObservingEv_block_invoke;
  block[3] = &__block_descriptor_48_ea8_32c44_ZTSKZN12TBusyFolders14StartObservingEvE3__0_e5_v8__0l;
  uint64_t v3 = TBusyFolders::CopyBusyFolders(this);
  BOOL v5 = v3;
  void block[4] = this;
  TString v7 = v3;
  if (v3) {
    CFRetain(v3);
  }
  dispatch_async(v2, block);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)&v5);

  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)&v7);
}

void sub_1D347BC28(_Unwind_Exception *a1)
{
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

void _NodeContextOpenExtended()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  TString::TString(&v5, "DS Context");
  TString::TString(&v4, "Open Extended");
  uint64_t v1 = StSignpostMacroHelper::GetOrCreateFinderLog(&v5, v0);
  ISignpostInterval::ISignpostInterval((uint64_t)&v7, v1);

  os_signpost_id_t SignpostID = ISignpostInterval::MakeSignpostID((ISignpostInterval *)&v7, 0);
  v9[0] = &unk_1F2AB96E8;
  void v9[3] = v9;
  v9[4] = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  std::mutex::lock(&v7);
  os_signpost_id_t v6 = SignpostID;
  *(void *)TPropertyValue buf = &unk_1F2AB9A00;
  uint64_t v11 = &v6;
  unint64_t v12 = buf;
  ISignpostInterval::BeginPriv((uint64_t)&v7, SignpostID, (uint64_t)buf);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](buf);
  std::mutex::unlock(&v7);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4.fString.fRef);
  uint64_t v2 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  TSystemNotificationTask::gHandleFolderManager = 1;
  sOpenDSStoreOnEnumeration = 1;
  sManageSidebar = 1;
  TFSInfo::MarkAsUsed((TFSInfo *)v2);
  NodeContextOpen();
  if (UseFileProviderFramework())
  {
    uint64_t v3 = LogObj(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)TPropertyValue buf = 0;
      _os_log_impl(&dword_1D343E000, v3, OS_LOG_TYPE_DEFAULT, "FileProvider enabled", buf, 2u);
    }
  }
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&v7);
}

void sub_1D347BE10(_Unwind_Exception *a1, char a2, int a3, __int16 a4, char a5, char a6, uint64_t a7, std::mutex *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void *std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

os_signpost_id_t ISignpostInterval::MakeSignpostID(ISignpostInterval *this, void *a2)
{
  uint64_t v2 = *((void *)this + 8);
  if (a2) {
    return os_signpost_id_make_with_pointer(v2, a2);
  }
  else {
    return os_signpost_id_generate(v2);
  }
}

void StSignpostMacroHelper::~StSignpostMacroHelper(StSignpostMacroHelper *this)
{
  std::mutex::lock((std::mutex *)this);
  std::function<void ()(StSignpostMacroHelper *,unsigned long long)>::operator()((uint64_t)this + 120, (uint64_t)this, *((void *)this + 14));
  std::mutex::unlock((std::mutex *)this);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 19);
  std::__function::__value_func<void ()(StSignpostMacroHelper *,unsigned long long)>::~__value_func[abi:ne180100]((void *)this + 15);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)this + 72);

  std::mutex::~mutex((std::mutex *)this);
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  TString v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void *std::__function::__value_func<void ()(StSignpostMacroHelper *,unsigned long long)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::function<void ()(StSignpostMacroHelper *,unsigned long long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

uint64_t *StSignpostMacroHelper::GetOrCreateFinderLog(TString *this, const TString *a2)
{
  {
    StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::gFinderLogs = 0u;
    unk_1EA6ABB00 = 0u;
    dword_1EA6ABB10 = 1065353216;
  }
  std::mutex::lock(&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::fMutex);
  if (!std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::find<TString>(&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::gFinderLogs, this))
  {
    uint64_t v3 = (const char *)TString::c_str(this);
    os_log_t v4 = os_log_create("com.apple.DesktopServices", v3);
    std::mutex v9 = (TString **)this;
    uint64_t v5 = std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::gFinderLogs, this, (uint64_t)&std::piecewise_construct, &v9);
    uint64_t v6 = v5[3];
    void v5[3] = (uint64_t *)v4;
  }
  std::mutex v9 = (TString **)this;
  std::mutex v7 = std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::gFinderLogs, this, (uint64_t)&std::piecewise_construct, &v9)[3];
  std::mutex::unlock(&StSignpostMacroHelper::GetOrCreateFinderLog(TString const&)::fMutex);
  return v7;
}

void sub_1D347C218(_Unwind_Exception *a1)
{
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(uint64_t a1, TString *this, uint64_t a3, TString ***a4)
{
  unint64_t v8 = FowlerNollVoHash::hash(this, this);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
    uint64_t v13 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (CFEqual(i[2], this->fString.fRef)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(a1, (__CFString *)v9, a4, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *BOOL v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (uint64_t **)v25[0];
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D347C494(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a10) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::find<TString>(void *a1, TString *this)
{
  unint64_t v4 = FowlerNollVoHash::hash(this, this);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  unint64_t v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t i = *v10; i; uint64_t i = (uint64_t **)*i)
  {
    unint64_t v12 = (unint64_t)i[1];
    if (v12 == v6)
    {
      if (CFEqual(i[2], this->fString.fRef)) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

uint64_t ISignpostInterval::ISignpostInterval(uint64_t a1, void *a2)
{
  id v3 = a2;
  *(void *)a1 = 850045863;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = v3;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 1065353216;
  return a1;
}

void ISignpostInterval::BeginPriv(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = a2;
  BOOL v6 = os_signpost_enabled(*(os_log_t *)(a1 + 64));
  if (a2)
  {
    if (v6)
    {
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(a1 + 72, &v7, &v7);
      std::function<void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(a3, *(void **)(a1 + 64));
    }
  }
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t a1, unint64_t *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x18uLL);
  void *i = 0;
  i[1] = v6;
  i[2] = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *i = *v19;
LABEL_38:
    void *v19 = i;
    goto LABEL_39;
  }
  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D347C87C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ISignpostInterval::EndPriv(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = a2;
  BOOL v6 = os_signpost_enabled(*(os_log_t *)(a1 + 64));
  if (a2)
  {
    if (v6)
    {
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>((void *)(a1 + 72), &v7);
      std::function<void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(a3, *(void **)(a1 + 64));
    }
  }
}

void std::function<void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, id *))(*(void *)v3 + 48))(v3, &v4);
}

void sub_1D347C964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__erase_unique<unsigned long long>(void *a1, unint64_t *a2)
{
  id result = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(a1, a2);
  if (result)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  uint64_t v3 = __p;
  std::string __p = 0;
  if (v3) {
    operator delete(v3);
  }
  return v2;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  BOOL v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    BOOL v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  void *v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  BOOL v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  id result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      id result = (void *)*result;
    }
    while (result);
  }
  return result;
}

TString *std::__hash_table<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, __CFString *a2@<X1>, TString ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = (TString *)operator new(0x20uLL);
  *(void *)(a4 + 8) = v7;
  *(void *)a4 = v8;
  *(unsigned char *)(a4 + 16) = 0;
  v8->fString.uint64_t fRef = 0;
  v8[1].fString.uint64_t fRef = a2;
  id result = std::pair<TString const,NSObject  {objcproto9OS_os_log}* {__strong}>::pair[abi:ne180100]<TString const&>(v8 + 2, *a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D347CC48(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

TString *std::pair<TString const,NSObject  {objcproto9OS_os_log}* {__strong}>::pair[abi:ne180100]<TString const&>(TString *a1, TString **a2)
{
  a1->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.uint64_t fRef = 0;
  return a1;
}

void sub_1D347CCAC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  uint64_t v3 = *a2;
  uint8x8_t v4 = v3;
  os_signpost_id_t v5 = **(void **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)BOOL v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v4, OS_SIGNPOST_INTERVAL_END, v5, "Open Extended", "End", v6, 2u);
  }
}

void std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  uint64_t v3 = *a2;
  uint8x8_t v4 = v3;
  os_signpost_id_t v5 = **(void **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)BOOL v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "Open Extended", "Begin", v6, 2u);
  }
}

void std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  uint64_t v3 = *a2;
  uint8x8_t v4 = v3;
  os_signpost_id_t v5 = **(void **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)BOOL v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v4, OS_SIGNPOST_INTERVAL_END, v5, "Open", "End", v6, 2u);
  }
}

void std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  uint64_t v3 = *a2;
  uint8x8_t v4 = v3;
  os_signpost_id_t v5 = **(void **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)BOOL v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "Open", "Begin", v6, 2u);
  }
}

void *std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  void v6[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  unint64_t v5 = *a3;
  v6[0] = &unk_1F2AB9A58;
  v6[1] = &v5;
  void v6[3] = v6;
  ISignpostInterval::EndPriv(v3, v5, (uint64_t)v6);
  return std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](v6);
}

void sub_1D347CFB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  void v6[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  unint64_t v5 = *a3;
  v6[0] = &unk_1F2AB98F8;
  v6[1] = &v5;
  void v6[3] = v6;
  ISignpostInterval::EndPriv(v3, v5, (uint64_t)v6);
  return std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](v6);
}

void sub_1D347D060(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1D347D0C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D347D254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

id DSFileServiceXPCInterface(void)
{
  uint64_t v5[2] = *MEMORY[0x1E4F143B8];
  SecTaskRef v0 = [MEMORY[0x1E4F29280] interfaceWithProtocol:&unk_1F2ACABF8];
  uint64_t v1 = (void *)MEMORY[0x1E4F1CAD0];
  v5[0] = objc_opt_class();
  v5[1] = objc_opt_class();
  uint64_t v2 = [MEMORY[0x1E4F1C978] arrayWithObjects:v5 count:2];
  uint64_t v3 = [v1 setWithArray:v2];
  [v0 setClasses:v3 forSelector:sel_inProgressOperationsWithReply_ argumentIndex:0 ofReply:1];

  return v0;
}

void sub_1D347D3A8(_Unwind_Exception *a1)
{
  uint8x8_t v4 = v3;

  _Unwind_Resume(a1);
}

void std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(id *a1, void **a2, void **a3)
{
  uint64_t v10 = (FINode **)a2;
  unint64_t v11 = a1;
  unint64_t v9 = (FINode **)a3;
  BOOL v5 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a2, (FINode **)a1);
  BOOL v6 = TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a3, (FINode **)a2);
  if (v5)
  {
    if (v6)
    {
      uint64_t v7 = &v11;
    }
    else
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v11, (void ***)&v10);
      if (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v9, v10)) {
        return;
      }
      uint64_t v7 = (id **)&v10;
    }
    unint64_t v8 = &v9;
    goto LABEL_10;
  }
  if (v6)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v10, (void ***)&v9);
    if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v10, (FINode **)v11))
    {
      uint64_t v7 = &v11;
      unint64_t v8 = &v10;
LABEL_10:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(v7, (void ***)v8);
    }
  }
}

BOOL TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(FINode **a1, FINode **a2)
{
  uint64_t v3 = TNodeFromFINode(*a1);
  uint8x8_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
  os_unfair_lock_lock(v4);
  BOOL v6 = *(TFSInfo **)(v3 + 16);
  BOOL v5 = *(std::__shared_weak_count **)(v3 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  uint64_t v7 = TNodeFromFINode(*a2);
  unint64_t v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v7);
  os_unfair_lock_lock(v8);
  unint64_t v9 = *(std::__shared_weak_count **)(v7 + 24);
  float v12 = *(TFSInfo **)(v7 + 16);
  float v13 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  BOOL v10 = TFSInfo::LessThan(v6, &v12);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return v10;
}

void sub_1D347D558(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(id **a1, void ***a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  TNodePtr::TNodePtr(&v4, *a1);
  TNodePtr::operator=(v2, v3);
  TNodePtr::operator=(v3, &v4);
}

void ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke(uint64_t a1)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = ___ZN21TClientChangeNotifier22SetTimerToHandleTickleEP11TDSNotifiery_block_invoke_2;
  v2[3] = &__block_descriptor_40_e5_v8__0l;
  v2[4] = *(void *)(a1 + 40);
  ExceptionSafeBlock(v2);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
}

void sub_1D347D6DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN12TGlobalNodes11GlobalNodesEv_block_invoke()
{
}

void sub_1D347D7D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

id iCloudDriveDomainIDForDataSeparated(char a1)
{
  if (ICloudDriveFPFSEnabled())
  {
    if (a1)
    {
      uint64_t v2 = objc_msgSend((id)objc_opt_class(), "br_getProviderDomainIDForDataSeparated:", 1);
      if (!v2)
      {
        uint64_t v3 = LogObj(4);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)BOOL v5 = 0;
          _os_log_impl(&dword_1D343E000, v3, OS_LOG_TYPE_DEBUG, "Failed to get domain ID for data separated iCloud Drive account", v5, 2u);
        }
      }
    }
    else
    {
      uint64_t v2 = [(id)objc_opt_class() mainICloudDriveDomainID];
    }
  }
  else
  {
    uint64_t v2 = 0;
  }
  return v2;
}

id DefaultContainerOfDomainWithID(const TString *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1->fString.fRef;
  id v17 = 0;
  uint64_t v2 = +[FIProviderDomain rootURLForProviderDomainID:v1 cachePolicy:1 error:&v17];
  id v3 = v17;

  if (v2)
  {
    if (IsDatalessDomain(v2, 1))
    {
      uint8x8_t v4 = LogObj(4);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v5 = SanitizedURL(v2);
        *(_DWORD *)TPropertyValue buf = 138543362;
        unint64_t v19 = v5;
        _os_log_impl(&dword_1D343E000, v4, OS_LOG_TYPE_DEFAULT, "Root of iCloud Drive is dataless: %{public}@", buf, 0xCu);
      }
    }
    BOOL v6 = [(NSURL *)v2 URLByAppendingPathComponent:@"com~apple~CloudDocs" isDirectory:1];

    if (IsDatalessDomain(v6, 0))
    {
      uint64_t v7 = LogObj(4);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v8 = SanitizedURL(v6);
        *(_DWORD *)TPropertyValue buf = 138543362;
        unint64_t v19 = v8;
        _os_log_impl(&dword_1D343E000, v7, OS_LOG_TYPE_DEFAULT, "com~apple~CloudDocs is dataless: %{public}@", buf, 0xCu);
      }
      unint64_t v9 = dispatch_get_global_queue(-2, 0);
      uint64_t v12 = MEMORY[0x1E4F143A8];
      uint64_t v13 = 3321888768;
      BOOL v14 = ___ZL30DefaultContainerOfDomainWithIDRK7TString_block_invoke;
      unint64_t v15 = &__block_descriptor_40_ea8_32c54_ZTSKZL30DefaultContainerOfDomainWithIDRK7TStringE3__0_e5_v8__0l;
      unint64_t v16 = v6;
      dispatch_async(v9, &v12);
    }
    BOOL v10 = +[FINode fiNodeFromURL:](FINode, "fiNodeFromURL:", v6, v12, v13, v14, v15);
  }
  else
  {
    LogObj(4);
    BOOL v6 = (NSURL *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(&v6->super, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)TPropertyValue buf = 0;
      _os_log_impl(&dword_1D343E000, &v6->super, OS_LOG_TYPE_ERROR, "No iCloud container because no domain storageURL", buf, 2u);
    }
    BOOL v10 = 0;
  }

  return v10;
}

void sub_1D347DB90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IsDatalessDomain(NSURL *a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a1;
  CFStringRef v3 = (const __CFString *)*MEMORY[0x1E4F1CDC8];
  if ((TCFURLInfo::GetNumericalProperty((const __CFURL *)v20, (const __CFString *)*MEMORY[0x1E4F1CDC8], v4) & 0x40000000) != 0)
  {
    BOOL v6 = LogObj(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = SanitizedURL(v20);
      *(_DWORD *)TPropertyValue buf = 138543362;
      BOOL v22 = v7;
      _os_log_impl(&dword_1D343E000, v6, OS_LOG_TYPE_DEFAULT, "Root of domain is dataless %{public}@", buf, 0xCu);
    }
    if (!a2)
    {
      uint64_t v5 = 1;
      goto LABEL_20;
    }
    unint64_t v8 = LogObj(4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v9 = SanitizedURL(v20);
      *(_DWORD *)TPropertyValue buf = 138543362;
      BOOL v22 = v9;
      _os_log_impl(&dword_1D343E000, v8, OS_LOG_TYPE_DEFAULT, "Forcing materialization of domain %{public}@", buf, 0xCu);
    }
    id v10 = objc_alloc_init(MEMORY[0x1E4F28CA0]);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3321888768;
    v18[2] = ___Z16IsDatalessDomainP5NSURLb_block_invoke;
    v18[3] = &__block_descriptor_40_ea8_32c37_ZTSKZ16IsDatalessDomainP5NSURLbE3__0_e15_v16__0__NSURL_8l;
    v18[4] = &v20;
    id v19 = 0;
    [v10 coordinateReadingItemAtURL:v20 options:1 error:&v19 byAccessor:v18];
    id v12 = v19;
    if (v12)
    {
      uint64_t v13 = LogObj(4);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        BOOL v14 = SanitizedURL(v20);
        *(_DWORD *)TPropertyValue buf = 138543618;
        BOOL v22 = v14;
        __int16 v23 = 2114;
        id v24 = v12;
        _os_log_impl(&dword_1D343E000, v13, OS_LOG_TYPE_ERROR, "Failed to materialize domain root %{public}@ with error: %{public}@", buf, 0x16u);
      }
    }
    else
    {
      if ((TCFURLInfo::GetNumericalProperty((const __CFURL *)v20, v3, v11) & 0x40000000) == 0)
      {
        uint64_t v13 = LogObj(4);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v15 = SanitizedURL(v20);
          *(_DWORD *)TPropertyValue buf = 138543362;
          BOOL v22 = v15;
          _os_log_impl(&dword_1D343E000, v13, OS_LOG_TYPE_DEFAULT, "Materialized domain %{public}@", buf, 0xCu);
        }
        uint64_t v5 = 0;
        goto LABEL_19;
      }
      uint64_t v13 = LogObj(4);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v16 = SanitizedURL(v20);
        *(_DWORD *)TPropertyValue buf = 138543362;
        BOOL v22 = v16;
        _os_log_impl(&dword_1D343E000, v13, OS_LOG_TYPE_DEFAULT, "Failed to materialize domain %{public}@ without error", buf, 0xCu);
      }
    }
    uint64_t v5 = 1;
LABEL_19:

    goto LABEL_20;
  }
  uint64_t v5 = 0;
LABEL_20:

  return v5;
}

void sub_1D347DF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1D347E048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D347E0E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D347E15C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id TGlobalNodes::iCloudLibrariesContainerNode@<X0>(void *a1@<X8>)
{
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  uint64_t v3 = TGlobalNodes::gGlobalNodes;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN12TGlobalNodes28iCloudLibrariesContainerNodeEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = TGlobalNodes::gGlobalNodes;
  if (TGlobalNodes::iCloudLibrariesContainerNode(void)::onceToken != -1) {
    dispatch_once(&TGlobalNodes::iCloudLibrariesContainerNode(void)::onceToken, block);
  }
  id result = *(id *)(v3 + 80);
  *a1 = result;
  return result;
}

void ___ZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptions_block_invoke(uint64_t a1)
{
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3321888768;
  v9[2] = ___ZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEv_block_invoke;
  void v9[3] = &__block_descriptor_72_ea8_32c127_ZTSKZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEvEUlvE__e5_v8__0l;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v4 = *(id *)(a1 + 56);
  id v5 = *(id *)(a1 + 48);
  unint64_t v6 = *(unsigned __int8 *)(a1 + 64) | ((unint64_t)*(unsigned int *)(a1 + 68) << 32);
  v9[4] = v3;
  id v10 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v7 = v4;
  id v11 = v7;
  id v8 = v5;
  id v12 = v8;
  unint64_t v13 = v6;
  ExceptionSafeBlock(v9);

  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
}

void sub_1D347E3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, void *a16, void *a17)
{
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }

  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  _Unwind_Resume(a1);
}

void __NodeContextOpen_block_invoke()
{
  SecTaskRef v0 = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZZ15NodeContextOpenENK3__2clEv_block_invoke;
  block[3] = &__block_descriptor_33_ea8_32c41_ZTSKZZ15NodeContextOpenENK3__2clEvEUlvE__e5_v8__0l;
  dispatch_async(v0, block);

  TCFURLInfo::Initialize((TCFURLInfo *)+[FIDSNode registerClassForFIDSNodeCoding:@"FI Local Storage"]);
  TFSVolumeInfo::SetFullEnvironment(v1);
  uint64_t v3 = (TDSNotifier *)TFSInfo::MarkAsUsed(v2);
  TClientChangeNotifier::ValidateNotifierList(v3);
  TFSInfo::Validate(v4);
  TSystemNotificationTask::MakeNotificationQueue(v5);
  TSystemNotificationTask::MakeStreamQueue(v6);
  TNode::Initialize(v7);
}

void TFSInfo::Validate(TFSInfo *this)
{
  uint64_t v1 = (os_unfair_lock_s *)TFSInfo::NetworkLock(this);
  os_unfair_lock_lock(v1);
  if (__PAIR128__(TFSInfo::gAirDropBrowserRef, TFSInfo::gNetworkNearbyBrowserRef) != 0) {
    abort();
  }
  os_unfair_lock_unlock(v1);
}

void sub_1D347E4FC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

int *TFSInfo::NetworkLock(TFSInfo *this)
{
  {
    TFSInfo::NetworkLock(void)::gNetworkLocuint64_t k = 0;
  }
  return &TFSInfo::NetworkLock(void)::gNetworkLock;
}

void TNode::Initialize(TNode *this)
{
  TGlobalNodes::RootNode((uint64_t *)&v6);

  TGlobalNodes::BootNode(&v5, v1);
  uint64_t v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v3 = dispatch_queue_create("FPItemFromMain", v2);
  id v4 = (void *)sFPItemsFetchingFromMainQueue;
  sFPItemsFetchingFromMainQueue = (uint64_t)v3;
}

void TSystemNotificationTask::MakeNotificationQueue(TSystemNotificationTask *this)
{
  dispatch_queue_t v1 = dispatch_queue_create("TSystemNotificationTask", 0);
  uint64_t v2 = (void *)gSystemNotificationGCDQueue;
  gSystemNotificationGCDQueue = (uint64_t)v1;
}

void TSystemNotificationTask::MakeStreamQueue(TSystemNotificationTask *this)
{
  dispatch_queue_t v1 = dispatch_queue_create("TSystemNotificationStreamTask", 0);
  uint64_t v2 = (void *)gSystemNotificationStreamGCDQueue;
  gSystemNotificationStreamGCDQueue = (uint64_t)v1;
}

void TClientChangeNotifier::ValidateNotifierList(TDSNotifier *this)
{
  RegistrationLocuint64_t k = (TDSMutex *)TDSNotifier::GetRegistrationLock(this);
  TDSMutex::lock(RegistrationLock);
  if (TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList != qword_1EA6AC3B0) {
    abort();
  }
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&v2);
}

void sub_1D347E6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void TFSVolumeInfo::SetFullEnvironment(TFSVolumeInfo *this)
{
  TFSVolumeInfo::gFullEnvironment = 1;
}

void TCFURLInfo::Initialize(TCFURLInfo *this)
{
  TCFURLInfo::gShowAllExtensions = 0;
  TCFURLInfo::gRootlessEnabled = 0;
  TCFURLInfo::gHasUnifiedVolumeGroup = 0;
  TCFURLInfo::gROSPState = 0;
}

void sub_1D347E7D4(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void TNode::ProviderNodeForProviderDomain(void *a1@<X0>, int a2@<W1>, void **a3@<X8>)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  {
    TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuard = 0u;
    *(_OWORD *)algn_1EA6AC2B0 = 0u;
    dword_1EA6AC2C0 = 1065353216;
  }
  id v6 = [v5 identifier];
  TNode::ProviderNodeForProviderDomainID(v6, a3);

  uint64_t v7 = TNodeFromFINode((FINode *)*a3);
  if ((a2 & 0x80) == 0 && !v7)
  {
    id v8 = [v5 identifier];
    id location = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&location, v8);

    std::mutex::lock(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuardLock);
    p_id location = (TString **)&location;
    unint64_t v9 = std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuard, (TString *)&location, (uint64_t)&std::piecewise_construct, &p_location);
    p_id location = (TString **)pthread_self();
    std::__hash_table<_opaque_pthread_t *,std::hash<_opaque_pthread_t *>,std::equal_to<_opaque_pthread_t *>,std::allocator<_opaque_pthread_t *>>::__emplace_unique_key_args<_opaque_pthread_t *,_opaque_pthread_t *>((uint64_t)(v9 + 3), &p_location, &p_location);
    LOBYTE(v9) = v10;
    std::mutex::unlock(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuardLock);
    if (v9)
    {
      p_id location = (TString **)&location;
      TGlobalNodes::AllProvidersNode(&v21);
      uint64_t v11 = TNodeFromFINode(v21);
      TNode::HandleSync(v11, 0x100u);

      id v12 = [v5 identifier];
      TNode::ProviderNodeForProviderDomainID(v12, &v21);
      TNodePtr::operator=(a3, (void **)&v21);

      StDefer<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_0,(void *)0>::~StDefer((TString **)&p_location);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&location);
  }
  if (TNodeFromFINode((FINode *)*a3))
  {
    uint64_t v13 = TNodeFromFINode((FINode *)*a3);
    BOOL v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v13);
    os_unfair_lock_lock(v14);
    unint64_t v16 = *(TFSInfo **)(v13 + 16);
    unint64_t v15 = *(std::__shared_weak_count **)(v13 + 24);
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v14);
    id v17 = TFSInfo::GetFPItem(v16);
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }
    if (v17) {
      goto LABEL_19;
    }
    if ([v5 expectFPItems])
    {
      id v17 = [v5 domain];
      if (!v17)
      {
        id v17 = [v5 asyncFetchedDomain];
      }
      objc_initWeak(&location, *a3);
      double v18 = 1000.0;
      if ((a2 & 0x40000) == 0) {
        double v18 = 5.0;
      }
      size_t v21 = *(FINode **)&v18;
      objc_copyWeak(&v19, &location);
      p_p_id location = 0;
      p_id location = (TString **)&unk_1F2AB9848;
      objc_moveWeak(&v24, &v19);
      p_p_id location = &p_location;
      objc_destroyWeak(&v19);
      TNode::RootFPItemForDomainWithTimeout(v17, (double *)&v21, (uint64_t)&p_location, v20);

      std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](&p_location);
      objc_destroyWeak(&location);
LABEL_19:
    }
  }
}

void sub_1D347EB28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id location, char a14)
{
  _Unwind_Resume(a1);
}

void TNode::ProviderNodeForProviderDomainID(TNode *this@<X0>, void *a2@<X8>)
{
  id v4 = this;
  TGlobalNodes::AllProvidersNode(&v16);
  id v5 = (TNode *)TNodeFromFINode(v16);
  TNode::CopyChildren(v5, (uint64_t)&v14);
  id v13 = 0;
  id v6 = v14;
  uint64_t v7 = v15;
  if (v14 == v15) {
    goto LABEL_7;
  }
  while (1)
  {
    id v8 = (TNode *)TNodeFromFINode(*v6);
    unint64_t v9 = TNode::GetFIProvider(v8);
    char v10 = [v9 identifier];
    char v11 = [(TNode *)v4 isEqual:v10];

    if (v11) {
      break;
    }
    if (++v6 == v7)
    {
      id v6 = v7;
      break;
    }
  }
  if (v6 == v15)
  {
LABEL_7:
    char v12 = 0;
    LOBYTE(v17) = 0;
  }
  else
  {
    id v17 = *v6;
    char v12 = 1;
  }
  char v18 = v12;
  std::optional<TNodePtr>::value_or[abi:ne180100]<TNodePtr const&>((uint64_t)&v17, &v13, a2);
  if (v18) {

  }
  id v17 = (FINode *)&v14;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);
}

void sub_1D347ED44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D347EDF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id TGlobalNodes::AllProvidersNode@<X0>(void *a1@<X8>)
{
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  uint64_t v3 = TGlobalNodes::gGlobalNodes;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN12TGlobalNodes16AllProvidersNodeEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  void block[4] = TGlobalNodes::gGlobalNodes;
  if (TGlobalNodes::AllProvidersNode(void)::onceToken != -1) {
    dispatch_once(&TGlobalNodes::AllProvidersNode(void)::onceToken, block);
  }
  id result = *(id *)(v3 + 96);
  *a1 = result;
  return result;
}

void *std::optional<TNodePtr>::value_or[abi:ne180100]<TNodePtr const&>@<X0>(uint64_t a1@<X0>, id *a2@<X1>, void *a3@<X8>)
{
  if (*(unsigned char *)(a1 + 8))
  {
    return TNodePtr::TNodePtr(a3, (id *)a1);
  }
  else
  {
    id result = *a2;
    *a3 = result;
  }
  return result;
}

void sub_1D347EFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  char v10 = v9;

  a9.super_class = (Class)FICustomNode;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1D347F298(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D347F4B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void TFSVolumeInfo::~TFSVolumeInfo(TFSVolumeInfo *this)
{
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  void v6[2] = ___ZN13TFSVolumeInfoD2Ev_block_invoke;
  void v6[3] = &__block_descriptor_33_ea8_32c31_ZTSKZN13TFSVolumeInfoD1EvE3__0_e5_v8__0l;
  dispatch_async(MEMORY[0x1E4F14428], v6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 52);
  if (*((unsigned char *)this + 408)) {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 50);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 49);
  char v2 = (std::__shared_weak_count *)*((void *)this + 45);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 43);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  id v4 = (std::__shared_weak_count *)*((void *)this + 41);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  if (*((unsigned char *)this + 304)) {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 37);
  }
  TDSMutex::~TDSMutex((TDSMutex *)((char *)this + 224));
  if (*((unsigned char *)this + 216))
  {
    uint64_t v7 = (void **)((char *)this + 192);
    std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&v7);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 10);
  id v5 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)this + 5);
  if (*((unsigned char *)this + 32))
  {
    if (*((char *)this + 23) < 0) {
      operator delete(*(void **)this);
    }
  }
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,TFSInfo&,void>@<X0>(const TFSInfo *a1@<X1>, void *a2@<X8>)
{
  id v4 = (char *)operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<TFSInfo&,std::allocator<TFSInfo>,0>((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_1D347F66C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<TFSInfo&,std::allocator<TFSInfo>,0>(uint64_t a1, const TFSInfo *a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), a2);
  return a1;
}

void sub_1D347F6C8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void TFSInfo::TFSInfo(TFSInfo *this, const TFSInfo *a2)
{
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  id v4 = (CFTypeRef *)((char *)this + 16);
  TFSInfo::TFSInfo(this);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 24);
  *((unsigned char *)this + 112) = *((unsigned char *)a2 + 112);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(v4, *((CFTypeRef *)a2 + 2));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)this + 1, *((CFTypeRef *)a2 + 1));
  if (this == a2)
  {
    objc_storeStrong((id *)this + 5, *((id *)a2 + 5));
  }
  else
  {
    TString::SetStringRefAsImmutable((TString *)this + 3, *((TString **)a2 + 3));
    TString::SetStringRefAsImmutable((TString *)this + 4, *((TString **)a2 + 4));
    objc_storeStrong((id *)this + 5, *((id *)a2 + 5));
    TString::SetStringRefAsImmutable((TString *)this + 6, *((TString **)a2 + 6));
  }
  objc_storeStrong((id *)this + 8, *((id *)a2 + 8));
  objc_storeStrong((id *)this + 9, *((id *)a2 + 9));
  if (*((void *)a2 + 10)) {
    operator new();
  }
  objc_storeStrong((id *)this + 7, *((id *)a2 + 7));
  *((unsigned char *)this + 114) = *((unsigned char *)a2 + 114);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v5 = *(_DWORD *)((char *)a2 + 115) & 0x20;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v6 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFDF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFDF | v5;
  *(_WORD *)((char *)this + 119) = WORD2(v6);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v7 = *(_DWORD *)((char *)a2 + 115) & 0x400;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v8 = *(_DWORD *)((char *)this + 115) & 0xFFFFFBFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFBFF | v7;
  *(_WORD *)((char *)this + 119) = WORD2(v8);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v9 = *(_DWORD *)((char *)a2 + 115) & 0x40;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v10 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFBF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFBF | v9;
  *(_WORD *)((char *)this + 119) = WORD2(v10);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v11 = *(_DWORD *)((char *)a2 + 115) & 2;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v12 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | v11;
  *(_WORD *)((char *)this + 119) = WORD2(v12);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v13 = *(_DWORD *)((char *)a2 + 115) & 4;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v14 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | v13;
  *(_WORD *)((char *)this + 119) = WORD2(v14);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v15 = *(_DWORD *)((char *)a2 + 115) & 0x80;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v16 = *(_DWORD *)((char *)this + 115) & 0xFFFFFF7F | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFF7F | v15;
  *(_WORD *)((char *)this + 119) = WORD2(v16);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v17 = *(unsigned int *)((char *)a2 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v18 = *(_DWORD *)((char *)this + 115) & 0xFFFEFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32) | (((v17 >> 16) & 1) << 16);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFEFFFF | (((v17 >> 16) & 1) << 16);
  *(_DWORD *)((char *)this + 115) = v18 & 0xFFFFFFFE | *(_DWORD *)((char *)a2 + 115) & 1;
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 8;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v19 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFF7 | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFF7 | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v19);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x100;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v20 = *(_DWORD *)((char *)this + 115) & 0xFFFFFEFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFEFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v20);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x200;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v21 = *(_DWORD *)((char *)this + 115) & 0xFFFFFDFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFDFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v21);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x800;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v22 = *(_DWORD *)((char *)this + 115) & 0xFFFFF7FF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFF7FF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v22);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x1000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v23 = *(_DWORD *)((char *)this + 115) & 0xFFFFEFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFEFFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v23);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x2000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v24 = *(_DWORD *)((char *)this + 115) & 0xFFFFDFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFDFFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v24);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x4000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v25 = *(_DWORD *)((char *)this + 115) & 0xFFFFBFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFBFFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v25);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x100000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v26 = *(_DWORD *)((char *)this + 115) & 0xFFEFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFEFFFFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v26);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x200000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v27 = *(_DWORD *)((char *)this + 115) & 0xFFDFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFDFFFFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v27);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x400000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v28 = *(_DWORD *)((char *)this + 115) & 0xFFBFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFBFFFFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v28);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x800000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v29 = *(_DWORD *)((char *)this + 115) & 0xFF7FFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFF7FFFFF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v29);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v17) = *(_DWORD *)((char *)a2 + 115) & 0x10;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v30 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFEF | v17;
  *(_WORD *)((char *)this + 119) = WORD2(v30);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v31 = (unint64_t)*(unsigned __int16 *)((char *)a2 + 119) >> 11;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v32 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFF7FFFFFFFFFFLL | ((v31 & 1) << 43);
  *(_WORD *)((char *)this + 119) = WORD2(v32);
  *(_WORD *)((char *)this + 119) = (v32 & 0xFFFFEFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x100000000000) >> 32;
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v31) = *(_DWORD *)((char *)a2 + 115) & 0x8000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v33 = *(_DWORD *)((char *)this + 115) & 0xFFFF7FFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFF7FFF | v31;
  *(_WORD *)((char *)this + 119) = WORD2(v33);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v31) = *(_DWORD *)((char *)a2 + 115) & 0x1000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v34 = *(_DWORD *)((char *)this + 115) & 0xFEFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFEFFFFFF | v31;
  *(_WORD *)((char *)this + 119) = WORD2(v34);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v31) = *(_DWORD *)((char *)a2 + 115) & 0x2000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v35 = *(_DWORD *)((char *)this + 115) & 0xFDFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFDFFFFFF | v31;
  *(_WORD *)((char *)this + 119) = WORD2(v35);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v36 = *(unsigned int *)((char *)a2 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v37 = *(_DWORD *)((char *)this + 115) & 0xFBFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32) | (((v36 >> 26) & 1) << 26);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFBFFFFFF | (((v36 >> 26) & 1) << 26);
  if (*(void *)a2) {
    operator new();
  }
  unint64_t v38 = v37 & 0xFFFFFFFBFFFFFFFFLL | ((((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) >> 2) & 1) << 34);
  *(_DWORD *)((char *)this + 115) = v37;
  *(_WORD *)((char *)this + 119) = WORD2(v38);
  unint64_t v39 = v38 & 0xFFFFFF7FFFFFFFFFLL | ((((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) >> 7) & 1) << 39);
  *(_DWORD *)((char *)this + 115) = v37;
  *(_WORD *)((char *)this + 119) = WORD2(v39);
  unint64_t v40 = v39 & 0xFEFFFFFFFFFFLL | ((((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) >> 8) & 1) << 40);
  *(_DWORD *)((char *)this + 115) = v37;
  *(_WORD *)((char *)this + 119) = WORD2(v40);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v41 = *(_DWORD *)((char *)a2 + 115) & 0x20000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v42 = *(_DWORD *)((char *)this + 115) & 0xFFFDFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFDFFFF | v41;
  *(_WORD *)((char *)this + 119) = WORD2(v42);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v43 = *(_DWORD *)((char *)a2 + 115) & 0x8000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v44 = *(_DWORD *)((char *)this + 115) & 0xF7FFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xF7FFFFFF | v43;
  *(_WORD *)((char *)this + 119) = WORD2(v44);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v45 = *(_DWORD *)((char *)a2 + 115) & 0x10000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v46 = *(_DWORD *)((char *)this + 115) & 0xEFFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xEFFFFFFF | v45;
  *(_WORD *)((char *)this + 119) = WORD2(v46);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v47 = *(_DWORD *)((char *)a2 + 115) & 0x20000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v48 = *(_DWORD *)((char *)this + 115) & 0xDFFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xDFFFFFFF | v47;
  *(_WORD *)((char *)this + 119) = WORD2(v48);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  int v49 = *(_DWORD *)((char *)a2 + 115) & 0x40000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v50 = *(_DWORD *)((char *)this + 115) & 0xBFFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xBFFFFFFF | v49;
  *(_WORD *)((char *)this + 119) = WORD2(v50);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unsigned int v51 = *(_DWORD *)((char *)a2 + 115) & 0x80000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v52 = *(_DWORD *)((char *)this + 115) & 0x7FFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0x7FFFFFFF | v51;
  *(_WORD *)((char *)this + 119) = WORD2(v52);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  uint64_t v53 = (*(_WORD *)((char *)a2 + 119) & 1) << 32;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v54 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFFEFFFFFFFFLL | v53;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v54);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v55 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x200000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v56 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFFDFFFFFFFFLL | v55;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v56);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v57 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x800000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v58 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFF7FFFFFFFFLL | v57;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v58);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v59 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x1000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v60 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFEFFFFFFFFFLL | v59;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v60);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v59) = *(_DWORD *)((char *)a2 + 115) & 0x40000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v61 = *(_DWORD *)((char *)this + 115) & 0xFFFBFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFBFFFF | v59;
  *(_WORD *)((char *)this + 119) = WORD2(v61);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  LODWORD(v59) = *(_DWORD *)((char *)a2 + 115) & 0x80000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v62 = *(_DWORD *)((char *)this + 115) & 0xFFF7FFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFF7FFFF | v59;
  *(_WORD *)((char *)this + 119) = WORD2(v62);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v63 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x2000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v64 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFDFFFFFFFFFLL | v63;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v64);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v65 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x4000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v66 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFFBFFFFFFFFFLL | v65;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v66);
  *((void *)this + 13) = *((void *)a2 + 13);
  *((unsigned char *)this + 113) = *((unsigned char *)a2 + 113);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v67 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x20000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v68 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFDFFFFFFFFFFLL | v67;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v68);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 25);
  unint64_t v69 = ((unint64_t)*(unsigned __int16 *)((char *)a2 + 119) << 32) & 0x40000000000;
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 25);
  unint64_t v70 = (*(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32)) & 0xFFFFFBFFFFFFFFFFLL | v69;
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115);
  *(_WORD *)((char *)this + 119) = WORD2(v70);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)this + 11, *((CFTypeRef *)a2 + 11));
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 24);
}

void sub_1D34801CC(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v3, 0x60C40902580DDLL);
  os_unfair_lock_unlock(v2);
  TFSInfo::~TFSInfo(v1);
  _Unwind_Resume(a1);
}

void ___ZN7TFSInfo14LSPropertyKeysEv_block_invoke()
{
  TFSInfo::LSPropertyKeys(void)::LSPropertyKeys = (uint64_t)CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E4F1D718]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E4F1D670]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E4F1D6A0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E4F1CD78]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys, (const void *)*MEMORY[0x1E4F1CD58]);
  SecTaskRef v0 = (__CFArray *)TFSInfo::LSPropertyKeys(void)::LSPropertyKeys;
  dispatch_queue_t v1 = (const void *)*MEMORY[0x1E4F1CD50];
  CFArrayAppendValue(v0, v1);
}

const void **ROSPVolumeID::BootVolumeID(void)::$_0::operator()()
{
  TCFURLInfo::BootURL(&v3);
  CFTypeRef VolumeIdentifier = TCFURLInfo::GetVolumeIdentifier(v3, v0);
  uint64_t result = TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v3);
  ROSPVolumeID::BootVolumeID(void)::sBootDeviceID = (uint64_t)VolumeIdentifier;
  if (VolumeIdentifier) {
    return (const void **)CFRetain(VolumeIdentifier);
  }
  return result;
}

void sub_1D3480338(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void ___ZN12TGlobalNodes8BootNodeEv_block_invoke(uint64_t a1)
{
  uint64_t v12 = 0;
  int v13 = 0;
  TCFURLInfo::BootURL(&v7);
  int v2 = TFSVolumeInfo::AddVolume(v7, 0, &v12);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v7);
  uint64_t v3 = 0;
  int v11 = 0;
  if (!v2)
  {
    TNodePtr::TNodePtr(&v9, 0);
    id v4 = *(std::__shared_weak_count **)(v12 + 64);
    int v7 = *(TCFURLInfo **)(v12 + 56);
    unint64_t v8 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    TNode::CreateNode(&v10, &v9, &v7, &v5);
    TNodePtr::operator=(&v11, &v10);

    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }

    **(unsigned char **)(a1 + 40) = 1;
    uint64_t v3 = v11;
  }
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 8), v3);

  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
}

void sub_1D348044C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13, void *a14)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }

  unint64_t v16 = *(std::__shared_weak_count **)(v14 - 24);
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  _Unwind_Resume(a1);
}

CFTypeRef TCFURLInfo::BootURL@<X0>(void *a1@<X8>)
{
  {
    TCFURLInfo::BootURL(void)::$_0::operator()();
  }
  CFTypeRef result = (CFTypeRef)TCFURLInfo::BootURL(void)::rootURL;
  *a1 = TCFURLInfo::BootURL(void)::rootURL;
  if (result)
  {
    return CFRetain(result);
  }
  return result;
}

void sub_1D3480520(_Unwind_Exception *a1)
{
}

const void **TCFURLInfo::BootURL(void)::$_0::operator()()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  CFErrorRef error = 0;
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  TCFURLInfo::BootURL(void)::rootCFURLRef URL = (uint64_t)CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"/", kCFURLPOSIXPathStyle, 1u);
  CFURLRef v1 = CFURLCreateFileReferenceURL(v0, (CFURLRef)TCFURLInfo::BootURL(void)::rootURL, &error);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&TCFURLInfo::BootURL(void)::rootURL, v1);
  if (error)
  {
    int v2 = LogObj(5);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = error;
      *(_DWORD *)TPropertyValue buf = 138543362;
      int v7 = v3;
      _os_log_impl(&dword_1D343E000, v2, OS_LOG_TYPE_ERROR, "Failed to get root URL. %{public}@", buf, 0xCu);
    }
  }
  return TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
}

void sub_1D348064C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&TCFURLInfo::BootURL(void)::rootURL);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

void ___ZN13TFSVolumeInfo20GetDedicatedGCDQueueE17FSInfoVirtualType_block_invoke()
{
  dispatch_queue_t v0 = dispatch_queue_create("NetworkNearbyQueue", 0);
  CFURLRef v1 = (void *)TFSVolumeInfo::gNetworkNearbyQueue;
  TFSVolumeInfo::gNetworkNearbyQueue = (uint64_t)v0;

  dispatch_queue_t v2 = dispatch_queue_create("AirDropQueue", 0);
  uint64_t v3 = (void *)TFSVolumeInfo::gAirDropQueue;
  TFSVolumeInfo::gAirDropQueue = (uint64_t)v2;

  dispatch_queue_t v4 = dispatch_queue_create("TagsSharedListQueue", 0);
  uint64_t v5 = (void *)TFSVolumeInfo::gTagsSharedListQueue;
  TFSVolumeInfo::gTagsSharedListQueue = (uint64_t)v4;

  dispatch_queue_t v6 = dispatch_queue_create("Cloud Containers", 0);
  int v7 = (void *)TFSVolumeInfo::gAllCloudLibsQueue;
  TFSVolumeInfo::gAllCloudLibsQueue = (uint64_t)v6;

  dispatch_queue_t v8 = dispatch_queue_create("FPitems", 0);
  TNodePtr v9 = (void *)TFSVolumeInfo::gFPItemQueue;
  TFSVolumeInfo::gFPItemQueue = (uint64_t)v8;
}

uint64_t TNode::FollowAlias(TNode *this, uint64_t a2)
{
  if ((a2 & 0x20000) != 0 && TNode::IsInTrash(this))
  {
    uint64_t NodeFromFSInfo = 4294959232;
LABEL_22:
    TNode::ClearAliasTarget(this, 1);
    return NodeFromFSInfo;
  }
  if (TNode::ResolveFPProvider(this))
  {
    TNode::GetAliasTarget(this, &v13);
    uint64_t v5 = v13;
    if (TNodeFromFINode(v13)) {
      uint64_t NodeFromFSInfo = 0;
    }
    else {
      uint64_t NodeFromFSInfo = 4294959232;
    }
  }
  else
  {
    dispatch_queue_t v6 = (TNode *)_ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v13);
    int v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
    os_unfair_lock_lock(v7);
    uint64_t v9 = *((void *)this + 2);
    dispatch_queue_t v8 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v7);
    uint64_t NodeFromFSInfo = TFSInfo::FollowAlias(v9, a2, (uint64_t *)&v13);
    v12.fFINode = 0;
    if (!NodeFromFSInfo)
    {
      uint64_t NodeFromFSInfo = TNode::GetNodeFromFSInfo((TFSInfo **)&v13, (void **)&v12.fFINode);
      if (!NodeFromFSInfo)
      {
        if ((a2 & 0x20000) != 0 && (unint64_t v10 = (TNode *)TNodeFromFINode(v12.fFINode), TNode::IsInTrash(v10)))
        {
          uint64_t NodeFromFSInfo = 4294959232;
        }
        else
        {
          TNode::SetAliasTarget(this, &v12, 1);
          uint64_t NodeFromFSInfo = 0;
        }
      }
    }

    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
    if (NodeFromFSInfo) {
      goto LABEL_22;
    }
  }
  return NodeFromFSInfo;
}

void sub_1D3480890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(a1);
}

void TNode::~TNode(TNode *this, const TNode *a2)
{
  uint64_t v3 = *((void *)this + 2);
  dispatch_queue_t v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v3)
  {
    uint64_t v5 = (void (*)(uint64_t, void))sReleaseCustomNodeCallback;
    if (sReleaseCustomNodeCallback && *((void *)this + 8))
    {
      uint64_t v6 = TNode::AsNodeRef(this, a2);
      v5(v6, *((void *)this + 8));
    }
    TNodePtr::TNodePtr(&v12, 0);
    TNode::SetAliasTarget(this, &v12, 0);

    TNodePtr::TNodePtr(&v12, this);
    TProgressMap::RemoveSubscriberForExternalProgress(&v12, v7);
  }
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v8 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v8) {
    std::default_delete<TNotifierList>::operator()[abi:ne180100]((uint64_t)this + 72, v8);
  }
  std::unique_ptr<TChildrenList>::reset[abi:ne180100]((TChildrenList **)this + 7, 0);
  uint64_t v9 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v9) {
    MEMORY[0x1D9436740](v9, 0x1020C40A5B76CDFLL);
  }

  unint64_t v10 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  int v11 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
}

void TNode::SetAliasTarget(TNode *this, const TNodePtr *a2, int a3)
{
  uint64_t v6 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v6);
  uint64_t v8 = (TFSInfo *)*((void *)this + 2);
  int v7 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v6);
  BOOL IsAlias = TFSInfo::IsAlias(v8);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  if (IsAlias)
  {
    TNode::GetAliasTarget(this, &v62);
    uint64_t v10 = TNodeFromFINode(v62);
    if (v10 != TNodeFromFINode(a2->fFINode))
    {
      int v11 = (TNode *)TNodeFromFINode(v62);
      if (v11)
      {
        TNodePtr v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
        os_unfair_lock_lock(v12);
        uint64_t v14 = *((void *)this + 2);
        int v13 = (std::__shared_weak_count *)*((void *)this + 3);
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v12);
          int v15 = *(unsigned __int8 *)(v14 + 112);
          std::__shared_weak_count::__release_shared[abi:ne180100](v13);
        }
        else
        {
          os_unfair_lock_unlock(v12);
          int v15 = *(unsigned __int8 *)(v14 + 112);
        }
        if (v15 != 7)
        {
          unint64_t v16 = (TNodeEvent *)TNodeFromFINode(v62);
          TNodePtr::TNodePtr(&v61, this);
          TNode::UnRegisterForInternalNotifications(v16, &v61.fFINode, 1);
        }
        TNode::GetAliasTarget(this, &v61);
        TNodePtr::operator=((void **)&v62, (void **)&v61.fFINode);
      }
      unint64_t v17 = (os_unfair_lock_s *)TNode::InfoLock(v11);
      os_unfair_lock_lock(v17);
      objc_storeStrong((id *)this + 4, a2->fFINode);
      os_unfair_lock_unlock(v17);
      if (TNodeFromFINode(v62))
      {
        uint64_t v18 = TNodeFromFINode(v62);
        unint64_t v19 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v18);
        os_unfair_lock_lock(v19);
        uint64_t v21 = *(void *)(v18 + 16);
        unint64_t v20 = *(std::__shared_weak_count **)(v18 + 24);
        if (v20)
        {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v19);
          int v22 = *(unsigned __int8 *)(v21 + 112);
          std::__shared_weak_count::__release_shared[abi:ne180100](v20);
        }
        else
        {
          os_unfair_lock_unlock(v19);
          int v22 = *(unsigned __int8 *)(v21 + 112);
        }
        if (v22 == 16)
        {
          unint64_t v23 = (TNode *)TNodeFromFINode(v62);
          TNode::RemoveSelf(v23, 0);
        }
      }
      unint64_t v24 = (TNode *)TNodeFromFINode(a2->fFINode);
      if (v24)
      {
        unint64_t v25 = (os_unfair_lock_s *)TNode::InfoLock(v24);
        os_unfair_lock_lock(v25);
        uint64_t v27 = *((void *)this + 2);
        unint64_t v26 = (std::__shared_weak_count *)*((void *)this + 3);
        if (v26) {
          atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v25);
        uint64_t v28 = TNodeFromFINode(a2->fFINode);
        unint64_t v29 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v28);
        os_unfair_lock_lock(v29);
        uint64_t v31 = *(void *)(v28 + 16);
        unint64_t v30 = *(std::__shared_weak_count **)(v28 + 24);
        if (v30) {
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v29);
        unint64_t v32 = (os_unfair_lock_s *)(v31 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v31 + 100));
        int v33 = *(_DWORD *)(v31 + 115);
        os_unfair_lock_unlock(v32);
        if (v30) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v30);
        }
        unint64_t v34 = (os_unfair_lock_s *)(v27 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v27 + 100));
        int v36 = *(_DWORD *)(v27 + 115);
        uint64_t v35 = v27 + 115;
        unint64_t v37 = v36 & 0xFFFDFFFF | ((unint64_t)*(unsigned __int16 *)(v35 + 4) << 32);
        *(_DWORD *)uint64_t v35 = v36 & 0xFFFDFFFF | (v33 << 12) & 0x20000;
        *(_WORD *)(v35 + 4) = WORD2(v37);
        os_unfair_lock_unlock(v34);
        if (v26) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v26);
        }
        unint64_t v39 = (os_unfair_lock_s *)TNode::InfoLock(v38);
        os_unfair_lock_lock(v39);
        uint64_t v41 = *((void *)this + 2);
        unint64_t v40 = (std::__shared_weak_count *)*((void *)this + 3);
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v39);
        uint64_t v42 = TNodeFromFINode(a2->fFINode);
        IsDeferredForSymlinuint64_t k = TNode::IsDeferredForSymlink(v42, (uint64_t (*)(void *))TFSInfo::IsPackage, 0);
        unint64_t v44 = (os_unfair_lock_s *)(v41 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v41 + 100));
        unsigned int v46 = *(_DWORD *)(v41 + 115);
        uint64_t v45 = v41 + 115;
        unint64_t v47 = v46 | ((unint64_t)*(unsigned __int16 *)(v45 + 4) << 32);
        int v48 = 2;
        if (!IsDeferredForSymlink) {
          int v48 = 0;
        }
        unint64_t v49 = v47 & 0xFFFFFFFFFFFFFFFDLL;
        *(_DWORD *)uint64_t v45 = v49 | v48;
        *(_WORD *)(v45 + 4) = WORD2(v49);
        os_unfair_lock_unlock(v44);
        if (v40) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v40);
        }
        unsigned int v51 = (os_unfair_lock_s *)TNode::InfoLock(v50);
        os_unfair_lock_lock(v51);
        uint64_t v53 = *((void *)this + 2);
        unint64_t v52 = (std::__shared_weak_count *)*((void *)this + 3);
        if (v52)
        {
          atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v51);
          int v54 = *(unsigned __int8 *)(v53 + 112);
          std::__shared_weak_count::__release_shared[abi:ne180100](v52);
        }
        else
        {
          os_unfair_lock_unlock(v51);
          int v54 = *(unsigned __int8 *)(v53 + 112);
        }
        if (v54 != 7)
        {
          unint64_t v55 = (TNodeEvent *)TNodeFromFINode(a2->fFINode);
          TNodePtr::TNodePtr(&v61, this);
          TNode::RegisterForInternalNotifications(v55, &v61.fFINode, 1);
        }
      }
      if (a3)
      {
        if (!TNodeFromFINode(a2->fFINode)) {
          goto LABEL_46;
        }
        uint64_t v56 = TNodeFromFINode(a2->fFINode);
        unint64_t v57 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v56);
        os_unfair_lock_lock(v57);
        uint64_t v59 = *(void *)(v56 + 16);
        unint64_t v58 = *(std::__shared_weak_count **)(v56 + 24);
        if (v58)
        {
          atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v57);
          int v60 = *(unsigned __int8 *)(v59 + 112);
          std::__shared_weak_count::__release_shared[abi:ne180100](v58);
        }
        else
        {
          os_unfair_lock_unlock(v57);
          int v60 = *(unsigned __int8 *)(v59 + 112);
        }
        if (v60 != 16)
        {
LABEL_46:
          TNodePtr::TNodePtr(&v61, this);
          TNode::SendNotification(this, 2, (id *)&v61.fFINode, 1634497639, 0);
        }
      }
    }
  }
}

void sub_1D3480E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::FollowAlias(TNode *this, TNodePtr *a2, TNodeRequest **a3, uint64_t a4)
{
  int v7 = this;
  int v38 = a4;
  if ((a4 & 0x20000) == 0) {
    goto LABEL_9;
  }
  this = (TNode *)TNode::IsInTrash(this);
  if (!this) {
    goto LABEL_9;
  }
  uint64_t v8 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v8);
  uint64_t v10 = (TFSInfo *)*((void *)v7 + 2);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)v7 + 3);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  this = (TNode *)TFSInfo::IsAlias(v10);
  char v11 = (char)this;
  if (!v9)
  {
    if (this) {
      return 4294959232;
    }
LABEL_9:
    int v13 = (os_unfair_lock_s *)TNode::InfoLock(this);
    os_unfair_lock_lock(v13);
    uint64_t v15 = *((void *)v7 + 2);
    uint64_t v14 = (std::__shared_weak_count *)*((void *)v7 + 3);
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v13);
      int v16 = *(unsigned __int8 *)(v15 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
    else
    {
      os_unfair_lock_unlock(v13);
      int v16 = *(unsigned __int8 *)(v15 + 112);
    }
    if (v16 == 1)
    {
      TGlobalNodes::RootNode(&v36.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value, v17);
      TNodePtr::operator=((void **)&a2->fFINode, (void **)&v36);

      TNode::SetAliasTarget(v7, a2, 1);
      return 0;
    }
    uint64_t v18 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v17);
    os_unfair_lock_lock(v18);
    unint64_t v20 = (TFSInfo *)*((void *)v7 + 2);
    unint64_t v19 = (std::__shared_weak_count *)*((void *)v7 + 3);
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v18);
    BOOL IsAlias = TFSInfo::IsAlias(v20);
    if (v19) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
    }
    if (!IsAlias)
    {
      TNodePtr::TNodePtr((TNodePtr *)&v36, v7);
      TNodePtr::operator=((void **)&a2->fFINode, (void **)&v36);

      return 0;
    }
    TNode::GetAliasTarget(v7, &obj);
    if (!TNodeFromFINode((FINode *)obj)) {
      goto LABEL_24;
    }
    int v22 = (TNode *)TNodeFromFINode((FINode *)obj);
    if (!TNode::Validate(v22, v23)) {
      goto LABEL_24;
    }
    unint64_t v24 = (TNode *)TNodeFromFINode((FINode *)obj);
    TNode::GetVolumeInfo(v24, &v36);
    int v25 = *(unsigned __int8 *)(v36.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value + 123);
    if (v36.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v36.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer);
    }
    if (!v25)
    {
      TNode::ClearAliasTarget(v7, 0);
      TNodePtr::TNodePtr((TNodePtr *)&v36, 0);
      TNodePtr::operator=(&obj, (void **)&v36);

      if ((a4 & 0x40000) == 0)
      {
LABEL_25:
        BOOL v27 = (int)a4 < 0 || *a3 != 0;
        if ((a4 & 0x40000000) != 0)
        {
          if (TNodeFromFINode((FINode *)obj)) {
            uint64_t v12 = 0;
          }
          else {
            uint64_t v12 = 4294959232;
          }
LABEL_51:
          objc_storeStrong((id *)&a2->fFINode, obj);

          return v12;
        }
        if (!TNodeFromFINode((FINode *)obj)) {
          goto LABEL_44;
        }
LABEL_39:
        uint64_t v28 = TNodeFromFINode((FINode *)obj);
        unint64_t v29 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v28);
        os_unfair_lock_lock(v29);
        uint64_t v31 = *(void *)(v28 + 16);
        unint64_t v30 = *(std::__shared_weak_count **)(v28 + 24);
        if (v30)
        {
          atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v29);
          int v32 = *(unsigned __int8 *)(v31 + 112);
          std::__shared_weak_count::__release_shared[abi:ne180100](v30);
        }
        else
        {
          os_unfair_lock_unlock(v29);
          int v32 = *(unsigned __int8 *)(v31 + 112);
        }
        if (v32 != 16)
        {
          uint64_t v12 = 0;
        }
        else
        {
LABEL_44:
          if (v27)
          {
            int v38 = a4 & 0xFFFBFFFD | 0x40000;
            TNode::SetUnresolvedTarget(v7);
            v36.fData.__impl_.__unsigned int index = 0;
            std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(&v36, &v38);
            int v33 = *a3;
            uint64_t v35 = v33;
            if (v33) {
              TNodeRequest::AddPtrReference(v33);
            }
            TNode::RequestTask((uint64_t)v7, 10, 1920167792, &v36, (uint64_t *)&v35, 0);
            TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef(&v35);
            TPropertyValue::~TPropertyValue(&v36);
            uint64_t v12 = 0;
          }
          else
          {
            uint64_t v12 = TNode::FollowAlias(v7, a4);
          }
          TNode::GetAliasTarget(v7, &v36);
          TNodePtr::operator=(&obj, (void **)&v36);
        }
        goto LABEL_51;
      }
    }
    else
    {
LABEL_24:
      if ((a4 & 0x40000) == 0) {
        goto LABEL_25;
      }
    }
    TNodePtr::TNodePtr((TNodePtr *)&v36, 0);
    TNodePtr::operator=(&obj, (void **)&v36);

    BOOL v27 = 0;
    goto LABEL_39;
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  if ((v11 & 1) == 0) {
    goto LABEL_9;
  }
  return 4294959232;
}

void sub_1D348127C(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13)
{
  _Unwind_Resume(a1);
}

void TNode::GetAliasTarget(TNode *this@<X0>, void *a2@<X8>)
{
  dispatch_queue_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  *a2 = *((id *)this + 4);
  os_unfair_lock_unlock(v4);
}

const void **TProgressMap::RemoveSubscriberForExternalProgress(const TNodePtr *this, const TNodePtr *a2)
{
  uint64_t v3 = (TNode *)TNodeFromFINode(this->fFINode);
  CFTypeRef result = (const void **)TNode::TestAndSetRegisteredForExternalProgress(v3, 0);
  if (result)
  {
    ProgressPathForNode(this, (TString *)&theString);
    if (CFStringGetLength(theString)) {
      TSystemNotificationTask::StopObservingDirectory((TString **)&theString, 0);
    }
    uint64_t v5 = TNodeFromFINode(this->fFINode);
    uint64_t v6 = TChildrenList::NSProgressSubscriber(*(TChildrenList **)(v5 + 56));
    if (v6)
    {
      [MEMORY[0x1E4F28F90] removeSubscriber:v6];
      uint64_t v7 = TNodeFromFINode(this->fFINode);
      TChildrenList::SetNSProgressSubscriber(*(TChildrenList **)(v7 + 56), 0);
    }

    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  return result;
}

void sub_1D34813E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::TestAndSetRegisteredForExternalProgress(TNode *this, int a2)
{
  dispatch_queue_t v2 = (atomic_ushort *)((char *)this + 80);
  if (a2) {
    unsigned int v3 = atomic_fetch_or(v2, 0x200u);
  }
  else {
    unsigned int v3 = atomic_fetch_and(v2, 0xFDFFu);
  }
  return (v3 >> 9) & 1;
}

uint64_t TFSInfo::FollowAlias(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  uint64_t v7 = *(const void **)(a1 + 16);
  char v11 = v7;
  if (v7)
  {
    CFRetain(v7);
    os_unfair_lock_unlock(v6);
    if (*(unsigned char *)(a1 + 112) == 7) {
      CFIndex v8 = TFSInfo::initialize(*a3, (const __CFURL *)v7, 0, 1, 1, 1, 0);
    }
    else {
      CFIndex v8 = TFSInfo::FollowAliasOrSymlinkDeep(a1, a2, a3, 0);
    }
    uint64_t v9 = v8;
  }
  else
  {
    os_unfair_lock_unlock(v6);
    uint64_t v9 = 4294959232;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v11);
  return v9;
}

void sub_1D34814F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::FollowAliasOrSymlinkDeep(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  v63[123] = *(const void **)MEMORY[0x1E4F143B8];
  CFIndex v8 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  uint64_t v9 = *(const void **)(a1 + 16);
  unint64_t v55 = v9;
  if (v9)
  {
    CFRetain(v9);
    os_unfair_lock_unlock(v8);
    if (TFSInfo::IsAlias((TFSInfo *)a1) && !*(unsigned char *)(a1 + 112))
    {
      os_unfair_lock_lock(v8);
      int v10 = *(_DWORD *)(a1 + 115);
      os_unfair_lock_unlock(v8);
      if ((v10 & 0x40) == 0)
      {
        os_unfair_lock_lock(v8);
        CFStringRef v11 = *(const __CFString **)(a1 + 16);
        CFStringRef theString = v11;
        if (v11) {
          CFRetain(v11);
        }
        os_unfair_lock_unlock(v8);
        anCFURLRef URL = 0;
        if ((a2 & 2) != 0) {
          Booleanint Property = TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)(a1 + 8), (const __CFString *)*MEMORY[0x1E4F1D870], v12);
        }
        else {
          Booleanint Property = 1;
        }
        *(void *)__s = 0;
        unint64_t v58 = __s;
        uint64_t v59 = 0x3812000000;
        int v60 = __Block_byref_object_copy_;
        TNodePtr v61 = __Block_byref_object_dispose_;
        unint64_t v62 = "";
        v63[0] = 0;
        if (BooleanProperty)
        {
          os_unfair_lock_lock(v8);
          unint64_t v19 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
          os_unfair_lock_unlock(v8);
          if ((v19 & 0x400000000) != 0
            || (TCFURLInfo::GetNumericalProperty(*(const __CFURL **)(a1 + 8), (const __CFString *)*MEMORY[0x1E4F1CDC8], v20) & 0x40000000) != 0)
          {
            uint64_t v21 = NewFileCoordinator();
            v51[0] = MEMORY[0x1E4F143A8];
            v51[1] = 3221225472;
            v51[2] = ___ZNK7TFSInfo24FollowAliasOrSymlinkDeepE18NodeRequestOptionsRNSt3__110shared_ptrIS_EEi_block_invoke;
            v51[3] = &unk_1E698FF90;
            v51[4] = __s;
            char v52 = BooleanProperty;
            [v21 coordinateReadingItemAtURL:theString options:1 error:0 byAccessor:v51];
          }
          else
          {
            *(void *)TPropertyValue buf = MEMORY[0x1D9435EE0](0, theString, 0);
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)v58 + 6, *(CFTypeRef *)buf);
            TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)buf);
          }
        }
        if (!*((void *)v58 + 6)) {
          goto LABEL_58;
        }
        if ((a2 & 2) != 0)
        {
          int v22 = (const void *)MEMORY[0x1D9435F40](0, *MEMORY[0x1E4F1D870]);
          *(void *)TPropertyValue buf = v22;
          if (v22 && (CFTypeID v23 = CFGetTypeID(v22), v23 == CFBooleanGetTypeID()))
          {
            char v24 = IsEqual(*(const void **)buf, (const void *)*MEMORY[0x1E4F1CFC8]);
            TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)buf);
            if (v24) {
              goto LABEL_58;
            }
          }
          else
          {
            TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)buf);
          }
        }
        if (a2) {
          uint64_t v30 = 0;
        }
        else {
          uint64_t v30 = 768;
        }
        *(void *)TPropertyValue buf = 0;
        LOBYTE(v48) = 0;
        anCFURLRef URL = (CFURLRef)MEMORY[0x1D9435EF0](0, *((void *)v58 + 6), v30, theString, 0, &v48, buf);
        if (anURL) {
          CFIndex v14 = 0;
        }
        else {
          CFIndex v14 = 4294959232;
        }
        if (*(void *)buf)
        {
          CFIndex v14 = TCFURLInfo::TranslateCFError(*(TCFURLInfo **)buf, v31);
          if (v14 == 60)
          {
            TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)buf);
            if (a2)
            {
              CFIndex v14 = 4294967168;
LABEL_59:
              _Block_object_dispose(__s, 8);
              TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v63);
              TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&anURL);
              TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&theString);
              goto LABEL_11;
            }
            goto LABEL_58;
          }
        }
        if (!(_BYTE)v48 || v14)
        {
          TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)buf);
          if (v14 == -128) {
            goto LABEL_59;
          }
          if (v14)
          {
LABEL_58:
            CFIndex v14 = 4294959232;
            goto LABEL_59;
          }
        }
        else
        {
          uint64_t v50 = MEMORY[0x1D9435ED0](0, anURL, 1024, 0, theString, 0);
          MEMORY[0x1D9436000](v50, theString, 0, 0);
          TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)&v50);
          TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)buf);
        }
        if (!anURL) {
          goto LABEL_58;
        }
        int v32 = (TString *)CFURLCopyScheme(anURL);
        uint64_t v50 = (uint64_t)v32;
        *(void *)TPropertyValue buf = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable((TString *)buf, v32);
        LODWORD(v32) = TFSInfo::IsNetworkScheme((TFSInfo *)buf, v33);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
        if (v32)
        {
          if ((a2 & 2) == 0)
          {
            char v49 = 0;
            int v48 = TFSInfo::SFNodeFromURL((uint64_t)anURL, 1, &v49);
            if (v48)
            {
              std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,__SFNode *&,void>(&v49, (uint64_t *)&v48, buf);
              long long v34 = *(_OWORD *)buf;
              *(void *)TPropertyValue buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              uint64_t v35 = (std::__shared_weak_count *)a3[1];
              *(_OWORD *)a3 = v34;
              if (v35)
              {
                std::__shared_weak_count::__release_shared[abi:ne180100](v35);
                if (*(void *)&buf[8]) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
                }
              }
            }
            goto LABEL_73;
          }
          goto LABEL_74;
        }
        unint64_t v44 = (TString *)v50;
        *(void *)TPropertyValue buf = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable((TString *)buf, v44);
        unsigned int v46 = (CFTypeRef *)TFSInfo::FileScheme(v45);
        int v47 = CFEqual(*(CFTypeRef *)buf, *v46);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
        if (!v47)
        {
          CFIndex v14 = 4294967168;
          goto LABEL_76;
        }
        CFIndex v14 = TFSInfo::initialize(*a3, anURL, 0, 1, 1, 1, 0);
        if (!v14)
        {
          if ((a2 & 8) == 0 || !TFSInfo::IsAlias((TFSInfo *)*a3))
          {
LABEL_73:
            CFIndex v14 = 0;
            goto LABEL_76;
          }
          if (a4 > 8)
          {
LABEL_74:
            CFIndex v14 = 4294959232;
            goto LABEL_76;
          }
          CFIndex v14 = TFSInfo::FollowAliasOrSymlinkDeep(a1, a2, a3, (a4 + 1));
        }
LABEL_76:
        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v50);
        goto LABEL_59;
      }
      TFSInfo::Path((TFSInfo *)a1, (CFTypeRef *)&theString);
      if (CFStringGetLength(theString))
      {
        int v16 = (const char *)TString::c_str((TString *)&theString);
        if (realpath_DARWIN_EXTSN(v16, __s))
        {
          CFIndex v17 = strlen(__s);
          CFURLRef v18 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)__s, v17, 1u);
          *(void *)TPropertyValue buf = v18;
          if (v18) {
            CFIndex v14 = TFSInfo::initialize(*a3, v18, 0, 1, 1, 1, 0);
          }
          else {
            CFIndex v14 = 4294959236;
          }
          TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)buf);
        }
        else
        {
          uint64_t v25 = *__error();
          unint64_t v26 = LogObj(4);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            BOOL v27 = SanitizedPath((TString *)&theString);
            uint64_t v28 = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F28798] code:v25 userInfo:0];
            *(_DWORD *)TPropertyValue buf = 138543618;
            *(void *)&uint8_t buf[4] = v27;
            *(_WORD *)&unsigned char buf[12] = 2114;
            *(void *)&buf[14] = v28;
            _os_log_impl(&dword_1D343E000, v26, OS_LOG_TYPE_ERROR, "realpath error: %{public}@: %{public}@", buf, 0x16u);
          }
          if (v25 != 11)
          {
            CFIndex v14 = 4294959236;
            goto LABEL_65;
          }
          NodeEventRefFromNodeEvent((id *)&v55);
          unint64_t v29 = (NSURL *)objc_claimAutoreleasedReturnValue();
          MyFPResolveSymlink(v29, (uint64_t)buf);

          CFIndex v14 = *(unsigned int *)&buf[8];
          if (!*(_DWORD *)&buf[8]) {
            CFIndex v14 = TFSInfo::initialize(*a3, *(const __CFURL **)buf, 0, 1, 1, 1, 0);
          }
        }
        if (!v14)
        {
          uint64_t v36 = *a3;
          unint64_t v37 = (os_unfair_lock_s *)(*a3 + 100);
          os_unfair_lock_lock(v37);
          LODWORD(v36) = *(_DWORD *)(v36 + 115);
          os_unfair_lock_unlock(v37);
          os_unfair_lock_lock(v8);
          int v38 = (v36 << 12) & 0x20000;
LABEL_66:
          int v40 = *(_DWORD *)(a1 + 115);
          unint64_t v39 = (unsigned int *)(a1 + 115);
          unint64_t v41 = v40 & 0xFFFDFFFF | ((unint64_t)*((unsigned __int16 *)v39 + 2) << 32);
          *unint64_t v39 = v40 & 0xFFFDFFFF | v38;
          *((_WORD *)v39 + 2) = WORD2(v41);
          os_unfair_lock_unlock(v8);
          os_unfair_lock_lock(v8);
          uint64_t v42 = *v39;
          unint64_t v43 = (v42 | ((unint64_t)*((unsigned __int16 *)v39 + 2) << 32)) & 0xFFFFFFFDFFFFFFFFLL;
          *unint64_t v39 = v42;
          *((_WORD *)v39 + 2) = WORD2(v43);
          os_unfair_lock_unlock(v8);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
          goto LABEL_11;
        }
      }
      else
      {
        CFIndex v14 = 4294959238;
      }
LABEL_65:
      os_unfair_lock_lock(v8);
      int v38 = 0;
      goto LABEL_66;
    }
  }
  else
  {
    os_unfair_lock_unlock(v8);
  }
  CFIndex v14 = 4294959238;
LABEL_11:
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v55);
  return v14;
}

void sub_1D3481C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, const void *a20,const void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&a12);
  _Block_object_dispose(&a27, 8);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v27);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a19);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a20);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a21);
  _Unwind_Resume(a1);
}

unint64_t TNode::ResolveFPProvider(TNode *this)
{
  dispatch_queue_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  unsigned int v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  unint64_t v5 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 100));
  if ((v5 & 0x8000000000) != 0)
  {
    if (!TNodeFromFINode(*((FINode **)this + 4))) {
      goto LABEL_9;
    }
    uint64_t v6 = TNodeFromFINode(*((FINode **)this + 4));
    uint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v6);
    os_unfair_lock_lock(v7);
    uint64_t v9 = *(void *)(v6 + 16);
    CFIndex v8 = *(std::__shared_weak_count **)(v6 + 24);
    if (v8)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v7);
      int v10 = *(unsigned __int8 *)(v9 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    else
    {
      os_unfair_lock_unlock(v7);
      int v10 = *(unsigned __int8 *)(v9 + 112);
    }
    if (v10 == 16)
    {
LABEL_9:
      TFSInfo::ObjectIdentifier((TFSInfo *)v4, &v21);
      TNode::FPItemNodeFromObjectID((TNode *)&v21, &v20);
      TNode::SetAliasTarget(this, &v20, 1);
      if (TNodeFromFINode(*((FINode **)this + 4)))
      {
        uint64_t v11 = TNodeFromFINode(*((FINode **)this + 4));
        CFStringRef v12 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v11);
        os_unfair_lock_lock(v12);
        uint64_t v14 = *(void *)(v11 + 16);
        int v13 = *(std::__shared_weak_count **)(v11 + 24);
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v12);
          int v15 = *(unsigned __int8 *)(v14 + 112);
          std::__shared_weak_count::__release_shared[abi:ne180100](v13);
        }
        else
        {
          os_unfair_lock_unlock(v12);
          int v15 = *(unsigned __int8 *)(v14 + 112);
        }
        int v16 = v15 != 16;
      }
      else
      {
        int v16 = 0;
      }
      os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
      int v17 = *(_DWORD *)(v4 + 115) & 1;
      os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 100));
      if (v16 != v17)
      {
        TFSInfo::SetIsInvisible((TFSInfo *)v4, v16 ^ 1);
        TNodePtr::TNodePtr(&v19, this);
        TNode::SendNotification(this, 2, (id *)&v19.fFINode, 1987273324, 0);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
    }
  }
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return (v5 >> 39) & 1;
}

void sub_1D3482004(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, ...)
{
  va_start(va, a4);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(a1);
}

void TNode::RegisterForInternalNotifications(TNodeEvent *a1, FINode **a2, uint64_t a3)
{
  TNodeEvent::GetInternalClientNotifier(a1, &v7);
  if (v7)
  {
    TNodePtr::TNodePtr(&v6, (const TNode *)a1);
    TDSNotifier::Register((TDSNotifier *)&v7, &v6.fFINode, a2, a3);
  }
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_1D34820D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(a1);
}

uint64_t TNode::GetNodeFromFSInfo(TFSInfo **a1, void **a2)
{
  TNodePtr::TNodePtr(&v36, 0);
  TNodePtr::operator=(a2, (void **)&v36.fFINode);

  uint64_t v4 = *a1;
  if (*((unsigned char *)*a1 + 112))
  {
    if (*((unsigned char *)*a1 + 112) == 23)
    {
      TGlobalNodes::iCloudLibrariesContainerNode(&v36);
      TNodePtr::operator=(a2, (void **)&v36.fFINode);

      return 0;
    }
    else
    {
      return 4294959238;
    }
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)v4 + 25);
    TNodePtr v6 = (FINode *)*((void *)v4 + 2);
    long long v34 = v6;
    if (v6) {
      CFRetain(v6);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v4 + 25);
    v36.fFINode = v34;
    NodeFromCFURLRef URL = TNode::GetNodeFromURL(&v36, a2, 0);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v34);
    if (TNodeFromFINode((FINode *)*a2) && (TFSInfo::IsLocalVolume(*a1, v7, v8) & 1) == 0)
    {
      uint64_t v9 = TNodeFromFINode((FINode *)*a2);
      int v10 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v9);
      os_unfair_lock_lock(v10);
      TNodePtr::TNodePtr(&v38, *(const TNode **)(v9 + 48));
      os_unfair_lock_unlock(v10);
      while (TNodeFromFINode(v38.fFINode))
      {
        uint64_t v11 = TNodeFromFINode(v38.fFINode);
        CFStringRef v12 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v11);
        os_unfair_lock_lock(v12);
        uint64_t v14 = *(void *)(v11 + 16);
        int v13 = *(std::__shared_weak_count **)(v11 + 24);
        if (v13) {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v12);
        int v15 = (os_unfair_lock_s *)(v14 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v14 + 100));
        int v16 = *(_DWORD *)(v14 + 115);
        os_unfair_lock_unlock(v15);
        if (v13) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v13);
        }
        if ((v16 & 0x100) != 0) {
          break;
        }
        int v17 = (TNode *)TNodeFromFINode(v38.fFINode);
        TNode::GetVolumeInfo(v17, &v36);
        CFURLRef v18 = (TNode *)TNodeFromFINode((FINode *)*a2);
        TNode::GetVolumeInfo(v18, &v34);
        fFINode = v36.fFINode;
        TNodePtr v20 = v34;
        if (v35) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v35);
        }
        if (v37) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v37);
        }
        if (fFINode != v20) {
          break;
        }
        uint64_t v21 = TNodeFromFINode(v38.fFINode);
        int v22 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v21);
        os_unfair_lock_lock(v22);
        TNodePtr::TNodePtr(&v36, *(const TNode **)(v21 + 48));
        os_unfair_lock_unlock(v22);
        TNodePtr::operator=((void **)&v38.fFINode, (void **)&v36.fFINode);
      }
      if (TNodeFromFINode(v38.fFINode))
      {
        uint64_t v23 = TNodeFromFINode(v38.fFINode);
        char v24 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v23);
        os_unfair_lock_lock(v24);
        uint64_t v26 = *(void *)(v23 + 16);
        uint64_t v25 = *(std::__shared_weak_count **)(v23 + 24);
        if (v25) {
          atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v24);
        BOOL v27 = (os_unfair_lock_s *)(v26 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v26 + 100));
        int v28 = *(_DWORD *)(v26 + 115);
        os_unfair_lock_unlock(v27);
        if (v25) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v25);
        }
        if ((v28 & 0x100) == 0)
        {
          uint64_t v29 = TNodeFromFINode(v38.fFINode);
          TNode::HandleSync(v29, 0x80000u);
          uint64_t v30 = *a1;
          uint64_t v31 = (os_unfair_lock_s *)((char *)*a1 + 100);
          os_unfair_lock_lock(v31);
          int v32 = (FINode *)*((void *)v30 + 2);
          long long v34 = v32;
          if (v32) {
            CFRetain(v32);
          }
          os_unfair_lock_unlock(v31);
          v36.fFINode = v32;
          NodeFromCFURLRef URL = TNode::GetNodeFromURL(&v36, a2, 0);
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v34);
        }
      }
    }
    if (!NodeFromURL)
    {
      if (TNodeFromFINode((FINode *)*a2)) {
        return 0;
      }
      else {
        return 4294959238;
      }
    }
  }
  return NodeFromURL;
}

void sub_1D3482414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  os_unfair_lock_unlock(v14);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsLocalVolume(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  return TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E4F1D870], a3);
}

void TNodeEvent::GetInternalClientNotifier(TNodeEvent *this@<X0>, void *a2@<X8>)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN10TNodeEvent25GetInternalClientNotifierEv_block_invoke;
  block[3] = &__block_descriptor_33_ea8_32c53_ZTSKZN10TNodeEvent25GetInternalClientNotifierEvE3__0_e5_v8__0l;
  if (TNodeEvent::GetInternalClientNotifier(void)::internalClientChangeNotifierOnce != -1) {
    dispatch_once(&TNodeEvent::GetInternalClientNotifier(void)::internalClientChangeNotifierOnce, block);
  }
  uint64_t v3 = qword_1EC008CA8;
  *a2 = TNodeEvent::gInternalClientChangeNotifier;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
}

id ___ZZ15NodeContextOpenENK3__2clEv_block_invoke()
{
  LogDSPath();
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZL30RegisterForComputerNameChangesv_block_invoke;
  block[3] = &__block_descriptor_33_ea8_32c45_ZTSKZL30RegisterForComputerNameChangesvE3__0_e5_v8__0l;
  if (RegisterForComputerNameChanges(void)::once != -1) {
    dispatch_once(&RegisterForComputerNameChanges(void)::once, block);
  }
  return (id)FPItemManagerInstance();
}

void LogDSPath(void)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v0 = dladdr("Release", &v7);
  CFURLRef v1 = LogObj(5);
  dispatch_queue_t v2 = v1;
  if (v0)
  {
    if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)TPropertyValue buf = 136446466;
      uint64_t v9 = "Release";
      __int16 v10 = 2082;
      dli_fname = v7.dli_fname;
      uint64_t v3 = "%{public}s DS loaded at %{public}s";
      uint64_t v4 = v2;
      os_log_type_t v5 = OS_LOG_TYPE_INFO;
      uint32_t v6 = 22;
LABEL_6:
      _os_log_impl(&dword_1D343E000, v4, v5, v3, buf, v6);
    }
  }
  else if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)TPropertyValue buf = 0;
    uint64_t v3 = "dladdr failed";
    uint64_t v4 = v2;
    os_log_type_t v5 = OS_LOG_TYPE_ERROR;
    uint32_t v6 = 2;
    goto LABEL_6;
  }
}

void ___ZN12TBusyFolders14StartObservingEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  notify_register_dispatch("CACHE_DELETE_PURGEABLE_UPDATED", (int *)(v2 + 48), (dispatch_queue_t)gSystemNotificationGCDQueue, &__block_literal_global_2);
  FSEventStreamForPath = CreateFSEventStreamForPath((TString *)@"/", (void (__cdecl *)(ConstFSEventStreamRef, void *, size_t, void *, const FSEventStreamEventFlags *, const FSEventStreamEventId *))TSystemNotificationTask::HandleAllFileChanges, *(const __CFArray **)(a1 + 40));
  dispatch_assert_queue_V2((dispatch_queue_t)gSystemNotificationStreamGCDQueue);
  *(void *)(v2 + 40) = FSEventStreamForPath;
}

__FSEventStream *CreateFSEventStreamForPath(TString *a1, void (__cdecl *a2)(ConstFSEventStreamRef, void *, size_t, void *, const FSEventStreamEventFlags *, const FSEventStreamEventId *), const __CFArray *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef pathsToWatch = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D510]);
  CFArraySetValueAtIndex(pathsToWatch, 0, a1);
  Dl_info v7 = FSEventStreamCreate(v6, a2, 0, pathsToWatch, 0xFFFFFFFFFFFFFFFFLL, 0.5, 2u);
  TString::TString((TString *)cf1, "/", 1uLL);
  if (a1) {
    CFStringRef v8 = (__CFString *)a1;
  }
  else {
    CFStringRef v8 = &stru_1F2ABD380;
  }
  int v9 = CFEqual(*(CFTypeRef *)cf1, v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)cf1);
  if (!v9)
  {
    __int16 v10 = LogObj(5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v13.fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(&v13, a1);
      uint64_t v11 = SanitizedPath(&v13);
      *(_DWORD *)CFTypeRef cf1 = 138543618;
      *(void *)&cf1[4] = v11;
      __int16 v16 = 2048;
      int v17 = v7;
      _os_log_impl(&dword_1D343E000, v10, OS_LOG_TYPE_DEFAULT, "Creating FSEvent Stream for %{public}@ = %p", cf1, 0x16u);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
    }
  }
  if (a3) {
    FSEventStreamSetExclusionPaths(v7, a3);
  }
  FSEventStreamSetDispatchQueue(v7, (dispatch_queue_t)gSystemNotificationGCDQueue);
  FSEventStreamStart(v7);
  TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef((const void **)&pathsToWatch);
  return v7;
}

void sub_1D3482940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);

  TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef(&a10);
  _Unwind_Resume(a1);
}

void ___ZL30RegisterForComputerNameChangesv_block_invoke()
{
  {
    RegisterForComputerNameChanges(void)::$_0::operator() const(void)::sDynamicStore = (uint64_t)SCDynamicStoreCreate(0, @"watchForComputerNameChanges", (SCDynamicStoreCallBack)TNode::ComputerNameChangedCallback, 0);
  }
  if (RegisterForComputerNameChanges(void)::$_0::operator() const(void)::sDynamicStore)
  {
    CFMutableArrayRef theArray = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    CFStringRef ComputerName = SCDynamicStoreKeyCreateComputerName(0);
    CFArrayAppendValue(theArray, ComputerName);
    if (SCDynamicStoreSetNotificationKeys((SCDynamicStoreRef)RegisterForComputerNameChanges(void)::$_0::operator() const(void)::sDynamicStore, theArray, 0))
    {
      int v0 = (const __SCDynamicStore *)RegisterForComputerNameChanges(void)::$_0::operator() const(void)::sDynamicStore;
      CFURLRef v1 = dispatch_get_global_queue(0, 0);
      SCDynamicStoreSetDispatchQueue(v0, v1);
    }
    TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&ComputerName);
    TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef((const void **)&theArray);
  }
}

void sub_1D3482A9C(_Unwind_Exception *a1)
{
}

const void **TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void ___ZN12TGlobalNodes28iCloudLibrariesContainerNodeEv_block_invoke(uint64_t a1)
{
  TFSVolumeInfo::GetVolumeInfoFor(0x17u, &v9);
  TNodePtr::TNodePtr(&v7, 0);
  uint64_t v2 = *(std::__shared_weak_count **)(v9 + 64);
  uint64_t v5 = *(void *)(v9 + 56);
  CFAllocatorRef v6 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  TNode::CreateNode(&obj, &v7, &v5, &v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }

  objc_storeStrong((id *)(*(void *)(a1 + 32) + 80), obj);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
}

void sub_1D3482BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }

  int v15 = *(std::__shared_weak_count **)(v13 - 24);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  _Unwind_Resume(a1);
}

void ___ZZ16CloudDocsRootURLvENK3__0cvU13block_pointerFvP5NSURLP7NSErrorEEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  id v7 = a3;
  id v8 = v6;
  id v9 = v7;
  if (v8)
  {
    objc_storeStrong(*(id **)(a1 + 32), a2);
  }
  else
  {
    __int16 v10 = LogObj(5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = 138412290;
      id v12 = v9;
      _os_log_impl(&dword_1D343E000, v10, OS_LOG_TYPE_ERROR, "BRGetCloudDocsRootURL failed: %@", (uint8_t *)&v11, 0xCu);
    }
  }
}

void sub_1D3482D14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN12TGlobalNodes16AllProvidersNodeEv_block_invoke(uint64_t a1)
{
  TFSVolumeInfo::GetVolumeInfoFor(0x1Bu, (uint64_t *)&v12);
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = v12;
  long long v12 = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 112);
  *(_OWORD *)(v2 + 104) = v3;
  if (v4)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    if (*((void *)&v12 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v12 + 1));
    }
  }
  TFSVolumeInfo::GetVolumeInfoFor(0x1Au, (uint64_t *)&v12);
  TNodePtr::TNodePtr(&v10, 0);
  uint64_t v5 = *(std::__shared_weak_count **)(v12 + 64);
  uint64_t v8 = *(void *)(v12 + 56);
  id v9 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = 0;
  id v7 = 0;
  TNode::CreateNode(&obj, &v10, &v8, &v6);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }

  objc_storeStrong((id *)(*(void *)(a1 + 32) + 96), obj);
  if (*((void *)&v12 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v12 + 1));
  }
}

void sub_1D3482E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }

  int v15 = *(std::__shared_weak_count **)(v13 - 24);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  _Unwind_Resume(a1);
}

void sub_1D3482FF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::FetchExtendedUserAccess(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = (TFSInfo *)*((void *)this + 2);
  long long v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  if ((TFSInfo::HasExtendedUserAccess(v4) & 1) == 0)
  {
    if (pthread_main_np())
    {
      dispatch_semaphore_t v5 = dispatch_semaphore_create(0);
      if (v3) {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      TNodePtr::TNodePtr(&v21, this);
      TNode::GetVolumeInfo(this, &v17);
      TFSVolumeInfo::GetPropertyUpdateThread(v17, &v19);
      uint64_t v6 = NodeEventRefFromNodeEvent(v19);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3321888768;
      block[2] = ___ZNK5TNode23FetchExtendedUserAccessEv_block_invoke;
      block[3] = &unk_1F2ABBC70;
      uint64_t v14 = v4;
      int v15 = v3;
      if (v3) {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      id v7 = v5;
      uint64_t v13 = v7;
      __int16 v16 = v21.fFINode;
      dispatch_async(v6, block);

      if (v20) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v20);
      }
      if (v18) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v18);
      }
      dispatch_time_t v8 = dispatch_time(0, 1000000);
      intptr_t v9 = dispatch_semaphore_wait(v7, v8);

      if (v15) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v15);
      }

      if (v3) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v3);
      }

      if (v9)
      {
        uint64_t v10 = 0;
        if (!v3) {
          return v10;
        }
        goto LABEL_22;
      }
    }
    else
    {
      TFSInfo::SetExtendedUserAccess(v4);
    }
  }
  uint64_t v10 = 1;
  if (v3) {
LABEL_22:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  return v10;
}

void sub_1D3483200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, std::__shared_weak_count *a19)
{
  uint64_t v23 = *(std::__shared_weak_count **)(v21 - 48);
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v23);
  }
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
  }

  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }

  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::HasExtendedUserAccess(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if (v3 < 0) {
    goto LABEL_9;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_DWORD *)((char *)this + 115) |= 0x100000u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_DWORD *)((char *)this + 115) |= 0x200000u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_DWORD *)((char *)this + 115) |= 0x400000u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_DWORD *)((char *)this + 115) |= 0x800000u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  uint64_t v4 = (const void *)*((void *)this + 2);
  intptr_t v9 = v4;
  if (!v4)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    goto LABEL_7;
  }
  CFRetain(v4);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if ((v5 & 0x20) == 0)
  {
LABEL_7:
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v9);
    goto LABEL_8;
  }
  int v6 = *((unsigned __int8 *)this + 112);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v9);
  if (v6)
  {
LABEL_8:
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    *(_DWORD *)((char *)this + 115) |= 0x80000000;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
LABEL_9:
    uint64_t v7 = 1;
    goto LABEL_10;
  }
  uint64_t v7 = 0;
LABEL_10:
  os_unfair_lock_unlock(v2);
  return v7;
}

void sub_1D34833D0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void ___ZN7TFSInfo25IterationInfoPropertyKeysEv_block_invoke()
{
  TFSInfo::IterationInfoPropertyKeys(void)::basicKeys = (uint64_t)CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D738]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CF50]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CDD0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CDD8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CDC0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CDE0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CE08]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D640]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D5B8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D5A0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D598]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D550]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D558]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D700]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D708]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D660]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D6E8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D690]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D6E0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D6D0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CE28]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D6C8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D678]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D6B8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D668]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D6B0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D6F0]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1D688]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CEB8]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CE48]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CE40]);
  CFArrayAppendValue((CFMutableArrayRef)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys, (const void *)*MEMORY[0x1E4F1CDC8]);
  int v0 = (__CFArray *)TFSInfo::IterationInfoPropertyKeys(void)::basicKeys;
  CFURLRef v1 = (const void *)*MEMORY[0x1E4F1D870];
  CFArrayAppendValue(v0, v1);
}

void std::__shared_ptr_emplace<TFolderSizingThread>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
}

void std::__shared_ptr_emplace<TFSVolumeInfo>::__on_zero_shared(uint64_t a1)
{
}

void TFSVolumeInfo::GarbageCollect(TFSVolumeInfo *this)
{
  uint64_t VolumeMap = (void *)GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  uint64_t v2 = (void *)VolumeMap[2];
  if (v2)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = v2[5];
        if (!v3 || *(void *)(v3 + 8) == -1) {
          break;
        }
        uint64_t v2 = (void *)*v2;
        if (!v2) {
          goto LABEL_7;
        }
      }
      uint64_t v4 = (void *)*v2;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(VolumeMap, v2, (uint64_t)v5);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<VolumeKey,std::weak_ptr<TFSVolumeInfo>>,void *>>>>::reset[abi:ne180100]((uint64_t)v5, 0);
      uint64_t v2 = v4;
    }
    while (v4);
  }
LABEL_7:
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
}

void sub_1D3483A70(_Unwind_Exception *a1)
{
  objc_sync_exit(v3);
  _Unwind_Resume(a1);
}

void sub_1D3483C34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3483D54(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1D3483E3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3483F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1D3484048(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c54_ZTSKZ41__FILocalStorageNode_fetchFPItemIfNeeded_E3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c54_ZTSKZ41__FILocalStorageNode_fetchFPItemIfNeeded_E3__0(uint64_t a1)
{
}

void sub_1D34842C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)FILocalAppContainerCollection;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
}

void sub_1D34843E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34844BC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1D34845AC(_Unwind_Exception *a1)
{
}

void sub_1D3484644(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34846D8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v2);

  _Unwind_Resume(a1);
}

void sub_1D3484998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34851BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  TNodeEventPtr::~TNodeEventPtr((id *)(v44 - 240));

  std::mutex::unlock(a12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&STACK[0x238]);

  STACK[0x238] = (unint64_t)&a26;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x238]);

  TNode::StPopulating::~StPopulating((TNode::StPopulating *)&a31);
  StDefer<-[FILocalAppContainerCollection populate]::$_1,(void *)0>::~StDefer((id *)&a38);

  a38 = (uint64_t)&a43;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a38);
  _Unwind_Resume(a1);
}

void sub_1D34855D8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v2);

  _Unwind_Resume(a1);
}

void sub_1D3485668(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1D348589C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c75_ZTSKZ62__FILocalAppContainerCollection_synchronizeWithOptions_async__E3__4(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c75_ZTSKZ62__FILocalAppContainerCollection_synchronizeWithOptions_async__E3__4(uint64_t a1)
{
}

void sub_1D3485B7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3485C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v10 = v9;

  a9.super_class = (Class)FILocalAppContainerNode;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1D3485D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1D3485FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  id v6 = va_arg(va1, id);
  id v8 = va_arg(va1, id);
  uint64_t v9 = va_arg(va1, void);
  TNodeEventPtr::~TNodeEventPtr((id *)va);
  TNodeEventPtr::~TNodeEventPtr(v4);

  TNodeEventPtr::~TNodeEventPtr((id *)va1);
  _Unwind_Resume(a1);
}

void sub_1D348615C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1D3486230(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3486544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

id objc_cast<FILocalAppContainerNode,FIDSNode * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

id objc_cast<FINode_ICloudAppLibrary,FIDSNode * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void sub_1D34867D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  objc_sync_exit(v10);

  _Unwind_Resume(a1);
}

void sub_1D3486868(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1D34869C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableSet<FILocalAppContainerNode *>>::NSForwardIterator<NSMutableSet<FILocalAppContainerNode *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  int v5 = (void *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  id v6 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 128) = -1;
  if (v4 && [v4 count] && (uint64_t v7 = *(void *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    uint64_t v8 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    uint64_t *v6 = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v9 = *(void *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            void *v5 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            uint64_t v11 = -1;
            uint64_t *v6 = -1;
          }
          if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            uint64_t v11 = *v6;
          }
          uint64_t v13 = *(void *)(a1 + 128) + 1;
          *(void *)(a1 + 120) = ++v11;
          *(void *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(void *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(void *)(a1 + 120) = *(void *)(a2 + 120);
      *(void *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)id v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1D3486B70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableSet<FILocalAppContainerNode *>>::NSForwardIterator<NSMutableSet<FILocalAppContainerNode *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D3486C34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableSet<FILocalAppContainerNode *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D3486CB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  CFURLRef v1 = *a1;
  id v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:ne180100]<TAppContainerInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<TAppContainerInfo,0>(uint64_t a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 16));

  id v2 = *(void **)a1;
}

uint64_t std::unique_lock<TDSMutex>::~unique_lock[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    TDSMutex::unlock(*(TDSMutex **)a1);
  }
  return a1;
}

void sub_1D3486EF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3486F80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34870EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34873A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

id archiveServiceConnection(void *a1)
{
  id v1 = a1;
  id v2 = (void *)[objc_alloc(MEMORY[0x1E4F29268]) initWithServiceName:@"com.apple.desktopservices.ArchiveService"];
  id v3 = DSArchiveServiceXPCInterface();
  [v2 setRemoteObjectInterface:v3];

  uint64_t v4 = DSArchiveServiceStreamingXPCInterface();
  [v2 setExportedInterface:v4];

  [v2 setExportedObject:v1];
  [v2 setInterruptionHandler:&__block_literal_global_129];

  return v2;
}

void sub_1D34874F8(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1D348758C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D3487CE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1D3487ED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D3487F98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348802C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348875C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1D348894C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D3488A10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3488B94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1D34890D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,void *a38)
{
  _Unwind_Resume(a1);
}

void sub_1D348922C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34892F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D3489428(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3489A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  _Unwind_Resume(a1);
}

void sub_1D3489B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D3489D10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1D3489E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL24archiveServiceConnectionPU44objcproto33DSArchiveServiceStreamingInternal11objc_object_block_invoke()
{
  int v0 = LogObj(0);
  if (os_log_type_enabled(v0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)id v1 = 0;
    _os_log_impl(&dword_1D343E000, v0, OS_LOG_TYPE_INFO, "Archive Service connection interrupted", v1, 2u);
  }
}

BOOL IsDebugLogCategoryEnabled(int a1)
{
  id v1 = LogObj(a1);
  BOOL v2 = os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG);

  return v2;
}

id DSArchiveServiceXPCInterface()
{
  v13[2] = *MEMORY[0x1E4F143B8];
  int v0 = [MEMORY[0x1E4F29280] interfaceWithProtocol:&unk_1F2ACAB98];
  id v1 = (void *)MEMORY[0x1E4F1CAD0];
  v13[0] = objc_opt_class();
  v13[1] = objc_opt_class();
  BOOL v2 = [MEMORY[0x1E4F1C978] arrayWithObjects:v13 count:2];
  id v3 = [v1 setWithArray:v2];
  [v0 setClasses:v3 forSelector:sel_archiveItemsWithURLWrappers_toURLWrapper_options_compressionFormat_passphrase_completionHandler_ argumentIndex:0 ofReply:0];

  uint64_t v4 = (void *)MEMORY[0x1E4F1CAD0];
  v12[0] = objc_opt_class();
  v12[1] = objc_opt_class();
  int v5 = [MEMORY[0x1E4F1C978] arrayWithObjects:v12 count:2];
  id v6 = [v4 setWithArray:v5];
  [v0 setClasses:v6 forSelector:sel_archiveItemsWithURLWrappers_passphrase_addToKeychain_compressionFormat_destinationFolderURLWrapper_usePlaceholder_completionHandler_ argumentIndex:0 ofReply:0];

  uint64_t v7 = (void *)MEMORY[0x1E4F1CAD0];
  v11[0] = objc_opt_class();
  v11[1] = objc_opt_class();
  uint64_t v8 = [MEMORY[0x1E4F1C978] arrayWithObjects:v11 count:2];
  uint64_t v9 = [v7 setWithArray:v8];
  [v0 setClasses:v9 forSelector:sel_itemDescriptorsForItemWithURLWrapper_passphrases_completionHandler_ argumentIndex:0 ofReply:1];

  return v0;
}

void sub_1D348A12C(_Unwind_Exception *a1)
{
  uint64_t v4 = v2;

  _Unwind_Resume(a1);
}

id DSArchiveServiceStreamingXPCInterface()
{
  uint64_t v5[2] = *MEMORY[0x1E4F143B8];
  int v0 = [MEMORY[0x1E4F29280] interfaceWithProtocol:&unk_1F2AC5F90];
  id v1 = (void *)MEMORY[0x1E4F1CAD0];
  v5[0] = objc_opt_class();
  v5[1] = objc_opt_class();
  BOOL v2 = [MEMORY[0x1E4F1C978] arrayWithObjects:v5 count:2];
  id v3 = [v1 setWithArray:v2];
  [v0 setClasses:v3 forSelector:sel_receiveArchivedItemsDescriptors_placeholderName_placeholderTypeIdentifier_ argumentIndex:0 ofReply:0];

  return v0;
}

void sub_1D348A298(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void OperationsUpdatedHandler(__CFNotificationCenter *a1, void *a2, const __CFString *a3, const void *a4, const __CFDictionary *a5)
{
  static_objc_cast<DSFileServiceConnection,void *>(a2);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  [v5 _triggerReloadCurrentOperations];
}

void sub_1D348A318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348A390(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)DSFileServiceConnection;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1D348A6A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348A8D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348AB00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_1D348AD5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348ADDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348AF14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348AF78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348B050(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL23dsFileServiceConnectionv_block_invoke()
{
}

void sub_1D348B14C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348B1DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348B264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348B344(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348B3D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348B46C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348B554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348B6DC(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1D348B77C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348B874(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1D9436740);
}

void sub_1D348BA48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D348BB48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348BCDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void TOperationSizer::TOperationSizer(TOperationSizer *this, const TOperationSizer::TOperationSizerParams *a2)
{
  *(void *)this = *(void *)a2;
  uint64_t v4 = *((void *)a2 + 1);
  *((void *)this + 1) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 2) = *((void *)a2 + 2);
  uint64_t v5 = *((void *)a2 + 3);
  *((void *)this + 3) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 6) = MEMORY[0x1D9436FC0](*((void *)a2 + 6));
  uint64_t v6 = MEMORY[0x1D9436FC0](*((void *)a2 + 7));
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = v6;
  *((void *)this + 10) = *((void *)a2 + 4);
  *(_OWORD *)((char *)this + 88) = *((_OWORD *)a2 + 4);
  *(_OWORD *)((char *)this + 104) = *((_OWORD *)a2 + 5);
  *((void *)this + 15) = 0;
  *((void *)this + 16) = *((void *)a2 + 12);
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((unsigned char *)this + 168) = *((unsigned char *)a2 + 121);
  *((unsigned char *)this + 169) = 0;
  *((unsigned char *)this + 170) = *((unsigned char *)a2 + 152);
  *((unsigned char *)this + 171) = *((unsigned char *)a2 + 42);
  *((unsigned char *)this + 172) = *((unsigned char *)a2 + 104);
  char v7 = *((unsigned char *)a2 + 105);
  if (v7)
  {
    uint64_t v8 = *(void *)a2;
    TCFURLInfo::CheckPrefetchState(*(void *)a2, 1);
    if (*(_WORD *)(v8 + 76))
    {
      uint64_t v9 = *(void *)a2;
      TCFURLInfo::CheckPrefetchState(*(void *)a2, 1);
      char v7 = (*(_WORD *)(v9 + 76) & 4) == 0;
    }
    else
    {
      char v7 = 0;
    }
  }
  *((void *)this + 25) = &stru_1F2ABD380;
  *((unsigned char *)this + 173) = v7;
  *((unsigned char *)this + 174) = *((unsigned char *)a2 + 106);
  *(_WORD *)((char *)this + 175) = *(_WORD *)((char *)a2 + 155);
  *((void *)this + 23) = 0;
  *((unsigned char *)this + 192) = *((unsigned char *)a2 + 120);
  *((unsigned char *)this + 193) = *((unsigned char *)a2 + 154);
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 26) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 27) = 0;
  *((_DWORD *)this + 60) = 0;
  *((unsigned char *)this + 260) = *((unsigned char *)this + 173);
  *((unsigned char *)this + 261) = *((unsigned char *)a2 + 153);
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((void *)this + 37) = 0;
  if (*((unsigned char *)a2 + 40)) {
    operator new();
  }
  *((void *)this + 38) = 0;
  if (*((unsigned char *)a2 + 41)) {
    operator new();
  }
  *((void *)this + 39) = 0;
  *((_OWORD *)this + 20) = *((_OWORD *)a2 + 8);
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((void *)this + 46) = 0;
  uint64_t v10 = (uint64_t *)*((void *)a2 + 18);
  if (v10)
  {
    uint64_t v11 = *v10;
    *((void *)this + 42) = *v10;
    long long v12 = *(_OWORD *)(v10 + 1);
    *(_OWORD *)((char *)this + 344) = v12;
    if (v11 && (void)v12) {
      ((void (*)(void))v12)();
    }
  }
  else
  {
    *((void *)this + 42) = 0;
    *((void *)this + 43) = 0;
    *((void *)this + 44) = 0;
  }
  if (*((unsigned char *)this + 173))
  {
    TCFURLInfo::FileSystemRepresentation(**(TCFURLInfo ***)this, (const __CFURL *)1, (TString *)&cf);
    if ((CFTypeRef *)((char *)this + 200) != &cf)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)this + 25, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  TCFURLInfo::Name(*(TCFURLInfo **)this, (TString *)&cf);
  if ((CFTypeRef *)((char *)this + 208) != &cf)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)this + 26, &cf);
    CFRetain(&stru_1F2ABD380);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = &stru_1F2ABD380;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1D348C050(_Unwind_Exception *a1)
{
  uint64_t v6 = *(std::__shared_weak_count **)(v1 + 368);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  std::unique_ptr<TCloneCache>::reset[abi:ne180100]((uint64_t *)(v1 + 312), 0);
  std::unique_ptr<std::unordered_set<unsigned long long>>::reset[abi:ne180100]((uint64_t *)(v1 + 304), 0);
  char v7 = *(std::__shared_weak_count **)(v1 + 296);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(v1 + 280);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  uint64_t v9 = *(std::__shared_weak_count **)(v1 + 72);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }

  std::unique_ptr<TDeepCFURLIterator>::reset[abi:ne180100](v2, 0);
  uint64_t v10 = *(std::__shared_weak_count **)(v1 + 24);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(v1 + 8);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  _Unwind_Resume(a1);
}

void TOperationSizer::~TOperationSizer(TOperationSizer *this)
{
  if (*((void *)this + 42))
  {
    BOOL v2 = (void (*)(void))*((void *)this + 44);
    if (v2) {
      v2();
    }
  }
  id v3 = (std::__shared_weak_count *)*((void *)this + 46);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  std::unique_ptr<TCloneCache>::reset[abi:ne180100]((uint64_t *)this + 39, 0);
  std::unique_ptr<std::unordered_set<unsigned long long>>::reset[abi:ne180100]((uint64_t *)this + 38, 0);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 37);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 26);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 25);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }

  std::unique_ptr<TDeepCFURLIterator>::reset[abi:ne180100]((TDeepCFURLIterator **)this + 4, 0);
  char v7 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void TOperationSizer::ComputeSize(TOperationSizer *this)
{
}

void TOperationSizer::ComputeSizeWithTimeout(TOperationSizer *this)
{
  uint64_t v3 = *(void *)this;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 9);
  *((void *)this + 8) = v3;
  *((void *)this + 9) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  TOperationSizer::UpdateSizingStats(this, 0);
  uint64_t v5 = (TCFURLInfo *)IsRunningInFinder();
  if (v5) {
    *((unsigned char *)this + 166) = 1;
  }
  else {
    *((unsigned char *)this + 165) = 1;
  }
  if (*((unsigned char *)this + 170)) {
    TCFURLInfo::GetBasicInfoPropertyKeys(v5);
  }
  else {
    TCFURLInfo::GetSizerPropertyKeys(v5);
  }
  operator new();
}

void sub_1D348C3F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  MEMORY[0x1D9436740](v14, 0x10E0C408176880BLL);
  _Unwind_Resume(a1);
}

uint64_t TOperationSizer::UpdateSizingStats(TOperationSizer *this, uint64_t a2)
{
  uint64_t result = *((void *)this + 6);
  if (result)
  {
    uint64_t v4 = *((void *)this + 13);
    if (*((unsigned char *)this + 174))
    {
      v4 -= *((void *)this + 28) + *((void *)this + 31);
      uint64_t v5 = *((void *)this + 12);
      uint64_t v6 = *((void *)this + 11) - (*((int *)this + 55) + (uint64_t)*((int *)this + 60));
    }
    else
    {
      uint64_t v6 = *((void *)this + 11);
      uint64_t v5 = *((void *)this + 12);
    }
    return (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t))(result + 16))(result, (char *)this + 64, v4, v6, v5, a2);
  }
  return result;
}

void TOperationSizer::StartSizing(TOperationSizer *this)
{
  long long v6 = 0uLL;
  if (*((unsigned char *)this + 173))
  {
    TOperationSizer::MapSourceToDestination((uint64_t)this, (TCFURLInfo ***)this, &v5);
    long long v6 = v5;
    BOOL IsSuspendedCopyOfSource = v5;
    if ((void)v5) {
      BOOL IsSuspendedCopyOfSource = TCFURLInfo::IsSuspendedCopyOfSource((TCFURLInfo **)v5, (const __CFURL ***)this, (double *)this + 23);
    }
    *((unsigned char *)this + 174) = IsSuspendedCopyOfSource;
  }
  uint64_t v3 = *(TCFURLInfo ***)this;
  TCFURLInfo::CheckPrefetchState(*(void *)this, 1);
  if (*((_WORD *)v3 + 38))
  {
    uint64_t v4 = (void (***)(void, TOperationSizer *))*((void *)this + 45);
    if (v4) {
      (**v4)(v4, this);
    }
  }
  TOperationSizer::AccumulateSize((uint64_t)this, (CFIndex *)this, 0, 0, (CFIndex *)&v6);
  if (*((void *)&v6 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v6 + 1));
  }
}

void sub_1D348C55C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TOperationSizer::ResumeSizing(TOperationSizer *this, uint64_t a2)
{
  uint64_t v4 = TTime::MicrosecondsSinceStartup(this);
  do
  {
    long long v5 = (void *)MEMORY[0x1D9436D80]();
    int v39 = 0;
    int v40 = 0;
    __int16 v38 = 0;
    char v37 = 0;
    uint64_t v35 = 0;
    TNodePtr v36 = 0;
    CFIndex v33 = 0;
    long long v34 = 0;
    _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v31);
    int v6 = TDeepCFURLIterator::Next(*((void *)this + 4), &v31, &v40, &v39, (BOOL *)&v38 + 1, &v38, &v33, &v37, &v35);
    int v7 = v6;
    if (v6 == -8013)
    {
      uint64_t v9 = *((void *)this + 45);
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
      }
    }
    else if (!v6)
    {
      if (TOperationSizer::ShouldSkip((uint64_t *)this, &v31))
      {
        int v8 = 0;
        goto LABEL_39;
      }
      if (!*((void *)this + 45)) {
        goto LABEL_21;
      }
      if (v39 >= 1)
      {
        int v11 = v39 + 1;
        while (--v11 >= 1)
          (*(void (**)(void, void))(**((void **)this + 45) + 8))(*((void *)this + 45), *(unsigned __int8 *)(*((void *)this + 4) + 112));
      }
      if (v40 >= 1
        && ((***((uint64_t (****)(void, TCFURLInfo **))this + 45))(*((void *)this + 45), &v31) & 1) != 0)
      {
        char v12 = 1;
      }
      else
      {
LABEL_21:
        TOperationSizer::AccumulateSize((uint64_t)this, (CFIndex *)&v31, SHIBYTE(v38), v38, &v33);
        char v12 = 0;
      }
      uint64_t v13 = v31;
      TCFURLInfo::CheckPrefetchState((CFIndex)v31, 1);
      if (*((_WORD *)v13 + 38))
      {
        __int16 v16 = v31;
        TCFURLInfo::CheckPrefetchState((CFIndex)v31, 1);
        if ((*((_WORD *)v16 + 38) & 4) == 0)
        {
          if (TCFURLInfo::IsDataless((const __CFURL **)v31, v14, v15))
          {
            uint64_t v17 = *((void *)this + 45);
            if (v17) {
              (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
            }
            *((unsigned char *)this + 167) = 1;
          }
        }
      }
      if (!*((unsigned char *)this + 166)
        && TCFURLInfo::IsRootItem((TCFURLInfo **)v31, v14, v15)
        && IsRunningInFinder())
      {
        *((unsigned char *)this + 166) = 1;
        if (*((unsigned char *)this + 261)) {
          int v7 = -8097;
        }
        else {
          int v7 = 0;
        }
        int v8 = v7;
        if ((v12 & 1) == 0)
        {
LABEL_35:
          if (!HIBYTE(v38) || v40 <= 0) {
            goto LABEL_42;
          }
LABEL_40:
          TDeepCFURLIterator::PopIterator(*((TDeepCFURLIterator **)this + 4));
          uint64_t v18 = *((void *)this + 45);
          if (v18) {
            (*(void (**)(uint64_t, void))(*(void *)v18 + 8))(v18, *(unsigned __int8 *)(*((void *)this + 4) + 112));
          }
          goto LABEL_42;
        }
      }
      else
      {
        int v7 = 0;
        int v8 = 0;
        if ((v12 & 1) == 0) {
          goto LABEL_35;
        }
      }
LABEL_39:
      int v7 = v8;
      if (v40 < 1) {
        goto LABEL_42;
      }
      goto LABEL_40;
    }
    if (v39 >= 1 && *((void *)this + 45))
    {
      int v10 = v39 + 1;
      while (--v10 >= 1)
        (*(void (**)(void, void))(**((void **)this + 45) + 8))(*((void *)this + 45), *(unsigned __int8 *)(*((void *)this + 4) + 112));
    }
LABEL_42:
    if (v7 != -1417 && v7 != 0 && *((unsigned char *)this + 193) != 0) {
      int v7 = 0;
    }
    if (*((unsigned char *)this + 173) && (!v7 || v7 == -1417) && v37 && v35)
    {
      ++*((_DWORD *)this + 59);
      TOperationSizer::SetFirstMergeDestinationConflict((uint64_t)this, (const TCFURLInfo **)&v35);
    }
    uint64_t v21 = *((void *)this + 7);
    if (v21 && ((*(uint64_t (**)(void))(v21 + 16))() & 1) != 0
      || (int v22 = (unsigned int (*)(void))*((void *)this + 41)) != 0 && v22(*((void *)this + 42)))
    {
      TDeepCFURLIterator::Cancel(*((void *)this + 4));
      int v7 = -128;
    }
    if (v32) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v32);
    }
    if (v34) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v34);
    }
    if (v36) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v36);
    }
    BOOL v26 = 0;
    if (a2 && !*((unsigned char *)this + 170)) {
      BOOL v26 = TTime::MicrosecondsSinceStartup(v23) - v4 > a2;
    }
  }
  while (!v7 && !v26);
  TOperationSizer::CheckMaxFileSize((unint64_t)this, v24, v25);
  TOperationSizer::UpdateSizingStats(this, 1);
  if (v7) {
    int v27 = 1;
  }
  else {
    int v27 = !v26;
  }
  if (v27 == 1)
  {
    if (v7 == -1417) {
      int v28 = 0;
    }
    else {
      int v28 = v7;
    }
    *((_DWORD *)this + 10) = v28;
    if (!v28)
    {
      uint64_t v29 = *((void *)this + 45);
      if (v29) {
        (*(void (**)(uint64_t))(*(void *)v29 + 16))(v29);
      }
    }
  }
  return v27 ^ 1u;
}

void sub_1D348C9F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

unint64_t TOperationSizer::CheckMaxFileSize(unint64_t this, uint64_t a2, const __CFString *a3)
{
  if (*(unsigned char *)(this + 170))
  {
    unint64_t v3 = this;
    this = (unint64_t)TCFURLInfo::GetNumericalProperty(*(const __CFURL ***)(this + 16), (const __CFString *)*MEMORY[0x1E4F1D8A0], a3);
    if ((uint64_t)this >= 1 && *(void *)(v3 + 136) > this) {
      *(_DWORD *)(v3 + 160) |= 0x100000u;
    }
  }
  return this;
}

const void **TOperationSizer::MapSourceToDestination@<X0>(uint64_t a1@<X0>, TCFURLInfo ***a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  v7.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  if (TCFURLInfo::FileSystemRepresentationRelativeToSource(*a2, (const TString *)(a1 + 200), &v7)) {
    TCFURLInfo::CreateCFURLInfoWithFileSystemRepresentationRelativeToBase(*(TCFURLInfo **)(a1 + 16), &v7, (const __CFString **)(a1 + 208), (uint64_t)a3);
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
}

void sub_1D348CB14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(a1);
}

uint64_t TOperationSizer::AccumulateSize(uint64_t a1, CFIndex *a2, char a3, char a4, CFIndex *a5)
{
  uint64_t v10 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v10 + 50) && !*(unsigned char *)(v10 + 51))
  {
    CFIndex v11 = *a2;
    TCFURLInfo::CheckPrefetchState(*a2, 1);
    if ((*(_WORD *)(v11 + 76) & 0x20) != 0) {
      ++*(void *)(a1 + 88);
    }
  }
  ++*(void *)(a1 + 96);
  if (!TCFURLInfo::IsTrash((TCFURLInfo *)*a2))
  {
    CFIndex v12 = *a2;
    TCFURLInfo::CheckPrefetchState(*a2, 1);
    if ((*(_WORD *)(v12 + 76) & 1) != 0
      || (a3 & 1) != 0
      || *(unsigned char *)(a1 + 170) && !*(unsigned char *)(a1 + 171) && (a4 & 1) != 0)
    {
      goto LABEL_33;
    }
    Numericalint Property = (int64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E4F1D640], v13);
    int64_t v16 = (int64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E4F1CDD8], v15);
    *(void *)(a1 + 104) += v16 + NumericalProperty;
    CFIndex v17 = *a2;
    TCFURLInfo::CheckPrefetchState(*a2, 1);
    double v19 = (double)NumericalProperty;
    if ((*(_WORD *)(v17 + 76) & 0x8000) != 0) {
      double v19 = (double)NumericalProperty * 0.48;
    }
    TNodePtr v20 = (char *)(*(void *)(a1 + 120) + v16 + NumericalProperty);
    *(void *)(a1 + 112) = (uint64_t)(v19 + (double)v16 + (double)*(uint64_t *)(a1 + 112));
    *(void *)(a1 + 120) = v20;
    if (NumericalProperty < 1)
    {
LABEL_26:
      if (v16 < 1) {
        goto LABEL_33;
      }
      unint64_t v26 = *(void *)(a1 + 80);
      unint64_t v27 = v16;
      if (!__CFADD__(v16, v26))
      {
        if (!v26) {
          goto LABEL_31;
        }
        unint64_t v27 = v16 + v26 - 1;
      }
      v26 *= v27 / v26;
LABEL_31:
      uint64_t v28 = *(void *)(a1 + 136);
      *(void *)(a1 + 128) += v26;
      if (v16 > v28) {
        *(void *)(a1 + 136) = v16;
      }
LABEL_33:
      CFIndex v29 = *a2;
      TCFURLInfo::CheckPrefetchState(*a2, 1);
      if ((*(_WORD *)(v29 + 76) & 1) != 0 && (a3 & 1) == 0) {
        ++*(void *)(a1 + 152);
      }
      if (TCFURLInfo::GetType((CFURLRef *)*a2) == 1651666795
        && !*(unsigned char *)(*(void *)(a1 + 32) + 50)
        && !*(unsigned char *)(a1 + 172))
      {
        *(_DWORD *)(a1 + 160) |= 0x1000u;
      }
      if (!*(unsigned char *)(a1 + 170)) {
        goto LABEL_101;
      }
      BOOL v94 = 1;
      if ((TCFURLInfo::EffectiveUserCanRead((const void **)*a2, &v94) & 1) == 0) {
        *(_DWORD *)(a1 + 160) |= 0x400u;
      }
      if (TCFURLInfo::IsDataless((const __CFURL **)*a2, v30, v31) && *(unsigned char *)(a1 + 175)) {
        *(_DWORD *)(a1 + 160) |= 0x40000000u;
      }
      if (*(unsigned char *)(a1 + 192) && TCFURLInfo::IsLocalVolume(*(TCFURLInfo ***)a1, v32, v33))
      {
        CFIndex v92 = 0;
        int v93 = 0;
        CFIndex v34 = *a2;
        TCFURLInfo::CheckPrefetchState(*a2, 2);
        if ((*(_WORD *)(v34 + 76) & 0x2000) != 0 && IsEqual(*(const void **)*a2, **(const void ***)a1)) {
          TCFURLInfo::GetParent((const void **)*a2, (uint64_t)&v92);
        }
        CFIndex v35 = *a2;
        TCFURLInfo::CheckPrefetchState(*a2, 2);
        if ((*(_WORD *)(v35 + 76) & 0x2000) == 0
          || (CFIndex v36 = v92) != 0 && (TCFURLInfo::CheckPrefetchState(v92, 2), (*(_WORD *)(v36 + 76) & 0x2000) == 0))
        {
          *(_DWORD *)(a1 + 160) |= 0x400u;
        }
        if (v93) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v93);
        }
      }
      if (!v94
        || (CFIndex v37 = *a2, TCFURLInfo::CheckPrefetchState(*a2, 2), (*(_WORD *)(v37 + 76) & 0x1000) == 0)
        || (v38 = *a2, int v39 = (TCFURLInfo *)TCFURLInfo::CheckPrefetchState(*a2, 1), (*(_WORD *)(v38 + 76) & 1) != 0)
        && (v40 = *a2, int v39 = (TCFURLInfo *)TCFURLInfo::CheckPrefetchState(*a2, 2), (*(_WORD *)(v40 + 76) & 0x4000) == 0)
        || (int v41 = TCFURLInfo::GetgidToUse(v39), v41 != TCFURLInfo::GetUserGroups((CFURLRef *)*a2)))
      {
        *(_DWORD *)(a1 + 160) |= 0x80000000;
      }
      if (*(unsigned char *)(a1 + 168))
      {
        CFIndex v42 = *a2;
        TCFURLInfo::CheckPrefetchState(*a2, 1);
        if ((*(_WORD *)(v42 + 76) & 0x10) != 0) {
          *(_DWORD *)(a1 + 160) |= 0x200u;
        }
        if (*(unsigned char *)(a1 + 168))
        {
          CFIndex v43 = *a2;
          TCFURLInfo::CheckPrefetchState(*a2, 1);
          if (((*(unsigned __int16 *)(v43 + 76) | (*(unsigned __int8 *)(v43 + 78) << 16)) & 0x20000) != 0) {
            *(_DWORD *)(a1 + 160) |= 0x400u;
          }
          if (*(unsigned char *)(a1 + 168) && TCFURLInfo::IsSystemRestrictionEffective((TCFURLInfo **)*a2, v44, v33)) {
            *(_DWORD *)(a1 + 160) |= 0x200u;
          }
        }
      }
      if (!*(unsigned char *)(a1 + 173) || !*(unsigned char *)(a1 + 260)) {
        goto LABEL_101;
      }
      CFIndex v45 = *a2;
      if (*a5)
      {
        TCFURLInfo::CheckPrefetchState(*a2, 1);
        int v46 = *(_WORD *)(v45 + 76) & 1;
        CFIndex v47 = *a5;
        TCFURLInfo::CheckPrefetchState(*a5, 1);
        if (v46 != (*(_WORD *)(v47 + 76) & 1)) {
          *(unsigned char *)(a1 + 260) = 0;
        }
        if (TCFURLInfo::IsDataless((const __CFURL **)*a5, v48, v49))
        {
          *(unsigned char *)(a1 + 260) = 0;
          goto LABEL_101;
        }
        if (!*(unsigned char *)(a1 + 260)
          || (CFIndex v55 = *a2, TCFURLInfo::CheckPrefetchState(*a2, 1), (*(_WORD *)(v55 + 76) & 0x20) == 0))
        {
LABEL_101:
          CFIndex v62 = *a2;
          TCFURLInfo::CheckPrefetchState(*a2, 1);
          if ((*(_WORD *)(v62 + 76) & 2) != 0) {
            *(_DWORD *)(a1 + 160) |= 0x4000u;
          }
          goto LABEL_103;
        }
        CFIndex v56 = *a2;
        TCFURLInfo::CheckPrefetchState(*a2, 1);
        if (*(_WORD *)(v56 + 76))
        {
          CFIndex v58 = *a2;
          TCFURLInfo::CheckPrefetchState(*a2, 1);
          if ((*(_WORD *)(v58 + 76) & 4) == 0)
          {
            ++*(_DWORD *)(a1 + 240);
            goto LABEL_101;
          }
        }
        CFStringRef v68 = (const __CFString *)*MEMORY[0x1E4F1D640];
        uint64_t v69 = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E4F1D640], v57);
        CFStringRef v70 = (const __CFString *)*MEMORY[0x1E4F1CDD8];
        uint64_t v72 = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E4F1CDD8], v71);
        if (v69 >= 1)
        {
          unint64_t v74 = *(void *)(a1 + 80);
          if (__CFADD__(v69, v74))
          {
LABEL_114:
            unint64_t v75 = v69 / v74 * v74;
            goto LABEL_116;
          }
          if (v74)
          {
            uint64_t v69 = v69 + v74 - 1;
            goto LABEL_114;
          }
        }
        unint64_t v75 = 0;
LABEL_116:
        if (v72 < 1) {
          goto LABEL_122;
        }
        unint64_t v76 = *(void *)(a1 + 80);
        if (!__CFADD__(v72, v76))
        {
          if (!v76)
          {
LABEL_121:
            v75 += v76;
LABEL_122:
            if (*(unsigned char *)(*(void *)(a1 + 32) + 50))
            {
              CFURLRef v77 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v68, v73);
              uint64_t v79 = (char *)v77 + (void)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v70, v78);
            }
            else
            {
              CFIndex v92 = 0;
              if (IsRunningInFinder()) {
                BOOL v80 = *(unsigned char *)(a1 + 172) == 0;
              }
              else {
                BOOL v80 = 0;
              }
              char v81 = TCFURLInfo::CompareForMerge(*a2, (CFURLRef **)a5, &v92, v80, *(unsigned char *)(a1 + 176));
              BOOL v91 = 0;
              BOOL v82 = TCFURLInfo::ModifiedAfterCheckPoint((CFURLRef *)*a5, *(double *)(a1 + 184), &v91);
              BOOL v84 = v82;
              if (v81)
              {
                if (*(unsigned char *)(a1 + 174))
                {
                  if (v82)
                  {
                    uint64_t v79 = 0;
                  }
                  else
                  {
                    ++*(_DWORD *)(a1 + 240);
                    CFURLRef v88 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v68, v83);
                    CFURLRef v90 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v70, v89);
                    uint64_t v79 = 0;
                    *(void *)(a1 + 248) += (char *)v88 + (void)v90;
                  }
                }
                else
                {
                  uint64_t v79 = 0;
                  ++*(_DWORD *)(a1 + 240);
                }
                goto LABEL_124;
              }
              CFURLRef v85 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v68, v83);
              uint64_t v79 = (char *)v85 + (void)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a5, v70, v86);
              if (v92 != 1)
              {
                if (v92 != -1)
                {
                  TOperationSizer::SetFirstMergeSourceConflict(a1, (const TCFURLInfo **)a2);
                  ++*(_DWORD *)(a1 + 256);
                  goto LABEL_124;
                }
                if (!*(unsigned char *)(a1 + 174))
                {
                  TOperationSizer::SetFirstMergeDestinationConflict(a1, (const TCFURLInfo **)a5);
                  ++*(_DWORD *)(a1 + 220);
                  goto LABEL_124;
                }
                if (!v91 || !v84)
                {
                  TOperationSizer::SetFirstMergeDestinationConflict(a1, (const TCFURLInfo **)a5);
                  ++*(_DWORD *)(a1 + 220);
                  *(void *)(a1 + 224) += v79;
                  goto LABEL_124;
                }
              }
              TOperationSizer::SetFirstMergeSourceConflict(a1, (const TCFURLInfo **)a2);
              ++*(_DWORD *)(a1 + 216);
            }
LABEL_124:
            unint64_t v61 = v75 - (void)v79 + *(void *)(a1 + 264);
LABEL_100:
            *(void *)(a1 + 264) = v61;
            goto LABEL_101;
          }
          uint64_t v72 = v72 + v76 - 1;
        }
        v76 *= v72 / v76;
        goto LABEL_121;
      }
      uint64_t v50 = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E4F1D640], v33);
      uint64_t v52 = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E4F1CDD8], v51);
      if (v50 >= 1)
      {
        unint64_t v53 = *(void *)(a1 + 80);
        if (__CFADD__(v50, v53))
        {
LABEL_83:
          unint64_t v54 = v50 / v53 * v53;
          goto LABEL_90;
        }
        if (v53)
        {
          uint64_t v50 = v50 + v53 - 1;
          goto LABEL_83;
        }
      }
      unint64_t v54 = 0;
LABEL_90:
      if (v52 < 1) {
        goto LABEL_96;
      }
      unint64_t v59 = *(void *)(a1 + 80);
      if (!__CFADD__(v52, v59))
      {
        if (!v59)
        {
LABEL_95:
          v54 += v59;
LABEL_96:
          CFIndex v60 = *a2;
          TCFURLInfo::CheckPrefetchState(*a2, 1);
          if ((*(_WORD *)(v60 + 76) & 0x20) != 0 && !*(unsigned char *)(*(void *)(a1 + 32) + 50))
          {
            TOperationSizer::SetFirstMergeSourceConflict(a1, (const TCFURLInfo **)a2);
            ++*(_DWORD *)(a1 + 232);
          }
          unint64_t v61 = *(void *)(a1 + 264) + v54;
          goto LABEL_100;
        }
        uint64_t v52 = v52 + v59 - 1;
      }
      v59 *= v52 / v59;
      goto LABEL_95;
    }
    if (*(unsigned char *)(a1 + 170))
    {
      unint64_t v21 = *(void *)(a1 + 80);
      unint64_t v22 = NumericalProperty;
      if (!__CFADD__(NumericalProperty, v21))
      {
        if (!v21) {
          goto LABEL_24;
        }
        unint64_t v22 = NumericalProperty + v21 - 1;
      }
      unint64_t v23 = v22 / v21;
    }
    else
    {
      CFURLRef v24 = TCFURLInfo::GetNumericalProperty((const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E4F1D768], v18);
      unint64_t v21 = *(void *)(a1 + 80);
      if (!__CFADD__(v24, v21))
      {
        if (!v21) {
          goto LABEL_24;
        }
        CFURLRef v24 = (const __CFURL *)((char *)v24 + v21 - 1);
      }
      unint64_t v23 = (unint64_t)v24 / v21;
    }
    v21 *= v23;
LABEL_24:
    uint64_t v25 = *(void *)(a1 + 136);
    *(void *)(a1 + 128) += v21;
    if (NumericalProperty > v25) {
      *(void *)(a1 + 136) = NumericalProperty;
    }
    goto LABEL_26;
  }
LABEL_103:
  if (!*(unsigned char *)(*(void *)(a1 + 32) + 50))
  {
    CFIndex v63 = *a2;
    TCFURLInfo::CheckPrefetchState(*a2, 1);
    if ((*(_WORD *)(v63 + 76) & 0x20) != 0)
    {
      CFIndex v65 = *a2;
      CFIndex v64 = a2[1];
      if (v64) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v64 + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v66 = *(std::__shared_weak_count **)(a1 + 72);
      *(void *)(a1 + 64) = v65;
      *(void *)(a1 + 72) = v64;
      if (v66) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v66);
      }
    }
  }
  return TOperationSizer::UpdateSizingStats((TOperationSizer *)a1, 0);
}

void sub_1D348D488(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TOperationSizer::ShouldSkip(uint64_t *a1, TCFURLInfo **a2)
{
  if (!a1[40]) {
    return 0;
  }
  TDeepCFURLIterator::CurrentContainerInfo(a1[4], &v6);
  if (!v6
    || (((uint64_t (*)(void, void, uint64_t))a1[40])(*(void *)*a2, *v6, a1[42]) & 1) != 0
    || TCFURLInfo::IsTrash(*a2))
  {
    ++a1[18];
    uint64_t v4 = 1;
  }
  else
  {
    uint64_t v4 = 0;
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  return v4;
}

void sub_1D348D540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

void TOperationSizer::SetFirstMergeDestinationConflict(uint64_t a1, const TCFURLInfo **a2)
{
  if (!*(void *)(a1 + 288))
  {
    std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo&,void>(*a2, &v5);
    long long v3 = v5;
    long long v5 = 0uLL;
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 296);
    *(_OWORD *)(a1 + 288) = v3;
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      if (*((void *)&v5 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v5 + 1));
      }
    }
  }
}

void TOperationSizer::SetFirstMergeSourceConflict(uint64_t a1, const TCFURLInfo **a2)
{
  if (!*(void *)(a1 + 272))
  {
    std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo&,void>(*a2, &v5);
    long long v3 = v5;
    long long v5 = 0uLL;
    uint64_t v4 = *(std::__shared_weak_count **)(a1 + 280);
    *(_OWORD *)(a1 + 272) = v3;
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      if (*((void *)&v5 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v5 + 1));
      }
    }
  }
}

uint64_t std::unique_ptr<std::unordered_set<unsigned long long>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(result);
    JUMPOUT(0x1D9436740);
  }
  return result;
}

uint64_t *std::unique_ptr<TCloneCache>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  void *result = a2;
  if (v2)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v2 + 48);
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::~__hash_table(v2 + 8);
    JUMPOUT(0x1D9436740);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      long long v3 = (void *)*v2;
      uint64_t v4 = (std::__shared_weak_count *)v2[4];
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

TDeepCFURLIterator *std::unique_ptr<TDeepCFURLIterator>::reset[abi:ne180100](TDeepCFURLIterator **a1, TDeepCFURLIterator *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    TDeepCFURLIterator::~TDeepCFURLIterator(result);
    JUMPOUT(0x1D9436740);
  }
  return result;
}

void *_ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x68uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceI10TCFURLInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1D348D7E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *_ZNSt3__120__shared_ptr_emplaceI10TCFURLInfoNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB0F0;
  TCFURLInfo::TCFURLInfo((TCFURLInfo *)(a1 + 3));
  return a1;
}

void sub_1D348D840(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TCFURLInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB0F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCFURLInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB0F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

const void **std::__shared_ptr_emplace<TCFURLInfo>::__on_zero_shared(uint64_t a1)
{
  return std::__destroy_at[abi:ne180100]<TCFURLInfo,0>(a1 + 24);
}

const void **std::__destroy_at[abi:ne180100]<TCFURLInfo,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  TFileDescriptor::~TFileDescriptor((TFileDescriptor *)(a1 + 32));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 16));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 8));
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)a1);
}

void *std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo&,void>@<X0>(const TCFURLInfo *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = std::__shared_ptr_emplace<TCFURLInfo>::__shared_ptr_emplace[abi:ne180100]<TCFURLInfo&,std::allocator<TCFURLInfo>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1D348D980(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TCFURLInfo>::__shared_ptr_emplace[abi:ne180100]<TCFURLInfo&,std::allocator<TCFURLInfo>,0>(void *a1, const TCFURLInfo *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB0F0;
  TCFURLInfo::TCFURLInfo((TCFURLInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1D348D9DC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1D348DB04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348DB8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D348DDE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id CopyDeepHelper(NSObject *a1, int a2)
{
  long long v3 = a1;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    static_objc_cast<NSString,objc_object * {__strong}>(v3);
    uint64_t v4 = (NSArray *)objc_claimAutoreleasedReturnValue();
    long long v5 = v4;
    if (a2) {
      MutableCopyDeep(v4);
    }
    else {
      CopyDeep(v4);
    }
    uint64_t v8 = LABEL_11:;
    uint64_t v10 = (void *)v8;

    goto LABEL_19;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    static_objc_cast<NSString,objc_object * {__strong}>(v3);
    int v6 = (NSDictionary *)objc_claimAutoreleasedReturnValue();
    long long v5 = v6;
    if (a2) {
      MutableCopyDeep(v6);
    }
    else {
      CopyDeep(v6);
    }
    goto LABEL_11;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    static_objc_cast<NSString,objc_object * {__strong}>(v3);
    TString v7 = (NSSet *)objc_claimAutoreleasedReturnValue();
    long long v5 = v7;
    if (a2) {
      MutableCopyDeep(v7);
    }
    else {
      CopyDeep(v7);
    }
    goto LABEL_11;
  }
  if (a2 && [v3 conformsToProtocol:&unk_1F2AC8B20])
  {
    uint64_t v9 = [v3 mutableCopy];
  }
  else if ([v3 conformsToProtocol:&unk_1F2AC4A10])
  {
    uint64_t v9 = [v3 copy];
  }
  else
  {
    uint64_t v9 = v3;
  }
  uint64_t v10 = v9;
LABEL_19:

  return v10;
}

void sub_1D348DF84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id TNodeEvent::Clone@<X0>(TNodeEvent *this@<X0>, void *a2@<X8>)
{
  id result = [[FINodeEvent alloc] init:this];
  *a2 = result;
  return result;
}

void TNodeEvent::CreatePropertyChangedNodeEvent(id *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
}

id std::vector<TNodeEventPtr>::push_back[abi:ne180100](uint64_t *a1, id *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  TString v7 = *(void **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - *a1;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    v16[4] = v4;
    if (v13) {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    CFStringRef v15 = &v14[8 * v10];
    v16[0] = v14;
    v16[1] = v15;
    v16[3] = &v14[8 * v13];
    *(void *)CFStringRef v15 = *a2;
    v16[2] = v15 + 8;
    std::vector<TNodeEventPtr>::__swap_out_circular_buffer(a1, v16);
    uint64_t v9 = (void *)a1[1];
    id result = (id)std::__split_buffer<TNodeEventPtr>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    id result = *a2;
    void *v7 = result;
    uint64_t v9 = v7 + 1;
    a1[1] = (uint64_t)v9;
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1D348E0F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TNodeEventPtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t TNodeEvent::Notify(TNodeEvent *a1, TDSNotifier **a2, int a3)
{
  if (TNode::IsContextOpen((TNode *)a1))
  {
    TNodeEvent::NotifyCommon(&a1->fEventKind, a2, a3);
    TNodeEvent::ForwardEventToParent(a1);
  }
  return 0;
}

id *std::pair<TNodePtr,TNodeEventPtr>::~pair(id *a1)
{
  id v2 = a1[1];
  a1[1] = 0;

  return a1;
}

void TBlockingEventQueue::~TBlockingEventQueue(TBlockingEventQueue *this)
{
  std::__function::__value_func<void ()(OpaqueEventQueue *)>::~__value_func[abi:ne180100]((void *)this + 23);
  id v2 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 112));
  std::mutex::~mutex((std::mutex *)((char *)this + 48));
  std::deque<TNodeEventPtr>::~deque[abi:ne180100](this);
}

uint64_t std::vector<TNodeEventPtr>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>,std::reverse_iterator<TNodeEventPtr*>,std::reverse_iterator<TNodeEventPtr*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E698F840, MEMORY[0x1E4FBA1C8]);
}

void sub_1D348E2D0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>,std::reverse_iterator<TNodeEventPtr*>,std::reverse_iterator<TNodeEventPtr*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)&long long v18 = a6;
  *((void *)&v18 + 1) = a7;
  long long v17 = v18;
  v15[0] = a1;
  v15[1] = &v17;
  id v15[2] = &v18;
  if (a3 == a5)
  {
    uint64_t v13 = a6;
  }
  else
  {
    uint64_t v8 = a3;
    uint64_t v9 = a7;
    uint64_t v10 = *((void *)&v18 + 1);
    uint64_t v11 = *((void *)&v18 + 1);
    do
    {
      uint64_t v12 = *(void **)(v8 - 8);
      v8 -= 8;
      *(void *)(v9 - 8) = v12;
      v11 -= 8;
      v10 -= 8;
      uint64_t v9 = v11;
    }
    while (v8 != a5);
    *((void *)&v18 + 1) = v11;
    uint64_t v13 = v18;
  }
  char v16 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v15);
  return v13;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<TNodeEventPtr>,std::reverse_iterator<TNodeEventPtr*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v14 = v3;
  uint64_t v15 = v2;
  uint64_t v16 = v3;
  uint64_t v17 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v9 = v7;
  uint64_t v10 = v6;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<TNodeEventPtr>,std::reverse_iterator<std::reverse_iterator<TNodeEventPtr*>>,std::reverse_iterator<std::reverse_iterator<TNodeEventPtr*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<TNodeEventPtr>,std::reverse_iterator<std::reverse_iterator<TNodeEventPtr*>>,std::reverse_iterator<std::reverse_iterator<TNodeEventPtr*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(id **)(a2 + 32); i != *(id **)(a3 + 32); *(void *)(a2 + 32) = i)
  {
    id v6 = *i;
    id *i = 0;

    uint64_t i = (id *)(*(void *)(a2 + 32) + 8);
  }
}

uint64_t std::__split_buffer<TNodeEventPtr>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<TNodeEventPtr>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    id v6 = *(void **)(i - 8);
    uint64_t v5 = (id *)(i - 8);
    *(void *)(a1 + 16) = v5;
    id *v5 = 0;
  }
}

void std::vector<TNodeEventPtr>::__base_destruct_at_end[abi:ne180100](uint64_t a1, id *a2)
{
  for (uint64_t i = *(id **)(a1 + 8); i != a2; *i)
  {
    uint64_t v5 = *--i;
    id *i = 0;
  }
  *(void *)(a1 + 8) = a2;
}

void **std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__move_range(void **result, uint64_t a2, unint64_t a3, unsigned char *a4)
{
  id v6 = result;
  uint64_t v7 = (char *)result[1];
  uint64_t v8 = v7 - a4;
  uint64_t v9 = (id *)(a2 + v7 - a4);
  if ((unint64_t)v9 >= a3)
  {
    uint64_t v11 = result[1];
  }
  else
  {
    uint64_t v11 = result[1];
    do
    {
      TNodePtr::TNodePtr(v11, v9);
      uint64_t result = (void **)v9[1];
      v11[1] = result;
      v9 += 2;
      v11 += 2;
    }
    while ((unint64_t)v9 < a3);
  }
  v6[1] = v11;
  if (v7 != a4)
  {
    uint64_t v12 = (void **)(v7 - 16);
    uint64_t v13 = 16 * (v8 >> 4);
    uint64_t v14 = a2 - 16;
    do
    {
      uint64_t result = std::pair<TNodePtr,TNodeEventPtr>::operator=[abi:ne180100](v12, (void **)(v14 + v13));
      v12 -= 2;
      v13 -= 16;
    }
    while (v13);
  }
  return result;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>,std::pair<TNodePtr,TNodeEventPtr> const*,std::pair<TNodePtr,TNodeEventPtr> const*,std::pair<TNodePtr,TNodeEventPtr>*>(uint64_t a1, id *a2, id *a3, void *a4)
{
  if (a2 != a3)
  {
    id v6 = a2;
    do
    {
      *a4 = *v6;
      a4[1] = v6[1];
      a4 += 2;
      v6 += 2;
    }
    while (v6 != a3);
  }
  return a4;
}

void **std::pair<TNodePtr,TNodeEventPtr>::operator=[abi:ne180100](void **a1, void **a2)
{
  TNodePtr::operator=(a1, a2);
  objc_storeStrong(a1 + 1, a2[1]);
  return a1;
}

id *std::pair<TNodePtr,TNodeEventPtr>::operator=[abi:ne180100](id *a1, id *a2)
{
  return a1;
}

void std::__shared_ptr_emplace<std::mutex>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB438;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::mutex>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB438;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

uint64_t std::deque<TNodeEventPtr>::~deque[abi:ne180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    uint64_t v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }
  else
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    id v6 = &v2[v5 >> 9];
    uint64_t v7 = (void **)((char *)*v6 + 8 * (v5 & 0x1FF));
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((a1[5] + v5) & 0x1FF);
    if (v7 != (void **)v8)
    {
      do
      {
        uint64_t v9 = *v7;
        char *v7 = 0;

        uint64_t v10 = *v7++;
        if ((char *)v7 - (unsigned char *)*v6 == 4096)
        {
          uint64_t v11 = (void **)v6[1];
          ++v6;
          uint64_t v7 = v11;
        }
      }
      while (v7 != (void **)v8);
      uint64_t v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v12 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v12 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v13 = v12 >> 3;
  if (v13 == 1)
  {
    uint64_t v14 = 256;
  }
  else
  {
    if (v13 != 2) {
      goto LABEL_16;
    }
    uint64_t v14 = 512;
  }
  a1[4] = v14;
LABEL_16:
  while (v2 != v3)
  {
    uint64_t v15 = *v2++;
    operator delete(v15);
  }
  return std::__split_buffer<TNodeEventPtr *>::~__split_buffer((uint64_t)a1);
}

uint64_t *TPropertyValue::As<__CFData const*>(uint64_t *result, uint64_t **a2)
{
  int v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_31;
      }
      uint64_t result = *a2;
      break;
    case 1:
      if (v2 != 1) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 2:
      if (v2 != 2) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 3:
      if (v2 != 3) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 4:
      if (v2 != 4) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 5:
      if (v2 != 5) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 6:
      if (v2 != 6) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 7:
      if (v2 != 7) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 8:
      if (v2 != 8) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 9:
      goto LABEL_39;
    case 10:
      if (v2 != 10) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 11:
      if (v2 != 11) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 12:
      if (v2 != 12) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 13:
      if (v2 != 13) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 14:
      if (v2 != 14) {
        goto LABEL_31;
      }
      uint64_t result = (uint64_t *)*result;
      break;
    case 15:
      if (v2 != 15) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 16:
      if (v2 != 16) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 17:
      if (v2 != 17) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 18:
      if (v2 != 18) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 19:
      if (v2 == 19) {
        goto LABEL_39;
      }
      goto LABEL_31;
    case 20:
      if (v2 != 20) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 21:
      if (v2 != 21) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 22:
      if (v2 != 22) {
        goto LABEL_31;
      }
      goto LABEL_39;
    case 23:
      if (v2 != 23) {
LABEL_31:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_39:
      uint64_t result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

void std::__throw_bad_variant_access[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA4F0] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA340], (void (*)(void *))std::bad_variant_access::~bad_variant_access);
}

unint64_t TPropertyValue::As<int>(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2 = a1[4];
  unsigned int v3 = v2;
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_50;
      }
      unsigned int v3 = *a2;
      unint64_t v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 2:
      if (v2 != 2) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 3:
      if (v2 != 3) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 4:
      if (v2 != 4) {
        goto LABEL_50;
      }
      goto LABEL_46;
    case 5:
      if (v2 != 5) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 6:
      if (v2 != 6) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 7:
      if (v2 != 7) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 8:
      if (v2 != 8) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 9:
      goto LABEL_48;
    case 10:
      if (v2 != 10) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 11:
      if (v2 != 11) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 12:
      if (v2 != 12) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 13:
      if (v2 != 13) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 14:
      if (v2 != 14) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 15:
      if (v2 != 15) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 16:
      if (v2 != 16) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 17:
      if (v2 != 17) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 18:
      if (v2 != 18) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 19:
      if (v2 != 19) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 20:
      if (v2 != 20) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 21:
      if (v2 != 21) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 22:
      if (v2 != 22) {
        goto LABEL_50;
      }
LABEL_46:
      unint64_t v4 = 0;
      unsigned int v3 = *a1;
      break;
    case 23:
      if (v2 != 23) {
LABEL_50:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_48:
      unint64_t v4 = 0xFFFFE08E00000000;
      unsigned int v3 = *a2;
      break;
    default:
      unint64_t v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | v3;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unsigned int v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void std::__shared_ptr_emplace<TBlockingEventQueue>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB240;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TBlockingEventQueue>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB240;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<TBlockingEventQueue>::__on_zero_shared(uint64_t a1)
{
}

void std::__split_buffer<TNodeEventPtr *>::push_front(uint64_t a1, void *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    uint64_t v8 = *(unsigned char **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v6, v12);
      unint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v19 = 8 * (v18 >> 3);
        TNodePtr v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)TNodePtr v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        unint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      unint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        unint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    unint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

{
  char *v4;
  char *v5;
  unsigned char *v6;
  unsigned char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(unsigned char **)(a1 + 16);
    uint64_t v7 = *(unsigned char **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = (v7 - v4) >> 2;
      }
      unint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(*(void *)(a1 + 32), v11);
      unint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      uint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        uint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          TNodePtr v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        unint64_t v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      unint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        unint64_t v4 = *(char **)(a1 + 16);
      }
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    unint64_t v5 = *(char **)(a1 + 8);
  }
  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Property const&,0,Property,20ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 20) {
    *a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property const&>(a1, a2);
  }
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABBF50 + v4))(&v6, a1);
  }
  *a1 = *a2;
  a1[4] = 20;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, id *a2)
{
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm13EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm14EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm15EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm16EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm17EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(a2);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm18EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILS1O_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEEEEDcS1Q_DpT0_(uint64_t a1, const void **a2)
{
  return TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef(a2);
}

const void **TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef(const void **a1)
{
  unsigned int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__emplace_unique_key_args<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>(uint64_t a1, void *a2, TDSNotifier **a3)
{
  unint64_t v5 = *a2 >> 4;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      uint64_t v3 = *a2 >> 4;
      if (v5 >= v6) {
        uint64_t v3 = v5 % v6;
      }
    }
    else
    {
      uint64_t v3 = (v6 - 1) & v5;
    }
    uint64_t v8 = *(void **)(*(void *)a1 + 8 * v3);
    if (v8)
    {
      uint64_t v9 = (void *)*v8;
      if (*v8)
      {
        do
        {
          unint64_t v10 = v9[1];
          if (v10 == v5)
          {
            if (v9[2] == *a2) {
              return v9;
            }
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v10 >= v6) {
                v10 %= v6;
              }
            }
            else
            {
              v10 &= v6 - 1;
            }
            if (v10 != v3) {
              break;
            }
          }
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
    }
  }
  std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__construct_node_hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>(a1, *a2 >> 4, a3, (uint64_t)v20);
  float v11 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v12 = *(float *)(a1 + 32);
  if (!v6 || (float)(v12 * (float)v6) < v11)
  {
    BOOL v13 = 1;
    if (v6 >= 3) {
      BOOL v13 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v14 = v13 | (2 * v6);
    unint64_t v15 = vcvtps_u32_f32(v11 / v12);
    if (v14 <= v15) {
      size_t v16 = v15;
    }
    else {
      size_t v16 = v14;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v16);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v5 >= v6) {
        uint64_t v3 = v5 % v6;
      }
      else {
        uint64_t v3 = v5;
      }
    }
    else
    {
      uint64_t v3 = (v6 - 1) & v5;
    }
  }
  uint64_t v17 = *(void **)(*(void *)a1 + 8 * v3);
  if (v17)
  {
    *(void *)v20[0] = *v17;
    void *v17 = v20[0];
  }
  else
  {
    *(void *)v20[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v20[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v20[0])
    {
      unint64_t v18 = *(void *)(*(void *)v20[0] + 8);
      if ((v6 & (v6 - 1)) != 0)
      {
        if (v18 >= v6) {
          v18 %= v6;
        }
      }
      else
      {
        v18 &= v6 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v18) = v20[0];
    }
  }
  uint64_t v9 = (void *)v20[0];
  v20[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>>>>::reset[abi:ne180100]((uint64_t)v20, 0);
  return v9;
}

void sub_1D348F558(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

TDSNotifier *std::__hash_table<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::equal_to<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>,std::allocator<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>>::__construct_node_hash<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, TDSNotifier **a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = operator new(0x18uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  void *v8 = 0;
  v8[1] = a2;
  uint64_t result = *a3;
  v8[2] = *a3;
  if (result) {
    uint64_t result = (TDSNotifier *)TDSNotifier::AddPtrReference(result);
  }
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D348F5D4(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(TDSNotifier ***)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(v2 + 2);
    }
    operator delete(v2);
  }
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::~__func(uint64_t a1)
{
  return a1;
}

void std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::~__func(uint64_t a1)
{
  JUMPOUT(0x1D9436740);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::__clone()
{
  return 0;
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2ABAAD8;
  uint64_t result = MEMORY[0x1D9436FC0](*(void *)(a1 + 8));
  a2[1] = result;
  return result;
}

void std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<void({block_pointer} {__strong})(OpaqueEventQueue *),std::allocator<void({block_pointer} {__strong})(OpaqueEventQueue *)>,void ()(OpaqueEventQueue *)>::target_type()
{
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E698F848, MEMORY[0x1E4FBA1D0]);
}

void sub_1D348F800(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

uint64_t FormatOneDetails<std::string>(const std::string::value_type **a1, std::string *this, uint64_t a3)
{
  uint64_t v3 = a1[1];
  if (v3)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = (unsigned __int8 *)&v3[(void)*a1];
    uint64_t v9 = 1;
    unint64_t v10 = (unsigned __int8 *)*a1;
    while (2)
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        if (*v10 == asc_1D3522C21[i])
        {
          uint64_t v12 = 0;
          uint64_t v9 = 1;
          if (v10 != v8)
          {
            unint64_t v13 = v10 - (unsigned __int8 *)v7;
            if (v10 - (unsigned __int8 *)v7 != -1)
            {
              std::string::append(this, v7, v10 - (unsigned __int8 *)v7);
              unint64_t v14 = a1[1];
              BOOL v15 = (unint64_t)v14 >= v13;
              size_t v16 = &v14[-v13];
              if (!v15) {
LABEL_102:
              }
                std::__throw_out_of_range[abi:ne180100]("string_view::substr");
              *a1 += v13;
              a1[1] = v16;
              ParseFormat(a1, (uint64_t)&v48);
              size_t v17 = v49;
              if (v49)
              {
                switch(v50)
                {
                  case 1u:
                  case 2u:
                  case 3u:
                    goto LABEL_99;
                  case 4u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
                      goto LABEL_103;
                    }
                    unint64_t v18 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v24 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v24 = v49 | 7;
                      }
                      uint64_t v25 = v24 + 1;
                      p_dst = (std::string *)operator new(v24 + 1);
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                      __dst.__r_.__value_.__r.__words[2] = v25 | 0x8000000000000000;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v49;
                      p_dst = &__dst;
                    }
                    memmove(p_dst, v18, v17);
                    p_dst->__r_.__value_.__s.__data_[v17] = 0;
                    std::string::basic_string[abi:ne180100]<0>(&v47, "??? (hex)");
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      unint64_t v26 = &v47;
                    }
                    else {
                      unint64_t v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    }
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = v47.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_94;
                  case 5u:
                    if (*(char *)(a3 + 23) < 0) {
                      std::string::__init_copy_ctor_external(&__dst, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
                    }
                    else {
                      std::string __dst = *(std::string *)a3;
                    }
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &v47);
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      unint64_t v26 = &v47;
                    }
                    else {
                      unint64_t v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    }
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = v47.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_94;
                  case 6u:
                    if (*(char *)(a3 + 23) < 0) {
                      std::string::__init_copy_ctor_external(&__dst, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
                    }
                    else {
                      std::string __dst = *(std::string *)a3;
                    }
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &v47);
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      unint64_t v26 = &v47;
                    }
                    else {
                      unint64_t v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    }
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = v47.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_94;
                  case 7u:
                    DeEscapeFormatFragment((uint64_t)&v48, &v47);
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      unint64_t v22 = &v47;
                    }
                    else {
                      unint64_t v22 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    }
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v23 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v23 = v47.__r_.__value_.__l.__size_;
                    }
                    std::string::append(this, (const std::string::value_type *)v22, v23);
                    goto LABEL_71;
                  case 8u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
LABEL_103:
                    }
                      std::string::__throw_length_error[abi:ne180100]();
                    TNodePtr v20 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v28 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v28 = v49 | 7;
                      }
                      uint64_t v29 = v28 + 1;
                      uint64_t v21 = (std::string *)operator new(v28 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v29 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v49;
                      uint64_t v21 = &__dst;
                    }
                    memmove(v21, v20, v17);
                    v21->__r_.__value_.__s.__data_[v17] = 0;
                    ExtractEmbeddedFormat(&__dst, &v47);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
                    std::string::size_type v30 = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    CFStringRef v31 = &v47;
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    {
                      std::string::size_type v30 = v47.__r_.__value_.__l.__size_;
                      CFStringRef v31 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    }
                    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v31;
                    __p.__r_.__value_.__l.__size_ = v30;
                    FormatDetails<std::string>(&__dst, &__p, a3);
                    uint64_t v32 = (void *)v49;
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    CFStringRef v33 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v35 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v35 = v49 | 7;
                      }
                      uint64_t v36 = v35 + 1;
                      CFIndex v34 = operator new(v35 + 1);
                      v43[1] = v32;
                      unint64_t v44 = v36 | 0x8000000000000000;
                      v43[0] = v34;
                    }
                    else
                    {
                      HIBYTE(v44) = v49;
                      CFIndex v34 = v43;
                      if (!v49) {
                        goto LABEL_59;
                      }
                    }
                    memmove(v34, v33, (size_t)v32);
LABEL_59:
                    *((unsigned char *)v32 + (void)v34) = 0;
                    ExtendedFormatAdaptor((char *)v43, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v38 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v38 = __p.__r_.__value_.__l.__size_;
                    }
                    std::string::append(this, (const std::string::value_type *)p_p, v38);
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p.__r_.__value_.__l.__data_);
                    }
                    if (SHIBYTE(v44) < 0) {
                      operator delete(v43[0]);
                    }
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
LABEL_71:
                    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
                    {
                      int v39 = (void *)v47.__r_.__value_.__r.__words[0];
LABEL_98:
                      operator delete(v39);
                    }
LABEL_99:
                    CFIndex v40 = a1[1];
                    int v41 = &v40[-v49];
                    if ((unint64_t)v40 < v49) {
                      goto LABEL_102;
                    }
                    uint64_t v9 = 0;
                    *a1 += v49;
                    a1[1] = v41;
                    uint64_t v12 = v50;
                    break;
                  default:
                    if (*(char *)(a3 + 23) < 0) {
                      std::string::__init_copy_ctor_external(&__dst, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
                    }
                    else {
                      std::string __dst = *(std::string *)a3;
                    }
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &v47);
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      unint64_t v26 = &v47;
                    }
                    else {
                      unint64_t v26 = (std::string *)v47.__r_.__value_.__r.__words[0];
                    }
                    if ((v47.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(v47.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = v47.__r_.__value_.__l.__size_;
                    }
LABEL_94:
                    std::string::append(this, (const std::string::value_type *)v26, size);
                    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v47.__r_.__value_.__l.__data_);
                    }
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_99;
                    }
                    int v39 = (void *)__dst.__r_.__value_.__r.__words[0];
                    goto LABEL_98;
                }
              }
              else
              {
                uint64_t v12 = 0;
                uint64_t v9 = 2;
              }
            }
          }
          return v9 | (v12 << 32);
        }
      }
      if (++v10 != v8) {
        continue;
      }
      break;
    }
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v9 = 1;
  }
  return v9 | (v12 << 32);
}

void sub_1D348FD8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

void FormatDetails<std::string>(long long *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  memset(&v11, 0, sizeof(v11));
  long long v10 = *a1;
  do
  {
    unint64_t v5 = FormatOneDetails<std::string>((const std::string::value_type **)&v10, &v11, a2);
    if (v5)
    {
      *((unsigned char *)&a3->__r_.__value_.__s + 23) = 0;
      a3->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v5) == 7);
  FormatDetails(&v10, &v9);
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v6 = &v11;
  }
  else {
    unint64_t v6 = (std::string *)v11.__r_.__value_.__r.__words[0];
  }
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v11.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v11.__r_.__value_.__l.__size_;
  }
  uint64_t v8 = std::string::insert(&v9, 0, (const std::string::value_type *)v6, size);
  *a3 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
LABEL_13:
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
}

void sub_1D348FF30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 - 17) < 0) {
    operator delete(*(void **)(v15 - 40));
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1D94366B0](a1 + 128);
  return a1;
}

void *std::string::basic_string[abi:ne180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    unint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    unint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  unint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    size_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    unint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz)
{
  std::vector<int>::size_type v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2) {
      this->__end_ = &this->__begin_[__sz];
    }
  }
  else
  {
    std::vector<int>::__append(this, __sz - v2);
  }
}

void std::vector<TNodePtr>::resize(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 3;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v6 = *a1 + 8 * a2;
      while (v3 != v6)
      {
        std::string::size_type v7 = *(void **)(v3 - 8);
        v3 -= 8;
      }
      a1[1] = v6;
    }
  }
  else
  {
    unint64_t v5 = a2 - v4;
    std::vector<TNodePtr>::__append((uint64_t)a1, v5);
  }
}

uint64_t std::tuple<std::vector<TNodePtr>,std::vector<TString>,std::vector<int>>::~tuple(uint64_t a1)
{
  std::vector<int>::size_type v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  unint64_t v4 = (void **)(a1 + 24);
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&v4);
  unint64_t v4 = (void **)a1;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v4);
  return a1;
}

uint64_t std::vector<TString>::reserve(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t result = a1 + 16;
  if (a2 > (v4 - *(void *)a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = *(void *)(a1 + 8) - *(void *)a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 8 * v6;
    std::vector<TString>::__swap_out_circular_buffer((CFTypeRef *)a1, v7);
    return std::__split_buffer<TString>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1D349037C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TString>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (char *)this->__end_ - (char *)this->__begin_;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)p_end_cap, __n);
    std::string::size_type v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    std::string v9 = (int *)&v6[4 * v8];
    std::vector<int>::pointer begin = this->__begin_;
    std::vector<int>::pointer end = this->__end_;
    uint64_t v12 = v7;
    if (end != this->__begin_)
    {
      uint64_t v12 = v7;
      do
      {
        int v13 = *--end;
        *--uint64_t v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  int64_t v5 = value;
  std::vector<int>::pointer end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<int>::pointer begin = this->__begin_;
    uint64_t v9 = (char *)end - (char *)this->__begin_;
    unint64_t v10 = __n + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)p_end_cap, v13);
      std::vector<int>::pointer begin = this->__begin_;
      std::vector<int>::pointer end = this->__end_;
    }
    else
    {
      unint64_t v14 = 0;
    }
    uint64_t v15 = &v14[4 * v11];
    size_t v16 = (int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    size_t v17 = (int *)&v15[4 * __n];
    while (end != begin)
    {
      int v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a2);
}

void std::vector<TNodePtr>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v4 = a1 + 16;
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    *(void *)(a1 + 8) = v7;
  }
  else
  {
    uint64_t v8 = v7 - *(void *)a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - *(void *)a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    uint64_t v18 = v4;
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = v13;
    uint64_t v15 = &v13[8 * v10];
    size_t v17 = &v13[8 * v12];
    bzero(v15, 8 * a2);
    size_t v16 = &v15[8 * a2];
    std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, &v14);
    std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)&v14);
  }
}

void sub_1D349067C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::vector<int>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,false>(unint64_t result, int *a2, void **a3, uint64_t a4, char a5)
{
  uint64_t i = (int *)result;
LABEL_2:
  uint64_t v10 = a2;
  uint64_t v11 = a2 - 1;
  while (1)
  {
    unint64_t v12 = i;
    uint64_t v13 = (char *)v10 - (char *)i;
    uint64_t v14 = v10 - i;
    if (v6 || !v5)
    {
      switch(v14)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v106 = *(a2 - 1);
          uint64_t v107 = *v12;
          uint64_t v108 = *a3[1];
          int v109 = *(_DWORD *)(v108 + 4 * v106);
          int v110 = *(_DWORD *)(v108 + 4 * v107);
          if (v109 < v110
            || v109 <= v110
            && ((uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v106), (const TString *)(*a3[2] + 8 * v107)),
                 result == -1)
             || !result
             && (unint64_t v200 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v106)),
                 uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v107)),
                 v200 < result)))
          {
            int v111 = *v12;
            *unint64_t v12 = *(a2 - 1);
            *(a2 - 1) = v111;
          }
          break;
        case 3:
          uint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v12, v12 + 1, v11, a3);
          break;
        case 4:
          uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v12, v12 + 1, v12 + 2, v11, a3);
          break;
        case 5:
          uint64_t result = std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,0>(v12, v12 + 1, v12 + 2, v12 + 3, v11, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    v223 = v12;
    if (v13 <= 95) {
      break;
    }
    if (!a4)
    {
      if (v12 == v10) {
        return result;
      }
      int64_t v133 = (unint64_t)(v14 - 2) >> 1;
      int64_t v134 = v133;
      do
      {
        int64_t v135 = v134;
        if (v133 < v134) {
          goto LABEL_193;
        }
        uint64_t v136 = (2 * v134) | 1;
        uint64_t v137 = &v12[v136];
        if (2 * v134 + 2 < v14)
        {
          uint64_t v138 = *v137;
          uint64_t v139 = v137[1];
          uint64_t v140 = *a3[1];
          int v141 = *(_DWORD *)(v140 + 4 * v138);
          int v142 = *(_DWORD *)(v140 + 4 * v139);
          if (v141 < v142
            || v141 <= v142
            && ((uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v138), (const TString *)(*a3[2] + 8 * v139)),
                 int64_t v133 = (unint64_t)(v14 - 2) >> 1,
                 result == -1)
             || !result
             && (unint64_t v143 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v138)),
                 uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v139)),
                 int64_t v133 = (unint64_t)(v14 - 2) >> 1,
                 v143 < result)))
          {
            ++v137;
            uint64_t v136 = 2 * v135 + 2;
          }
        }
        uint64_t v144 = *v137;
        unint64_t v12 = v223;
        uint64_t v145 = v223[v135];
        uint64_t v146 = *a3[1];
        int v147 = *(_DWORD *)(v146 + 4 * v144);
        int v148 = *(_DWORD *)(v146 + 4 * v145);
        if (v147 < v148) {
          goto LABEL_193;
        }
        if (v147 <= v148)
        {
          uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v144), (const TString *)(*a3[2] + 8 * v145));
          int64_t v133 = (unint64_t)(v14 - 2) >> 1;
          if (result == -1) {
            goto LABEL_193;
          }
          if (!result)
          {
            unint64_t v149 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v144));
            uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v145));
            int64_t v133 = (unint64_t)(v14 - 2) >> 1;
            if (v149 < result) {
              goto LABEL_193;
            }
          }
        }
        int v150 = v223[v135];
        v223[v135] = *v137;
        int v219 = v150;
        if (v133 < v136) {
          goto LABEL_192;
        }
        uint64_t v151 = v150;
        uint64_t v216 = v150;
        while (1)
        {
          v152 = v137;
          uint64_t v153 = 2 * v136;
          uint64_t v136 = (2 * v136) | 1;
          uint64_t v137 = &v12[v136];
          uint64_t v154 = v153 + 2;
          if (v153 + 2 < v14)
          {
            uint64_t v155 = *v137;
            uint64_t v156 = v137[1];
            uint64_t v157 = *a3[1];
            int v158 = *(_DWORD *)(v157 + 4 * v155);
            int v159 = *(_DWORD *)(v157 + 4 * v156);
            if (v158 < v159) {
              goto LABEL_177;
            }
            if (v158 <= v159)
            {
              v217 = v152;
              uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v155), (const TString *)(*a3[2] + 8 * v156));
              uint64_t v151 = v216;
              v152 = v217;
              int64_t v133 = (unint64_t)(v14 - 2) >> 1;
              if (result == -1
                || !result
                && (unint64_t v160 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v155)),
                    uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v156)),
                    uint64_t v151 = v216,
                    v152 = v217,
                    int64_t v133 = (unint64_t)(v14 - 2) >> 1,
                    v160 < result))
              {
LABEL_177:
                ++v137;
                uint64_t v136 = v154;
              }
            }
          }
          uint64_t v161 = *v137;
          uint64_t v162 = *a3[1];
          int v163 = *(_DWORD *)(v162 + 4 * v161);
          int v164 = *(_DWORD *)(v162 + 4 * v151);
          if (v163 < v164)
          {
            uint64_t v137 = v152;
            unint64_t v12 = v223;
            goto LABEL_192;
          }
          unint64_t v12 = v223;
          if (v163 <= v164)
          {
            unint64_t v165 = v152;
            uint64_t v166 = v151;
            uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v161), (const TString *)(*a3[2] + 8 * v151));
            if (result)
            {
              int64_t v133 = (unint64_t)(v14 - 2) >> 1;
              uint64_t v151 = v166;
              v152 = v165;
              if (result == -1) {
                break;
              }
              goto LABEL_189;
            }
            unint64_t v167 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v161));
            uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v166));
            int64_t v133 = (unint64_t)(v14 - 2) >> 1;
            uint64_t v151 = v166;
            v152 = v165;
            if (v167 < result) {
              break;
            }
          }
LABEL_189:
          int *v152 = *v137;
          if (v133 < v136) {
            goto LABEL_192;
          }
        }
        uint64_t v137 = v152;
LABEL_192:
        *uint64_t v137 = v219;
LABEL_193:
        int64_t v134 = v135 - 1;
      }
      while (v135);
      uint64_t v168 = (unint64_t)v13 >> 2;
      while (1)
      {
        uint64_t v169 = 0;
        int v221 = *v12;
        uint64_t v170 = v12;
        do
        {
          uint64_t v171 = v170;
          v170 += v169 + 1;
          uint64_t v172 = 2 * v169;
          uint64_t v169 = (2 * v169) | 1;
          uint64_t v173 = v172 + 2;
          if (v172 + 2 < v168)
          {
            uint64_t v174 = *v170;
            uint64_t v175 = v170[1];
            uint64_t v176 = *a3[1];
            int v177 = *(_DWORD *)(v176 + 4 * v174);
            int v178 = *(_DWORD *)(v176 + 4 * v175);
            if (v177 < v178
              || v177 <= v178
              && ((uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v174), (const TString *)(*a3[2] + 8 * v175)),
                   result == -1)
               || !result
               && (unint64_t v179 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v174)),
                   uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v175)),
                   v179 < result)))
            {
              ++v170;
              uint64_t v169 = v173;
            }
          }
          *uint64_t v171 = *v170;
        }
        while (v169 <= (uint64_t)((unint64_t)(v168 - 2) >> 1));
        v180 = a2 - 1;
        BOOL v6 = v170 == --a2;
        if (v6)
        {
          *uint64_t v170 = v221;
        }
        else
        {
          *uint64_t v170 = *v180;
          int *v180 = v221;
          unint64_t v12 = v223;
          uint64_t v181 = (char *)v170 - (char *)v223 + 4;
          if (v181 < 5) {
            goto LABEL_223;
          }
          unint64_t v182 = ((unint64_t)v181 >> 2) - 2;
          unint64_t v183 = v182 >> 1;
          v184 = &v223[v182 >> 1];
          uint64_t v185 = *v184;
          uint64_t v186 = *v170;
          uint64_t v187 = *a3[1];
          int v188 = *(_DWORD *)(v187 + 4 * v185);
          int v189 = *(_DWORD *)(v187 + 4 * v186);
          if (v188 >= v189)
          {
            if (v188 > v189) {
              goto LABEL_223;
            }
            uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v185), (const TString *)(*a3[2] + 8 * v186));
            if (result != -1)
            {
              if (result) {
                goto LABEL_223;
              }
              unint64_t v192 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v185));
              uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v186));
              if (v192 >= result) {
                goto LABEL_223;
              }
            }
          }
          int v190 = *v170;
          *uint64_t v170 = *v184;
          if (v182 >= 2)
          {
            while (1)
            {
              unint64_t v193 = v183 - 1;
              unint64_t v183 = (v183 - 1) >> 1;
              v191 = &v223[v183];
              uint64_t v194 = *v191;
              uint64_t v195 = *a3[1];
              int v196 = *(_DWORD *)(v195 + 4 * v194);
              int v197 = *(_DWORD *)(v195 + 4 * v190);
              if (v196 >= v197)
              {
                if (v196 > v197) {
                  break;
                }
                uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v194), (const TString *)(*a3[2] + 8 * v190));
                if (result != -1)
                {
                  if (result) {
                    break;
                  }
                  unint64_t v198 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v194));
                  uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v190));
                  if (v198 >= result) {
                    break;
                  }
                }
              }
              int *v184 = *v191;
              v184 = &v223[v183];
              if (v193 <= 1) {
                goto LABEL_221;
              }
            }
          }
          v191 = v184;
LABEL_221:
          int *v191 = v190;
        }
        unint64_t v12 = v223;
LABEL_223:
        if (v168-- <= 2) {
          return result;
        }
      }
    }
    unint64_t v15 = (unint64_t)v14 >> 1;
    size_t v16 = &v12[(unint64_t)v14 >> 1];
    if ((unint64_t)v13 < 0x201)
    {
      uint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v16, v12, v11, a3);
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v12, v16, v11, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v12 + 1, v16 - 1, a2 - 2, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v12 + 2, &v12[v15 + 1], a2 - 3, a3);
      uint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v16 - 1, v16, &v12[v15 + 1], a3);
      int v17 = *v12;
      *unint64_t v12 = *v16;
      int *v16 = v17;
    }
    --a4;
    if (a5) {
      goto LABEL_16;
    }
    uint64_t v19 = *(v12 - 1);
    uint64_t v18 = *v12;
    uint64_t v20 = *a3[1];
    int v21 = *(_DWORD *)(v20 + 4 * v19);
    int v22 = *(_DWORD *)(v20 + 4 * v18);
    if (v21 < v22
      || v21 <= v22
      && ((uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v19), (const TString *)(*a3[2] + 8 * v18)),
           result == -1)
       || !result
       && (unint64_t v23 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v19)),
           uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v18)),
           v23 < result)))
    {
LABEL_16:
      uint64_t v24 = 0;
      int v25 = *v12;
      while (1)
      {
        uint64_t v26 = v12[v24 + 1];
        uint64_t v27 = *a3[1];
        int v28 = *(_DWORD *)(v27 + 4 * v26);
        int v29 = *(_DWORD *)(v27 + 4 * v25);
        if (v28 >= v29)
        {
          if (v28 > v29) {
            break;
          }
          CFComparisonResult v30 = TString::StringCompare((TString *)(*a3[2] + 8 * v26), (const TString *)(*a3[2] + 8 * v25));
          if (v30 != kCFCompareLessThan)
          {
            if (v30) {
              break;
            }
            unint64_t v31 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v26));
            if (v31 >= TNodeFromFINode(*(FINode **)(**a3 + 8 * v25))) {
              break;
            }
          }
        }
        ++v24;
      }
      uint64_t v32 = &v12[v24];
      CFStringRef v33 = v32 + 1;
      uint64_t v220 = a4;
      if (!(v24 * 4))
      {
        uint64_t v10 = a2;
        std::string::size_type v38 = a2;
        if (v33 >= a2) {
          goto LABEL_44;
        }
        uint64_t v43 = *v11;
        uint64_t v44 = *a3[1];
        int v45 = *(_DWORD *)(v44 + 4 * v43);
        int v46 = *(_DWORD *)(v44 + 4 * v25);
        std::string::size_type v38 = v11;
        if (v45 < v46) {
          goto LABEL_44;
        }
        std::string::size_type v38 = v11;
        while (2)
        {
          if (v45 > v46)
          {
LABEL_39:
            if (v33 >= v38) {
              goto LABEL_44;
            }
          }
          else
          {
            CFComparisonResult v47 = TString::StringCompare((TString *)(*a3[2] + 8 * v43), (const TString *)(*a3[2] + 8 * v25));
            if (v47)
            {
              if (v47 == kCFCompareLessThan) {
                goto LABEL_44;
              }
              goto LABEL_39;
            }
            unint64_t v48 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v43));
            unint64_t v49 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v25));
            if (v33 >= v38 || v48 < v49) {
              goto LABEL_44;
            }
          }
          uint64_t v50 = *--v38;
          uint64_t v43 = v50;
          uint64_t v51 = *a3[1];
          int v45 = *(_DWORD *)(v51 + 4 * v50);
          int v46 = *(_DWORD *)(v51 + 4 * v25);
          if (v45 < v46) {
            goto LABEL_44;
          }
          continue;
        }
      }
      uint64_t v34 = *v11;
      uint64_t v35 = *a3[1];
      int v36 = *(_DWORD *)(v35 + 4 * v34);
      int v37 = *(_DWORD *)(v35 + 4 * v25);
      std::string::size_type v38 = v11;
      uint64_t v10 = a2;
      if (v36 >= v37)
      {
        std::string::size_type v38 = v11;
        do
        {
          if (v36 <= v37)
          {
            CFComparisonResult v39 = TString::StringCompare((TString *)(*a3[2] + 8 * v34), (const TString *)(*a3[2] + 8 * v25));
            if (v39)
            {
              if (v39 == kCFCompareLessThan) {
                break;
              }
            }
            else
            {
              unint64_t v40 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v34));
              if (v40 < TNodeFromFINode(*(FINode **)(**a3 + 8 * v25))) {
                break;
              }
            }
          }
          uint64_t v41 = *--v38;
          uint64_t v34 = v41;
          uint64_t v42 = *a3[1];
          int v36 = *(_DWORD *)(v42 + 4 * v41);
          int v37 = *(_DWORD *)(v42 + 4 * v25);
        }
        while (v36 >= v37);
      }
LABEL_44:
      if (v33 < v38)
      {
        uint64_t v52 = v32 + 1;
        unint64_t v53 = v38;
        do
        {
          int v54 = *v52;
          *v52++ = *v53;
          *unint64_t v53 = v54;
          while (1)
          {
            uint64_t v55 = *v52;
            uint64_t v56 = *a3[1];
            int v57 = *(_DWORD *)(v56 + 4 * v55);
            int v58 = *(_DWORD *)(v56 + 4 * v25);
            if (v57 >= v58)
            {
              if (v57 > v58) {
                break;
              }
              CFComparisonResult v59 = TString::StringCompare((TString *)(*a3[2] + 8 * v55), (const TString *)(*a3[2] + 8 * v25));
              if (v59 != kCFCompareLessThan)
              {
                if (v59) {
                  break;
                }
                unint64_t v60 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v55));
                if (v60 >= TNodeFromFINode(*(FINode **)(**a3 + 8 * v25))) {
                  break;
                }
              }
            }
            ++v52;
          }
          while (1)
          {
            uint64_t v62 = *--v53;
            uint64_t v61 = v62;
            uint64_t v63 = *a3[1];
            int v64 = *(_DWORD *)(v63 + 4 * v62);
            int v65 = *(_DWORD *)(v63 + 4 * v25);
            if (v64 < v65) {
              break;
            }
            if (v64 <= v65)
            {
              CFComparisonResult v66 = TString::StringCompare((TString *)(*a3[2] + 8 * v61), (const TString *)(*a3[2] + 8 * v25));
              if (v66)
              {
                if (v66 == kCFCompareLessThan) {
                  break;
                }
              }
              else
              {
                unint64_t v67 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v61));
                if (v67 < TNodeFromFINode(*(FINode **)(**a3 + 8 * v25))) {
                  break;
                }
              }
            }
          }
        }
        while (v52 < v53);
        uint64_t v32 = v52 - 1;
        uint64_t v11 = a2 - 1;
      }
      if (v32 != v223) {
        int *v223 = *v32;
      }
      *uint64_t v32 = v25;
      BOOL v5 = v33 >= v38;
      a4 = v220;
      if (v5)
      {
        BOOL v68 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v223, v32, a3);
        uint64_t i = v32 + 1;
        uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(v32 + 1, v10, a3);
        if (result)
        {
          a2 = v32;
          uint64_t i = v223;
          if (v68) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v68) {
          goto LABEL_67;
        }
      }
      else
      {
LABEL_67:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,false>(v223, v32, a3, v220, a5 & 1);
        a5 = 0;
        uint64_t i = v32 + 1;
      }
    }
    else
    {
      int v69 = *v12;
      uint64_t v70 = *v11;
      uint64_t v71 = *a3[1];
      int v72 = *(_DWORD *)(v71 + 4 * v69);
      int v73 = *(_DWORD *)(v71 + 4 * v70);
      if (v72 < v73
        || v72 <= v73
        && ((uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v69), (const TString *)(*a3[2] + 8 * v70)),
             result == -1)
         || !result
         && (unint64_t v78 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v69)),
             uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v70)),
             v78 < result)))
      {
        uint64_t i = v223 + 1;
        uint64_t v74 = v223[1];
        uint64_t v75 = *a3[1];
        int v76 = *(_DWORD *)(v75 + 4 * v69);
        int v77 = *(_DWORD *)(v75 + 4 * v74);
        if (v76 >= v77)
        {
          uint64_t v10 = a2;
          do
          {
            if (v76 <= v77)
            {
              uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v69), (const TString *)(*a3[2] + 8 * v74));
              if (result)
              {
                if (result == -1) {
                  break;
                }
              }
              else
              {
                unint64_t v84 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v69));
                uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v74));
                if (v84 < result) {
                  break;
                }
              }
            }
            uint64_t v85 = i[1];
            ++i;
            uint64_t v74 = v85;
            uint64_t v86 = *a3[1];
            int v76 = *(_DWORD *)(v86 + 4 * v69);
            int v77 = *(_DWORD *)(v86 + 4 * v85);
          }
          while (v76 >= v77);
        }
        else
        {
          uint64_t v10 = a2;
        }
      }
      else
      {
        uint64_t v10 = a2;
        for (uint64_t i = v223 + 1; i < a2; ++i)
        {
          uint64_t v79 = *i;
          uint64_t v80 = *a3[1];
          int v81 = *(_DWORD *)(v80 + 4 * v69);
          int v82 = *(_DWORD *)(v80 + 4 * v79);
          if (v81 < v82) {
            break;
          }
          if (v81 <= v82)
          {
            uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v69), (const TString *)(*a3[2] + 8 * v79));
            if (result)
            {
              if (result == -1) {
                break;
              }
            }
            else
            {
              unint64_t v83 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v69));
              uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v79));
              if (v83 < result) {
                break;
              }
            }
          }
        }
      }
      CFIndex j = v10;
      if (i < v10)
      {
        for (CFIndex j = a2 - 1; ; --j)
        {
          uint64_t v88 = *j;
          uint64_t v89 = *a3[1];
          int v90 = *(_DWORD *)(v89 + 4 * v69);
          int v91 = *(_DWORD *)(v89 + 4 * v88);
          if (v90 >= v91)
          {
            if (v90 > v91) {
              break;
            }
            uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v69), (const TString *)(*a3[2] + 8 * v88));
            if (result != -1)
            {
              if (result) {
                break;
              }
              unint64_t v92 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v69));
              uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v88));
              if (v92 >= result) {
                break;
              }
            }
          }
        }
      }
      while (i < j)
      {
        int v93 = *i;
        int *i = *j;
        int *j = v93;
        while (1)
        {
          uint64_t v95 = i[1];
          ++i;
          uint64_t v94 = v95;
          uint64_t v96 = *a3[1];
          int v97 = *(_DWORD *)(v96 + 4 * v69);
          int v98 = *(_DWORD *)(v96 + 4 * v95);
          if (v97 < v98) {
            break;
          }
          if (v97 <= v98)
          {
            uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v69), (const TString *)(*a3[2] + 8 * v94));
            if (result)
            {
              if (result == -1) {
                goto LABEL_106;
              }
            }
            else
            {
              unint64_t v99 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v69));
              uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v94));
              if (v99 < result) {
                goto LABEL_106;
              }
            }
          }
        }
        while (1)
        {
          do
          {
LABEL_106:
            uint64_t v100 = *--j;
            uint64_t v101 = *a3[1];
            int v102 = *(_DWORD *)(v101 + 4 * v69);
            int v103 = *(_DWORD *)(v101 + 4 * v100);
          }
          while (v102 < v103);
          if (v102 > v103) {
            break;
          }
          uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v69), (const TString *)(*a3[2] + 8 * v100));
          if (result != -1)
          {
            if (result) {
              break;
            }
            unint64_t v104 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v69));
            uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v100));
            if (v104 >= result) {
              break;
            }
          }
        }
      }
      unint64_t v105 = i - 1;
      BOOL v5 = i - 1 >= v223;
      BOOL v6 = i - 1 == v223;
      if (i - 1 != v223) {
        int *v223 = *v105;
      }
      a5 = 0;
      *unint64_t v105 = v69;
      uint64_t v11 = a2 - 1;
    }
  }
  unsigned int v112 = v12 + 1;
  BOOL v114 = v12 == v10 || v112 == v10;
  if ((a5 & 1) == 0)
  {
    if (!v114)
    {
      do
      {
        v201 = v12;
        unint64_t v12 = v112;
        uint64_t v203 = *v201;
        uint64_t v202 = v201[1];
        uint64_t v204 = *a3[1];
        int v205 = *(_DWORD *)(v204 + 4 * v202);
        int v206 = *(_DWORD *)(v204 + 4 * v203);
        if (v205 < v206
          || v205 <= v206
          && ((uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v202), (const TString *)(*a3[2] + 8 * v203)),
               result == -1)
           || !result
           && (unint64_t v215 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v202)),
               uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v203)),
               v215 < result)))
        {
          int v207 = *v12;
          while (1)
          {
            do
            {
              v208 = v201;
              v201[1] = *v201;
              uint64_t v210 = *--v201;
              uint64_t v209 = v210;
              uint64_t v211 = *a3[1];
              int v212 = *(_DWORD *)(v211 + 4 * v207);
              int v213 = *(_DWORD *)(v211 + 4 * v210);
            }
            while (v212 < v213);
            if (v212 > v213) {
              break;
            }
            uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v207), (const TString *)(*a3[2] + 8 * v209));
            if (result != -1)
            {
              if (result) {
                break;
              }
              unint64_t v214 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v207));
              uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v209));
              if (v214 >= result) {
                break;
              }
            }
          }
          int *v208 = v207;
        }
        unsigned int v112 = v12 + 1;
      }
      while (v12 + 1 != a2);
    }
    return result;
  }
  if (v114) {
    return result;
  }
  uint64_t v115 = 0;
  long long v116 = v12;
  while (2)
  {
    int v117 = v116;
    long long v116 = v112;
    uint64_t v119 = *v117;
    uint64_t v118 = v117[1];
    uint64_t v120 = *a3[1];
    int v121 = *(_DWORD *)(v120 + 4 * v118);
    int v122 = *(_DWORD *)(v120 + 4 * v119);
    if (v121 >= v122)
    {
      if (v121 > v122) {
        goto LABEL_156;
      }
      uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v118), (const TString *)(*a3[2] + 8 * v119));
      if (result != -1)
      {
        if (result) {
          goto LABEL_156;
        }
        unint64_t v132 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v118));
        uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v119));
        if (v132 >= result) {
          goto LABEL_156;
        }
      }
    }
    int v123 = v117[1];
    v117[1] = *v117;
    char v124 = v12;
    if (v117 == v12) {
      goto LABEL_155;
    }
    uint64_t v125 = v115;
    while (2)
    {
      int v126 = (int *)((char *)v12 + v125);
      uint64_t v127 = (int)*(v126 - 1);
      uint64_t v128 = *a3[1];
      int v129 = *(_DWORD *)(v128 + 4 * v123);
      int v130 = *(_DWORD *)(v128 + 4 * v127);
      if (v129 < v130) {
        goto LABEL_146;
      }
      if (v129 > v130) {
        goto LABEL_153;
      }
      uint64_t result = TString::StringCompare((TString *)(*a3[2] + 8 * v123), (const TString *)(*a3[2] + 8 * v127));
      if (result == -1)
      {
LABEL_146:
        --v117;
        *int v126 = *(v126 - 1);
        v125 -= 4;
        unint64_t v12 = v223;
        if (!v125)
        {
          char v124 = v223;
          goto LABEL_155;
        }
        continue;
      }
      break;
    }
    if (!result)
    {
      unint64_t v131 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v123));
      uint64_t result = TNodeFromFINode(*(FINode **)(**a3 + 8 * v127));
      if (v131 >= result)
      {
LABEL_153:
        char v124 = v117;
        unint64_t v12 = v223;
        goto LABEL_155;
      }
      goto LABEL_146;
    }
    unint64_t v12 = v223;
    char v124 = (int *)((char *)v223 + v125);
LABEL_155:
    int *v124 = v123;
LABEL_156:
    unsigned int v112 = v116 + 1;
    v115 += 4;
    if (v116 + 1 != a2) {
      continue;
    }
    return result;
  }
}

unint64_t std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,0>(int *a1, int *a2, int *a3, int *a4, int *a5, void **a6)
{
  unint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a2, a3, a4, a6);
  uint64_t v13 = *a5;
  uint64_t v14 = *a4;
  uint64_t v15 = *a6[1];
  int v16 = *(_DWORD *)(v15 + 4 * v13);
  int v17 = *(_DWORD *)(v15 + 4 * v14);
  if (v16 < v17
    || v16 <= v17
    && ((unint64_t result = TString::StringCompare((TString *)(*a6[2] + 8 * v13), (const TString *)(*a6[2] + 8 * v14)),
         result == -1)
     || !result
     && (unint64_t v37 = TNodeFromFINode(*(FINode **)(**a6 + 8 * v13)),
         unint64_t result = TNodeFromFINode(*(FINode **)(**a6 + 8 * v14)),
         v37 < result)))
  {
    int v18 = *a4;
    *a4 = *a5;
    *a5 = v18;
    uint64_t v19 = *a4;
    uint64_t v20 = *a3;
    uint64_t v21 = *a6[1];
    int v22 = *(_DWORD *)(v21 + 4 * v19);
    int v23 = *(_DWORD *)(v21 + 4 * v20);
    if (v22 < v23
      || v22 <= v23
      && ((unint64_t result = TString::StringCompare((TString *)(*a6[2] + 8 * v19), (const TString *)(*a6[2] + 8 * v20)),
           result == -1)
       || !result
       && (unint64_t v38 = TNodeFromFINode(*(FINode **)(**a6 + 8 * v19)),
           unint64_t result = TNodeFromFINode(*(FINode **)(**a6 + 8 * v20)),
           v38 < result)))
    {
      int v24 = *a3;
      *a3 = *a4;
      *a4 = v24;
      uint64_t v25 = *a3;
      uint64_t v26 = *a2;
      uint64_t v27 = *a6[1];
      int v28 = *(_DWORD *)(v27 + 4 * v25);
      int v29 = *(_DWORD *)(v27 + 4 * v26);
      if (v28 < v29
        || v28 <= v29
        && ((unint64_t result = TString::StringCompare((TString *)(*a6[2] + 8 * v25), (const TString *)(*a6[2] + 8 * v26)),
             result == -1)
         || !result
         && (unint64_t v39 = TNodeFromFINode(*(FINode **)(**a6 + 8 * v25)),
             unint64_t result = TNodeFromFINode(*(FINode **)(**a6 + 8 * v26)),
             v39 < result)))
      {
        int v30 = *a2;
        *a2 = *a3;
        *a3 = v30;
        uint64_t v31 = *a2;
        uint64_t v32 = *a1;
        uint64_t v33 = *a6[1];
        int v34 = *(_DWORD *)(v33 + 4 * v31);
        int v35 = *(_DWORD *)(v33 + 4 * v32);
        if (v34 < v35
          || v34 <= v35
          && ((unint64_t result = TString::StringCompare((TString *)(*a6[2] + 8 * v31), (const TString *)(*a6[2] + 8 * v32)),
               result == -1)
           || !result
           && (unint64_t v40 = TNodeFromFINode(*(FINode **)(**a6 + 8 * v31)),
               unint64_t result = TNodeFromFINode(*(FINode **)(**a6 + 8 * v32)),
               v40 < result)))
        {
          int v36 = *a1;
          *a1 = *a2;
          *a2 = v36;
        }
      }
    }
  }
  return result;
}

int *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(int *result, int *a2, int *a3, void **a4)
{
  BOOL v6 = a2;
  uint64_t v7 = result;
  uint64_t v8 = *a2;
  uint64_t v9 = *result;
  uint64_t v10 = *a4[1];
  int v11 = *(_DWORD *)(v10 + 4 * v8);
  int v12 = *(_DWORD *)(v10 + 4 * v9);
  if (v11 < v12
    || v11 <= v12
    && ((unint64_t result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v8), (const TString *)(*a4[2] + 8 * v9)),
         result == (int *)-1)
     || !result
     && (unint64_t v25 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v8)),
         unint64_t result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v9)),
         v25 < (unint64_t)result)))
  {
    uint64_t v13 = *a3;
    uint64_t v14 = *v6;
    uint64_t v15 = *a4[1];
    int v16 = *(_DWORD *)(v15 + 4 * v13);
    int v17 = *(_DWORD *)(v15 + 4 * v14);
    if (v16 >= v17)
    {
      if (v16 > v17
        || (unint64_t result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v13), (const TString *)(*a4[2] + 8 * v14)),
            result != (int *)-1)
        && (result
         || (unint64_t v18 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v13)),
             unint64_t result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v14)),
             v18 >= (unint64_t)result)))
      {
        uint64_t v19 = *v7;
        int *v7 = *v6;
        int *v6 = v19;
        uint64_t v20 = *a3;
        uint64_t v21 = *a4[1];
        int v22 = *(_DWORD *)(v21 + 4 * v20);
        int v23 = *(_DWORD *)(v21 + 4 * v19);
        if (v22 >= v23)
        {
          if (v22 > v23) {
            return result;
          }
          unint64_t result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v20), (const TString *)(*a4[2] + 8 * v19));
          if (result != (int *)-1)
          {
            if (result) {
              return result;
            }
            unint64_t v39 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v20));
            unint64_t result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v19));
            uint64_t v7 = v6;
            BOOL v6 = a3;
            if (v39 >= (unint64_t)result) {
              return result;
            }
LABEL_10:
            int v24 = *v7;
            int *v7 = *v6;
            int *v6 = v24;
            return result;
          }
        }
        uint64_t v7 = v6;
      }
    }
    BOOL v6 = a3;
    goto LABEL_10;
  }
  uint64_t v26 = *a3;
  uint64_t v27 = *v6;
  uint64_t v28 = *a4[1];
  int v29 = *(_DWORD *)(v28 + 4 * v26);
  int v30 = *(_DWORD *)(v28 + 4 * v27);
  if (v29 < v30
    || v29 <= v30
    && ((unint64_t result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v26), (const TString *)(*a4[2] + 8 * v27)),
         result == (int *)-1)
     || !result
     && (unint64_t v38 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v26)),
         unint64_t result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v27)),
         v38 < (unint64_t)result)))
  {
    int v31 = *v6;
    int *v6 = *a3;
    *a3 = v31;
    uint64_t v32 = *v6;
    uint64_t v33 = *v7;
    uint64_t v34 = *a4[1];
    int v35 = *(_DWORD *)(v34 + 4 * v32);
    int v36 = *(_DWORD *)(v34 + 4 * v33);
    if (v35 < v36) {
      goto LABEL_10;
    }
    if (v35 <= v36)
    {
      unint64_t result = (int *)TString::StringCompare((TString *)(*a4[2] + 8 * v32), (const TString *)(*a4[2] + 8 * v33));
      if (result == (int *)-1) {
        goto LABEL_10;
      }
      if (!result)
      {
        unint64_t v37 = TNodeFromFINode(*(FINode **)(**a4 + 8 * v32));
        unint64_t result = (int *)TNodeFromFINode(*(FINode **)(**a4 + 8 * v33));
        if (v37 < (unint64_t)result) {
          goto LABEL_10;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(int *a1, int *a2, void **a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      uint64_t v10 = *a3[1];
      int v11 = *(_DWORD *)(v10 + 4 * v8);
      int v12 = *(_DWORD *)(v10 + 4 * v9);
      if (v11 < v12) {
        goto LABEL_3;
      }
      if (v11 > v12) {
        return result;
      }
      CFComparisonResult v35 = TString::StringCompare((TString *)(*a3[2] + 8 * v8), (const TString *)(*a3[2] + 8 * v9));
      if (v35 == kCFCompareLessThan
        || v35 == kCFCompareEqualTo
        && (unint64_t v36 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v8)), v36 < TNodeFromFINode(*(FINode **)(**a3 + 8 * v9))))
      {
LABEL_3:
        int v13 = *a1;
        *a1 = *(v4 - 1);
        *(v4 - 1) = v13;
        return 1;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v14 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a1 + 1, a1 + 2, a3);
      uint64_t v15 = a1 + 3;
      if (a1 + 3 == v4) {
        return 1;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      unint64_t v37 = v4;
      break;
  }
  while (1)
  {
    uint64_t v18 = *v15;
    uint64_t v19 = *v14;
    uint64_t v20 = *a3[1];
    int v21 = *(_DWORD *)(v20 + 4 * v18);
    int v22 = *(_DWORD *)(v20 + 4 * v19);
    if (v21 < v22
      || v21 <= v22
      && ((CFComparisonResult v33 = TString::StringCompare((TString *)(*a3[2] + 8 * v18), (const TString *)(*a3[2] + 8 * v19)),
           v33 == kCFCompareLessThan)
       || v33 == kCFCompareEqualTo
       && (unint64_t v34 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v18)), v34 < TNodeFromFINode(*(FINode **)(**a3 + 8 * v19)))))
    {
      int v23 = *v15;
      *uint64_t v15 = *v14;
      int v24 = a1;
      if (v14 != a1)
      {
        int v38 = v23;
        uint64_t v25 = v23;
        uint64_t v26 = v16;
        while (1)
        {
          uint64_t v27 = *(int *)((char *)a1 + v26 + 4);
          uint64_t v28 = *a3[1];
          int v29 = *(_DWORD *)(v28 + 4 * v25);
          int v30 = *(_DWORD *)(v28 + 4 * v27);
          if (v29 >= v30)
          {
            if (v29 > v30) {
              goto LABEL_22;
            }
            CFComparisonResult v31 = TString::StringCompare((TString *)(*a3[2] + 8 * v25), (const TString *)(*a3[2] + 8 * v27));
            if (v31 != kCFCompareLessThan)
            {
              if (v31)
              {
LABEL_22:
                int v24 = v14;
                goto LABEL_24;
              }
              unint64_t v32 = TNodeFromFINode(*(FINode **)(**a3 + 8 * v25));
              if (v32 >= TNodeFromFINode(*(FINode **)(**a3 + 8 * v27))) {
                break;
              }
            }
          }
          --v14;
          *(int *)((char *)a1 + v26 + 8) = *(int *)((char *)a1 + v26 + 4);
          v26 -= 4;
          if (v26 == -8)
          {
            int v24 = a1;
            goto LABEL_24;
          }
        }
        int v24 = (int *)((char *)a1 + v26 + 8);
LABEL_24:
        uint64_t v4 = v37;
        int v23 = v38;
      }
      *int v24 = v23;
      if (++v17 == 8) {
        return v15 + 1 == v4;
      }
    }
    uint64_t v14 = v15;
    v16 += 4;
    if (++v15 == v4) {
      return 1;
    }
  }
}

unint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(int *a1, int *a2, int *a3, int *a4, void **a5)
{
  unint64_t result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TNodeIterator::TNodeIterator(TNodePtr const&,BOOL,BOOL,BOOL)::$_0 &,int *>(a1, a2, a3, a5);
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  uint64_t v13 = *a5[1];
  int v14 = *(_DWORD *)(v13 + 4 * v11);
  int v15 = *(_DWORD *)(v13 + 4 * v12);
  if (v14 < v15
    || v14 <= v15
    && ((unint64_t result = TString::StringCompare((TString *)(*a5[2] + 8 * v11), (const TString *)(*a5[2] + 8 * v12)),
         result == -1)
     || !result
     && (unint64_t v29 = TNodeFromFINode(*(FINode **)(**a5 + 8 * v11)),
         unint64_t result = TNodeFromFINode(*(FINode **)(**a5 + 8 * v12)),
         v29 < result)))
  {
    int v16 = *a3;
    *a3 = *a4;
    *a4 = v16;
    uint64_t v17 = *a3;
    uint64_t v18 = *a2;
    uint64_t v19 = *a5[1];
    int v20 = *(_DWORD *)(v19 + 4 * v17);
    int v21 = *(_DWORD *)(v19 + 4 * v18);
    if (v20 < v21
      || v20 <= v21
      && ((unint64_t result = TString::StringCompare((TString *)(*a5[2] + 8 * v17), (const TString *)(*a5[2] + 8 * v18)),
           result == -1)
       || !result
       && (unint64_t v30 = TNodeFromFINode(*(FINode **)(**a5 + 8 * v17)),
           unint64_t result = TNodeFromFINode(*(FINode **)(**a5 + 8 * v18)),
           v30 < result)))
    {
      int v22 = *a2;
      *a2 = *a3;
      *a3 = v22;
      uint64_t v23 = *a2;
      uint64_t v24 = *a1;
      uint64_t v25 = *a5[1];
      int v26 = *(_DWORD *)(v25 + 4 * v23);
      int v27 = *(_DWORD *)(v25 + 4 * v24);
      if (v26 < v27
        || v26 <= v27
        && ((unint64_t result = TString::StringCompare((TString *)(*a5[2] + 8 * v23), (const TString *)(*a5[2] + 8 * v24)),
             result == -1)
         || !result
         && (unint64_t v31 = TNodeFromFINode(*(FINode **)(**a5 + 8 * v23)),
             unint64_t result = TNodeFromFINode(*(FINode **)(**a5 + 8 * v24)),
             v31 < result)))
      {
        int v28 = *a1;
        *a1 = *a2;
        *a2 = v28;
      }
    }
  }
  return result;
}

uint64_t CopyBlob(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return 0;
  }
  if (!*(void *)(a1 + 8)) {
    return 4294959224;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 4) = v6;
  if (!v6) {
    return 0;
  }
  unsigned int v7 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 < v6 && *(void *)(a3 + 24) != 0)
  {
    std::function<void ()(Blob &,unsigned int)>::operator()(a3, a2, v6);
    unsigned int v7 = *(_DWORD *)a2;
    unsigned int v6 = *(_DWORD *)(a2 + 4);
  }
  if (v6 <= v7)
  {
    uint64_t v9 = *(const void **)(a1 + 8);
    if (v9)
    {
      uint64_t v10 = *(void **)(a2 + 8);
      if (v10)
      {
        memcpy(v10, v9, v6);
        return 0;
      }
    }
  }
  return 4294959233;
}

uint64_t std::function<void ()(Blob &,unsigned int)>::operator()(uint64_t a1, uint64_t a2, int a3)
{
  int v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)v3 + 48))(v3, a2, &v5);
}

BOOL TPropertyReference::IsValid(TPropertyReference *this)
{
  return !this || *((_DWORD *)this + 2) != 0;
}

void TPropertyReference::Clear(void ***this)
{
  int v1 = *((_DWORD *)this + 2);
  switch((char)v1)
  {
    case 10:
      if (v1 != 10) {
        goto LABEL_11;
      }
      std::vector<int>::size_type v2 = *this;
      uint64_t v3 = **this;
      void *v2 = 0;

      break;
    case 12:
      if (v1 == 12) {
        goto LABEL_7;
      }
      goto LABEL_11;
    case 13:
      if (v1 != 13) {
        goto LABEL_11;
      }
      goto LABEL_7;
    case 14:
      if (v1 != 14) {
        goto LABEL_11;
      }
      goto LABEL_7;
    case 15:
      if (v1 != 15) {
        goto LABEL_11;
      }
      goto LABEL_7;
    case 16:
      if (v1 != 16) {
        goto LABEL_11;
      }
      goto LABEL_7;
    case 17:
      if (v1 != 17) {
        goto LABEL_11;
      }
      goto LABEL_7;
    case 18:
      if (v1 != 18) {
LABEL_11:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_7:
      uint64_t v4 = *this;
      int v5 = **this;
      if (v5) {
        CFRelease(v5);
      }
      int *v4 = 0;
      break;
    default:
      return;
  }
}

void TPropertyValue::TPropertyValue(TPropertyValue *this, const TPropertyReference *a2)
{
  this->fData.__impl_.__unsigned int index = 0;
  int v2 = *((_DWORD *)a2 + 2);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<BOOL>((uint64_t)this, *(unsigned char **)a2);
      break;
    case 2:
      if (v2 != 2) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<unsigned char>((uint64_t)this, *(unsigned char **)a2);
      break;
    case 3:
      if (v2 != 3) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<short>((uint64_t)this, *(_WORD **)a2);
      break;
    case 4:
      if (v2 != 4) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<int>(this, *(_DWORD **)a2);
      break;
    case 5:
      if (v2 != 5) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<long long>((uint64_t)this, *(void **)a2);
      break;
    case 6:
      if (v2 != 6) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<unsigned int>(this, *(_DWORD **)a2);
      break;
    case 7:
      if (v2 != 7) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<double>((uint64_t)this, *(void **)a2);
      break;
    case 8:
      if (v2 != 8) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<Point>(this, *(_DWORD **)a2);
      break;
    case 9:
      if (v2 != 9) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<Blob>(this, *(Blob **)a2);
      break;
    case 10:
      if (v2 != 10) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<NSObject * {__strong}>((id *)this, *(id **)a2);
      break;
    case 11:
      if (v2 != 11) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<TString>((uint64_t)this, *(TString **)a2);
      break;
    case 12:
      if (v2 != 12) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>((uint64_t)this, *(const void ***)a2);
      break;
    case 13:
      if (v2 != 13) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>((uint64_t)this, *(const void ***)a2);
      break;
    case 14:
      if (v2 != 14) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>((uint64_t)this, *(const void ***)a2);
      break;
    case 15:
      if (v2 != 15) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>((uint64_t)this, *(const void ***)a2);
      break;
    case 16:
      if (v2 != 16) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>((uint64_t)this, *(const void ***)a2);
      break;
    case 17:
      if (v2 != 17) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>((uint64_t)this, *(const void ***)a2);
      break;
    case 18:
      if (v2 != 18) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>((uint64_t)this, *(const void ***)a2);
      break;
    case 19:
      if (v2 != 19) {
        goto LABEL_50;
      }
      uint64_t v3 = *(TPropertyValue **)a2;
      if (v3 != this) {
        TPropertyValue::CopyFrom(this, v3);
      }
      break;
    case 20:
      if (v2 != 20) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<Property>(this, *(_DWORD **)a2);
      break;
    case 21:
      if (v2 != 21) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<NodeRequestOptions>(this, *(_DWORD **)a2);
      break;
    case 22:
      if (v2 != 22) {
        goto LABEL_50;
      }
      TPropertyValue::SetAs<NodeDSStoreStatus>(this, *(_DWORD **)a2);
      break;
    case 23:
      if (v2 != 23) {
LABEL_50:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      TPropertyValue::SetAs<DSBladeRunnerFlags>(this, *(_DWORD **)a2);
      break;
    default:
      return;
  }
}

void sub_1D3492788(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::SetAs<BOOL>(uint64_t a1, unsigned char *a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<BOOL const&,0,BOOL,1ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_9;
      }
      uint64_t result = 0;
      *(unsigned char *)a1 = *a2;
      break;
    case 2:
      if (v2 == 2) {
        goto LABEL_7;
      }
      goto LABEL_9;
    case 3:
      if (v2 != 3) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 4:
      if (v2 != 4) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 5:
      if (v2 != 5) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 6:
      if (v2 != 6) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 7:
      if (v2 != 7) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 8:
      if (v2 != 8) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 9:
      goto LABEL_7;
    case 10:
      if (v2 != 10) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 11:
      if (v2 != 11) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 12:
      if (v2 != 12) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 13:
      if (v2 != 13) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 14:
      if (v2 != 14) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 15:
      if (v2 != 15) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 16:
      if (v2 != 16) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 17:
      if (v2 != 17) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 18:
      if (v2 != 18) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 19:
      if (v2 != 19) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 20:
      if (v2 != 20) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 21:
      if (v2 != 21) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 22:
      if (v2 != 22) {
        goto LABEL_9;
      }
      goto LABEL_7;
    case 23:
      if (v2 != 23) {
LABEL_9:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_7:
      uint64_t result = 4294959246;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<unsigned char>(uint64_t a1, unsigned char *a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<unsigned char const&,0,unsigned char,2ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 2:
      if (v2 != 2) {
        goto LABEL_11;
      }
      uint64_t result = 0;
      *(unsigned char *)a1 = *a2;
      break;
    case 3:
      if (v2 == 3) {
        goto LABEL_9;
      }
      goto LABEL_11;
    case 4:
      if (v2 != 4) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 5:
      if (v2 != 5) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 6:
      if (v2 != 6) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 7:
      if (v2 != 7) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 8:
      if (v2 != 8) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 9:
      goto LABEL_9;
    case 10:
      if (v2 != 10) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 11:
      if (v2 != 11) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 12:
      if (v2 != 12) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 13:
      if (v2 != 13) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 14:
      if (v2 != 14) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 15:
      if (v2 != 15) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 16:
      if (v2 != 16) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 17:
      if (v2 != 17) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 18:
      if (v2 != 18) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 19:
      if (v2 != 19) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 20:
      if (v2 != 20) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 21:
      if (v2 != 21) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 22:
      if (v2 != 22) {
        goto LABEL_11;
      }
      goto LABEL_9;
    case 23:
      if (v2 != 23) {
LABEL_11:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_9:
      uint64_t result = 4294959246;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<short>(uint64_t a1, _WORD *a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<short const&,0,short,3ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 2:
      if (v2 != 2) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 3:
      if (v2 != 3) {
        goto LABEL_43;
      }
      uint64_t result = 0;
      *(_WORD *)a1 = *a2;
      return result;
    case 4:
      if (v2 != 4) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 5:
      if (v2 != 5) {
        goto LABEL_43;
      }
      uint64_t result = 0;
      *(void *)a1 = (__int16)*a2;
      return result;
    case 6:
      if (v2 != 6) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 7:
      if (v2 != 7) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 8:
      if (v2 != 8) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 11:
      if (v2 != 11) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 12:
      if (v2 != 12) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 13:
      if (v2 != 13) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 14:
      if (v2 != 14) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 15:
      if (v2 != 15) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 16:
      if (v2 != 16) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 17:
      if (v2 != 17) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 18:
      if (v2 != 18) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 19:
      if (v2 != 19) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 20:
      if (v2 != 20) {
        goto LABEL_43;
      }
LABEL_41:
      uint64_t result = 4294959246;
      break;
    case 21:
      if (v2 != 21) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 23:
      if (v2 != 23) {
LABEL_43:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      uint64_t result = 0;
      *(_DWORD *)a1 = (__int16)*a2;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<int>(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<int const&,0,int,4ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 2:
      if (v2 != 2) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 3:
      if (v2 != 3) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 4:
      if (v2 != 4) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 5:
      if (v2 != 5) {
        goto LABEL_43;
      }
      uint64_t result = 0;
      *(void *)a1 = (int)*a2;
      return result;
    case 6:
      if (v2 != 6) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 7:
      if (v2 != 7) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 8:
      if (v2 != 8) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 11:
      if (v2 != 11) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 12:
      if (v2 != 12) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 13:
      if (v2 != 13) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 14:
      if (v2 != 14) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 15:
      if (v2 != 15) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 16:
      if (v2 != 16) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 17:
      if (v2 != 17) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 18:
      if (v2 != 18) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 19:
      if (v2 != 19) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 20:
      if (v2 != 20) {
        goto LABEL_43;
      }
LABEL_41:
      uint64_t result = 4294959246;
      break;
    case 21:
      if (v2 != 21) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 23:
      if (v2 != 23) {
LABEL_43:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      uint64_t result = 0;
      *a1 = *a2;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<long long>(uint64_t a1, void *a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<long long const&,0,long long,5ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 2:
      if (v2 != 2) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 3:
      if (v2 != 3) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 4:
      if (v2 != 4) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 5:
      if (v2 != 5) {
        goto LABEL_48;
      }
      uint64_t result = 0;
      *(void *)a1 = *a2;
      return result;
    case 6:
      if (v2 != 6) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 7:
      if (v2 != 7) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 8:
      if (v2 != 8) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 9:
      goto LABEL_45;
    case 10:
      if (v2 != 10) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 11:
      if (v2 != 11) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 12:
      if (v2 != 12) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 13:
      if (v2 != 13) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 14:
      if (v2 != 14) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 15:
      if (v2 != 15) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 16:
      if (v2 != 16) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 17:
      if (v2 != 17) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 18:
      if (v2 != 18) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 19:
      if (v2 != 19) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 20:
      if (v2 != 20) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_48;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_48;
      }
LABEL_45:
      uint64_t result = 4294959246;
      break;
    case 23:
      if (v2 != 23) {
LABEL_48:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      uint64_t result = 0;
      *(_DWORD *)a1 = *a2;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<unsigned int>(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<unsigned int const&,0,unsigned int,6ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      goto LABEL_41;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 9:
      goto LABEL_43;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 20:
      if (v2 != 20) {
        goto LABEL_45;
      }
LABEL_41:
      uint64_t result = 0;
      *a1 = *a2;
      break;
    case 21:
      if (v2 == 21) {
        goto LABEL_43;
      }
      goto LABEL_45;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_43:
      uint64_t result = 4294959246;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<Point>(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Point const&,0,Point,8ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 2:
      if (v2 != 2) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 3:
      if (v2 != 3) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 4:
      if (v2 != 4) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 5:
      if (v2 != 5) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 6:
      if (v2 != 6) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 7:
      if (v2 != 7) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 8:
      if (v2 != 8) {
        goto LABEL_39;
      }
      uint64_t result = 0;
      *a1 = *a2;
      break;
    case 9:
      goto LABEL_23;
    case 10:
      if (v2 != 10) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 11:
      if (v2 == 11) {
        goto LABEL_23;
      }
      goto LABEL_39;
    case 12:
      if (v2 != 12) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 13:
      if (v2 != 13) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 14:
      if (v2 != 14) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 15:
      if (v2 != 15) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 16:
      if (v2 != 16) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 17:
      if (v2 != 17) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 18:
      if (v2 != 18) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 19:
      if (v2 != 19) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 20:
      if (v2 != 20) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 21:
      if (v2 != 21) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 22:
      if (v2 != 22) {
        goto LABEL_39;
      }
      goto LABEL_23;
    case 23:
      if (v2 != 23) {
LABEL_39:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_23:
      uint64_t result = 4294959246;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<TString>(uint64_t a1, TString *a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(a1, (TString *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_28;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_28;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_28;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_28;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_28;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_28;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_28;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_28;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_28;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_28;
      }
      if ((TString *)a1 != a2) {
        TString::SetStringRefAsImmutable((TString *)a1, (TString *)a2->fString.fRef);
      }
      return 0;
    case 12:
      if (v2 != 12) {
        goto LABEL_28;
      }
      uint64_t v4 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
      if (v4)
      {
        CFTypeRef v5 = CFAutorelease(v4);
        unsigned int v6 = static_cf_cast<__CFString const*,void const*>(v5);
      }
      else
      {
        unsigned int v6 = 0;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, v6);
      return 0;
    case 13:
      if (v2 != 13) {
        goto LABEL_28;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_28;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_28;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_28;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_28;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_28;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_28;
    case 20:
      if (v2 != 20) {
        goto LABEL_28;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_28;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_28;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_28:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<Blob>(TPropertyValue *this, Blob *a2)
{
  unsigned int index = this->fData.__impl_.__index;
  switch((char)index)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Blob const&,0,Blob,9ul,0>((uint64_t)this, &kEmptyBlob);
      TPropertyValue::CopyBlob(this, a2);
      goto LABEL_3;
    case 1:
      if (index == 1) {
        goto LABEL_5;
      }
      goto LABEL_7;
    case 2:
      if (index != 2) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 3:
      if (index != 3) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 4:
      if (index != 4) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 5:
      if (index != 5) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 6:
      if (index != 6) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 7:
      if (index != 7) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 8:
      if (index != 8) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 9:
      return TPropertyValue::CopyBlob(this, a2);
    case 10:
      if (index != 10) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 11:
      if (index != 11) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 12:
      if (index != 12) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 13:
      if (index != 13) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 14:
      if (index != 14) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 15:
      if (index != 15) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 16:
      if (index != 16) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 17:
      if (index != 17) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 18:
      if (index != 18) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 19:
      if (index != 19) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 20:
      if (index != 20) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 21:
      if (index != 21) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 22:
      if (index != 22) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 23:
      if (index != 23) {
LABEL_7:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_5:
      uint64_t result = 4294959246;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<double>(uint64_t a1, void *a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<double const&,0,double,7ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 2:
      if (v2 != 2) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 3:
      if (v2 != 3) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 4:
      if (v2 != 4) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 5:
      if (v2 != 5) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 6:
      if (v2 != 6) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 7:
      if (v2 != 7) {
        goto LABEL_23;
      }
      uint64_t result = 0;
      *(void *)a1 = *a2;
      break;
    case 8:
      if (v2 == 8) {
        goto LABEL_19;
      }
      goto LABEL_23;
    case 9:
      goto LABEL_19;
    case 10:
      if (v2 != 10) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 11:
      if (v2 != 11) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 12:
      if (v2 != 12) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 13:
      if (v2 != 13) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 14:
      if (v2 != 14) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 15:
      if (v2 != 15) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 16:
      if (v2 != 16) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 17:
      if (v2 != 17) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 18:
      if (v2 != 18) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 19:
      if (v2 != 19) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 20:
      if (v2 != 20) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 21:
      if (v2 != 21) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 22:
      if (v2 != 22) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 23:
      if (v2 != 23) {
LABEL_23:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_19:
      uint64_t result = 4294959246;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(uint64_t a1, const void **a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_28;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_28;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_28;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_28;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_28;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_28;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_28;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_28;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_28;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_28;
      }
      uint64_t v4 = (TString *)*a2;
      if (*(const void **)a1 != *a2) {
        TString::SetStringRefAsImmutable((TString *)a1, v4);
      }
      return 0;
    case 12:
      if (v2 != 12) {
        goto LABEL_28;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 13:
      if (v2 != 13) {
        goto LABEL_28;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_28;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_28;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_28;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_28;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_28;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_28;
    case 20:
      if (v2 != 20) {
        goto LABEL_28;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_28;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_28;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_28:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(uint64_t a1, const void **a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_29;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_29;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_29;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_29;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_29;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_29;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_29;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_29;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_29;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_29;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_29;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_29;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 14:
      if (v2 != 14) {
        goto LABEL_29;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_29;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_29;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_29;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_29;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_29;
    case 20:
      if (v2 != 20) {
        goto LABEL_29;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_29;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_29;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_29:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(uint64_t a1, const void **a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_31;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_31;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_31;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_31;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_31;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_31;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_31;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_31;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_31;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_31;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_31;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_31;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_31;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 15:
      if (v2 != 15) {
        goto LABEL_31;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_31;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_31;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_31;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_31;
    case 20:
      if (v2 != 20) {
        goto LABEL_31;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_31;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_31;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_31:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(uint64_t a1, const void **a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_33;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_33;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_33;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_33;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_33;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_33;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_33;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_33;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_33;
      }
      objc_storeStrong((id *)a1, (id)*a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_33;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_33;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_33;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_33;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_33;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 16:
      if (v2 != 16) {
        goto LABEL_33;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_33;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_33;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_33;
    case 20:
      if (v2 != 20) {
        goto LABEL_33;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_33;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_33;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_33:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<NSObject * {__strong}>(id *location, id *a2)
{
  int v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSObject * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_33;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_33;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_33;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_33;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_33;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_33;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_33;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_33;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_33;
      }
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_33;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_33;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_33;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_33;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_33;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_33;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_33;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_33;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_33;
    case 20:
      if (v2 != 20) {
        goto LABEL_33;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_33;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_33;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_33:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(uint64_t a1, const void **a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_35;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_35;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_35;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_35;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_35;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_35;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_35;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_35;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_35;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_35;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_35;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_35;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_35;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_35;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_35;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 17:
      if (v2 != 17) {
        goto LABEL_35;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_35;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_35;
    case 20:
      if (v2 != 20) {
        goto LABEL_35;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_35;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_35;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_35:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(uint64_t a1, const void **a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_37;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_37;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_37;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_37;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_37;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_37;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_37;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_37;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_37;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_37;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_37;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_37;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_37;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_37;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_37;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_37;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 18:
      if (v2 != 18) {
        goto LABEL_37;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_37;
    case 20:
      if (v2 != 20) {
        goto LABEL_37;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_37;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_37;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_37:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(uint64_t a1, const void **a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(a1, (CFTypeRef *)a1, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_41;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_41;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_41;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_41;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_41;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_41;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_41;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_41;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_41;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_41;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_41;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_41;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_41;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_41;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_41;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_41;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_41;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_41;
    case 20:
      if (v2 != 20) {
        goto LABEL_41;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_41;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_41;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_41:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<Property>(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Property const&,0,Property,20ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      goto LABEL_41;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 9:
      goto LABEL_43;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 20:
      if (v2 != 20) {
        goto LABEL_45;
      }
LABEL_41:
      uint64_t result = 0;
      *a1 = *a2;
      break;
    case 21:
      if (v2 == 21) {
        goto LABEL_43;
      }
      goto LABEL_45;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_43:
      uint64_t result = 4294959246;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<NodeRequestOptions>(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeRequestOptions const&,0,NodeRequestOptions,21ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 2:
      if (v2 != 2) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 3:
      if (v2 != 3) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 4:
      if (v2 != 4) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 5:
      if (v2 != 5) {
        goto LABEL_48;
      }
      uint64_t result = 0;
      *(void *)a1 = *a2;
      return result;
    case 6:
      if (v2 != 6) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 7:
      if (v2 != 7) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 8:
      if (v2 != 8) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 9:
      goto LABEL_45;
    case 10:
      if (v2 != 10) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 11:
      if (v2 != 11) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 12:
      if (v2 != 12) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 13:
      if (v2 != 13) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 14:
      if (v2 != 14) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 15:
      if (v2 != 15) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 16:
      if (v2 != 16) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 17:
      if (v2 != 17) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 18:
      if (v2 != 18) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 19:
      if (v2 != 19) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 20:
      if (v2 != 20) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_48;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_48;
      }
LABEL_45:
      uint64_t result = 4294959246;
      break;
    case 23:
      if (v2 != 23) {
LABEL_48:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      uint64_t result = 0;
      *a1 = *a2;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<NodeDSStoreStatus>(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeDSStoreStatus const&,0,NodeDSStoreStatus,22ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 2:
      if (v2 != 2) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 3:
      if (v2 != 3) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 4:
      if (v2 != 4) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 5:
      if (v2 != 5) {
        goto LABEL_43;
      }
      uint64_t result = 0;
      *(void *)a1 = *a2;
      return result;
    case 6:
      if (v2 != 6) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 7:
      if (v2 != 7) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 8:
      if (v2 != 8) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 11:
      if (v2 != 11) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 12:
      if (v2 != 12) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 13:
      if (v2 != 13) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 14:
      if (v2 != 14) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 15:
      if (v2 != 15) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 16:
      if (v2 != 16) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 17:
      if (v2 != 17) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 18:
      if (v2 != 18) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 19:
      if (v2 != 19) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 20:
      if (v2 != 20) {
        goto LABEL_43;
      }
LABEL_41:
      uint64_t result = 4294959246;
      break;
    case 21:
      if (v2 != 21) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 23:
      if (v2 != 23) {
LABEL_43:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      uint64_t result = 0;
      *a1 = *a2;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<DSBladeRunnerFlags>(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[4];
  switch((char)v2)
  {
    case 0:
      std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<DSBladeRunnerFlags const&,0,DSBladeRunnerFlags,23ul,0>(a1, a2);
      goto LABEL_3;
    case 1:
      if (v2 != 1) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 2:
      if (v2 != 2) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 3:
      if (v2 != 3) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 4:
      if (v2 != 4) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 5:
      if (v2 != 5) {
        goto LABEL_48;
      }
      uint64_t result = 0;
      *(void *)a1 = *a2;
      return result;
    case 6:
      if (v2 != 6) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 7:
      if (v2 != 7) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 8:
      if (v2 != 8) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 9:
      goto LABEL_45;
    case 10:
      if (v2 != 10) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 11:
      if (v2 != 11) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 12:
      if (v2 != 12) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 13:
      if (v2 != 13) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 14:
      if (v2 != 14) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 15:
      if (v2 != 15) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 16:
      if (v2 != 16) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 17:
      if (v2 != 17) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 18:
      if (v2 != 18) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 19:
      if (v2 != 19) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 20:
      if (v2 != 20) {
        goto LABEL_48;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_48;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_48;
      }
LABEL_45:
      uint64_t result = 4294959246;
      break;
    case 23:
      if (v2 != 23) {
LABEL_48:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_47:
      uint64_t result = 0;
      *a1 = *a2;
      break;
    default:
LABEL_3:
      uint64_t result = 0;
      break;
  }
  return result;
}

TReferenceCounted **TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=(TReferenceCounted **a1, uint64_t a2)
{
  if (a2) {
    TRefCount::Retain<int>((unsigned int *)(a2 + 16));
  }
  if (*a1) {
    TReferenceCounted::RemovePtrReference(*a1);
  }
  *a1 = (TReferenceCounted *)a2;
  return a1;
}

uint64_t *TString::KEmptyString(TString *this)
{
  {
    TString::KEmptyString(void)::sEmptyString = (uint64_t)&stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
  }
  return &TString::KEmptyString(void)::sEmptyString;
}

void sub_1D349518C(_Unwind_Exception *a1)
{
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Blob const&,0,Blob,9ul,0>(uint64_t a1, _OWORD *a2)
{
  if (*(_DWORD *)(a1 + 16) == 9) {
    *(_OWORD *)a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob const&>(a1, a2);
  }
  return a1;
}

uint64_t TPropertyValue::CopyBlob(TPropertyValue *this, const Blob *a2)
{
  v4[4] = *MEMORY[0x1E4F143B8];
  if (this->fData.__impl_.__index != 9) {
    return 4294959224;
  }
  if (this->fData.__impl_.__index != 9) {
    std::__throw_bad_variant_access[abi:ne180100]();
  }
  v4[0] = &unk_1F2ABAB88;
  v4[3] = v4;
  uint64_t v2 = CopyBlob((uint64_t)a2, (uint64_t)this, (uint64_t)v4);
  std::__function::__value_func<void ()(Blob &,unsigned int)>::~__value_func[abi:ne180100](v4);
  return v2;
}

void sub_1D34952A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Blob &,unsigned int)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 1) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 2) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, _WORD *a2, _WORD *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 3) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 4) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 5) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 6) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 7) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 8) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 9) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob>(result, a3);
  }
  *a2 = *a3;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, void **a2, uint64_t *a3)
{
}

CFTypeRef *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(CFTypeRef **a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm13ELm13EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm14ELm14EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm15ELm15EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm16ELm16EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm17ELm17EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm18ELm18EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, const void **a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(*a1, a2, a3);
}

TReferenceCounted **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm19ELm19EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(uint64_t *a1, TReferenceCounted **a2, TReferenceCounted **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(*a1, a2, a3);
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm20ELm20EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 20) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm21ELm21EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 21) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm22ELm22EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 22) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm23ELm23EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100INS0_17__move_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1T_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEEOS21_EEEDcS1T_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 23) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL>(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(unsigned char *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 1;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char>(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(unsigned char *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 2;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short>(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(_WORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 3;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<4ul,int>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 4;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 5;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 6;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 7;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 8;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob>(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(_OWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 9;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSObject * {__strong}>(uint64_t a1, void **a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10)
  {
    uint64_t v3 = *a3;
    *a3 = 0;
    uint64_t v4 = *a2;
    *a2 = (void *)v3;
  }
  else
  {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSObject * {__strong}>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSObject * {__strong}>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v7, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  uint64_t v5 = *a2;
  *a2 = 0;
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

CFTypeRef *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString>(CFTypeRef *result, const void **a2, const void **a3)
{
  if (*((_DWORD *)result + 4) == 11)
  {
    if (a2 != a3)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, a3);
      return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a3, &stru_1F2ABD380);
    }
  }
  else
  {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<11ul,TString>((uint64_t)result, a3);
  }
  return result;
}

CFTypeRef *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<11ul,TString>(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  uint64_t result = std::__variant_detail::__alt<11ul,TString>::__alt[abi:ne180100]<TString>((CFTypeRef *)a1, a2);
  *(_DWORD *)(a1 + 16) = 11;
  return result;
}

CFTypeRef *std::__variant_detail::__alt<11ul,TString>::__alt[abi:ne180100]<TString>(CFTypeRef *a1, CFTypeRef *a2)
{
  *a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 12) {
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, a3);
  }
  else {
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 12;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 13) {
    return TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::operator=<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>(a2, a3);
  }
  else {
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(a1, a3);
  }
}

const void **TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::operator=<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 13;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 14) {
    return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::operator=<__CFData const*,TRetainReleasePolicy<__CFData const*>>(a2, a3);
  }
  else {
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 14;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 15) {
    return TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::operator=<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>(a2, a3);
  }
  else {
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(a1, a3);
  }
}

const void **TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::operator=<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 15;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 16) {
    return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::operator=<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>(a2, a3);
  }
  else {
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 16;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 17) {
    return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::operator=<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>(a2, a3);
  }
  else {
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(a1, a3);
  }
}

const void **TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::operator=<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 17;
  return a1;
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(uint64_t a1, const void **a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 18) {
    return TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::operator=<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>(a2, a3);
  }
  else {
    return (const void **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(a1, a3);
  }
}

const void **TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::operator=<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *a2 = 0;
  *(_DWORD *)(a1 + 16) = 18;
  return a1;
}

TReferenceCounted **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(uint64_t a1, TReferenceCounted **a2, TReferenceCounted **a3)
{
  if (*(_DWORD *)(a1 + 16) == 19) {
    return TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>(a2, a3);
  }
  else {
    return (TReferenceCounted **)std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<19ul,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>>(a1, a3);
  }
}

TReferenceCounted **TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>::operator=<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>(TReferenceCounted **a1, TReferenceCounted **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      TReferenceCounted::RemovePtrReference(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *a1 = *a2;
  a1[4] = 20;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<21ul,NodeRequestOptions>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *a1 = *a2;
  a1[4] = 21;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *a1 = *a2;
  a1[4] = 22;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *a1 = *a2;
  a1[4] = 23;
  return a1;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 1) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 2) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, _WORD *a2, _WORD *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 3) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 5) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm6ELm6EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 6) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm7ELm7EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 7) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm8ELm8EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 8) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm9ELm9EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 16) != 9) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm10ELm10EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, id *a2, id *a3)
{
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm11ELm11EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, TString *a2, TString *a3)
{
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm12ELm12EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm13ELm13EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm14ELm14EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm15ELm15EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm16ELm16EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm17ELm17EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(*a1, a2, a3);
}

const void **_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm18ELm18EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(uint64_t *a1, CFTypeRef *a2, const void **a3)
{
  return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(*a1, a2, a3);
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm20ELm20EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 20) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<20ul,Property const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm22ELm22EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 22) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

_DWORD *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm23ELm23EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEbhsixjd5Point4BlobU8__strongP8NSObject7TString4TRefIPK10__CFString20TRetainReleasePolicyISI_EESF_IPK10__CFNumberSJ_ISO_EESF_IPK8__CFDataSJ_IST_EESF_IPK14__CFDictionarySJ_ISY_EESF_IPK7__CFURLSJ_IS13_EESF_IPK9__CFArraySJ_IS18_EESF_IP16__CFFileSecuritySJ_IS1C_EESF_IP17TReferenceCountedSJ_IS1G_EE8Property18NodeRequestOptions17NodeDSStoreStatus18DSBladeRunnerFlagsEEEE16__generic_assignB8ne180100IRKNS0_17__copy_assignmentIS1N_LNS0_6_TraitE1EEEEEvOT_EUlRS1V_OT0_E_JRNS0_6__baseILS1R_1EJS8_bhsixjdS9_SA_SD_SE_SL_SQ_SV_S10_S15_S1A_S1E_S1I_S1J_S1K_S1L_S1M_EEERKS23_EEEDcS1V_DpT0_(_DWORD **a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = *a1;
  if (result[4] != 23) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags const&>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<0ul,std::monostate const&>(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v2))(&v4, a1);
  }
  *(_DWORD *)(a1 + 16) = 0;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL const&>(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(unsigned char *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 1;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char const&>(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(unsigned char *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 2;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short const&>(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(_WORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 3;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long const&>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 5;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 6;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double const&>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 7;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  a1[4] = -1;
  *a1 = *a2;
  a1[4] = 8;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<9ul,Blob const&>(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(_OWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 9;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSObject * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10) {
    objc_storeStrong(location, *a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSObject * const {__strong}&>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSObject * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(uint64_t a1, TString *this, TString *a3)
{
  if (*(_DWORD *)(a1 + 16) == 11)
  {
    if (this != a3)
    {
      uint64_t fRef = (TString *)a3->fString.fRef;
      TString::SetStringRefAsImmutable(this, fRef);
    }
  }
  else
  {
    v5[0] = a1;
    v5[1] = (uint64_t)a3;
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(std::__variant_detail::__alt<11ul,TString> &,TString const&)::{unnamed type#1}::operator()[abi:ne180100](v5);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<11ul,TString,TString const&>(std::__variant_detail::__alt<11ul,TString> &,TString const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (TString **)a1[1];
  v4.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v4, *v2);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<11ul,TString>(v1, (CFTypeRef *)&v4.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4.fString.fRef);
}

void sub_1D3496868(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 12)
  {
    TString v4 = *a3;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v4);
  }
  else
  {
    v6[0] = a1;
    v6[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(std::__variant_detail::__alt<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>> &,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v6);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&>(std::__variant_detail::__alt<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>> &,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = **(const void ***)(a1 + 8);
  TString v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>(v1, &v4);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v4);
}

void sub_1D3496928(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 13)
  {
    TString v4 = *a3;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v4);
  }
  else
  {
    v6[0] = a1;
    v6[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(std::__variant_detail::__alt<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>> &,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v6);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&>(std::__variant_detail::__alt<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>> &,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = **(const void ***)(a1 + 8);
  TString v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<13ul,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>>(v1, &v4);
  return TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef(&v4);
}

void sub_1D34969E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 14)
  {
    TString v4 = *a3;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v4);
  }
  else
  {
    v6[0] = a1;
    v6[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(std::__variant_detail::__alt<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>> &,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v6);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(std::__variant_detail::__alt<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>> &,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = **(const void ***)(a1 + 8);
  TString v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(v1, &v4);
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v4);
}

void sub_1D3496AA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 15)
  {
    TString v4 = *a3;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v4);
  }
  else
  {
    v6[0] = a1;
    v6[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(std::__variant_detail::__alt<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>> &,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v6);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&>(std::__variant_detail::__alt<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>> &,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = **(const void ***)(a1 + 8);
  TString v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>(v1, &v4);
  return TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(&v4);
}

void sub_1D3496B5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 16)
  {
    TString v4 = *a3;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v4);
  }
  else
  {
    v6[0] = a1;
    v6[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(std::__variant_detail::__alt<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>> &,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v6);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(std::__variant_detail::__alt<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>> &,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = **(const void ***)(a1 + 8);
  TString v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(v1, &v4);
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v4);
}

void sub_1D3496C18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 17)
  {
    TString v4 = *a3;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v4);
  }
  else
  {
    v6[0] = a1;
    v6[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(std::__variant_detail::__alt<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>> &,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v6);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&>(std::__variant_detail::__alt<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>> &,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = **(const void ***)(a1 + 8);
  TString v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(v1, &v4);
  return TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(&v4);
}

void sub_1D3496CD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(uint64_t a1, CFTypeRef *a2, const void **a3)
{
  if (*(_DWORD *)(a1 + 16) == 18)
  {
    TString v4 = *a3;
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, v4);
  }
  else
  {
    v6[0] = a1;
    v6[1] = a3;
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(std::__variant_detail::__alt<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>> &,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&)::{unnamed type#1}::operator()[abi:ne180100]((uint64_t)v6);
  }
}

const void **std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&>(std::__variant_detail::__alt<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>> &,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>> const&)::{unnamed type#1}::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)a1;
  uint64_t v2 = **(const void ***)(a1 + 8);
  TString v4 = v2;
  if (v2) {
    CFRetain(v2);
  }
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<18ul,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>>(v1, &v4);
  return TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef(&v4);
}

void sub_1D3496D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *a1 = *a2;
  a1[4] = 22;
  return a1;
}

_DWORD *std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags const&>(_DWORD *a1, _DWORD *a2)
{
  uint64_t v4 = a1[4];
  if (v4 != -1) {
    ((void (*)(char *, _DWORD *))*(&off_1F2ABC010 + v4))(&v6, a1);
  }
  *a1 = *a2;
  a1[4] = 23;
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<BOOL const&,0,BOOL,1ul,0>(uint64_t a1, unsigned char *a2)
{
  if (*(_DWORD *)(a1 + 16) == 1) {
    *(unsigned char *)a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<1ul,BOOL const&>(a1, a2);
  }
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<unsigned char const&,0,unsigned char,2ul,0>(uint64_t a1, unsigned char *a2)
{
  if (*(_DWORD *)(a1 + 16) == 2) {
    *(unsigned char *)a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<2ul,unsigned char const&>(a1, a2);
  }
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<short const&,0,short,3ul,0>(uint64_t a1, _WORD *a2)
{
  if (*(_DWORD *)(a1 + 16) == 3) {
    *(_WORD *)a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<3ul,short const&>(a1, a2);
  }
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<long long const&,0,long long,5ul,0>(uint64_t a1, void *a2)
{
  if (*(_DWORD *)(a1 + 16) == 5) {
    *(void *)a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<5ul,long long const&>(a1, a2);
  }
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<unsigned int const&,0,unsigned int,6ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 6) {
    *a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<6ul,unsigned int const&>(a1, a2);
  }
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<Point const&,0,Point,8ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 8) {
    *a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<8ul,Point const&>(a1, a2);
  }
  return a1;
}

uint64_t std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<double const&,0,double,7ul,0>(uint64_t a1, void *a2)
{
  if (*(_DWORD *)(a1 + 16) == 7) {
    *(void *)a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<7ul,double const&>(a1, a2);
  }
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<NodeDSStoreStatus const&,0,NodeDSStoreStatus,22ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 22) {
    *a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<22ul,NodeDSStoreStatus const&>(a1, a2);
  }
  return a1;
}

_DWORD *std::variant<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>::operator=[abi:ne180100]<DSBladeRunnerFlags const&,0,DSBladeRunnerFlags,23ul,0>(_DWORD *a1, _DWORD *a2)
{
  if (a1[4] == 23) {
    *a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<23ul,DSBladeRunnerFlags const&>(a1, a2);
  }
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},decltype(nullptr)>(uint64_t a1, void **a2)
{
  if (*(_DWORD *)(a1 + 16) == 10)
  {
    uint64_t v2 = *a2;
    *a2 = 0;
  }
  else
  {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,decltype(nullptr)>(a1);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,decltype(nullptr)>(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))*(&off_1F2ABC010 + v2))(&v4, a1);
  }
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

void std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::~__func()
{
}

void *std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F2ABAB88;
  return result;
}

void std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2ABAB88;
}

void std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::operator()(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(_DWORD *)a2 = *a3;
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3) {
    MEMORY[0x1D9436720](v3, 0x1000C8077774924);
  }
  operator new[]();
}

uint64_t std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<TPropertyValue::CopyBlob(Blob const&)::$_0,std::allocator<TPropertyValue::CopyBlob(Blob const&)::$_0>,void ()(Blob&,unsigned int)>::target_type()
{
}

void *std::__function::__value_func<void ()(Blob &,unsigned int)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1D3497430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  int v15 = v14;

  _Unwind_Resume(a1);
}

void sub_1D34974D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497530(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497734(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D349788C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v10 = v9;

  a9.super_class = (Class)FINode_ICloudAppLibrary;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1D34979D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D3497AA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497B18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497BD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497C64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497CD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497D44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3497EA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1D34980BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  id v6 = va_arg(va1, id);
  id v8 = va_arg(va1, id);
  uint64_t v9 = va_arg(va1, void);
  TNodeEventPtr::~TNodeEventPtr((id *)va);
  TNodeEventPtr::~TNodeEventPtr(v4);

  TNodeEventPtr::~TNodeEventPtr((id *)va1);
  _Unwind_Resume(a1);
}

void sub_1D3498264(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3498358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3498428(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34987A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, const void *a11, void *a12, uint64_t a13, id location, uint64_t a15, uint64_t a16, id a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)&a20);
  objc_destroyWeak(v30);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  objc_destroyWeak(v29);

  objc_destroyWeak(&location);
  objc_destroyWeak(&a17);

  _Unwind_Resume(a1);
}

void AddProgressObserver(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  uint64_t v7 = *a2;
  for (uint64_t i = a2[1]; i != v7; TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)(i - 40)))
    ;
  a2[1] = v7;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v8 = [&unk_1F2AC37E8 countByEnumeratingWithState:&v13 objects:v18 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v14;
    do
    {
      uint64_t v10 = 0;
      do
      {
        if (*(void *)v14 != v9) {
          objc_enumerationMutation(&unk_1F2AC37E8);
        }
        uint64_t v11 = (TString *)*(id *)(*((void *)&v13 + 1) + 8 * v10);
        v12.fString.uint64_t fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v12, v11);

        std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v17, a3);
        TKeyValueObserver::StartObserving<std::function<void ()(void)>>(a2, v5, &v12, (uint64_t)v17, 0);
        std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v17);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);
        ++v10;
      }
      while (v8 != v10);
      uint64_t v8 = [&unk_1F2AC37E8 countByEnumeratingWithState:&v13 objects:v18 count:16];
    }
    while (v8);
  }
}

void sub_1D34989FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D3498DE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v27);
  objc_destroyWeak(v28);
  -[DSFileProgress progressChanged:]::$_3::~$_3((uint64_t)&location);

  -[DSFileProgress progressChanged:]::$_3::~$_3((uint64_t)&a24);
  objc_destroyWeak((id *)(v29 - 112));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v29 - 104));

  _Unwind_Resume(a1);
}

void sub_1D3498EC4()
{
  JUMPOUT(0x1D3498EB4);
}

void sub_1D3498ED0()
{
}

void sub_1D3498ED8()
{
}

void OperationTypeFromProgress(NSDictionary *a1@<X0>, TString *a2@<X8>)
{
  uint64_t v3 = [(NSDictionary *)a1 objectForKeyedSubscript:*MEMORY[0x1E4F28868]];
  objc_cast<NSString,objc_object * {__strong}>(v3);
  char v4 = (TString *)(id)objc_claimAutoreleasedReturnValue();
  CFStringRef theString = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&theString, v4);

  if (CFStringGetLength(theString))
  {
    if (operator==((void **)&theString, (void *)*MEMORY[0x1E4F28850]))
    {
      a2->fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(a2, (TString *)@"CopyOperationType");
LABEL_6:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      return;
    }
    if (operator==((void **)&theString, (void *)*MEMORY[0x1E4F28840]))
    {
      a2->fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(a2, (TString *)@"AirdropOperationType");
      goto LABEL_6;
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  a2->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, (TString *)@"CopyOperationType");
}

void sub_1D3499034(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

id TProgressMap::GetProgressDispatchQueue(TProgressMap *this)
{
  if (TProgressMap::GetProgressDispatchQueue(void)::once != -1) {
    dispatch_once(&TProgressMap::GetProgressDispatchQueue(void)::once, &__block_literal_global_1);
  }
  uint64_t v1 = (void *)TProgressMap::GetProgressDispatchQueue(void)::progressQueue;
  return v1;
}

void sub_1D34991E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__3(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  *(void *)(a1 + 40) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 40), *(TString **)(a2 + 40));
  *(void *)(a1 + 48) = *(id *)(a2 + 48);
  __n128 result = *(__n128 *)(a2 + 56);
  *(__n128 *)(a1 + 56) = result;
  return result;
}

void sub_1D3499284(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__3(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 32);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 40));
  objc_destroyWeak(v2);
}

id TProgressInfo::CreateProgressDictionary(TProgressInfo *this)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  v28[0] = @"InlineState";
  int v27 = [NSNumber numberWithUnsignedInt:*((unsigned int *)this + 17)];
  uint64_t v29 = v27;
  v28[1] = @"InlinePercentageDone";
  LODWORD(v2) = *((_DWORD *)this + 4);
  uint64_t v30 = [NSNumber numberWithFloat:v2];
  v28[2] = @"InlineTimeEstimate";
  LODWORD(v3) = *((_DWORD *)this + 18);
  int v26 = (void *)v30;
  uint64_t v31 = [NSNumber numberWithFloat:v3];
  v28[3] = @"TotalSize";
  uint64_t v25 = (void *)v31;
  uint64_t v24 = [NSNumber numberWithLongLong:*(void *)this];
  unint64_t v32 = v24;
  v28[4] = @"CompletedSize";
  char v4 = [NSNumber numberWithLongLong:*((void *)this + 1)];
  CFComparisonResult v33 = v4;
  v28[5] = @"DownloadPercentageDone";
  LODWORD(v5) = *((_DWORD *)this + 10);
  id v6 = [NSNumber numberWithFloat:v5];
  unint64_t v34 = v6;
  v28[6] = @"DownloadTotalSize";
  uint64_t v7 = [NSNumber numberWithLongLong:*((void *)this + 3)];
  CFComparisonResult v35 = v7;
  v28[7] = @"DownloadCompletedSize";
  uint64_t v8 = [NSNumber numberWithLongLong:*((void *)this + 4)];
  unint64_t v36 = v8;
  v28[8] = @"UploadPercentageDone";
  LODWORD(v9) = *((_DWORD *)this + 16);
  uint64_t v10 = [NSNumber numberWithFloat:v9];
  unint64_t v37 = v10;
  v28[9] = @"UploadTotalSize";
  uint64_t v11 = [NSNumber numberWithLongLong:*((void *)this + 6)];
  int v38 = v11;
  void v28[10] = @"UploadCompletedSize";
  uint64_t v12 = [NSNumber numberWithLongLong:*((void *)this + 7)];
  long long v13 = (void *)v12;
  if (*((unsigned char *)this + 76)) {
    uint64_t v14 = MEMORY[0x1E4F1CC38];
  }
  else {
    uint64_t v14 = MEMORY[0x1E4F1CC28];
  }
  uint64_t v39 = v12;
  uint64_t v40 = v14;
  v28[11] = @"InlineCanCancel";
  v28[12] = @"InlineCanPause";
  if (*((unsigned char *)this + 77)) {
    uint64_t v15 = MEMORY[0x1E4F1CC38];
  }
  else {
    uint64_t v15 = MEMORY[0x1E4F1CC28];
  }
  if (*((unsigned char *)this + 78)) {
    uint64_t v16 = MEMORY[0x1E4F1CC38];
  }
  else {
    uint64_t v16 = MEMORY[0x1E4F1CC28];
  }
  uint64_t v41 = v15;
  uint64_t v42 = v16;
  v28[13] = @"UserDownload";
  v28[14] = @"InlineOperationType";
  id v17 = *((id *)this + 10);
  id v43 = v17;
  uint64_t v18 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v29 forKeys:v28 count:15];

  id v19 = *((id *)this + 14);
  if (v19
    && (int v20 = v19,
        int v21 = (void *)[v18 mutableCopy],
        [v21 setObject:v20 forKeyedSubscript:@"InlineImage"],
        v20,
        v21))
  {
    id v22 = (id)[v21 copy];
  }
  else
  {
    id v22 = v18;
    int v21 = 0;
  }

  return v22;
}

void sub_1D349973C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TProgressMap::NormalizedPathForPath(TString **this@<X0>, TString *a2@<X8>)
{
  a2->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, *this);
}

void sub_1D349983C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

BOOL TProgressMap::HasProgress(TProgressMap *this, const __CFURL *a2)
{
  TCFURLInfo::FileSystemRepresentation(this, (const __CFURL *)1, &v7);
  TProgressMap::NormalizedPathForPath((TString **)&v7, (TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v7.fString.fRef, &cf);
  CFRetain(&stru_1F2ABD380);
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = &stru_1F2ABD380;
  double v2 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  double v3 = (os_unfair_lock_s *)TProgressMap::ProgressLock((TProgressMap *)v2);
  os_unfair_lock_lock(v3);
  BOOL v4 = TProgressMap::gProgressMap
    && *(void *)(TProgressMap::gProgressMap + 16)
    && TProgressMap::gProgressMap + 8 != std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, (CFStringRef *)&v7.fString.fRef);
  os_unfair_lock_unlock(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  return v4;
}

void sub_1D3499914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  os_unfair_lock_unlock(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

int *TProgressMap::ProgressLock(TProgressMap *this)
{
  {
    TProgressMap::ProgressLock(void)::gProgressLocuint64_t k = 0;
  }
  return &TProgressMap::ProgressLock(void)::gProgressLock;
}

uint64_t TProgressMap::GetProgress(TProgressMap *this, const TNodePtr *a2, TProgressInfo *a3)
{
  double v5 = (os_unfair_lock_s *)TProgressMap::ProgressLock(this);
  os_unfair_lock_lock(v5);
  if (TProgressMap::gProgressMap && *(void *)(TProgressMap::gProgressMap + 16))
  {
    CFStringRef theString = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    ProgressPathForNode((const TNodePtr *)this, (TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&theString, &cf);
    CFRetain(&stru_1F2ABD380);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = &stru_1F2ABD380;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    CFIndex Length = CFStringGetLength(theString);
    uint64_t v7 = Length != 0;
    if (!Length) {
      goto LABEL_14;
    }
    uint64_t v8 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &theString);
    uint64_t v9 = v8;
    if (TProgressMap::gProgressMap + 8 != v8)
    {
      *(_OWORD *)&a2->fFINode = *(_OWORD *)(v8 + 40);
      long long v10 = *(_OWORD *)(v8 + 56);
      long long v11 = *(_OWORD *)(v8 + 72);
      long long v12 = *(_OWORD *)(v8 + 88);
      *(_OWORD *)((char *)&a2[7].fFINode + 7) = *(_OWORD *)(v8 + 103);
      *(_OWORD *)&a2[4].fFINode = v11;
      *(_OWORD *)&a2[6].fFINode = v12;
      *(_OWORD *)&a2[2].fFINode = v10;
      if ((const TNodePtr *)(v8 + 40) != a2) {
        TString::SetStringRefAsImmutable((TString *)&a2[10], *(TString **)(v8 + 120));
      }
      uint64_t v14 = *(FINode **)(v9 + 128);
      uint64_t v13 = *(void *)(v9 + 136);
      if (v13) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
      }
      fFINode = a2[12].fFINode;
      a2[11].fFINode = v14;
      a2[12].fFINode = (FINode *)v13;
      if (fFINode) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)fFINode);
      }
      objc_storeStrong((id *)&a2[13].fFINode, *(id *)(v9 + 144));
      objc_storeStrong((id *)&a2[14].fFINode, *(id *)(v9 + 152));
LABEL_14:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      os_unfair_lock_unlock(v5);
      return v7;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  os_unfair_lock_unlock(v5);
  uint64_t v16 = TNodeFromFINode(*(FINode **)this);
  id v17 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v16);
  os_unfair_lock_lock(v17);
  uint64_t v19 = *(void *)(v16 + 16);
  uint64_t v18 = *(std::__shared_weak_count **)(v16 + 24);
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v17);
  os_unfair_lock_lock((os_unfair_lock_t)(v19 + 100));
  uint64_t v20 = *(unsigned __int16 *)(v19 + 119);
  unint64_t v21 = *(unsigned int *)(v19 + 115) | (unint64_t)(v20 << 32);
  os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 100));
  if ((v21 & 0x20000000000) != 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 96));
    uint64_t v22 = *(void *)(v19 + 80);
    if (v22)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v22 + 72));
      double v23 = *(double *)(v22 + 48);
      os_unfair_lock_unlock((os_unfair_lock_t)(v22 + 72));
      float v24 = v23;
    }
    else
    {
      float v24 = 0.0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 96));
    if (v24 >= 100.0) {
      int v25 = 0;
    }
    else {
      int v25 = 3;
    }
    if (v24 <= 0.0) {
      int v25 = 2;
    }
    *(float *)&a2[2].fFINode = v24;
    HIDWORD(a2[8].fFINode) = v25;
    LODWORD(a2[9].fFINode) = 0;
    int v26 = a2[12].fFINode;
    a2[11].fFINode = 0;
    a2[12].fFINode = 0;
    if (v26) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v26);
    }
    a2->fFINode = 0;
    a2[1].fFINode = 0;
    WORD2(a2[9].fFINode) = 0;
    int v28 = (__CFString *)a2[10].fFINode;
    int v27 = (TString *)&a2[10];
    if (v28 != @"CopyOperationType") {
      TString::SetStringRefAsImmutable(v27, (TString *)@"CopyOperationType");
    }
  }
  uint64_t v7 = (v20 >> 9) & 1;
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  return v7;
}

void sub_1D3499C24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void ProgressPathForNode(const TNodePtr *a1@<X0>, TString *a2@<X8>)
{
  if (TNodeFromFINode(a1->fFINode))
  {
    uint64_t v4 = TNodeFromFINode(a1->fFINode);
    TNode::GetPath(v4, 1, (uint64_t)v7);
    TString::TString(&v6, "", 0);
    fstd::optional_err<TString,int>::value_or<TString>((uint64_t)v7, (CFTypeRef *)&v6.fString.fRef, (CFTypeRef *)&a2->fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v7);
  }
  else
  {
    double v5 = TString::KEmptyString(0);
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, (TString *)*v5);
  }
}

void sub_1D3499D14(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TProgressMap::KeyForMatchingProgressObject(TProgressMap *this@<X0>, TString *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this;
  double v5 = v4;
  if (!v4 || !TProgressMap::gProgressMap) {
    goto LABEL_16;
  }
  uint64_t v6 = TProgressMap::gProgressMap + 8;
  uint64_t v7 = *(TString **)TProgressMap::gProgressMap;
  if (*(void *)TProgressMap::gProgressMap != TProgressMap::gProgressMap + 8)
  {
    while ((TProgressMap *)v7[18].fString.fRef != v4)
    {
      uint64_t fRef = v7[1].fString.fRef;
      if (fRef)
      {
        do
        {
          uint64_t v9 = fRef;
          uint64_t fRef = (__CFString *)fRef->isa;
        }
        while (fRef);
      }
      else
      {
        do
        {
          uint64_t v9 = v7[2].fString.fRef;
          BOOL v10 = v9->isa == v7;
          uint64_t v7 = (TString *)v9;
        }
        while (!v10);
      }
      uint64_t v7 = (TString *)v9;
      if (v9 == (__CFString *)v6) {
        goto LABEL_16;
      }
    }
  }
  if (v7 != (TString *)v6)
  {
    long long v11 = LogObj(5);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      long long v12 = SanitizedPath(v7 + 4);
      int v13 = 138543362;
      uint64_t v14 = v12;
      _os_log_impl(&dword_1D343E000, v11, OS_LOG_TYPE_INFO, "Found path matching progress object %{public}@", (uint8_t *)&v13, 0xCu);
    }
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, (TString *)v7[4].fString.fRef);
  }
  else
  {
LABEL_16:
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
  }
}

void sub_1D3499EB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **TProgressMap::UpdateExternalProgress(TNodePtr *this, const TNodePtr *a2, const TProgressInfo *a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  BOOL v5 = HIDWORD(a2[8].fFINode) == 0;
  ProgressPathForNode(this, (TString *)buf);
  TProgressMap::NormalizedPathForPath((TString **)buf, (TString *)&theString);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
  if (!CFStringGetLength(theString))
  {
    uint64_t v6 = LogObj(5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = TNodeFromFINode(this->fFINode);
      if (v7)
      {
        uint64_t v8 = TNodeFromFINode(this->fFINode);
        uint64_t v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
        os_unfair_lock_lock(v9);
        long long v11 = *(TFSInfo **)(v8 + 16);
        BOOL v10 = *(std::__shared_weak_count **)(v8 + 24);
        if (v10) {
          atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v9);
        TFSInfo::Name(v11, &v45);
        if (v10) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v10);
        }
        SanitizedStr(&v45);
        long long v12 = (__CFString *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        long long v12 = @"nil node";
      }
      int v13 = (TNode *)TNodeFromFINode(this->fFINode);
      int v15 = TNode::Validate(v13, v14);
      *(_DWORD *)TPropertyValue buf = 138543618;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v48 = 1024;
      int v49 = v15;
      _os_log_impl(&dword_1D343E000, v6, OS_LOG_TYPE_INFO, "No path found for progress %{public}@ valid=%d", buf, 0x12u);
      if (v7)
      {

        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v45.fString.fRef);
      }
    }

    id v17 = (os_unfair_lock_s *)TProgressMap::ProgressLock(v16);
    os_unfair_lock_lock(v17);
    TProgressMap::KeyForMatchingProgressObject((TProgressMap *)a2[13].fFINode, (TString *)buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&theString, (const void **)buf);
    CFRetain(&stru_1F2ABD380);
    if (*(void *)buf) {
      CFRelease(*(CFTypeRef *)buf);
    }
    *(void *)TPropertyValue buf = &stru_1F2ABD380;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
    os_unfair_lock_unlock(v17);
    BOOL v5 = 0;
  }
  CFIndex Length = (TProgressMap *)CFStringGetLength(theString);
  if (Length)
  {
    uint64_t v19 = (os_unfair_lock_s *)TProgressMap::ProgressLock(Length);
    os_unfair_lock_lock(v19);
    if (!TProgressMap::gProgressMap)
    {
      os_unfair_lock_unlock(v19);
      return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    }
    uint64_t v20 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &theString);
    unint64_t v21 = (uint64_t **)TProgressMap::gProgressMap;
    BOOL v22 = TProgressMap::gProgressMap + 8 == v20 && v5;
    if (v22 && a2[13].fFINode)
    {
      TProgressMap::KeyForMatchingProgressObject((TProgressMap *)a2[13].fFINode, (TString *)buf);
      if (CFStringGetLength(*(CFStringRef *)buf))
      {
        TString::SetStringRefAsImmutable((TString *)&theString, *(TString **)buf);
        uint64_t v20 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, &theString);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
      unint64_t v21 = (uint64_t **)TProgressMap::gProgressMap;
    }
    if ((uint64_t **)v20 == v21 + 1)
    {
      BOOL v25 = 0;
    }
    else
    {
      int fFINode_high = HIDWORD(a2[8].fFINode);
      if (fFINode_high)
      {
        int v24 = *(_DWORD *)(v20 + 108);
        BOOL v25 = v24 != fFINode_high;
        if (v24 != fFINode_high) {
          *(_DWORD *)(v20 + 108) = fFINode_high;
        }
        float v26 = *(float *)&a2[2].fFINode;
        if (*(float *)(v20 + 56) != v26)
        {
          *(float *)(v20 + 56) = v26;
          BOOL v25 = 1;
        }
        float v27 = *(float *)&a2[9].fFINode;
        if (*(float *)(v20 + 112) != v27)
        {
          *(float *)(v20 + 112) = v27;
          BOOL v25 = 1;
        }
        int v28 = BYTE5(a2[9].fFINode);
        if (*(unsigned __int8 *)(v20 + 117) != v28)
        {
          *(unsigned char *)(v20 + 117) = v28;
          BOOL v25 = 1;
        }
        int v29 = BYTE4(a2[9].fFINode);
        if (*(unsigned __int8 *)(v20 + 116) != v29)
        {
          *(unsigned char *)(v20 + 116) = v29;
          BOOL v25 = 1;
        }
        if (*(FINode **)(v20 + 40) != a2->fFINode)
        {
          *(TNodePtr *)(v20 + 40) = (TNodePtr)a2->fFINode;
          BOOL v25 = 1;
        }
        fFINode = a2[1].fFINode;
        if (*(FINode **)(v20 + 48) != fFINode)
        {
          *(void *)(v20 + 48) = fFINode;
          BOOL v25 = 1;
        }
        uint64_t v31 = a2[3].fFINode;
        if (*(FINode **)(v20 + 64) != v31)
        {
          *(void *)(v20 + 64) = v31;
          BOOL v25 = 1;
        }
        unint64_t v32 = a2[4].fFINode;
        if (*(FINode **)(v20 + 72) != v32)
        {
          *(void *)(v20 + 72) = v32;
          BOOL v25 = 1;
        }
        float v33 = *(float *)&a2[5].fFINode;
        if (*(float *)(v20 + 80) != v33)
        {
          *(float *)(v20 + 80) = v33;
          BOOL v25 = 1;
        }
        unint64_t v34 = a2[6].fFINode;
        if (*(FINode **)(v20 + 88) != v34)
        {
          *(void *)(v20 + 88) = v34;
          BOOL v25 = 1;
        }
        CFComparisonResult v35 = a2[7].fFINode;
        if (*(FINode **)(v20 + 96) != v35)
        {
          *(void *)(v20 + 96) = v35;
          BOOL v25 = 1;
        }
        float v36 = *(float *)&a2[8].fFINode;
        if (*(float *)(v20 + 104) != v36)
        {
          *(float *)(v20 + 104) = v36;
          BOOL v25 = 1;
        }
        int v38 = *(const void **)(v20 + 120);
        unint64_t v37 = (TString *)(v20 + 120);
        uint64_t v39 = (TString **)&a2[10];
        int v40 = v25;
        if (CFEqual(v38, a2[10].fFINode)) {
          goto LABEL_61;
        }
        if (v37 != (TString *)v39) {
          TString::SetStringRefAsImmutable(v37, *v39);
        }
      }
      else
      {
        std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(v21, (uint64_t *)v20);
        std::pair<TString,TProgressInfo>::~pair(v20 + 32);
        operator delete((void *)v20);
      }
      BOOL v25 = 1;
    }
    int v40 = 1;
LABEL_61:
    os_unfair_lock_unlock(v19);
    if (TNodeFromFINode(this->fFINode))
    {
      if (v40) {
        TProgressMap::PostProgressChange(&this->fFINode, v41);
      }
      if (HIDWORD(a2[8].fFINode)) {
        BOOL v42 = 0;
      }
      else {
        BOOL v42 = v25;
      }
      if (v42)
      {
        uint64_t v43 = TNodeFromFINode(this->fFINode);
        TNode::HandleSync(v43, 0x10080000u);
      }
    }
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1D349A36C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  os_unfair_lock_unlock(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TProgressMap::PostProgressChange(FINode **this, const TNodePtr *a2)
{
  if (TNodeFromFINode(*this))
  {
    uint64_t v3 = TNodeFromFINode(*this);
    uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
    os_unfair_lock_lock(v4);
    uint64_t v6 = *(void *)(v3 + 16);
    BOOL v5 = *(std::__shared_weak_count **)(v3 + 24);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v4);
    uint64_t v7 = (os_unfair_lock_s *)(v6 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
    int v8 = *(_DWORD *)(v6 + 115);
    os_unfair_lock_unlock(v7);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
    if ((v8 & 0x20) == 0)
    {
      uint64_t v9 = (TNode *)TNodeFromFINode(*this);
      TNode::UpdatePropertySynchronous(v9, 1819240307, 0, 0);
    }
    BOOL v10 = (const TNode *)TNodeFromFINode(*this);
    TNode::SendNotification(v10, 2, (id *)this, 1768845426, 0);
  }
}

void TProgressMap::AddExternalProgress(TProgressMap *this, TNodePtr *a2, TNodePtr *a3, NSDictionary *a4)
{
  uint64_t v7 = this;
  int v8 = a3;
  if (TNodeFromFINode(a2->fFINode))
  {
    ProgressPathForNode(a2, &v36);
    if (CFStringGetLength(v36.fString.fRef))
    {
      uint64_t v9 = [(TNodePtr *)v8 objectForKeyedSubscript:*MEMORY[0x1E4F28810]];
      CFNumberRef v10 = (const __CFNumber *)static_cf_cast<__CFString const*,void const*>(v9);

      double valuePtr = 0.0;
      if (v10) {
        CFNumberGetValue(v10, kCFNumberDoubleType, &valuePtr);
      }
      long long v11 = [(TNodePtr *)v8 objectForKey:*MEMORY[0x1E4F28838]];
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      int v26 = 0;
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      int v29 = 0;
      *(_DWORD *)&v31[3] = 0;
      unint64_t v32 = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      long long v33 = 0u;
      long long v34 = 0u;
      int v30 = TProgressInfo::ProgressStateFromProgress(v7, v12);
      [(TProgressMap *)v7 fractionCompleted];
      *(float *)&double v13 = v13 * 100.0;
      float v14 = valuePtr;
      int v23 = LODWORD(v13);
      *(float *)uint64_t v31 = v14;
      OperationTypeFromProgress((NSDictionary *)v8, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v32, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      uint64_t v21 = [(TProgressMap *)v7 totalUnitCount];
      uint64_t v22 = [(TProgressMap *)v7 completedUnitCount];
      v31[5] = [(TProgressMap *)v7 isPausable];
      v31[4] = [(TProgressMap *)v7 isCancellable];
      int v15 = operator new(0x28uLL);
      v15[1] = 0;
      id v15[2] = 0;
      *int v15 = &unk_1F2ABB320;
      uint64_t v16 = v7;
      void v15[3] = &unk_1F2ABAA18;
      v15[4] = v16;
      id v17 = (std::__shared_weak_count *)*((void *)&v33 + 1);
      *(void *)&long long v33 = v15 + 3;
      *((void *)&v33 + 1) = v15;
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
      if (v11) {
        objc_storeStrong((id *)&v34 + 1, v11);
      }
      objc_storeStrong((id *)&v34, this);
      TProgressMap::AddProgressForPath((TProgressMap *)&v21, (TString **)&v36, v18);
      if (TNodeFromFINode(a2->fFINode)) {
        TProgressMap::PostProgressChange(&a2->fFINode, v19);
      }

      if (*((void *)&v33 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v33 + 1));
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v32);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v36.fString.fRef);
  }
}

void sub_1D349A7AC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v3 - 72));

  _Unwind_Resume(a1);
}

uint64_t TProgressInfo::ProgressStateFromProgress(TProgressInfo *this, NSProgress *a2)
{
  double v2 = this;
  if (([(TProgressInfo *)v2 isFinished] & 1) != 0
    || ([(TProgressInfo *)v2 isCancelled] & 1) != 0)
  {
    uint64_t v3 = 0;
  }
  else if ([(TProgressInfo *)v2 isIndeterminate])
  {
    uint64_t v3 = 2;
  }
  else
  {
    uint64_t v3 = 3;
  }

  return v3;
}

void sub_1D349A868(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **TProgressMap::AddProgressForPath(TProgressMap *this, TString **a2, const TString *a3)
{
  TProgressMap::NormalizedPathForPath(a2, &v14);
  BOOL v5 = (os_unfair_lock_s *)TProgressMap::ProgressLock(v4);
  os_unfair_lock_lock(v5);
  if (!TProgressMap::gProgressMap) {
    operator new();
  }
  uint64_t v6 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, (CFStringRef *)&v14.fString.fRef);
  uint64_t v7 = (uint64_t **)TProgressMap::gProgressMap;
  if (TProgressMap::gProgressMap + 8 == v6)
  {
    std::pair<TString,TProgressInfo>::pair[abi:ne180100]<true,0>((uint64_t)v9, (TString **)&v14, (long long *)this);
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__emplace_unique_key_args<TString,std::pair<TString,TProgressInfo>>(v7, v9, (uint64_t)v9);

    if (v11) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v10);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v9);
  }
  os_unfair_lock_unlock(v5);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14.fString.fRef);
}

void sub_1D349A970(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::pair<TString,TProgressInfo>::~pair((uint64_t)va);
  os_unfair_lock_unlock(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v3 - 40));
  _Unwind_Resume(a1);
}

void TProgressInfo::~TProgressInfo(TProgressInfo *this)
{
  double v2 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 10);
}

const void **std::pair<TString,TProgressInfo>::~pair(uint64_t a1)
{
  double v2 = *(std::__shared_weak_count **)(a1 + 104);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 88));
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)a1);
}

void ___ZN12TProgressMap24GetProgressDispatchQueueEv_block_invoke()
{
  dispatch_queue_t v0 = dispatch_queue_create("TProgressMap", 0);
  uint64_t v1 = (void *)TProgressMap::GetProgressDispatchQueue(void)::progressQueue;
  TProgressMap::GetProgressDispatchQueue(void)::progressQueue = (uint64_t)v0;
}

void TProgressMap::CancelProgress(TProgressMap *this, const TNodePtr *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)TProgressMap::ProgressLock(this);
  os_unfair_lock_lock(v4);
  if (TProgressMap::gProgressMap)
  {
    ProgressPathForNode((const TNodePtr *)this, &v10);
    uint64_t v5 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(TProgressMap::gProgressMap, (CFStringRef *)&v10.fString.fRef);
    uint64_t v6 = v5;
    uint64_t v7 = TProgressMap::gProgressMap + 8;
    if (TProgressMap::gProgressMap + 8 == v5)
    {
      int v8 = 0;
      uint64_t v9 = 0;
    }
    else
    {
      uint64_t v9 = *(void (****)(void, const TNodePtr *))(v5 + 128);
      int v8 = *(std::__shared_weak_count **)(v5 + 136);
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
    os_unfair_lock_unlock(v4);
    if (v7 != v6 && v9) {
      (**v9)(v9, a2);
    }
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
  }
  else
  {
    os_unfair_lock_unlock(v4);
  }
}

void sub_1D349ABAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void TKeyValueObserver::StartObserving<std::function<void ()(void)>>(uint64_t *a1, void *a2, const TString *a3, uint64_t a4, uint64_t a5)
{
  void v11[4] = *MEMORY[0x1E4F143B8];
  id v9 = a2;
  TKeyValueObserver::TKeyValueObserver((TKeyValueObserver *)v10);
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v11, a4);
  TKeyValueObserver::StartObserving<std::function<void ()(void)>>((TKeyValueObserver *)v10, v9, a3, (uint64_t)v11, a5);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v11);
  std::vector<TKeyValueObserver>::push_back[abi:ne180100](a1, (uint64_t)v10);
  TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)v10);
}

void sub_1D349ACA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](&a14);
  TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)&a9);

  _Unwind_Resume(a1);
}

const void **TProgressMap::AddSubscriberForExternalProgress(const TNodePtr *this, const TNodePtr *a2)
{
  __n128 result = (const void **)TNodeFromFINode(this->fFINode);
  if (result)
  {
    ProgressPathForNode(this, (TString *)&theString);
    if (CFStringGetLength(theString))
    {
      uint64_t v4 = (TNode *)TNodeFromFINode(this->fFINode);
      TNode::TestAndSetRegisteredForExternalProgress(v4, 1);
      started = TSystemNotificationTask::StartObservingDirectory((TString **)&theString, 0);
      uint64_t v6 = (void *)MEMORY[0x1D9436D80](started);
      uint64_t v7 = (void *)MEMORY[0x1E4F28F90];
      int v8 = (TNode *)TNodeFromFINode(this->fFINode);
      id v9 = TNode::CopyURL(v8);
      v12[0] = MEMORY[0x1E4F143A8];
      v12[1] = 3321888768;
      void v12[2] = ___ZN12TProgressMap32AddSubscriberForExternalProgressERK8TNodePtr_block_invoke;
      void v12[3] = &__block_descriptor_33_ea8_32c72_ZTSKZN12TProgressMap32AddSubscriberForExternalProgressERK8TNodePtrE3__0_e26____v___16__0__NSProgress_8l;
      TString v10 = [v7 addSubscriberForFileURL:v9 withPublishingHandler:v12];

      if (v10)
      {
        uint64_t v11 = TNodeFromFINode(this->fFINode);
        TChildrenList::SetNSProgressSubscriber(*(TChildrenList **)(v11 + 56), v10);
      }
    }
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  return result;
}

void sub_1D349ADFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

id ___ZN12TProgressMap32AddSubscriberForExternalProgressERK8TNodePtr_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  uint64_t v3 = [v2 kind];
  char v4 = [v3 isEqualToString:*MEMORY[0x1E4F28898]];

  if ((v4 & 1) == 0)
  {

    goto LABEL_6;
  }
  uint64_t v5 = [v2 userInfo];
  uint64_t v6 = *MEMORY[0x1E4F28890];
  uint64_t v7 = [v5 objectForKeyedSubscript:*MEMORY[0x1E4F28890]];
  int v8 = static_objc_cast<NSString,objc_object * {__strong}>(v7);

  if (v8)
  {
    BOOL HasProgress = TProgressMap::HasProgress((TProgressMap *)v8, v9);

    if (!HasProgress) {
      goto LABEL_8;
    }
LABEL_6:
    *(void *)TPropertyValue buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3321888768;
    *(void *)&buf[16] = ___ZL21StartExternalProgressP10NSProgress_block_invoke;
    int v38 = &__block_descriptor_33_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__0_e5_v8__0l;
    uint64_t v11 = (void *)[buf copy];
    goto LABEL_15;
  }

LABEL_8:
  id v12 = [v2 userInfo];
  int v29 = MutableCopyDeep(v12);

  id v13 = LogObj(5);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    TString v14 = [v2 userInfo];
    int v15 = [v14 objectForKeyedSubscript:v6];
    static_objc_cast<NSString,objc_object * {__strong}>(v15);
    uint64_t v16 = (NSURL *)objc_claimAutoreleasedReturnValue();
    id v17 = SanitizedURL(v16);
    uint64_t v18 = [v2 userInfo];
    *(_DWORD *)TPropertyValue buf = 138543874;
    *(void *)&uint8_t buf[4] = v17;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v2;
    *(_WORD *)&unsigned char buf[22] = 2112;
    int v38 = v18;
    _os_log_impl(&dword_1D343E000, v13, OS_LOG_TYPE_INFO, "StartExternalProgress for url %{public}@ %@ %@", buf, 0x20u);
  }
  uint64_t v19 = (std::__shared_weak_count *)operator new(0x20uLL);
  v19->__shared_owners_ = 0;
  v19->__shared_weak_owners_ = 0;
  v19->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9B58;
  LOBYTE(v19[1].__vftable) = 1;
  uint64_t v20 = objc_alloc_init(DSFileProgress);
  uint64_t v21 = TProgressMap::GetProgressDispatchQueue((TProgressMap *)v20);
  *(void *)TPropertyValue buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3321888768;
  *(void *)&buf[16] = ___ZL21StartExternalProgressP10NSProgress_block_invoke_45;
  int v38 = &__block_descriptor_72_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__1_e5_v8__0l;
  id v22 = v2;
  int v23 = v20;
  id v24 = v29;
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  id v39 = v22;
  int v40 = v23;
  id v41 = v24;
  BOOL v42 = v19 + 1;
  uint64_t v43 = v19;
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  dispatch_async(v21, buf);
  std::__shared_weak_count::__release_shared[abi:ne180100](v19);

  id v30 = v22;
  uint64_t v31 = v23;
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  v32[0] = MEMORY[0x1E4F143A8];
  v32[1] = 3321888768;
  void v32[2] = ___ZZL21StartExternalProgressP10NSProgressENK3__2cvU13block_pointerFvvEEv_block_invoke;
  v32[3] = &__block_descriptor_64_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__2_e5_v8__0l;
  id v25 = v30;
  id v33 = v25;
  int v26 = v31;
  long long v34 = v26;
  CFComparisonResult v35 = v19 + 1;
  TString v36 = v19;
  atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v27 = (void *)MEMORY[0x1D9436FC0](v32);
  if (v36) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v36);
  }

  uint64_t v11 = (void *)[v27 copy];
  std::__shared_weak_count::__release_shared[abi:ne180100](v19);

  if (v43) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v43);
  }

  std::__shared_weak_count::__release_shared[abi:ne180100](v19);
LABEL_15:

  return v11;
}

void sub_1D349B28C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void TKeyValueObserver::~TKeyValueObserver(TKeyValueObserver *this)
{
}

const void **___ZZ34__DSFileProgress_progressChanged__ENK3__2cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  v10[0].fFINode = 0;
  v10[1].fFINode = 0;
  int v11 = 0;
  long long v12 = 0uLL;
  int v13 = 0;
  long long v14 = 0uLL;
  memset(v15, 0, 15);
  v16.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  long long v17 = 0u;
  *(_OWORD *)uint64_t v18 = 0u;
  HIDWORD(v15[0]) = TProgressInfo::ProgressStateFromProgress(*(TProgressInfo **)(a1 + 48), v2);
  [*(id *)(a1 + 48) fractionCompleted];
  *(float *)&double v3 = v3 * 100.0;
  float v4 = *(double *)(a1 + 64);
  int v11 = LODWORD(v3);
  *(float *)&v15[1] = v4;
  BYTE5(v15[1]) = [*(id *)(a1 + 48) isPausable];
  BYTE4(v15[1]) = [*(id *)(a1 + 48) isCancellable];
  v10[0].fFINode = (FINode *)[*(id *)(a1 + 48) totalUnitCount];
  v10[1].fFINode = (FINode *)[*(id *)(a1 + 48) completedUnitCount];
  BYTE4(v15[1]) = [*(id *)(a1 + 48) isCancellable];
  if (&v16 != (TString *)(a1 + 40)) {
    TString::SetStringRefAsImmutable(&v16, *(TString **)(a1 + 40));
  }
  objc_storeStrong(v18, *(id *)(a1 + 48));
  if (operator==((void **)(a1 + 40), @"UbiquityOperationType"))
  {
    if (*(unsigned char *)(a1 + 56))
    {
      long long v12 = *(_OWORD *)&v10[0].fFINode;
      int v13 = v11;
    }
    if (*(unsigned char *)(a1 + 57))
    {
      long long v14 = *(_OWORD *)&v10[0].fFINode;
      LODWORD(v15[0]) = v11;
    }
  }
  id WeakRetained = (FINode *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v6 = (const TNode *)TNodeFromFINode(WeakRetained);
  TNodePtr::TNodePtr(&v9, v6);
  TProgressMap::UpdateExternalProgress(&v9, v10, v7);

  if (*((void *)&v17 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v17 + 1));
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16.fString.fRef);
}

void sub_1D349B55C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,void *a24,void *a25)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a23);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v25);
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__2(uint64_t a1, uint64_t a2)
{
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
  *(void *)(a1 + 40) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 40), *(TString **)(a2 + 40));
  *(void *)(a1 + 48) = *(id *)(a2 + 48);
  __n128 result = *(__n128 *)(a2 + 56);
  *(__n128 *)(a1 + 56) = result;
  return result;
}

void sub_1D349B618(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c47_ZTSKZ34__DSFileProgress_progressChanged__E3__2(uint64_t a1)
{
  id v2 = (id *)(a1 + 32);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 40));
  objc_destroyWeak(v2);
}

void std::vector<TKeyValueObserver>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  id v2 = (char *)**a1;
  if (v2)
  {
    float v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)(v4 - 40));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::pair<TString,TProgressInfo>::pair[abi:ne180100]<true,0>(uint64_t a1, TString **a2, long long *a3)
{
  *(void *)a1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  long long v6 = a3[2];
  long long v7 = a3[3];
  long long v8 = *(long long *)((char *)a3 + 63);
  long long v10 = *a3;
  long long v9 = a3[1];
  *(void *)(a1 + 88) = &stru_1F2ABD380;
  *(_OWORD *)(a1 + 71) = v8;
  *(_OWORD *)(a1 + 40) = v6;
  *(_OWORD *)(a1 + 56) = v7;
  *(_OWORD *)(a1 + 8) = v10;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v9;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 88), *((TString **)a3 + 10));
  uint64_t v11 = *((void *)a3 + 12);
  *(void *)(a1 + 96) = *((void *)a3 + 11);
  *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 112) = *((id *)a3 + 13);
  *(void *)(a1 + 120) = *((id *)a3 + 14);
  return a1;
}

void sub_1D349B7C0(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void ___ZL21StartExternalProgressP10NSProgress_block_invoke_45(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) userInfo];
  double v3 = [v2 objectForKeyedSubscript:*MEMORY[0x1E4F28890]];
  float v4 = static_objc_cast<NSString,objc_object * {__strong}>(v3);

  NodeForURL((const __CFURL *)v4, (TNodePtr *)&v26);
  uint64_t v5 = (const TNode *)TNodeFromFINode((FINode *)v26.super.isa);
  long long v6 = FINodeFromTNode(v5);
  [*(id *)(a1 + 40) setProgressNode:v6];

  **(unsigned char **)(a1 + 56) = TNodeFromFINode((FINode *)v26.super.isa) != 0;
  int v7 = UseFileProviderFramework();
  long long v8 = *(unsigned char **)(a1 + 56);
  if (v7)
  {
    if (!*v8) {
      goto LABEL_12;
    }
    long long v9 = [*(id *)(a1 + 32) userInfo];
    long long v10 = [v9 objectForKeyedSubscript:*MEMORY[0x1E4F28868]];
    objc_cast<NSString,objc_object * {__strong}>(v10);
    uint64_t v11 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    block[0].fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(block, v11);

    if ((operator==((void **)&block[0].fString.fRef, (void *)*MEMORY[0x1E4F28880]) & 1) != 0
      || operator==((void **)&block[0].fString.fRef, (void *)*MEMORY[0x1E4F28858]))
    {
      long long v12 = [*(id *)(a1 + 32) userInfo];
      int v13 = [v12 objectForKeyedSubscript:*MEMORY[0x1E4F28830]];
      if (v13)
      {
      }
      else
      {
        long long v14 = (TNode *)TNodeFromFINode((FINode *)v26.super.isa);
        BOOL IsLockFile = TNode::LowLevelIsLockFile(v14);

        if (IsLockFile) {
          **(unsigned char **)(a1 + 56) = 0;
        }
      }
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&block[0].fString.fRef);
    long long v8 = *(unsigned char **)(a1 + 56);
  }
  if (*v8)
  {
    Main = CFRunLoopGetMain();
    long long v17 = (const void *)*MEMORY[0x1E4F1D410];
    block[0].fString.uint64_t fRef = (__CFString *)MEMORY[0x1E4F143A8];
    block[1].fString.uint64_t fRef = (__CFString *)3321888768;
    block[2].fString.uint64_t fRef = (__CFString *)___ZZL21StartExternalProgressP10NSProgressENK3__1clEv_block_invoke;
    block[3].fString.uint64_t fRef = (__CFString *)&__block_descriptor_48_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE__e5_v8__0l;
    id v18 = *(id *)(a1 + 32);
    id v19 = *(id *)(a1 + 40);
    id v24 = v18;
    id v20 = v19;
    id v25 = v20;
    id v21 = v18;
    CFRunLoopPerformBlock(Main, v17, block);

    TProgressMap::AddExternalProgress(*(TProgressMap **)(a1 + 32), (TNodePtr *)&v26, *(TNodePtr **)(a1 + 48), v22);
  }
LABEL_12:
}

void sub_1D349BA8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id a16)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__1(void *a1, uint64_t a2)
{
  a1[4] = *(id *)(a2 + 32);
  a1[5] = *(id *)(a2 + 40);
  id result = *(id *)(a2 + 48);
  uint64_t v6 = *(void *)(a2 + 56);
  uint64_t v5 = *(void *)(a2 + 64);
  a1[6] = result;
  a1[7] = v6;
  a1[8] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__1(uint64_t a1)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  double v3 = *(void **)(a1 + 32);
}

uint64_t StartExternalProgress(NSProgress *)::$_1::~$_1(uint64_t a1)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  return a1;
}

uint64_t StartExternalProgress(NSProgress *)::$_2::~$_2(uint64_t a1)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  return a1;
}

void std::__shared_ptr_emplace<BOOL>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9B58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BOOL>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9B58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void NodeForURL(const __CFURL *a1@<X0>, TNodePtr *a2@<X8>)
{
  id v3 = 0;
  CFURLRef v4 = a1;
  if (TNode::GetNodeFromURL(&v4, &v3, 0)) {
    TNodePtr::TNodePtr(a2, 0);
  }
  else {
    a2->fFINode = (FINode *)v3;
  }
}

void sub_1D349BD6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZZL21StartExternalProgressP10NSProgressENK3__1clEv_block_invoke(uint64_t a1)
{
  [*(id *)(a1 + 40) startObserving:*(void *)(a1 + 32)];
  id v2 = *(void **)(a1 + 32);
  return [v2 acknowledgeWithSuccess:1];
}

id __copy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE_(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = *(id *)(a2 + 32);
  id result = *(id *)(a2 + 40);
  *(void *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__1clEvEUlvE_(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
}

void ___ZZL21StartExternalProgressP10NSProgressENK3__2cvU13block_pointerFvvEEv_block_invoke(uint64_t a1)
{
  id v2 = TProgressMap::GetProgressDispatchQueue((TProgressMap *)a1);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3321888768;
  v9[2] = ___ZZL21StartExternalProgressP10NSProgressENK3__2clEv_block_invoke;
  void v9[3] = &__block_descriptor_64_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE__e5_v8__0l;
  id v3 = *(id *)(a1 + 32);
  id v4 = *(id *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  id v7 = v3;
  id v10 = v7;
  id v8 = v4;
  id v11 = v8;
  uint64_t v12 = v6;
  int v13 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    dispatch_async(v2, v9);
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  else
  {
    dispatch_async(v2, v9);
  }

  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
}

id __copy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__2(void *a1, uint64_t a2)
{
  a1[4] = *(id *)(a2 + 32);
  id result = *(id *)(a2 + 40);
  uint64_t v6 = *(void *)(a2 + 48);
  uint64_t v5 = *(void *)(a2 + 56);
  a1[5] = result;
  a1[6] = v6;
  a1[7] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c48_ZTSKZL21StartExternalProgressP10NSProgressE3__2(uint64_t a1)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  id v3 = *(void **)(a1 + 32);
}

void ___ZZL21StartExternalProgressP10NSProgressENK3__2clEv_block_invoke(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (**(unsigned char **)(a1 + 48))
  {
    id v2 = *(void **)(a1 + 32);
    uint64_t v1 = *(void **)(a1 + 40);
    id v3 = v2;
    id v4 = v1;
    uint64_t v5 = LogObj(5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = [v3 userInfo];
      id v7 = [v6 objectForKeyedSubscript:*MEMORY[0x1E4F28890]];
      static_objc_cast<NSString,objc_object * {__strong}>(v7);
      id v8 = (NSURL *)objc_claimAutoreleasedReturnValue();
      long long v9 = SanitizedURL(v8);
      id v10 = [v3 userInfo];
      *(_DWORD *)TPropertyValue buf = 138543874;
      *(void *)&uint8_t buf[4] = v9;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v3;
      *(_WORD *)&unsigned char buf[22] = 2112;
      int v23 = v10;
      _os_log_impl(&dword_1D343E000, v5, OS_LOG_TYPE_INFO, "EndExternalProgress for url %{public}@ %@ %@", buf, 0x20u);
    }
    id v11 = [v3 kind];
    int v12 = IsEqual(v11, *MEMORY[0x1E4F28898]);

    if (v12)
    {
      int v13 = [v3 userInfo];
      BOOL v14 = v13 == 0;

      if (!v14)
      {
        *(void *)TPropertyValue buf = 0;
        *(void *)&uint8_t buf[8] = 0;
        int v23 = 0;
        id v24 = 0;
        int v25 = 0;
        uint64_t v26 = 0;
        uint64_t v27 = 0;
        memset(v28, 0, 15);
        int v29 = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        long long v31 = 0u;
        long long v30 = 0u;
        *(_DWORD *)&buf[16] = 1120403456;
        *(void *)((char *)v28 + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
        BYTE5(v28[1]) = [v3 isPausable];
        BYTE4(v28[1]) = [v3 isCancellable];
        objc_storeStrong((id *)&v31, v2);
        int v15 = [v4 progressNode];
        TString v16 = (const TNode *)TNodeFromFINode(v15);
        TNodePtr::TNodePtr(&v21, v16);
        TProgressMap::UpdateExternalProgress(&v21, (const TNodePtr *)buf, v17);

        if (*((void *)&v30 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v30 + 1));
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v29);
      }
    }
    Main = CFRunLoopGetMain();
    id v19 = (const void *)*MEMORY[0x1E4F1D410];
    *(void *)TPropertyValue buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3321888768;
    *(void *)&buf[16] = ___ZL19EndExternalProgressP10NSProgressP14DSFileProgress_block_invoke;
    int v23 = &__block_descriptor_40_ea8_32c63_ZTSKZL19EndExternalProgressP10NSProgressP14DSFileProgressE3__0_e5_v8__0l;
    id v20 = v4;
    id v24 = v20;
    CFRunLoopPerformBlock(Main, v19, buf);
  }
}

void sub_1D349C2F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23,void *a24,void *a25)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a23);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v27);

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE_(void *a1, uint64_t a2)
{
  a1[4] = *(id *)(a2 + 32);
  id result = *(id *)(a2 + 40);
  uint64_t v6 = *(void *)(a2 + 48);
  uint64_t v5 = *(void *)(a2 + 56);
  a1[5] = result;
  a1[6] = v6;
  a1[7] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c61_ZTSKZZL21StartExternalProgressP10NSProgressENK3__2clEvEUlvE_(uint64_t a1)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  id v3 = *(void **)(a1 + 32);
}

uint64_t ___ZL19EndExternalProgressP10NSProgressP14DSFileProgress_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) stopObserving];
}

id __copy_helper_block_ea8_32c63_ZTSKZL19EndExternalProgressP10NSProgressP14DSFileProgressE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c63_ZTSKZL19EndExternalProgressP10NSProgressP14DSFileProgressE3__0(uint64_t a1)
{
}

void *std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1D349C74C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<TKeyValueObserver>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 3);
    if (v10 + 1 > 0x666666666666666) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= v10 + 1) {
      uint64_t v12 = v10 + 1;
    }
    if (v11 >= 0x333333333333333) {
      unint64_t v13 = 0x666666666666666;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      BOOL v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TKeyValueObserver>>(v4, v13);
    }
    else {
      BOOL v14 = 0;
    }
    int v15 = v14;
    TString v16 = &v14[40 * v10];
    id v18 = &v14[40 * v13];
    TKeyValueObserver::TKeyValueObserver(v16, a2);
    long long v17 = v16 + 40;
    std::vector<TKeyValueObserver>::__swap_out_circular_buffer(a1, &v15);
    uint64_t v9 = a1[1];
    uint64_t result = std::__split_buffer<TKeyValueObserver>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t result = TKeyValueObserver::TKeyValueObserver(*(void *)(v4 - 8), a2);
    uint64_t v9 = v7 + 40;
    a1[1] = v7 + 40;
  }
  a1[1] = v9;
  return result;
}

void sub_1D349C8BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TKeyValueObserver>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void TKeyValueObserver::TKeyValueObserver(TKeyValueObserver *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
}

void sub_1D349C90C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D349CCDC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id objc_cast<NSURL,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

uint64_t std::unordered_set<NSObject *>::unordered_set(uint64_t a1, id *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 8 * a3;
    do
    {
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_unique_key_args<std::hash,NSObject * const&>(a1, a2, a2);
      ++a2;
      v5 -= 8;
    }
    while (v5);
  }
  return a1;
}

void sub_1D349CE74(_Unwind_Exception *a1)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_unique_key_args<std::hash,NSObject * const&>(uint64_t a1, id *a2, void *a3)
{
  unint64_t v7 = [*a2 hash];
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(void **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
          if (std::equal_to<NSObject * {__strong}>::operator()(a1 + 44, *((void **)i + 2), *a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x18uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v8;
  *((void *)i + 2) = *a3;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 40);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<true>(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v21 = *(void *)a1;
  id v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)uint64_t i = *v22;
LABEL_38:
    *id v22 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v21 + 8 * v3) = a1 + 16;
  if (*(void *)i)
  {
    unint64_t v23 = *(void *)(*(void *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9) {
        v23 %= v9;
      }
    }
    else
    {
      v23 &= v9 - 1;
    }
    id v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D349D0B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::equal_to<NSObject * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  if (v4 == v5) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = [v4 isEqual:v5];
  }

  return v6;
}

void sub_1D349D130(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<TKeyValueObserver>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 40;
    uint64_t result = TKeyValueObserver::TKeyValueObserver(result - 40, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TKeyValueObserver>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(40 * a2);
}

uint64_t std::__split_buffer<TKeyValueObserver>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    TKeyValueObserver::~TKeyValueObserver((TKeyValueObserver *)(i - 40));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::find<TString>(uint64_t a1, CFStringRef *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    BOOL v6 = TString::operator<((CFStringRef *)(v3 + 32), a2);
    uint64_t v7 = (uint64_t *)(v3 + 8);
    if (!v6)
    {
      uint64_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v5 == v2 || TString::operator<(a2, (CFStringRef *)(v5 + 32))) {
    return v2;
  }
  return v5;
}

uint64_t *std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  BOOL v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  BOOL v6 = (uint64_t **)v3[2];
  uint64_t v7 = *v6;
  if (*v6 == v3)
  {
    uint64_t *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      uint64_t v7 = 0;
      uint64_t result = (uint64_t *)v2;
    }
    else
    {
      uint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *uint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
      *(unsigned char *)(v12 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
      unint64_t v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *unint64_t v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        uint64_t result = v7;
      }
      uint64_t v7 = *(uint64_t **)(*v7 + 8);
    }
    float v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      float v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
        *((unsigned char *)v7 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
        uint64_t v22 = v15[1];
        uint64_t *v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        void v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        float v16 = v7;
      }
      else
      {
        float v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
      *((unsigned char *)v16 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
      id v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      id v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *id v24 = v23;
      goto LABEL_72;
    }
    float v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
    BOOL v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      BOOL v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    uint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
    *(unsigned char *)(v12 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      uint64_t result = v7;
    }
    uint64_t v7 = *(uint64_t **)v12;
  }
  unint64_t v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  size_t v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
    BOOL v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    size_t v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
    *((unsigned char *)v7 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    id v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    uint64_t *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    unint64_t v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
  *((unsigned char *)v19 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
  id v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  id v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

void std::__shared_ptr_emplace<TExternalOperationCanceller>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB320;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TExternalOperationCanceller>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB320;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

uint64_t std::__shared_ptr_emplace<TExternalOperationCanceller>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 24))();
}

uint64_t TExternalOperationCanceller::CancelTaskForProgress(id *this)
{
  if ([this[1] isCancellable]) {
    [this[1] cancel];
  }
  return 1;
}

void *TExternalOperationCanceller::TaskIsPausable(TExternalOperationCanceller *this)
{
  uint64_t result = (void *)*((void *)this + 1);
  if (result) {
    return (void *)[result isPausable];
  }
  return result;
}

uint64_t TExternalOperationCanceller::PauseTaskForProgress(id *this)
{
  return 1;
}

void TExternalOperationCanceller::~TExternalOperationCanceller(id *this)
{
}

{
  uint64_t vars8;

  JUMPOUT(0x1D9436740);
}

uint64_t *std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__emplace_unique_key_args<TString,std::pair<TString,TProgressInfo>>(uint64_t **a1, CFStringRef *a2, uint64_t a3)
{
  int v5 = (uint64_t **)std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__find_equal<TString>((uint64_t)a1, &v11, a2);
  BOOL v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    BOOL v6 = (uint64_t *)operator new(0xA0uLL);
    v9[1] = a1 + 1;
    std::pair<TString const,TProgressInfo>::pair[abi:ne180100]<TString,TProgressInfo,0>((uint64_t)(v6 + 4), a3);
    char v10 = 1;
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, v11, v7, v6);
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<TString,TProgressInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<TString,TProgressInfo>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

void *std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__find_equal<TString>(uint64_t a1, void *a2, CFStringRef *a3)
{
  int v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = (void *)v4;
        int v8 = (CFStringRef *)(v4 + 32);
        if (!TString::operator<(a3, (CFStringRef *)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v7;
        int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!TString::operator<(v8, a3)) {
        break;
      }
      int v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::pair<TString const,TProgressInfo>::pair[abi:ne180100]<TString,TProgressInfo,0>(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a2, &stru_1F2ABD380);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  long long v4 = *(_OWORD *)(a2 + 24);
  long long v5 = *(_OWORD *)(a2 + 40);
  long long v6 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 71) = *(_OWORD *)(a2 + 71);
  *(_OWORD *)(a1 + 56) = v6;
  *(_OWORD *)(a1 + 40) = v5;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v4;
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 88), &stru_1F2ABD380);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  long long v7 = *(_OWORD *)(a2 + 112);
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  *(_OWORD *)(a1 + 112) = v7;
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<TString,TProgressInfo>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<TString,TProgressInfo>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::pair<TString,TProgressInfo>::~pair((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void TKeyValueObserver::StartObserving<std::function<void ()(void)>>(TKeyValueObserver *a1, void *a2, const TString *a3, uint64_t a4, uint64_t a5)
{
  v12[1] = *(id *)MEMORY[0x1E4F143B8];
  uint64_t v9 = a2;
  v12[0] = v9;
  std::unordered_set<NSObject *>::unordered_set((uint64_t)v11, v12, 1);
  TKeyValueObserver::CreateObserver((uint64_t)a1, a4, (uint64_t)v11, (uint64_t)a3);
  char v10 = (DS_TKeyValueObserverGlue *)objc_claimAutoreleasedReturnValue();
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v11);
  TKeyValueObserver::StartObservingPriv(a1, v10, v9, a3, a5);
}

void sub_1D349DB68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  }
  return a1;
}

void TBusyFolders::StopObserving(TBusyFolders *this)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders13StopObservingEv_block_invoke;
  block[3] = &__block_descriptor_40_ea8_32c43_ZTSKZN12TBusyFolders13StopObservingEvE3__0_e5_v8__0l;
  TString block[4] = this;
  dispatch_async((dispatch_queue_t)gSystemNotificationStreamGCDQueue, block);
}

void TSystemNotificationTask::FinalizeSystemNotificationTask(TSystemNotificationTask *this)
{
  std::mutex::lock(&gBusyFoldersLock);
  uint64_t v1 = TSystemNotificationTask::gSystemNotificationTask;
  if (TSystemNotificationTask::gSystemNotificationTask)
  {
    TBusyFolders::StopObserving((TBusyFolders *)TSystemNotificationTask::gBusyFolders);
    MEMORY[0x1D9436740](v1, 0xC400A2AC0F1);
  }
  TSystemNotificationTask::gSystemNotificationTasuint64_t k = 0;
  std::mutex::unlock(&gBusyFoldersLock);
}

const void **TSystemNotificationTask::HandleBusyFoldersChanges(TSystemNotificationTask *this, const __FSEventStream *a2, const void **a3, const char **a4, int *a5, const unsigned int *a6, const unint64_t *a7)
{
  return TSystemNotificationTask::HandleFSEvent(a3, a4, a5, 0);
}

const void **TSystemNotificationTask::StartObservingDirectory(TString **this, const TString *a2)
{
  char v2 = (char)a2;
  TString::TString(&v7, "/");
  if (TString::EndsWith((TString *)this, &v7))
  {
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&cf, *this);
  }
  else
  {
    long long v4 = *this;
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFStringRef)v4);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = MutableCopy;
    TString::Append((TString *)&cf, (const __CFString *)"/");
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  std::mutex::lock(&gBusyFoldersLock);
  TBusyFolders::StartObservingDirectory((TBusyFolders *)TSystemNotificationTask::gBusyFolders, (const TString *)&cf, v2);
  std::mutex::unlock(&gBusyFoldersLock);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1D349DE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **TBusyFolders::StartObservingDirectory(TBusyFolders *this, const TString *a2, char a3)
{
  long long v6 = (id)gSystemNotificationStreamGCDQueue;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders23StartObservingDirectoryERK7TStringb_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c63_ZTSKZN12TBusyFolders23StartObservingDirectoryERK7TStringbE3__0_e5_v8__0l;
  int v8 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&v8, (TString *)a2->fString.fRef);
  char v9 = a3;
  TString block[4] = this;
  v11.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v11, (TString *)v8);
  char v12 = v9;
  dispatch_async(v6, block);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8);

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
}

void sub_1D349DF80(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

const void **TSystemNotificationTask::StopObservingDirectory(TString **this, const TString *a2)
{
  char v2 = (char)a2;
  TString::TString(&v7, "/");
  if (TString::EndsWith((TString *)this, &v7))
  {
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&cf, *this);
  }
  else
  {
    long long v4 = *this;
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFStringRef)v4);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = MutableCopy;
    TString::Append((TString *)&cf, (const __CFString *)"/");
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  std::mutex::lock(&gBusyFoldersLock);
  TBusyFolders::StopObservingDirectory((TBusyFolders *)TSystemNotificationTask::gBusyFolders, (const TString *)&cf, v2);
  std::mutex::unlock(&gBusyFoldersLock);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1D349E0AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **TBusyFolders::StopObservingDirectory(TBusyFolders *this, const TString *a2, char a3)
{
  long long v6 = (id)gSystemNotificationStreamGCDQueue;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN12TBusyFolders22StopObservingDirectoryERK7TStringb_block_invoke;
  block[3] = &__block_descriptor_56_ea8_32c62_ZTSKZN12TBusyFolders22StopObservingDirectoryERK7TStringbE3__0_e5_v8__0l;
  int v8 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&v8, (TString *)a2->fString.fRef);
  char v9 = a3;
  TString block[4] = this;
  v11.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v11, (TString *)v8);
  char v12 = v9;
  dispatch_async(v6, block);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8);

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
}

void sub_1D349E204(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

void CloseFSEventStream(__FSEventStream *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    char v2 = LogObj(5);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 134217984;
      long long v4 = a1;
      _os_log_impl(&dword_1D343E000, v2, OS_LOG_TYPE_DEFAULT, "Closing FSEvent Stream %p", (uint8_t *)&v3, 0xCu);
    }

    FSEventStreamStop(a1);
    FSEventStreamInvalidate(a1);
    FSEventStreamRelease(a1);
  }
}

void ___ZN12TBusyFolders23StartObservingDirectoryERK7TStringb_block_invoke(uint64_t a1)
{
  char v2 = *(void **)(a1 + 32);
  std::mutex::lock(&gBusyFoldersLock);
  int v3 = v2 + 2;
  while (1)
  {
    int v3 = (void *)*v3;
    if (!v3) {
      break;
    }
    if (*((unsigned char *)v3 + 36)) {
      BOOL v4 = *(unsigned char *)(a1 + 48) != 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (CheckInterestedInPath((TString *)(a1 + 40), (TString *)v3 + 2, v4))
    {
      int v5 = *((_DWORD *)v3 + 8);
      *((_DWORD *)v3 + 8) = v5 + 1;
      if (!v5)
      {
        CFTypeRef cf = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v3[2]);
        long long v6 = (TString *)cf;
        if (cf)
        {
          CFTypeRef v7 = CFRetain(cf);
          long long v6 = (TString *)static_cf_cast<__CFString const*,void const*>(v7);
          if (v6)
          {
            CFTypeRef v8 = CFAutorelease(v6);
            long long v6 = (TString *)static_cf_cast<__CFString const*,void const*>(v8);
          }
        }
        FSEventStreamForPath = CreateFSEventStreamForPath(v6, (void (__cdecl *)(ConstFSEventStreamRef, void *, size_t, void *, const FSEventStreamEventFlags *, const FSEventStreamEventId *))TSystemNotificationTask::HandleBusyFoldersChanges, 0);
        char v10 = std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::find<TString>(v2, (TString *)&cf);
        if (v10 && *((int *)v10 + 8) >= 1 && !v10[3]) {
          v10[3] = (uint64_t *)FSEventStreamForPath;
        }
        else {
          CloseFSEventStream(FSEventStreamForPath);
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      }
      break;
    }
  }
  std::mutex::unlock(&gBusyFoldersLock);
}

void sub_1D349E430(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  std::mutex::unlock(&gBusyFoldersLock);
  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c63_ZTSKZN12TBusyFolders23StartObservingDirectoryERK7TStringbE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = &stru_1F2ABD380;
  *(void *)(a1 + 32) = v4;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 40), *(TString **)(a2 + 40));
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
}

void sub_1D349E4C4(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **__destroy_helper_block_ea8_32c63_ZTSKZN12TBusyFolders23StartObservingDirectoryERK7TStringbE3__0(uint64_t a1)
{
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 40));
}

void ___ZN12TBusyFolders13StopObservingEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  std::mutex::lock(&gBusyFoldersLock);
  int v2 = *(_DWORD *)(v1 + 48);
  if (v2) {
    notify_cancel(v2);
  }
  *(_DWORD *)(v1 + 48) = 0;
  dispatch_assert_queue_V2((dispatch_queue_t)gSystemNotificationStreamGCDQueue);
  CloseFSEventStream(*(__FSEventStream **)(v1 + 40));
  dispatch_assert_queue_V2((dispatch_queue_t)gSystemNotificationStreamGCDQueue);
  *(void *)(v1 + 40) = 0;
  std::mutex::unlock(&gBusyFoldersLock);
}

void sub_1D349E554(_Unwind_Exception *a1)
{
}

uint64_t __copy_helper_block_ea8_32c43_ZTSKZN12TBusyFolders13StopObservingEvE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

void ___ZN12TBusyFolders22StopObservingDirectoryERK7TStringb_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  std::mutex::lock(&gBusyFoldersLock);
  int v3 = (uint64_t *)(v2 + 16);
  while (1)
  {
    int v3 = (uint64_t *)*v3;
    if (!v3) {
      break;
    }
    if (*((unsigned char *)v3 + 36)) {
      BOOL v4 = *(unsigned char *)(a1 + 48) != 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (CheckInterestedInPath((TString *)(a1 + 40), (TString *)v3 + 2, v4))
    {
      int v5 = *((_DWORD *)v3 + 8);
      BOOL v6 = __OFSUB__(v5, 1);
      int v7 = v5 - 1;
      if (v7 < 0 == v6)
      {
        *((_DWORD *)v3 + 8) = v7;
        if (!v7)
        {
          CFTypeRef v8 = (__FSEventStream *)v3[3];
          v3[3] = 0;
          CloseFSEventStream(v8);
        }
      }
      break;
    }
  }
  std::mutex::unlock(&gBusyFoldersLock);
}

void sub_1D349E624(_Unwind_Exception *a1)
{
}

void __copy_helper_block_ea8_32c62_ZTSKZN12TBusyFolders22StopObservingDirectoryERK7TStringbE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = &stru_1F2ABD380;
  *(void *)(a1 + 32) = v4;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 40), *(TString **)(a2 + 40));
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
}

void sub_1D349E69C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **__destroy_helper_block_ea8_32c62_ZTSKZN12TBusyFolders22StopObservingDirectoryERK7TStringbE3__0(uint64_t a1)
{
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 40));
}

BOOL CheckInterestedInPath(TString *a1, TString *a2, int a3)
{
  BOOL result = TString::BeginsWith(a1, a2);
  if ((result & 1) == 0 && a3)
  {
    return TString::BeginsWith(a2, a1);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__deallocate_node(a1, *(const void ***)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::__deallocate_node(uint64_t a1, const void **a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      int v3 = (const void **)*v2;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2 + 2);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void sub_1D349E830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  TDSMutex::unlock(v10);

  _Unwind_Resume(a1);
}

void TDSHelperContext::HandleHelperEvent(void *a1, void *a2)
{
  xpc_object_t xdict = a2;
  if (MEMORY[0x1D9437530]() == MEMORY[0x1E4F145A8])
  {
    int v3 = xdict;
    if (xdict == (xpc_object_t)MEMORY[0x1E4F14528])
    {
      uint64_t v4 = (void *)a1[19];
      a1[19] = 0;

      int v3 = xdict;
    }
    TDSHelperContext::ReplyReceived((uint64_t)a1, v3);
  }
  else if (xpc_dictionary_get_string(xdict, "request") && a1[19])
  {
    (*(void (**)(void *))(*a1 + 16))(a1);
  }
}

void sub_1D349E930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t TDSHelperContext::TDSHelperContext(uint64_t a1, int a2, TString *a3)
{
  *(void *)a1 = &unk_1F2ABA9B0;
  *(void *)(a1 + 8) = 850045863;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 6TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 72) = 1018212795;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  BOOL v6 = operator new(0x58uLL);
  v6[1] = 0;
  void v6[2] = 0;
  void *v6 = &unk_1F2ABB438;
  void v6[3] = 850045863;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  v6[10] = 0;
  *(void *)(a1 + 160) = &stru_1F2ABD380;
  *(void *)(a1 + 120) = v6 + 3;
  *(void *)(a1 + 128) = v6;
  *(_DWORD *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 14TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(_DWORD *)(a1 + 148) = a2;
  *(void *)(a1 + 152) = 0;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 160), a3);
  *(void *)(a1 + 18TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  return a1;
}

void sub_1D349EACC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);

  TConditionVariable::~TConditionVariable(v3);
  std::mutex::~mutex(v1);
  _Unwind_Resume(a1);
}

void TConditionVariable::~TConditionVariable(std::condition_variable *this)
{
  uint64_t v2 = *(std::__shared_weak_count **)this[1].__cv_.__opaque;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  std::condition_variable::~condition_variable(this);
}

void TDSHelperContext::~TDSHelperContext(TDSHelperContext *this)
{
  *(void *)this = &unk_1F2ABA9B0;
  TDSHelperContext::Disconnect(this);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 20);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 72));
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
}

{
  uint64_t vars8;

  TDSHelperContext::~TDSHelperContext(this);
  JUMPOUT(0x1D9436740);
}

void TDSHelperContext::Disconnect(TDSHelperContext *this)
{
  uint64_t v1 = (void *)*((void *)this + 19);
  if (v1)
  {
    *((void *)this + 19) = 0;

    [*((id *)this + 25) clearHelper];
    int v3 = (void *)*((void *)this + 25);
    *((void *)this + 25) = 0;
  }
}

int64_t TDSHelperContext::LaunchDesktopServicesHelper(TDSHelperContext *this, BOOL a2, BOOL a3)
{
  if (*((void *)this + 19)) {
    return 0;
  }
  int v7 = DesktopServicesHelperServiceName();
  CFTypeRef v8 = dispatch_get_global_queue(0, 0);
  xpc_connection_t mach_service = xpc_connection_create_mach_service(v7, v8, 2uLL);
  char v10 = (void *)*((void *)this + 19);
  *((void *)this + 19) = mach_service;

  if (!*((void *)this + 19)) {
    return 4294959234;
  }
  TString v11 = [[DS_TDSHelperConnectionHandler alloc] initWithHelper:this];
  char v12 = (void *)*((void *)this + 25);
  *((void *)this + 25) = v11;

  id v13 = *((id *)this + 25);
  uint64_t v14 = (_xpc_connection_s *)*((void *)this + 19);
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 3221225472;
  handler[2] = ___ZN16TDSHelperContext27LaunchDesktopServicesHelperEbb_block_invoke;
  handler[3] = &unk_1E698FEA8;
  id v15 = v13;
  id v23 = v15;
  xpc_connection_set_event_handler(v14, handler);
  xpc_connection_resume(*((xpc_connection_t *)this + 19));
  BOOL v17 = TDSHelperContext::CreateMessageForHelper(v16, "Handshake");
  xpc_dictionary_set_BOOL(v17, "authorizeImmediately", a2);
  char v18 = UseFileProviderFramework();
  xpc_dictionary_set_BOOL(v17, "ENABLE_FILE_PROVIDER", v18);
  xpc_dictionary_set_BOOL(v17, "FXEnableResumableCopies", a3);
  xpc_dictionary_set_uint64(v17, "processOptions", *((unsigned int *)this + 37));
  if (CFStringGetLength(*((CFStringRef *)this + 20)))
  {
    unint64_t v19 = (const char *)TString::c_str((TString *)this + 20);
    xpc_dictionary_set_string(v17, "AuthMessage", v19);
  }
  xpc_object_t v20 = xpc_connection_send_message_with_reply_sync(*((xpc_connection_t *)this + 19), v17);
  if (MEMORY[0x1D9437530]() == MEMORY[0x1E4F14590]) {
    int64_t int64 = xpc_dictionary_get_int64(v20, "errorStatus");
  }
  else {
    int64_t int64 = 4294959234;
  }

  return int64;
}

void sub_1D349EE84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN16TDSHelperContext27LaunchDesktopServicesHelperEbb_block_invoke(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) handleHelperEvent:a2];
}

id TDSHelperContext::CreateMessageForHelper(TDSHelperContext *this, const char *a2)
{
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v3, "request", a2);
  char v4 = UseFileProviderFramework();
  xpc_dictionary_set_BOOL(v3, "UseFileProviderFramework", v4);
  return v3;
}

void sub_1D349EF44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TDSHelperContext::ReplyReceived(uint64_t a1, void *a2)
{
  id v4 = a2;
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (*(unsigned char *)(a1 + 144))
  {
    *(unsigned char *)(a1 + 14TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
    objc_storeStrong((id *)(a1 + 192), a2);
    TConditionVariable::Signal((TConditionVariable *)(a1 + 72));
  }
  std::mutex::unlock((std::mutex *)(a1 + 8));
}

void sub_1D349EFD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex::unlock(v10);

  _Unwind_Resume(a1);
}

void TDSHelperContext::UpdateDestinationSpaceNeeds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, const char *a16, const char *a17, uint64_t a18, unint64_t a19, int a20,char a21,char a22,int a23)
{
  *(void *)a2 = a3;
  *(void *)(a2 + 8) = a4;
  *(void *)(a2 + 16) = a5;
  *(void *)(a2 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = a6;
  *(unsigned char *)(a2 + 2168) = a22;
  if (a21)
  {
    *(void *)(a2 + 48) = a8;
    *(void *)(a2 + 56) = a9;
    *(void *)(a2 + 32) = a7;
    *(void *)(a2 + 40) = a10;
    *(void *)(a2 + 6TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = a11;
    *(void *)(a2 + 72) = a12;
    id v24 = (char *)(a2 + 104);
    *(void *)(a2 + 80) = a13;
    *(void *)(a2 + 88) = a14;
    if (a16) {
      uint64_t v25 = a16;
    }
    else {
      uint64_t v25 = "";
    }
    *(void *)(a2 + 96) = a15;
    strlcpy(v24, v25, 0x400uLL);
    if (a17) {
      uint64_t v26 = a17;
    }
    else {
      uint64_t v26 = "";
    }
    strlcpy((char *)(a2 + 1128), v26, 0x400uLL);
  }
  else
  {
    *(unsigned char *)(a2 + 1128) = 0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 6TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 89) = 0u;
  }
  *(void *)(a2 + 2152) = a18;
  if (*(void *)(a2 + 2160) < a19) {
    *(void *)(a2 + 2160) = a19;
  }
  *(_DWORD *)(a2 + 2172) |= a20;
  if (*(_DWORD *)(a2 + 2176)) {
    *(_DWORD *)(a2 + 2176) = a23;
  }
}

id TDSHelperContext::SendMessageAndWait(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(void *)(a1 + 152))
  {
    id v4 = (std::mutex *)(a1 + 8);
    std::mutex::lock((std::mutex *)(a1 + 8));
    *(unsigned char *)(a1 + 14TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 1;
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 152), v3);
    TConditionVariable::Wait((TConditionVariable *)(a1 + 72), (std::mutex *)(a1 + 8));
    if (!*(void *)(a1 + 152))
    {
      [*(id *)(a1 + 200) clearHelper];
      int v5 = *(void **)(a1 + 200);
      *(void *)(a1 + 200) = 0;
    }
    id v6 = *(id *)(a1 + 192);
    std::mutex::unlock(v4);
  }
  else
  {
    id v6 = (id)MEMORY[0x1E4F14528];
    id v7 = MEMORY[0x1E4F14528];
  }

  return v6;
}

void sub_1D349F1AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::FilesCopyChildCreateLock(uint64_t a1, void *a2, void *a3, void *a4, void *a5, int64_t a6, int a7, unsigned int a8, BOOL value, const void **a10, BOOL *a11)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v33 = a2;
  id v32 = a3;
  id v29 = a4;
  long long v31 = a5;
  *a11 = 0;
  BOOL v17 = TDSHelperContext::CreateMessageForHelper(v31, "FilesCopyChildCreateLock");
  char v18 = [(id)objc_opt_class() wrapperWithURL:v33 readonly:0 error:0];
  unint64_t v19 = [(id)objc_opt_class() wrapperWithURL:v32 readonly:1 error:0];
  xpc_object_t v20 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v18 requiringSecureCoding:1 error:0];
  objc_msgSend(MEMORY[0x1E4F28DB0], "archivedDataWithRootObject:requiringSecureCoding:error:", v19, 1, 0, v20);
  id v30 = (id)objc_claimAutoreleasedReturnValue();
  id v21 = v20;
  xpc_dictionary_set_data(v17, "parentURLWrapper", (const void *)[v21 bytes], objc_msgSend(v21, "length"));
  id v22 = v30;
  xpc_dictionary_set_data(v17, "sourceURLWrapper", (const void *)[v22 bytes], objc_msgSend(v22, "length"));
  id v23 = v29;
  xpc_dictionary_set_string(v17, "newName", (const char *)[v23 UTF8String]);
  xpc_dictionary_set_uint64(v17, "processOptions", a8);
  xpc_dictionary_set_BOOL(v17, "copyIsDuplication", value);
  *(void *)uuid = 0;
  uint64_t v36 = 0;
  [(TDSHelperContext *)v31 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v17, "GroupUUID", uuid);
  xpc_dictionary_set_int64(v17, "GroupCount", a6);
  xpc_dictionary_set_BOOL(v17, "UseFileProviderFramework", 0);
  id v24 = TDSHelperContext::SendMessageAndWait(a1, v17);
  uint64_t v25 = v24;
  int64_t int64 = 4294959293;
  if (v24 != (void *)MEMORY[0x1E4F14528])
  {
    if (v24)
    {
      if (v24 != (void *)MEMORY[0x1E4F14520])
      {
        int64_t int64 = xpc_dictionary_get_int64(v24, "errorStatus");
        if (!int64)
        {
          *a11 = xpc_dictionary_get_BOOL(v25, "resultIsClone");
          string = xpc_dictionary_get_string(v25, "resultPath");
          TString::TString((TString *)&cf, string);
          if (&cf != a10)
          {
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a10, &cf);
            CFRetain(&stru_1F2ABD380);
            if (cf) {
              CFRelease(cf);
            }
            CFTypeRef cf = &stru_1F2ABD380;
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
          if (CFStringGetLength((CFStringRef)*a10)) {
            int64_t int64 = 0;
          }
          else {
            int64_t int64 = 4294959236;
          }
        }
      }
    }
  }

  return int64;
}

void sub_1D349F528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

int64_t TDSHelperContext::FilesCopyDeleteLock(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v7 = a2;
  id v8 = a3;
  char v9 = a4;
  char v10 = TDSHelperContext::CreateMessageForHelper(v9, "FilesCopyDeleteLock");
  TString v11 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v7 requiringSecureCoding:1 error:0];
  char v12 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v8 requiringSecureCoding:1 error:0];
  id v13 = v11;
  xpc_dictionary_set_data(v10, "lockURLWrapper", (const void *)[v13 bytes], objc_msgSend(v13, "length"));
  id v14 = v12;
  xpc_dictionary_set_data(v10, "sourceURLWrapper", (const void *)[v14 bytes], objc_msgSend(v14, "length"));
  *(void *)uuid = 0;
  uint64_t v20 = 0;
  [(TDSHelperContext *)v9 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v10, "GroupUUID", uuid);
  id v15 = TDSHelperContext::SendMessageAndWait(a1, v10);
  float v16 = v15;
  int64_t int64 = 4294959293;
  if (v15 != (void *)MEMORY[0x1E4F14528] && v15 && v15 != (void *)MEMORY[0x1E4F14520]) {
    int64_t int64 = xpc_dictionary_get_int64(v15, "errorStatus");
  }

  return int64;
}

void sub_1D349F7A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::FilesCopyDeleteItem(uint64_t a1, void *a2, unsigned int a3, BOOL a4, BOOL a5)
{
  char v9 = a2;
  char v10 = TDSHelperContext::CreateMessageForHelper(v9, "DeleteItem");
  id v11 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v9 requiringSecureCoding:1 error:0];
  xpc_dictionary_set_data(v10, "sourceURLWrapper", (const void *)[v11 bytes], objc_msgSend(v11, "length"));
  xpc_dictionary_set_uint64(v10, "mergeResolution", a3);
  xpc_dictionary_set_BOOL(v10, "deleteLocked", a4);
  xpc_dictionary_set_BOOL(v10, "deleteBusy", a5);
  xpc_dictionary_set_BOOL(v10, "reportProgress", 0);
  char v12 = TDSHelperContext::SendMessageAndWait(a1, v10);
  id v13 = v12;
  int64_t int64 = 4294959293;
  if (v12 != (void *)MEMORY[0x1E4F14528] && v12 && v12 != (void *)MEMORY[0x1E4F14520]) {
    int64_t int64 = xpc_dictionary_get_int64(v12, "errorStatus");
  }

  return int64;
}

void sub_1D349F960(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::FilesCopySetRootMetadata(uint64_t a1, void *a2, void *a3, void *a4, unsigned int a5, _DWORD *a6)
{
  id v11 = a2;
  id v27 = a3;
  uint64_t v25 = v11;
  uint64_t v26 = a4;
  char v12 = TDSHelperContext::CreateMessageForHelper(v26, "RunFilesCopyRunSetRootMetadata");
  id v13 = [(id)objc_opt_class() wrapperWithURL:v11 readonly:1 error:0];
  id v14 = [(id)objc_opt_class() wrapperWithURL:v27 readonly:0 error:0];
  id v24 = a6;
  id v15 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v13 requiringSecureCoding:1 error:0];
  float v16 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v14 requiringSecureCoding:1 error:0];
  id v17 = v15;
  xpc_dictionary_set_data(v12, "sourceURLWrapper", (const void *)[v17 bytes], objc_msgSend(v17, "length"));
  id v18 = v16;
  xpc_dictionary_set_data(v12, "destinationURLWrapper", (const void *)[v18 bytes], objc_msgSend(v18, "length"));
  unint64_t v19 = v26;
  xpc_dictionary_set_string(v12, "targetName", (const char *)[(TDSHelperContext *)v19 UTF8String]);
  xpc_dictionary_set_int64(v12, "requestedOperation", a5);
  uint64_t v20 = TDSHelperContext::SendMessageAndWait(a1, v12);
  uint64_t v21 = v20;
  int64_t int64 = 4294959293;
  if (v20 != (void *)MEMORY[0x1E4F14528] && v20 && v20 != (void *)MEMORY[0x1E4F14520])
  {
    *id v24 = xpc_dictionary_get_int64(v20, "completedOperation");
    int64_t int64 = xpc_dictionary_get_int64(v21, "errorStatus");
  }

  return int64;
}

void sub_1D349FBD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::FilesCopyOperationSize(uint64_t a1, void *a2, void *a3, void *a4, unsigned int a5, __int16 a6, int64_t *a7, unsigned int a8, void *a9, int64_t *a10)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  id v56 = a2;
  id v55 = a3;
  id v49 = a4;
  uint64_t v52 = a9;
  int64_t v16 = *a7;
  int64_t v17 = a7[1];
  int64_t v19 = a7[2];
  int64_t v18 = a7[3];
  int64_t v47 = a7[269];
  uint64_t v20 = TDSHelperContext::CreateMessageForHelper(v52, "FilesCopyOperationSizing");
  int v58 = [(id)objc_opt_class() wrapperWithURL:v56 readonly:1 error:0];
  int v57 = [(id)objc_opt_class() wrapperWithURL:v55 readonly:0 error:0];
  uint64_t v50 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v58 requiringSecureCoding:1 error:0];
  uint64_t v51 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v57 requiringSecureCoding:1 error:0];
  id v54 = v50;
  xpc_dictionary_set_data(v20, "sourceURLWrapper", (const void *)[v54 bytes], objc_msgSend(v54, "length"));
  id v53 = v51;
  xpc_dictionary_set_data(v20, "destinationURLWrapper", (const void *)[v53 bytes], objc_msgSend(v53, "length"));
  id v44 = v49;
  xpc_dictionary_set_string(v20, "targetName", (const char *)[v44 UTF8String]);
  xpc_dictionary_set_BOOL(v20, "Coordinate", (a6 & 0x2000) != 0);
  xpc_dictionary_set_int64(v20, "requestedOperation", a5);
  xpc_dictionary_set_int64(v20, "conflicts", a8);
  xpc_dictionary_set_int64(v20, "userVisibleItemsTotal", v16);
  xpc_dictionary_set_int64(v20, "FSItemsTotal", v17);
  xpc_dictionary_set_int64(v20, "logicalBytesTotal", v19);
  xpc_dictionary_set_int64(v20, "physicalBytesTotal", v18);
  xpc_dictionary_set_int64(v20, "conflictPhysicalDelta", v47);
  xpc_dictionary_set_BOOL(v20, "canMerge", (a6 & 0x40) == 0);
  *(void *)uuid = 0;
  uint64_t v60 = 0;
  [(TDSHelperContext *)v52 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(v20, "GroupUUID", uuid);
  uint64_t v21 = TDSHelperContext::SendMessageAndWait(a1, v20);
  id v22 = v21;
  int64_t v23 = 4294959293;
  if (v21 != (void *)MEMORY[0x1E4F14528] && v21 && v21 != (void *)MEMORY[0x1E4F14520])
  {
    *a10 = xpc_dictionary_get_int64(v21, "oprecordBytesCompleted");
    int64_t int64 = xpc_dictionary_get_int64(v22, "userVisibleItemsCompleted");
    int64_t v46 = xpc_dictionary_get_int64(v22, "itemsCompleted");
    int64_t v43 = xpc_dictionary_get_int64(v22, "logicalBytesTotal");
    int64_t v42 = xpc_dictionary_get_int64(v22, "physicalBytesTotal");
    int64_t v41 = xpc_dictionary_get_int64(v22, "mergeSourceNewerConflictsCount");
    int64_t v40 = xpc_dictionary_get_int64(v22, "mergeDestinationNewerConflictsCount");
    int64_t v39 = xpc_dictionary_get_int64(v22, "mergeDestinationNewerConflictsBytes");
    int64_t v38 = xpc_dictionary_get_int64(v22, "mergeSourceItemsNotInDestinationCount");
    int64_t v37 = xpc_dictionary_get_int64(v22, "mergeDestinationItemsNotInSourceCount");
    int64_t v36 = xpc_dictionary_get_int64(v22, "mergeMatchedFilesCount");
    int64_t v35 = xpc_dictionary_get_int64(v22, "mergeMatchedFilesBytes");
    int64_t v34 = xpc_dictionary_get_int64(v22, "mergeDiffMetaDataFilesCount");
    int64_t v33 = xpc_dictionary_get_int64(v22, "mergePhysicalDelta");
    string = xpc_dictionary_get_string(v22, "mergeFirstSourceConflictPath");
    uint64_t v25 = xpc_dictionary_get_string(v22, "mergeFirstDestinationConflictPath");
    int64_t v26 = xpc_dictionary_get_int64(v22, "conflictPhysicalDelta");
    uint64_t int64 = xpc_dictionary_get_uint64(v22, "maxFileSize");
    int v28 = xpc_dictionary_get_int64(v22, "conflicts");
    char v29 = xpc_dictionary_get_BOOL(v22, "mergeAllowed");
    char v30 = xpc_dictionary_get_BOOL(v22, "CopyWillClone");
    int64_t v31 = xpc_dictionary_get_int64(v22, "errorStatus");
    TDSHelperContext::UpdateDestinationSpaceNeeds(v31, (uint64_t)a7, int64, v46, v43, v42, v41, v40, v39, v38, v37, v36, v35, v34, v33, string, v25, v26, uint64,
      v28,
      v29,
      v30,
      v31);
    int64_t v23 = xpc_dictionary_get_int64(v22, "errorStatus");
  }

  return v23;
}

void sub_1D34A01B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int64_t TDSHelperContext::PerformFilesCopy(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, BOOL a7, BOOL a8, _DWORD *a9)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  id v15 = a2;
  id v41 = a3;
  id v43 = a4;
  int64_t v40 = a5;
  TDSHelperContext::CreateMessageForHelper(v40, "RunFilesCopyOperation");
  xpc_object_t xdict = (xpc_object_t)objc_claimAutoreleasedReturnValue();
  BOOL v37 = a8;
  BOOL v38 = a7;
  int64_t v16 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v36 = a1;
  int64_t v17 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v18 = 0;
  int64_t v19 = 0;
  while (v18 < [v15 count])
  {
    uint64_t v20 = [v15 objectAtIndexedSubscript:v18];
    uint64_t v21 = objc_opt_class();
    id v44 = v19;
    id v22 = [v21 wrapperWithURL:v20 readonly:1 error:&v44];
    id v23 = v44;

    if (v22)
    {
      [v16 addObject:v22];
      id v24 = [v43 objectAtIndexedSubscript:v18];
      [v17 addObject:v24];
    }
    ++v18;
    int64_t v19 = v23;
  }
  uint64_t v25 = [(id)objc_opt_class() wrapperWithURL:v41 readonly:0 error:0];
  id v34 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v16 requiringSecureCoding:1 error:0];
  id v33 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v25 requiringSecureCoding:1 error:0];
  id v35 = [MEMORY[0x1E4F28DB0] archivedDataWithRootObject:v43 requiringSecureCoding:1 error:0];
  xpc_dictionary_set_int64(xdict, "requestedOperation", 2);
  id v26 = v34;
  xpc_dictionary_set_data(xdict, "sourceURLWrappers", (const void *)[v26 bytes], objc_msgSend(v26, "length"));
  id v27 = v33;
  xpc_dictionary_set_data(xdict, "destinationURLWrapper", (const void *)[v27 bytes], objc_msgSend(v27, "length"));
  id v28 = v35;
  xpc_dictionary_set_data(xdict, "targetNames", (const void *)[v28 bytes], objc_msgSend(v28, "length"));
  xpc_dictionary_set_uint64(xdict, "maxFileSize", a6);
  xpc_dictionary_set_BOOL(xdict, "copySync", v38);
  xpc_dictionary_set_BOOL(xdict, "copyIsDuplication", v37);
  *(void *)uuid = 0;
  uint64_t v46 = 0;
  [(TDSHelperContext *)v40 getUUIDBytes:uuid];
  xpc_dictionary_set_uuid(xdict, "GroupUUID", uuid);
  char v29 = TDSHelperContext::SendMessageAndWait(v36, xdict);
  char v30 = v29;
  int64_t int64 = 4294959293;
  if (v29 != (void *)MEMORY[0x1E4F14528] && v29 && v29 != (void *)MEMORY[0x1E4F14520])
  {
    *a9 = xpc_dictionary_get_int64(v29, "completedOperation");
    int64_t int64 = xpc_dictionary_get_int64(v30, "errorStatus");
  }

  return int64;
}

void sub_1D34A0624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void TDSHelperContext::HandleMsgFromHelper(uint64_t a1, const char *a2, void *a3)
{
  id v5 = a3;
  if (!strcmp(a2, "DeleteItem_Reply")
    || !strcmp(a2, "ChildCreateLock_Reply")
    || !strcmp(a2, "RunCopyMoveOperation_Reply")
    || !strcmp(a2, "OperationSizing_Reply")
    || !strcmp(a2, "FilesCopyDeleteLock_Reply")
    || !strcmp(a2, "RunFilesCopyOperation"))
  {
    TDSHelperContext::ReplyReceived(a1, v5);
  }
}

void sub_1D34A07CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void TCloneCache::TCloneCache(TCloneCache *this, char a2)
{
  *(unsigned char *)this = a2;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *((_DWORD *)this + 20) = 1065353216;
}

void TCloneCache::RecordClone(TCloneCache *a1, void *a2, uint64_t *a3)
{
  if (!TCloneCache::HasCloneID(a1, a2))
  {
    if (*(unsigned char *)a1)
    {
      char v10 = a2;
      id v6 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)a1 + 8, a2, (uint64_t)&std::piecewise_construct, &v10);
      uint64_t v8 = *a3;
      uint64_t v7 = a3[1];
      if (v7) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
      }
      char v9 = (std::__shared_weak_count *)v6[4];
      void v6[3] = v8;
      void v6[4] = v7;
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      }
    }
    else
    {
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)a1 + 48, a2, a2);
    }
  }
}

BOOL TCloneCache::HasCloneID(TCloneCache *this, unint64_t *a2)
{
  if (*(unsigned char *)this)
  {
    uint64_t v2 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>((void *)this + 1, a2);
    if (v2)
    {
      id v4 = (void *)v2[3];
      id v3 = (std::__shared_weak_count *)v2[4];
      if (v3)
      {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](v3);
      }
    }
    else
    {
      id v4 = 0;
    }
  }
  else
  {
    id v4 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>((void *)this + 6, a2);
  }
  return v4 != 0;
}

void TCloneCache::RemoveAll(TCloneCache *this)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear((void *)this + 6);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::clear((uint64_t)this + 8);
}

void std::vector<TString>::__vdeallocate(void **a1)
{
  uint64_t v1 = (const void **)*a1;
  if (*a1)
  {
    id v3 = (const void **)a1[1];
    id v4 = v1;
    if (v3 != v1)
    {
      do
        id v3 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3 - 1);
      while (v3 != v1);
      id v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

const void *cf_cast<__CFDictionary const*,void const*>(const void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNullGetTypeID())
    {
      return 0;
    }
    else
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFDictionaryGetTypeID()) {
        return v1;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(void *result)
{
  if (result[3])
  {
    uint64_t v1 = result;
    BOOL result = (void *)result[2];
    if (result)
    {
      do
      {
        CFTypeID v2 = (void *)*result;
        operator delete(result);
        BOOL result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    uint64_t v3 = v1[1];
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TCFURLInfo>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  }
}

void SlashesToColons(const TString *a1@<X0>, TString *a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!CFStringGetLength(a1->fString.fRef)) {
    goto LABEL_12;
  }
  CFStringRef v4 = (const __CFString *)RetainCF<__CFString const*>((const void **)&a1->fString.fRef);
  if (v4)
  {
    CFTypeRef v5 = CFAutorelease(v4);
    CFStringRef v4 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v5);
  }
  if (!CFStringGetCString(v4, buffer, 1024, 0x8000100u))
  {
LABEL_12:
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, (TString *)a1->fString.fRef);
    return;
  }
  char v6 = 0;
  for (uint64_t i = buffer; *i == 47; ++i)
  {
    char *i = 58;
    char v6 = 1;
LABEL_10:
    ;
  }
  if (*i) {
    goto LABEL_10;
  }
  if ((v6 & 1) == 0) {
    goto LABEL_12;
  }
  uint64_t v8 = (TString *)CFStringCreateWithCString(0, buffer, 0x8000100u);
  char v9 = v8;
  a2->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9);
}

void sub_1D34A0C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void TString::TString(TString *this, const TString *a2)
{
  this->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(this, (TString *)a2->fString.fRef);
}

void sub_1D34A0C8C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

CFComparisonResult SpotlightStringCompare(const __CFString *a1, const __CFString *a2)
{
  if (a1)
  {
    if (a2) {
      return CFStringCompare(a1, a2, 0x260uLL);
    }
    else {
      return 1;
    }
  }
  else if (a2)
  {
    return -1;
  }
  else
  {
    return 0;
  }
}

const void **FileSuffixChain@<X0>(TString a1@<0:X0>, TString *a2@<X8>)
{
  a2->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  FileSuffix((const TString *)a1.fString.fRef, (TString *)&v19);
  uint64_t v4 = *MEMORY[0x1E4F44408];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    CFStringRef theString = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&theString, (TString *)v19);
    TString::TString((TString *)&cf, ".");
    BOOL v6 = TString::BeginsWith((TString *)&theString, (const TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v6)
    {
      TString::SubStringFrom((TString *)&v19, 1, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&theString, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    if (!CFStringGetLength(theString)) {
      break;
    }
    uint64_t v7 = [MEMORY[0x1E4F442D8] typeWithFilenameExtension:theString conformingToType:v4];
    uint64_t v8 = v7;
    if (!v7) {
      break;
    }
    if ([v7 isDeclared])
    {

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    }
    else
    {
      id v9 = objc_alloc(MEMORY[0x1E4F22408]);
      char v10 = [v8 identifier];
      uint64_t v11 = (void *)[v9 initWithTypeIdentifier:v10 error:0];

      char v12 = [v11 bundleRecord];
      id v13 = [v12 executableURL];

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      if (!v13) {
        return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19);
      }
    }
    CFIndex Length = CFStringGetLength((CFStringRef)a1.fString.fRef->isa);
    CFIndex v15 = CFStringGetLength(v19);
    TString::SetLength((TString *)a1.fString.fRef, Length - v15);
    CFStringRef v16 = v19;
    CFStringRef theString = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    MutableCFStringRef Copy = CFStringCreateMutableCopy(v5, 0, v16);
    if (theString) {
      CFRelease(theString);
    }
    CFStringRef theString = MutableCopy;
    TString::Append((TString *)&theString, a2);
    if (&theString != (CFStringRef *)a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, (const void **)&theString);
      CFRetain(&stru_1F2ABD380);
      if (theString) {
        CFRelease(theString);
      }
      CFStringRef theString = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    FileSuffix((const TString *)a1.fString.fRef, (TString *)&theString);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v19, (const void **)&theString);
    CFRetain(&stru_1F2ABD380);
    if (theString) {
      CFRelease(theString);
    }
    CFStringRef theString = &stru_1F2ABD380;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19);
}

void sub_1D34A0F68(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

TString *RedactedStr@<X0>(TString *a1@<X0>, TString *a2@<X8>)
{
  if (CFStringGetLength(a1->fString.fRef))
  {
    CFIndex Length = CFStringGetLength(a1->fString.fRef);
    v47.fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v47, (TString *)a1->fString.fRef);
    v5.fString.uint64_t fRef = (__CFString *)&v47;
    FileSuffixChain(v5, &v48);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v47.fString.fRef);
    uint64_t v6 = Length - CFStringGetLength(v48.fString.fRef);
    if (v6 <= 2 && CFStringGetLength(v48.fString.fRef))
    {
      while (1)
      {
        CFIndex v7 = v6 + 1;
        if (v6 + 1 >= Length) {
          break;
        }
        int v8 = v6 < -1 || CFStringGetLength(a1->fString.fRef) <= v7
           ? 0
           : CFStringGetCharacterAtIndex(a1->fString.fRef, v6 + 1);
        uint64_t v9 = v6 + 1;
        if (v6++ >= 2)
        {
          uint64_t v6 = v9;
          if (v8 == 46) {
            break;
          }
        }
      }
      TString::SubStringFrom(a1, v7, &v49);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v48.fString.fRef, (const void **)&v49.fString.fRef);
      CFRetain(&stru_1F2ABD380);
      if (v49.fString.fRef) {
        CFRelease(v49.fString.fRef);
      }
      v49.fString.uint64_t fRef = &stru_1F2ABD380;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v49.fString.fRef);
      uint64_t v6 = v7;
    }
    LODWORD(v36.__r_.__value_.__l.__data_) = 0;
    uint64_t fRef = a1->fString.fRef;
    v49.fString.uint64_t fRef = (__CFString *)MEMORY[0x1E4F143A8];
    uint64_t v50 = 3321888768;
    uint64_t v51 = ___ZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRange_block_invoke;
    uint64_t v52 = &__block_descriptor_40_ea8_32c77_ZTSKZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRangeEUlP8NSStringS3_S3_PbE__e52_v56__0__NSString_8__NSRange_QQ_16__NSRange_QQ_32_B48l;
    id v53 = &v36;
    -[__CFString enumerateSubstringsInRange:options:usingBlock:](fRef, "enumerateSubstringsInRange:options:usingBlock:", 0, Length, 2, &v49);
    uint64_t data_low = SLODWORD(v36.__r_.__value_.__l.__data_);
    if (data_low - CFStringGetLength(v48.fString.fRef) < 3)
    {
      TString::TString(a2, "<private>", 9uLL);
    }
    else
    {
      v46.id location = 0;
      v46.length = 0;
      v46.id location = [(__CFString *)a1->fString.fRef rangeOfComposedCharacterSequenceAtIndex:0];
      v46.length = v13;
      v45.id location = 0;
      v45.length = 0;
      v45.id location = [(__CFString *)a1->fString.fRef rangeOfComposedCharacterSequenceAtIndex:v6 - 1];
      v45.length = v14;
      TString::SubString(a1, &v46, &v44);
      TString::SubString(a1, &v45, &v43);
      LODWORD(v36.__r_.__value_.__l.__data_) = 0;
      CFIndex v15 = a1->fString.fRef;
      v49.fString.uint64_t fRef = (__CFString *)MEMORY[0x1E4F143A8];
      uint64_t v50 = 3321888768;
      uint64_t v51 = ___ZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRange_block_invoke;
      uint64_t v52 = &__block_descriptor_40_ea8_32c77_ZTSKZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRangeEUlP8NSStringS3_S3_PbE__e52_v56__0__NSString_8__NSRange_QQ_16__NSRange_QQ_32_B48l;
      id v53 = &v36;
      -[__CFString enumerateSubstringsInRange:options:usingBlock:](v15, "enumerateSubstringsInRange:options:usingBlock:", v46.length + v46.location, v45.location - (v46.length + v46.location), 2, &v49);
      int data = (int)v36.__r_.__value_.__l.__data_;
      HIBYTE(v51) = 1;
      LOWORD(v49.fString.fRef) = 123;
      v38.fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      if (SHIBYTE(v51) >= 0) {
        int64_t v17 = (__CFString *)&v49;
      }
      else {
        int64_t v17 = v49.fString.fRef;
      }
      if (SHIBYTE(v51) >= 0) {
        CFIndex v18 = HIBYTE(v51);
      }
      else {
        CFIndex v18 = v50;
      }
      TString::SetFromUTF8(&v38, (const UInt8 *)v17, v18);
      CFStringRef v19 = v44.fString.fRef;
      CFTypeRef cf = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      CFAllocatorRef v20 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v19);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = MutableCopy;
      TString::Append((TString *)&cf, &v38);
      std::to_string(&v36, data);
      v37.fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        id v22 = &v36;
      }
      else {
        id v22 = (std::string *)v36.__r_.__value_.__r.__words[0];
      }
      if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFIndex size = HIBYTE(v36.__r_.__value_.__r.__words[2]);
      }
      else {
        CFIndex size = v36.__r_.__value_.__l.__size_;
      }
      TString::SetFromUTF8(&v37, (const UInt8 *)v22, size);
      CFStringRef v24 = (const __CFString *)cf;
      CFTypeRef v40 = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      CFMutableStringRef v25 = CFStringCreateMutableCopy(v20, 0, v24);
      if (v40) {
        CFRelease(v40);
      }
      CFTypeRef v40 = v25;
      TString::Append((TString *)&v40, &v37);
      char v34 = 1;
      LOWORD(__p) = 125;
      v35.fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetFromUTF8(&v35, (const UInt8 *)&__p, 1);
      CFStringRef v26 = (const __CFString *)v40;
      CFTypeRef v41 = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      CFMutableStringRef v27 = CFStringCreateMutableCopy(v20, 0, v26);
      if (v41) {
        CFRelease(v41);
      }
      CFTypeRef v41 = v27;
      TString::Append((TString *)&v41, &v35);
      CFStringRef v28 = (const __CFString *)v41;
      CFTypeRef v42 = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      CFMutableStringRef v29 = CFStringCreateMutableCopy(v20, 0, v28);
      if (v42) {
        CFRelease(v42);
      }
      CFTypeRef v42 = v29;
      TString::Append((TString *)&v42, &v43);
      CFStringRef v30 = (const __CFString *)v42;
      a2->fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      CFMutableStringRef v31 = CFStringCreateMutableCopy(v20, 0, v30);
      if (a2->fString.fRef) {
        CFRelease(a2->fString.fRef);
      }
      a2->fString.uint64_t fRef = v31;
      TString::Append(a2, &v48);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v42);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v41);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v35.fString.fRef);
      if (v34 < 0) {
        operator delete(__p);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v40);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v37.fString.fRef);
      if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v36.__r_.__value_.__l.__data_);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v38.fString.fRef);
      if (SHIBYTE(v51) < 0) {
        operator delete(v49.fString.fRef);
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v43.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44.fString.fRef);
    }
    return (TString *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v48.fString.fRef);
  }
  else
  {
    return TString::TString(a2, "<empty>", 7uLL);
  }
}

void sub_1D34A156C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,int a27,__int16 a28,char a29,char a30,int a31,__int16 a32,char a33,char a34,int a35,__int16 a36,char a37,char a38,int a39,__int16 a40,char a41,char a42,int a43,__int16 a44,char a45,char a46,int a47,__int16 a48,char a49,char a50)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v50 - 128));
  _Unwind_Resume(a1);
}

void AcceptableNames(void)
{
  v21[1] = *(TString *)MEMORY[0x1E4F143B8];
  {
    TString::TString(&v3, "/", 1uLL);
    TString::TString(&v4, "Volumes", 7uLL);
    TString::TString(&v5, "Users", 5uLL);
    TString::TString(&v6, "Applications", 0xCuLL);
    TString::TString(&v7, "Utilities", 9uLL);
    TString::TString(&v8, "System", 6uLL);
    TString::TString(&v9, "Desktop", 7uLL);
    TString::TString(&v10, "Documents", 9uLL);
    TString::TString(&v11, "Downloads", 9uLL);
    TString::TString(&v12, "Library", 7uLL);
    TString::TString(&v13, "Movies", 6uLL);
    TString::TString(&v14, "Music", 5uLL);
    TString::TString(&v15, "Pictures", 8uLL);
    TString::TString(&v16, "Public", 6uLL);
    dispatch_queue_t v0 = (TCFURLInfo *)TString::TString(&v17, "Drop Box", 8uLL);
    PropertyStoreName = TCFURLInfo::GetPropertyStoreName(v0);
    TString::TString(&v18, (const TString *)PropertyStoreName);
    TString::TString(&v19, ".localized", 0xAuLL);
    TString::TString(&v20, ".Trash", 6uLL);
    TString::TString(v21, ".Trashes", 8uLL);
    std::unordered_set<TString>::unordered_set((uint64_t)&AcceptableNames(void)::sNames, &v3, 19);
    for (uint64_t i = 144; i != -8; i -= 8)
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)((char *)&v3.fString.fRef + i));
  }
}

void sub_1D34A1964(_Unwind_Exception *a1)
{
  for (uint64_t i = 144; i != -8; i -= 8)
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v1 + i));
  _Unwind_Resume(a1);
}

id SanitizedURL(NSURL *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = [(NSURL *)v1 path];
  v8.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v8, v2);

  TString v3 = SanitizedPath(&v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);

  if (IsRedactionEnabled()
    && [(NSURL *)v1 isFileURL]
    && ![(NSURL *)v1 isFileReferenceURL])
  {
    TString v6 = NSString;
    TString v7 = [(NSURL *)v1 scheme];
    TString v4 = [v6 stringWithFormat:@"%@://<private> (%@)", v7, v3];
  }
  else
  {
    TString v4 = [NSString stringWithFormat:@"%@ (%@)", v1, v3];
  }

  return v4;
}

void sub_1D34A1ADC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRange_block_invoke(uint64_t result)
{
  return result;
}

uint64_t __copy_helper_block_ea8_32c77_ZTSKZZ11RedactedStrRK7TStringENK3__0clES1_RK8_NSRangeEUlP8NSStringS3_S3_PbE_(uint64_t result, uint64_t a2)
{
  *(void *)(result + ++**(_DWORD **)(result + 32) = *(void *)(a2 + 32);
  return result;
}

uint64_t std::unordered_set<TString>::unordered_set(uint64_t a1, TString *this, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + ++**(_DWORD **)(result + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 8 * a3;
    do
    {
      std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__emplace_unique_key_args<TString,TString const&>(a1, this, (TString **)this);
      ++this;
      v5 -= 8;
    }
    while (v5);
  }
  return a1;
}

void sub_1D34A1BBC(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__emplace_unique_key_args<TString,TString const&>(uint64_t a1, TString *this, TString **a3)
{
  unint64_t v7 = FowlerNollVoHash::hash(this, this);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    TString v12 = *(uint64_t ****)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v14 = (unint64_t)i[1];
        if (v14 == v8)
        {
          if (CFEqual(i[2], this->fString.fRef)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__construct_node_hash<TString const&>(a1, (__CFString *)v8, a3, (uint64_t)v24);
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    void *v21 = v24[0];
  }
  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v22 >= v9) {
          v22 %= v9;
        }
      }
      else
      {
        v22 &= v9 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }
  uint64_t i = (uint64_t **)v24[0];
  v24[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return i;
}

void sub_1D34A1E28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

TString *std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::__construct_node_hash<TString const&>@<X0>(uint64_t a1@<X0>, __CFString *a2@<X1>, TString **a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = (TString *)operator new(0x18uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  v8->fString.uint64_t fRef = 0;
  v8[1].fString.uint64_t fRef = a2;
  BOOL result = std::construct_at[abi:ne180100]<TString,TString const&,TString*>(v8 + 2, a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D34A1EA0(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<TString,std::hash<TString>,std::equal_to<TString>,std::allocator<TString>>::find<TString>(void *a1, TString *this)
{
  unint64_t v4 = FowlerNollVoHash::hash(this, this);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  uint8x8_t v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t i = *v10; i; uint64_t i = (uint64_t **)*i)
  {
    unint64_t v12 = (unint64_t)i[1];
    if (v6 == v12)
    {
      if (CFEqual(i[2], this->fString.fRef)) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

void *TReservationRecord::TReservationRecord(void *a1, uint64_t *a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    int8x8_t v5 = (std::__shared_weak_count *)a1[2];
    a1[1] = v4;
    a1[2] = v3;
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
  else
  {
    a1[1] = v4;
    a1[2] = 0;
  }
  return a1;
}

void TReservationRecord::~TReservationRecord(TReservationRecord *this)
{
  uint64_t v2 = *(TFileCoordinationRecord **)this;
  if (v2)
  {
    TFileCoordinationRecord::~TFileCoordinationRecord(v2);
    MEMORY[0x1D9436740]();
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

uint64_t TReservationRecord::CreateAndAcquireFileCoordinator(TReservationRecord *this, NSFileCoordinator *a2)
{
  uint64_t v3 = a2;
  if (!*(void *)this) {
    operator new();
  }

  return 4294959201;
}

void sub_1D34A214C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A2234(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A25EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34A2E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c62_ZTSKZ49__FINode_fiNodeFromItem_inFPv2Domain_completion__E3__0(void *a1, uint64_t a2)
{
  a1[4] = *(id *)(a2 + 32);
  a1[5] = *(id *)(a2 + 40);
  uint64_t result = MEMORY[0x1D9436FC0](*(void *)(a2 + 48));
  a1[6] = result;
  return result;
}

void __destroy_helper_block_ea8_32c62_ZTSKZ49__FINode_fiNodeFromItem_inFPv2Domain_completion__E3__0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
}

void sub_1D34A31A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34A3258(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1D34A33AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A35C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A3670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A36D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A375C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A3804(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A3DB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A3E28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A3EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A3F98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A4050(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A4108(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A4214(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A4288(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A441C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t FINodeSizingSkipProc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (objc_opt_respondsToSelector()) {
    uint64_t v6 = [v5 FINodeSizingSkip:a1 forParent:a2];
  }
  else {
    uint64_t v6 = 0;
  }

  return v6;
}

void sub_1D34A44AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t FINodeSizingCancelProc(void *a1)
{
  id v1 = a1;
  if (objc_opt_respondsToSelector()) {
    uint64_t v2 = [v1 FINodeSizingCancel];
  }
  else {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_1D34A4510(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A49D4(_Unwind_Exception *a1, void *a2, void *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},FPItem * const {__strong}&,BOOL,void>@<X0>(FIProviderDomain **a1@<X1>, FPItem **a2@<X2>, unsigned __int8 *a3@<X3>, void *a4@<X8>)
{
  unint64_t v8 = (char *)operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},FPItem * const {__strong}&,BOOL,std::allocator<TFSInfo>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1D34A4B74(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},FPItem * const {__strong}&,BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, FPItem **a3, unsigned __int8 *a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), *a2, *a3, *a4);
  return a1;
}

void sub_1D34A4BDC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TFSInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB358;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFSInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB358;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::default_delete<TVersionData>::operator()[abi:ne180100](uint64_t a1, const void **a2)
{
  if (a2)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2 + 3);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2 + 2);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2 + 1);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(a2);
    JUMPOUT(0x1D9436740);
  }
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34A4D78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(a1, a2);
  if (a3 >= 1)
  {
    uint64_t v5 = *(void *)(a1 + 120);
    do
    {
      if (v5 >= *(void *)(a1 + 112) - 1)
      {
        uint64_t v6 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
        uint64_t v5 = -1;
        *(void *)(a1 + 112) = v6;
        *(void *)(a1 + 120) = -1;
      }
      if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
      {
        objc_enumerationMutation(*(id *)a1);
        uint64_t v5 = *(void *)(a1 + 120);
      }
      uint64_t v7 = *(void *)(a1 + 128) + 1;
      *(void *)(a1 + 120) = ++v5;
      *(void *)(a1 + 128) = v7;
      --a3;
    }
    while (a3);
  }
  return a1;
}

void sub_1D34A4E3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::NSForwardIterator<NSMutableArray<FPItem *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 112) = -1;
  uint64_t v5 = (void *)(a1 + 112);
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  uint64_t v6 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 128) = -1;
  if (v4 && [v4 count] && (uint64_t v7 = *(void *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    uint64_t v8 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = **(void **)(a1 + 24);
    uint64_t *v6 = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v9 = *(void *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            void *v5 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            uint64_t v11 = -1;
            uint64_t *v6 = -1;
          }
          if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            uint64_t v11 = *v6;
          }
          uint64_t v13 = *(void *)(a1 + 128) + 1;
          *(void *)(a1 + 120) = ++v11;
          *(void *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(void *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(void *)(a1 + 120) = *(void *)(a2 + 120);
      *(void *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1D34A4FC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSMutableArray<FPItem *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34A5040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItem *>>::NSForwardIterator<NSArray<FPItem *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34A5104(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItem *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34A5184(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL30DefaultContainerOfDomainWithIDRK7TString_block_invoke(uint64_t a1)
{
  return IsDatalessDomain(*(NSURL **)(a1 + 32), 1);
}

id __copy_helper_block_ea8_32c54_ZTSKZL30DefaultContainerOfDomainWithIDRK7TStringE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + ++**(_DWORD **)(result + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c54_ZTSKZL30DefaultContainerOfDomainWithIDRK7TStringE3__0(uint64_t a1)
{
}

id DSLocalizationBundle(void)
{
  if (DSLocalizationBundle(void)::onceToken != -1) {
    dispatch_once(&DSLocalizationBundle(void)::onceToken, &__block_literal_global_3);
  }
  dispatch_queue_t v0 = (void *)DSLocalizationBundle(void)::bundle;
  return v0;
}

void ___Z20DSLocalizationBundlev_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B50] bundleForClass:objc_opt_class()];
  id v1 = (void *)DSLocalizationBundle(void)::bundle;
  DSLocalizationBundle(void)::bundle = v0;
}

id DSLocalizedErrorStringForKey(NSString *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = DSLocalizationBundle();
  id v3 = [v2 localizedStringForKey:v1 value:@"X" table:0];

  if ([v3 isEqualToString:@"X"])
  {
    id v4 = LogObj(2);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = DSLocalizationBundle();
      uint64_t v6 = [v5 bundlePath];
      *(_DWORD *)TPropertyValue buf = 138543618;
      uint64_t v11 = v1;
      __int16 v12 = 2114;
      uint64_t v13 = v6;
      _os_log_impl(&dword_1D343E000, v4, OS_LOG_TYPE_ERROR, "Localized key '%{public}@' missing from DesktopServices (bundlePath:%{public}@)", buf, 0x16u);
    }
    id v7 = [NSString stringWithFormat:@"KEY_MISSING(%@)", v1];
  }
  else
  {
    id v7 = v3;
  }
  uint64_t v8 = v7;

  return v8;
}

void sub_1D34A53F8(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1D34A563C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A5828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A58B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34A5930(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A59E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A5BB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A5D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A5E30(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v2, 0x10E1C4078A9A281);

  _Unwind_Resume(a1);
}

void sub_1D34A5FDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A61DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  __int16 v12 = va_arg(va1, const void *);
  uint64_t v14 = va_arg(va1, void);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);

  _Unwind_Resume(a1);
}

void sub_1D34A662C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  TRef<__CFUserNotification *,TRetainReleasePolicy<__CFUserNotification *>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1D34A67B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1D34A6C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v26 - 104));

  _Unwind_Resume(a1);
}

void sub_1D34A6E64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34A70E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34A7534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_1D34A77E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_1D34A80E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23,void *a24,uint64_t a25,void *a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,void *a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,id a49,uint64_t a50,uint64_t a51,std::__shared_weak_count *a52,id a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  StScopedResourceAccess::~StScopedResourceAccess(&a49);
  if (a52) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a52);
  }
  StScopedResourceAccess::~StScopedResourceAccess(&a53);

  if (a64) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a64);
  }

  _Unwind_Resume(a1);
}

void sub_1D34A83C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34A8B90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,id a53,uint64_t a54,id a55)
{
  StScopedResourceAccess::~StScopedResourceAccess(&a53);
  _Unwind_Resume(a1);
}

void sub_1D34A8E40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c102_ZTSKZ89__DSNSHelperContext_copyItemsAtURLs_toURL_options_conflictStrategy_receiveTargets_error__E3__1(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

void sub_1D34A8F14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void StScopedResourceAccess::StScopedResourceAccess(StScopedResourceAccess *this, NSURL *a2)
{
  id v3 = a2;
  *(void *)this = v3;
  char v4 = [(NSURL *)v3 startAccessingSecurityScopedResource];
  *((unsigned char *)this + 8) = v4;
  if (*(void *)this) {
    char v5 = v4;
  }
  else {
    char v5 = 1;
  }
  if ((v5 & 1) == 0)
  {
    uint64_t v6 = LogObj(2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v7 = 0;
      _os_log_impl(&dword_1D343E000, v6, OS_LOG_TYPE_ERROR, "Failed to access security-scoped resource.", v7, 2u);
    }
  }
}

void sub_1D34A900C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void StScopedResourceAccess::~StScopedResourceAccess(id *this)
{
  if (*((unsigned char *)this + 8)) {
    [*this stopAccessingSecurityScopedResource];
  }
}

const void **TRef<__CFUserNotification *,TRetainReleasePolicy<__CFUserNotification *>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t IsEnhancedAPFSEnabled(void)
{
  return 1;
}

uint64_t BRContainerClass(void)
{
  return objc_opt_class();
}

uint64_t CheckPointXattrName(void)
{
  {
    CheckPointXattrName(void)::sCheckpointXattrNameLegacy = (uint64_t)xattr_name_with_flags("com.apple.finder.copy.checkpoint", 4uLL);
  }
  return CheckPointXattrName(void)::sCheckpointXattrNameLegacy;
}

void sub_1D34A9118(_Unwind_Exception *a1)
{
}

uint64_t SourceInodeXattrName(char a1)
{
  if ((a1 & 1) == 0)
  {
    {
      id v1 = &SourceInodeXattrName(BOOL)::sSourceInodeXattrName;
      return *v1;
    }
    id v1 = &SourceInodeXattrName(BOOL)::sSourceInodeXattrName;
      return *v1;
    SourceInodeXattrName(BOOL)::sSourceInodeXattrName = (uint64_t)xattr_name_without_flags("com.apple.finder.copy.source.inode");
LABEL_11:
    __cxa_guard_release(v3);
    return *v1;
  }
  {
    id v1 = &SourceInodeXattrName(BOOL)::sSourceInodeXattrNameLegacy;
      return *v1;
    SourceInodeXattrName(BOOL)::sSourceInodeXattrNameLegacy = (uint64_t)xattr_name_with_flags("com.apple.finder.copy.source.inode", 4uLL);
    goto LABEL_11;
  }
  id v1 = &SourceInodeXattrName(BOOL)::sSourceInodeXattrNameLegacy;
  return *v1;
}

void sub_1D34A91F8(_Unwind_Exception *a1)
{
}

uint64_t SourceVolumeUUIDXattrName(char a1)
{
  if ((a1 & 1) == 0)
  {
    {
      id v1 = &SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrName;
      return *v1;
    }
    id v1 = &SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrName;
      return *v1;
    SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrName = (uint64_t)xattr_name_without_flags("com.apple.finder.copy.source.volumeuuid");
LABEL_11:
    __cxa_guard_release(v3);
    return *v1;
  }
  {
    id v1 = &SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrNameLegacy;
      return *v1;
    SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrNameLegacy = (uint64_t)xattr_name_with_flags("com.apple.finder.copy.source.volumeuuid", 4uLL);
    goto LABEL_11;
  }
  id v1 = &SourceVolumeUUIDXattrName(BOOL)::sSourceVolumeXattrNameLegacy;
  return *v1;
}

void sub_1D34A92E8(_Unwind_Exception *a1)
{
}

const char *DesktopServicesHelperServiceName(void)
{
  return "com.apple.DesktopServicesHelper";
}

BOOL TCFURLInfo::AreOnSameVolume(TCFURLInfo ***a1, const __CFURL *a2)
{
  CFTypeRef VolumeIdentifier = TCFURLInfo::GetVolumeIdentifier(**a1, a2);
  CFTypeRef cf1 = VolumeIdentifier;
  if (VolumeIdentifier) {
    CFRetain(VolumeIdentifier);
  }
  CFTypeRef v5 = TCFURLInfo::GetVolumeIdentifier(**(TCFURLInfo ***)a2, v4);
  uint64_t v6 = v5;
  uint64_t v9 = v5;
  if (v5)
  {
    CFRetain(v5);
    if (cf1) {
      BOOL v7 = CFEqual(cf1, v6) != 0;
    }
    else {
      BOOL v7 = 0;
    }
  }
  else
  {
    BOOL v7 = cf1 == 0;
  }
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v9);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&cf1);
  return v7;
}

void sub_1D34A93C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

BOOL TCFURLInfo::IsOnSystemVolume(TCFURLInfo **this, const __CFURL *a2)
{
  CFTypeRef VolumeIdentifier = TCFURLInfo::GetVolumeIdentifier(*this, a2);
  *((void *)&v5 + 1) = VolumeIdentifier;
  if (VolumeIdentifier) {
    CFRetain(VolumeIdentifier);
  }
  ROSPVolumeID::BootVolumeID(&v5);
  BOOL v3 = v5 == 0;
  if (*((void *)&v5 + 1) && (void)v5) {
    BOOL v3 = CFEqual(*((CFTypeRef *)&v5 + 1), (CFTypeRef)v5) != 0;
  }
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v5);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v5 + 1);
  return v3;
}

void sub_1D34A945C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t TCFURLInfo::ShowAllExtensions(TCFURLInfo *this)
{
  return TCFURLInfo::gShowAllExtensions;
}

uint64_t TCFURLInfo::GetgidToUse(TCFURLInfo *this)
{
  if (TCFURLInfo::gDSHelperRunning) {
    return TCFURLInfo::ggidToUse;
  }
  else {
    return getgid();
  }
}

void TCFURLInfo::TCFURLInfo(TCFURLInfo *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 2) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 3) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((unsigned char *)this + 4TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 18) = 0;
  int v2 = (*((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16)) & 0xE00100;
  *((_WORD *)this + 38) &= 0x100u;
  *((unsigned char *)this + 78) = BYTE2(v2);
}

void sub_1D34A9548(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TCFURLInfo::TCFURLInfo(TCFURLInfo *this, const TCFURLInfo *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = &stru_1F2ABD380;
  CFURLRef v4 = (TString *)((char *)this + 8);
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 2) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + 3) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *((void *)this + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((unsigned char *)this + 4TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)this, *(CFTypeRef *)a2);
  if (this != a2)
  {
    TString::SetStringRefAsImmutable(v4, *((TString **)a2 + 1));
    TString::SetStringRefAsImmutable((TString *)this + 2, *((TString **)a2 + 2));
    TString::SetStringRefAsImmutable((TString *)this + 3, *((TString **)a2 + 3));
  }
  unsigned int v6 = *((unsigned __int16 *)a2 + 38);
  long long v5 = (unsigned __int16 *)((char *)a2 + 76);
  int v7 = *((_WORD *)this + 38) & 0xFEFF | (*((unsigned __int8 *)this + 78) << 16) | (((v6 >> 8) & 1) << 8);
  *((_WORD *)this + 38) = *((_WORD *)this + 38) & 0xFEFF | (((v6 >> 8) & 1) << 8);
  unsigned int v8 = v7 & 0xFFFFFFFE | *v5 & 1;
  *((_WORD *)this + 38) = v8;
  unsigned int v9 = v8 & 0xFFFFFFFD | (2 * ((*v5 >> 1) & 1));
  *((_WORD *)this + 38) = v9;
  unsigned int v10 = v9 & 0xFFFFFFFB | (4 * ((*v5 >> 2) & 1));
  *((_WORD *)this + 38) = v10;
  unsigned int v11 = v10 & 0xFFFFFFF7 | (8 * ((*v5 >> 3) & 1));
  *((_WORD *)this + 38) = v11;
  unsigned int v12 = v11 & 0xFFFFFFEF | (16 * ((*v5 >> 4) & 1));
  *((_WORD *)this + 38) = v12;
  unsigned int v13 = v12 & 0xFFFFFFDF | (32 * ((*v5 >> 5) & 1));
  *((_WORD *)this + 38) = v13;
  unsigned int v14 = v13 & 0xFFFFFFBF | (((*v5 >> 6) & 1) << 6);
  *((_WORD *)this + 38) = v14;
  unsigned int v15 = v14 & 0xFFFFFF7F | (((*v5 >> 7) & 1) << 7);
  *((_WORD *)this + 38) = v15;
  unsigned int v16 = v15 & 0xFFFFFDFF | (((*v5 >> 9) & 1) << 9);
  *((_WORD *)this + 38) = v16;
  int v17 = *((unsigned __int8 *)v5 + 2) >> 4;
  *((_WORD *)this + 38) = v16;
  unsigned int v18 = v16 & 0xFFEFFFFF | ((v17 & 1) << 20);
  unsigned int v19 = HIWORD(v18);
  *((unsigned char *)this + 78) = BYTE2(v18);
  unsigned int v20 = v18 & 0xFFFFFBFF | (((*v5 >> 10) & 1) << 10);
  *((unsigned char *)this + 78) = v19;
  *((_WORD *)this + 38) = v20;
  unsigned int v21 = v20 & 0xFFFFF7FF | (((*v5 >> 11) & 1) << 11);
  *((unsigned char *)this + 78) = v19;
  *((_WORD *)this + 38) = v21;
  unsigned int v22 = v21 & 0xFFFF7FFF | (((*v5 >> 15) & 1) << 15);
  *((unsigned char *)this + 78) = v19;
  *((_WORD *)this + 38) = v22;
  unsigned int v23 = v22 & 0xFFFFEFFF | (((*v5 >> 12) & 1) << 12);
  *((unsigned char *)this + 78) = v19;
  *((_WORD *)this + 38) = v23;
  unsigned int v24 = v23 & 0xFFFFDFFF | (((*v5 >> 13) & 1) << 13);
  *((unsigned char *)this + 78) = v19;
  *((_WORD *)this + 38) = v24;
  unsigned int v25 = v24 & 0xFFFFBFFF | (((*v5 >> 14) & 1) << 14);
  *((unsigned char *)this + 78) = v19;
  *((_WORD *)this + 38) = v25;
  unsigned int v26 = v25 & 0xFFFEFFFF | ((v5[1] & 1) << 16);
  *((_WORD *)this + 38) = v25;
  *((unsigned char *)this + 78) = BYTE2(v26);
  unsigned int v27 = v26 & 0xFFFDFFFF | (((*((unsigned __int8 *)v5 + 2) >> 1) & 1) << 17);
  *((_WORD *)this + 38) = v25;
  *((unsigned char *)this + 78) = BYTE2(v27);
  unsigned int v28 = v27 & 0xFFFBFFFF | (((*((unsigned __int8 *)v5 + 2) >> 2) & 1) << 18);
  *((_WORD *)this + 38) = v25;
  *((unsigned char *)this + 78) = BYTE2(v28);
  unsigned int v29 = v28 & 0xFFF7FFFF | (((*((unsigned __int8 *)v5 + 2) >> 3) & 1) << 19);
  *((_WORD *)this + 38) = v25;
  *((unsigned char *)this + 78) = BYTE2(v29);
  *((_DWORD *)this + 18) = *((_DWORD *)v5 - 1);
}

void sub_1D34A97F8(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetObjectIdentifier(TCFURLInfo *this)
{
  return 0;
}

uint64_t TCFURLInfo::PathAsCStr(TCFURLInfo *this)
{
  {
    TCFURLInfo::PathAsCStr(void)const::localLocuint64_t k = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&TCFURLInfo::PathAsCStr(void)const::localLock);
  uint64_t v2 = *((void *)this + 6);
  uint64_t v3 = *((void *)this + 7);
  if (v2 == v3)
  {
    uint64_t v3 = *((void *)this + 6);
    if (*(void *)this)
    {
      std::vector<char>::vector(&v12, 0x400uLL);
      int FileSystemRepresentation = TCFURLInfo::GetFileSystemRepresentation(*(TCFURLInfo **)this, (const __CFURL *)1, (UInt8 *)v12.__begin_, (unsigned __int8 *)(v12.__end_ - v12.__begin_));
      std::vector<int>::pointer begin = v12.__begin_;
      if (FileSystemRepresentation)
      {
        size_t v6 = strlen(v12.__begin_);
        if (v6 + 1 <= v12.__end_ - v12.__begin_)
        {
          std::vector<char>::pointer end = &v12.__begin_[v6 + 1];
          if (v6 + 1 >= v12.__end_ - v12.__begin_) {
            std::vector<char>::pointer end = v12.__end_;
          }
        }
        else
        {
          std::vector<char>::__append(&v12, v6 + 1 - (v12.__end_ - v12.__begin_));
          std::vector<int>::pointer begin = v12.__begin_;
          std::vector<char>::pointer end = v12.__end_;
        }
        unsigned int v8 = (char *)*((void *)this + 6);
        *((void *)this + 6) = begin;
        *((void *)this + 7) = end;
        unsigned int v9 = (char *)*((void *)this + 8);
        *((void *)this + 8) = v12.__end_cap_.__value_;
        v12.__begin_ = v8;
        v12.__end_cap_.__value_ = v9;
        std::vector<int>::pointer begin = v8;
      }
      if (begin)
      {
        v12.__end_ = begin;
        operator delete(begin);
      }
      uint64_t v2 = *((void *)this + 6);
      uint64_t v3 = *((void *)this + 7);
    }
  }
  if (v2 == v3) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v2;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&TCFURLInfo::PathAsCStr(void)const::localLock);
  return v10;
}

void sub_1D34A9A0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
}

TString *TCFURLInfo::Path@<X0>(TCFURLInfo *this@<X0>, TString *a2@<X8>)
{
  uint64_t v3 = (const char *)TCFURLInfo::PathAsCStr(this);
  if (v3)
  {
    return TString::TString(a2, v3);
  }
  else
  {
    return TString::TString(a2, "", 0);
  }
}

uint64_t TCFURLInfo::CopyExtendedAttribute(TCFURLInfo *this, CFStringRef theString, const __CFString *a3, CFDataRef *a4, const __CFData **a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  uint64_t v5 = 4294959224;
  if (!this || !theString) {
    return v5;
  }
  int v8 = (int)a3;
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (!CStringPtr)
  {
    CStringPtr = buffer;
    if (!CFStringGetCString(theString, buffer, 127, 0x8000100u)) {
      CStringPtr = 0;
    }
  }
  std::vector<char>::vector(&bytes, 0x1000uLL);
  if (!strcmp("com.apple.ResourceFork", CStringPtr))
  {
LABEL_9:
    unint64_t v12 = getxattr((const char *)this, CStringPtr, 0, 0, 0, v8);
    if ((v12 & 0x8000000000000000) == 0)
    {
      std::vector<char>::pointer begin = bytes.__begin_;
      std::vector<char>::pointer end = bytes.__end_;
      if (v12 <= bytes.__end_ - bytes.__begin_)
      {
        if (v12 < bytes.__end_ - bytes.__begin_)
        {
          std::vector<char>::pointer end = &bytes.__begin_[v12];
          bytes.__end_ = &bytes.__begin_[v12];
        }
      }
      else
      {
        std::vector<char>::__append(&bytes, v12 - (bytes.__end_ - bytes.__begin_));
        std::vector<char>::pointer begin = bytes.__begin_;
        std::vector<char>::pointer end = bytes.__end_;
      }
      ssize_t v11 = getxattr((const char *)this, CStringPtr, begin, end - begin, 0, v8);
      if ((v11 & 0x8000000000000000) == 0) {
        goto LABEL_15;
      }
    }
LABEL_19:
    unsigned int v16 = __error();
    uint64_t v5 = *v16;
    if (v5)
    {
      if (v5 == 93)
      {
        uint64_t v5 = 4294965869;
      }
      else if (v5 == 45)
      {
        uint64_t v5 = 4294965870;
      }
      else
      {
        uint64_t v5 = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v16, 0, v17);
      }
    }
    goto LABEL_16;
  }
  ssize_t v11 = getxattr((const char *)this, CStringPtr, bytes.__begin_, bytes.__end_ - bytes.__begin_, 0, v8);
  if (v11 < 0)
  {
    if (*__error() != 34) {
      goto LABEL_19;
    }
    goto LABEL_9;
  }
LABEL_15:
  uint64_t v5 = 0;
  *a4 = CFDataCreate(0, (const UInt8 *)bytes.__begin_, v11);
LABEL_16:
  if (bytes.__begin_)
  {
    bytes.__end_ = bytes.__begin_;
    operator delete(bytes.__begin_);
  }
  return v5;
}

void sub_1D34A9C8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFIndex TCFURLInfo::CheckPrefetchState(CFIndex result, int a2)
{
  int v2 = *(_DWORD *)(result + 72);
  if (v2 < a2 || v2 == 0) {
    return TCFURLInfo::FetchProperties((const void **)result, 1);
  }
  return result;
}

CFIndex TCFURLInfo::FetchProperties(const void **this, int a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  CFURLRef v2 = (const __CFURL *)*this;
  if (!*this) {
    return 4294959236;
  }
  CFErrorRef error = 0;
  if (a2)
  {
    CFArrayRef CopyItemRequestedPropertyKeys = (const __CFArray *)TCFURLInfo::GetCopyItemRequestedPropertyKeys((TCFURLInfo *)this);
    CFDictionaryRef v36 = CFURLCopyResourcePropertiesForKeys(v2, CopyItemRequestedPropertyKeys, &error);
    if (error)
    {
      CFRelease(error);
      CFErrorRef error = 0;
      long long v32 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      id v7 = (id)TCFURLInfo::GetCopyItemRequestedPropertyKeys(v6);
      uint64_t v8 = [v7 countByEnumeratingWithState:&v32 objects:v38 count:16];
      if (v8)
      {
        uint64_t v9 = *(void *)v33;
        do
        {
          for (uint64_t i = 0; i != v8; ++i)
          {
            if (*(void *)v33 != v9) {
              objc_enumerationMutation(v7);
            }
            CFStringRef v11 = *(const __CFString **)(*((void *)&v32 + 1) + 8 * i);
            CFErrorRef v30 = 0;
            CFNumberRef propertyValueTypeRefPtr = 0;
            CFURLCopyResourcePropertyForKey((CFURLRef)*this, v11, &propertyValueTypeRefPtr, &v30);
            TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v30);
            TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&propertyValueTypeRefPtr);
          }
          uint64_t v8 = [v7 countByEnumeratingWithState:&v32 objects:v38 count:16];
        }
        while (v8);
      }
    }
  }
  else
  {
    CFDictionaryRef v36 = 0;
  }
  CFNumberRef propertyValueTypeRefPtr = 0;
  if (_CFURLGetResourcePropertyFlags())
  {
    unsigned int v15 = propertyValueTypeRefPtr;
    unsigned int v16 = (propertyValueTypeRefPtr >> 1) & 0x7FFFFF;
    unsigned int v17 = *((_WORD *)this + 38) & 0xFFFC | (*((unsigned __int8 *)this + 78) << 16) & 0xFFFEFFFC | ((propertyValueTypeRefPtr & 1) << 16) | ((propertyValueTypeRefPtr & 0xFFFFFE) >> 1) & 2 | ((propertyValueTypeRefPtr & 0xFFFFFE) >> 1) & 1;
    *((unsigned char *)this + 78) = (*((_WORD *)this + 38) & 0xFFFC | (*((unsigned __int8 *)this + 78) << 16) & 0xFFFEFFFF | ((propertyValueTypeRefPtr & 1) << 16)) >> 16;
    *((_WORD *)this + 38) = v17;
    if (v16)
    {
      if (TCFURLInfo::GetBooleanProperty((TCFURLInfo *)*this, (const __CFString *)*MEMORY[0x1E4F1D6A0], v14))int v18 = 4; {
      else
      }
        int v18 = 0;
      unsigned int v17 = *((_WORD *)this + 38) & 0xFFFB | (*((unsigned __int8 *)this + 78) << 16) | v18;
      *((_WORD *)this + 38) = *((_WORD *)this + 38) & 0xFFFB | v18;
      unsigned int v15 = propertyValueTypeRefPtr;
    }
    unsigned int v19 = (v15 >> 2) & 0x10 | v17 & 0xFFFD7F4F | (((v15 >> 5) & 1) << 17);
    unsigned int v20 = HIWORD(v19);
    unsigned int v21 = (v19 & 0xFFFF7F7F | (((v15 >> 3) & 1) << 7) & 0xFFFF7FFF | (v15 >> 2) & 0x20 | (((v15 >> 10) & 1) << 15)) ^ 0x20;
    *((unsigned char *)this + 78) = v20;
    *((_WORD *)this + 38) = v21;
    *((_DWORD *)this + 18) = 1;
    if (a2)
    {
      *((unsigned char *)this + 78) = BYTE2(v21);
      *((_WORD *)this + 38) = (v15 >> 2) & 0x40 | v15 & 0x7000 | (v15 >> 6) & 8 | v21 & 0x8FB7;
      *((_DWORD *)this + 18) = 2;
    }
    CFErrorRef v30 = 0;
    if (CFURLCopyResourcePropertyForKey((CFURLRef)*this, (CFStringRef)*MEMORY[0x1E4F1D738], &v30, &error))
    {
      unsigned int v22 = (TString *)v30;
      CFTypeRef cf = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable((TString *)&cf, v22);
      if (this + 1 != &cf)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(this + 1, &cf);
        CFRetain(&stru_1F2ABD380);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = &stru_1F2ABD380;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v30);
  }
  unsigned __int8 v23 = atomic_load(sUseFileProviderFramework);
  if (v23)
  {
    Numericalint Property = TCFURLInfo::GetNumericalProperty((const __CFURL *)*this, (const __CFString *)*MEMORY[0x1E4F1CDC8], v14);
    int v26 = *((unsigned __int16 *)this + 38);
    unsigned int v25 = (char *)this + 76;
    unsigned int v27 = (v26 | (v25[2] << 16)) & 0xFFFBFFFF | (NumericalProperty >> 12) & 0x40000;
    *(_WORD *)unsigned int v25 = v26;
    v25[2] = BYTE2(v27);
  }
  CFIndex v12 = TCFURLInfo::TranslateCFError(error, v13);
  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&v36);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
  return v12;
}

void sub_1D34AA064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va1, a14);
  va_start(va, a14);
  unsigned int v16 = va_arg(va1, const void *);

  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetCopyItemRequestedPropertyKeys(TCFURLInfo *this)
{
  {
    if (v2)
    {
      TCFURLInfo::GetCopyItemRequestedPropertyKeys(void)::copyKeys = (uint64_t)TCFURLInfo::GetCopyItemRequestedPropertyKeys(void)::$_0::operator()(v2);
    }
  }
  return TCFURLInfo::GetCopyItemRequestedPropertyKeys(void)::copyKeys;
}

void sub_1D34AA154(_Unwind_Exception *a1)
{
}

unint64_t TCFURLInfo::IsDataless(const __CFURL **this, uint64_t a2, const __CFString *a3)
{
  return ((unint64_t)TCFURLInfo::GetNumericalProperty(*this, (const __CFString *)*MEMORY[0x1E4F1CDC8], a3) >> 30) & 1;
}

CFIndex TCFURLInfo::TranslateCFError(TCFURLInfo *this, __CFError *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    CFURLRef v2 = this;
    Domain = (TString *)CFErrorGetDomain(v2);
    v22.fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v22, Domain);
    FileProviderErrorDomain((TString *)buf);
    LODWORD(Domain) = CFEqual(v22.fString.fRef, *(CFTypeRef *)buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
    if (Domain)
    {
      CFIndex v5 = TCFURLInfo::TranslateFileProviderError(v2, v4);
    }
    else
    {
      CFDictionaryRef v7 = CFErrorCopyUserInfo(v2);
      *(void *)TPropertyValue buf = v7;
      if (v7)
      {
        Value = CFDictionaryGetValue(v7, (const void *)*MEMORY[0x1E4F1D190]);
        uint64_t v9 = (TCFURLInfo *)static_cf_cast<__CFString const*,void const*>(Value);
        if (v9)
        {
          CFIndex v6 = TCFURLInfo::OSStatusFromCFErrorShallow(v9, v10);
          TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)buf);
LABEL_10:
          if (operator==((void **)&v22.fString.fRef, (void *)*MEMORY[0x1E4F281F8])
            && [(TCFURLInfo *)v2 code] == 260)
          {
            CFIndex v12 = [(TCFURLInfo *)v2 userInfo];
            unsigned int v13 = [v12 objectForKeyedSubscript:*MEMORY[0x1E4F289D0]];

            if (v13)
            {
              CFStringRef v14 = [v13 lastPathComponent];
              TCFURLInfo::GetPropertyStoreName(v14);
              char v15 = operator==((void **)&TCFURLInfo::GetPropertyStoreName(void)::propertyStoreName, v14);
            }
            else
            {
              char v15 = 1;
            }
            {
              TCFURLInfo::TranslateCFError(__CFError *)::$_0::operator()();
            }
            if (v15)
            {
              unsigned int v16 = v13;
LABEL_26:

              TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
              return v6;
            }
            unsigned int v17 = v13;
            int v18 = (NSObject **)TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories;
            unsigned int v19 = (NSObject **)unk_1EA6ABF70;
            unsigned int v16 = v17;
            while (1)
            {
              if (v18 == v19)
              {

                goto LABEL_26;
              }
              if (IsEqual(v16, *v18)) {
                break;
              }
              ++v18;
            }
          }
          unsigned int v16 = LogObj(2);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            unsigned int v20 = [NSNumber numberWithInt:v6];
            *(_DWORD *)TPropertyValue buf = 138543618;
            *(void *)&uint8_t buf[4] = v20;
            __int16 v24 = 2112;
            unsigned int v25 = v2;
            _os_log_impl(&dword_1D343E000, v16, OS_LOG_TYPE_ERROR, "TCFURLInfo::TranslateCFError -- status: %{public}@, CFError = %@", buf, 0x16u);
          }
          goto LABEL_26;
        }
      }
      TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)buf);
      CFIndex v5 = TCFURLInfo::OSStatusFromCFErrorShallow(v2, v11);
    }
    CFIndex v6 = v5;
    goto LABEL_10;
  }
  return 0;
}

void sub_1D34AA454(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TCFURLInfo::ForceNameFetch(const void **this)
{
  CFURLRef v2 = (const __CFURL *)*this;
  if (v2)
  {
    CFStringRef PathComponent = CFURLCopyLastPathComponent(v2);
    CFStringRef v7 = PathComponent;
    if (PathComponent)
    {
      CFURLRef v4 = (TString *)PathComponent;
      CFTypeRef cf = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable((TString *)&cf, v4);
      if (this + 1 != &cf)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(this + 1, &cf);
        CFRetain(&stru_1F2ABD380);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = &stru_1F2ABD380;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
  }
  else
  {
    CFStringRef v7 = 0;
  }
  return TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v7);
}

void sub_1D34AA5C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

CFIndex TCFURLInfo::Initialize(TString *this, const __CFURL *a2, int a3, int a4)
{
  uint64_t v8 = this + 1;
  TString::SetStringRefAsImmutable(this + 1, 0);
  TString::SetFromUTF8(v8, (const UInt8 *)"", 0);
  TString::SetStringRefAsImmutable(this + 2, 0);
  TString::SetFromUTF8(this + 2, (const UInt8 *)"", 0);
  TString::SetStringRefAsImmutable(this + 3, 0);
  TString::SetFromUTF8(this + 3, (const UInt8 *)"", 0);
  int v9 = WORD2(this[9].fString.fRef) & 0xFEFF | (BYTE6(this[9].fString.fRef) << 16);
  WORD2(this[9].fString.fRef) &= ~0x100u;
  BYTE6(this[9].fString.fRef) = BYTE2(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, a2);
  if (!this->fString.fRef || !a3) {
    return 0;
  }
  return TCFURLInfo::FetchProperties((const void **)&this->fString.fRef, a4);
}

CFIndex TCFURLInfo::Initialize(TString *this, const char *__s)
{
  if (!__s) {
    return 4294959224;
  }
  CFIndex v4 = strlen(__s);
  CFURLRef v5 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)__s, v4, 0);
  CFURLRef v8 = v5;
  if (v5) {
    CFIndex v6 = TCFURLInfo::Initialize(this, v5, 1, 1);
  }
  else {
    CFIndex v6 = 4294959238;
  }
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v8);
  return v6;
}

void sub_1D34AA780(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetSizerPropertyKeys(TCFURLInfo *this)
{
  v23[21] = *MEMORY[0x1E4F143B8];
  {
    TString v22 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D738]);
    v23[0] = v22;
    unsigned int v21 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CDD8]);
    v23[1] = v21;
    unsigned int v20 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CDC0]);
    void v23[2] = v20;
    unsigned int v19 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CDE0]);
    v23[3] = v19;
    int v18 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE08]);
    v23[4] = v18;
    unsigned int v17 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D640]);
    v23[5] = v17;
    unsigned int v16 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D5B8]);
    v23[6] = v16;
    char v15 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D708]);
    v23[7] = v15;
    CFStringRef v14 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D690]);
    v23[8] = v14;
    unsigned int v13 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6E0]);
    v23[9] = v13;
    CFIndex v12 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6D0]);
    v23[10] = v12;
    CFStringRef v11 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE58]);
    v23[11] = v11;
    CFURLRef v2 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE30]);
    v23[12] = v2;
    uint64_t v3 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE28]);
    v23[13] = v3;
    CFIndex v4 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE50]);
    v23[14] = v4;
    CFURLRef v5 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6E8]);
    v23[15] = v5;
    CFIndex v6 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6C8]);
    v23[16] = v6;
    CFStringRef v7 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D678]);
    id v23[17] = v7;
    CFURLRef v8 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6B8]);
    v23[18] = v8;
    int v9 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D668]);
    v23[19] = v9;
    uint64_t v10 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CEB8]);
    v23[20] = v10;
    TCFURLInfo::GetSizerPropertyKeys(void)::sizerKeys = [MEMORY[0x1E4F1C978] arrayWithObjects:v23 count:21];
  }
  return TCFURLInfo::GetSizerPropertyKeys(void)::sizerKeys;
}

void sub_1D34AAB04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

__CFArray *TCFURLInfo::GetCopyItemRequestedPropertyKeys(void)::$_0::operator()(TCFURLInfo *a1)
{
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef BasicInfoPropertyKeys = (const __CFArray *)TCFURLInfo::GetBasicInfoPropertyKeys(a1);
  MutableCFStringRef Copy = CFArrayCreateMutableCopy(v1, 0, BasicInfoPropertyKeys);
  CFArrayAppendValue(MutableCopy, (const void *)*MEMORY[0x1E4F1D638]);
  return MutableCopy;
}

uint64_t TCFURLInfo::GetBasicInfoPropertyKeys(TCFURLInfo *this)
{
  v39[39] = *MEMORY[0x1E4F143B8];
  {
    TString v38 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D738]);
    v39[0] = v38;
    TString v37 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CF50]);
    v39[1] = v37;
    CFDictionaryRef v36 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CDD0]);
    v39[2] = v36;
    long long v35 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CDD8]);
    v39[3] = v35;
    long long v34 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CDC0]);
    v39[4] = v34;
    long long v33 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CDE0]);
    v39[5] = v33;
    long long v32 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE08]);
    v39[6] = v32;
    CFMutableStringRef v31 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D640]);
    v39[7] = v31;
    CFErrorRef v30 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D5B8]);
    v39[8] = v30;
    unsigned int v29 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D5A0]);
    v39[9] = v29;
    unsigned int v28 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D598]);
    v39[10] = v28;
    unsigned int v27 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D550]);
    v39[11] = v27;
    uint64_t v26 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D558]);
    v39[12] = v26;
    unsigned int v25 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D700]);
    v39[13] = v25;
    __int16 v24 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D708]);
    v39[14] = v24;
    unsigned __int8 v23 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D660]);
    v39[15] = v23;
    TString v22 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6E8]);
    unsigned __int8 v39[16] = v22;
    unsigned int v21 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D690]);
    v39[17] = v21;
    unsigned int v20 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6E0]);
    v39[18] = v20;
    unsigned int v19 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6D0]);
    v39[19] = v19;
    int v18 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE58]);
    v39[20] = v18;
    unsigned int v17 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE30]);
    v39[21] = v17;
    unsigned int v16 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE28]);
    v39[22] = v16;
    char v15 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CE50]);
    v39[23] = v15;
    CFStringRef v14 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6C8]);
    v39[24] = v14;
    CFURLRef v2 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D678]);
    v39[25] = v2;
    uint64_t v3 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6B8]);
    v39[26] = v3;
    CFIndex v4 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D668]);
    v39[27] = v4;
    CFURLRef v5 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D670]);
    v39[28] = v5;
    CFIndex v6 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6B0]);
    v39[29] = v6;
    CFStringRef v7 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D6F0]);
    v39[30] = v7;
    CFURLRef v8 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1D688]);
    v39[31] = v8;
    int v9 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CDC8]);
    v39[32] = v9;
    uint64_t v10 = NodeEventRefFromNodeEvent(MEMORY[0x1E4F1CF38]);
    uint64_t v11 = *MEMORY[0x1E4F1C590];
    v39[33] = v10;
    v39[34] = v11;
    uint64_t v12 = *MEMORY[0x1E4F1C560];
    v39[35] = *MEMORY[0x1E4F1C6E0];
    v39[36] = v12;
    uint64_t v13 = *MEMORY[0x1E4F1C6D8];
    v39[37] = *MEMORY[0x1E4F1C678];
    v39[38] = v13;
    TCFURLInfo::GetBasicInfoPropertyKeys(void)::basicKeys = [MEMORY[0x1E4F1C978] arrayWithObjects:v39 count:39];
  }
  return TCFURLInfo::GetBasicInfoPropertyKeys(void)::basicKeys;
}

void sub_1D34AB22C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33)
{
  _Unwind_Resume(a1);
}

void TCFURLInfo::Name(TCFURLInfo *this@<X0>, TString *a2@<X8>)
{
  if (!CFStringGetLength(*((CFStringRef *)this + 1)) && !*((_DWORD *)this + 18)) {
    TCFURLInfo::ForceNameFetch((const void **)this);
  }
  a2->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 1));
}

void sub_1D34AB4A4(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void TCFURLInfo::DisplayName(TString **this@<X0>, TString *a2@<X8>)
{
  int v4 = *((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16);
  if ((*((_WORD *)this + 38) & 0x100) != 0)
  {
    if (CFStringGetLength((CFStringRef)this[2]))
    {
      a2->fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(a2, this[2]);
      return;
    }
    int v4 = *((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16);
  }
  if ((v4 & 0x100) != 0) {
    goto LABEL_14;
  }
  LOBYTE(v5) = v4;
  *((unsigned char *)this + 78) = BYTE2(v4);
  *((_WORD *)this + 38) = v4 | 0x100;
  if (!*this) {
    goto LABEL_14;
  }
  if ((v4 & 0x40001) != 0)
  {
    TCFURLInfo::StringProperty((TCFURLInfo *)*this, (const __CFString *)*MEMORY[0x1E4F1D718], (TString *)&cf1);
    if (CFEqual(cf1, this[1]))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
LABEL_14:
      a2->fString.uint64_t fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(a2, this[1]);
      return;
    }
    CFIndex v6 = (TString *)(this + 2);
    if (v6 != (TString *)&cf1) {
      TString::SetStringRefAsImmutable(v6, (TString *)cf1);
    }
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, (TString *)v6->fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  }
  else
  {
    if (TCFURLInfo::gShowAllExtensions) {
      goto LABEL_14;
    }
    if (*((int *)this + 18) <= 1)
    {
      TCFURLInfo::FetchProperties((const void **)this, 1);
      __int16 v5 = *((_WORD *)this + 38);
    }
    if ((v5 & 0x40) == 0) {
      goto LABEL_14;
    }
    CFStringRef v7 = (CFStringRef *)(this + 1);
    FileSuffix((const TString *)this + 1, (TString *)&cf1);
    if (CFStringGetLength((CFStringRef)cf1))
    {
      CFIndex Length = CFStringGetLength(*v7);
      CFIndex v9 = CFStringGetLength((CFStringRef)cf1);
      TString::SubString((TString *)this + 1, 0, Length - v9, (TString *)&cf);
    }
    else
    {
      CFTypeRef cf = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable((TString *)&cf, (TString *)*v7);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    uint64_t v10 = (const void **)(this + 2);
    if (v10 != &cf)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(v10, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, (TString *)*v10);
  }
}

void sub_1D34AB6F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t TCFURLInfo::GetType(CFURLRef *this)
{
  CFDataRef propertyValueTypeRefPtr = 0;
  if (CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E4F1CDE0], &propertyValueTypeRefPtr, 0)
    && propertyValueTypeRefPtr
    && CFDataGetLength(propertyValueTypeRefPtr) == 32)
  {
    uint64_t v1 = *(unsigned int *)CFDataGetBytePtr(propertyValueTypeRefPtr);
  }
  else
  {
    uint64_t v1 = 0;
  }
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
  return v1;
}

void sub_1D34AB7BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetInode(const __CFURL **this)
{
  CFNumberRef number = 0;
  uint64_t valuePtr = 0;
  CFURLRef v1 = *this;
  if (v1 && CFURLCopyResourcePropertyForKey(v1, (CFStringRef)*MEMORY[0x1E4F1D5D8], &number, 0) && number)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
    uint64_t v2 = valuePtr;
  }
  else
  {
    uint64_t v2 = 0;
  }
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&number);
  return v2;
}

void sub_1D34AB850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void TCFURLInfo::VolumeUUID(const __CFURL **this@<X0>, TString *a2@<X8>)
{
  CFURLRef v3 = *this;
  CFDataRef propertyValueTypeRefPtr = 0;
  if (v3)
  {
    CFURLCopyResourcePropertyForKey(v3, (CFStringRef)*MEMORY[0x1E4F1D988], &propertyValueTypeRefPtr, 0);
    int v4 = propertyValueTypeRefPtr;
  }
  else
  {
    int v4 = 0;
  }
  a2->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, v4);
}

void sub_1D34AB8D8(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

double TCFURLInfo::GetCreationDate(CFURLRef *this)
{
  CFDataRef propertyValueTypeRefPtr = 0;
  CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E4F1D5A0], &propertyValueTypeRefPtr, 0);
  CFURLRef v3 = propertyValueTypeRefPtr;
  if (propertyValueTypeRefPtr) {
    double v1 = MEMORY[0x1D9435A50](propertyValueTypeRefPtr);
  }
  else {
    double v1 = 0.0;
  }
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(&v3);
  return v1;
}

void sub_1D34AB960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t TCFURLInfo::GetOwner(CFURLRef *this)
{
  uid_t owner = 0;
  CFFileSecurityRef fileSec = 0;
  if (CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E4F1D638], &fileSec, 0) && fileSec)
  {
    CFFileSecurityGetOwner(fileSec, &owner);
    uint64_t v1 = owner;
  }
  else
  {
    uint64_t v1 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
  return v1;
}

void sub_1D34AB9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t TCFURLInfo::GetUserGroups(CFURLRef *this)
{
  gid_t group = 0;
  CFFileSecurityRef fileSec = 0;
  if (CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E4F1D638], &fileSec, 0) && fileSec)
  {
    CFFileSecurityGetGroup(fileSec, &group);
    uint64_t v1 = group;
  }
  else
  {
    uint64_t v1 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
  return v1;
}

void sub_1D34ABA70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

TCFURLInfo *TCFURLInfo::TranslatePOSIXError(TCFURLInfo *this, const char *a2, const char *a3)
{
  int v4 = this;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if ((int)this > -2)
  {
    if (this == -1) {
      this = (TCFURLInfo *)*__error();
    }
    return TCFURLInfo::TranslateRawPOSIXError(this, a2, a3);
  }
  else
  {
    if (a2)
    {
      __int16 v5 = LogObj(5);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        TString::TString(&v8, a2);
        CFIndex v6 = SanitizedPath(&v8);
        *(_DWORD *)TPropertyValue buf = 67109378;
        int v10 = (int)v4;
        __int16 v11 = 2114;
        uint64_t v12 = v6;
        _os_log_impl(&dword_1D343E000, v5, OS_LOG_TYPE_ERROR, "MacOS error %d for %{public}@", buf, 0x12u);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
      }
    }
    return v4;
  }
}

void sub_1D34ABBEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

id TCFURLInfo::GetNumberProperty(TCFURLInfo *this, const __CFString *a2, const __CFString *a3)
{
  if (this)
  {
    CFDataRef propertyValueTypeRefPtr = 0;
    if (CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0))
    {
      CFURLRef v3 = propertyValueTypeRefPtr;
      if (propertyValueTypeRefPtr)
      {
        CFDataRef propertyValueTypeRefPtr = 0;
        TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
        goto LABEL_7;
      }
    }
    TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
  }
  CFURLRef v3 = 0;
LABEL_7:
  return v3;
}

void sub_1D34ABC88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

const __CFURL *TCFURLInfo::GetNumericalProperty(const __CFURL **this, const __CFString *a2, const __CFString *a3)
{
  return TCFURLInfo::GetNumericalProperty(*this, a2, a3);
}

id TCFURLInfo::ObjectProperty(TCFURLInfo *this, const __CFString *a2, const __CFString *a3)
{
  id propertyValueTypeRefPtr = 0;
  if (this)
  {
    if (a3) {
      CFURLCopyResourcePropertyForKey(this, a2, &propertyValueTypeRefPtr, 0);
    }
    else {
      _CFURLCopyResourcePropertyForKeyFromCache();
    }
  }
  id v3 = propertyValueTypeRefPtr;

  return v3;
}

void sub_1D34ABD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::IsClone(const void **this, unint64_t *a2, BOOL *a3)
{
  if (a3) {
    *a3 = 0;
  }
  if (a2) {
    *a2 = 0;
  }
  if (*((int *)this + 18) <= 0) {
    TCFURLInfo::FetchProperties(this, 1);
  }
  if (((*((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16)) & 0x10000) == 0) {
    return 0;
  }
  id propertyValueTypeRefPtr = 0;
  if (CFURLCopyResourcePropertyForKey((CFURLRef)*this, (CFStringRef)*MEMORY[0x1E4F1D730], &propertyValueTypeRefPtr, 0)&& ([propertyValueTypeRefPtr BOOLValue] & 1) != 0)
  {
    CFNumberRef number = 0;
    if (a3 || !CFURLCopyResourcePropertyForKey((CFURLRef)*this, (CFStringRef)*MEMORY[0x1E4F1D5C0], &number, 0))
    {
      CFStringRef v7 = (const char *)TCFURLInfo::PathAsCStr((TCFURLInfo *)this);
      if (v7)
      {
        uint64_t v12 = 0;
        unint64_t v13 = 0;
        int v8 = fsctl(v7, 0x40104A0EuLL, &v12, 0);
        char v9 = v12;
        BOOL v10 = v8 < 0 || v12 == 0;
        uint64_t v6 = !v10;
        if (!v10)
        {
          if (a2) {
            *a2 = v13;
          }
          if (a3 && (v9 & 2) != 0) {
            *a3 = 1;
          }
        }
      }
      else
      {
        uint64_t v6 = 0;
      }
    }
    else
    {
      if (a2) {
        CFNumberGetValue(number, kCFNumberLongLongType, a2);
      }
      uint64_t v6 = 1;
    }
    TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&number);
  }
  else
  {
    uint64_t v6 = 0;
  }
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
  return v6;
}

void sub_1D34ABE88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  int v4 = va_arg(va1, const void *);
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::FileSystemRepresentationRelativeToSource(TCFURLInfo **this, const TString *a2, TString *a3)
{
  TString::SetStringRefAsImmutable(a3, 0);
  TCFURLInfo::FileSystemRepresentation(*this, (const __CFURL *)1, (TString *)&theString);
  if (CFStringGetLength(theString))
  {
    CFTypeRef cf = a2;
    BOOL v10 = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&v10, (TString *)theString);
    v11.fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v11, (TString *)v10);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10);
    BOOL v6 = TString::BeginsWith(&v11, a2);
    if (v6)
    {
      CFIndex Length = CFStringGetLength(a2->fString.fRef);
      TString::SubStringFrom(&v11, Length, (TString *)&cf);
      if (&cf != (CFTypeRef *)a3)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a3->fString.fRef, &cf);
        CFRetain(&stru_1F2ABD380);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = &stru_1F2ABD380;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
  }
  else
  {
    BOOL v6 = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v6;
}

void sub_1D34ABFEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  int v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::CreateCFURLInfoWithFileSystemRepresentationRelativeToBase(TCFURLInfo *a1, const TString *a2, const __CFString **a3, uint64_t a4)
{
  TCFURLInfo::Path(a1, (TString *)&v19);
  CFStringRef v7 = *a3;
  v20.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v7);
  CFRelease(&stru_1F2ABD380);
  v20.fString.uint64_t fRef = MutableCopy;
  TString::Append(&v20, a2);
  AppendPath((const TString *)&v19, &v20, (TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19);
  char v9 = *(std::__shared_weak_count **)(a4 + 8);
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  if (cf && (CFTypeRef v10 = CFRetain(cf), (v11 = static_cf_cast<__CFString const*,void const*>(v10)) != 0))
  {
    CFTypeRef v12 = CFAutorelease(v11);
    CFStringRef v13 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v12);
  }
  else
  {
    CFStringRef v13 = 0;
  }
  v20.fString.uint64_t fRef = (__CFString *)CFURLCreateWithFileSystemPath(0, v13, kCFURLPOSIXPathStyle, 1u);
  if (v20.fString.fRef)
  {
    _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v19);
    long long v14 = v19;
    long long v19 = 0uLL;
    char v15 = *(std::__shared_weak_count **)(a4 + 8);
    *(_OWORD *)a4 = v14;
    if (v15)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
      if (*((void *)&v19 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v19 + 1));
      }
    }
    if (!TCFURLInfo::Initialize(*(TString **)a4, (const __CFURL *)v20.fString.fRef, 1, 1))
    {
      uint64_t v17 = 0;
      goto LABEL_16;
    }
    unsigned int v16 = *(std::__shared_weak_count **)(a4 + 8);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    if (v16) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v16);
    }
  }
  uint64_t v17 = 4294959236;
LABEL_16:
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v20.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  return v17;
}

void sub_1D34AC1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  __int16 v5 = va_arg(va1, const void *);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetVolumeInfoRecord(CFURLRef *a1, void *a2)
{
  if (*a1) {
    CFURLRef v3 = CFURLCreateFilePathURL(0, *a1, 0);
  }
  else {
    CFURLRef v3 = 0;
  }
  CFURLRef v6 = v3;
  uint64_t VolumeInfoRecord = TCFURLInfo::GetVolumeInfoRecord(v3, a2);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v6);
  return VolumeInfoRecord;
}

void sub_1D34AC258(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::CheckDestinationModificationDates(CFURLRef *a1, CFURLRef **a2, char a3)
{
  CFDateRef propertyValueTypeRefPtr = 0;
  CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1D598];
  CFURLCopyResourcePropertyForKey(*a1, (CFStringRef)*MEMORY[0x1E4F1D598], &propertyValueTypeRefPtr, 0);
  CFDateRef v6 = propertyValueTypeRefPtr;
  CFDateRef v14 = propertyValueTypeRefPtr;
  CFStringRef v7 = *a2;
  if (*a2)
  {
    CFDateRef propertyValueTypeRefPtr = 0;
    CFURLCopyResourcePropertyForKey(*v7, v5, &propertyValueTypeRefPtr, 0);
    CFDateRef v6 = v14;
    CFDateRef v8 = propertyValueTypeRefPtr;
  }
  else
  {
    CFDateRef v8 = 0;
  }
  CFDateRef v13 = v8;
  if (v6) {
    uint64_t v9 = (v8 != 0) + 1;
  }
  else {
    uint64_t v9 = v8 != 0;
  }
  if (!v9) {
    goto LABEL_21;
  }
  if (v9 == 1)
  {
    if (v6) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = -1;
    }
    if (a3) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v9 = CFDateCompare(v6, v8, 0);
    if (a3) {
      goto LABEL_21;
    }
  }
  if (v9 == 1)
  {
    double v10 = MEMORY[0x1D9435A50](v14);
    double v11 = MEMORY[0x1D9435A50](v13);
    uint64_t v9 = v10 - v11 >= 1.0 || floor(v10) != v11 && floor(v10 / 0.01) != v11 / 0.01;
  }
LABEL_21:
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)&v13);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)&v14);
  return v9;
}

void sub_1D34AC3B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  CFURLRef v3 = va_arg(va1, const void *);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::XattrValuesEqual(TCFURLInfo *this, TCFURLInfo *a2, TCFURLInfo *a3, CFStringRef theString, __CFString *a5)
{
  CFDateRef v13 = 0;
  CFDateRef v14 = 0;
  int v8 = TCFURLInfo::CopyExtendedAttribute(a2, theString, a5, (CFDataRef *)&v14, (const __CFData **)a5);
  int v10 = TCFURLInfo::CopyExtendedAttribute(a3, theString, a5, (CFDataRef *)&v13, v9);
  if (v8 == -1427 && v10 == -1427)
  {
    BOOL v11 = 1;
  }
  else if (v8 | v10)
  {
    BOOL v11 = 0;
  }
  else
  {
    BOOL v11 = CFEqual(v14, v13) != 0;
  }
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v13);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v14);
  return v11;
}

void sub_1D34AC498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void ListXattrs(const char *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  std::vector<char>::vector(&v26, 0x400uLL);
  ssize_t v6 = listxattr(a1, v26.__begin_, 0x400uLL, a2);
  if (v6 == -1)
  {
    if (*__error() != 34 || (v21 = listxattr(a1, 0, 0, a2), size_t v22 = v21, v21 < 1))
    {
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      goto LABEL_26;
    }
    std::vector<char>::pointer begin = v26.__begin_;
    if ((std::vector<char>::pointer)v21 <= (std::vector<char>::pointer)(v26.__end_ - v26.__begin_))
    {
      if ((std::vector<char>::pointer)v21 < (std::vector<char>::pointer)(v26.__end_ - v26.__begin_)) {
        v26.__end_ = &v26.__begin_[v21];
      }
    }
    else
    {
      std::vector<char>::__append(&v26, v21 - (v26.__end_ - v26.__begin_));
      std::vector<char>::pointer begin = v26.__begin_;
    }
    ssize_t v6 = listxattr(a1, begin, v22, a2);
  }
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  if (v6 >= 1)
  {
    CFStringRef v7 = v26.__begin_;
    do
    {
      std::string::basic_string[abi:ne180100]<0>(__p, v7);
      unint64_t v9 = *(void *)(a3 + 8);
      unint64_t v8 = *(void *)(a3 + 16);
      if (v9 >= v8)
      {
        unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - *(void *)a3) >> 3);
        unint64_t v12 = v11 + 1;
        if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
          std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - *(void *)a3) >> 3);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x555555555555555) {
          unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v14 = v12;
        }
        __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a3 + 16);
        if (v14) {
          char v15 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(a3 + 16, v14);
        }
        else {
          char v15 = 0;
        }
        unsigned int v16 = v15 + v11;
        __v.__first_ = v15;
        __v.__begin_ = v16;
        __v.__end_cap_.__value_ = &v15[v14];
        long long v17 = *(_OWORD *)__p;
        v16->__r_.__value_.__r.__words[2] = v25;
        *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v17;
        __p[1] = 0;
        std::string::size_type v25 = 0;
        __p[0] = 0;
        __v.__end_ = v16 + 1;
        std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a3, &__v);
        uint64_t v18 = *(void *)(a3 + 8);
        std::__split_buffer<std::string>::~__split_buffer(&__v);
        int v19 = SHIBYTE(v25);
        *(void *)(a3 + 8) = v18;
        if (v19 < 0) {
          operator delete(__p[0]);
        }
      }
      else
      {
        long long v10 = *(_OWORD *)__p;
        *(void *)(v9 + 16) = v25;
        *(_OWORD *)unint64_t v9 = v10;
        *(void *)(a3 + 8) = v9 + 24;
      }
      v7 += strlen(v7) + 1;
      TString v20 = v26.__begin_;
    }
    while (v7 < &v26.__begin_[v6]);
    if (v26.__begin_) {
      goto LABEL_19;
    }
    return;
  }
LABEL_26:
  TString v20 = v26.__begin_;
  if (v26.__begin_)
  {
LABEL_19:
    v26.__end_ = v20;
    operator delete(v20);
  }
}

void sub_1D34AC70C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, uint64_t a18, std::__split_buffer<std::string> *a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t xattr_intent(const char *a1, xattr_operation_intent_t a2)
{
  v8[1] = *(TString *)MEMORY[0x1E4F143B8];
  {
    {
      TString::TString(v8, "com.apple.favorite-rank.number#PS");
      std::vector<TString>::vector[abi:ne180100](&xattr_intent(char const*,unsigned int)::sharedXATTRs, (uint64_t)v8, 1uLL);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8[0].fString.fRef);
    }
  }
  if ((a2 & 0xFFFFFFFD) != 1) {
    return xattr_preserve_for_intent(a1, a2);
  }
  int v4 = (CFTypeRef *)xattr_intent(char const*,unsigned int)::sharedXATTRs;
  uint64_t v5 = qword_1EA6ABF30;
  if (xattr_intent(char const*,unsigned int)::sharedXATTRs == qword_1EA6ABF30)
  {
    uint64_t v6 = xattr_intent(char const*,unsigned int)::sharedXATTRs;
  }
  else
  {
    while (!operator==(v4, a1))
    {
      if (++v4 == (CFTypeRef *)v5)
      {
        int v4 = (CFTypeRef *)v5;
        break;
      }
    }
    uint64_t v6 = (uint64_t)v4;
    int v4 = (CFTypeRef *)qword_1EA6ABF30;
  }
  if (v4 == (CFTypeRef *)v6) {
    return xattr_preserve_for_intent(a1, a2);
  }
  else {
    return 0;
  }
}

void sub_1D34AC894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void *std::vector<TString>::vector[abi:ne180100](void *a1, uint64_t a2, unint64_t a3)
{
  a1[2] = 0;
  uint64_t v4 = (uint64_t)(a1 + 2);
  *a1 = 0;
  a1[1] = 0;
  if (a3)
  {
    std::vector<TNodePtr>::__vallocate[abi:ne180100](a1, a3);
    a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<TString>,TString const*,TString const*,TString*>(v4, a2, a2 + 8 * a3, a1[1]);
  }
  return a1;
}

void sub_1D34AC940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<TString>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

__CFSet *TCFURLInfo::CopyXattrNamesForCompare(TCFURLInfo *this, const char *a2)
{
  ListXattrs(a2, 1, (uint64_t)&v30);
  CFURLRef v3 = v30;
  uint64_t v2 = v31;
  if (v30 != v31)
  {
    Mutable = 0;
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    while (1)
    {
      if (*((char *)v3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v29, *(const std::string::value_type **)v3, *((void *)v3 + 1));
      }
      else
      {
        long long v6 = *v3;
        v29.__r_.__value_.__r.__words[2] = *((void *)v3 + 2);
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v6;
      }
      CFStringRef v7 = (v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &v29
         : (std::string *)v29.__r_.__value_.__r.__words[0];
      if (xattr_intent((const char *)v7, 1u) == 1) {
        break;
      }
LABEL_45:
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v29.__r_.__value_.__l.__data_);
      }
      CFURLRef v3 = (long long *)((char *)v3 + 24);
      if (v3 == v2) {
        goto LABEL_53;
      }
    }
    std::string::basic_string[abi:ne180100]<0>(v27, "com.apple.mtm.");
    std::string::basic_string[abi:ne180100]<0>(v25, "com.apple.acl.text.");
    std::string::size_type size = HIBYTE(v29.__r_.__value_.__r.__words[2]);
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v29.__r_.__value_.__l.__size_;
    }
    if (size != 20
      || ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (uint64_t v9 = &v29)
        : (uint64_t v9 = (std::string *)v29.__r_.__value_.__r.__words[0]),
          (std::string::size_type v10 = v9->__r_.__value_.__r.__words[0],
           std::string::size_type v11 = v9->__r_.__value_.__l.__size_,
           int v12 = v9->__r_.__value_.__r.__words[2],
           v10 == 0x6C7070612E6D6F63)
        ? (BOOL v13 = v11 == 0x6E61726175712E65)
        : (BOOL v13 = 0),
          v13 ? (BOOL v14 = v12 == 1701734772) : (BOOL v14 = 0),
          !v14))
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "com.apple.metadata:_kTimeMachine");
      if (BeginsWith((const void **)&v29.__r_.__value_.__l.__data_, __p)) {
        goto LABEL_33;
      }
      std::string::size_type v15 = HIBYTE(v29.__r_.__value_.__r.__words[2]);
      if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v15 = v29.__r_.__value_.__l.__size_;
      }
      if (v15 == 42
        && ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (unsigned int v16 = &v29)
          : (unsigned int v16 = (std::string *)v29.__r_.__value_.__r.__words[0]),
            !memcmp(v16, "com.apple.metadata:_kMDItemTimeMachinePath", 0x2AuLL))
        || BeginsWith((const void **)&v29.__r_.__value_.__l.__data_, v27)
        || BeginsWith((const void **)&v29.__r_.__value_.__l.__data_, v25))
      {
LABEL_33:
        int v17 = 0;
      }
      else
      {
        std::string::basic_string[abi:ne180100]<0>(v21, "com.apple.timemachine.private.");
        BOOL v19 = BeginsWith((const void **)&v29.__r_.__value_.__l.__data_, v21);
        if (v22 < 0) {
          operator delete(v21[0]);
        }
        int v17 = !v19;
      }
      if ((v24 & 0x80000000) == 0)
      {
        if (!v17) {
          goto LABEL_41;
        }
LABEL_38:
        CFStringRef v18 = CFStringCreateWithCString(v5, (const char *)v7, 0x8000100u);
        __p[0] = (void *)v18;
        if (!Mutable)
        {
          Mutable = CFSetCreateMutable(v5, 0, MEMORY[0x1E4F1D548]);
          CFStringRef v18 = (CFStringRef)__p[0];
        }
        CFSetAddValue(Mutable, v18);
        TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)__p);
        goto LABEL_41;
      }
      operator delete(__p[0]);
      if (v17) {
        goto LABEL_38;
      }
    }
LABEL_41:
    if (v26 < 0) {
      operator delete(v25[0]);
    }
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    goto LABEL_45;
  }
  Mutable = 0;
LABEL_53:
  v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v29);
  return Mutable;
}

void sub_1D34ACC2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  a33 = (void *)(v38 - 104);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a33);
  _Unwind_Resume(a1);
}

BOOL BeginsWith(const void **a1, void *a2)
{
  int v2 = *((char *)a2 + 23);
  if (v2 >= 0) {
    size_t v3 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v3 = a2[1];
  }
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    if (v3 != -1)
    {
      size_t v4 = *((unsigned __int8 *)a1 + 23);
      goto LABEL_9;
    }
LABEL_20:
    std::string::__throw_out_of_range[abi:ne180100]();
  }
  if (v3 == -1) {
    goto LABEL_20;
  }
  CFAllocatorRef v5 = a1;
  a1 = (const void **)*a1;
  size_t v4 = (size_t)v5[1];
LABEL_9:
  if (v4 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v4;
  }
  if (v2 < 0) {
    a2 = (void *)*a2;
  }
  return !memcmp(a1, a2, v6) && v6 == v3;
}

uint64_t TCFURLInfo::XattrsEqual(TCFURLInfo **a1, TCFURLInfo ***a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  TCFURLInfo::FileSystemRepresentation(*a1, (const __CFURL *)1, &v23);
  TCFURLInfo::FileSystemRepresentation(**a2, (const __CFURL *)1, &v22);
  size_t v3 = (TCFURLInfo *)TString::c_str(&v23);
  CFSetRef theSet = TCFURLInfo::CopyXattrNamesForCompare(v3, (const char *)v3);
  size_t v4 = (TCFURLInfo *)TString::c_str(&v22);
  CFSetRef v5 = TCFURLInfo::CopyXattrNamesForCompare(v4, (const char *)v4);
  CFSetRef v20 = v5;
  if (!theSet)
  {
    CFIndex Count = 0;
    if (!v5) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  CFIndex Count = CFSetGetCount(theSet);
  CFSetRef v5 = v20;
  if (v20) {
LABEL_5:
  }
    CFSetRef v5 = (const __CFSet *)CFSetGetCount(v5);
LABEL_6:
  if ((const __CFSet *)Count == v5)
  {
    if (Count < 1)
    {
      uint64_t v14 = 1;
    }
    else
    {
      long long v18 = 0u;
      long long v19 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      CFSetRef v7 = theSet;
      uint64_t v8 = [(__CFSet *)v7 countByEnumeratingWithState:&v16 objects:v24 count:16];
      if (v8)
      {
        uint64_t v9 = *(void *)v17;
        while (2)
        {
          for (uint64_t i = 0; i != v8; ++i)
          {
            if (*(void *)v17 != v9) {
              objc_enumerationMutation(v7);
            }
            std::string::size_type v11 = (__CFString *)*(id *)(*((void *)&v16 + 1) + 8 * i);
            if (!CFSetContainsValue(v20, v11))
            {

LABEL_22:
              uint64_t v14 = 0;
              goto LABEL_23;
            }
            int v12 = (TCFURLInfo *)TString::c_str(&v23);
            BOOL v13 = (TCFURLInfo *)TString::c_str(&v22);
            LODWORD(v12) = TCFURLInfo::XattrValuesEqual(v13, v12, v13, v11, (__CFString *)1);

            if (!v12) {
              goto LABEL_22;
            }
          }
          uint64_t v8 = [(__CFSet *)v7 countByEnumeratingWithState:&v16 objects:v24 count:16];
          uint64_t v14 = 1;
          if (v8) {
            continue;
          }
          break;
        }
      }
      else
      {
        uint64_t v14 = 1;
      }
LABEL_23:
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef((const void **)&v20);
  TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef((const void **)&theSet);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
  return v14;
}

void sub_1D34ACF6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va3, a10);
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  int v12 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v14 = va_arg(va2, const void *);
  va_copy(va3, va2);
  long long v16 = va_arg(va3, const void *);

  TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef((const void **)va);
  TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::LessThan(TCFURLInfo *a1, TCFURLInfo **a2)
{
  TCFURLInfo::Name(a1, &v6);
  TCFURLInfo::Name(*a2, &v5);
  BOOL v3 = TString::StringCompare(&v6, &v5) == kCFCompareLessThan;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return v3;
}

void sub_1D34AD040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

BOOL TCFURLInfo::ShouldSkip(const void **this, uint64_t a2, int a3)
{
  if (*((int *)this + 18) <= 0) {
    TCFURLInfo::FetchProperties(this, 1);
  }
  __int16 v6 = *((_WORD *)this + 38);
  if (v6) {
    return 0;
  }
  if (a3)
  {
    if (*((int *)this + 18) <= 1)
    {
      TCFURLInfo::FetchProperties(this, 1);
      __int16 v6 = *((_WORD *)this + 38);
    }
    if ((v6 & 0x1000) == 0) {
      return 1;
    }
  }
  if (TCFURLInfo::GetType((CFURLRef *)this) == 1651666795 && (*((_WORD *)this + 38) & 0x400) == 0) {
    return 1;
  }
  if (a2 < 1) {
    return 0;
  }
  CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1CDD8];
  Numericalint Property = TCFURLInfo::GetNumericalProperty((const __CFURL *)*this, (const __CFString *)*MEMORY[0x1E4F1CDD8], v7);
  if ((uint64_t)NumericalProperty
     + (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL *)*this, (const __CFString *)*MEMORY[0x1E4F1D640], v10) > a2)
    return 1;
  return (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL *)*this, v8, v11) > a2;
}

uint64_t TCFURLInfo::EffectiveUserCanRead(const void **this, BOOL *a2)
{
  if (!a2) {
    return 0;
  }
  *a2 = 1;
  if (TCFURLInfo::gDSHelperRunning) {
    uid_t v4 = TCFURLInfo::guidToUse;
  }
  else {
    uid_t v4 = getuid();
  }
  if (*((int *)this + 18) <= 1) {
    TCFURLInfo::FetchProperties(this, 1);
  }
  uint64_t v5 = (*((unsigned __int16 *)this + 38) >> 12) & 1;
  *a2 = TCFURLInfo::GetOwner((CFURLRef *)this) == v4;
  return v5;
}

CFIndex TCFURLInfo::GetParent(const void **this, uint64_t a2)
{
  if (*((int *)this + 18) <= 0) {
    TCFURLInfo::FetchProperties(this, 1);
  }
  if ((*((_WORD *)this + 38) & 0x80) != 0 || (CFURLRef v4 = (const __CFURL *)*this) == 0)
  {
    CFStringRef v8 = *(std::__shared_weak_count **)(a2 + 8);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    return 0;
  }
  else
  {
    CFURLRef propertyValueTypeRefPtr = 0;
    CFURLCopyResourcePropertyForKey(v4, (CFStringRef)*MEMORY[0x1E4F1D740], &propertyValueTypeRefPtr, 0);
    if (propertyValueTypeRefPtr)
    {
      _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v11);
      long long v5 = v11;
      long long v11 = 0uLL;
      __int16 v6 = *(std::__shared_weak_count **)(a2 + 8);
      *(_OWORD *)a2 = v5;
      if (v6)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v6);
        if (*((void *)&v11 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v11 + 1));
        }
      }
      CFIndex v7 = TCFURLInfo::Initialize(*(TString **)a2, propertyValueTypeRefPtr, 1, 1);
    }
    else
    {
      uint64_t v9 = *(std::__shared_weak_count **)(a2 + 8);
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      }
      CFIndex v7 = 4294959236;
    }
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&propertyValueTypeRefPtr);
  }
  return v7;
}

void sub_1D34AD314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::SetImmutableAndAppendFlags(id *a1, int a2)
{
  if (!*a1) {
    return 4294959238;
  }
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFMutableDictionaryRef theDict = Mutable;
  long long v5 = (const void *)*MEMORY[0x1E4F1CFD0];
  __int16 v6 = (const void *)*MEMORY[0x1E4F1CFC8];
  if (a2) {
    CFIndex v7 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    CFIndex v7 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F1D6E0], v7);
  if ((a2 & 0x100) != 0) {
    CFStringRef v8 = v5;
  }
  else {
    CFStringRef v8 = v6;
  }
  CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E4F1D6D0], v8);
  if ((*(void *)&a2 & 0x10000) != 0) {
    uint64_t v9 = v5;
  }
  else {
    uint64_t v9 = v6;
  }
  CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E4F1CE58], v9);
  if ((a2 & 0x1000000) != 0) {
    CFStringRef v10 = v5;
  }
  else {
    CFStringRef v10 = v6;
  }
  CFDictionaryAddValue(theDict, (const void *)*MEMORY[0x1E4F1CE30], v10);
  if (TCFURLInfo::SetResourceProperties(a1, theDict)) {
    uint64_t v11 = 4294967260;
  }
  else {
    uint64_t v11 = 0;
  }
  TAutoRef<__CFDictionary *,TRetainReleasePolicy<__CFDictionary *>>::~TAutoRef((const void **)&theDict);
  return v11;
}

void sub_1D34AD438(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFDictionary *,TRetainReleasePolicy<__CFDictionary *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::SetResourceProperties(id *this, const __CFDictionary *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  CFURLRef v3 = (const __CFURL *)*this;
  if (!v3) {
    return 4294959238;
  }
  CFErrorRef error = 0;
  if (CFURLSetResourcePropertiesForKeys(v3, a2, &error))
  {
    uint64_t v5 = 0;
  }
  else
  {
    __int16 v6 = LogObj(2);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      CFIndex v7 = (NSURL *)*this;
      CFStringRef v8 = SanitizedURL(v7);
      *(_DWORD *)TPropertyValue buf = 138543874;
      uint64_t v14 = v8;
      __int16 v15 = 2114;
      CFDictionaryRef v16 = a2;
      __int16 v17 = 2114;
      CFErrorRef v18 = error;
      _os_log_impl(&dword_1D343E000, v6, OS_LOG_TYPE_ERROR, "CFURLSetResourcePropertiesForKeys failed %{public}@, %{public}@, error: %{public}@", buf, 0x20u);
    }
    unsigned int v10 = TCFURLInfo::TranslateCFError(error, v9);
    if (v10 == -5000) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = v10;
    }
  }
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
  return v5;
}

void sub_1D34AD580(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::IsTrash(TCFURLInfo *this)
{
  {
    operator new();
  }
  {
    operator new();
  }
  TCFURLInfo::Name(this, (TString *)&cf1);
  if (CFEqual(cf1, *(CFTypeRef *)TCFURLInfo::IsTrash(void)const::trashName))
  {
    BOOL v2 = 1;
  }
  else
  {
    TCFURLInfo::Name(this, (TString *)&v4);
    BOOL v2 = CFEqual(v4, *(CFTypeRef *)TCFURLInfo::IsTrash(void)const::trashesName) != 0;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v4);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return v2;
}

void sub_1D34AD704(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::TranslateFileProviderError(TCFURLInfo *this, __CFError *a2)
{
  CFIndex Code = CFErrorGetCode(this);
  if ((unint64_t)(Code + 1004) > 4) {
    return 4294959279;
  }
  else {
    return *((unsigned int *)&unk_1D350AED4 + Code + 1004);
  }
}

CFIndex TCFURLInfo::OSStatusFromCFErrorShallow(TCFURLInfo *this, __CFError *a2)
{
  Domain = (TString *)CFErrorGetDomain(this);
  CFTypeRef cf1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf1, Domain);
  v15.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v15, (TString *)*MEMORY[0x1E4F1D160]);
  LODWORD(Domain) = CFEqual(cf1, v15.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
  if (Domain)
  {
    CFIndex Code = (TCFURLInfo *)CFErrorGetCode(this);
    __int16 v6 = TCFURLInfo::TranslatePOSIXError(Code, 0, v5);
  }
  else
  {
    v15.fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v15, (TString *)*MEMORY[0x1E4F1D158]);
    int v8 = CFEqual(cf1, v15.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
    if (v8)
    {
      CFIndex v7 = CFErrorGetCode(this);
      goto LABEL_6;
    }
    FileProviderErrorDomain(&v15);
    if (CFEqual(cf1, v15.fString.fRef))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
    }
    else
    {
      CFTypeRef cf2 = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable((TString *)&cf2, (TString *)*MEMORY[0x1E4F289A0]);
      int v11 = CFEqual(cf1, cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
      if (!v11)
      {
        v15.fString.uint64_t fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v15, (TString *)*MEMORY[0x1E4F1D148]);
        int v12 = CFEqual(cf1, v15.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        if (v12)
        {
          int v13 = CFErrorGetCode(this);
          if (v13 > 639)
          {
            if (v13 > 4352)
            {
              if (v13 == 4353 || v13 == 4355)
              {
                CFIndex v7 = 4294959289;
                goto LABEL_6;
              }
            }
            else
            {
              if (v13 == 640)
              {
                CFIndex v7 = 4294967262;
                goto LABEL_6;
              }
              if (v13 == 3072)
              {
                CFIndex v7 = 4294967168;
                goto LABEL_6;
              }
            }
          }
          else
          {
            CFIndex v7 = 4294967253;
            if (v13 > 259)
            {
              if (v13 == 260) {
                goto LABEL_6;
              }
              if (v13 == 516)
              {
                CFIndex v7 = 4294967248;
                goto LABEL_6;
              }
            }
            else
            {
              if (v13 == 4) {
                goto LABEL_6;
              }
              if (v13 == 257)
              {
                CFIndex v7 = 4294967242;
                goto LABEL_6;
              }
            }
          }
        }
        CFIndex v7 = 4294967260;
        goto LABEL_6;
      }
    }
    __int16 v6 = (TCFURLInfo *)TCFURLInfo::TranslateFileProviderError(this, v10);
  }
  CFIndex v7 = (CFIndex)v6;
LABEL_6:
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return v7;
}

void sub_1D34ADA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  CFTypeRef v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t *TCFURLInfo::GetPropertyStoreName(TCFURLInfo *this)
{
  {
    TString::TString((TString *)&TCFURLInfo::GetPropertyStoreName(void)::propertyStoreName, ".DS_Store", 9uLL);
  }
  return &TCFURLInfo::GetPropertyStoreName(void)::propertyStoreName;
}

void sub_1D34ADAE0(_Unwind_Exception *a1)
{
}

void TCFURLInfo::TranslateCFError(__CFError *)::$_0::operator()()
{
  TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories = 0;
  unk_1EA6ABF70 = 0;
  qword_1EA6ABF78 = 0;
  uint64_t v0 = (void *)MEMORY[0x1E4F1CB10];
  uint64_t v1 = NSHomeDirectory();
  BOOL v2 = [v1 stringByAppendingPathComponent:@"Applications"];
  id v5 = [v0 fileURLWithPath:v2 isDirectory:1];

  std::vector<NSURL * {__strong}>::push_back[abi:ne180100]((char **)&TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories, &v5);
  id v4 = [MEMORY[0x1E4F1CB10] fileURLWithPath:@"/Developer" isDirectory:1];
  std::vector<NSURL * {__strong}>::push_back[abi:ne180100]((char **)&TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories, &v4);
  id v3 = [v4 URLByAppendingPathComponent:@"Applications"];
  std::vector<NSURL * {__strong}>::push_back[abi:ne180100]((char **)&TCFURLInfo::TranslateCFError(__CFError *)::ignoredDirectories, &v3);
}

void sub_1D34ADC00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void **a12)
{
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

TCFURLInfo *TCFURLInfo::TranslateRawPOSIXError(TCFURLInfo *this, const char *a2, const char *a3)
{
  id v3 = this;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if ((int)this < -1) {
    return v3;
  }
  if ((int)this > 62)
  {
    if ((int)this <= 68)
    {
      if (this == 63)
      {
        uint64_t v5 = 4294965886;
        goto LABEL_30;
      }
      if (this == 66)
      {
LABEL_12:
        uint64_t v5 = 4294967249;
        goto LABEL_30;
      }
    }
    else
    {
      switch(this)
      {
        case 'E':
          uint64_t v5 = 4294965871;
          goto LABEL_30;
        case 'P':
          uint64_t v5 = 4294962273;
          goto LABEL_30;
        case 'Y':
          uint64_t v5 = 4294967168;
LABEL_30:
          __int16 v6 = LogObj(2);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          {
            CFIndex v7 = "'null'";
            v9[0] = 67109634;
            if (a2) {
              CFIndex v7 = a2;
            }
            v9[1] = v3;
            __int16 v10 = 1024;
            int v11 = v5;
            __int16 v12 = 2080;
            int v13 = v7;
            _os_log_impl(&dword_1D343E000, v6, OS_LOG_TYPE_DEBUG, "TCFURLInfo::TranslateRawPOSIXError %d -> %d, path: %s", (uint8_t *)v9, 0x18u);
          }

          return (TCFURLInfo *)v5;
      }
    }
LABEL_29:
    uint64_t v5 = (this + 100000);
    goto LABEL_30;
  }
  uint64_t v5 = 4294967260;
  switch((int)this)
  {
    case -1:
    case 5:
      goto LABEL_30;
    case 0:
      return v3;
    case 1:
    case 13:
      uint64_t v5 = 4294962296;
      goto LABEL_30;
    case 2:
      uint64_t v5 = 4294967253;
      goto LABEL_30;
    case 9:
      uint64_t v5 = 4294967245;
      goto LABEL_30;
    case 11:
      uint64_t v5 = 4294959283;
      goto LABEL_30;
    case 12:
    case 23:
      uint64_t v5 = 4294967255;
      goto LABEL_30;
    case 16:
      goto LABEL_12;
    case 17:
      uint64_t v5 = 4294967248;
      goto LABEL_30;
    case 18:
      uint64_t v5 = 100018;
      goto LABEL_30;
    case 20:
    case 21:
      uint64_t v5 = 4294965889;
      goto LABEL_30;
    case 22:
      uint64_t v5 = 4294967246;
      goto LABEL_30;
    case 24:
      uint64_t v5 = 4294967254;
      goto LABEL_30;
    case 27:
      uint64_t v5 = 4294965987;
      goto LABEL_30;
    case 28:
      uint64_t v5 = 4294967262;
      goto LABEL_30;
    case 30:
      uint64_t v5 = 4294967235;
      goto LABEL_30;
    case 45:
      uint64_t v5 = 4294965870;
      goto LABEL_30;
    default:
      goto LABEL_29;
  }
  return v3;
}

uint64_t TCFURLInfo::TranslateXAttrError(uint64_t this, int a2, const char *a3)
{
  if (this)
  {
    if (this == 93)
    {
      return 4294965869;
    }
    else if (this == 45)
    {
      return 4294965870;
    }
    else
    {
      return (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)this, 0, a3);
    }
  }
  return this;
}

uint64_t TCFURLInfo::DesktopServicesBundle(TCFURLInfo *this)
{
  {
    TCFURLInfo::DesktopServicesBundle(void)::dsBundle = (uint64_t)TCFURLInfo::DesktopServicesBundle(void)::$_0::operator()();
  }
  return TCFURLInfo::DesktopServicesBundle(void)::dsBundle;
}

void sub_1D34ADFAC(_Unwind_Exception *a1)
{
}

CFBundleRef TCFURLInfo::DesktopServicesBundle(void)::$_0::operator()()
{
  CFBundleRef BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.desktopservices");
  CFBundleRef v5 = BundleWithIdentifier;
  if (BundleWithIdentifier)
  {
    CFBundleRef v1 = BundleWithIdentifier;
    CFRetain(BundleWithIdentifier);
  }
  else
  {
    CFURLRef v2 = [MEMORY[0x1E4F1CB10] fileURLWithPath:@"/System/Library/PrivateFrameworks/DesktopServicesPriv.framework" isDirectory:1];
    CFBundleRef v4 = CFBundleCreate(0, v2);
    TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::operator=<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>((const void **)&v5, (const void **)&v4);
    TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TRef((const void **)&v4);

    CFBundleRef v1 = v5;
  }
  CFBundleRef v5 = 0;
  TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TRef((const void **)&v5);
  return v1;
}

void sub_1D34AE064(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **TCFURLInfo::LocalizedCopyErrorMessage@<X0>(TCFURLInfo *this@<X0>, const void **a2@<X1>, TString *a3@<X8>)
{
  if ((int)this <= -1310)
  {
    if ((int)this <= -5009)
    {
      if ((int)this <= -8088)
      {
        if (this == -8095)
        {
          int v8 = 0;
          int v7 = 0;
          CFStringRef v9 = @"ReservationError";
          goto LABEL_35;
        }
        if (this == -8089)
        {
          int v7 = 0;
          int v8 = 1;
          CFStringRef v9 = @"CaseSensitivity";
          goto LABEL_35;
        }
      }
      else
      {
        switch(this)
        {
          case 0xFFFFE069:
            goto LABEL_10;
          case 0xFFFFEC66:
            goto LABEL_20;
          case 0xFFFFEC6E:
LABEL_10:
            int v8 = 0;
            int v7 = 0;
            CFStringRef v9 = @"FileBusy";
            goto LABEL_35;
        }
      }
LABEL_31:
      int v8 = 0;
      int v7 = 1;
      CFStringRef v9 = @"UnknownError";
      goto LABEL_35;
    }
    if ((int)this <= -1430)
    {
      if (this != -5008)
      {
        if (this == -5000)
        {
          int v8 = 0;
          int v7 = 0;
          CFStringRef v9 = @"AccessDenied";
          goto LABEL_35;
        }
        goto LABEL_31;
      }
    }
    else if (this != -1429)
    {
      if (this == -1410)
      {
LABEL_28:
        int v7 = 0;
        int v8 = 1;
        CFStringRef v9 = @"BadName";
        goto LABEL_35;
      }
      if (this != -1401) {
        goto LABEL_31;
      }
      goto LABEL_20;
    }
LABEL_27:
    int v8 = 0;
    int v7 = 0;
    CFStringRef v9 = @"DiskFull";
    goto LABEL_35;
  }
  if ((int)this <= -49)
  {
    if (this == -1309)
    {
      int v8 = 0;
      int v7 = 0;
      CFStringRef v9 = @"FileTooBig";
      goto LABEL_35;
    }
    if (this != -120)
    {
      if (this == -61)
      {
        int v8 = 0;
        int v7 = 0;
        CFStringRef v9 = @"WritePermission";
        goto LABEL_35;
      }
      goto LABEL_31;
    }
LABEL_20:
    int v8 = 0;
    int v7 = 1;
    CFStringRef v9 = @"FileNotFound";
    goto LABEL_35;
  }
  switch((int)this)
  {
    case -48:
      int v7 = 0;
      int v8 = 1;
      CFStringRef v9 = @"DuplicateFileName";
      break;
    case -47:
      goto LABEL_10;
    case -46:
    case -45:
    case -44:
    case -42:
    case -41:
    case -40:
    case -39:
    case -38:
      goto LABEL_31;
    case -43:
    case -35:
      goto LABEL_20;
    case -37:
      goto LABEL_28;
    case -36:
      int v7 = 0;
      int v8 = 1;
      CFStringRef v9 = @"IOError";
      break;
    case -34:
      goto LABEL_27;
    default:
      if (this != 100006) {
        goto LABEL_31;
      }
      int v8 = 0;
      int v7 = 0;
      CFStringRef v9 = @"DeviceDisappeared";
      break;
  }
LABEL_35:
  __int16 v10 = (__CFBundle *)TCFURLInfo::DesktopServicesBundle(this);
  CFStringRef v11 = CFBundleCopyLocalizedString(v10, v9, v9, 0);
  CFErrorRef v18 = (TString *)v11;
  if (v8)
  {
    __int16 v12 = RetainCF<__CFString const*>(a2);
    if (v12)
    {
      CFTypeRef v13 = CFAutorelease(v12);
      __int16 v12 = static_cf_cast<__CFString const*,void const*>(v13);
    }
    CFStringRef v14 = CFStringCreateWithFormat(0, 0, v11, v12);
    goto LABEL_41;
  }
  if (v7)
  {
    CFStringRef v14 = CFStringCreateWithFormat(0, 0, v11, this);
LABEL_41:
    CFStringRef v17 = v14;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v18, (const void **)&v17);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17);
  }
  TString v15 = v18;
  a3->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a3, v15);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18);
}

void sub_1D34AE35C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TCFURLInfo::LocalizedCopyErrorMessage(TCFURLInfo *this@<X0>, const __CFURL *a2@<X1>, TString *a3@<X8>)
{
  _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v7);
  TCFURLInfo::Initialize((TString *)v7, a2, 1, 0);
  TCFURLInfo::LocalizedCopyErrorMessage((TString **)v7, this, a3);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_1D34AE438(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(exception_object);
}

const void **TCFURLInfo::LocalizedCopyErrorMessage@<X0>(TString **this@<X0>, TCFURLInfo *a2@<X1>, TString *a3@<X8>)
{
  TCFURLInfo::DisplayName(this, (TString *)&theString);
  if (CFStringGetLength(theString))
  {
    v7.fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v7, (TString *)theString);
  }
  else
  {
    TCFURLInfo::Name((TCFURLInfo *)this, &v7);
  }
  TCFURLInfo::LocalizedCopyErrorMessage(a2, (const void **)&v7.fString.fRef, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1D34AE4E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **TCFURLInfo::LocalizedStringWithFileName@<X0>(const __CFString *this@<X0>, __CFString *a2@<X1>, TString *a3@<X8>)
{
  __int16 v6 = TCFURLInfo::StringProperty((TCFURLInfo *)a2, (const __CFString *)*MEMORY[0x1E4F1D718], (TString *)&cf);
  TString v7 = (__CFBundle *)TCFURLInfo::DesktopServicesBundle((TCFURLInfo *)v6);
  CFStringRef v8 = CFBundleCopyLocalizedString(v7, this, this, 0);
  CFStringRef v15 = v8;
  CFTypeRef v9 = cf;
  if (cf)
  {
    CFTypeRef v10 = CFRetain(cf);
    CFTypeRef v9 = static_cf_cast<__CFString const*,void const*>(v10);
    if (v9)
    {
      CFTypeRef v11 = CFAutorelease(v9);
      CFTypeRef v9 = static_cf_cast<__CFString const*,void const*>(v11);
    }
  }
  __int16 v12 = (TString *)CFStringCreateWithFormat(0, 0, v8, v9);
  CFStringRef v14 = v12;
  a3->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a3, v12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
}

void sub_1D34AE5E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  CFBundleRef v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  __int16 v6 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::DeleteDeep(const void **this, int a2, char a3)
{
  CFBundleRef v5 = this;
  if (*((int *)this + 18) <= 0) {
    this = (const void **)TCFURLInfo::FetchProperties(this, 1);
  }
  if (*((_WORD *)v5 + 38))
  {
    if (*((int *)v5 + 18) <= 0)
    {
      this = (const void **)TCFURLInfo::FetchProperties(v5, 1);
      if (*((int *)v5 + 18) <= 0) {
        this = (const void **)TCFURLInfo::FetchProperties(v5, 1);
      }
    }
    TCFURLInfo::GetBasicInfoPropertyKeys((TCFURLInfo *)this);
    operator new();
  }
  return TCFURLInfo::Delete((TCFURLInfo *)v5, a2, a3);
}

void sub_1D34AE7C8(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x1060C40FBA2130BLL);
  _Unwind_Resume(a1);
}

uint64_t TCFURLIterator::Next(uint64_t a1, uint64_t a2)
{
  CFIndex v4 = a1 + 16;
  if (!*(void *)(a1 + 16))
  {
    uint64_t v25 = (const void *)MEMORY[0x1D9435F70](0, **(void **)a1, *(void *)(a1 + 24), *(void *)(a1 + 32));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)v4, v25);
    if (*(unsigned char *)(a1 + 74))
    {
      CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1CDC8];
      do
      {
        _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v24);
        CFIndex Raw = TCFURLIterator::NextRaw(a1, (TString **)&v24);
        int v8 = Raw;
        if (Raw == -1417) {
          goto LABEL_16;
        }
        if (Raw)
        {
          int v12 = 0;
          CFIndex v4 = Raw;
        }
        else
        {
          uint64_t v9 = v24;
          if (*(int *)(v24 + 72) <= 0) {
            TCFURLInfo::FetchProperties((const void **)v24, 1);
          }
          if (*(void *)v9) {
            BOOL v10 = TCFURLInfo::gRootlessEnabled == 0;
          }
          else {
            BOOL v10 = 1;
          }
          if ((v10
             || !TCFURLInfo::IsOnSystemVolume((TCFURLInfo **)v9, v7)
             || (TCFURLInfo::GetNumericalProperty(*(const __CFURL **)v9, v5, v11) & 0x80) == 0)
            && ((*(unsigned __int16 *)(v9 + 76) | (*(unsigned __int8 *)(v9 + 78) << 16)) & 0x10003) != 0)
          {
            std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100]((uint64_t *)(a1 + 40), &v24);
LABEL_16:
            int v12 = 1;
            goto LABEL_19;
          }
          CFIndex v4 = 0;
          int v12 = 0;
        }
LABEL_19:
        if (*((void *)&v24 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v24 + 1));
        }
        if (!v12)
        {
          TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef(&v25);
          return v4;
        }
      }
      while (v8 != -1417);
    }
    TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef(&v25);
  }
  if (!*(unsigned char *)(a1 + 74))
  {
    CFStringRef v18 = (const __CFString *)*MEMORY[0x1E4F1CDC8];
    while (1)
    {
      CFIndex v4 = TCFURLIterator::NextRaw(a1, (TString **)a2);
      if (!v4)
      {
        CFSetRef v20 = *(TString **)a2;
        if (*(int *)(*(void *)a2 + 72) <= 0) {
          TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
        }
        if (v20->fString.fRef) {
          BOOL v21 = TCFURLInfo::gRootlessEnabled == 0;
        }
        else {
          BOOL v21 = 1;
        }
        if ((v21
           || !TCFURLInfo::IsOnSystemVolume((TCFURLInfo **)v20, v19)
           || (TCFURLInfo::GetNumericalProperty((const __CFURL *)v20->fString.fRef, v18, v22) & 0x80) == 0)
          && ((WORD2(v20[9].fString.fRef) | (BYTE6(v20[9].fString.fRef) << 16)) & 0x10003) != 0)
        {
          return 0;
        }
        CFIndex v4 = 4294959234;
      }
      if (v4 != -8062) {
        return v4;
      }
    }
  }
  unint64_t v13 = *(void *)(a1 + 64);
  uint64_t v14 = *(void *)(a1 + 40);
  if (v13 >= (*(void *)(a1 + 48) - v14) >> 4) {
    return 4294965879;
  }
  long long v15 = *(_OWORD *)(v14 + 16 * v13);
  uint64_t v16 = *(void *)(v14 + 16 * v13 + 8);
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  CFStringRef v17 = *(std::__shared_weak_count **)(a2 + 8);
  *(_OWORD *)a2 = v15;
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  CFIndex v4 = 0;
  ++*(void *)(a1 + 64);
  return v4;
}

void sub_1D34AEAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::Delete(TCFURLInfo *this, int a2, char a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!*(void *)this) {
    return 4294959238;
  }
  uint64_t v6 = TCFURLInfo::PathAsCStr(this);
  if (!v6) {
    return 0;
  }
  int v8 = (const char *)v6;
  if (*((int *)this + 18) < 1)
  {
    TCFURLInfo::FetchProperties((const void **)this, 1);
    uint64_t v9 = (_WORD *)((char *)this + 76);
    LOBYTE(v11) = *((_WORD *)this + 38);
    if (*((int *)this + 18) <= 0) {
      TCFURLInfo::FetchProperties((const void **)this, 1);
    }
    int v10 = *((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16);
  }
  else
  {
    uint64_t v9 = (_WORD *)((char *)this + 76);
    int v10 = *((unsigned __int16 *)this + 38) | (*((unsigned __int8 *)this + 78) << 16);
    __int16 v11 = *((_WORD *)this + 38);
  }
  unsigned int v13 = v11 & 0x10;
  unsigned int v14 = v10 & 0x20000;
  Booleanint Property = TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)this, (const __CFString *)*MEMORY[0x1E4F1CE58], v7);
  CFIndex Properties = (TCFURLInfo *)TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)this, (const __CFString *)*MEMORY[0x1E4F1CE30], v16);
  int v18 = (int)Properties;
  if (!a2
    || (v13 | v14 ? (int v19 = 1) : (int v19 = BooleanProperty),
        (v19 | Properties) != 1
     || (CFIndex Properties = (TCFURLInfo *)TCFURLInfo::SetImmutableAndAppendFlags((id *)this, 0),
         uint64_t v12 = (uint64_t)Properties,
         !Properties)))
  {
    if (*((int *)this + 18) <= 0) {
      CFIndex Properties = (TCFURLInfo *)TCFURLInfo::FetchProperties((const void **)this, 1);
    }
    if (*v9)
    {
      uint64_t v12 = TCFURLInfo::RmDir(Properties, v8);
LABEL_29:
      if (v12 && a2)
      {
        int v29 = v13 | v14 ? 1 : BooleanProperty;
        if ((v29 | v18) == 1)
        {
          int v30 = 0x1000000;
          if (!v18) {
            int v30 = 0;
          }
          int v31 = 0x10000;
          if (!BooleanProperty) {
            int v31 = 0;
          }
          TCFURLInfo::SetImmutableAndAppendFlags((id *)this, v31 | v30 | (v14 >> 9) | (v13 >> 4));
        }
      }
      return v12;
    }
    if ((a3 & 1) != 0
      || (TCFURLInfo::Name(this, (TString *)&cf1),
          TCFURLInfo::GetPropertyStoreName(v20),
          int v21 = CFEqual(cf1, (CFTypeRef)TCFURLInfo::GetPropertyStoreName(void)::propertyStoreName),
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1),
          v21))
    {
      uint64_t v12 = unlink(v8);
      if (!v12) {
        return v12;
      }
      CFStringRef v22 = LogObj(2);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        TString::TString(&v33, v8);
        TString v23 = SanitizedPath(&v33);
        LODWORD(cf1) = 67109378;
        HIDWORD(cf1) = v12;
        __int16 v35 = 2114;
        CFDictionaryRef v36 = v23;
        _os_log_impl(&dword_1D343E000, v22, OS_LOG_TYPE_ERROR, "unlink returned %d for %{public}@ ", (uint8_t *)&cf1, 0x12u);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v33.fString.fRef);
      }
      goto LABEL_24;
    }
    if (__carbon_delete())
    {
LABEL_24:
      long long v24 = __error();
      uint64_t v12 = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v24, 0, v25);
      if (TCFURLInfo::IsSystemRestrictionEffective((TCFURLInfo **)this, v26, v27)
        || TCFURLInfo::gRootlessEnabled
        && TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)this, (const __CFString *)*MEMORY[0x1E4F1CE50], v28))
      {
        uint64_t v12 = 4294959217;
      }
      goto LABEL_29;
    }
    return 0;
  }
  return v12;
}

void sub_1D34AEDEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::RmDir(TCFURLInfo *this, const char *a2)
{
  uint64_t result = rmdir(a2);
  if (result)
  {
    CFIndex v4 = __error();
    unsigned int v6 = TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v4, 0, v5);
    if (unlinkat(-2, a2, 256)) {
      return v6;
    }
    else {
      return 0;
    }
  }
  return result;
}

BOOL TCFURLInfo::IsSystemRestrictionEffective(TCFURLInfo **this, const __CFURL *a2, const __CFString *a3)
{
  if (TCFURLInfo::gRootlessEnabled
    && (TCFURLInfo::GetBooleanProperty(*this, (const __CFString *)*MEMORY[0x1E4F1CE28], a3) & 1) != 0)
  {
    return 1;
  }
  BOOL result = TCFURLInfo::IsOnSystemVolume(this, a2);
  if (result) {
    return TCFURLInfo::gROSPState != 3;
  }
  return result;
}

uint64_t TCFURLInfo::IsRootItem(TCFURLInfo **this, uint64_t a2, const __CFString *a3)
{
  return TCFURLInfo::GetBooleanProperty(*this, (const __CFString *)*MEMORY[0x1E4F1CEB8], a3);
}

uint64_t TCFURLInfo::IsLocalVolume(TCFURLInfo **this, uint64_t a2, const __CFString *a3)
{
  return TCFURLInfo::GetBooleanProperty(*this, (const __CFString *)*MEMORY[0x1E4F1D870], a3);
}

uint64_t TCFURLInfo::RenameWithoutReplacing(const std::__fs::filesystem::path *this, const std::__fs::filesystem::path *a2, const char *a3)
{
  if (strcmp((const char *)this, (const char *)a2))
  {
    {
      operator new();
    }
    CFStringRef v5 = (TDSMutex *)TCFURLInfo::RenameWithoutReplacing(char const*,char const*)::sLocalMutex;
    TDSMutex::lock((TDSMutex *)TCFURLInfo::RenameWithoutReplacing(char const*,char const*)::sLocalMutex);
    if (!lstat((const char *)a2, &v25))
    {
      CFIndex v7 = strlen((const char *)this);
      CFStringRef v22 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)this, v7, 0);
      CFIndex v8 = strlen((const char *)a2);
      long long v24 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)a2, v8, 0);
      CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1CDD0];
      Numericalint Property = TCFURLInfo::GetNumericalProperty(v22, (const __CFString *)*MEMORY[0x1E4F1CDD0], v10);
      CFURLRef v13 = TCFURLInfo::GetNumericalProperty(v24, v9, v12);
      CFStringRef v14 = (const __CFString *)*MEMORY[0x1E4F1CF50];
      CFURLRef v16 = TCFURLInfo::GetNumericalProperty(v22, (const __CFString *)*MEMORY[0x1E4F1CF50], v15);
      CFURLRef v18 = TCFURLInfo::GetNumericalProperty(v24, v14, v17);
      if (NumericalProperty != v13 || v16 != v18)
      {
        *__error() = 17;
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v24);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v22);
        goto LABEL_16;
      }
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v24);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v22);
    }
    rename(this, a2, v6);
    uint64_t v20 = v19;
    if ((v19 & 0x80000000) == 0 || *__error() != 18) {
      goto LABEL_17;
    }
    if ((copyfile((const char *)this, (const char *)a2, 0, 0x6800Fu) & 0x80000000) == 0)
    {
      _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v22);
      if (!TCFURLInfo::Initialize((TString *)v22, (const char *)this)) {
        TCFURLInfo::DeleteDeep((const void **)v22, 1, 1);
      }
      if (v23) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v23);
      }
      goto LABEL_17;
    }
LABEL_16:
    uint64_t v20 = 0xFFFFFFFFLL;
LABEL_17:
    TDSMutex::unlock(v5);
    return v20;
  }
  return 0;
}

void sub_1D34AF134(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x1000C40FA0F61DDLL);
  _Unwind_Resume(a1);
}

TString *TCFURLInfo::SourcePathForResumableCopy@<X0>(TString *a1@<X8>)
{
  return TString::TString(a1, "");
}

BOOL TCFURLInfo::IsSuspendedCopyOfSource(TString *a1, const __CFURL ***a2, double *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  *a3 = 0.0;
  uint64_t value = 0;
  unsigned int v6 = (const char *)TString::c_str(a1);
  CFIndex v7 = (const char *)SourceInodeXattrName(0);
  ssize_t v8 = getxattr(v6, v7, &value, 8uLL, 0, 1);
  if (v8 == -1)
  {
    CFStringRef v9 = (const char *)TString::c_str(a1);
    CFStringRef v10 = (const char *)SourceInodeXattrName(1);
    if (getxattr(v9, v10, &value, 8uLL, 0, 1) == -1) {
      return 0;
    }
  }
  uint64_t Inode = TCFURLInfo::GetInode(*a2);
  if (Inode != value) {
    return 0;
  }
  double v23 = 0.0;
  CFStringRef v12 = (const char *)TString::c_str(a1);
  CFURLRef v13 = (const char *)CheckPointXattrName();
  if (getxattr(v12, v13, &v23, 8uLL, 0, 1) != -1)
  {
    double v14 = v23;
    if (v14 < CFAbsoluteTimeGetCurrent())
    {
      *a3 = v23;
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  CFStringRef theString = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  CFStringRef v15 = (const char *)TString::c_str(a1);
  CFURLRef v16 = (const char *)SourceVolumeUUIDXattrName(v8 == -1);
  ssize_t v17 = getxattr(v15, v16, __s, 0x100uLL, 0, 1);
  if (v17 != -1)
  {
    __s[v17] = 0;
    TString::SetStringRefAsImmutable((TString *)&theString, 0);
    CFIndex v18 = strlen((const char *)__s);
    TString::SetFromUTF8((TString *)&theString, __s, v18);
  }
  TCFURLInfo::VolumeUUID(*a2, &v21);
  if (CFStringGetLength(theString)) {
    BOOL v19 = CFEqual(v21.fString.fRef, theString) != 0;
  }
  else {
    BOOL v19 = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v19;
}

void sub_1D34AF3F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::IsSuspendedCopyOfSource(TCFURLInfo **a1, const __CFURL ***a2, double *a3)
{
  TCFURLInfo::FileSystemRepresentation(*a1, (const __CFURL *)1, (TString *)&theString);
  if (CFStringGetLength(theString)) {
    BOOL IsSuspendedCopyOfSource = TCFURLInfo::IsSuspendedCopyOfSource((TString *)&theString, a2, a3);
  }
  else {
    BOOL IsSuspendedCopyOfSource = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return IsSuspendedCopyOfSource;
}

void sub_1D34AF498(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TCFURLInfo::ModifiedAfterCheckPoint(CFURLRef *this, double a2, BOOL *a3)
{
  *a3 = 0;
  CFURLRef propertyValueTypeRefPtr = 0;
  CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E4F1D558], &propertyValueTypeRefPtr, 0);
  ssize_t v8 = propertyValueTypeRefPtr;
  double v5 = MEMORY[0x1D9435A50](propertyValueTypeRefPtr);
  if (v5 < a2 + 120.0) {
    *a3 = 1;
  }
  BOOL v6 = v5 > a2;
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef(&v8);
  return v6;
}

void sub_1D34AF540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t TFileDescriptor::Close(TFileDescriptor *this)
{
  int v2 = *((_DWORD *)this + 2);
  if (v2 < 1) {
    return 4294967242;
  }
  uint64_t result = close(v2);
  if (result) {
    uint64_t result = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)result, 0, v4);
  }
  if (result) {
    int v5 = -1;
  }
  else {
    int v5 = 0;
  }
  *((_DWORD *)this + 2) = v5;
  return result;
}

uint64_t TCFURLInfo::CompareForMerge(uint64_t a1, CFURLRef **a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v8 = TCFURLInfo::CheckDestinationModificationDates((CFURLRef *)a1, a2, a5);
  *a3 = v8;
  if (v8) {
    return 0;
  }
  CFStringRef v10 = (const __CFString *)*MEMORY[0x1E4F1CDD8];
  Numericalint Property = TCFURLInfo::GetNumericalProperty(*(const __CFURL **)a1, (const __CFString *)*MEMORY[0x1E4F1CDD8], v9);
  CFStringRef v12 = (const __CFString *)*MEMORY[0x1E4F1D640];
  CFURLRef v14 = (const __CFURL *)((char *)NumericalProperty
                        + (void)TCFURLInfo::GetNumericalProperty(*(const __CFURL **)a1, (const __CFString *)*MEMORY[0x1E4F1D640], v13));
  CFStringRef v15 = *a2;
  CFURLRef v17 = TCFURLInfo::GetNumericalProperty(**a2, v10, v16);
  if (v14 != (const __CFURL *)((char *)v17 + (void)TCFURLInfo::GetNumericalProperty(*v15, v12, v18))) {
    return 0;
  }
  CFURLRef v20 = TCFURLInfo::GetNumericalProperty(*(const __CFURL **)a1, v10, v19);
  if (v20 != TCFURLInfo::GetNumericalProperty(**a2, v10, v21)) {
    return 0;
  }
  if (*(int *)(a1 + 72) <= 0) {
    TCFURLInfo::FetchProperties((const void **)a1, 1);
  }
  int v23 = *(unsigned __int16 *)(a1 + 76) | (*(unsigned __int8 *)(a1 + 78) << 16);
  long long v24 = *a2;
  if (*((int *)*a2 + 18) <= 0) {
    TCFURLInfo::FetchProperties((const void **)*a2, 1);
  }
  if ((v23 ^ (*((unsigned __int16 *)v24 + 38) | (*((unsigned __int8 *)v24 + 78) << 16)))) {
    return 0;
  }
  CFStringRef v26 = (const __CFString *)*MEMORY[0x1E4F1D870];
  if (!TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)a1, (const __CFString *)*MEMORY[0x1E4F1D870], v22)
    || !TCFURLInfo::GetBooleanProperty(**a2, v26, v27))
  {
    return 1;
  }
  return TCFURLInfo::XattrsEqual((TCFURLInfo **)a1, a2);
}

TString *TString::TString(TString *a1, uint64_t a2)
{
  a1->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    int v5 = (const UInt8 *)a2;
  }
  else {
    int v5 = *(const UInt8 **)a2;
  }
  if (v4 >= 0) {
    CFIndex v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    CFIndex v6 = *(void *)(a2 + 8);
  }
  TString::SetFromUTF8(a1, v5, v6);
  return a1;
}

void sub_1D34AF79C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t TCFURLInfo::GetMagicBusyCreationDate(TCFURLInfo *this)
{
  if (TCFURLInfo::GetMagicBusyCreationDate(void)::once != -1) {
    dispatch_once(&TCFURLInfo::GetMagicBusyCreationDate(void)::once, &__block_literal_global_108);
  }
  return TCFURLInfo::GetMagicBusyCreationDate(void)::magicBusyCreationDate;
}

CFDateRef ___ZN10TCFURLInfo24GetMagicBusyCreationDateEv_block_invoke()
{
  CFDateRef result = CFDateCreate(0, -534528000.0);
  TCFURLInfo::GetMagicBusyCreationDate(void)::magicBusydouble CreationDate = (uint64_t)result;
  return result;
}

uint64_t TCFURLInfo::CopyVolumeURL(CFURLRef *this)
{
  uint64_t propertyValueTypeRefPtr = 0;
  CFURLCopyResourcePropertyForKey(*this, (CFStringRef)*MEMORY[0x1E4F1D980], &propertyValueTypeRefPtr, 0);
  return propertyValueTypeRefPtr;
}

void TCFURLInfo::PropertyToString(signed int a1@<W0>, TString *a2@<X8>)
{
  if (a1 <= 1819501923)
  {
    if (a1 > 1718641012)
    {
      if (a1 <= 1769169259)
      {
        if (a1 > 1752458087)
        {
          if (a1 > 1768323436)
          {
            if (a1 <= 1768387183)
            {
              if (a1 == 1768323437)
              {
                OSTypeAsString(0x6966796Du, &v4);
                Format<std::string>("prIFSymbol (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              if (a1 == 1768386423)
              {
                OSTypeAsString(0x69676F77u, &v4);
                Format<std::string>("prIgnoreOwnership (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            if (a1 != 1768387184)
            {
              if (a1 == 1768845426)
              {
                OSTypeAsString(0x696E7072u, &v4);
                Format<std::string>("prInlineProgress (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x69677270u, &v4);
            Format<std::string>("prItemGroupID (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
          }
          else
          {
            if (a1 <= 1768123491)
            {
              if (a1 == 1752458088)
              {
                OSTypeAsString(0x68746368u, &v4);
                Format<std::string>("prAttributeChanged (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              if (a1 == 1768120688)
              {
                OSTypeAsString(0x69636170u, &v4);
                Format<std::string>("prIsiCloudLibraryInSidebar (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            if (a1 == 1768123492)
            {
              OSTypeAsString(0x69636C64u, &v4);
              Format<std::string>("prIsiCloudInSidebar (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 != 1768124270) {
              goto LABEL_405;
            }
            OSTypeAsString(0x69636F6Eu, &v4);
            Format<std::string>("prIconRef (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
          }
          goto LABEL_404;
        }
        if (a1 <= 1718904683)
        {
          if (a1 <= 1718776687)
          {
            if (a1 == 1718641013)
            {
              OSTypeAsString(0x66706175u, &v4);
              Format<std::string>("prFPAuthenticated (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 == 1718645604)
            {
              OSTypeAsString(0x66707364u, &v4);
              Format<std::string>("prIsFileProviderInSidebar (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          if (a1 != 1718776688)
          {
            if (a1 == 1718903156)
            {
              OSTypeAsString(0x66746174u, &v4);
              Format<std::string>("prFinderTagAndAttrs (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x66727370u, &v4);
          Format<std::string>("prFreeSpace (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 <= 1751480435)
        {
          if (a1 == 1718904684)
          {
            OSTypeAsString(0x6674676Cu, &v4);
            Format<std::string>("prFinderTagAttrsLabel (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1735287668)
          {
            OSTypeAsString(0x676E6374u, &v4);
            Format<std::string>("prGenerationCount (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 == 1751480436)
        {
          OSTypeAsString(0x68657874u, &v4);
          Format<std::string>("prIsExtensionHidden (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1752392562)
        {
          OSTypeAsString(0x68736372u, &v4);
          Format<std::string>("prHasScriptingTerminology (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
      }
      else if (a1 <= 1769173874)
      {
        if (a1 > 1769171055)
        {
          if (a1 <= 1769171298)
          {
            if (a1 == 1769171056)
            {
              OSTypeAsString(0x69736870u, &v4);
              Format<std::string>("prICloudSharePerson (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 == 1769171059)
            {
              OSTypeAsString(0x69736873u, &v4);
              Format<std::string>("prICloudSharePersonString (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          if (a1 == 1769171299)
          {
            OSTypeAsString(0x69736963u, &v4);
            Format<std::string>("prISIcon (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1769173099)
          {
            OSTypeAsString(0x6973706Bu, &v4);
            Format<std::string>("prIsPackage (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
        else if (a1 > 1769170539)
        {
          if (a1 == 1769170540)
          {
            OSTypeAsString(0x6973666Cu, &v4);
            Format<std::string>("prIsFolder (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1769170547)
          {
            OSTypeAsString(0x69736673u, &v4);
            Format<std::string>("prIsFileShare (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
        else
        {
          if (a1 == 1769169260)
          {
            OSTypeAsString(0x6973616Cu, &v4);
            Format<std::string>("prIsAlias (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1769169264)
          {
            OSTypeAsString(0x69736170u, &v4);
            Format<std::string>("prIsApplication (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
      }
      else if (a1 <= 1818321515)
      {
        if (a1 > 1802071651)
        {
          if (a1 == 1802071652)
          {
            OSTypeAsString(0x6B696E64u, &v4);
            Format<std::string>("prKind (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1802072172)
          {
            OSTypeAsString(0x6B69706Cu, &v4);
            Format<std::string>("prKindWithoutPlatform (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
        else
        {
          if (a1 == 1769173875)
          {
            OSTypeAsString(0x69737373u, &v4);
            Format<std::string>("prIsScreenShare (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1769370466)
          {
            OSTypeAsString(0x69767362u, &v4);
            Format<std::string>("prHideInFinderSidebar (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
      }
      else
      {
        if (a1 <= 1819240274)
        {
          if (a1 != 1818321516)
          {
            if (a1 == 1818702163)
            {
              OSTypeAsString(0x6C673153u, &v4);
              Format<std::string>("prCachedLogicalSize (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x6C61626Cu, &v4);
          Format<std::string>("prLabel (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        switch(a1)
        {
          case 1819240275:
            OSTypeAsString(0x6C6F6753u, &v4);
            Format<std::string>("prObsoleteCachedLogicalSize (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          case 1819240307:
            OSTypeAsString(0x6C6F6773u, &v4);
            Format<std::string>("prLogicalSize (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          case 1819243362:
            OSTypeAsString(0x6C6F7362u, &v4);
            Format<std::string>("prLockedInSidebar (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
        }
      }
    }
    else if (a1 <= 1668313714)
    {
      if (a1 > 1634956408)
      {
        if (a1 > 1667851117)
        {
          if (a1 > 1668246895)
          {
            if (a1 != 1668246896)
            {
              if (a1 == 1668247156)
              {
                OSTypeAsString(0x636F6E74u, &v4);
                Format<std::string>("prICloudContainer (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x636F6D70u, &v4);
            Format<std::string>("prIsSystemCompressed (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
          }
          else
          {
            if (a1 != 1667851118)
            {
              if (a1 == 1668115828)
              {
                OSTypeAsString(0x636D6D74u, &v4);
                Format<std::string>("prFinderComment (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x6369636Eu, &v4);
            Format<std::string>("prHasCustomIcon (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
          }
          goto LABEL_404;
        }
        if (a1 > 1667330144)
        {
          if (a1 != 1667330145)
          {
            if (a1 == 1667785588)
            {
              OSTypeAsString(0x63686374u, &v4);
              Format<std::string>("prChildCount (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x63617061u, &v4);
          Format<std::string>("prCapacity (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1634956409)
        {
          OSTypeAsString(0x61737479u, &v4);
          Format<std::string>("prType (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1635085684)
        {
          OSTypeAsString(0x61756D74u, &v4);
          Format<std::string>("prIsAboutToUnmount (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
      }
      else if (a1 > 1634758243)
      {
        if (a1 > 1634952035)
        {
          if (a1 == 1634952036)
          {
            OSTypeAsString(0x61736364u, &v4);
            Format<std::string>("prCreationDate (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1634954347)
          {
            OSTypeAsString(0x61736C6Bu, &v4);
            Format<std::string>("prIsLocked (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
        else
        {
          if (a1 == 1634758244)
          {
            OSTypeAsString(0x61706E64u, &v4);
            Format<std::string>("prAppNapIsDisabled (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1634758765)
          {
            OSTypeAsString(0x6170706Du, &v4);
            Format<std::string>("prIsApplicationManaged (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
      }
      else
      {
        if (a1 <= 1634497638)
        {
          if (a1)
          {
            if (a1 == 1231843171)
            {
              OSTypeAsString(0x496C6F63u, &v4);
              Format<std::string>("prIconSpatialLocation (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0, &v4);
          Format<std::string>("prNullProperty (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1634497639)
        {
          OSTypeAsString(0x616C7467u, &v4);
          Format<std::string>("prAliasTargetChanged (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1634755444)
        {
          OSTypeAsString(0x61706374u, &v4);
          Format<std::string>("prAppCategories (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
      }
    }
    else
    {
      if (a1 > 1684366193)
      {
        if (a1 <= 1685287795)
        {
          if (a1 <= 1684893816)
          {
            if (a1 == 1684366194)
            {
              OSTypeAsString(0x64656372u, &v4);
              Format<std::string>("prItemDecorations (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 == 1684630627)
            {
              OSTypeAsString(0x64696C63u, &v4);
              Format<std::string>("prDesktopIconSpatialLocation (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          if (a1 == 1684893817)
          {
            OSTypeAsString(0x646D7079u, &v4);
            Format<std::string>("prApplicationDeviceManagementPolicy (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 != 1684955501) {
            goto LABEL_405;
          }
          OSTypeAsString(0x646E616Du, &v4);
          Format<std::string>("prDisplayName (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
        }
        else if (a1 <= 1685548131)
        {
          if (a1 == 1685287796)
          {
            OSTypeAsString(0x64737374u, &v4);
            Format<std::string>("prDSStoreStatus (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 != 1685480308) {
            goto LABEL_405;
          }
          OSTypeAsString(0x64766374u, &v4);
          Format<std::string>("prDeepVisibleItemCount (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
        }
        else
        {
          switch(a1)
          {
            case 1685548132:
              OSTypeAsString(0x64776C64u, &v4);
              Format<std::string>("prProviderDownloadedState (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_408;
              }
              break;
            case 1701277813:
              OSTypeAsString(0x65677075u, &v4);
              Format<std::string>("prPrefersExternalGPU (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            case 1717793396:
              OSTypeAsString(0x66637274u, &v4);
              Format<std::string>("prCreator (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_408;
              }
              break;
            default:
              goto LABEL_405;
          }
        }
        goto LABEL_404;
      }
      if (a1 > 1684107378)
      {
        if (a1 > 1684237411)
        {
          if (a1 == 1684237412)
          {
            OSTypeAsString(0x64636C64u, &v4);
            Format<std::string>("prIsDataSeparatedICloudInSidebar (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 != 1684237940) {
            goto LABEL_405;
          }
          OSTypeAsString(0x64636E74u, &v4);
          Format<std::string>("prDeepItemCount (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1684107379)
        {
          OSTypeAsString(0x64617073u, &v4);
          Format<std::string>("prDataForkPhysicalSize (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1684108403)
        {
          OSTypeAsString(0x64617473u, &v4);
          Format<std::string>("prDataForkLogicalSize (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
      }
      else
      {
        if (a1 > 1668506983)
        {
          if (a1 != 1668506984)
          {
            if (a1 == 1668507504)
            {
              OSTypeAsString(0x63736770u, &v4);
              Format<std::string>("prCanSetPrefersExternalGPU (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x63736568u, &v4);
          Format<std::string>("prCanSetExtensionHidden (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1668313715)
        {
          OSTypeAsString(0x63707273u, &v4);
          Format<std::string>("prCopyrightString (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1668505966)
        {
          OSTypeAsString(0x6373616Eu, &v4);
          Format<std::string>("prCanSetAppNapState (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
      }
    }
  }
  else if (a1 <= 1919251314)
  {
    if (a1 <= 1870098033)
    {
      if (a1 > 1836282479)
      {
        if (a1 > 1869375854)
        {
          if (a1 > 1869379186)
          {
            if (a1 != 1869379187)
            {
              if (a1 == 1869769063)
              {
                OSTypeAsString(0x6F726967u, &v4);
                Format<std::string>("prOriginatorInfo (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x6F6C7673u, &v4);
            Format<std::string>("prOldViewStyle (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1869375855)
          {
            OSTypeAsString(0x6F6C696Fu, &v4);
            Format<std::string>("prOldIconOrigin (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1869377379)
          {
            OSTypeAsString(0x6F6C6F63u, &v4);
            Format<std::string>("prOldLocation (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
        else
        {
          if (a1 > 1853318003)
          {
            if (a1 != 1853318004)
            {
              if (a1 == 1868720740)
              {
                OSTypeAsString(0x6F626A64u, &v4);
                Format<std::string>("prObjectIdentifier (%s)", (uint64_t)&v4, &__p);
                TString::TString(a2, (uint64_t)&__p);
                goto LABEL_406;
              }
              goto LABEL_405;
            }
            OSTypeAsString(0x6E776374u, &v4);
            Format<std::string>("prNetworkComment (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1836282480)
          {
            OSTypeAsString(0x6D737270u, &v4);
            Format<std::string>("prIsMountedSharepoint (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
          if (a1 == 1853121395)
          {
            OSTypeAsString(0x6E746373u, &v4);
            Format<std::string>("prNetworkConnectionState (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_408;
            }
            goto LABEL_404;
          }
        }
      }
      else
      {
        if (a1 > 1835295091)
        {
          if (a1 <= 1836016707)
          {
            if (a1 == 1835295092)
            {
              OSTypeAsString(0x6D646174u, &v4);
              Format<std::string>("prMDAttributes (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            if (a1 == 1836008516)
            {
              OSTypeAsString(0x6D6F4444u, &v4);
              Format<std::string>("prCachedLogicalTimeStamp (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          if (a1 == 1836016708)
          {
            OSTypeAsString(0x6D6F6444u, &v4);
            Format<std::string>("prCachedPhysicalTimeStamp (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 != 1836016740) {
            goto LABEL_405;
          }
          OSTypeAsString(0x6D6F6464u, &v4);
          Format<std::string>("prModificationDate (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 <= 1819632755)
        {
          if (a1 == 1819501924)
          {
            OSTypeAsString(0x6C736564u, &v4);
            Format<std::string>("prICloudLastShareEditor (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1819503973)
          {
            OSTypeAsString(0x6C736D65u, &v4);
            Format<std::string>("prICloudLastChangedByMe (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 == 1819632756)
        {
          OSTypeAsString(0x6C756474u, &v4);
          Format<std::string>("prLastUsedDate (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1835291497)
        {
          OSTypeAsString(0x6D645369u, &v4);
          Format<std::string>("prMDSortIdentifier (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
      }
    }
    else if (a1 <= 1885895026)
    {
      if (a1 > 1885626994)
      {
        if (a1 > 1885876562)
        {
          if (a1 == 1885876563)
          {
            OSTypeAsString(0x70683153u, &v4);
            Format<std::string>("prCachedPhysicalSize (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1885894995)
          {
            OSTypeAsString(0x70687953u, &v4);
            Format<std::string>("prObsoleteCachedPhysicalSize (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
        }
        else
        {
          if (a1 == 1885626995)
          {
            OSTypeAsString(0x70646273u, &v4);
            Format<std::string>("prIsDeviceBusy (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1885627244)
          {
            OSTypeAsString(0x7064636Cu, &v4);
            Format<std::string>("prIsDeviceOperationCancellable (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
        }
        goto LABEL_405;
      }
      if (a1 > 1883665004)
      {
        if (a1 == 1883665005)
        {
          OSTypeAsString(0x7046726Du, &v4);
          Format<std::string>("prIsFullyFormed (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        if (a1 != 1885434984) {
          goto LABEL_405;
        }
        OSTypeAsString(0x70617468u, &v4);
        Format<std::string>("prPath (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
      if (a1 == 1870098034)
      {
        OSTypeAsString(0x6F776E72u, &v4);
        Format<std::string>("prOwner (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
      if (a1 == 1883333732)
      {
        OSTypeAsString(0x70416464u, &v4);
        Format<std::string>("prDateAdded (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
    }
    else if (a1 <= 1886613603)
    {
      if (a1 > 1886540642)
      {
        if (a1 == 1886540643)
        {
          OSTypeAsString(0x70725363u, &v4);
          Format<std::string>("prSecurityRef (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1886549619)
        {
          OSTypeAsString(0x70727673u, &v4);
          Format<std::string>("prPermissions (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
      }
      else
      {
        if (a1 == 1885895027)
        {
          OSTypeAsString(0x70687973u, &v4);
          Format<std::string>("prPhysicalSize (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
        if (a1 == 1886282093)
        {
          OSTypeAsString(0x706E616Du, &v4);
          Format<std::string>("prName (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        }
      }
    }
    else
    {
      if (a1 <= 1886675533)
      {
        if (a1 != 1886613604)
        {
          if (a1 == 1886675532)
          {
            OSTypeAsString(0x7074624Cu, &v4);
            Format<std::string>("prTrashItemOriginalLocation (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x70737064u, &v4);
        Format<std::string>("prIsStationery (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
      switch(a1)
      {
        case 1886675534:
          OSTypeAsString(0x7074624Eu, &v4);
          Format<std::string>("prTrashItemOriginalName (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        case 1919250547:
          OSTypeAsString(0x72657073u, &v4);
          Format<std::string>("prResourceForkPhysicalSize (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
        case 1919251312:
          OSTypeAsString(0x72657370u, &v4);
          Format<std::string>("prReclaimableSpace (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
          goto LABEL_404;
      }
    }
  }
  else if (a1 > 1952740194)
  {
    if (a1 <= 1970497393)
    {
      if (a1 <= 1969386593)
      {
        if (a1 <= 1969385825)
        {
          if (a1 == 1952740195)
          {
            OSTypeAsString(0x74647363u, &v4);
            Format<std::string>("prTagIsDiscovered (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1953718898)
          {
            OSTypeAsString(0x74736272u, &v4);
            Format<std::string>("prTagShowsInSidebar (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 == 1969385826)
        {
          OSTypeAsString(0x75627162u, &v4);
          Format<std::string>("prUbiquityTotalBytes (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        if (a1 != 1969385844) {
          goto LABEL_405;
        }
        OSTypeAsString(0x75627174u, &v4);
        Format<std::string>("prUbiquityStatus (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
      if (a1 <= 1970170986)
      {
        if (a1 != 1969386594)
        {
          if (a1 == 1969646708)
          {
            OSTypeAsString(0x75666C74u, &v4);
            Format<std::string>("prIsUbiquityFault (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x75627462u, &v4);
        Format<std::string>("prUbiquityTransferredBytes (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
      if (a1 == 1970170987)
      {
        OSTypeAsString(0x756E6C6Bu, &v4);
        Format<std::string>("prIsNoUnlink (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        goto LABEL_406;
      }
      if (a1 == 1970495843)
      {
        OSTypeAsString(0x75736163u, &v4);
        Format<std::string>("prUserAccess (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
    }
    else
    {
      if (a1 > 1986424179)
      {
        if (a1 <= 1987273323)
        {
          if (a1 != 1986424180)
          {
            if (a1 == 1987013741)
            {
              OSTypeAsString(0x766F6C6Du, &v4);
              Format<std::string>("prIsVolume (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            }
            goto LABEL_405;
          }
          OSTypeAsString(0x76666D74u, &v4);
          Format<std::string>("prVolumeFormat (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_408;
          }
        }
        else
        {
          switch(a1)
          {
            case 1987273324:
              OSTypeAsString(0x7673626Cu, &v4);
              Format<std::string>("prIsVisible (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_408;
              }
              break;
            case 1987277938:
              OSTypeAsString(0x76737472u, &v4);
              Format<std::string>("prVolumeFormatString (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_408;
              }
              break;
            case 1987406180:
              OSTypeAsString(0x76756964u, &v4);
              Format<std::string>("prVolumeUUID (%s)", (uint64_t)&v4, &__p);
              TString::TString(a2, (uint64_t)&__p);
              goto LABEL_406;
            default:
              goto LABEL_405;
          }
        }
        goto LABEL_404;
      }
      if (a1 > 1970566255)
      {
        if (a1 == 1970566256)
        {
          OSTypeAsString(0x75747470u, &v4);
          Format<std::string>("prUTType (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        if (a1 != 1986359923) {
          goto LABEL_405;
        }
        OSTypeAsString(0x76657273u, &v4);
        Format<std::string>("prLongVersion (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
      if (a1 == 1970497394)
      {
        OSTypeAsString(0x75736772u, &v4);
        Format<std::string>("prUserGroups (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
      if (a1 == 1970563428)
      {
        OSTypeAsString(0x75746964u, &v4);
        Format<std::string>("prTypeIdentifier (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
        goto LABEL_404;
      }
    }
  }
  else
  {
    if (a1 <= 1936225905)
    {
      if (a1 > 1935829346)
      {
        if (a1 <= 1936221803)
        {
          if (a1 == 1935829347)
          {
            OSTypeAsString(0x73626963u, &v4);
            Format<std::string>("prSidebarIconRef (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1935829368)
          {
            OSTypeAsString(0x73626978u, &v4);
            Format<std::string>("prSidebarIndex (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 != 1936221804)
        {
          if (a1 == 1936225392)
          {
            OSTypeAsString(0x73687470u, &v4);
            Format<std::string>("prIsTopLevelSharedItem (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x7368666Cu, &v4);
        Format<std::string>("prIsPublishedFolder (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
      }
      else
      {
        if (a1 > 1920167266)
        {
          if (a1 == 1920167267)
          {
            OSTypeAsString(0x72736D63u, &v4);
            Format<std::string>("prIsResumableCopyTarget (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          if (a1 == 1920167792)
          {
            OSTypeAsString(0x72736F70u, &v4);
            Format<std::string>("prResolveOptions (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        if (a1 != 1919251315)
        {
          if (a1 == 1920103284)
          {
            OSTypeAsString(0x72727374u, &v4);
            Format<std::string>("prRegionRestrictions (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x72657373u, &v4);
        Format<std::string>("prResourceForkLogicalSize (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
      }
      goto LABEL_404;
    }
    if (a1 <= 1937143149)
    {
      if (a1 > 1936484459)
      {
        if (a1 == 1936484460)
        {
          OSTypeAsString(0x736C686Cu, &v4);
          Format<std::string>("prSLHighlight (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        if (a1 != 1937008498) {
          goto LABEL_405;
        }
        OSTypeAsString(0x73746772u, &v4);
        Format<std::string>("prSortingGroup (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
      }
      else
      {
        if (a1 != 1936225906)
        {
          if (a1 == 1936484457)
          {
            OSTypeAsString(0x736C6869u, &v4);
            Format<std::string>("prSLHighlightID (%s)", (uint64_t)&v4, &__p);
            TString::TString(a2, (uint64_t)&__p);
            goto LABEL_406;
          }
          goto LABEL_405;
        }
        OSTypeAsString(0x73687672u, &v4);
        Format<std::string>("prShortVersion (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_408;
        }
      }
      goto LABEL_404;
    }
    if (a1 > 1937339249)
    {
      if (a1 == 1937339250)
      {
        OSTypeAsString(0x73797372u, &v4);
        Format<std::string>("prIsSystemRestricted (%s)", (uint64_t)&v4, &__p);
        TString::TString(a2, (uint64_t)&__p);
        goto LABEL_406;
      }
      if (a1 != 1937340018)
      {
        if (a1 == 1952673396)
        {
          OSTypeAsString(0x74636E74u, &v4);
          Format<std::string>("prTagInstancesCount (%s)", (uint64_t)&v4, &__p);
          TString::TString(a2, (uint64_t)&__p);
          goto LABEL_406;
        }
        goto LABEL_405;
      }
      OSTypeAsString(0x73797672u, &v4);
      Format<std::string>("prSystemVersion (%s)", (uint64_t)&v4, &__p);
      TString::TString(a2, (uint64_t)&__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_408;
      }
LABEL_404:
      operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_408;
    }
    if (a1 == 1937143150)
    {
      OSTypeAsString(0x7376756Eu, &v4);
      Format<std::string>("prServerUserName (%s)", (uint64_t)&v4, &__p);
      TString::TString(a2, (uint64_t)&__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_408;
      }
      goto LABEL_404;
    }
    if (a1 == 1937334902)
    {
      OSTypeAsString(0x73796276u, &v4);
      Format<std::string>("prSystemBuildVersion (%s)", (uint64_t)&v4, &__p);
      TString::TString(a2, (uint64_t)&__p);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_408;
      }
      goto LABEL_404;
    }
  }
LABEL_405:
  signed int v3 = a1;
  OSTypeAsString(a1, &v4);
  Format<unsigned int,std::string>("0x%x (%s)", (unsigned int *)&v3, (uint64_t)&v4, &__p);
  TString::TString(a2, (uint64_t)&__p);
LABEL_406:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_408:
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
}

void sub_1D34B2318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

void Format<std::string>(const char *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  *(void *)&long long v5 = a1;
  *((void *)&v5 + 1) = strlen(a1);
  FormatDetails<std::string>(&v5, a2, a3);
}

void Format<unsigned int,std::string>(const char *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  *(void *)&long long v7 = a1;
  *((void *)&v7 + 1) = strlen(a1);
  FormatDetails<unsigned int,std::string>(&v7, a2, a3, a4);
}

BOOL TCFURLInfo::IsLockFile(CFURLRef *this)
{
  if (TCFURLInfo::GetCreationDate(this) == -534528000.0) {
    return 1;
  }
  if (*((int *)this + 18) <= 0) {
    TCFURLInfo::FetchProperties((const void **)this, 1);
  }
  return (*((_WORD *)this + 38) & 1) == 0 && TCFURLInfo::GetType(this) == 1651666795;
}

void TCFURLInfo::DecodeEncodedTagString(TCFURLInfo *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  std::string v4 = objc_cast<NSString,void const*>(this);
  if ([v4 length] && !objc_msgSend(v4, "hasPrefix:", @"\n"))
  {
    long long v5 = [v4 componentsSeparatedByString:@"\n"];
    unint64_t v6 = [v5 count];
    long long v7 = [v5 firstObject];
    uint64_t v8 = static_objc_cast<NSString,objc_object * {__strong}>(v7);

    if (v6 < 2)
    {
      uint64_t v28 = 0;
    }
    else
    {
      CFStringRef v9 = [v5 objectAtIndexedSubscript:1];
      CFStringRef v10 = static_objc_cast<NSString,objc_object * {__strong}>(v9);

      [v10 componentsSeparatedByString:@"."];
      int v29 = v5;
      int v30 = v4;
      std::string __p = 0;
      CFDictionaryRef v36 = 0;
      uint64_t v37 = 0;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      long long v34 = 0u;
      id v11 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v12 = [v11 countByEnumeratingWithState:&v31 objects:v38 count:16];
      if (v12)
      {
        uint64_t v13 = *(void *)v32;
        do
        {
          for (uint64_t i = 0; i != v12; ++i)
          {
            if (*(void *)v32 != v13) {
              objc_enumerationMutation(v11);
            }
            CFStringRef v15 = *(void **)(*((void *)&v31 + 1) + 8 * i);
            if ([v15 length])
            {
              __int16 v16 = [v15 intValue];
              __int16 v17 = v16;
              CFStringRef v18 = v36;
              if (v36 >= v37)
              {
                CFURLRef v20 = (char *)__p;
                uint64_t v21 = v36 - (unsigned char *)__p;
                if (v36 - (unsigned char *)__p <= -3) {
                  std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v22 = v21 >> 1;
                if (v37 - (unsigned char *)__p <= (unint64_t)((v21 >> 1) + 1)) {
                  uint64_t v23 = v22 + 1;
                }
                else {
                  uint64_t v23 = v37 - (unsigned char *)__p;
                }
                if ((unint64_t)(v37 - (unsigned char *)__p) >= 0x7FFFFFFFFFFFFFFELL) {
                  uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  uint64_t v24 = v23;
                }
                if (v24)
                {
                  stat v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)&v37, v24);
                  CFURLRef v20 = (char *)__p;
                  CFStringRef v18 = v36;
                }
                else
                {
                  stat v25 = 0;
                }
                CFStringRef v26 = &v25[2 * v22];
                *(_WORD *)CFStringRef v26 = v17;
                CFStringRef v19 = v26 + 2;
                while (v18 != v20)
                {
                  __int16 v27 = *((_WORD *)v18 - 1);
                  v18 -= 2;
                  *((_WORD *)v26 - 1) = v27;
                  v26 -= 2;
                }
                std::string __p = v26;
                CFDictionaryRef v36 = v19;
                uint64_t v37 = &v25[2 * v24];
                if (v20) {
                  operator delete(v20);
                }
              }
              else
              {
                *(_WORD *)CFDictionaryRef v36 = v16;
                CFStringRef v19 = v18 + 2;
              }
              CFDictionaryRef v36 = v19;
            }
          }
          uint64_t v12 = [v11 countByEnumeratingWithState:&v31 objects:v38 count:16];
        }
        while (v12);
      }

      long long v5 = v29;
      std::string v4 = v30;
      uint64_t v28 = [MEMORY[0x1E4F1C9B8] dataWithBytes:__p length:v36 - (unsigned char *)__p];
      if (__p)
      {
        CFDictionaryRef v36 = (char *)__p;
        operator delete(__p);
      }
    }
    *a2 = v8;
    a2[1] = v28;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1D34B2DD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

id objc_cast<NSString,void const*>(void *a1)
{
  uint64_t v1 = objc_cast<NSString,objc_object * {__strong}>(a1);
  return v1;
}

CFDictionaryRef TCFURLInfo::CreateTagDictionary(TCFURLInfo *this, const __CFString *a2, const __CFData *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    *(_OWORD *)keys = xmmword_1E698FF78;
    v7[0] = this;
    v7[1] = a2;
    signed int v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    std::string v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    CFIndex v5 = 2;
  }
  else
  {
    keys[0] = @"TagName";
    v7[0] = this;
    signed int v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    std::string v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    CFIndex v5 = 1;
  }
  return CFDictionaryCreate(0, (const void **)keys, v7, v5, v3, v4);
}

void TCFURLIterator::TCFURLIterator(TCFURLIterator *this, const TCFURLInfo *a2, const __CFArray *a3, char a4)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = a3;
  if (a3) {
    CFRetain(a3);
  }
  *((unsigned char *)this + 72) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((unsigned char *)this + 73) = a4;
  *((unsigned char *)this + 7TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
}

void sub_1D34B2FCC(_Unwind_Exception *a1)
{
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(v2);
  std::string v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(a1);
}

CFIndex TCFURLIterator::NextRaw(uint64_t a1, TString **a2)
{
  uint64_t v9 = 0;
  CFStringRef v10 = 0;
  uint64_t v4 = MEMORY[0x1D9435F80](*(void *)(a1 + 16), &v9, &v10);
  if (v4 == 1)
  {
    CFIndex v7 = TCFURLInfo::Initialize(*a2, v9, 1, *(unsigned __int8 *)(a1 + 73));
  }
  else if (v4 == 3)
  {
    unsigned int v6 = TCFURLInfo::TranslateCFError(v10, v5);
    if (v6 == -43) {
      CFIndex v7 = 4294959234;
    }
    else {
      CFIndex v7 = v6;
    }
  }
  else
  {
    CFIndex v7 = 4294965879;
  }
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v10);
  return v7;
}

void sub_1D34B3080(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  CFDateRef result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  CFIndex v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    CFURLRef v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)result, v13);
    CFStringRef v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    id v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)CFStringRef v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<TCFURLInfo>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    CFDateRef result = std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer(v18);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1D34B319C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::TDeepCFURLIterator(uint64_t a1, uint64_t a2, char a3, char a4, const void *a5, char a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char a11, char a12, char a13, uint64_t *a14, int a15)
{
  *(void *)(a1 + 8) = *(void *)a2;
  uint64_t v20 = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + ++**(_DWORD **)(result + 32) = 0;
  *(unsigned char *)(a1 + 48) = a6;
  *(unsigned char *)(a1 + 55) = a10;
  *(unsigned char *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 97) = 0u;
  *(void *)(a1 + 120) = a7;
  *(void *)(a1 + 128) = a8;
  *(void *)(a1 + 14TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  uint64_t v21 = (const __CFURL ***)(a1 + 144);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = &stru_1F2ABD380;
  uint64_t v22 = (CFTypeRef *)(a1 + 160);
  CFRetain(&stru_1F2ABD380);
  *(void *)(a1 + 168) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 22TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(void *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 2++**(_DWORD **)(result + 32) = a15;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a1 + 40), a5);
  *(unsigned char *)(a1 + 216) = a11;
  *(void *)(a1 + 136) = a9;
  *(unsigned char *)(a1 + 217) = a3;
  *(unsigned char *)(a1 + 218) = a4;
  uint64_t v24 = *a14;
  uint64_t v23 = a14[1];
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  stat v25 = *(std::__shared_weak_count **)(a1 + 152);
  *(void *)(a1 + 14TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v24;
  *(void *)(a1 + 152) = v23;
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
  }
  if (*(unsigned char *)(a1 + 217) && *v21)
  {
    TCFURLInfo::FileSystemRepresentation(**(TCFURLInfo ***)a2, (const __CFURL *)1, (TString *)&cf);
    if (v22 != &cf)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(a1 + 160), &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (*v21) {
      *(void *)(a1 + 22TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = TCFURLInfo::GetNumericalProperty(**v21, (const __CFString *)*MEMORY[0x1E4F1D8A0], v26);
    }
  }
  TCFURLInfo::Name(*(TCFURLInfo **)a2, (TString *)&cf);
  if ((CFTypeRef *)(a1 + 168) != &cf)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(a1 + 168), &cf);
    CFRetain(&stru_1F2ABD380);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = &stru_1F2ABD380;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  __int16 v27 = *(std::__shared_weak_count **)(a1 + 208);
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  *(void *)a1 = 0;
  *(unsigned char *)(a1 + 219) = a12;
  *(unsigned char *)(a1 + 220) = a13;
  TDeepCFURLIterator::Reset((TDeepCFURLIterator *)a1);
  return a1;
}

{
  return TDeepCFURLIterator::TDeepCFURLIterator(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

void sub_1D34B3400(_Unwind_Exception *a1, void **a2, ...)
{
  va_start(va, a2);
  CFIndex v7 = (std::__shared_weak_count *)v2[26];
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  uint64_t v8 = (std::__shared_weak_count *)v2[19];
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)v2[13];
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    v2[10] = v10;
    operator delete(v10);
  }
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(v3);
  unint64_t v11 = (std::__shared_weak_count *)v2[4];
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  uint64_t v12 = (std::__shared_weak_count *)v2[2];
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::Reset(TDeepCFURLIterator *this)
{
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    *(void *)&long long v18 = v2 + 40;
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(v2 + 32));
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(v2 + 16));
    signed int v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    MEMORY[0x1D9436740](v2, 0x1060C40FBA2130BLL);
  }
  uint64_t v4 = (const void ***)((char *)this + 8);
  uint64_t v5 = *((void *)this + 1);
  if (*(int *)(v5 + 72) <= 0) {
    TCFURLInfo::FetchProperties(*((const void ***)this + 1), 1);
  }
  if (*(_WORD *)(v5 + 76)) {
    operator new();
  }
  *(void *)this = 0;
  if (*((unsigned char *)this + 218))
  {
    if (*((void *)this + 18))
    {
      TDeepCFURLIterator::CreateDestinationListForSource((uint64_t)this, (TCFURLInfo ***)this + 1, &v18);
      unint64_t v6 = (std::__shared_weak_count *)*((void *)this + 26);
      *(_OWORD *)((char *)this + 200) = v18;
      if (v6) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v6);
      }
    }
  }
  CFIndex v7 = *v4;
  if (*((int *)*v4 + 18) <= 0) {
    TCFURLInfo::FetchProperties(*v4, 1);
  }
  __int16 v8 = *((_WORD *)v7 + 38);
  *((unsigned char *)this + 49) = (v8 & 4) != 0;
  *((unsigned char *)this + 52) = 0;
  *((unsigned char *)this + 5TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  if ((v8 & 4) != 0)
  {
    uint64_t v10 = *((void *)this + 1);
    uint64_t v9 = *((void *)this + 2);
    if (v9) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v11 = (std::__shared_weak_count *)*((void *)this + 13);
    *((void *)this + 12) = v10;
    *((void *)this + 13) = v9;
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
  }
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 4);
  *((void *)this + 3) = 0;
  *((void *)this + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  *((_WORD *)this + 29) = *((unsigned __int8 *)this + 49);
  *((_WORD *)this + 30) = *((unsigned __int8 *)this + 52);
  *((_WORD *)this + 31) = *((unsigned __int8 *)this + 54);
  *((_WORD *)this + ++**(_DWORD **)(result + 32) = 1;
  *((_WORD *)this + 25) = 0;
  *((unsigned char *)this + 53) = 0;
  unint64_t v13 = (void *)*((void *)this + 15);
  if (v13) {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(v13);
  }
  CFURLRef v14 = (TCloneCache *)*((void *)this + 16);
  if (v14) {
    TCloneCache::RemoveAll(v14);
  }
  uint64_t result = (uint64_t)TDeepCFURLIterator::ResetReservationStack(this);
  if (*((unsigned char *)this + 217))
  {
    if (*((void *)this + 18))
    {
      LOBYTE(v18) = 1;
      if (*((unsigned char *)this + 55))
      {
        if (!*((unsigned char *)this + 56))
        {
          uint64_t v16 = *v4;
          if (*((int *)*v4 + 18) <= 0) {
            uint64_t result = TCFURLInfo::FetchProperties(*v4, 1);
          }
          if (*((_WORD *)v16 + 38))
          {
            uint64_t result = TCFURLInfo::EffectiveUserCanRead(*v4, (BOOL *)&v18);
            if (!result) {
              goto LABEL_37;
            }
            long long v17 = *v4;
            if (*((int *)v17 + 18) <= 1) {
              uint64_t result = TCFURLInfo::FetchProperties(v17, 1);
            }
            if ((*((_WORD *)v17 + 38) & 0x4000) == 0) {
LABEL_37:
            }
              *((unsigned char *)this + 56) = 1;
          }
        }
      }
    }
  }
  return result;
}

void sub_1D34B3708(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x1060C40FBA2130BLL);
  _Unwind_Resume(a1);
}

void TDeepCFURLIterator::~TDeepCFURLIterator(const void **this)
{
  TDeepCFURLIterator::DestroyIterators(this);
  TDeepCFURLIterator::ResetReservationStack((TDeepCFURLIterator *)this);
  uint64_t v2 = (std::__shared_weak_count *)this[26];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  __int16 v8 = (void **)(this + 22);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(this + 21);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(this + 20);
  signed int v3 = (std::__shared_weak_count *)this[19];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)this[13];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = (void *)this[9];
  if (v5)
  {
    this[10] = v5;
    operator delete(v5);
  }
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(this + 5);
  unint64_t v6 = (std::__shared_weak_count *)this[4];
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  CFIndex v7 = (std::__shared_weak_count *)this[2];
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
}

void *TDeepCFURLIterator::DestroyIterators(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *this;
  if (*this)
  {
    uint64_t v9 = (void **)(v2 + 40);
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v9);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(v2 + 32));
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(v2 + 16));
    signed int v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    this = (void *)MEMORY[0x1D9436740](v2, 0x1060C40FBA2130BLL);
  }
  *uint64_t v1 = 0;
  uint64_t v5 = v1[9];
  uint64_t v4 = v1[10];
  if (v4 != v5)
  {
    do
    {
      uint64_t v7 = *(void *)(v4 - 8);
      v4 -= 8;
      uint64_t v6 = v7;
      if (v7)
      {
        uint64_t v9 = (void **)(v6 + 40);
        std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v9);
        TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(v6 + 32));
        TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(v6 + 16));
        __int16 v8 = *(std::__shared_weak_count **)(v6 + 8);
        if (v8) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v8);
        }
        this = (void *)MEMORY[0x1D9436740](v6, 0x1060C40FBA2130BLL);
      }
    }
    while (v4 != v5);
    uint64_t v4 = v1[9];
  }
  v1[10] = v4;
  return this;
}

void *TDeepCFURLIterator::ResetReservationStack(TDeepCFURLIterator *this)
{
  uint64_t result = (void *)*((void *)this + 17);
  if (result)
  {
    while (1)
    {
      uint64_t v3 = result[5];
      if (!v3) {
        break;
      }
      uint64_t v4 = *(TReservationRecord **)(*(void *)(result[1]
                                              + (((unint64_t)(v3 + result[4] - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                                  + 8 * ((v3 + result[4] - 1) & 0x1FF));
      if (!v4) {
        break;
      }
      result[5] = v3 - 1;
      std::deque<TReservationRecord *>::__maybe_remove_back_spare[abi:ne180100](result, 1);
      TReservationRecord::~TReservationRecord(v4);
      MEMORY[0x1D9436740]();
      uint64_t result = (void *)*((void *)this + 17);
    }
  }
  return result;
}

void TCFURLIterator::~TCFURLIterator(const void **this)
{
  uint64_t v3 = (void **)(this + 5);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v3);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(this + 4);
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(this + 2);
  uint64_t v2 = (std::__shared_weak_count *)this[1];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void TDeepCFURLIterator::CreateDestinationListForSource(uint64_t a1@<X0>, TCFURLInfo ***a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x30uLL);
  v6[1] = 0;
  void v6[2] = 0;
  void v6[3] = 0;
  void *v6 = &unk_1F2ABB198;
  void v6[4] = 0;
  void v6[5] = 0;
  *a3 = v6 + 3;
  a3[1] = v6;
  if (CFStringGetLength(*(CFStringRef *)(a1 + 160)))
  {
    TDeepCFURLIterator::MapSourceToDestination(a1, a2, &v20);
    uint64_t v7 = v20;
    if (v20)
    {
      if (*((int *)v20 + 18) <= 0) {
        TCFURLInfo::FetchProperties(v20, 1);
      }
      if (*((_WORD *)v7 + 38))
      {
        TCFURLIterator::TCFURLIterator((TCFURLIterator *)v15, (const TCFURLInfo *)v7, *(const __CFArray **)(a1 + 40), 1);
        do
        {
          _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v14);
          int v8 = TCFURLIterator::Next((uint64_t)v15, (uint64_t)&v14);
          if (!v8)
          {
            uint64_t v9 = v14;
            if (*(int *)(v14 + 72) <= 0) {
              TCFURLInfo::FetchProperties((const void **)v14, 1);
            }
            if ((*(_WORD *)(v9 + 76) & 0x20) != 0) {
              std::vector<std::shared_ptr<TCFURLInfo>>::push_back[abi:ne180100](v6 + 3, &v14);
            }
          }
          if (*((void *)&v14 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v14 + 1));
          }
        }
        while (!v8);
        unint64_t v10 = v6[3];
        unint64_t v11 = v6[4];
        unint64_t v12 = 126 - 2 * __clz((uint64_t)(v11 - v10) >> 4);
        if (v11 == v10) {
          uint64_t v13 = 0;
        }
        else {
          uint64_t v13 = v12;
        }
        std::__introsort<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,false>(v10, v11, v13, 1);
        *(void *)&long long v14 = &v19;
        std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v14);
        TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(&v18);
        TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(&v17);
        if (v16) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v16);
        }
      }
    }
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
  }
}

void sub_1D34B3B90(_Unwind_Exception *a1)
{
  uint64_t v4 = *(std::__shared_weak_count **)(v2 - 64);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::CurrentContainerInfo@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  *a2 = *(void *)(this + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t TDeepCFURLIterator::Cancel(uint64_t this)
{
  *(unsigned char *)(this + 112) = 1;
  if (*(void *)this) {
    *(unsigned char *)(*(void *)this + 72) = 1;
  }
  uint64_t v1 = *(uint64_t **)(this + 72);
  for (uint64_t i = *(uint64_t **)(this + 80); v1 != i; *(unsigned char *)(v3 + 72) = 1)
    uint64_t v3 = *v1++;
  return this;
}

void TDeepCFURLIterator::PushIterator(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __int16 v5 = *(_WORD *)(a1 + 58);
  if (!v5)
  {
    if (*(int *)(v4 + 72) <= 0) {
      TCFURLInfo::FetchProperties((const void **)v4, 1);
    }
    if ((*(_WORD *)(v4 + 76) & 4) != 0)
    {
LABEL_9:
      if (*(void *)(a1 + 136)) {
        operator new();
      }
      if (!*(void *)(a1 + 96))
      {
        if (v3) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v6 = *(std::__shared_weak_count **)(a1 + 104);
        *(void *)(a1 + 96) = v4;
        *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v3;
        if (v6) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v6);
        }
      }
      ++*(_WORD *)(a1 + 58);
LABEL_17:
      __int16 v7 = *(_WORD *)(a1 + 60);
      if (!v7 && (IsTrash = TCFURLInfo::IsTrash((TCFURLInfo *)v4), __int16 v7 = *(_WORD *)(a1 + 60), IsTrash) || v7 >= 1) {
        *(_WORD *)(a1 + 60) = v7 + 1;
      }
      __int16 v9 = *(_WORD *)(a1 + 62);
      if (!v9
        && (*(int *)(v4 + 72) <= 0
          ? (TCFURLInfo::FetchProperties((const void **)v4, 1), __int16 v9 = *(_WORD *)(a1 + 62))
          : (__int16 v9 = 0),
            (*(_WORD *)(v4 + 76) & 0x20) == 0)
        || v9 >= 1)
      {
        *(_WORD *)(a1 + 62) = v9 + 1;
      }
      unint64_t v10 = *(void *)(a1 + 88);
      ++*(_WORD *)(a1 + 64);
      unint64_t v11 = *(void **)(a1 + 80);
      if ((unint64_t)v11 >= v10)
      {
        uint64_t v13 = *(void *)(a1 + 72);
        uint64_t v14 = ((uint64_t)v11 - v13) >> 3;
        if ((unint64_t)(v14 + 1) >> 61) {
          std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = v10 - v13;
        uint64_t v16 = v15 >> 2;
        if (v15 >> 2 <= (unint64_t)(v14 + 1)) {
          uint64_t v16 = v14 + 1;
        }
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v17) {
          long long v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(a1 + 88, v17);
        }
        else {
          long long v18 = 0;
        }
        uint64_t v19 = &v18[8 * v14];
        uint64_t v20 = &v18[8 * v17];
        *(void *)uint64_t v19 = *(void *)a1;
        unint64_t v12 = v19 + 8;
        uint64_t v22 = *(char **)(a1 + 72);
        uint64_t v21 = *(char **)(a1 + 80);
        if (v21 != v22)
        {
          do
          {
            uint64_t v23 = *((void *)v21 - 1);
            v21 -= 8;
            *((void *)v19 - 1) = v23;
            v19 -= 8;
          }
          while (v21 != v22);
          uint64_t v21 = *(char **)(a1 + 72);
        }
        *(void *)(a1 + 72) = v19;
        *(void *)(a1 + 80) = v12;
        *(void *)(a1 + 88) = v20;
        if (v21) {
          operator delete(v21);
        }
      }
      else
      {
        *unint64_t v11 = *(void *)a1;
        unint64_t v12 = v11 + 1;
      }
      *(void *)(a1 + 80) = v12;
      BOOL v24 = 1;
      if (*(unsigned char *)(a1 + 217) && *(void *)(a1 + 144) && *(unsigned char *)(a1 + 55) && !*(unsigned char *)(a1 + 56))
      {
        if (!TCFURLInfo::EffectiveUserCanRead((const void **)v4, &v24)) {
          goto LABEL_58;
        }
        if (*(int *)(v4 + 72) <= 1) {
          TCFURLInfo::FetchProperties((const void **)v4, 1);
        }
        if ((*(_WORD *)(v4 + 76) & 0x4000) == 0)
        {
LABEL_58:
          if (!*(_WORD *)(a1 + 60)) {
            *(unsigned char *)(a1 + 56) = 1;
          }
        }
      }
      operator new();
    }
    __int16 v5 = *(_WORD *)(a1 + 58);
  }
  if (v5 < 1) {
    goto LABEL_17;
  }
  goto LABEL_9;
}

void sub_1D34B4064(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TDeepCFURLIterator::Next(uint64_t a1, TCFURLInfo **a2, _DWORD *a3, _DWORD *a4, BOOL *a5, unsigned char *a6, void *a7, unsigned char *a8, uint64_t **a9)
{
  uint64_t result = TDeepCFURLIterator::NextInternal(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
  if (*(unsigned char *)(a1 + 48)) {
    BOOL v18 = result == 0;
  }
  else {
    BOOL v18 = 0;
  }
  if (v18)
  {
    while (TCFURLInfo::IsTrash(*a2) || *(unsigned char *)(a1 + 53))
    {
      uint64_t result = TDeepCFURLIterator::NextInternal(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
      if (result) {
        return result;
      }
    }
    while (*(_DWORD *)(a1 + 232) == 3)
    {
      TCFURLInfo::Name(*a2, &v23);
      TString::TString(&v22, ".com.apple.backupd.mvlist.plist", 0x1FuLL);
      if (CFEqual(v23.fString.fRef, v22.fString.fRef))
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
      }
      else
      {
        TCFURLInfo::Name(*a2, &v21);
        TString::TString(&v20, ".com.apple.backupd.mdmv", 0x17uLL);
        BOOL v19 = TString::BeginsWith(&v21, &v20);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23.fString.fRef);
        if (!v19) {
          return 0;
        }
      }
      uint64_t result = TDeepCFURLIterator::NextInternal(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
      if (result) {
        return result;
      }
    }
    return 0;
  }
  return result;
}

void sub_1D34B4268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  int v8 = va_arg(va3, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  _Unwind_Resume(a1);
}

uint64_t TDeepCFURLIterator::NextInternal(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, BOOL *a5, unsigned char *a6, void *a7, unsigned char *a8, uint64_t **a9)
{
  uint64_t v16 = (std::__shared_weak_count *)a7[1];
  *a7 = 0;
  a7[1] = 0;
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  *a8 = 0;
  unint64_t v17 = (std::__shared_weak_count *)a9[1];
  *a9 = 0;
  a9[1] = 0;
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  BOOL v18 = *(uint64_t **)a1;
  if (!*(void *)a1) {
    goto LABEL_69;
  }
  uint64_t v50 = a3;
  while (1)
  {
    *(unsigned char *)(a1 + 50) = *(__int16 *)(a1 + 58) > 0;
    *(unsigned char *)(a1 + 53) = *(__int16 *)(a1 + 60) > 0;
    *(unsigned char *)(a1 + 51) = *(__int16 *)(a1 + 62) > 0;
    uint64_t v19 = TCFURLIterator::Next((uint64_t)v18, a2);
    uint64_t v21 = **(void **)a1;
    uint64_t v20 = *(void *)(*(void *)a1 + 8);
    if (v20) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
    }
    TString v22 = *(std::__shared_weak_count **)(a1 + 32);
    *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v21;
    *(void *)(a1 + ++**(_DWORD **)(result + 32) = v20;
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
    }
    if (!v19) {
      break;
    }
    if (!*a9 && !*(unsigned char *)(a1 + 50))
    {
      TString v23 = *(uint64_t **)(a1 + 200);
      if (v23)
      {
        BOOL v24 = (uint64_t **)*v23;
        if (*v23 != v23[1])
        {
          TString v23 = *v24;
          stat v25 = v24[1];
          if (v25) {
            atomic_fetch_add_explicit(v25 + 1, 1uLL, memory_order_relaxed);
          }
          goto LABEL_30;
        }
        TString v23 = 0;
      }
      stat v25 = 0;
LABEL_30:
      long long v31 = (std::__shared_weak_count *)a9[1];
      *a9 = v23;
      a9[1] = v25;
      if (v31) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v31);
      }
    }
    TDeepCFURLIterator::PopIterator((TDeepCFURLIterator *)a1);
    ++*a4;
    *a8 = 1;
LABEL_33:
    BOOL v18 = *(uint64_t **)a1;
    if (!*(void *)a1 || v19 != -1417) {
      goto LABEL_68;
    }
  }
  TDeepCFURLIterator::RecordHardlink(*(void *)(a1 + 120), (const void ***)a2, (const __CFString *)*(unsigned int *)(a1 + 232));
  CFStringRef v26 = *(const void ***)(a1 + 128);
  int v27 = *(_DWORD *)(a1 + 232);
  uint64_t v28 = *(const void ***)a2;
  if (*(int *)(*(void *)a2 + 72) <= 0) {
    TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
  }
  TDeepCFURLIterator::RecordClone(v26, (uint64_t *)a2, v27 == 1, *((unsigned __int16 *)v28 + 38) >> 15);
  int v30 = *(const void ***)a2;
  if (*(int *)(*(void *)a2 + 72) <= 0) {
    TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
  }
  if ((*((_WORD *)v30 + 38) & 1) != 0
    && (TCFURLInfo::ShouldSkip(*(const void ***)a2, *(void *)(a1 + 224), 0)
     || *(unsigned char *)(a1 + 48) && (TCFURLInfo::IsTrash(*(TCFURLInfo **)a2) || *(unsigned char *)(a1 + 53))))
  {
    uint64_t v19 = 4294965879;
    goto LABEL_33;
  }
  if ((uint64_t)TCFURLInfo::GetNumericalProperty(**(const __CFURL ***)a2, (const __CFString *)*MEMORY[0x1E4F1D708], v29) < 2)
  {
    __int16 v35 = a5;
    *a5 = 0;
    unint64_t v56 = 0;
    BOOL v55 = 0;
    long long v33 = *(const void ***)a2;
    goto LABEL_40;
  }
  LOBYTE(v++**(_DWORD **)(result + 32) = 0;
  long long v33 = *(const void ***)a2;
  __int16 v34 = *(_WORD *)(*(void *)a2 + 76);
  __int16 v35 = a5;
  *a5 = (v34 & 0x200) != 0;
  unint64_t v56 = 0;
  BOOL v55 = 0;
  if ((v34 & 0x200) == 0)
  {
LABEL_40:
    if (*((int *)v33 + 18) <= 0) {
      TCFURLInfo::FetchProperties(v33, 1);
    }
    if (*((_WORD *)v33 + 38))
    {
      LOBYTE(v++**(_DWORD **)(result + 32) = 0;
    }
    else
    {
      int IsClone = TCFURLInfo::IsClone(*(const void ***)a2, &v56, &v55);
      LOBYTE(v++**(_DWORD **)(result + 32) = 0;
      if (IsClone && v55) {
        int v32 = (*(unsigned __int8 *)(*(void *)a2 + 78) >> 4) & 1;
      }
    }
  }
  *a6 = v32;
  if (*(unsigned char *)(a1 + 218))
  {
    if (*(void *)(a1 + 144))
    {
      if (!*(unsigned char *)(a1 + 50))
      {
        TCFURLInfoList::FindAndRemove(*(void *)(a1 + 200), (TCFURLInfo **)a2, (TCFURLInfo **)&v54);
        uint64_t v37 = (std::__shared_weak_count *)a7[1];
        *(_OWORD *)a7 = v54;
        if (v37) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v37);
        }
      }
    }
  }
  uint64_t v38 = *(const void ***)a2;
  if (*(int *)(*(void *)a2 + 72) <= 0) {
    TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
  }
  uint64_t v19 = 0;
  if ((*((_WORD *)v38 + 38) & 1) != 0 && !*v35)
  {
    uint64_t v39 = *(const void ***)a2;
    if (*(int *)(*(void *)a2 + 72) <= 0) {
      TCFURLInfo::FetchProperties(*(const void ***)a2, 1);
    }
    if ((*((_WORD *)v39 + 38) & 0x80) != 0 || !*(void *)a1)
    {
      uint64_t v19 = 0;
    }
    else
    {
      CFTypeRef v40 = *(std::__shared_weak_count **)(a2 + 8);
      uint64_t v52 = *(const void ***)a2;
      id v53 = v40;
      if (v40) {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      TDeepCFURLIterator::PushIterator(a1, (uint64_t *)&v52);
      uint64_t v19 = v41;
      if (v53) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v53);
      }
      if (!v19) {
        ++*v50;
      }
    }
  }
  uint64_t v42 = *(void *)a2 + 76;
  int v43 = *(_WORD *)v42 & 0xFBFF | (*(unsigned __int8 *)(*(void *)a2 + 78) << 16) | (*(unsigned __int8 *)(a1 + 50) << 10);
  *(_WORD *)uint64_t v42 = *(_WORD *)v42 & 0xFBFF | (*(unsigned __int8 *)(a1 + 50) << 10);
  *(unsigned char *)(v42 + 2) = BYTE2(v43);
LABEL_68:
  if (v19 == -1417)
  {
LABEL_69:
    uint64_t v44 = *(void *)(a1 + 200);
    if (v44)
    {
      *a8 = 1;
      if (!*a9 && !*(unsigned char *)(a1 + 50))
      {
        _NSRange v45 = *(uint64_t **)v44;
        if (*(void *)v44 == *(void *)(v44 + 8))
        {
          _NSRange v46 = 0;
          TString v47 = 0;
        }
        else
        {
          _NSRange v46 = (uint64_t *)*v45;
          TString v47 = (uint64_t *)v45[1];
          if (v47) {
            atomic_fetch_add_explicit(v47 + 1, 1uLL, memory_order_relaxed);
          }
        }
        TString v48 = (std::__shared_weak_count *)a9[1];
        *a9 = v46;
        a9[1] = v47;
        if (v48) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v48);
        }
      }
    }
    return 4294965879;
  }
  return v19;
}

void sub_1D34B4734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void **std::vector<std::shared_ptr<TCFURLInfoList>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  __int16 v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    id v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<TCFURLInfoList>>::__swap_out_circular_buffer(a1, v18);
    __int16 v9 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer(v18);
  }
  else
  {
    void *v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    __int16 v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1D34B4854(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void TDeepCFURLIterator::PopIterator(TDeepCFURLIterator *this)
{
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    CFStringRef v26 = (void **)(v2 + 40);
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v26);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(v2 + 32));
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(v2 + 16));
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    MEMORY[0x1D9436740](v2, 0x1060C40FBA2130BLL);
  }
  uint64_t v4 = *((void *)this + 10);
  if (*((void *)this + 9) == v4)
  {
    *(void *)this = 0;
  }
  else
  {
    int v5 = *((__int16 *)this + 30);
    BOOL v6 = __OFSUB__(v5, 1);
    int v7 = v5 - 1;
    if (v7 < 0 == v6) {
      *((_WORD *)this + 30) = v7;
    }
    int v8 = *((__int16 *)this + 31);
    BOOL v6 = __OFSUB__(v8, 1);
    int v9 = v8 - 1;
    if (v9 < 0 == v6) {
      *((_WORD *)this + 31) = v9;
    }
    uint64_t v10 = *(const void ****)(v4 - 8);
    *(void *)this = v10;
    *((void *)this + 10) = v4 - 8;
    uint64_t v11 = *((void *)this + 23);
    if (*((void *)this + 22) != v11)
    {
      uint64_t v13 = *(void *)(v11 - 16);
      uint64_t v12 = *(void *)(v11 - 8);
      if (v12) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 26);
      *((void *)this + 25) = v13;
      *((void *)this + 26) = v12;
      if (v14) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v14);
      }
      uint64_t v15 = *((void *)this + 23);
      uint64_t v16 = *(std::__shared_weak_count **)(v15 - 8);
      if (v16) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v16);
      }
      *((void *)this + 23) = v15 - 16;
      uint64_t v10 = *(const void ****)this;
    }
    if (v10)
    {
      long long v17 = *v10;
      BOOL v18 = (TCFURLInfo *)*v10;
      if (*((int *)*v10 + 18) <= 0)
      {
        TCFURLInfo::FetchProperties(*v10, 1);
        BOOL v18 = **(TCFURLInfo ***)this;
      }
      *((unsigned char *)this + 49) = (*((unsigned char *)v17 + 76) & 4) != 0;
      *((unsigned char *)this + 52) = TCFURLInfo::IsTrash(v18);
      --*((_WORD *)this + 32);
    }
    else
    {
      *((unsigned char *)this + 49) = 0;
      *((unsigned char *)this + 52) = 0;
    }
    int v19 = *((__int16 *)this + 29);
    BOOL v6 = __OFSUB__(v19, 1);
    int v20 = v19 - 1;
    if (v20 < 0 == v6)
    {
      *((_WORD *)this + 29) = v20;
      if (!(_WORD)v20)
      {
        uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 13);
        *((void *)this + 12) = 0;
        *((void *)this + 13) = 0;
        if (v21) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v21);
        }
      }
      TString v22 = (void *)*((void *)this + 17);
      if (v22)
      {
        uint64_t v23 = v22[5];
        if (v23)
        {
          uint64_t v24 = v23 - 1;
          stat v25 = *(TReservationRecord **)(*(void *)(v22[1]
                                                   + (((unint64_t)(v22[4] + v24) >> 6) & 0x3FFFFFFFFFFFFF8))
                                       + 8 * ((v22[4] + v24) & 0x1FF));
          v22[5] = v24;
          std::deque<TReservationRecord *>::__maybe_remove_back_spare[abi:ne180100](v22, 1);
          if (v25)
          {
            TReservationRecord::~TReservationRecord(v25);
            MEMORY[0x1D9436740]();
          }
        }
      }
    }
  }
}

uint64_t TDeepCFURLIterator::RecordHardlink(uint64_t result, const void ***a2, const __CFString *a3)
{
  if (result)
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      uint64_t v5 = result;
      unsigned int v6 = a3 & 0xFFFFFFFB;
      if (*((int *)v4 + 18) <= 0) {
        uint64_t result = TCFURLInfo::FetchProperties(*a2, 1);
      }
      if (v6 == 2 || (*((_WORD *)v4 + 38) & 1) == 0)
      {
        CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1D708];
        uint64_t result = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL *)**a2, (const __CFString *)*MEMORY[0x1E4F1D708], a3);
        if (result >= 2)
        {
          uint64_t ObjectIdentifier = TCFURLInfo::GetObjectIdentifier((TCFURLInfo *)*a2);
          int v8 = *a2;
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(v5, (unint64_t *)&ObjectIdentifier, &ObjectIdentifier);
          char v10 = v9;
          uint64_t result = (uint64_t)TCFURLInfo::GetNumericalProperty((const __CFURL *)*v8, v7, v11);
          if (result >= 2)
          {
            int v13 = *((unsigned __int16 *)v8 + 38);
            uint64_t v12 = (char *)v8 + 76;
            unsigned int v14 = v13 & 0xFFFFFDFF | (v12[2] << 16);
            id v12[2] = BYTE2(v14);
            *(_WORD *)uint64_t v12 = (v14 | ((v10 & 1) << 9)) ^ 0x200;
          }
        }
      }
    }
  }
  return result;
}

const void **TDeepCFURLIterator::RecordClone(const void **result, uint64_t *a2, int a3, char a4)
{
  if (result)
  {
    uint64_t v5 = (TCloneCache *)result;
    uint64_t result = (const void **)*a2;
    if (*a2)
    {
      unint64_t v16 = 0;
      uint64_t result = (const void **)TCFURLInfo::IsClone(result, &v16, 0);
      if (result)
      {
        if ((!a3
           || (uint64_t result = (const void **)TCFURLInfo::GetNumericalProperty(*(const __CFURL **)*a2, (const __CFString *)*MEMORY[0x1E4F1D640], v8)) != 0)&& (a4 & 1) == 0)
        {
          BOOL HasCloneID = TCloneCache::HasCloneID(v5, &v16);
          if (!HasCloneID) {
            TCloneCache::RecordClone(v5, &v16, a2);
          }
          uint64_t v10 = *a2;
          uint64_t result = (const void **)TCFURLInfo::IsClone((const void **)v10, 0, 0);
          if (result)
          {
            int v12 = *(unsigned __int16 *)(v10 + 76);
            uint64_t v11 = v10 + 76;
            int v13 = v12 | (*(unsigned __int8 *)(v11 + 2) << 16);
            if (HasCloneID) {
              int v14 = 0x100000;
            }
            else {
              int v14 = 0;
            }
            unsigned int v15 = v13 & 0xFFEFFFFF;
            *(_WORD *)uint64_t v11 = v15;
            *(unsigned char *)(v11 + 2) = (v15 | v14) >> 16;
          }
        }
      }
    }
  }
  return result;
}

void TCFURLInfoList::FindAndRemove(uint64_t a1@<X0>, TCFURLInfo **a2@<X1>, TCFURLInfo **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  uint64_t v7 = *(void *)a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v8 = v6 - *(void *)a1;
  if (v8 >= 1)
  {
    unint64_t v9 = (unint64_t)v8 >> 4;
    do
    {
      uint64_t v10 = (TCFURLInfo **)(v7 + 16 * (v9 >> 1));
      int v12 = *v10;
      uint64_t v11 = v10 + 2;
      if (TCFURLInfo::LessThan(v12, a2))
      {
        uint64_t v7 = (uint64_t)v11;
        v9 += ~(v9 >> 1);
      }
      else
      {
        v9 >>= 1;
      }
    }
    while ((uint64_t)v9 > 0);
    uint64_t v6 = *(void *)(a1 + 8);
  }
  if (v7 != v6)
  {
    TCFURLInfo::Name(*(TCFURLInfo **)v7, &v21);
    TCFURLInfo::Name(*a2, &v20);
    int v13 = CFEqual(v21.fString.fRef, v20.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
    if (v13)
    {
      unsigned int v15 = *(TCFURLInfo **)v7;
      int v14 = *(atomic_ullong **)(v7 + 8);
      if (v14) {
        atomic_fetch_add_explicit(v14 + 1, 1uLL, memory_order_relaxed);
      }
      *a3 = v15;
      a3[1] = (TCFURLInfo *)v14;
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<TCFURLInfo> *,std::shared_ptr<TCFURLInfo> *,std::shared_ptr<TCFURLInfo> *>((uint64_t)&v21, (long long *)(v7 + 16), *(long long **)(a1 + 8), v7);
      uint64_t v17 = v16;
      for (uint64_t i = *(void *)(a1 + 8); i != v17; i -= 16)
      {
        int v19 = *(std::__shared_weak_count **)(i - 8);
        if (v19) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v19);
        }
      }
      *(void *)(a1 + 8) = v17;
    }
  }
}

void sub_1D34B4D54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  int v12 = *(std::__shared_weak_count **)(v10 + 8);
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(exception_object);
}

const void **TDeepCFURLIterator::MapSourceToDestination@<X0>(uint64_t a1@<X0>, TCFURLInfo ***a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  v7.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  if (TCFURLInfo::FileSystemRepresentationRelativeToSource(*a2, (const TString *)(a1 + 160), &v7)) {
    TCFURLInfo::CreateCFURLInfoWithFileSystemRepresentationRelativeToBase(*(TCFURLInfo **)(a1 + 144), &v7, (const __CFString **)(a1 + 168), (uint64_t)a3);
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
}

void sub_1D34B4E10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 8);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(a1);
}

void TFileDescriptor::~TFileDescriptor(TFileDescriptor *this)
{
  if (*((int *)this + 2) >= 1) {
    TFileDescriptor::Close(this);
  }
}

uint64_t ReturnToSenderEnabled(void)
{
  {
    ReturnToSenderEnabled(void)::enabled = getSYDocumentWorkflowsClass() != 0;
  }
  return ReturnToSenderEnabled(void)::enabled;
}

void sub_1D34B4ED8(_Unwind_Exception *a1)
{
}

std::vector<char> *__cdecl std::vector<char>::vector(std::vector<char> *this, std::vector<char>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<char>::__vallocate[abi:ne180100](this, __n);
    std::vector<char>::pointer end = this->__end_;
    uint64_t v5 = &end[__n];
    bzero(end, __n);
    this->__end_ = v5;
  }
  return this;
}

void sub_1D34B4F48(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<char>::__append(std::vector<char> *this, std::vector<char>::size_type __n)
{
  std::vector<char>::pointer end = this->__end_;
  uint64_t value = this->__end_cap_.__value_;
  if (value - end >= __n)
  {
    if (__n)
    {
      bzero(this->__end_, __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<char>::pointer begin = this->__begin_;
    int64_t v7 = end - this->__begin_;
    unint64_t v8 = v7 + __n;
    if ((uint64_t)(v7 + __n) < 0) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = value - begin;
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      uint64_t v11 = (char *)operator new(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    int v12 = &v11[v7];
    int v13 = &v11[v10];
    bzero(v12, __n);
    if (end == begin)
    {
      uint64_t v11 = v12;
    }
    else
    {
      int v14 = &end[~(unint64_t)begin];
      do
      {
        char v15 = *--end;
        (v14--)[(void)v11] = v15;
      }
      while (end != begin);
      std::vector<char>::pointer end = this->__begin_;
    }
    this->__begin_ = v11;
    this->__end_ = &v12[__n];
    this->__end_cap_.__value_ = v13;
    if (end)
    {
      operator delete(end);
    }
  }
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  std::vector<char>::pointer begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  std::vector<char>::pointer end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  uint64_t value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  id v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
}

id std::vector<NSURL * {__strong}>::push_back[abi:ne180100](char **a1, id *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = (v7 - *a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)*a1;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v25 = v4;
    if (v13) {
      long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    }
    else {
      long long v14 = 0;
    }
    long long v15 = &v14[8 * v10];
    uint64_t v16 = &v14[8 * v13];
    uint64_t v24 = v16;
    *(void *)long long v15 = *a2;
    uint64_t v9 = v15 + 8;
    v23.i64[1] = (uint64_t)(v15 + 8);
    BOOL v18 = *a1;
    uint64_t v17 = a1[1];
    if (v17 == *a1)
    {
      int64x2_t v20 = vdupq_n_s64((unint64_t)v17);
    }
    else
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *(void *)uint64_t v17 = 0;
        *((void *)v15 - 1) = v19;
        v15 -= 8;
      }
      while (v17 != v18);
      int64x2_t v20 = *(int64x2_t *)a1;
      uint64_t v9 = (char *)v23.i64[1];
      uint64_t v16 = v24;
    }
    *a1 = v15;
    a1[1] = v9;
    int64x2_t v23 = v20;
    TString v21 = a1[2];
    a1[2] = v16;
    uint64_t v24 = v21;
    uint64_t v22 = v20.i64[0];
    id result = (id)std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)&v22);
  }
  else
  {
    id result = *a2;
    *(void *)uint64_t v7 = result;
    uint64_t v9 = v7 + 8;
  }
  a1[1] = v9;
  return result;
}

const void **TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::operator=<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

const void **TRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t std::string_view::compare[abi:ne180100](void *a1, unint64_t a2, size_t a3, void *__s2, size_t a5)
{
  unint64_t v5 = a1[1];
  BOOL v6 = v5 >= a2;
  size_t v7 = v5 - a2;
  if (!v6) {
    std::__throw_out_of_range[abi:ne180100]("string_view::substr");
  }
  uint64_t v9 = (const void *)(*a1 + a2);
  if (v7 >= a3) {
    size_t v10 = a3;
  }
  else {
    size_t v10 = v7;
  }
  if (a5 >= v10) {
    size_t v11 = v10;
  }
  else {
    size_t v11 = a5;
  }
  LODWORD(result) = memcmp(v9, __s2, v11);
  if (v10 < a5) {
    unsigned int v13 = -1;
  }
  else {
    unsigned int v13 = 1;
  }
  if (v10 == a5) {
    unsigned int v13 = 0;
  }
  if (result) {
    return result;
  }
  else {
    return v13;
  }
}

BOOL operator==(CFTypeRef *a1, const char *a2)
{
  TString::TString((TString *)&cf2, a2);
  BOOL v3 = CFEqual(*a1, cf2) != 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf2);
  return v3;
}

void sub_1D34B55E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::string>::__push_back_slow_path<std::string const&>(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
  if (v9) {
    size_t v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  }
  else {
    size_t v10 = 0;
  }
  std::__split_buffer<std::string>::pointer end = v10 + v4;
  __v.__first_ = v10;
  __v.__begin_ = end;
  __v.__end_ = end;
  __v.__end_cap_.__value_ = &v10[v9];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(end, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    std::__split_buffer<std::string>::pointer end = __v.__end_;
  }
  else
  {
    long long v12 = *a2;
    end->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v12;
  }
  __v.__end_ = end + 1;
  std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
  uint64_t v13 = a1[1];
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v13;
}

void sub_1D34B570C(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(2 * a2);
}

uint64_t std::vector<std::shared_ptr<TCFURLInfo>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  id v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 16;
  }
}

uint64_t std::vector<std::shared_ptr<TCFURLInfoList>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<TCFURLInfoList>>,std::reverse_iterator<std::shared_ptr<TCFURLInfoList>*>,std::reverse_iterator<std::shared_ptr<TCFURLInfoList>*>,std::reverse_iterator<std::shared_ptr<TCFURLInfoList>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<TCFURLInfoList>>,std::reverse_iterator<std::shared_ptr<TCFURLInfoList>*>,std::reverse_iterator<std::shared_ptr<TCFURLInfoList>*>,std::reverse_iterator<std::shared_ptr<TCFURLInfoList>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  id v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfoList>>,std::reverse_iterator<std::shared_ptr<TCFURLInfoList>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfoList>>,std::reverse_iterator<std::shared_ptr<TCFURLInfoList>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TCFURLInfo>>,std::reverse_iterator<std::shared_ptr<TCFURLInfo>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

long long *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::shared_ptr<TCFURLInfo> *,std::shared_ptr<TCFURLInfo> *,std::shared_ptr<TCFURLInfo> *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      }
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

Class initSYDocumentWorkflows(void)
{
  if (SynapseLibrary(void)::frameworkLibrary
    || (SynapseLibrary(void)::frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/Synapse.framework/Synapse", 2)) != 0)
  {
    Class Class = objc_getClass("SYDocumentWorkflows");
    classSYDocumentWorkflows = (uint64_t)Class;
    getSYDocumentWorkflowsClass Class = (uint64_t (*)(void))SYDocumentWorkflowsFunction;
  }
  else
  {
    Class Class = (Class)classSYDocumentWorkflows;
  }
  return Class;
}

{
  Class Class;
  uint64_t vars8;

  if (SynapseLibrary(void)::frameworkLibrary
    || (SynapseLibrary(void)::frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/Synapse.framework/Synapse", 2)) != 0)
  {
    Class Class = objc_getClass("SYDocumentWorkflows");
    classSYDocumentWorkflows = (uint64_t)Class;
    getSYDocumentWorkflowsClass Class = (uint64_t (*)(void))SYDocumentWorkflowsFunction;
  }
  else
  {
    Class Class = (Class)classSYDocumentWorkflows;
  }
  return Class;
}

id SYDocumentWorkflowsFunction(void)
{
  return (id)classSYDocumentWorkflows;
}

{
  return (id)classSYDocumentWorkflows;
}

const void **TAutoRef<__CFSet *,TRetainReleasePolicy<__CFSet *>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TAutoRef<__CFDictionary *,TRetainReleasePolicy<__CFDictionary *>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::default_delete<TCFURLIterator>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v4 = (void **)(a2 + 40);
    std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v4);
    TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)(a2 + 32));
    TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)(a2 + 16));
    uint64_t v3 = *(std::__shared_weak_count **)(a2 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    MEMORY[0x1D9436740](a2, 0x1060C40FBA2130BLL);
  }
}

void **TACLRef<_acl *>::~TACLRef(void **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    acl_free(v2);
    *a1 = 0;
  }
  return a1;
}

void FormatDetails<unsigned int,std::string>(long long *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  long long v12 = *a1;
  do
  {
    unint64_t v7 = FormatOneDetails<unsigned int>((const std::string::value_type **)&v12, &__p, a2);
    if (v7)
    {
      *((unsigned char *)&a4->__r_.__value_.__s + 23) = 0;
      a4->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v7) == 7);
  FormatDetails<std::string>(&v12, a3, &v11);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v10 = std::string::insert(&v11, 0, (const std::string::value_type *)p_p, size);
  *a4 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1D34B5D14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t FormatOneDetails<unsigned int>(const std::string::value_type **a1, std::string *this, unsigned int *a3)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1[1];
  if (v3)
  {
    unint64_t v7 = *a1;
    uint64_t v8 = (unsigned __int8 *)&v3[(void)*a1];
    uint64_t v9 = 1;
    uint64_t v10 = (unsigned __int8 *)*a1;
    while (2)
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        if (*v10 == asc_1D3522C21[i])
        {
          uint64_t v12 = 0;
          uint64_t v9 = 1;
          if (v10 != v8)
          {
            unint64_t v13 = v10 - (unsigned __int8 *)v7;
            if (v10 - (unsigned __int8 *)v7 != -1)
            {
              std::string::append(this, v7, v10 - (unsigned __int8 *)v7);
              long long v14 = a1[1];
              BOOL v15 = (unint64_t)v14 >= v13;
              uint64_t v16 = &v14[-v13];
              if (!v15) {
                std::__throw_out_of_range[abi:ne180100]("string_view::substr");
              }
              *a1 += v13;
              a1[1] = v16;
              ParseFormat(a1, (uint64_t)&__src);
              size_t v17 = __len;
              if (__len)
              {
                switch(v67)
                {
                  case 1u:
                    if (__len > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    BOOL v18 = __src;
                    if (__len >= 0x17)
                    {
                      size_t v48 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17) {
                        size_t v48 = __len | 7;
                      }
                      size_t v49 = v48 + 1;
                      p_dst = (std::string *)operator new(v48 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v49 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = __len;
                      p_dst = &__dst;
                    }
                    memmove(p_dst, v18, v17);
                    p_dst->__r_.__value_.__s.__data_[v17] = 0;
                    LODWORD(v50) = *a3;
                    int v35 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
                    std::string::size_type v36 = __dst.__r_.__value_.__r.__words[0];
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      snprintf((char *)__str, 0x64uLL, (const char *)&__dst, (double)v50);
                    }
                    else {
                      snprintf((char *)__str, 0x64uLL, __dst.__r_.__value_.__l.__data_, (double)v50);
                    }
                    std::string::basic_string[abi:ne180100]<0>(&v64, (char *)__str);
                    if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      uint64_t v37 = &v64;
                    }
                    else {
                      uint64_t v37 = (std::string *)v64.__r_.__value_.__r.__words[0];
                    }
                    if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(v64.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = v64.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_100;
                  case 2u:
                    if (__len > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    uint64_t v28 = __src;
                    if (__len >= 0x17)
                    {
                      size_t v52 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17) {
                        size_t v52 = __len | 7;
                      }
                      size_t v53 = v52 + 1;
                      CFStringRef v29 = operator new(v52 + 1);
                      v64.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
                      v64.__r_.__value_.__r.__words[2] = v53 | 0x8000000000000000;
                    }
                    else
                    {
                      *((unsigned char *)&v64.__r_.__value_.__s + 23) = __len;
                      CFStringRef v29 = &v64;
                    }
                    memmove(v29, v28, v17);
                    *((unsigned char *)v29 + v17) = 0;
                    std::to_string(__str, *a3);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int64x2_t v20 = __str;
                    }
                    else {
                      int64x2_t v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    }
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v21 = __str[0].__r_.__value_.__l.__size_;
                    }
                    goto LABEL_113;
                  case 3u:
                    if (__len > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    uint64_t v22 = __src;
                    if (__len >= 0x17)
                    {
                      size_t v32 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17) {
                        size_t v32 = __len | 7;
                      }
                      size_t v33 = v32 + 1;
                      int64x2_t v23 = (std::string *)operator new(v32 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = __len;
                      int64x2_t v23 = &__dst;
                    }
                    memmove(v23, v22, v17);
                    v23->__r_.__value_.__s.__data_[v17] = 0;
                    uint64_t v34 = *a3;
                    int v35 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
                    std::string::size_type v36 = __dst.__r_.__value_.__r.__words[0];
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      snprintf((char *)__str, 0x64uLL, (const char *)&__dst, v34);
                    }
                    else {
                      snprintf((char *)__str, 0x64uLL, __dst.__r_.__value_.__l.__data_, v34);
                    }
                    std::string::basic_string[abi:ne180100]<0>(&v64, (char *)__str);
                    if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      uint64_t v37 = &v64;
                    }
                    else {
                      uint64_t v37 = (std::string *)v64.__r_.__value_.__r.__words[0];
                    }
                    if ((v64.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(v64.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = v64.__r_.__value_.__l.__size_;
                    }
LABEL_100:
                    std::string::append(this, (const std::string::value_type *)v37, size);
                    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v64.__r_.__value_.__l.__data_);
                    }
                    if ((v35 & 0x80000000) == 0) {
                      goto LABEL_136;
                    }
                    uint64_t v51 = (void *)v36;
                    goto LABEL_135;
                  case 4u:
                    if (__len > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    uint64_t v24 = __src;
                    if (__len >= 0x17)
                    {
                      size_t v39 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17) {
                        size_t v39 = __len | 7;
                      }
                      size_t v40 = v39 + 1;
                      uint64_t v25 = operator new(v39 + 1);
                      v64.__r_.__value_.__l.__size_ = v17;
                      v64.__r_.__value_.__r.__words[2] = v40 | 0x8000000000000000;
                      v64.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
                    }
                    else
                    {
                      *((unsigned char *)&v64.__r_.__value_.__s + 23) = __len;
                      uint64_t v25 = &v64;
                    }
                    memmove(v25, v24, v17);
                    *((unsigned char *)v25 + v17) = 0;
                    HexDescriptionPrinterGlue<unsigned int,void>::dump((uint64_t)&v64, a3, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int64x2_t v20 = __str;
                    }
                    else {
                      int64x2_t v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    }
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v21 = __str[0].__r_.__value_.__l.__size_;
                    }
                    goto LABEL_113;
                  case 5u:
                    std::to_string(&v64, *a3);
                    RedactForPrivacy((uint64_t *)&__src, (uint64_t)&v64, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int64x2_t v20 = __str;
                    }
                    else {
                      int64x2_t v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    }
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v21 = __str[0].__r_.__value_.__l.__size_;
                    }
                    goto LABEL_113;
                  case 6u:
                    std::to_string(&v64, *a3);
                    RedactForPrivacy((uint64_t *)&__src, (uint64_t)&v64, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int64x2_t v20 = __str;
                    }
                    else {
                      int64x2_t v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    }
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v21 = __str[0].__r_.__value_.__l.__size_;
                    }
                    goto LABEL_113;
                  case 7u:
                    DeEscapeFormatFragment((uint64_t)&__src, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int v30 = __str;
                    }
                    else {
                      int v30 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    }
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v31 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v31 = __str[0].__r_.__value_.__l.__size_;
                    }
                    std::string::append(this, (const std::string::value_type *)v30, v31);
                    goto LABEL_133;
                  case 8u:
                    if (__len > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    CFStringRef v26 = __src;
                    if (__len >= 0x17)
                    {
                      size_t v41 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17) {
                        size_t v41 = __len | 7;
                      }
                      size_t v42 = v41 + 1;
                      int v27 = operator new(v41 + 1);
                      v64.__r_.__value_.__l.__size_ = v17;
                      v64.__r_.__value_.__r.__words[2] = v42 | 0x8000000000000000;
                      v64.__r_.__value_.__r.__words[0] = (std::string::size_type)v27;
                    }
                    else
                    {
                      *((unsigned char *)&v64.__r_.__value_.__s + 23) = __len;
                      int v27 = &v64;
                    }
                    memmove(v27, v26, v17);
                    *((unsigned char *)v27 + v17) = 0;
                    ExtractEmbeddedFormat(&v64, __str);
                    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v64.__r_.__value_.__l.__data_);
                    }
                    std::string::size_type v43 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    uint64_t v44 = __str;
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    {
                      std::string::size_type v43 = __str[0].__r_.__value_.__l.__size_;
                      uint64_t v44 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    }
                    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
                    __dst.__r_.__value_.__l.__size_ = v43;
                    FormatDetails<unsigned int>((long long *)&__dst, &v64);
                    _NSRange v45 = (void *)__len;
                    if (__len > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    _NSRange v46 = __src;
                    if (__len >= 0x17)
                    {
                      size_t v54 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((__len | 7) != 0x17) {
                        size_t v54 = __len | 7;
                      }
                      size_t v55 = v54 + 1;
                      TString v47 = operator new(v54 + 1);
                      __p[1] = v45;
                      unint64_t v62 = v55 | 0x8000000000000000;
                      __p[0] = v47;
                    }
                    else
                    {
                      HIBYTE(v62) = __len;
                      TString v47 = __p;
                      if (!__len) {
                        goto LABEL_121;
                      }
                    }
                    memmove(v47, v46, (size_t)v45);
LABEL_121:
                    *((unsigned char *)v45 + (void)v47) = 0;
                    ExtendedFormatAdaptor((char *)__p, (uint64_t)&v64, &__dst);
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      unint64_t v56 = &__dst;
                    }
                    else {
                      unint64_t v56 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                    }
                    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v57 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v57 = __dst.__r_.__value_.__l.__size_;
                    }
                    std::string::append(this, (const std::string::value_type *)v56, v57);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
                    if (SHIBYTE(v62) < 0) {
                      operator delete(__p[0]);
                    }
                    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v64.__r_.__value_.__l.__data_);
                    }
LABEL_133:
                    if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0)
                    {
                      uint64_t v51 = (void *)__str[0].__r_.__value_.__r.__words[0];
LABEL_135:
                      operator delete(v51);
                    }
LABEL_136:
                    int v58 = a1[1];
                    CFComparisonResult v59 = &v58[-__len];
                    if ((unint64_t)v58 < __len) {
                      std::__throw_out_of_range[abi:ne180100]("string_view::substr");
                    }
                    uint64_t v9 = 0;
                    *a1 += __len;
                    a1[1] = v59;
                    uint64_t v12 = v67;
                    break;
                  default:
                    std::to_string(&v64, *a3);
                    RedactForPrivacy((uint64_t *)&__src, (uint64_t)&v64, __str);
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int64x2_t v20 = __str;
                    }
                    else {
                      int64x2_t v20 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                    }
                    if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v21 = HIBYTE(__str[0].__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v21 = __str[0].__r_.__value_.__l.__size_;
                    }
LABEL_113:
                    std::string::append(this, (const std::string::value_type *)v20, v21);
                    if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__str[0].__r_.__value_.__l.__data_);
                    }
                    if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_136;
                    }
                    uint64_t v51 = (void *)v64.__r_.__value_.__r.__words[0];
                    goto LABEL_135;
                }
              }
              else
              {
                uint64_t v12 = 0;
                uint64_t v9 = 2;
              }
            }
          }
          return v9 | (v12 << 32);
        }
      }
      if (++v10 != v8) {
        continue;
      }
      break;
    }
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v9 = 1;
  }
  return v9 | (v12 << 32);
}

void sub_1D34B64E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  _Unwind_Resume(exception_object);
}

void FormatDetails<unsigned int>(long long *a1@<X0>, std::string *a2@<X8>)
{
  memset(&v9, 0, sizeof(v9));
  long long v8 = *a1;
  do
  {
    unint64_t v3 = FormatOneDetails<unsigned int>((int)&v8, &v9);
    if (v3)
    {
      *((unsigned char *)&a2->__r_.__value_.__s + 23) = 0;
      a2->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v3) == 7);
  FormatDetails(&v8, &v7);
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v4 = &v9;
  }
  else {
    unint64_t v4 = (std::string *)v9.__r_.__value_.__r.__words[0];
  }
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v9.__r_.__value_.__l.__size_;
  }
  uint64_t v6 = std::string::insert(&v7, 0, (const std::string::value_type *)v4, size);
  *a2 = *v6;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
LABEL_13:
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_1D34B66CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 - 17) < 0) {
    operator delete(*(void **)(v15 - 40));
  }
  _Unwind_Resume(exception_object);
}

void *HexDescriptionPrinterGlue<unsigned int,void>::dump@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  v14[19] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  if (v5)
  {
    WidenHexFormatStringSpecifierToLongLong((char *)a1, (uint64_t)__p);
    if (v9 >= 0) {
      snprintf(__str, 0x64uLL, (const char *)__p, *a2);
    }
    else {
      snprintf(__str, 0x64uLL, (const char *)__p[0], *a2);
    }
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    return std::string::basic_string[abi:ne180100]<0>(a3, __str);
  }
  else
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__str);
    *(_DWORD *)((char *)v12 + *(void *)(v11 - 24)) = *(_DWORD *)((unsigned char *)v12 + *(void *)(v11 - 24)) & 0xFFFFFFB5 | 8;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)"0x", 2);
    std::ostream::operator<<();
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v12, a3);
    *(void *)__str = *MEMORY[0x1E4FBA408];
    uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(void *)&__str[*(void *)(*(void *)__str - 24)] = *(void *)(MEMORY[0x1E4FBA408] + 64);
    uint64_t v11 = v7;
    v12[0] = MEMORY[0x1E4FBA470] + 16;
    if (v13 < 0) {
      operator delete((void *)v12[8]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    return (void *)MEMORY[0x1D94366B0](v14);
  }
}

void sub_1D34B694C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<TCFURLInfo,std::allocator<TCFURLInfo>,TCFURLInfo const&,void>@<X0>(const TCFURLInfo *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = std::__shared_ptr_emplace<TCFURLInfo>::__shared_ptr_emplace[abi:ne180100]<TCFURLInfo const&,std::allocator<TCFURLInfo>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1D34B69B0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TCFURLInfo>::__shared_ptr_emplace[abi:ne180100]<TCFURLInfo const&,std::allocator<TCFURLInfo>,0>(void *a1, const TCFURLInfo *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB0F0;
  TCFURLInfo::TCFURLInfo((TCFURLInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1D34B6A0C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

const void **TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t std::deque<TReservationRecord *>::__maybe_remove_back_spare[abi:ne180100](void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x200) {
    a2 = 1;
  }
  if (v5 < 0x400) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void std::deque<TReservationRecord *>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<TReservationRecord *>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void std::deque<TReservationRecord *>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    char v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v5, v33);
      int v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        size_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)size_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      char v9 = (char *)a1[1];
    }
    unint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    char v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v46);
      int v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      size_t v48 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        unint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      std::string::size_type v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        unint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  unint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  size_t v53 = operator new(0x1000uLL);
  std::__split_buffer<TNodeEventPtr *>::push_back(&v54, &v53);
  int v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)&v54, v27);
  }
  CFStringRef v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1D34B6E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TCFURLInfoList>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB198;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TCFURLInfoList>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB198;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<TCFURLInfoList>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 24);
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void std::__introsort<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = a2 - v10;
    uint64_t v12 = (uint64_t)(a2 - v10) >> 4;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return;
        case 2:
          if (TCFURLInfo::LessThan(*(TCFURLInfo **)(a2 - 16), (TCFURLInfo **)a1))
          {
            uint64_t v44 = *(TCFURLInfo **)a1;
            *(void *)a1 = *(void *)(a2 - 16);
            *(void *)(a2 - 16) = v44;
            uint64_t v45 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = *(void *)(a2 - 8);
            *(void *)(a2 - 8) = v45;
          }
          break;
        case 3:
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a2 - 16);
          break;
        case 4:
          std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a1 + 32, a2 - 16);
          break;
        case 5:
          std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,0>(a1, a1 + 16, a1 + 32, a1 + 48, a2 - 16);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 383) {
      break;
    }
    if (!a3)
    {
      if (a1 == a2) {
        return;
      }
      unint64_t v104 = (void *)a2;
      int64_t v61 = (unint64_t)(v12 - 2) >> 1;
      int64_t v62 = v61;
      do
      {
        int64_t v63 = v62;
        if (v61 >= v62)
        {
          uint64_t v64 = (2 * v62) | 1;
          unint64_t v65 = a1 + 16 * v64;
          if (2 * v62 + 2 < v12 && TCFURLInfo::LessThan(*(TCFURLInfo **)v65, (TCFURLInfo **)(v65 + 16)))
          {
            v65 += 16;
            uint64_t v64 = 2 * v63 + 2;
          }
          unint64_t v66 = a1 + 16 * v63;
          if (!TCFURLInfo::LessThan(*(TCFURLInfo **)v65, (TCFURLInfo **)v66))
          {
            long long v106 = *(_OWORD *)v66;
            *(void *)unint64_t v66 = 0;
            *(void *)(v66 + 8) = 0;
            do
            {
              unint64_t v67 = v65;
              long long v68 = *(_OWORD *)v65;
              *(void *)unint64_t v65 = 0;
              *(void *)(v65 + 8) = 0;
              uint64_t v69 = *(std::__shared_weak_count **)(v66 + 8);
              *(_OWORD *)unint64_t v66 = v68;
              if (v69) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v69);
              }
              if (v61 < v64) {
                break;
              }
              uint64_t v70 = (2 * v64) | 1;
              unint64_t v65 = a1 + 16 * v70;
              uint64_t v64 = 2 * v64 + 2;
              if (v64 < v12)
              {
                if (TCFURLInfo::LessThan(*(TCFURLInfo **)v65, (TCFURLInfo **)(v65 + 16))) {
                  v65 += 16;
                }
                else {
                  uint64_t v64 = v70;
                }
              }
              else
              {
                uint64_t v64 = v70;
              }
              unint64_t v66 = v67;
            }
            while (!TCFURLInfo::LessThan(*(TCFURLInfo **)v65, (TCFURLInfo **)&v106));
            long long v71 = v106;
            long long v106 = 0uLL;
            int v72 = *(std::__shared_weak_count **)(v67 + 8);
            *(_OWORD *)unint64_t v67 = v71;
            if (v72) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v72);
            }
            if (*((void *)&v106 + 1)) {
              std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v106 + 1));
            }
          }
        }
        int64_t v62 = v63 - 1;
      }
      while (v63);
      uint64_t v73 = (unint64_t)v11 >> 4;
      uint64_t v74 = v104;
      while (2)
      {
        uint64_t v75 = 0;
        int v76 = v74;
        int v77 = *(TCFURLInfo **)a1;
        uint64_t v105 = *(void *)(a1 + 8);
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        unint64_t v78 = a1;
        do
        {
          uint64_t v79 = v78 + 16 * v75 + 16;
          uint64_t v80 = 2 * v75;
          uint64_t v75 = (2 * v75) | 1;
          uint64_t v81 = v80 + 2;
          if (v80 + 2 < v73 && TCFURLInfo::LessThan(*(TCFURLInfo **)v79, (TCFURLInfo **)(v79 + 16)))
          {
            v79 += 16;
            uint64_t v75 = v81;
          }
          long long v82 = *(_OWORD *)v79;
          *(void *)uint64_t v79 = 0;
          *(void *)(v79 + 8) = 0;
          unint64_t v83 = *(std::__shared_weak_count **)(v78 + 8);
          *(_OWORD *)unint64_t v78 = v82;
          if (v83) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v83);
          }
          unint64_t v78 = v79;
        }
        while (v75 <= (uint64_t)((unint64_t)(v73 - 2) >> 1));
        v74 -= 2;
        if ((void *)v79 == v76 - 2)
        {
          int v93 = *(std::__shared_weak_count **)(v79 + 8);
          *(void *)uint64_t v79 = v77;
          *(void *)(v79 + 8) = v105;
          if (!v93) {
            goto LABEL_137;
          }
        }
        else
        {
          long long v84 = *((_OWORD *)v76 - 1);
          *uint64_t v74 = 0;
          *(v76 - 1) = 0;
          uint64_t v85 = *(std::__shared_weak_count **)(v79 + 8);
          *(_OWORD *)uint64_t v79 = v84;
          if (v85) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v85);
          }
          uint64_t v86 = (std::__shared_weak_count *)*(v76 - 1);
          *(v76 - 2) = v77;
          *(v76 - 1) = v105;
          if (v86) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v86);
          }
          uint64_t v87 = v79 + 16 - a1;
          if (v87 < 17) {
            goto LABEL_137;
          }
          unint64_t v88 = (((unint64_t)v87 >> 4) - 2) >> 1;
          unint64_t v89 = a1 + 16 * v88;
          if (!TCFURLInfo::LessThan(*(TCFURLInfo **)v89, (TCFURLInfo **)v79)) {
            goto LABEL_137;
          }
          long long v106 = *(_OWORD *)v79;
          *(void *)uint64_t v79 = 0;
          *(void *)(v79 + 8) = 0;
          do
          {
            uint64_t v90 = v89;
            long long v91 = *(_OWORD *)v89;
            *(void *)unint64_t v89 = 0;
            *(void *)(v89 + 8) = 0;
            unint64_t v92 = *(std::__shared_weak_count **)(v79 + 8);
            *(_OWORD *)uint64_t v79 = v91;
            if (v92) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v92);
            }
            if (!v88) {
              break;
            }
            unint64_t v88 = (v88 - 1) >> 1;
            unint64_t v89 = a1 + 16 * v88;
            uint64_t v79 = v90;
          }
          while (TCFURLInfo::LessThan(*(TCFURLInfo **)v89, (TCFURLInfo **)&v106));
          int v93 = *(std::__shared_weak_count **)(v90 + 8);
          *(_OWORD *)uint64_t v90 = v106;
          if (!v93)
          {
LABEL_137:
            if (v73-- <= 2) {
              return;
            }
            continue;
          }
        }
        break;
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v93);
      goto LABEL_137;
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    BOOL v14 = (_OWORD *)(a1 + 16 * ((unint64_t)v12 >> 1));
    if ((unint64_t)v11 < 0x801)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>((uint64_t)v14, a1, a2 - 16);
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, (uint64_t)v14, a2 - 16);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1 + 16, (uint64_t)(v14 - 1), a2 - 32);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1 + 32, a1 + 16 + 16 * v13, a2 - 48);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>((uint64_t)(v14 - 1), (uint64_t)v14, a1 + 16 + 16 * v13);
      long long v15 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *v14;
      *BOOL v14 = v15;
    }
    --a3;
    if ((a4 & 1) != 0 || TCFURLInfo::LessThan(*(TCFURLInfo **)(a1 - 16), (TCFURLInfo **)a1))
    {
      uint64_t v16 = 0;
      long long v106 = *(_OWORD *)a1;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      do
      {
        BOOL v17 = TCFURLInfo::LessThan(*(TCFURLInfo **)(a1 + v16 + 16), (TCFURLInfo **)&v106);
        v16 += 16;
      }
      while (v17);
      unint64_t v18 = a1 + v16;
      uint64_t v19 = (TCFURLInfo **)a2;
      if (v16 == 16)
      {
        uint64_t v19 = (TCFURLInfo **)a2;
        do
        {
          if (v18 >= (unint64_t)v19) {
            break;
          }
          uint64_t v21 = *(v19 - 2);
          v19 -= 2;
        }
        while (!TCFURLInfo::LessThan(v21, (TCFURLInfo **)&v106));
      }
      else
      {
        do
        {
          int64_t v20 = *(v19 - 2);
          v19 -= 2;
        }
        while (!TCFURLInfo::LessThan(v20, (TCFURLInfo **)&v106));
      }
      unint64_t v10 = a1 + v16;
      if (v18 < (unint64_t)v19)
      {
        unint64_t v22 = v19;
        do
        {
          uint64_t v23 = *(TCFURLInfo **)v10;
          *(void *)unint64_t v10 = *v22;
          *unint64_t v22 = v23;
          uint64_t v24 = *(TCFURLInfo **)(v10 + 8);
          *(void *)(v10 + 8) = v22[1];
          v22[1] = v24;
          do
          {
            unint64_t v25 = *(TCFURLInfo **)(v10 + 16);
            v10 += 16;
          }
          while (TCFURLInfo::LessThan(v25, (TCFURLInfo **)&v106));
          do
          {
            uint64_t v26 = *(v22 - 2);
            v22 -= 2;
          }
          while (!TCFURLInfo::LessThan(v26, (TCFURLInfo **)&v106));
        }
        while (v10 < (unint64_t)v22);
      }
      int v27 = (long long *)(v10 - 16);
      if (v10 - 16 != a1)
      {
        long long v28 = *v27;
        *(void *)int v27 = 0;
        *(void *)(v10 - 8) = 0;
        CFStringRef v29 = *(std::__shared_weak_count **)(a1 + 8);
        *(_OWORD *)a1 = v28;
        if (v29) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v29);
        }
      }
      long long v30 = v106;
      long long v106 = 0uLL;
      long long v31 = *(std::__shared_weak_count **)(v10 - 8);
      *(_OWORD *)(v10 - 16) = v30;
      if (v31) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v31);
      }
      if (*((void *)&v106 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v106 + 1));
      }
      if (v18 < (unint64_t)v19) {
        goto LABEL_35;
      }
      BOOL v32 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, v10 - 16);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(v10, a2))
      {
        a2 = v10 - 16;
        if (v32) {
          return;
        }
        goto LABEL_1;
      }
      if (!v32)
      {
LABEL_35:
        std::__introsort<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,false>(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v34 = *(TCFURLInfo **)a1;
      uint64_t v33 = *(void *)(a1 + 8);
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      if (TCFURLInfo::LessThan(v34, (TCFURLInfo **)(a2 - 16)))
      {
        unint64_t v10 = a1;
        do
          v10 += 16;
        while (!TCFURLInfo::LessThan(v34, (TCFURLInfo **)v10));
      }
      else
      {
        int v35 = (TCFURLInfo **)(a1 + 16);
        do
        {
          unint64_t v10 = (unint64_t)v35;
          if ((unint64_t)v35 >= a2) {
            break;
          }
          BOOL v36 = TCFURLInfo::LessThan(v34, v35);
          int v35 = (TCFURLInfo **)(v10 + 16);
        }
        while (!v36);
      }
      unint64_t v37 = a2;
      if (v10 < a2)
      {
        unint64_t v37 = a2;
        do
          v37 -= 16;
        while (TCFURLInfo::LessThan(v34, (TCFURLInfo **)v37));
      }
      while (v10 < v37)
      {
        uint64_t v38 = *(TCFURLInfo **)v10;
        *(void *)unint64_t v10 = *(void *)v37;
        *(void *)unint64_t v37 = v38;
        uint64_t v39 = *(void *)(v10 + 8);
        *(void *)(v10 + 8) = *(void *)(v37 + 8);
        *(void *)(v37 + 8) = v39;
        do
          v10 += 16;
        while (!TCFURLInfo::LessThan(v34, (TCFURLInfo **)v10));
        do
          v37 -= 16;
        while (TCFURLInfo::LessThan(v34, (TCFURLInfo **)v37));
      }
      uint64_t v40 = (long long *)(v10 - 16);
      BOOL v4 = v10 - 16 >= a1;
      BOOL v5 = v10 - 16 == a1;
      if (v10 - 16 != a1)
      {
        long long v41 = *v40;
        *(void *)uint64_t v40 = 0;
        *(void *)(v10 - 8) = 0;
        uint64_t v42 = *(std::__shared_weak_count **)(a1 + 8);
        *(_OWORD *)a1 = v41;
        if (v42) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v42);
        }
      }
      a4 = 0;
      std::string::size_type v43 = *(std::__shared_weak_count **)(v10 - 8);
      *(void *)(v10 - 16) = v34;
      *(void *)(v10 - 8) = v33;
      if (v43)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v43);
        a4 = 0;
      }
    }
  }
  unint64_t v46 = a1 + 16;
  BOOL v48 = a1 == a2 || v46 == a2;
  if (a4)
  {
    if (!v48)
    {
      uint64_t v49 = 0;
      unint64_t v50 = a1;
      do
      {
        unint64_t v51 = v50;
        unint64_t v50 = v46;
        if (TCFURLInfo::LessThan(*(TCFURLInfo **)(v51 + 16), (TCFURLInfo **)v51))
        {
          uint64_t v52 = *(TCFURLInfo **)v50;
          uint64_t v53 = *(void *)(v51 + 24);
          uint64_t v54 = v49;
          *(void *)unint64_t v50 = 0;
          *(void *)(v50 + 8) = 0;
          while (1)
          {
            uint64_t v55 = a1 + v54;
            long long v56 = *(_OWORD *)(a1 + v54);
            *(void *)uint64_t v55 = 0;
            *(void *)(v55 + 8) = 0;
            std::string::size_type v57 = *(std::__shared_weak_count **)(a1 + v54 + 24);
            *(_OWORD *)(v55 + 16) = v56;
            if (v57) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v57);
            }
            if (!v54) {
              break;
            }
            BOOL v58 = TCFURLInfo::LessThan(v52, (TCFURLInfo **)(a1 + v54 - 16));
            v54 -= 16;
            if (!v58)
            {
              CFComparisonResult v59 = (void *)(a1 + v54 + 16);
              goto LABEL_87;
            }
          }
          CFComparisonResult v59 = (void *)a1;
LABEL_87:
          uint64_t v60 = (std::__shared_weak_count *)v59[1];
          *CFComparisonResult v59 = v52;
          v59[1] = v53;
          if (v60) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v60);
          }
        }
        unint64_t v46 = v50 + 16;
        v49 += 16;
      }
      while (v50 + 16 != a2);
    }
  }
  else if (!v48)
  {
    unint64_t v95 = a1 - 16;
    do
    {
      unint64_t v96 = a1;
      a1 = v46;
      if (TCFURLInfo::LessThan(*(TCFURLInfo **)(v96 + 16), (TCFURLInfo **)v96))
      {
        int v97 = *(TCFURLInfo **)a1;
        uint64_t v98 = *(void *)(v96 + 24);
        unint64_t v99 = v95;
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = 0;
        do
        {
          long long v100 = *(_OWORD *)(v99 + 16);
          *(void *)(v99 + 16) = 0;
          *(void *)(v99 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
          uint64_t v101 = *(std::__shared_weak_count **)(v99 + 40);
          *(_OWORD *)(v99 + ++**(_DWORD **)(result + 32) = v100;
          if (v101) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v101);
          }
          BOOL v102 = TCFURLInfo::LessThan(v97, (TCFURLInfo **)v99);
          v99 -= 16;
        }
        while (v102);
        int v103 = *(std::__shared_weak_count **)(v99 + 40);
        *(void *)(v99 + ++**(_DWORD **)(result + 32) = v97;
        *(void *)(v99 + 40) = v98;
        if (v103) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v103);
        }
      }
      unint64_t v46 = a1 + 16;
      v95 += 16;
    }
    while (a1 + 16 != a2);
  }
}

void sub_1D34B77AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a2, a3, a4);
  BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a5, (TCFURLInfo **)a4);
  if (result)
  {
    uint64_t v11 = *(TCFURLInfo **)a4;
    *(void *)a4 = *(void *)a5;
    *(void *)a5 = v11;
    uint64_t v12 = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = *(void *)(a5 + 8);
    *(void *)(a5 + 8) = v12;
    BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a4, (TCFURLInfo **)a3);
    if (result)
    {
      unint64_t v13 = *(TCFURLInfo **)a3;
      *(void *)a3 = *(void *)a4;
      *(void *)a4 = v13;
      uint64_t v14 = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = *(void *)(a4 + 8);
      *(void *)(a4 + 8) = v14;
      BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a3, (TCFURLInfo **)a2);
      if (result)
      {
        long long v15 = *(TCFURLInfo **)a2;
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v15;
        uint64_t v16 = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = *(void *)(a3 + 8);
        *(void *)(a3 + 8) = v16;
        BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a2, (TCFURLInfo **)a1);
        if (result)
        {
          BOOL v17 = *(TCFURLInfo **)a1;
          *(void *)a1 = *(void *)a2;
          *(void *)a2 = v17;
          uint64_t v18 = *(void *)(a1 + 8);
          *(void *)(a1 + 8) = *(void *)(a2 + 8);
          *(void *)(a2 + 8) = v18;
        }
      }
    }
  }
  return result;
}

BOOL std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = TCFURLInfo::LessThan(*(TCFURLInfo **)a2, (TCFURLInfo **)a1);
  BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a3, (TCFURLInfo **)a2);
  if (v6)
  {
    unint64_t v8 = *(TCFURLInfo **)a1;
    if (result)
    {
      *(void *)a1 = *(void *)a3;
      *(void *)a3 = v8;
      char v9 = (uint64_t *)(a3 + 8);
      unint64_t v10 = (uint64_t *)(a1 + 8);
    }
    else
    {
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v8;
      uint64_t v15 = *(void *)(a1 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = v15;
      BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a3, (TCFURLInfo **)a2);
      if (!result) {
        return result;
      }
      uint64_t v16 = *(TCFURLInfo **)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v16;
      char v9 = (uint64_t *)(a3 + 8);
      unint64_t v10 = (uint64_t *)(a2 + 8);
    }
    unint64_t v13 = v9;
    goto LABEL_10;
  }
  if (result)
  {
    uint64_t v11 = *(TCFURLInfo **)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v11;
    unint64_t v13 = (uint64_t *)(a2 + 8);
    uint64_t v12 = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = v12;
    BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a2, (TCFURLInfo **)a1);
    if (result)
    {
      uint64_t v14 = *(TCFURLInfo **)a1;
      *(void *)a1 = *(void *)a2;
      unint64_t v10 = (uint64_t *)(a1 + 8);
      *(void *)a2 = v14;
LABEL_10:
      uint64_t v17 = *v10;
      *unint64_t v10 = *v13;
      *unint64_t v13 = v17;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (TCFURLInfo::LessThan(*(TCFURLInfo **)(a2 - 16), (TCFURLInfo **)a1))
      {
        BOOL v6 = *(TCFURLInfo **)a1;
        *(void *)a1 = *(void *)(a2 - 16);
        *(void *)(a2 - 16) = v6;
        uint64_t v7 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a2 - 16);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*,0>(a1, a1 + 16, a1 + 32, a1 + 48, a2 - 16);
      return 1;
    default:
      unint64_t v8 = (TCFURLInfo **)(a1 + 32);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a1 + 16, a1 + 32);
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    if (TCFURLInfo::LessThan(*(TCFURLInfo **)v9, v8))
    {
      unint64_t v13 = *(TCFURLInfo **)v9;
      uint64_t v12 = *(void *)(v9 + 8);
      uint64_t v14 = v10;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      while (1)
      {
        uint64_t v15 = a1 + v14;
        long long v16 = *(_OWORD *)(a1 + v14 + 32);
        *(void *)(v15 + ++**(_DWORD **)(result + 32) = 0;
        *(void *)(v15 + 40) = 0;
        uint64_t v17 = *(std::__shared_weak_count **)(a1 + v14 + 56);
        *(_OWORD *)(v15 + 48) = v16;
        if (v17) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v17);
        }
        if (v14 == -32) {
          break;
        }
        BOOL v18 = TCFURLInfo::LessThan(v13, (TCFURLInfo **)(a1 + v14 + 16));
        v14 -= 16;
        if (!v18)
        {
          uint64_t v19 = (void *)(a1 + v14 + 48);
          goto LABEL_14;
        }
      }
      uint64_t v19 = (void *)a1;
LABEL_14:
      int64_t v20 = (std::__shared_weak_count *)v19[1];
      void *v19 = v13;
      v19[1] = v12;
      if (v20) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v20);
      }
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    unint64_t v8 = (TCFURLInfo **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2) {
      return 1;
    }
  }
}

void sub_1D34B7C1C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TDeepCFURLIterator::CreateDestinationListForSource(std::shared_ptr<TCFURLInfo> const&)::$_0 &,std::shared_ptr<TCFURLInfo>*>(a1, a2, a3);
  BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a4, (TCFURLInfo **)a3);
  if (result)
  {
    uint64_t v9 = *(TCFURLInfo **)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v9;
    uint64_t v10 = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = v10;
    BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a3, (TCFURLInfo **)a2);
    if (result)
    {
      int v11 = *(TCFURLInfo **)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v11;
      uint64_t v12 = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = v12;
      BOOL result = TCFURLInfo::LessThan(*(TCFURLInfo **)a2, (TCFURLInfo **)a1);
      if (result)
      {
        unint64_t v13 = *(TCFURLInfo **)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v13;
        uint64_t v14 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = v14;
      }
    }
  }
  return result;
}

void sub_1D34B7DA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::function<void ()(void)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(void)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<void ()(void)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void sub_1D34B7EB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::function<void ()(NSDictionary<NSString *,NSObject *> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<void ()(NSDictionary<NSString *,NSObject *> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(NSDictionary<NSString *,NSObject *> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<void ()(NSDictionary<NSString *,NSObject *> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void sub_1D34B8090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::function<void ()(NSDictionary<NSString *,NSObject *> *)>::operator()(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, id *))(*(void *)v3 + 48))(v3, &v4);
}

void sub_1D34B8118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t TKeyValueObserver::TKeyValueObserver(uint64_t a1, uint64_t *a2)
{
  CFTypeRef v3 = (CFTypeRef)*a2;
  *a2 = 0;
  *(void *)a1 = v3;
  id v4 = a2 + 1;
  *(void *)(a1 + 8) = a2[1];
  *(void *)(a1 + 16) = a2[2];
  long long v5 = *(_OWORD *)(a2 + 3);
  a2[3] = 0;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v5;
  a2[4] = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a2 + 4, &stru_1F2ABD380);
  void *v4 = 0;
  v4[1] = 0;
  return a1;
}

void TKeyValueObserver::StartObservingPriv(TKeyValueObserver *this, DS_TKeyValueObserverGlue *a2, NSObject *a3, const TString *a4, uint64_t a5)
{
  uint64_t v12 = a2;
  uint64_t v10 = a3;
  objc_storeStrong((id *)this, a2);
  *((void *)this + 1) = v10;
  int v11 = v10;
  if ((const TString *)((char *)this + 32) != a4)
  {
    TString::SetStringRefAsImmutable((TString *)this + 4, (TString *)a4->fString.fRef);
    int v11 = *((void *)this + 1);
  }
  [v11 addObserver:*(void *)this forKeyPath:*((void *)this + 4) options:a5 context:0];
}

void sub_1D34B82EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void TKeyValueObserver::StopObserving(TKeyValueObserver *this)
{
  unint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    [v2 removeObserver:*(void *)this forKeyPath:*((void *)this + 4)];
    *((void *)this + 1) = 0;
  }
  else
  {
    CFTypeRef v3 = (void *)*((void *)this + 2);
    if (v3)
    {
      [v3 removeObserver:*(void *)this fromObjectsAtIndexes:*((void *)this + 3) forKeyPath:*((void *)this + 4)];
      id v4 = (void *)*((void *)this + 3);
      *((void *)this + 2) = 0;
      *((void *)this + 3) = 0;
    }
  }
  long long v5 = *(void **)this;
  *(void *)this = 0;

  TString::SetStringRefAsImmutable((TString *)this + 4, 0);
}

DS_TKeyValueObserverGlue *TKeyValueObserver::CreateObserver(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v4 = [[DS_TKeyValueObserverGlue alloc] initWithFunctor:a2 observedObjects:a3 observedKeyPath:a4];
  return v4;
}

void *std::__function::__value_func<void ()(void)>::swap[abi:ne180100](void *result, void *a2)
{
  void v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    CFTypeRef v3 = result;
    id v4 = (void *)result[3];
    long long v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        BOOL result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1D34B8644(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::__function::__value_func<void ()(NSDictionary<NSString *,NSObject *> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(NSDictionary<NSString *,NSObject *> *)>::swap[abi:ne180100](void *result, void *a2)
{
  void v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    id v4 = (void *)result[3];
    long long v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        BOOL result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      BOOL result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1D34B8948(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(unsigned char *)(a1 + ++**(_DWORD **)(result + 32) = *(unsigned char *)(a2 + 32);
    *(unsigned char *)(a1 + 4TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = *(unsigned char *)(a2 + 44);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
    std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::hash,void *> *>>((void *)a1, *(void ***)(a2 + 16), 0);
  }
  return a1;
}

void std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::hash,void *> *>>(void *a1, void **a2, uint64_t *a3)
{
  uint64_t v6 = a1[1];
  if (!v6) {
    goto LABEL_9;
  }
  for (uint64_t i = 0; i != v6; *(void *)(*a1 + 8 * i++) = 0)
    ;
  unint64_t v8 = (void *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v8)
  {
    while (a2 != (void **)a3)
    {
      TString v8[2] = a2[2];
      uint64_t v9 = (void *)*v8;
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi(a1, (uint64_t)v8);
      a2 = (void **)*a2;
      unint64_t v8 = v9;
      if (!v9) {
        goto LABEL_9;
      }
    }
    do
    {
      uint64_t v10 = (void *)*v8;
      operator delete(v8);
      unint64_t v8 = v10;
    }
    while (v10);
  }
  else
  {
LABEL_9:
    while (a2 != (void **)a3)
    {
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_multi<NSObject * const&>(a1, a2 + 2);
      a2 = (void **)*a2;
    }
  }
}

void sub_1D34B8A6C(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    unint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1D34B8A8C(_Unwind_Exception *a1)
{
}

uint64_t std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi(void *a1, uint64_t a2)
{
  id v4 = (void **)(a2 + 16);
  unint64_t v5 = [*(id *)(a2 + 16) hash];
  *(void *)(a2 + 8) = v5;
  inserted = std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_prepare((uint64_t)a1, v5, v4);
  std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_perform(a1, (void *)a2, inserted);
  return a2;
}

void *std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, void **a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  float v7 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v8 = *(float *)(a1 + 40);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    BOOL v9 = 1;
    if (v6 >= 3) {
      BOOL v9 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v10 = v9 | (2 * v6);
    unint64_t v11 = vcvtps_u32_f32(v7 / v8);
    if (v10 <= v11) {
      size_t v12 = v11;
    }
    else {
      size_t v12 = v10;
    }
    std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<false>(a1, v12);
    unint64_t v6 = *(void *)(a1 + 8);
  }
  uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v13.i16[0] = vaddlv_u8(v13);
  unint64_t v14 = v13.u32[0];
  if (v13.u32[0] > 1uLL)
  {
    unint64_t v15 = a2;
    if (v6 <= a2) {
      unint64_t v15 = a2 % v6;
    }
  }
  else
  {
    unint64_t v15 = (v6 - 1) & a2;
  }
  long long v16 = *(void **)(*(void *)a1 + 8 * v15);
  if (v16)
  {
    uint64_t v17 = (void *)*v16;
    if (*v16)
    {
      int v18 = 0;
      uint64_t v19 = a1 + 44;
      do
      {
        unint64_t v20 = v17[1];
        if (v14 > 1)
        {
          unint64_t v21 = v17[1];
          if (v20 >= v6) {
            unint64_t v21 = v20 % v6;
          }
        }
        else
        {
          unint64_t v21 = v20 & (v6 - 1);
        }
        if (v21 != v15) {
          break;
        }
        int v22 = v20 == a2 ? std::equal_to<NSObject * {__strong}>::operator()(v19, (void *)v17[2], *a3) : 0;
        if (v18 & (v22 ^ 1)) {
          break;
        }
        v18 |= v22;
        long long v16 = (void *)*v16;
        uint64_t v17 = (void *)*v16;
      }
      while (*v16);
    }
  }
  return v16;
}

void std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__rehash<false>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 40));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__do_rehash<false>(a1, prime);
    }
  }
}

void std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(uint64_t **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      unint64_t v10 = v9.u32[0];
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      for (uint64_t i = *v7; *v7; uint64_t i = *v7)
      {
        unint64_t v13 = *(void *)(i + 8);
        if (v10 > 1)
        {
          if (v13 >= a2) {
            v13 %= a2;
          }
        }
        else
        {
          v13 &= a2 - 1;
        }
        if (v13 == v8)
        {
          uint64_t v7 = (uint64_t *)i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v13))
        {
          unint64_t v14 = *(void **)i;
          unint64_t v15 = (void *)i;
          if (*(void *)i)
          {
            while (1)
            {
              int v16 = std::equal_to<NSObject * {__strong}>::operator()(a1 + 44, *(void **)(i + 16), (void *)v14[2]);
              uint64_t v17 = (void *)*v15;
              if (!v16) {
                break;
              }
              unint64_t v14 = (void *)*v17;
              unint64_t v15 = (void *)*v15;
              if (!*v17) {
                goto LABEL_30;
              }
            }
            unint64_t v14 = (void *)*v15;
            uint64_t v17 = v15;
          }
          else
          {
            uint64_t v17 = (void *)i;
          }
LABEL_30:
          uint64_t *v7 = (uint64_t)v14;
          void *v17 = **(void **)(*(void *)a1 + 8 * v13);
          **(void **)(*(void *)a1 + 8 * v13) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v13) = v7;
          uint64_t v7 = (uint64_t *)i;
          unint64_t v8 = v13;
        }
      }
    }
  }
  else
  {
    unint64_t v11 = *(void **)a1;
    *(void *)a1 = 0;
    if (v11) {
      operator delete(v11);
    }
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__emplace_multi<NSObject * const&>(void *a1, void **a2)
{
  std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__construct_node<NSObject * const&>((uint64_t)a1, a2, (uint64_t)v4);
  return std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__node_insert_multi(a1, v4[0]);
}

void sub_1D34B8F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::__construct_node<NSObject * const&>@<X0>(uint64_t a1@<X0>, void **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 16;
  uint64_t v6 = operator new(0x18uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  void *v6 = 0;
  v6[1] = 0;
  uint64_t v7 = *a2;
  void v6[2] = *a2;
  *(unsigned char *)(a3 + 16) = 1;
  uint64_t result = [v7 hash];
  v6[1] = result;
  return result;
}

void sub_1D34B8FD4(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<NSObject *,std::hash<std::hash>,std::equal_to<std::hash>,std::allocator<std::hash>>::find<std::hash>(void *a1, id *a2)
{
  unint64_t v4 = [*a2 hash];
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  unint64_t v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  unint64_t v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)a1 + 44;
    do
    {
      unint64_t v13 = (unint64_t)v11[1];
      if (v6 == v13)
      {
        if (std::equal_to<NSObject * {__strong}>::operator()(v12, v11[2], *a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }
        else
        {
          v13 &= *(void *)&v5 - 1;
        }
        if (v13 != v9) {
          return 0;
        }
      }
      unint64_t v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  return v11;
}

void *std::__function::__value_func<void ()(NSDictionary<NSString *,NSObject *> *)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void ___Z16IsDatalessDomainP5NSURLb_block_invoke(uint64_t a1, void *a2)
{
}

uint64_t __copy_helper_block_ea8_32c37_ZTSKZ16IsDatalessDomainP5NSURLbE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + ++**(_DWORD **)(result + 32) = *(void *)(a2 + 32);
  return result;
}

BOOL IsDataSeparatedDomainID(const TString *this)
{
  {
    TString::TString(&IsDataSeparatedDomainID(TString const&)::kDataSeparatedDomainIDPrefix, "com.apple.CloudDocs.iCloudDriveFileProviderManaged/", 0x33uLL);
  }
  return TString::BeginsWith((TString *)this, &IsDataSeparatedDomainID(TString const&)::kDataSeparatedDomainIDPrefix);
}

void sub_1D34B920C(_Unwind_Exception *a1)
{
}

BOOL IsMainICloudDriveDomainID(const TString *this)
{
  {
    TString::TString(&IsMainICloudDriveDomainID(TString const&)::kMainICloudDriveProviderID, "com.apple.CloudDocs.iCloudDriveFileProvider/", 0x2CuLL);
  }
  return TString::BeginsWith((TString *)this, &IsMainICloudDriveDomainID(TString const&)::kMainICloudDriveProviderID);
}

void sub_1D34B92A8(_Unwind_Exception *a1)
{
}

BOOL IsICloudDriveDomainID(TString *a1)
{
  if (!ICloudDriveFPFSEnabled()) {
    return 0;
  }
  {
    {
      TString::TString(&IsICloudDriveDomainID(TString const&)::kICloudDriveProviderIDCommonPrefix, "com.apple.CloudDocs.iCloudDriveFileProvider", 0x2BuLL);
    }
  }
  return TString::BeginsWith(a1, &IsICloudDriveDomainID(TString const&)::kICloudDriveProviderIDCommonPrefix);
}

void sub_1D34B9350(_Unwind_Exception *a1)
{
}

uint64_t URLMightBeInFileProvider(uint64_t result)
{
  if (result)
  {
    uint64_t result = UseFileProviderFramework();
    if (result) {
      return FPURLMightBeInFileProvider() != 0;
    }
  }
  return result;
}

id FIProviderDomainForURL(const __CFURL *a1)
{
  id v5 = 0;
  uint64_t v1 = +[FIProviderDomain providerDomainForURL:a1 cachePolicy:1 error:&v5];
  id v2 = v5;
  if ([v1 supportsEnumeration]) {
    id v3 = v1;
  }
  else {
    id v3 = 0;
  }

  return v3;
}

void sub_1D34B943C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IsDefaultFPDomain(FPProviderDomain *a1)
{
  uint64_t v1 = a1;
  id v2 = [(FPProviderDomain *)v1 identifier];
  id v3 = [(FPProviderDomain *)v1 providerID];
  uint64_t v4 = [v2 isEqualToString:v3];

  return v4;
}

void sub_1D34B94B8(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

id FPSharedItemCreator(FPItem *a1)
{
  uint64_t v1 = [(FPItem *)a1 ownerNameComponents];
  return v1;
}

void MyFPResolveSymlink(NSURL *a1@<X0>, uint64_t a2@<X8>)
{
  id v3 = a1;
  uint64_t v4 = FPResolveSymlink();
  id v5 = v4;
  if (v4)
  {
    id v6 = v4;
    int v7 = 0;
  }
  else
  {
    id v6 = 0;
    int v7 = -8064;
  }
  *(void *)a2 = v6;
  *(_DWORD *)(a2 + 8) = v7;
}

void sub_1D34B95A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void FileProviderErrorDomain(TString *a1@<X8>)
{
  id v2 = (TString *)*MEMORY[0x1E4F25C08];
  a1->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, v2);
}

void sub_1D34B9600(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void FileProviderInternalErrorDomain(TString *a1@<X8>)
{
  id v2 = (TString *)*MEMORY[0x1E4F25C50];
  a1->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, v2);
}

void sub_1D34B965C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void FileProviderSharedItemPermissionsReadOnly(TString *a1@<X8>)
{
  id v2 = (TString *)*MEMORY[0x1E4F1C7D8];
  a1->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, v2);
}

void sub_1D34B96B8(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

id FP_ItemDecorationTypeSharing(void)
{
  return (id)*MEMORY[0x1E4F25BB0];
}

BOOL IsDomainDisconnected(FPProviderDomain *a1)
{
  uint64_t v1 = a1;
  id v2 = v1;
  if (v1) {
    BOOL v3 = [(FPProviderDomain *)v1 disconnectionState] != 1;
  }
  else {
    BOOL v3 = 0;
  }

  return v3;
}

void sub_1D34B9724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL FileProviderDomainsHaveEquivalentProperties(FPProviderDomain *a1, FPProviderDomain *a2)
{
  BOOL v3 = a1;
  uint64_t v4 = a2;
  id v5 = v4;
  if (!v3 || !v4)
  {
    BOOL v18 = v3 == v4;
    goto LABEL_17;
  }
  if (![(FPProviderDomain *)v3 isEqual:v4]) {
    goto LABEL_16;
  }
  int v6 = [(FPProviderDomain *)v3 isEnabled];
  if (v6 != [(FPProviderDomain *)v5 isEnabled]) {
    goto LABEL_16;
  }
  int v7 = [(FPProviderDomain *)v3 isHidden];
  if (v7 != [(FPProviderDomain *)v5 isHidden]) {
    goto LABEL_16;
  }
  int v8 = [(FPProviderDomain *)v3 needsAuthentication];
  if (v8 != [(FPProviderDomain *)v5 needsAuthentication]) {
    goto LABEL_16;
  }
  BOOL v9 = IsDomainDisconnected(v3);
  if (v9 != IsDomainDisconnected(v5)) {
    goto LABEL_16;
  }
  int v10 = [(FPProviderDomain *)v3 storageURLsAreInTransientState];
  if (v10 != [(FPProviderDomain *)v5 storageURLsAreInTransientState]) {
    goto LABEL_16;
  }
  unint64_t v11 = [(FPProviderDomain *)v3 domainFullDisplayName];
  uint64_t v12 = [(FPProviderDomain *)v5 domainFullDisplayName];
  if (([v11 isEqual:v12] & 1) == 0)
  {

    goto LABEL_16;
  }
  int v13 = [(FPProviderDomain *)v3 isUsingFPFS];
  int v14 = [(FPProviderDomain *)v5 isUsingFPFS];

  if (v13 != v14) {
    goto LABEL_16;
  }
  if (![(FPProviderDomain *)v3 isUsingFPFS]
    || ([(FPProviderDomain *)v3 storageURLs],
        unint64_t v15 = objc_claimAutoreleasedReturnValue(),
        [(FPProviderDomain *)v5 storageURLs],
        int v16 = objc_claimAutoreleasedReturnValue(),
        char v17 = [v15 isEqual:v16],
        v16,
        v15,
        (v17 & 1) != 0))
  {
    BOOL v18 = 1;
    goto LABEL_17;
  }
  unint64_t v20 = [(FPProviderDomain *)v3 storageURLs];
  uint64_t v21 = [v20 count];
  int v22 = [(FPProviderDomain *)v5 storageURLs];
  uint64_t v23 = [v22 count];

  if (v21 != v23)
  {
LABEL_16:
    BOOL v18 = 0;
    goto LABEL_17;
  }
  BOOL v36 = v5;
  unint64_t v37 = [(FPProviderDomain *)v3 storageURLs];
  int v35 = v36;
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator((uint64_t)&obj, v37);
  IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)v39, -1, v37);
  uint64_t v38 = v35;
  while (obj != v39[0] || v45 != v39[16])
  {
    id v24 = *(id *)(v41[1] + 8 * v44);
    unint64_t v25 = [(FPProviderDomain *)v38 storageURLs];
    id v26 = v24;
    IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator((uint64_t)&v47, v25);
    IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)v46, -1, v25);
    int v27 = v26;
    while (v47 != v46[0] || v52 != v46[16])
    {
      long long v28 = *(id *)(v48[1] + 8 * v51);
      char v29 = IsEqual(v27, v28);

      if (v29)
      {
        char v32 = 1;
        goto LABEL_33;
      }
      uint64_t v30 = v51;
      if (v51 >= v50 - 1)
      {
        uint64_t v31 = [v47 countByEnumeratingWithState:v48 objects:v49 count:4];
        uint64_t v30 = -1;
        uint64_t v50 = v31;
        uint64_t v51 = -1;
      }
      if (v49[4] != *(void *)v48[2])
      {
        objc_enumerationMutation(v47);
        uint64_t v30 = v51;
      }
      uint64_t v51 = v30 + 1;
      ++v52;
    }
    char v32 = 0;
LABEL_33:

    if ((v32 & 1) == 0)
    {
      BOOL v18 = 0;
      goto LABEL_41;
    }
    uint64_t v33 = v44;
    if (v44 >= v43 - 1)
    {
      uint64_t v34 = [obj countByEnumeratingWithState:v41 objects:v42 count:4];
      uint64_t v33 = -1;
      uint64_t v43 = v34;
      uint64_t v44 = -1;
    }
    if (v42[4] != *(void *)v41[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v33 = v44;
    }
    uint64_t v44 = v33 + 1;
    ++v45;
  }
  BOOL v18 = 1;
LABEL_41:

LABEL_17:
  return v18;
}

void sub_1D34B9B90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{
  _Unwind_Resume(a1);
}

id FileMetadataCopyLastUsedDateAtURL()
{
  uint64_t v0 = FPFileMetadataCopyLastUsedDateAtURL();
  return v0;
}

uint64_t TCachedAppLibraryCollections::Singleton(TCachedAppLibraryCollections *this)
{
  {
    operator new();
  }
  return TCachedAppLibraryCollections::Singleton(void)::sCollections;
}

void sub_1D34B9D38(_Unwind_Exception *a1)
{
}

void std::__optional_destruct_base<std::pair<NSString * {__strong},FPItemCollection * {__strong}>,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16))
  {

    *(unsigned char *)(a1 + 16) = 0;
  }
}

id TCachedAppLibraryCollections::CachedCollection(TCachedAppLibraryCollections *this, const TString *a2, int a3)
{
  int v6 = (std::mutex *)((char *)this + 48);
  std::mutex::lock((std::mutex *)((char *)this + 48));
  if (!CFStringGetLength(a2->fString.fRef)) {
    goto LABEL_14;
  }
  BOOL v7 = IsMainICloudDriveDomainID(a2);
  if (!v7 && !IsDataSeparatedDomainID(a2)) {
    goto LABEL_14;
  }
  uint64_t v8 = 24;
  if (v7)
  {
    uint64_t v8 = 0;
    BOOL v9 = this;
  }
  else
  {
    BOOL v9 = (TCachedAppLibraryCollections *)((char *)this + 24);
  }
  if (*((unsigned char *)v9 + 16))
  {
    if (operator==((void **)&a2->fString.fRef, *(void **)((char *)this + v8)))
    {
      int v10 = (void *)*((void *)v9 + 1);
      if (v10)
      {
        id v11 = v10;
        goto LABEL_15;
      }
    }
  }
  std::__optional_destruct_base<std::pair<NSString * {__strong},FPItemCollection * {__strong}>,false>::reset[abi:ne180100]((uint64_t)v9);
  if (!a3) {
    goto LABEL_14;
  }
  uint64_t v12 = [(id)objc_opt_class() defaultManager];
  int v13 = a2->fString.fRef;
  int v14 = [v12 appLibraryCollectionForProviderDomainID:v13];

  if (v14)
  {
    int v16 = a2->fString.fRef;
    id v11 = v14;
    id v17 = v11;
    std::optional<std::pair<NSString * {__strong},FPItemCollection * {__strong}>>::operator=[abi:ne180100]<std::pair<NSString * {__strong},FPItemCollection * {__strong}>,void>((uint64_t)v9, (uint64_t *)&v16);
  }
  else
  {
LABEL_14:
    id v11 = 0;
  }
LABEL_15:
  std::mutex::unlock(v6);
  return v11;
}

void sub_1D34B9EF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  std::mutex::unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::pair<NSString * {__strong},FPItemCollection * {__strong}>>::operator=[abi:ne180100]<std::pair<NSString * {__strong},FPItemCollection * {__strong}>,void>(uint64_t a1, uint64_t *a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 16);
  uint64_t v5 = *a2;
  *a2 = 0;
  if (v4)
  {
    int v6 = *(void **)a1;
    *(void *)a1 = v5;

    uint64_t v7 = a2[1];
    a2[1] = 0;
    uint64_t v8 = *(void **)(a1 + 8);
    *(void *)(a1 + 8) = v7;
  }
  else
  {
    uint64_t v9 = a2[1];
    a2[1] = 0;
    *(void *)a1 = v5;
    *(void *)(a1 + 8) = v9;
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34BA054(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 10TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34BA0D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>,std::tuple<NSString * {__strong},NSString * {__strong}>>::operator*@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  id v4 = *(id *)(a1[2] + 8 * a1[15]);
  id result = *(id *)(a1[19] + 8 * a1[32]);
  *a2 = v4;
  a2[1] = result;
  return result;
}

uint64_t iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::ZipIterator<std::tuple<IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>,std::tuple<NSString * {__strong},NSString * {__strong}>>::operator++(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if (v2 >= *(void *)(a1 + 112) - 1)
  {
    uint64_t v3 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    uint64_t v2 = -1;
    *(void *)(a1 + 112) = v3;
    *(void *)(a1 + 120) = -1;
  }
  if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
  {
    objc_enumerationMutation(*(id *)a1);
    uint64_t v2 = *(void *)(a1 + 120);
  }
  uint64_t v4 = *(void *)(a1 + 128) + 1;
  *(void *)(a1 + 120) = v2 + 1;
  *(void *)(a1 + 128) = v4;
  uint64_t v5 = *(void *)(a1 + 256);
  if (v5 >= *(void *)(a1 + 248) - 1)
  {
    uint64_t v6 = [*(id *)(a1 + 136) countByEnumeratingWithState:a1 + 144 objects:a1 + 208 count:4];
    uint64_t v5 = -1;
    *(void *)(a1 + 248) = v6;
    *(void *)(a1 + 256) = -1;
  }
  if (*(void *)(a1 + 240) != **(void **)(a1 + 160))
  {
    objc_enumerationMutation(*(id *)(a1 + 136));
    uint64_t v5 = *(void *)(a1 + 256);
  }
  uint64_t v7 = *(void *)(a1 + 264) + 1;
  *(void *)(a1 + 256) = v5 + 1;
  *(void *)(a1 + 26TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = v7;
  return a1;
}

void iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::cbegin<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>>(void ***a1@<X0>, uint64_t a2@<X8>)
{
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator((uint64_t)v5, **a1);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator((uint64_t)v4, *a1[1]);
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1EEEEJ26IDContainerIteratorAdaptorI7NSArrayIP8NSStringEES8_EEC2B8ne180100IJLm0ELm1EEJS8_S8_EJEJEJS8_S8_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSC_IJDpT2_EEEDpOT3_((uint64_t)v6, (uint64_t)v5, (uint64_t)v4);
  std::__tuple_impl<std::__tuple_indices<0ul,1ul>,IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>::__tuple_impl(a2, (uint64_t)v6);
}

void sub_1D34BA2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1EEEEJ26IDContainerIteratorAdaptorI7NSArrayIP8NSStringEES8_EEC2B8ne180100IJLm0ELm1EEJS8_S8_EJEJEJS8_S8_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSC_IJDpT2_EEEDpOT3_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(a1, a2);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(v5 + 136, a3);
  return a1;
}

void sub_1D34BA30C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__tuple_impl<std::__tuple_indices<0ul,1ul>,IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>::__tuple_impl(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(a1, a2);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::NSForwardIterator<NSArray<NSString *>>::NSForwardIterator(v4 + 136, a2 + 136);
  return a1;
}

void sub_1D34BA358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void iterator_extras::make_zip_iter_details::ZippedRange<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>,0ul,1ul>::cend<std::tuple<NSArray<NSString *> * {__strong}&,NSArray<NSString *> * {__strong}&>>(void ***a1@<X0>, uint64_t a2@<X8>)
{
  IDContainerIteratorAdaptor<NSArray<NSString *>>::IDContainerIteratorAdaptor((uint64_t)v5, -1, **a1);
  IDContainerIteratorAdaptor<NSArray<NSString *>>::IDContainerIteratorAdaptor((uint64_t)v4, -1, *a1[1]);
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1EEEEJ26IDContainerIteratorAdaptorI7NSArrayIP8NSStringEES8_EEC2B8ne180100IJLm0ELm1EEJS8_S8_EJEJEJS8_S8_EEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSC_IJDpT2_EEEDpOT3_((uint64_t)v6, (uint64_t)v5, (uint64_t)v4);
  std::__tuple_impl<std::__tuple_indices<0ul,1ul>,IDContainerIteratorAdaptor<NSArray<NSString *>>,IDContainerIteratorAdaptor<NSArray<NSString *>>>::__tuple_impl(a2, (uint64_t)v6);
}

void sub_1D34BA408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

uint64_t *TypeForUTI(NSString *a1)
{
  uint64_t v1 = a1;
  int v16 = v1;
  if ([(NSString *)v1 length])
  {
    {
      operator new();
    }
    {
      TypeForUTI(NSString *)::sCacheSpinLocuint64_t k = 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&TypeForUTI(NSString *)::sCacheSpinLock);
    uint64_t v2 = std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::find<NSString * {__strong}>((void *)TypeForUTI(NSString *)::sKnownCache, (id *)&v16);
    if (v2) {
      uint64_t v3 = v2[3];
    }
    else {
      uint64_t v3 = 0;
    }
    uint64_t v4 = v3;
    if (!v4 && TypeForUTI(NSString *)::sRecentDynamicCache)
    {
      uint64_t v5 = std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::find<NSString * {__strong}>((void *)TypeForUTI(NSString *)::sRecentDynamicCache, (id *)&v16);
      if (v5) {
        uint64_t v6 = v5[3];
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t v4 = v6;
    }
    if (!v4 && TypeForUTI(NSString *)::sOldDynamicCache)
    {
      uint64_t v7 = std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::find<NSString * {__strong}>((void *)TypeForUTI(NSString *)::sOldDynamicCache, (id *)&v16);
      if (v7) {
        uint64_t v8 = v7[3];
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v4 = v8;
    }
    if (!v4)
    {
      uint64_t v9 = [MEMORY[0x1E4F442D8] typeWithIdentifier:v16];
      uint64_t v4 = v9;
      if (v9)
      {
        if ([v9 isDynamic])
        {
          uint64_t v10 = TypeForUTI(NSString *)::sRecentDynamicCache;
          if (!TypeForUTI(NSString *)::sRecentDynamicCache) {
            operator new();
          }
          if (*(void *)(TypeForUTI(NSString *)::sRecentDynamicCache + 24) >= 0x3E8uLL)
          {
            block[0] = MEMORY[0x1E4F143A8];
            block[1] = 3321888768;
            block[2] = ___Z10TypeForUTIP8NSString_block_invoke;
            block[3] = &__block_descriptor_33_ea8_32c33_ZTSKZ10TypeForUTIP8NSStringE3__0_e5_v8__0l;
            if (TypeForUTI(NSString *)::__once__ != -1) {
              dispatch_once(&TypeForUTI(NSString *)::__once__, block);
            }
            uint64_t v10 = TypeForUTI(NSString *)::sRecentDynamicCache;
            if (*(void *)(TypeForUTI(NSString *)::sRecentDynamicCache + 24) >= 0x9C4uLL)
            {
              id v11 = (void *)MEMORY[0x1D9436D80]();
              uint64_t v12 = LogObj(5);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)TPropertyValue buf = 0;
                _os_log_impl(&dword_1D343E000, v12, OS_LOG_TYPE_ERROR, "Swapping Dynamic UTType caches.", buf, 2u);
              }

              if (!TypeForUTI(NSString *)::sOldDynamicCache) {
                operator new();
              }
              std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::clear(TypeForUTI(NSString *)::sOldDynamicCache);
              std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::swap(TypeForUTI(NSString *)::sOldDynamicCache, TypeForUTI(NSString *)::sRecentDynamicCache);
              uint64_t v10 = TypeForUTI(NSString *)::sRecentDynamicCache;
            }
          }
          *(void *)TPropertyValue buf = &v16;
          int v13 = (id *)std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>(v10, (id *)&v16, (uint64_t)&std::piecewise_construct, (id **)buf);
        }
        else
        {
          *(void *)TPropertyValue buf = &v16;
          int v13 = (id *)std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>(TypeForUTI(NSString *)::sKnownCache, (id *)&v16, (uint64_t)&std::piecewise_construct, (id **)buf);
        }
        objc_storeStrong(v13 + 3, v4);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&TypeForUTI(NSString *)::sCacheSpinLock);
    uint64_t v1 = v16;
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

void sub_1D34BA7C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<NSString * {__strong},UTType * {__strong}>::unordered_map(uint64_t a1, size_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + ++**(_DWORD **)(result + 32) = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, a2);
  return a1;
}

void sub_1D34BA890(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void ___Z10TypeForUTIP8NSString_block_invoke()
{
  uint64_t v0 = LogObj(5);
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl(&dword_1D343E000, v0, OS_LOG_TYPE_ERROR, "Dynamic UTType cache is larger then expected.", v1, 2u);
  }
}

uint64_t TFSInfo::GetName(TFSInfo *a1, uint64_t a2)
{
  TFSInfo::Name(a1, &v5);
  uint64_t v3 = TPropertyReference::SetAs<TString>(a2, (TString **)&v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1D34BA960(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::ReadOnlyError()
{
  return 4294959235;
}

uint64_t TFSInfo::GetPath(TFSInfo *a1, uint64_t a2)
{
  TFSInfo::Path(a1, (CFTypeRef *)&v5);
  uint64_t v3 = TPropertyReference::SetAs<TString>(a2, &v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5);
  return v3;
}

void sub_1D34BA9C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetType(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 112) == 21) {
    int v2 = 0;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 104);
  }
  int v4 = v2;
  return TPropertyReference::SetAs<unsigned int>(a2, &v4);
}

CFIndex TFSInfo::SetType(uint64_t a1, unint64_t a2)
{
  unsigned int v6 = 0;
  unint64_t v3 = TPropertyReference::As<unsigned int>(a2, &v6);
  unsigned int v4 = v3;
  CFIndex result = HIDWORD(v3);
  if (!result)
  {
    if (*(unsigned char *)(a1 + 112) || *(_DWORD *)(a1 + 104) == v4) {
      return 0;
    }
    else {
      return TFSInfo::SetType((TFSInfo *)a1, v4);
    }
  }
  return result;
}

uint64_t TFSInfo::GetCreator(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 112) == 21) {
    int v2 = 0;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 108);
  }
  int v4 = v2;
  return TPropertyReference::SetAs<unsigned int>(a2, &v4);
}

CFIndex TFSInfo::SetCreator(uint64_t a1, unint64_t a2)
{
  unsigned int v5 = 0;
  unint64_t v3 = TPropertyReference::As<unsigned int>(a2, &v5);
  CFIndex result = HIDWORD(v3);
  if (!HIDWORD(v3))
  {
    if (*(unsigned char *)(a1 + 112) || *(_DWORD *)(a1 + 108) == v3) {
      return 0;
    }
    else {
      return TFSInfo::SetCreator((TFSInfo *)a1, v3);
    }
  }
  return result;
}

uint64_t TFSInfo::GetCreationDate(TFSInfo *a1, uint64_t a2)
{
  double CreationDate = TFSInfo::GetCreationDate(a1);
  return TPropertyReference::SetAs<double>(a2, &CreationDate);
}

CFIndex TFSInfo::SetCreationDate(uint64_t a1, uint64_t *a2)
{
  if (*(unsigned char *)(a1 + 112)) {
    return 4294959224;
  }
  unsigned int v5 = (uint64_t *)0xC1E6CEAF20000000;
  double v4 = COERCE_DOUBLE(TPropertyReference::As<double>(a2, &v5));
  if (TFSInfo::GetCreationDate((TFSInfo *)a1) == v4) {
    return 0;
  }
  else {
    return TFSInfo::SetTimeProperty((TFSInfo *)a1, (const __CFString *)*MEMORY[0x1E4F1D5A0], v4);
  }
}

uint64_t TFSInfo::GetModificationDate(TFSInfo *a1, uint64_t a2)
{
  double ModificationDate = TFSInfo::GetModificationDate(a1);
  return TPropertyReference::SetAs<double>(a2, &ModificationDate);
}

CFIndex TFSInfo::SetModificationDate(TFSInfo *a1, uint64_t *a2)
{
  uint64_t v7 = (uint64_t *)0xC1E6CEAF20000000;
  double v3 = COERCE_DOUBLE(TPropertyReference::As<double>(a2, &v7));
  CFIndex result = v4;
  if (!v4)
  {
    CFAbsoluteTime v6 = v3;
    if (TFSInfo::GetModificationDate(a1) == v3) {
      return 0;
    }
    else {
      return TFSInfo::SetTimeProperty(a1, (const __CFString *)*MEMORY[0x1E4F1D598], v6);
    }
  }
  return result;
}

uint64_t TFSInfo::GetDateAdded(TFSInfo *a1, uint64_t a2)
{
  double DateAddedDate = TFSInfo::GetDateAddedDate(a1);
  return TPropertyReference::SetAs<double>(a2, &DateAddedDate);
}

uint64_t TFSInfo::IsLocked(TFSInfo *a1, uint64_t a2)
{
  char IsLocked = TFSInfo::IsLocked(a1);
  return TPropertyReference::SetAs<BOOL>(a2, &IsLocked);
}

CFIndex TFSInfo::SetIsLocked(TFSInfo *a1, unint64_t a2)
{
  unsigned __int8 v7 = 0;
  unint64_t v3 = TPropertyReference::As<BOOL>(a2, &v7);
  unsigned __int8 v4 = v3;
  CFIndex result = HIDWORD(v3);
  if (!result)
  {
    if (TFSInfo::IsLocked(a1) == v4)
    {
      return 0;
    }
    else
    {
      CFAbsoluteTime v6 = (const __CFString **)MEMORY[0x1E4F1CFC8];
      if (v4) {
        CFAbsoluteTime v6 = (const __CFString **)MEMORY[0x1E4F1CFD0];
      }
      return TFSInfo::SetProperty(a1, (const __CFString *)*MEMORY[0x1E4F1D6E0], *v6);
    }
  }
  return result;
}

uint64_t TFSInfo::IsSystemRestrictionEffective(uint64_t a1, uint64_t a2)
{
  char v3 = 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v3);
}

uint64_t TFSInfo::IsNoUnlinkEffective(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  Booleanint Property = TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)(a1 + 8), (const __CFString *)*MEMORY[0x1E4F1CE50], a3);
  return TPropertyReference::SetAs<BOOL>(a2, &BooleanProperty);
}

uint64_t TFSInfo::IsStationery(TFSInfo *a1, uint64_t a2)
{
  TFSInfo::GetFinderInfo(a1);
  BOOL v5 = (v3 & 0x800) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v5);
}

CFIndex TFSInfo::SetIsStationery(TFSInfo *a1, unint64_t a2)
{
  LOBYTE(v10[0]) = 0;
  unint64_t v3 = TPropertyReference::As<BOOL>(a2, (unsigned __int8 *)v10);
  unsigned __int8 v4 = v3;
  CFIndex result = HIDWORD(v3);
  if (!result)
  {
    int v6 = v4;
    TFSInfo::GetFinderInfo(a1);
    if (((v7 >> 11) & 1) == v6)
    {
      return 0;
    }
    else
    {
      v10[0] = TFSInfo::GetFinderInfo(a1);
      v10[1] = v8 & 0xFFFFFFFFFFFFF7FFLL | ((unint64_t)(v6 != 0) << 11);
      TNodePtr v10[2] = TFSInfo::GetExtendedFinderInfo(a1);
      v10[3] = v9;
      return TFSInfo::SetTotalFinderInfo(a1, (const UInt8 *)v10);
    }
  }
  return result;
}

uint64_t TFSInfo::IsVisible(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  unsigned __int8 v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  char v6 = v3 & 1;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

CFIndex TFSInfo::SetIsVisible(TFSInfo *a1, unint64_t a2)
{
  unsigned __int8 v6 = 0;
  unint64_t v3 = TPropertyReference::As<BOOL>(a2, &v6);
  char v4 = v3;
  CFIndex result = HIDWORD(v3);
  if (!result) {
    return TFSInfo::SetIsInvisible(a1, v4 == 0);
  }
  return result;
}

uint64_t TFSInfo::IsContainer(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  char v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  BOOL v6 = (v3 & 0x20) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::IsAlias(TFSInfo *a1, uint64_t a2)
{
  BOOL IsAlias = TFSInfo::IsAlias(a1);
  return TPropertyReference::SetAs<BOOL>(a2, &IsAlias);
}

uint64_t TFSInfo::GetDataLogicalSize(TFSInfo *a1, uint64_t a2)
{
  uint64_t DataLogicalSize = TFSInfo::GetDataLogicalSize(a1);
  return TPropertyReference::SetAs<long long>(a2, &DataLogicalSize);
}

uint64_t TFSInfo::GetResourceLogicalSize(TFSInfo *a1, uint64_t a2)
{
  uint64_t ResourceLogicalSize = TFSInfo::GetResourceLogicalSize(a1);
  return TPropertyReference::SetAs<long long>(a2, &ResourceLogicalSize);
}

uint64_t TFSInfo::GetDataPhysicalSize(TFSInfo *a1, uint64_t a2)
{
  uint64_t DataPhysicalSize = TFSInfo::GetDataPhysicalSize(a1);
  return TPropertyReference::SetAs<long long>(a2, &DataPhysicalSize);
}

uint64_t TFSInfo::GetResourcePhysicalSize(TFSInfo *a1, uint64_t a2)
{
  uint64_t ResourcePhysicalSize = TFSInfo::GetResourcePhysicalSize(a1);
  return TPropertyReference::SetAs<long long>(a2, &ResourcePhysicalSize);
}

uint64_t TFSInfo::IsSystemCompressed(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  char v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LODWORD(v3) = *(os_unfair_lock_s *)((char *)v3 + 115);
  os_unfair_lock_unlock(v4);
  BOOL v6 = ((unsigned __int16)v3 & 0x200) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::IsVolume(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  char v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = v3[29]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v4);
  char v6 = v3 & 1;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::ObjectIdentifier(TFSInfo *a1, uint64_t a2)
{
  TFSInfo::ObjectIdentifier(a1, &v5);
  uint64_t v3 = TPropertyReference::SetAs<TString>(a2, (TString **)&v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1D34BB288(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetOwner(TFSInfo *a1, uint64_t a2)
{
  int Owner = TFSInfo::GetOwner(a1);
  return TPropertyReference::SetAs<int>(a2, &Owner);
}

uint64_t TFSInfo::SetOwner(uint64_t a1, unint64_t a2)
{
  LODWORD(fileSec) = 0;
  unint64_t v3 = TPropertyReference::As<int>(a2, (unsigned int *)&fileSec);
  unint64_t v4 = HIDWORD(v3);
  if (!HIDWORD(v3))
  {
    if (*(void *)(a1 + 8))
    {
      uid_t v5 = v3;
      char v6 = (__CFFileSecurity *)TFSInfo::CopyPermissions((TFSInfo *)a1);
      CFFileSecurityRef fileSec = v6;
      if (v6 && (uid_t owner = 0, CFFileSecurityGetOwner(v6, &owner), owner != v5) && CFFileSecuritySetOwner(fileSec, v5)) {
        unint64_t v4 = TFSInfo::SetProperty((TFSInfo *)a1, (const __CFString *)*MEMORY[0x1E4F1D638], (const __CFString *)fileSec);
      }
      else {
        unint64_t v4 = 0;
      }
      TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
    }
    else
    {
      return 4294959238;
    }
  }
  return v4;
}

void sub_1D34BB3A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetUserGroups(TFSInfo *a1, uint64_t a2)
{
  int UserGroups = TFSInfo::GetUserGroups(a1);
  return TPropertyReference::SetAs<int>(a2, &UserGroups);
}

uint64_t TFSInfo::SetUserGroups(uint64_t a1, unint64_t a2)
{
  LODWORD(fileSec) = 0;
  unint64_t v3 = TPropertyReference::As<int>(a2, (unsigned int *)&fileSec);
  unint64_t v4 = HIDWORD(v3);
  if (!HIDWORD(v3))
  {
    if (*(void *)(a1 + 8))
    {
      gid_t v5 = v3;
      char v6 = (__CFFileSecurity *)TFSInfo::CopyPermissions((TFSInfo *)a1);
      CFFileSecurityRef fileSec = v6;
      if (v6 && (uid_t owner = 0, CFFileSecurityGetOwner(v6, &owner), owner != v5) && CFFileSecuritySetGroup(fileSec, v5)) {
        unint64_t v4 = TFSInfo::SetProperty((TFSInfo *)a1, (const __CFString *)*MEMORY[0x1E4F1D638], (const __CFString *)fileSec);
      }
      else {
        unint64_t v4 = 0;
      }
      TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
    }
    else
    {
      return 4294959238;
    }
  }
  return v4;
}

void sub_1D34BB4B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetMode(TFSInfo *a1, uint64_t a2)
{
  __int16 Mode = TFSInfo::GetMode(a1);
  return TPropertyReference::SetAs<short>(a2, &Mode);
}

CFIndex TFSInfo::SetMode(TFSInfo *a1, unint64_t a2)
{
  unsigned __int16 v6 = 0;
  unint64_t v3 = TPropertyReference::As<short>(a2, &v6);
  unint64_t v4 = HIDWORD(v3);
  if (!HIDWORD(v3)) {
    return TFSInfo::SetModeDetails(a1, v3);
  }
  return v4;
}

uint64_t TFSInfo::GetUserAccess(TFSInfo *a1, uint64_t a2)
{
  __int16 UserAccess = TFSInfo::GetUserAccess(a1);
  return TPropertyReference::SetAs<short>(a2, &UserAccess);
}

uint64_t TFSInfo::IsExtensionHidden(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  BOOL v6 = (v3 & 8) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

unint64_t TFSInfo::SetIsExtensionHidden(uint64_t a1, unint64_t a2)
{
  unsigned __int8 v8 = 0;
  unint64_t v3 = TPropertyReference::As<BOOL>(a2, &v8);
  unint64_t v4 = HIDWORD(v3);
  if (!HIDWORD(v3))
  {
    int v5 = v3;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
    unsigned int v6 = *(unsigned __int8 *)(a1 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
    if (((v6 >> 3) & 1) != v5) {
      TFSInfo::SetIsExtensionHidden((TFSInfo *)a1, v5 != 0);
    }
  }
  return v4;
}

uint64_t TFSInfo::CanSetExtensionHidden(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  uint32_t v5 = *(uint32_t *)((char *)&v3[28]._os_unfair_lock_opaque + 3);
  unint64_t v3 = (os_unfair_lock_s *)((char *)v3 + 115);
  unint64_t v6 = v5 | ((unint64_t)LOWORD(v3[1]._os_unfair_lock_opaque) << 32) | 0x80000000000;
  v3->_uint32_t os_unfair_lock_opaque = v5;
  LOWORD(v3[1]._os_unfair_lock_opaque) = WORD2(v6);
  os_unfair_lock_unlock(v4);
  os_unfair_lock_lock(v4);
  LOBYTE(v3) = v3->_os_unfair_lock_opaque;
  os_unfair_lock_unlock(v4);
  BOOL v8 = (v3 & 0x10) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v8);
}

uint64_t TFSInfo::IsPackage(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  BOOL v6 = (v3 & 2) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::IsApplication(os_unfair_lock_s *a1, uint64_t a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOBYTE(v3) = HIBYTE(v3[28]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v4);
  BOOL v6 = (v3 & 4) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::GetApplicationDMFPolicy(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 112)
    && *(void *)(a1 + 8)
    && (os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100)),
        int v6 = *(_DWORD *)(a1 + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100)),
        (v6 & 4) != 0))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    if (*(char *)(a1 + 113) == -1)
    {
      *(unsigned char *)(a1 + 113) = 0;
      uint64_t v3 = 4294959210;
    }
    else
    {
      __int16 v8 = *(char *)(a1 + 113);
      uint64_t v3 = TPropertyReference::SetAs<short>(a2, &v8);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }
  else
  {
    __int16 v7 = 0;
    return TPropertyReference::SetAs<short>(a2, &v7);
  }
  return v3;
}

void sub_1D34BB89C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetIFSymbol(TFSInfo *a1, uint64_t a2)
{
  TFSInfo::FetchIFSymbol(a1);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v3 = TPropertyReference::SetAs<IFSymbol * {__strong}>(a2, &v5);

  return v3;
}

void sub_1D34BB900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SupportsFileSharing()
{
  return 4294959245;
}

uint64_t TFSInfo::SupportsScreenSharing()
{
  return 4294959245;
}

uint64_t TFSInfo::IsMountedSharepoint()
{
  return 4294959245;
}

uint64_t TFSInfo::GetSortingGroup()
{
  return 4294959245;
}

uint64_t TFSInfo::GetNetworkConnectionState()
{
  return 4294959245;
}

uint64_t TFSInfo::GetServerUserName()
{
  return 4294959245;
}

uint64_t TFSInfo::GetNetworkComment()
{
  return 4294959245;
}

uint64_t TFSInfo::GetContact()
{
  return 4294959245;
}

uint64_t TFSInfo::GetCapacity(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  int v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v6);
  if (!*a3) {
    return 4294959245;
  }
  uint64_t Capacity = TFSVolumeInfo::GetCapacity(*a3);
  uint64_t result = TPropertyReference::SetAs<long long>(a2, &Capacity);
  if (!result)
  {
    if (TFSVolumeInfo::SpaceAndCapacityAreUpToDate(*a3, 0)) {
      return 0;
    }
    else {
      return 4294959210;
    }
  }
  return result;
}

uint64_t TFSInfo::GetFreeSpace(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  int v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v6);
  if (!*a3) {
    return 4294959245;
  }
  uint64_t FreeSpace = TFSVolumeInfo::GetFreeSpace(*a3);
  uint64_t v9 = FreeSpace + TFSVolumeInfo::GetReclaimableSpace(*a3);
  if (v9 < 0) {
    uint64_t v9 = TFSVolumeInfo::GetFreeSpace(*a3);
  }
  uint64_t result = TPropertyReference::SetAs<long long>(a2, &v9);
  if (!result)
  {
    if (TFSVolumeInfo::SpaceAndCapacityAreUpToDate(*a3, 1)) {
      return 0;
    }
    else {
      return 4294959210;
    }
  }
  return result;
}

uint64_t TFSInfo::GetReclaimableSpace(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  int v6 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v6);
  if (!*a3) {
    return 4294959245;
  }
  uint64_t ReclaimableSpace = TFSVolumeInfo::GetReclaimableSpace(*a3);
  uint64_t result = TPropertyReference::SetAs<long long>(a2, &ReclaimableSpace);
  if (!result)
  {
    if (TFSVolumeInfo::SpaceAndCapacityAreUpToDate(*a3, 1)) {
      return 0;
    }
    else {
      return 4294959210;
    }
  }
  return result;
}

uint64_t TFSInfo::GetVolumeFormat(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  if (!*a3) {
    return 4294959245;
  }
  __int16 VolumeFormat = TFSVolumeInfo::GetVolumeFormat(*a3);
  return TPropertyReference::SetAs<short>(a2, &VolumeFormat);
}

uint64_t TFSInfo::GetVolumeFormatString(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  if (!*a3) {
    return 4294959245;
  }
  TFSVolumeInfo::GetVolumeFormatString(*a3, &v6);
  uint64_t v4 = TPropertyReference::SetAs<TString>(a2, (TString **)&v6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return v4;
}

void sub_1D34BBBE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetSystemBuildVersion(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  if (!*a3) {
    return 4294959245;
  }
  uint64_t v4 = (TString **)TFSVolumeInfo::SystemBuildVersion(*a3);
  return TPropertyReference::SetAs<TString>(a2, v4);
}

uint64_t TFSInfo::GetAboutToUnmount(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  if (!*a3) {
    return 4294959245;
  }
  if (*(unsigned char *)(v3 + 123)) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = *(unsigned char *)(v3 + 128) != 0;
  }
  BOOL v6 = v4;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::GetVolUUID(uint64_t a1, uint64_t a2, TFSVolumeInfo **a3)
{
  if (!*a3) {
    return 4294959245;
  }
  TFSVolumeInfo::GetUUID(*a3, &v6);
  uint64_t v4 = TPropertyReference::SetAs<TString>(a2, (TString **)&v6);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return v4;
}

void sub_1D34BBD00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetShortVersion(uint64_t a1, uint64_t a2)
{
  TString v6 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  uint64_t ShortVersion = TFSInfo::GetShortVersion(a1, (const void **)&v6);
  if (!ShortVersion) {
    uint64_t ShortVersion = TPropertyReference::SetAs<TString>(a2, (TString **)&v6);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6);
  return ShortVersion;
}

void sub_1D34BBD90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetLongVersion(uint64_t a1, uint64_t a2)
{
  v6.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  uint64_t LongVersion = TFSInfo::GetLongVersion(a1, &v6);
  if (!LongVersion) {
    uint64_t LongVersion = TPropertyReference::SetAs<TString>(a2, (TString **)&v6);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return LongVersion;
}

void sub_1D34BBE24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetSystemVersion(uint64_t a1, uint64_t a2)
{
  v6.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  uint64_t SystemVersion = TFSInfo::GetSystemVersion(a1, &v6);
  if (!SystemVersion) {
    uint64_t SystemVersion = TPropertyReference::SetAs<TString>(a2, (TString **)&v6);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return SystemVersion;
}

void sub_1D34BBEB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetCopyrightString(uint64_t a1, uint64_t a2)
{
  v6.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  uint64_t CopyrightString = TFSInfo::GetCopyrightString(a1, &v6);
  if (!CopyrightString) {
    uint64_t CopyrightString = TPropertyReference::SetAs<TString>(a2, (TString **)&v6);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);
  return CopyrightString;
}

void sub_1D34BBF4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetKindWithoutPlatformString(TFSInfo *a1, uint64_t a2, uint64_t a3, char a4, unsigned char *a5)
{
  v13.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  uint64_t KindWithoutPlatform = TFSInfo::GetKindWithoutPlatform(a1, &v13, a4, a5);
  uint64_t v10 = KindWithoutPlatform;
  if (KindWithoutPlatform && KindWithoutPlatform != -8086
    || (uint64_t v11 = TPropertyReference::SetAs<TString>(a2, (TString **)&v13), !v11))
  {
    uint64_t v11 = v10;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
  return v11;
}

void sub_1D34BBFFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetTypeIdentifierString(TFSInfo *a1, uint64_t a2, uint64_t a3, char a4, unsigned char *a5)
{
  id location = 0;
  UTint Type = TFSInfo::GetUTType(a1, &location, a4, a5);
  uint64_t v7 = UTType;
  if (UTType != -8086 && UTType != 0)
  {
    id v11 = location;
LABEL_7:
    uint64_t v10 = v7;
    goto LABEL_8;
  }
  id v11 = location;
  uint64_t v9 = [location identifier];
  CFTypeRef v13 = v9;
  uint64_t v10 = TPropertyReference::SetAs<__CFString const*>(a2, &v13);

  if (!v10) {
    goto LABEL_7;
  }
LABEL_8:

  return v10;
}

void sub_1D34BC0B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetUTType(TFSInfo *a1, uint64_t a2, uint64_t a3, char a4, unsigned char *a5)
{
  id location = 0;
  UTint Type = TFSInfo::GetUTType(a1, &location, a4, a5);
  uint64_t v7 = UTType;
  if (UTType && UTType != -8086
    || (uint64_t v8 = TPropertyReference::SetAs<UTType * {__strong}>(a2, &location), !v8))
  {
    uint64_t v8 = v7;
  }

  return v8;
}

void sub_1D34BC14C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetPhysicalSize(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v4);
  uint64_t PhysicalSize = TFSInfo::GetPhysicalSize((TFSInfo *)a1);
  TPropertyReference::SetAs<long long>(a2, &PhysicalSize);
  os_unfair_lock_lock(v4);
  LODWORD(a2) = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  if ((a2 & 0x2000000) == 0
    && ((os_unfair_lock_lock(v4), int v5 = *(_DWORD *)(a1 + 115), os_unfair_lock_unlock(v4), (v5 & 0x10000000) != 0)
     || *(unsigned char *)(a1 + 112) == 7))
  {
    return 0;
  }
  else
  {
    return 4294959210;
  }
}

uint64_t TFSInfo::GetLogicalSize(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  *(_DWORD *)(a1 + 115) |= 0x8000000u;
  os_unfair_lock_unlock(v4);
  uint64_t LogicalSize = TFSInfo::GetLogicalSize((TFSInfo *)a1);
  TPropertyReference::SetAs<long long>(a2, &LogicalSize);
  os_unfair_lock_lock(v4);
  LODWORD(a2) = *(_DWORD *)(a1 + 115);
  os_unfair_lock_unlock(v4);
  if ((a2 & 0x2000000) == 0
    && ((os_unfair_lock_lock(v4), int v5 = *(_DWORD *)(a1 + 115), os_unfair_lock_unlock(v4), (v5 & 0x10000000) != 0)
     || *(unsigned char *)(a1 + 112) == 7))
  {
    return 0;
  }
  else
  {
    return 4294959210;
  }
}

uint64_t TFSInfo::GetDeepItemCount(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  int v5 = *(uint32_t *)((char *)&v3[28]._os_unfair_lock_opaque + 3);
  uint64_t v3 = (os_unfair_lock_s *)((char *)v3 + 115);
  v3->_uint32_t os_unfair_lock_opaque = v5 | 0x8000000;
  os_unfair_lock_unlock(v4);
  TString v6 = (os_unfair_lock_s *)((char *)v3 - 19);
  os_unfair_lock_lock((os_unfair_lock_s *)((char *)v3 - 19));
  uint64_t v7 = *(os_unfair_lock_s **)((char *)&v3[-9]._os_unfair_lock_opaque + 1);
  if (v7)
  {
    TFSInfoOverflow::FolderSizeRecord(v7, (uint64_t)v10);
    if (v11) {
      uint64_t v8 = v10[2];
    }
    else {
      uint64_t v8 = -1;
    }
  }
  else
  {
    uint64_t v8 = -1;
  }
  os_unfair_lock_unlock(v6);
  v10[0] = v8;
  return TPropertyReference::SetAs<long long>(a2, v10);
}

void sub_1D34BC394(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetDeepVisibleItemCount(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  int v5 = *(uint32_t *)((char *)&v3[28]._os_unfair_lock_opaque + 3);
  uint64_t v3 = (os_unfair_lock_s *)((char *)v3 + 115);
  v3->_uint32_t os_unfair_lock_opaque = v5 | 0x8000000;
  os_unfair_lock_unlock(v4);
  TString v6 = (os_unfair_lock_s *)((char *)v3 - 19);
  os_unfair_lock_lock((os_unfair_lock_s *)((char *)v3 - 19));
  uint64_t v7 = *(os_unfair_lock_s **)((char *)&v3[-9]._os_unfair_lock_opaque + 1);
  if (v7)
  {
    TFSInfoOverflow::FolderSizeRecord(v7, (uint64_t)v10);
    if (v11) {
      uint64_t v8 = v10[3];
    }
    else {
      uint64_t v8 = -1;
    }
  }
  else
  {
    uint64_t v8 = -1;
  }
  os_unfair_lock_unlock(v6);
  v10[0] = v8;
  return TPropertyReference::SetAs<long long>(a2, v10);
}

void sub_1D34BC448(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetLastUsedDate(uint64_t a1, uint64_t a2, uint64_t a3, char a4, unsigned char *a5)
{
  id v9 = *(id *)(a1 + 72);
  uint64_t v10 = *(void **)(a1 + 72);
  if (v10) {
    goto LABEL_2;
  }
  if ((a4 & 0x82) != 0)
  {
    uint64_t v12 = 4294959222;
  }
  else
  {
    uint64_t v16 = TFSInfo::LastUsedDate((TFSInfo *)a1);
    id v17 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = v16;

    uint64_t v10 = *(void **)(a1 + 72);
    if (v10)
    {
LABEL_2:
      int v11 = 0;
      uint64_t v12 = 0;
      goto LABEL_6;
    }
    uint64_t v12 = 0;
  }
  uint64_t v10 = [MEMORY[0x1E4F1C9C8] distantPast];
  int v11 = 1;
LABEL_6:
  id v13 = v10;
  double v18 = MEMORY[0x1D9435A50]();
  TPropertyReference::SetAs<double>(a2, &v18);

  if (v11) {
  if (*(void *)(a1 + 72))
  }
    char v14 = objc_msgSend(v9, "isEqualToDate:") ^ 1;
  else {
    char v14 = 0;
  }
  *a5 = v14;

  return v12;
}

void sub_1D34BC568(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetTagsAndAttributes(uint64_t a1, uint64_t a2, uint64_t a3, char a4, unsigned char *a5)
{
  uint64_t v16 = TFSInfo::CopyTagsAndAttributes((TFSInfo *)a1, 0);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  uint64_t v9 = *(unsigned __int16 *)(a1 + 119);
  uint64_t v10 = *(unsigned int *)(a1 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
  unint64_t v15 = TFSInfo::CopyTagsAndAttributes((TFSInfo *)a1, (a4 & 0x82) == 0);
  id v17 = v15;
  unsigned int v11 = TPropertyReference::SetAs<__CFArray const*>(a2, (CFTypeRef *)&v17);
  BOOL v12 = (a4 & 0x82) != 0 && v11 == 0;
  if (v12) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = v11;
  }
  if (v12 && ((v10 | (v9 << 32)) & 0x40000000000) == 0)
  {
    if (*(unsigned char *)(a1 + 112) == 7) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = 4294959222;
    }
  }
  *a5 = IsEqual(v16, v15) ^ 1;
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&v15);
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)&v16);
  return v13;
}

void sub_1D34BC67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TAutoRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetTagsAndAttributes(TFSInfo *a1, uint64_t *a2)
{
  TString v6 = 0;
  TPropertyReference::As<__CFArray const*>(a2, &v6);
  uint64_t v4 = v3;
  if (!v3) {
    TFSInfo::GetLabel(a1);
  }
  return v4;
}

uint64_t TFSInfo::GetUbiquityStatus(TFSInfo *a1, uint64_t a2)
{
  int BladeRunnerFlags = TFSInfo::GetBladeRunnerFlags(a1);
  uint64_t v5 = BladeRunnerFlags & 0x7FFFFFFF;
  LODWORD(result) = TPropertyReference::SetAs<long long>(a2, &v5);
  if (result) {
    return result;
  }
  else {
    return (BladeRunnerFlags >> 31) & 0xFFFFE06A;
  }
}

uint64_t TFSInfo::GetDownloadedState(TFSInfo *a1, uint64_t a2)
{
  char v4 = TFSInfo::GetBladeRunnerFlags(a1) & 1;
  return TPropertyReference::SetAs<BOOL>(a2, &v4);
}

uint64_t TFSInfo::GetUbiquityFault(uint64_t a1, uint64_t a2)
{
  char v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  unint64_t v5 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x400000000) != 0
    || (TCFURLInfo::GetNumericalProperty(*(const __CFURL **)(a1 + 8), (const __CFString *)*MEMORY[0x1E4F1CDC8], v6) & 0x40000000) != 0)
  {
    char v7 = 1;
  }
  else
  {
    char v7 = TFSInfo::GetBladeRunnerFlags((TFSInfo *)a1) & 1;
  }
  char v9 = v7;
  return TPropertyReference::SetAs<BOOL>(a2, &v9);
}

uint64_t TFSInfo::GetICloudSharePerson(TFSInfo *a1, uint64_t a2)
{
  TFSInfo::CopyICloudSharePerson(a1);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v3 = TPropertyReference::SetAs<NSPersonNameComponents * {__strong}>(a2, &v5);

  return v3;
}

void sub_1D34BC868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetICloudSharePersonString(uint64_t a1, uint64_t a2)
{
  UseFileProviderFramework();
  TString::TString(&v5, "", 0);
  uint64_t v3 = TPropertyReference::SetAs<TString>(a2, (TString **)&v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1D34BC8D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetICloudLastEditor(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v3 = a1 + 24;
  os_unfair_lock_lock(a1 + 24);
  os_unfair_lock_unlock(v3);
  id v6 = 0;
  uint64_t v4 = TPropertyReference::SetAs<NSPersonNameComponents * {__strong}>(a2, &v6);

  return v4;
}

void sub_1D34BC948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetSLHighlight()
{
  return 4294967246;
}

uint64_t TFSInfo::GetSLHighlightID()
{
  return 4294967246;
}

uint64_t TFSInfo::GetOriginatorInfo(uint64_t a1, uint64_t a2, uint64_t a3, char a4, unsigned char *a5)
{
  id v29 = 0;
  if (ReturnToSenderEnabled())
  {
    TFSInfo::OriginatorInfo((TFSInfo *)a1);
    id v29 = (id)objc_claimAutoreleasedReturnValue();
    char v9 = (os_unfair_lock_s *)(a1 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
    uint64_t v10 = *(const void **)(a1 + 16);
    uint64_t v28 = (uint64_t)v10;
    if (v10)
    {
      CFRetain(v10);
      unsigned int v11 = (void *)v28;
    }
    else
    {
      unsigned int v11 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
    id v13 = v11;
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v28);
    if (!v13)
    {
      TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a2, &v29);
LABEL_24:
      uint64_t v12 = 0;
LABEL_25:

      goto LABEL_26;
    }
    if (a4 < 0)
    {
      *a5 = 0;
      TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a2, &v29);
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
      unint64_t v21 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32);
      os_unfair_lock_unlock(v9);
      if ((v21 & 0x200000000000) != 0) {
        uint64_t v12 = 0;
      }
      else {
        uint64_t v12 = 4294959210;
      }
      goto LABEL_25;
    }
    uint64_t v28 = [(id)getSYDocumentAttributesClass() documentAttributesForFileAtURL:v13];
    TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a2, (id *)&v28);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
    uint64_t v14 = *(unsigned int *)(a1 + 115);
    unint64_t v15 = v14 | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32) | 0x200000000000;
    *(_DWORD *)(a1 + 115) = v14;
    *(_WORD *)(a1 + 119) = WORD2(v15);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 100));
    int v16 = v29 == 0;
    id v17 = (void *)v28;
    int v18 = v28 == 0;
    *a5 = v16 ^ v18;
    if (v16 == v18)
    {
LABEL_23:

      goto LABEL_24;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    if (v28 && !*(void *)(a1 + 80)) {
      TFSInfo::GetOrCreateOverflow((TFSInfo *)a1);
    }
    unint64_t v19 = *(void *)(a1 + 80);
    if (!v19)
    {
LABEL_22:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
      id v17 = (void *)v28;
      goto LABEL_23;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 72));
    int v20 = *(unsigned __int8 *)(v19 + 76);
    if (v20 == 3)
    {
      *(unsigned char *)(v19 + 76) = 2;
      *(void *)unint64_t v19 = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 72));
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 72));
      if (v20 != 2)
      {
        unint64_t v26 = TFSInfoOverflow::ICloud(*(void *)(a1 + 80), 0);
        if (!v27) {
          goto LABEL_22;
        }
        int v22 = (void *)v28;
        unint64_t v19 = v26 + 16;
        goto LABEL_21;
      }
    }
    int v22 = (void *)v28;
LABEL_21:
    id v23 = v22;
    id v24 = *(void **)v19;
    *(void *)unint64_t v19 = v23;

    goto LABEL_22;
  }
  TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(a2, &v29);
  uint64_t v12 = 0;
LABEL_26:

  return v12;
}

void sub_1D34BCBB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10)
{
  os_unfair_lock_unlock(v11);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetIsTopLevelSharedItem(TFSInfo *a1, uint64_t a2)
{
  char IsTopLevelSharedItem = TFSInfo::IsTopLevelSharedItem(a1);
  return TPropertyReference::SetAs<BOOL>(a2, &IsTopLevelSharedItem);
}

uint64_t TFSInfo::GetItemDecorations(TFSInfo *a1, uint64_t a2)
{
  uint64_t v3 = TFSInfo::GetFPItem(a1);
  uint64_t v4 = [v3 itemDecorations];
  CFTypeRef v7 = v4;
  uint64_t v5 = TPropertyReference::SetAs<__CFArray const*>(a2, &v7);

  return v5;
}

void sub_1D34BCCB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetOldViewStyle(TFSInfo *a1, uint64_t a2)
{
  __int16 OldViewStyle = TFSInfo::GetOldViewStyle(a1);
  return TPropertyReference::SetAs<short>(a2, &OldViewStyle);
}

uint64_t TFSInfo::GetOldLocation(TFSInfo *a1, uint64_t a2)
{
  int OldLocation = TFSInfo::GetOldLocation(a1);
  return TPropertyReference::SetAs<Point>(a2, &OldLocation);
}

uint64_t TFSInfo::GetOldIconOrigin(TFSInfo *a1, uint64_t a2)
{
  int OldIconOrigin = TFSInfo::GetOldIconOrigin(a1);
  return TPropertyReference::SetAs<Point>(a2, &OldIconOrigin);
}

uint64_t TFSInfo::GetFlatItemCount(TFSInfo *a1, uint64_t a2, const __CFString *a3, unsigned int a4)
{
  FlatItemCFIndex Count = TFSInfo::GetFlatItemCount(a1, (a4 >> 2) & 1, a3);
  return TPropertyReference::SetAs<long long>(a2, &FlatItemCount);
}

uint64_t TFSInfo::GetResumableCopy(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = a1 + 25;
  os_unfair_lock_lock(a1 + 25);
  LOWORD(v3) = *(_WORD *)((char *)&v3[29]._os_unfair_lock_opaque + 3);
  os_unfair_lock_unlock(v4);
  BOOL v6 = ((unsigned __int16)v3 & 0x1000) != 0;
  return TPropertyReference::SetAs<BOOL>(a2, &v6);
}

uint64_t TFSInfo::SetProperty(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!GetPropertyRecord(a2, (uint64_t)v12)) {
    return 4294959245;
  }
  char v9 = v13;
  uint64_t v10 = (void *)(a1 + (v14 >> 1));
  if (v14) {
    char v9 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*v10 + v13);
  }
  return v9(v10, a3, a4, a5);
}

void TFSInfo::ObjectIdentifier(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v4 = *((unsigned __int8 *)this + 112);
  if (v4 == 28)
  {
    TFSInfo::GetFPItem(this);
    id v11 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v5 = [v11 itemID];
    BOOL v6 = [v5 identifier];
    CFTypeRef v7 = [MEMORY[0x1E4F28B88] URLHostAllowedCharacterSet];
    uint64_t v8 = [v6 stringByAddingPercentEncodingWithAllowedCharacters:v7];
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, v8);
  }
  else
  {
    if (v4 != 27)
    {
      uint64_t ObjectIdentifier = TFSInfo::GetObjectIdentifier(this);
      uint64_t VolumeIdentifier = TFSInfo::GetVolumeIdentifier(this);
      snprintf(__str, 0x100uLL, "%llu.%llu", VolumeIdentifier, ObjectIdentifier);
      TString::TString(a2, __str);
      return;
    }
    TFSInfo::GetFPItem(this);
    id v11 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v5 = [v11 providerDomainID];
    BOOL v6 = [MEMORY[0x1E4F28B88] URLHostAllowedCharacterSet];
    CFTypeRef v7 = [v5 stringByAddingPercentEncodingWithAllowedCharacters:v6];
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, v7);
  }
}

void sub_1D34BD0CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
}

CFIndex TFSInfo::Initialize(TFSInfo *this, FPItem *a2, int a3)
{
  uint64_t v5 = a2;
  BOOL v6 = v5;
  if (!a3)
  {
    *((unsigned char *)this + 112) = 28;
    unint64_t v12 = *(_DWORD *)((char *)this + 115) & 0xF9FFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
    *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xF9FFFFFF | 0x4000000;
    *(_WORD *)((char *)this + 119) = WORD2(v12);
    TFSInfo::SetFPItem(this, v5);
    TFSInfo::FetchProperties(this, 0);
    CFIndex v8 = 0;
    goto LABEL_8;
  }
  CFTypeRef v7 = CopyURLForFPItem(v5, 0);
  unint64_t v15 = v7;
  if (!v7)
  {
    CFIndex v8 = 4294967253;
    goto LABEL_7;
  }
  CFIndex v8 = TFSInfo::initialize((uint64_t)this, (const __CFURL *)v7, 0, 1, 1, 1, 0);
  if (v8)
  {
LABEL_7:
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v15);
    goto LABEL_8;
  }
  *(_DWORD *)((char *)this + 115) |= 0x40003821u;
  char v9 = [(FPItem *)v6 documentSize];
  unint64_t v10 = *(_DWORD *)((char *)this + 115) & 0xEFFFFFFF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xEFFFFFFF | ((v9 != 0) << 28);
  *(_WORD *)((char *)this + 119) = WORD2(v10);

  id v11 = [(FPItem *)v6 displayName];
  v14.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v14, v11);
  TFSInfo::SetItemName(this, &v14);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14.fString.fRef);

  *((unsigned char *)this + 112) = 25;
  TFSInfo::SetFPItem(this, v6);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v15);
  CFIndex v8 = 0;
LABEL_8:

  return v8;
}

void sub_1D34BD350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

const void *CopyURLForFPItem(FPItem *a1, int a2)
{
  uint64_t v3 = a1;
  if (!v3) {
    goto LABEL_11;
  }
  int v4 = FPItemManagerInstance();

  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = [(FPItem *)v3 fileURL];

  if (v5)
  {
    BOOL v6 = [(FPItem *)v3 fileURL];
    CFTypeRef v7 = static_cf_cast<__CFString const*,void const*>(v6);
    goto LABEL_12;
  }
  if (!a2)
  {
LABEL_11:
    CFTypeRef v7 = 0;
    goto LABEL_12;
  }
  CFIndex v8 = (std::__shared_weak_count *)operator new(0x20uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB4E0;
  v8[1].__vftable = 0;
  dispatch_semaphore_t v9 = dispatch_semaphore_create(0);
  unint64_t v10 = FPItemManagerInstance();
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3321888768;
  void v17[2] = ___Z16CopyURLForFPItemP6FPItemb_block_invoke;
  v17[3] = &__block_descriptor_72_ea8_32c38_ZTSKZ16CopyURLForFPItemP6FPItembE3__0_e27_v24__0__NSURL_8__NSError_16l;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v15 = v9;
  int v16 = v3;
  void v17[4] = v8 + 1;
  int v18 = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  id v11 = v15;
  unint64_t v19 = v11;
  unint64_t v12 = v16;
  int v20 = v12;
  char v21 = a2;
  [v10 fetchURLForItem:v12 creatingPlaceholderIfMissing:1 completionHandler:v17];

  std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  dispatch_time_t v13 = dispatch_time(0, 1000000000);
  CFTypeRef v7 = 0;
  if (!dispatch_semaphore_wait(v11, v13)) {
    CFTypeRef v7 = static_cf_cast<__CFString const*,void const*>(v8[1].__vftable);
  }

  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }

  std::__shared_weak_count::__release_shared[abi:ne180100](v8);
LABEL_12:

  return v7;
}

void sub_1D34BD5B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  CopyURLForFPItem(FPItem *,BOOL)::$_0::~$_0(a10);

  std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  _Unwind_Resume(a1);
}

void TFSInfoOverflow::TFSInfoOverflow(TFSInfoOverflow *this, const TFSInfoOverflow *a2)
{
  *((void *)this + 7) = 0;
  int v4 = (char *)this + 56;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = *((void *)a2 + 6);
  *((void *)this + 8) = *((id *)a2 + 8);
  *((_DWORD *)v4 + TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0;
  v4[20] = 3;
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 18);
  int v5 = *((unsigned __int8 *)a2 + 76);
  v4[20] = v5;
  if (*((void *)a2 + 5)) {
    operator new();
  }
  switch(v5)
  {
    case 2:
      *(void *)this = *(id *)a2;
      break;
    case 1:
      *(void *)this = *(id *)a2;
      *((void *)this + 1) = *((id *)a2 + 1);
      *((void *)this + 2) = *((id *)a2 + 2);
      *((void *)this + 3) = *((id *)a2 + 3);
      *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
      break;
    case 0:
      if (*(void *)a2)
      {
        std::allocate_shared[abi:ne180100]<TNWNode,std::allocator<TNWNode>,TNWNode&,void>(*(void *)a2, this);
      }
      else
      {
        *(void *)this = 0;
        *((void *)this + 1) = 0;
      }
      break;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 18);
}

void sub_1D34BD760(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);

  std::unique_ptr<TFileDescriptor>::reset[abi:ne180100](v3, 0);
  uint64_t v5 = *(void *)(v1 + 40);
  *(void *)(v1 + 40) = 0;
  if (v5) {
    MEMORY[0x1D9436740](v5, 0x1000C40E0EAB150);
  }
  _Unwind_Resume(a1);
}

void TFSInfoOverflow::MigrateToType(uint64_t a1, int a2)
{
  if (a2 == 1 && *(unsigned char *)(a1 + 76) == 2)
  {
    id v3 = *(id *)a1;

    *(unsigned char *)(a1 + 76) = 1;
    *(void *)(a1 + ++**(_DWORD **)(result + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + ++**(_DWORD **)(result + 32) = 0x80000000;
    int v4 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = v3;
  }
}

uint64_t TFSInfo::TFSInfo(uint64_t a1, os_unfair_lock_s **a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, char a9)
{
  TString __dst[128] = *(TString *)MEMORY[0x1E4F143B8];
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 6TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + ++**(_DWORD **)(result + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  TFSInfo::TFSInfo((TFSInfo *)a1);
  TString::TString(__dst, a4);
  TFSInfo::SetItemName((TFSInfo *)a1, __dst);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&__dst[0].fString.fRef);
  FileSuffix((const TString *)(a1 + 24), (TString *)&theString);
  if (a8)
  {
    if (CFStringGetLength(theString))
    {
      TString::TString(__dst, a4);
      TFSInfo::Initialize((TFSInfo *)a1, *a2, __dst);
LABEL_17:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&__dst[0].fString.fRef);
      goto LABEL_18;
    }
    int v14 = 32;
    int v15 = 20480;
  }
  else
  {
    int v14 = 0;
    int v15 = 4096;
  }
  int v16 = (unsigned int *)(a1 + 115);
  if (a9) {
    int v17 = 100664384;
  }
  else {
    int v17 = 100664320;
  }
  unsigned int v18 = v17 | v14 | *(_DWORD *)(a1 + 115) & 0xF9FFFB9F;
  unsigned int *v16 = v18;
  unsigned int *v16 = v15 | (*a4 != 46) | v18 & 0xFFFF8FFE;
  strlcpy((char *)__dst, a3, 0x400uLL);
  strlcat((char *)__dst, a4, 0x400uLL);
  CFIndex v19 = strlen((const char *)__dst);
  CFURLRef v23 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)__dst, v19, a8);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a1 + 8), v23);
  if (*(void *)(a1 + 8)) {
    _CFURLCacheSetAutoFlushingEnabled();
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v23);
  if (!*(void *)(a1 + 8))
  {
    TString::TString(__dst, a4);
    TFSInfo::Initialize((TFSInfo *)a1, *a2, __dst);
    goto LABEL_17;
  }
  uint64_t v20 = _CFURLCopyFileURL();
  char v21 = *(const void **)(a1 + 16);
  if (v21) {
    CFRelease(v21);
  }
  *(void *)(a1 + 16) = v20;
  if (strchr(a4, 58))
  {
    ColonsToSlashes((const TString *)(a1 + 24), __dst);
    TFSInfo::SetDisplayName((TFSInfo *)a1, __dst);
    goto LABEL_17;
  }
LABEL_18:
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return a1;
}

void sub_1D34BDA80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TFSInfo::~TFSInfo(v3);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsRootItem(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0 || *((unsigned char *)this + 112)) {
    return 0;
  }
  BOOL v6 = (TCFURLInfo *)*((void *)this + 1);
  CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1CEB8];
  return TCFURLInfo::GetBooleanProperty(v6, v7, v4);
}

uint64_t TFSInfo::TFSInfo(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v24 = a3;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + ++**(_DWORD **)(result + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 6TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  TFSInfo::TFSInfo((TFSInfo *)a1);
  *(unsigned char *)(v5 + 112) = a2;
  *(_DWORD *)(v5 + 115) |= 0x40000000u;
  std::allocate_shared[abi:ne180100]<TNWNode,std::allocator<TNWNode>,__SFNode *&,void>(&v24, &v22);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  uint64_t Overflow = TFSInfo::GetOrCreateOverflow((TFSInfo *)a1);
  CFStringRef v7 = (os_unfair_lock_s *)(Overflow + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(Overflow + 72));
  int v8 = *(unsigned __int8 *)(Overflow + 76);
  if (v8 == 3)
  {
    int v8 = 0;
    *(unsigned char *)(Overflow + 76) = 0;
    *(void *)uint64_t Overflow = 0;
    *(void *)(Overflow + 8) = 0;
  }
  unint64_t v9 = Overflow & 0xFFFFFFFFFFFFFF00;
  uint64_t v10 = Overflow & 0xF8;
  os_unfair_lock_unlock(v7);
  if (v8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v10;
  }
  unint64_t v12 = (void *)(v11 | v9);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  uint64_t v14 = v22;
  dispatch_time_t v13 = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v15 = (std::__shared_weak_count *)v12[1];
  *unint64_t v12 = v14;
  v12[1] = v13;
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  int v16 = (TString *)SFNodeCopyDisplayName();
  char v21 = v16;
  uint64_t v17 = 32;
  if ((*(_WORD *)(*v12 + 57) & 0x80) == 0) {
    uint64_t v17 = 133120;
  }
  unint64_t v18 = *(unsigned int *)(a1 + 115) | ((unint64_t)*(unsigned __int16 *)(a1 + 119) << 32) | v17;
  *(_DWORD *)(a1 + 115) = v18;
  if ((*(unsigned char *)(*v12 + 57) & 8) != 0)
  {
    *(_WORD *)(a1 + 119) = WORD2(v18);
    *(_DWORD *)(a1 + 115) = v18 | 0x20;
  }
  v20.fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(&v20, v16);
  TFSInfo::SetItemName((TFSInfo *)a1, &v20);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
  *(_DWORD *)(a1 + 115) |= 1u;
  TFSInfo::SetIfVirtualAlias((TFSInfo *)a1);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v21);
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v23);
  }
  return a1;
}

void sub_1D34BDDB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, const void *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef(&a11);
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  TFSInfo::~TFSInfo(v13);
  _Unwind_Resume(a1);
}

const void **TFSInfo::CopyFSInfo@<X0>(TFSInfo *this@<X0>, uint64_t *a2@<X8>)
{
  CFStringRef v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x2000000) == 0) {
    return (const void **)std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,TFSInfo const&,void>(this, a2);
  }
  os_unfair_lock_lock(v4);
  CFURLRef v7 = (const __CFURL *)*((void *)this + 2);
  CFURLRef v8 = v7;
  if (v7) {
    CFRetain(v7);
  }
  os_unfair_lock_unlock(v4);
  _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(a2);
  TFSInfo::initialize(*a2, v8, 1, 0, 1, 1, 0);
  return TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v8);
}

void sub_1D34BDED0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IterationInfoPropertyKeys(TFSInfo *this)
{
  if (TFSInfo::IterationInfoPropertyKeys(void)::once != -1) {
    dispatch_once(&TFSInfo::IterationInfoPropertyKeys(void)::once, &__block_literal_global_32);
  }
  return TFSInfo::IterationInfoPropertyKeys(void)::basicKeys;
}

const void **TFSInfo::ActualSuffix@<X0>(TFSInfo *this@<X0>, TString *a2@<X8>)
{
  TFSInfo::Name(this, &v5);
  int v3 = [(__CFString *)v5.fString.fRef pathExtension];
  a2->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, v3);

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
}

void sub_1D34BDFCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void DecorationIdentifier(void *a1@<X0>, TString *a2@<X8>)
{
  id v4 = a1;
  if (objc_opt_respondsToSelector())
  {
    objc_cast<NSString,objc_object * {__strong}>((void *)[v4 performSelector:sel_identifier]);
    int v3 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    a2->fString.uint64_t fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, v3);
  }
  else
  {
    TString::TString(a2, "", 0);
  }
}

void sub_1D34BE154(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v10);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::FetchApplicationDMFPolicy(TFSInfo *this)
{
  if (!*((void *)this + 2)) {
    return 0;
  }
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 4) == 0) {
    return 0;
  }
  CFURLRef v9 = CFURLCreateFilePathURL(0, *((CFURLRef *)this + 2), 0);
  Numericalint Property = TCFURLInfo::GetNumericalProperty(v9, (const __CFString *)*MEMORY[0x1E4F1CD40], v5);
  CFURLRef v7 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  *((unsigned char *)this + 113) = NumericalProperty;
  uint64_t v4 = NumericalProperty;
  os_unfair_lock_unlock(v7);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v9);
  return v4;
}

void sub_1D34BE240(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::FetchFPItemProperties(TFSInfo *this)
{
  TFSInfo::GetFPItem(this);
  int v2 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
  int v3 = v2;
  if (!v2)
  {
    uint64_t v10 = 4294959224;
    goto LABEL_25;
  }
  uint64_t v4 = [(TFSInfo *)v2 filename];
  CFTypeRef cf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf, v4);

  TFSInfo::SetItemName(this, (const TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);

  CFStringRef v5 = [(TFSInfo *)v3 displayName];
  CFTypeRef cf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf, v5);

  TFSInfo::SetDisplayName(this, (const TString *)&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);

  uint64_t v6 = [(TFSInfo *)v3 contentType];
  CFURLRef v7 = (void *)*((void *)this + 5);
  *((void *)this + 5) = v6;

  KindWithoutPlatformFromUTType(*((UTType **)this + 5), (TString *)&cf);
  if ((CFTypeRef *)((char *)this + 48) != &cf)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)this + 6, &cf);
    CFRetain(&stru_1F2ABD380);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = &stru_1F2ABD380;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  unsigned int v8 = [(TFSInfo *)v3 fileSystemFlags];
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFE | ((v8 & 8) == 0);
  if ([(TFSInfo *)v3 isFolder])
  {
    unint64_t v9 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  }
  else
  {
    int v11 = [(TFSInfo *)v3 isPackage];
    unint64_t v9 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
    if (!v11)
    {
      int v12 = 0;
      goto LABEL_12;
    }
  }
  int v12 = 32;
LABEL_12:
  *(_WORD *)((char *)this + 119) = WORD2(v9);
  *(_DWORD *)((char *)this + 115) = v9 & 0xFFFFFFDF | v12;
  int v13 = [(TFSInfo *)v3 isPackage];
  int v14 = 2;
  if (!v13) {
    int v14 = 0;
  }
  unint64_t v15 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFD | v14;
  *(_WORD *)((char *)this + 119) = WORD2(v15);
  int v16 = [*((id *)this + 5) conformsToType:*MEMORY[0x1E4F44528]];
  int v17 = 256;
  if (!v16) {
    int v17 = 0;
  }
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFF7AFF | v17 & 0xFFFFFBFF | (((*(_DWORD *)((char *)this + 115) >> 5) & 1) << 10);
  int v18 = [*((id *)this + 5) conformsToType:*MEMORY[0x1E4F444D8]];
  int v19 = 64;
  if (!v18) {
    int v19 = 0;
  }
  unint64_t v20 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFBF | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  *(_DWORD *)((char *)this + 115) = *(_DWORD *)((char *)this + 115) & 0xFFFFFFBF | v19;
  *(_WORD *)((char *)this + 119) = WORD2(v20);
  int v21 = [*((id *)this + 5) conformsToType:*MEMORY[0x1E4F44318]];
  unint64_t v23 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  uint64_t v24 = 4;
  if (!v21) {
    uint64_t v24 = 0;
  }
  unint64_t v25 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFFB | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32) | v24;
  *(_DWORD *)((char *)this + 115) = v25;
  *(_WORD *)((char *)this + 119) = (v23 & 0xFFFFFFFFFFFFFFFBLL) >> 32;
  if ((v23 & 0x40) != 0
    || (int v26 = [*((id *)this + 5) conformsToType:*MEMORY[0x1E4F44308]],
        unint64_t v25 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32),
        v26))
  {
    int v27 = 2048;
  }
  else
  {
    int v27 = 0;
  }
  *(_WORD *)((char *)this + 119) = WORD2(v25);
  *(_DWORD *)((char *)this + 115) = v25 & 0xFFFFF7FF | v27;
  *((void *)this + 13) = 0;
  unsigned int v28 = *(_DWORD *)((char *)this + 115) & 0xFFFFFFE7 | (v8 >> 1) & 8 | ~(TFSInfo::FPItemPermissionRestrictions(v3, v22) >> 13) & 0x10;
  *(_WORD *)((char *)this + 119) = *(_WORD *)((char *)this + 119);
  *(_DWORD *)((char *)this + 115) = v28;
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  *(_WORD *)((char *)this + 119) |= 0x800u;
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  unsigned int v29 = *(_DWORD *)((char *)this + 115) & 0xFFFF8FFF | (v8 << 11) & 0x3000 | ((v8 & 1) << 14);
  *(_WORD *)((char *)this + 119) = *(_WORD *)((char *)this + 119);
  *(_DWORD *)((char *)this + 115) = v29;
  TFSInfo::FetchBladeRunnerProperties(this, v30, v31);
  uint64_t v10 = 0;
LABEL_25:

  return v10;
}

void sub_1D34BE628(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void KindWithoutPlatformFromUTType(UTType *a1@<X0>, TString *a2@<X8>)
{
  uint64_t v6 = a1;
  a2->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  int v3 = [(UTType *)v6 _kindString];
  uint64_t v4 = v3;
  if (v3)
  {
    CFStringRef v5 = v3;
    if ((TString *)a2->fString.fRef != v5) {
      TString::SetStringRefAsImmutable(a2, v5);
    }
  }
  else
  {
    CFStringRef v5 = [(UTType *)v6 localizedDescription];
    if ((TString *)a2->fString.fRef != v5) {
      TString::SetStringRefAsImmutable(a2, v5);
    }
  }
}

void sub_1D34BE758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v10);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetHasLSProperties(TFSInfo *this, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unsigned int v6 = *(_DWORD *)((char *)this + 115);
  CFStringRef v5 = (char *)this + 115;
  unint64_t v7 = v6 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  uint64_t v8 = (v7 >> 30) & 1;
  int v9 = 0x40000000;
  if (!a2) {
    int v9 = 0;
  }
  unint64_t v10 = v7 & 0xFFFFFFFFBFFFFFFFLL;
  *(_DWORD *)CFStringRef v5 = v10 | v9;
  *((_WORD *)v5 + 2) = WORD2(v10);
  os_unfair_lock_unlock(v4);
  return v8;
}

uint64_t TFSInfo::GetAliasInfoFrom(TFSInfo *this, BOOL *a2, BOOL *a3, TString *a4, TString *a5)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (TFSInfo::IsAlias(this))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    int v10 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v10 & 0x40) == 0)
    {
      if (TFSInfo::GetAliasInfoFrom(BOOL &,BOOL &,TString *,TString *)const::once != -1) {
        dispatch_once(&TFSInfo::GetAliasInfoFrom(BOOL &,BOOL &,TString *,TString *)const::once, &__block_literal_global_119);
      }
      CFURLRef URL = TFSInfo::MakeURL(this);
      *(void *)uint64_t v44 = URL;
      if (!URL) {
        goto LABEL_26;
      }
      int v12 = URL;
      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
      unint64_t v13 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      if ((v13 & 0x400000000) != 0)
      {
        uint64_t v38 = 0;
      }
      else
      {
        int v14 = (const void *)MEMORY[0x1D9435EE0](0, v12, 0);
        uint64_t v38 = v14;
        if (v14)
        {
          unint64_t v15 = (__CFString *)MEMORY[0x1D9435F40](0, *MEMORY[0x1E4F1D678], v14);
          v43.fString.uint64_t fRef = v15;
          if (v15)
          {
            CFTypeID v16 = CFGetTypeID(v15);
            if (v16 == CFBooleanGetTypeID())
            {
              int v17 = IsEqual(v43.fString.fRef, (const void *)*MEMORY[0x1E4F1CFD0]);
              *a3 = v17;
              TFSInfo::SetAliasIsContainer(this, v17);
            }
          }
          int v18 = (void *)MEMORY[0x1D9435F40](0, *MEMORY[0x1E4F1D6E8], v38);
          unint64_t v37 = v18;
          if (v18)
          {
            CFTypeID v19 = CFGetTypeID(v18);
            if (v19 == CFBooleanGetTypeID()) {
              *a2 = IsEqual(v37, (const void *)*MEMORY[0x1E4F1CFD0]);
            }
          }
          unint64_t v20 = (__CFString *)MEMORY[0x1D9435F40](0, *MEMORY[0x1E4F1D568], v38);
          BOOL v36 = v20;
          if (v20)
          {
            CFTypeID v21 = CFGetTypeID(v20);
            CFTypeID TypeID = CFStringGetTypeID();
            if (a4)
            {
              if (v21 == TypeID && a4->fString.fRef != v36) {
                TString::SetStringRefAsImmutable(a4, (TString *)v36);
              }
            }
          }
          unint64_t v23 = (__CFString *)MEMORY[0x1D9435F40](0, *MEMORY[0x1E4F1D738], v38);
          int v35 = v23;
          if (v23)
          {
            CFTypeID v24 = CFGetTypeID(v23);
            CFTypeID v25 = CFStringGetTypeID();
            if (a5)
            {
              if (v24 == v25)
              {
                if (a5->fString.fRef != v35) {
                  TString::SetStringRefAsImmutable(a5, (TString *)v35);
                }
                BOOL v26 = TString::EndsWith(a5, (const TString *)TFSInfo::GetAliasInfoFrom(BOOL &,BOOL &,TString *,TString *)const::burnFolderExtension);
                TFSInfo::SetAliasIsBurnFolder(this, v26);
              }
            }
          }
          TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)&v35);
          TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)&v36);
          TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)&v37);
          TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef((const void **)&v43.fString.fRef);
          TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v38);
LABEL_26:
          TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)v44);
          return 0;
        }
      }
      TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v38);
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)v44);
      return 4294959232;
    }
    TFSInfo::Path(this, (CFTypeRef *)&v43.fString.fRef);
    unsigned int v28 = (const char *)TString::c_str(&v43);
    if (readlink(v28, v44, 0x400uLL) == -1)
    {
      char v32 = __error();
      uint64_t v27 = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v32, 0, v33);
    }
    else
    {
      *a2 = 0;
      *a3 = 1;
      if (a4 && &v43 != a4) {
        TString::SetStringRefAsImmutable(a4, (TString *)v43.fString.fRef);
      }
      if (!a5) {
        goto LABEL_40;
      }
      TPathName::TPathName((TPathName *)&v38, &v43, TPathName::kPOSIXPathNameSeparator);
      if (v40 != v39)
      {
        unsigned int v29 = (void *)(v39 + 8 * ((v41 + v42) >> 9));
        uint64_t v30 = (v41 + v42) & 0x1FF;
        uint64_t v31 = *v29 + 8 * v30;
        if (v31 != *(void *)(v39 + ((v41 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v41 & 0x1FF))
        {
          if (!v30) {
            uint64_t v31 = *(v29 - 1) + 4096;
          }
          if ((TString *)(v31 - 8) != a5) {
            TString::SetStringRefAsImmutable(a5, *(TString **)(v31 - 8));
          }
          std::deque<TString>::~deque[abi:ne180100](&v38);
LABEL_40:
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v43.fString.fRef);
          return 0;
        }
      }
      std::deque<TString>::~deque[abi:ne180100](&v38);
      uint64_t v27 = 4294959234;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v43.fString.fRef);
    return v27;
  }
  return 4294959226;
}

void sub_1D34BEC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  std::deque<TString>::~deque[abi:ne180100]((uint64_t *)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetIsResumableCopyTarget(TFSInfo *this, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unsigned int v6 = *(_DWORD *)((char *)this + 115);
  uint64_t v5 = (char *)this + 115;
  uint64_t v7 = *((unsigned __int16 *)v5 + 2);
  unint64_t v8 = v6 | (unint64_t)(v7 << 32);
  uint64_t v9 = (v7 >> 12) & 1;
  __int16 v10 = 4096;
  if (!a2) {
    __int16 v10 = 0;
  }
  unint64_t v11 = v8 & 0xFFFFEFFFFFFFFFFFLL;
  *(_DWORD *)uint64_t v5 = v11;
  *((_WORD *)v5 + 2) = WORD2(v11) | v10;
  os_unfair_lock_unlock(v4);
  return v9;
}

uint64_t TFSInfo::SetSizesFetchedValid(TFSInfo *this, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unsigned int v6 = *(_DWORD *)((char *)this + 115);
  uint64_t v5 = (char *)this + 115;
  unint64_t v7 = v6 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  uint64_t v8 = (v7 >> 28) & 1;
  int v9 = 0x10000000;
  if (!a2) {
    int v9 = 0;
  }
  unint64_t v10 = v7 & 0xFFFFFFFFEFFFFFFFLL;
  *(_DWORD *)uint64_t v5 = v10 | v9;
  *((_WORD *)v5 + 2) = WORD2(v10);
  os_unfair_lock_unlock(v4);
  return v8;
}

void TFSInfo::SetOperationFractionCompleted(TFSInfo *this, double a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v5 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x20000000000) != 0)
  {
    unsigned int v6 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    uint64_t Overflow = (os_unfair_lock_s *)TFSInfo::GetOrCreateOverflow(this);
    uint64_t v8 = Overflow;
    if (a2 > 1.0 || a2 < 0.0) {
      double v10 = 0.0;
    }
    else {
      double v10 = a2 * 100.0;
    }
    unint64_t v11 = Overflow + 18;
    os_unfair_lock_lock(Overflow + 18);
    *(double *)&v8[12]._uint32_t os_unfair_lock_opaque = v10;
    os_unfair_lock_unlock(v11);
    os_unfair_lock_unlock(v6);
  }
}

void sub_1D34BEE64(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetLocalizedTypeDescription(TFSInfo *this, const TString *a2, int a3)
{
  unsigned int v6 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  uint64_t v8 = (const void *)*((void *)this + 6);
  unint64_t v7 = (TString *)((char *)this + 48);
  if (CFEqual(v8, a2->fString.fRef) || a3 && CFStringGetLength(v7->fString.fRef))
  {
    uint64_t v9 = 0;
  }
  else
  {
    if (v7 != a2) {
      TString::SetStringRefAsImmutable(v7, (TString *)a2->fString.fRef);
    }
    uint64_t v9 = 1;
  }
  os_unfair_lock_unlock(v6);
  return v9;
}

void sub_1D34BEF00(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetUTType(TFSInfo *this, UTType *a2, int a3)
{
  unsigned int v6 = a2;
  unint64_t v7 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  uint64_t v9 = (void *)*((void *)this + 5);
  uint64_t v8 = (id *)((char *)this + 40);
  if (([v9 isEqual:v6] & 1) != 0 || a3 && *v8)
  {
    uint64_t v10 = 0;
  }
  else
  {
    objc_storeStrong(v8, a2);
    uint64_t v10 = 1;
  }
  os_unfair_lock_unlock(v7);

  return v10;
}

void sub_1D34BEFA4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

unint64_t TFSInfoOverflow::ICloud(uint64_t a1, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  if (!a2)
  {
    int v8 = *(unsigned __int8 *)(a1 + 76);
    if (v8 == 2)
    {
      TFSInfoOverflow::MigrateToType(a1, 1);
    }
    else if (v8 == 3)
    {
      *(unsigned char *)(a1 + 76) = 1;
      *(void *)(a1 + ++**(_DWORD **)(result + 32) = 0;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      *(_DWORD *)(a1 + ++**(_DWORD **)(result + 32) = 0x80000000;
    }
  }
  int v5 = *(unsigned __int8 *)(a1 + 76);
  os_unfair_lock_unlock(v4);
  uint64_t v6 = a1;
  if (v5 != 1) {
    uint64_t v6 = 0;
  }
  return v6 | a1 & 0xFFFFFFFFFFFFFF00;
}

void BRFlagsRecord::~BRFlagsRecord(id *this)
{
}

id objc_cast<NSError,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void TFSInfo::SetICloudSharePerson(TFSInfo *this, NSPersonNameComponents *a2)
{
  int v8 = a2;
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  if (v8 || *((void *)this + 10))
  {
    uint64_t Overflow = TFSInfo::GetOrCreateOverflow(this);
    os_unfair_lock_lock((os_unfair_lock_t)(Overflow + 72));
    if (v8)
    {
      int v6 = *(unsigned __int8 *)(Overflow + 76);
      if (v6 == 2)
      {
        TFSInfoOverflow::MigrateToType(Overflow, 1);
      }
      else if (v6 == 3)
      {
        *(unsigned char *)(Overflow + 76) = 1;
        *(void *)(Overflow + ++**(_DWORD **)(result + 32) = 0;
        *(_OWORD *)uint64_t Overflow = 0u;
        *(_OWORD *)(Overflow + 16) = 0u;
        *(_DWORD *)(Overflow + ++**(_DWORD **)(result + 32) = 0x80000000;
      }
    }
    int v7 = *(unsigned __int8 *)(Overflow + 76);
    os_unfair_lock_unlock((os_unfair_lock_t)(Overflow + 72));
    if (v7 == 1) {
      objc_storeStrong((id *)Overflow, a2);
    }
  }
  os_unfair_lock_unlock(v4);
}

void sub_1D34BF1E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  os_unfair_lock_unlock(v10);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetKindWithoutPlatform(TFSInfo *this, TString *a2, char a3, unsigned char *a4)
{
  *a4 = 0;
  switch(*((unsigned char *)this + 112))
  {
    case 0:
      TFSInfo::LocalizedTypeDescription(this, (TString *)&cf);
      if (&cf != (CFTypeRef *)a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
        CFRetain(&stru_1F2ABD380);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = &stru_1F2ABD380;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      if (CFStringGetLength(a2->fString.fRef)) {
        return 0;
      }
      if (a3 < 0)
      {
        unint64_t v13 = TFSInfo::ApproximateUTType(this);
        int v14 = v13;
        if (v13)
        {
          unint64_t v15 = [v13 _kindString];
          if ((TString *)a2->fString.fRef != v15) {
            TString::SetStringRefAsImmutable(a2, v15);
          }
        }
        if (CFStringGetLength(a2->fString.fRef)) {
          uint64_t v7 = 4294959210;
        }
        else {
          uint64_t v7 = 4294959222;
        }
      }
      else
      {
        os_unfair_lock_lock((os_unfair_lock_t)this + 25);
        int v12 = (void *)*((void *)this + 2);
        CFTypeID v16 = v12;
        if (v12) {
          CFRetain(v12);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
        TCFURLInfo::StringProperty((TCFURLInfo *)v12, (const __CFString *)*MEMORY[0x1E4F1D720], (TString *)&cf);
        if (&cf != (CFTypeRef *)a2)
        {
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
          CFRetain(&stru_1F2ABD380);
          if (cf) {
            CFRelease(cf);
          }
          CFTypeRef cf = &stru_1F2ABD380;
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v16);
        uint64_t v7 = 0;
      }
      TFSInfo::SetLocalizedTypeDescription(this, a2, v7 != 0);
      return v7;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 0xB:
    case 0xC:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x22:
    case 0x23:
      CFTypeRef cf = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      if (&cf == (CFTypeRef *)a2) {
        goto LABEL_6;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v6 = cf;
      if (!cf) {
        goto LABEL_5;
      }
      goto LABEL_4;
    case 0x1B:
    case 0x1C:
      uint64_t v9 = TFSInfo::GetFPItem(this);
      uint64_t v10 = [v9 contentType];

      KindWithoutPlatformFromUTType(v10, (TString *)&cf);
      if (&cf != (CFTypeRef *)a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
        CFRetain(&stru_1F2ABD380);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = &stru_1F2ABD380;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);

      return 0;
    case 0x1F:
    case 0x20:
    case 0x21:
      os_unfair_lock_lock((os_unfair_lock_t)this + 24);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 24);
      return 0;
    default:
      TString::TString((TString *)&cf, "Unknown");
      if (&cf != (CFTypeRef *)a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&a2->fString.fRef, &cf);
        CFRetain(&stru_1F2ABD380);
        CFTypeRef v6 = cf;
        if (cf) {
LABEL_4:
        }
          CFRelease(v6);
LABEL_5:
        CFTypeRef cf = &stru_1F2ABD380;
      }
LABEL_6:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
      return 0;
  }
}

void sub_1D34BF500(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetExtendedUserAccess(TFSInfo *this)
{
  id v2 = TFSInfo::GetFPItem(this);
  if (v2)
  {
    TFSInfo::GetFPItem(this);
    int v3 = (TFSInfo *)objc_claimAutoreleasedReturnValue();
    int v5 = TFSInfo::FPItemPermissionRestrictions(v3, v4);

    CFTypeRef v6 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    int v7 = (~v5 & 0x1004) != 0;
    int v8 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    unsigned int v10 = *(_DWORD *)((char *)this + 115);
    uint64_t v9 = (unsigned int *)((char *)this + 115);
    os_unfair_lock_unlock(v8);
    int v11 = v7 ^ (v10 >> 20) & 1;
    os_unfair_lock_lock(v8);
    unint64_t v12 = *v9 & 0xFFEFFFFF | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    *uint64_t v9 = *v9 & 0xFFEFFFFF | (v7 << 20);
    *((_WORD *)v9 + 2) = WORD2(v12);
    os_unfair_lock_unlock(v8);
    int v13 = (~v5 & 0x5000) != 0;
    os_unfair_lock_lock(v8);
    unint64_t v14 = ((unint64_t)*v9 >> 21) & 1;
    os_unfair_lock_unlock(v8);
    os_unfair_lock_lock(v8);
    unint64_t v15 = *v9 & 0xFFDFFFFF | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    *uint64_t v9 = *v9 & 0xFFDFFFFF | (v13 << 21);
    *((_WORD *)v9 + 2) = WORD2(v15);
    os_unfair_lock_unlock(v8);
    os_unfair_lock_lock(v8);
    unint64_t v16 = ((unint64_t)*v9 >> 22) & 1;
    os_unfair_lock_unlock(v8);
    LOBYTE(v11) = v11 | v13 ^ v14 | ((v5 & 0x400000) == 0) ^ v16;
    os_unfair_lock_lock(v8);
    unint64_t v17 = *v9 & 0xFFBFFFFF | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    *uint64_t v9 = *v9 & 0xFFBFFFFF | v5 & 0x400000 ^ 0x400000;
    *((_WORD *)v9 + 2) = WORD2(v17);
    os_unfair_lock_unlock(v8);
    os_unfair_lock_lock(v8);
    unsigned int v18 = *v9;
    os_unfair_lock_unlock(v8);
    int v19 = ((~v5 & 0x9000) != 0) & (v18 >> 5);
    os_unfair_lock_lock(v8);
    unint64_t v20 = ((unint64_t)*v9 >> 23) & 1;
    os_unfair_lock_unlock(v8);
    char v21 = v11 | v19 ^ v20;
    os_unfair_lock_lock(v8);
    int v22 = 0x800000;
    if ((v19 & 1) == 0) {
      int v22 = 0;
    }
    unint64_t v23 = *v9 & 0xFF7FFFFF | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32);
    *uint64_t v9 = *v9 & 0xFF7FFFFF | v22;
    *((_WORD *)v9 + 2) = WORD2(v23);
    os_unfair_lock_unlock(v8);
    os_unfair_lock_lock(v8);
    *v9 |= 0x80000000;
    os_unfair_lock_unlock(v8);
    os_unfair_lock_unlock(v6);
  }
  else
  {
    char v21 = 0;
  }

  return v21 & 1;
}

void sub_1D34BF834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TFSInfo::CopyFPItemIfNeeded(uint64_t a1, TFSInfo **a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (UseFileProviderFramework())
  {
    uint64_t v4 = TFSInfo::GetFPItem(*a2);
    if (!v4)
    {
LABEL_5:

      return;
    }
    uint64_t Inode = TFSInfo::GetInode((TFSInfo *)a1);
    if (*(unsigned char *)(a1 + 112))
    {
LABEL_4:
      TFSInfo::SetFPItem((TFSInfo *)a1, (FPItem *)v4);
      goto LABEL_5;
    }
    uint64_t v6 = Inode;
    int v7 = TFSInfo::GetFPItem(*a2);
    uint64_t v8 = [v7 fileID];
    if (v8)
    {

      if (v8 == v6) {
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v9 = [v7 providerDomainID];
      *(void *)unint64_t v15 = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable((TString *)v15, v9);

      BOOL v10 = IsLocalStorageDomainID((const TString *)v15);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v15);
      if (v10)
      {

        goto LABEL_4;
      }
      int v11 = v9;
      *(void *)unint64_t v15 = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable((TString *)v15, v11);

      BOOL v12 = IsExternalDeviceDomainID((const TString *)v15);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v15);

      if (v12) {
        goto LABEL_4;
      }
    }
    int v13 = LogObj(4);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = [v4 fileID];
      *(_DWORD *)unint64_t v15 = 134218240;
      *(void *)&v15[4] = v14;
      __int16 v16 = 2048;
      uint64_t v17 = v6;
      _os_log_impl(&dword_1D343E000, v13, OS_LOG_TYPE_INFO, "FPItem fileID (%llu) and current inode(%llu) differ, will refetch item.", v15, 0x16u);
    }

    goto LABEL_5;
  }
}

void sub_1D34BFA40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *SFBrowsers(void)
{
  {
    std::vector<TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>>::vector(SFBrowsers(void)::browsers, 2uLL);
  }
  return SFBrowsers(void)::browsers;
}

void sub_1D34BFB38(_Unwind_Exception *a1)
{
}

int *SFBrowserLock(void)
{
  {
    SFBrowserLock(void)::locuint64_t k = 0;
  }
  return &SFBrowserLock(void)::lock;
}

const void **TFSInfo::Finalize(TFSInfo *this)
{
  uint64_t v1 = (os_unfair_lock_s *)TFSInfo::NetworkLock(this);
  os_unfair_lock_lock(v1);
  id v2 = (const void *)TFSInfo::gNetworkNearbyBrowserRef;
  TFSInfo::gNetworkNearbyBrowserRef = 0;
  int v3 = (const void *)TFSInfo::gAirDropBrowserRef;
  TFSInfo::gAirDropBrowserRef = 0;
  uint64_t v14 = v3;
  unint64_t v15 = v2;
  uint64_t v5 = TFSInfo::OpenBrowserMap(v4);
  uint64_t v6 = (int *)(v5 + 8);
  int v7 = *(int **)v5;
  if (*(void *)v5 != v5 + 8)
  {
    do
    {
      if (v7[12] >= 1) {
        SFBrowserCloseNode();
      }
      uint64_t v8 = (int *)*((void *)v7 + 1);
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = *(int **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (int *)*((void *)v7 + 2);
          BOOL v10 = *(void *)v9 == (void)v7;
          int v7 = v9;
        }
        while (!v10);
      }
      int v7 = v9;
    }
    while (v9 != v6);
  }
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy(v5, *(void **)(v5 + 8));
  *(void *)(v5 + 8) = 0;
  *(void *)(v5 + 16) = 0;
  *(void *)uint64_t v5 = v6;
  os_unfair_lock_unlock(v1);
  SFBrowserLock();
  os_unfair_lock_lock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  SFBrowsers();
  int v11 = (CFTypeRef *)SFBrowsers(void)::browsers[0];
  BOOL v12 = (CFTypeRef *)unk_1EA6AC048;
  while (v11 != v12)
  {
    if (*v11) {
      CFRelease(*v11);
    }
    *v11++ = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  if (v15) {
    SFBrowserInvalidate();
  }
  if (v14) {
    SFBrowserInvalidate();
  }
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&v14);
  return TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&v15);
}

void sub_1D34BFCF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t TFSInfo::OpenBrowserMap(TFSInfo *this)
{
  {
    operator new();
  }
  return TFSInfo::OpenBrowserMap(void)::sOpenNodeBrowsers;
}

void sub_1D34BFDBC(_Unwind_Exception *a1)
{
}

CFIndex TFSInfo::SetResourcePropertyForKey(TFSInfo *this, const __CFString *a2, const __CFString *a3, const void *a4)
{
  CFErrorRef error = 0;
  if (CFURLSetResourcePropertyForKey((CFURLRef)this, a2, a3, &error)) {
    CFIndex v5 = 0;
  }
  else {
    CFIndex v5 = TCFURLInfo::TranslateCFError(error, v4);
  }
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&error);
  return v5;
}

void sub_1D34BFE28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::SetProperty(TFSInfo *this, const __CFString *a2, const __CFString *a3)
{
  uint64_t v6 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v7 = (TFSInfo *)*((void *)this + 2);
  int v11 = v7;
  if (v7)
  {
    CFRetain(v7);
    os_unfair_lock_unlock(v6);
    if (a3) {
      CFIndex v9 = TFSInfo::SetResourcePropertyForKey(v7, a2, a3, v8);
    }
    else {
      CFIndex v9 = 4294959224;
    }
  }
  else
  {
    os_unfair_lock_unlock(v6);
    CFIndex v9 = 4294959238;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v11);
  return v9;
}

void sub_1D34BFEDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::SetTimeProperty(TFSInfo *this, const __CFString *a2, CFAbsoluteTime a3)
{
  CFStringRef v5 = (const __CFString *)CFDateCreate(0, a3);
  CFStringRef v8 = v5;
  if (v5) {
    CFIndex v6 = TFSInfo::SetProperty(this, a2, v5);
  }
  else {
    CFIndex v6 = 4294959224;
  }
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)&v8);
  return v6;
}

void sub_1D34BFF64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFDate const*,TRetainReleasePolicy<__CFDate const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::UserIsOwner(TFSInfo *this)
{
  int UserID = TFSInfo::GetUserID(this);
  return UserID == TFSInfo::GetOwner(this);
}

uint64_t TFSInfo::GetUserID(TFSInfo *this)
{
  {
    TFSInfo::GetUserID(void)::UID = geteuid();
  }
  return TFSInfo::GetUserID(void)::UID;
}

void sub_1D34C000C(_Unwind_Exception *a1)
{
}

uint64_t std::vector<std::pair<TString,TString>>::vector[abi:ne180100](uint64_t a1, TString **a2, unint64_t a3)
{
  *(void *)(a1 + 16) = 0;
  uint64_t v4 = a1 + 16;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  if (a3)
  {
    std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100]((void *)a1, a3);
    *(void *)(a1 + 8) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString> const*,std::pair<TString,TString> const*,std::pair<TString,TString>*>(v4, a2, &a2[2 * a3], *(TString **)(a1 + 8));
  }
  return a1;
}

void sub_1D34C00A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::pair<TString,TString>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetInode(TFSInfo *this)
{
  CFNumberRef number = 0;
  uint64_t valuePtr = 0;
  CFURLRef v1 = (const __CFURL *)*((void *)this + 1);
  if (v1 && CFURLCopyResourcePropertyForKey(v1, (CFStringRef)*MEMORY[0x1E4F1D5D8], &number, 0) && number)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
    uint64_t v2 = valuePtr;
  }
  else
  {
    uint64_t v2 = 0;
  }
  TAutoRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>::~TAutoRef((const void **)&number);
  return v2;
}

void sub_1D34C013C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void ___Z16CopyURLForFPItemP6FPItemb_block_invoke(uint64_t a1, void *a2)
{
  objc_storeStrong(*(id **)(a1 + 32), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

id __copy_helper_block_ea8_32c38_ZTSKZ16CopyURLForFPItemP6FPItembE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + ++**(_DWORD **)(result + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 48) = *(id *)(a2 + 48);
  id result = *(id *)(a2 + 56);
  *(void *)(a1 + 56) = result;
  *(unsigned char *)(a1 + 6TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = *(unsigned char *)(a2 + 64);
  return result;
}

void __destroy_helper_block_ea8_32c38_ZTSKZ16CopyURLForFPItemP6FPItembE3__0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

uint64_t CopyURLForFPItem(FPItem *,BOOL)::$_0::~$_0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

os_unfair_lock_s *TFSInfo::CopyParentPathURL(TFSInfo *this)
{
  CFStringRef PathComponent = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = (const void *)*((void *)this + 2);
  CFStringRef v5 = v3;
  if (v3)
  {
    CFRetain(v3);
    os_unfair_lock_unlock(PathComponent);
    CFStringRef PathComponent = (os_unfair_lock_s *)CFURLCreateCopyDeletingLastPathComponent(0, (CFURLRef)v3);
  }
  else
  {
    os_unfair_lock_unlock(PathComponent);
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v5);
  if (v3) {
    return PathComponent;
  }
  else {
    return 0;
  }
}

void sub_1D34C0314(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<BOOL>(uint64_t a1, unsigned char *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      uint64_t result = 0;
      **(unsigned char **)a1 = *a2;
      return result;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      CFStringRef v5 = *(unsigned char **)a1;
      return TPropertyValue::SetAs<BOOL>((uint64_t)v5, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TString::GetUniChar(TString *this, CFIndex a2)
{
  if (a2 < 0 || CFStringGetLength(this->fString.fRef) <= a2) {
    return 0;
  }
  uint64_t fRef = this->fString.fRef;
  return CFStringGetCharacterAtIndex(fRef, a2);
}

uint64_t TFSInfo::IsLocation(TFSInfo *this)
{
  if (*((unsigned char *)this + 112) == 21) {
    CFURLRef v1 = 0;
  }
  else {
    CFURLRef v1 = (TFSInfo *)*((unsigned int *)this + 26);
  }
  TFSInfo::Name(this, &v5);
  uint64_t IsLocation = TFSInfo::IsLocation(v1, (TFSInfo *)&v5, v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return IsLocation;
}

void sub_1D34C05DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsLocation(TFSInfo *this, TFSInfo *a2, const TString *a3)
{
  if ((int)this <= 1768712036)
  {
    if ((int)this > 1768711784)
    {
      if (this != 1768711785)
      {
        unsigned __int16 v3 = 26228;
        goto LABEL_13;
      }
    }
    else if (this != 1768710502)
    {
      unsigned __int16 v3 = 24948;
      goto LABEL_13;
    }
    return 1;
  }
  if ((int)this <= 1768713568)
  {
    if (this != 1768712037)
    {
      unsigned __int16 v3 = 26740;
      goto LABEL_13;
    }
    return 1;
  }
  if (this == 1768713569 || this == 1768713847) {
    return 1;
  }
  unsigned __int16 v3 = 30318;
LABEL_13:
  if (this == (v3 | 0x696C0000)) {
    return 1;
  }
  return TFSInfo::HasLocationExtension(a2, (const TString *)a2);
}

uint64_t TFSInfo::HasLocationExtension(TFSInfo *this, const TString *a2)
{
  unint64_t Length = CFStringGetLength(*(CFStringRef *)this);
  CFIndex v4 = Length - 5;
  if (Length < 5) {
    return 0;
  }
  unint64_t v5 = Length;
  CFIndex v6 = Length - 3;
  if ((uint64_t)(Length - 3) < 0) {
    return 0;
  }
  if ((CFStringGetLength(*(CFStringRef *)this) <= v6 || CFStringGetCharacterAtIndex(*(CFStringRef *)this, v6) != 76)
    && (CFStringGetLength(*(CFStringRef *)this) <= v6 || CFStringGetCharacterAtIndex(*(CFStringRef *)this, v6) != 108))
  {
    return 0;
  }
  if ((CFStringGetLength(*(CFStringRef *)this) <= (uint64_t)(v5 - 2)
     || CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 2) != 79)
    && (CFStringGetLength(*(CFStringRef *)this) <= (uint64_t)(v5 - 2)
     || CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 2) != 111))
  {
    return 0;
  }
  if (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 1)
    && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 1) == 67)
  {
    if (v5 < 7) {
      return 0;
    }
    goto LABEL_18;
  }
  if (CFStringGetLength(*(CFStringRef *)this) <= (uint64_t)(v5 - 1)) {
    return 0;
  }
  int CharacterAtIndex = CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 1);
  uint64_t result = 0;
  if (v5 >= 7 && CharacterAtIndex == 99)
  {
LABEL_18:
    CFIndex v9 = v5 - 6;
    if (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 6)
      && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 46
      && (CFStringGetLength(*(CFStringRef *)this) > v4 && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v4) == 65
       || CFStringGetLength(*(CFStringRef *)this) > v4 && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v4) == 97)
      && (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 4)
       && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 4) == 84
       || TString::GetUniChar((TString *)this, v5 - 4) == 116))
    {
      return 1;
    }
    if (v5 >= 8)
    {
      CFIndex v10 = v5 - 7;
      if (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 7)
        && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 7) == 46
        && ((CFStringGetLength(*(CFStringRef *)this) > v9
          && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 87
          || CFStringGetLength(*(CFStringRef *)this) > v9
          && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 119)
         && (CFStringGetLength(*(CFStringRef *)this) > v4 && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v4) == 69
          || TString::GetUniChar((TString *)this, v4) == 101)
         && (CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 4)
          && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 4) == 66
          || TString::GetUniChar((TString *)this, v5 - 4) == 98)
         || (CFStringGetLength(*(CFStringRef *)this) > v9
          && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 70
          || TString::GetUniChar((TString *)this, v5 - 6) == 102)
         && (TString::GetUniChar((TString *)this, v4) == 84
          || TString::GetUniChar((TString *)this, v4) == 116)
         && (TString::GetUniChar((TString *)this, v5 - 4) == 80
          || TString::GetUniChar((TString *)this, v5 - 4) == 112)
         || (TString::GetUniChar((TString *)this, v5 - 6) == 65
          || TString::GetUniChar((TString *)this, v5 - 6) == 97)
         && (TString::GetUniChar((TString *)this, v4) == 70
          || TString::GetUniChar((TString *)this, v4) == 102)
         && (TString::GetUniChar((TString *)this, v5 - 4) == 80
          || TString::GetUniChar((TString *)this, v5 - 4) == 112)))
      {
        return 1;
      }
      if (v5 >= 9
        && CFStringGetLength(*(CFStringRef *)this) > (uint64_t)(v5 - 8)
        && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 8) == 46)
      {
        if ((CFStringGetLength(*(CFStringRef *)this) > v10
           && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 7) == 70
           || TString::GetUniChar((TString *)this, v5 - 7) == 102)
          && (CFStringGetLength(*(CFStringRef *)this) > v9
           && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 6) == 73
           || TString::GetUniChar((TString *)this, v5 - 6) == 105)
          && (CFStringGetLength(*(CFStringRef *)this) > v4
           && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v4) == 76
           || TString::GetUniChar((TString *)this, v4) == 108)
          && (TString::GetUniChar((TString *)this, v5 - 4) == 69
           || TString::GetUniChar((TString *)this, v5 - 4) == 101))
        {
          return 1;
        }
        if ((CFStringGetLength(*(CFStringRef *)this) > v10
           && CFStringGetCharacterAtIndex(*(CFStringRef *)this, v5 - 7) == 73
           || TString::GetUniChar((TString *)this, v5 - 7) == 105)
          && (TString::GetUniChar((TString *)this, v5 - 6) == 78
           || TString::GetUniChar((TString *)this, v5 - 6) == 110)
          && (TString::GetUniChar((TString *)this, v4) == 69
           || TString::GetUniChar((TString *)this, v4) == 101)
          && (TString::GetUniChar((TString *)this, v5 - 4) == 84
           || TString::GetUniChar((TString *)this, v5 - 4) == 116))
        {
          return 1;
        }
        if ((TString::GetUniChar((TString *)this, v5 - 7) == 77
           || TString::GetUniChar((TString *)this, v5 - 7) == 109)
          && (TString::GetUniChar((TString *)this, v5 - 6) == 65
           || TString::GetUniChar((TString *)this, v5 - 6) == 97)
          && (TString::GetUniChar((TString *)this, v4) == 73
           || TString::GetUniChar((TString *)this, v4) == 105)
          && (TString::GetUniChar((TString *)this, v5 - 4) == 76
           || TString::GetUniChar((TString *)this, v5 - 4) == 108))
        {
          return 1;
        }
        if ((TString::GetUniChar((TString *)this, v5 - 7) == 78
           || TString::GetUniChar((TString *)this, v5 - 7) == 110)
          && (TString::GetUniChar((TString *)this, v5 - 6) == 69
           || TString::GetUniChar((TString *)this, v5 - 6) == 101)
          && (TString::GetUniChar((TString *)this, v4) == 87
           || TString::GetUniChar((TString *)this, v4) == 119))
        {
          CFIndex v11 = v5 - 4;
          if (TString::GetUniChar((TString *)this, v11) == 83
            || TString::GetUniChar((TString *)this, v11) == 115)
          {
            return 1;
          }
        }
      }
    }
    return 0;
  }
  return result;
}

BOOL TFSInfo::UserCanChangeLock(TFSInfo *this)
{
  int UserID = (TFSInfo *)TFSInfo::GetUserID(this);
  if (!*((unsigned char *)this + 112))
  {
    int v5 = (int)UserID;
    int v6 = TFSInfo::GetUserID(UserID);
    int Owner = TFSInfo::GetOwner(this);
    if (v5)
    {
      if (v6 != Owner) {
        return 0;
      }
    }
  }
  unsigned __int16 v3 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  BOOL v4 = (*(_DWORD *)((char *)this + 115) & 0x10000) == 0;
  os_unfair_lock_unlock(v3);
  return v4;
}

BOOL TFSInfo::UserIsRoot(TFSInfo *this)
{
  return TFSInfo::GetUserID(this) == 0;
}

uint64_t TFSIterator::Next(uint64_t a1, uint64_t *a2)
{
  if (*(void *)(a1 + 8))
  {
    while (1)
    {
      uint64_t result = TFSIterator::NextRaw(a1, a2);
      if (!result)
      {
        uint64_t v5 = *a2;
        int v6 = (os_unfair_lock_s *)(*a2 + 100);
        os_unfair_lock_lock(v6);
        int v7 = *(_DWORD *)(v5 + 115);
        os_unfair_lock_unlock(v6);
        if ((v7 & 0x20) != 0) {
          return 0;
        }
        os_unfair_lock_lock(v6);
        int v8 = *(_DWORD *)(v5 + 115);
        os_unfair_lock_unlock(v6);
        if ((v8 & 0x400) != 0) {
          return 0;
        }
        os_unfair_lock_lock(v6);
        int v9 = *(_DWORD *)(v5 + 115);
        os_unfair_lock_unlock(v6);
        if ((v9 & 0x40) != 0) {
          return 0;
        }
        uint64_t result = 4294959234;
      }
      if (result != -8062) {
        return result;
      }
    }
  }
  return TFSIterator::First(a1, (uint64_t)a2);
}

uint64_t TFSInfo::MoveAndRenameTo(uint64_t a1, TFSInfo **a2, TString **a3, TString *this)
{
  TString::SetStringRefAsImmutable(this, 0);
  if ((TCFURLInfo::GetBooleanProperty(*(TCFURLInfo **)(a1 + 8), (const __CFString *)*MEMORY[0x1E4F1CE50], v8) & 1) == 0)
  {
    TFSInfo::Path((TFSInfo *)a1, (CFTypeRef *)&theString);
    if (!CFStringGetLength(theString))
    {
      uint64_t v9 = 4294959238;
LABEL_27:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      return v9;
    }
    TFSInfo::Path(*a2, (CFTypeRef *)&v23);
    if (!CFStringGetLength(v23))
    {
      uint64_t v9 = 4294959238;
LABEL_26:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v23);
      goto LABEL_27;
    }
    TFSInfo::Name((TFSInfo *)a1, (TString *)&v22);
    if (!CFStringGetLength(v22))
    {
      uint64_t v9 = 4294959238;
LABEL_25:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v22);
      goto LABEL_26;
    }
    CFStringRef v21 = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    if (a3) {
      TString::SetStringRefAsImmutable((TString *)&v21, *a3);
    }
    else {
      TString::SetStringRefAsImmutable((TString *)&v21, (TString *)v22);
    }
    if (CFStringGetLength(v21))
    {
      SlashesToColons((const TString *)&v21, &v19);
      AppendPath((const TString *)&v23, &v19, &v20);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
      CFIndex v10 = (const char *)TString::c_str(&v20);
      if (strlen(v10) < 0x400)
      {
        if (&v20 != this) {
          TString::SetStringRefAsImmutable(this, (TString *)v20.fString.fRef);
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
        CFIndex v11 = (const std::__fs::filesystem::path *)TString::c_str((TString *)&theString);
        BOOL v12 = (const std::__fs::filesystem::path *)TString::c_str(this);
        int v14 = TCFURLInfo::RenameWithoutReplacing(v11, v12, v13);
        if (v14)
        {
          unint64_t v15 = __error();
          unsigned int v17 = TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v15, 0, v16);
        }
        else
        {
          unsigned int v17 = -8069;
        }
        if (v14) {
          uint64_t v9 = v17;
        }
        else {
          uint64_t v9 = 0;
        }
        goto LABEL_24;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
    }
    uint64_t v9 = 4294959227;
LABEL_24:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21);
    goto LABEL_25;
  }
  return 4294959217;
}

void sub_1D34C112C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  BOOL v4 = va_arg(va1, const void *);
  va_copy(va2, va1);
  int v6 = va_arg(va2, const void *);
  va_copy(va3, va2);
  CFStringRef v8 = va_arg(va3, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::IsNoUnlinkEffective(TFSInfo *this, uint64_t a2, const __CFString *a3)
{
  return TCFURLInfo::GetBooleanProperty(*((TCFURLInfo **)this + 1), (const __CFString *)*MEMORY[0x1E4F1CE50], a3);
}

uint64_t TFSInfo::FileScheme(TFSInfo *this)
{
  {
    operator new();
  }
  return TFSInfo::FileScheme(void)::fileScheme;
}

void sub_1D34C123C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::TriggerMount(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x8000) == 0) {
    return 0;
  }
  TFSInfo::Path(this, (CFTypeRef *)&theString);
  if (CFStringGetLength(theString))
  {
    uint64_t v5 = (const char *)TString::c_str((TString *)&theString);
    int v6 = opendir(v5);
    if (v6)
    {
      closedir(v6);
      uint64_t v4 = 0;
    }
    else
    {
      int v7 = __error();
      uint64_t v4 = (uint64_t)TCFURLInfo::TranslatePOSIXError((TCFURLInfo *)*v7, 0, v8);
    }
  }
  else
  {
    uint64_t v4 = 4294959238;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  return v4;
}

void sub_1D34C132C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

TString *TFSInfo::CopyTagsForPath(TFSInfo *this)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = (void *)*((void *)this + 2);
  uint64_t v27 = v3;
  if (v3)
  {
    CFRetain(v3);
    os_unfair_lock_unlock(v2);
    CFPropertyListRef v26 = 0;
    if (([v27 isFileURL] & 1) == 0)
    {
      uint64_t v4 = 0;
      goto LABEL_24;
    }
    uint64_t v4 = [v27 path];
    CFStringRef theString = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&theString, v4);

    if (!CFStringGetLength(theString))
    {
LABEL_20:
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
      unint64_t v15 = (TString *)cf_cast<__CFArray const*,void const*>(v26);
      uint64_t v4 = v15;
      if (v15) {
        CFRetain(v15);
      }
      std::vector<char> bytes = 0;
      TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)&bytes);
      goto LABEL_24;
    }
    std::vector<unsigned char>::vector(&bytes, 0x100uLL);
    uint64_t v5 = (const char *)TString::c_str((TString *)&theString);
    ssize_t v6 = getxattr(v5, "com.apple.metadata:_kMDItemUserTags", bytes, v24 - bytes, 0, 1);
    if (v6 >= 1)
    {
      uint64_t v4 = (TString *)*MEMORY[0x1E4F1CF80];
      CFDataRef v22 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, v6, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
      CFPropertyListRef v26 = CFPropertyListCreateWithData((CFAllocatorRef)v4, v22, 0, 0, 0);
      if (cf_cast<__CFDictionary const*,void const*>(v26))
      {
        {
          unsigned int v17 = (void *)MEMORY[0x1E4F1CAD0];
          uint64_t v18 = objc_opt_class();
          uint64_t v19 = objc_opt_class();
          uint64_t v20 = objc_opt_class();
          TFSInfo::CopyTagsForPath(void)const::classes = objc_msgSend(v17, "setWithObjects:", v18, v19, v20, objc_opt_class(), 0);
        }
        int v7 = (void *)MEMORY[0x1E4F28DC0];
        uint64_t v8 = TFSInfo::CopyTagsForPath(void)const::classes;
        CFDataRef v9 = v22;
        id v21 = 0;
        CFIndex v10 = [v7 unarchivedObjectOfClasses:v8 fromData:v9 error:&v21];
        id v11 = v21;
        objc_cast<NSArray,objc_object * {__strong}>(v10);
        uint64_t v4 = (TString *)objc_claimAutoreleasedReturnValue();

        if (v4)
        {
          TFSInfo::WriteTagsForPath(this, (const __CFArray *)v4);
          BOOL v12 = v4;
        }
        else
        {
          int v14 = LogObj(5);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)TPropertyValue buf = 138412290;
            id v29 = v11;
            _os_log_impl(&dword_1D343E000, v14, OS_LOG_TYPE_ERROR, "Failed to unarchive tag array: %@", buf, 0xCu);
          }
        }
        TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v22);
        char v13 = 0;
        goto LABEL_17;
      }
      TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v22);
    }
    char v13 = 1;
LABEL_17:
    if (bytes)
    {
      CFTypeID v24 = bytes;
      operator delete(bytes);
    }
    if (v13) {
      goto LABEL_20;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
LABEL_24:
    TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&v26);
    goto LABEL_25;
  }
  os_unfair_lock_unlock(v2);
  uint64_t v4 = 0;
LABEL_25:
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v27);
  return v4;
}

void sub_1D34C16B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *__p, uint64_t a16, uint64_t a17, const void *a18, const void *a19, const void *a20)
{
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a18);
  TAutoRef<void const*,TRetainReleasePolicy<void const*>>::~TAutoRef(&a19);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&a20);
  _Unwind_Resume(a1);
}

id objc_cast<NSArray,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

uint64_t TFSInfo::WriteTagsForPath(TFSInfo *this, const __CFArray *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  uint64_t v5 = (void *)*((void *)this + 2);
  uint64_t v18 = v5;
  if (v5)
  {
    CFRetain(v5);
    ssize_t v6 = v18;
  }
  else
  {
    ssize_t v6 = 0;
  }
  os_unfair_lock_unlock(v4);
  if (([v6 isFileURL] & 1) == 0) {
    goto LABEL_15;
  }
  int v7 = v18;
  if (!v18)
  {
LABEL_17:
    uint64_t v15 = 4294959238;
    goto LABEL_18;
  }
  if (!a2 || (Count = CFArrayGetCount(a2), int v7 = v18, !Count))
  {
    char v13 = [v7 path];
    CFStringRef theString = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&theString, v13);

    if (CFStringGetLength(theString))
    {
      int v14 = (const char *)TString::c_str((TString *)&theString);
      removexattr(v14, "com.apple.metadata:_kMDItemUserTags", 1);
    }
    goto LABEL_14;
  }
  CFDataRef v9 = [v18 path];
  CFStringRef theString = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&theString, v9);

  if (!CFStringGetLength(theString))
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    goto LABEL_17;
  }
  CFDataRef Data = CFPropertyListCreateData(0, a2, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (Data)
  {
    id v11 = (const char *)TString::c_str((TString *)&theString);
    CFDataRef v12 = Data;
    setxattr(v11, "com.apple.metadata:_kMDItemUserTags", (const void *)[(__CFData *)v12 bytes], [(__CFData *)v12 length], 0, 1);
  }

LABEL_14:
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
LABEL_15:
  uint64_t v15 = 0;
LABEL_18:
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v18);
  return v15;
}

void sub_1D34C19C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void TFSInfo::Rename(TFSInfo *this@<X0>, TString *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)a4 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  *(_DWORD *)(a4 + 8) = 0;
  unsigned int v8 = *((unsigned __int8 *)this + 112);
  if (v8 > 0x14)
  {
    if (v8 == 21 || v8 == 34) {
      goto LABEL_8;
    }
  }
  else if (*((unsigned char *)this + 112))
  {
    if (v8 == 1)
    {
      TFSInfo::Name(this, (TString *)&cf1);
      int v9 = CFEqual(cf1, a2->fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
      if (!v9) {
LABEL_8:
      }
        TFSInfo::SetItemName(this, a2);
    }
  }
  else
  {
    TFSInfo::Name(this, (TString *)&cf1);
    int v10 = CFEqual(cf1, a2->fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    if (v10)
    {
      if (a3) {
        *(_DWORD *)(a4 + 8) = 0;
      }
      else {
        *(_DWORD *)(a4 + 8) = -8057;
      }
    }
    else
    {
      _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&cf1);
      int Parent = TFSInfo::GetParent((uint64_t)this, (uint64_t *)&cf1);
      *(_DWORD *)(a4 + 8) = Parent;
      if (!Parent)
      {
        if (cf1)
        {
          int v12 = TFSInfo::MoveAndRenameTo((uint64_t)this, (TFSInfo **)&cf1, (TString **)a2, (TString *)a4);
        }
        else
        {
          char v13 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
          if (v13)
          {
            CFTypeRef v14 = CFAutorelease(v13);
            CFStringRef v15 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v14);
          }
          else
          {
            CFStringRef v15 = 0;
          }
          int v12 = TFSInfo::SetProperty(this, (const __CFString *)*MEMORY[0x1E4F1D738], v15);
        }
        *(_DWORD *)(a4 + 8) = v12;
      }
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
    }
  }
}

void sub_1D34C1BC8(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::SetType(TFSInfo *this, unsigned int a2)
{
  TFSInfo::GetFinderInfo(this);
  v7[0] = a2 | ((unint64_t)*((unsigned int *)this + 27) << 32);
  v7[1] = v4;
  v7[2] = TFSInfo::GetExtendedFinderInfo(this);
  v7[3] = v5;
  CFIndex result = TFSInfo::SetTotalFinderInfo(this, (const UInt8 *)v7);
  if (!result) {
    *((_DWORD *)this + 26) = a2;
  }
  return result;
}

CFIndex TFSInfo::SetCreator(TFSInfo *this, uint64_t a2)
{
  TFSInfo::GetFinderInfo(this);
  v7[0] = *((unsigned int *)this + 26) | (unint64_t)(a2 << 32);
  v7[1] = v4;
  v7[2] = TFSInfo::GetExtendedFinderInfo(this);
  v7[3] = v5;
  CFIndex result = TFSInfo::SetTotalFinderInfo(this, (const UInt8 *)v7);
  if (!result) {
    *((_DWORD *)this + 27) = a2;
  }
  return result;
}

CFIndex TFSInfo::SetIsExtensionHidden(TFSInfo *this, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v4);
  if ((v5 & 0x10) == 0) {
    return 0;
  }
  CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1D660];
  unsigned int v8 = (const __CFString **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    unsigned int v8 = (const __CFString **)MEMORY[0x1E4F1CFC8];
  }
  CFStringRef v9 = *v8;
  return TFSInfo::SetProperty(this, v7, v9);
}

id TFSInfo::LastUsedDate(TFSInfo *this)
{
  id v2 = (void *)*((void *)this + 9);
  if (!v2)
  {
    int v3 = TFSInfo::GetFPItem(this);
    uint64_t v4 = v3;
    if (v3)
    {
      uint64_t v5 = [v3 lastUsedDate];
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)this + 25);
      CFStringRef v7 = (void *)*((void *)this + 2);
      int v12 = v7;
      if (v7) {
        CFRetain(v7);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      id v8 = v7;
      uint64_t v9 = FileMetadataCopyLastUsedDateAtURL();
      int v10 = (void *)*((void *)this + 9);
      *((void *)this + 9) = v9;

      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v12);
      if (*((void *)this + 9)) {
        goto LABEL_8;
      }
      uint64_t v5 = [MEMORY[0x1E4F1C9C8] distantPast];
    }
    ssize_t v6 = (void *)*((void *)this + 9);
    *((void *)this + 9) = v5;

LABEL_8:
    id v2 = (void *)*((void *)this + 9);
  }
  return v2;
}

void sub_1D34C1E5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_unlock(v11);

  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<double>(uint64_t a1, void *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      uint64_t result = 0;
      **(void **)a1 = *a2;
      return result;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      uint64_t v5 = *(void **)a1;
      return TPropertyValue::SetAs<double>((uint64_t)v5, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

CFIndex TFSInfo::SetIsInvisible(TFSInfo *this, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v4);
  if ((v5 ^ a2)) {
    return 0;
  }
  CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1D690];
  id v8 = (const __CFString **)MEMORY[0x1E4F1CFD0];
  if (!a2) {
    id v8 = (const __CFString **)MEMORY[0x1E4F1CFC8];
  }
  CFStringRef v9 = *v8;
  return TFSInfo::SetProperty(this, v7, v9);
}

uint64_t TFSInfo::GetExtendedFinderInfo(TFSInfo *this)
{
  if (*((unsigned char *)this + 112) != 28) {
    TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
  }
  return 0;
}

CFIndex TFSInfo::SetTotalFinderInfo(TFSInfo *a1, const UInt8 *a2)
{
  CFStringRef v5 = (const __CFString *)CFDataCreate(0, a2, 32);
  CFIndex v3 = TFSInfo::SetProperty(a1, (const __CFString *)*MEMORY[0x1E4F1CDE0], v5);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)&v5);
  return v3;
}

void sub_1D34C2200(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

unint64_t TFSInfo::HasBeenInited(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0) {
    return 0;
  }
  TFSInfo::GetFinderInfo(this);
  return (v4 >> 8) & 1;
}

uint64_t TFSInfo::GetLogicalSize(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) == 0)
  {
    unint64_t v4 = TFSInfo::GetFPItem(this);
    CFStringRef v5 = v4;
    if (v4)
    {
      if ([v4 isCloudItem])
      {
        char v6 = (*(_DWORD *)((char *)this + 115) & 0x20) != 0
           ? [v5 isRecursivelyDownloaded]
           : [v5 isDownloaded];
        if ((v6 & 1) == 0)
        {
          os_unfair_lock_lock(v2);
          int v8 = *(_DWORD *)((char *)this + 115);
          os_unfair_lock_unlock(v2);
          if ((v8 & 2) != 0
            || (os_unfair_lock_lock(v2),
                int v9 = *(_DWORD *)((char *)this + 115),
                os_unfair_lock_unlock(v2),
                (v9 & 0x20) == 0))
          {
            os_unfair_lock_lock(v2);
            *(_DWORD *)((char *)this + 115) |= 0x10000000u;
            os_unfair_lock_unlock(v2);
            goto LABEL_21;
          }
        }
      }
      if ([v5 isCloudItem]
        && [v5 isDownloaded]
        && (*(_DWORD *)((char *)this + 115) & 0x20) != 0
        && TFSInfo::IsPackage(this))
      {
        TFSInfo::SetSizesFetchedValid(this, 1);
        goto LABEL_21;
      }
      os_unfair_lock_lock(v2);
      int v10 = *(_DWORD *)((char *)this + 115);
      os_unfair_lock_unlock(v2);
      if ((v10 & 0x20) != 0
        && (TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E4F1CDC8], v11) & 0x40000000) != 0)
      {
        uint64_t v7 = -2;
        goto LABEL_26;
      }
    }
    int v12 = *((unsigned __int8 *)this + 112);
    if (v12 == 28)
    {
      CFTypeRef v14 = TFSInfo::GetFPItem(this);
      CFStringRef v15 = [v14 documentSize];
      uint64_t v7 = [v15 integerValue];

LABEL_26:
      return v7;
    }
    if (v12 != 27)
    {
      os_unfair_lock_lock(v2);
      int v16 = *(_DWORD *)((char *)this + 115);
      os_unfair_lock_unlock(v2);
      if ((v16 & 0x20) != 0)
      {
        uint64_t v19 = (os_unfair_lock_s *)((char *)this + 96);
        os_unfair_lock_lock((os_unfair_lock_t)this + 24);
        uint64_t v20 = (os_unfair_lock_s *)*((void *)this + 10);
        if (v20 && (TFSInfoOverflow::FolderSizeRecord(v20, (uint64_t)v21), v22)) {
          uint64_t v7 = v21[0];
        }
        else {
          uint64_t v7 = -1;
        }
        os_unfair_lock_unlock(v19);
        goto LABEL_26;
      }
      Numericalint Property = TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E4F1D770], v17);
      goto LABEL_25;
    }
LABEL_21:
    Numericalint Property = (const __CFURL *)TFSInfo::GetDataLogicalSize(this);
LABEL_25:
    uint64_t v7 = (uint64_t)NumericalProperty;
    goto LABEL_26;
  }
  return -1;
}

void sub_1D34C24CC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetDataLogicalSize(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0) {
    return -1;
  }
  unint64_t v4 = TFSInfo::GetFPItem(this);
  if (!v4)
  {
    TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
    return -1;
  }
  CFStringRef v5 = v4;
  char v6 = [v4 documentSize];
  uint64_t v7 = v6;
  if (v6) {
    unint64_t v3 = [v6 longLongValue];
  }

  if (v7) {
    uint64_t v8 = v3;
  }
  else {
    uint64_t v8 = -2;
  }

  return v8;
}

void sub_1D34C2604(_Unwind_Exception *exception_object)
{
}

uint64_t TFSInfo::GetResourceLogicalSize(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) == 0)
  {
    if (*((unsigned __int8 *)this + 112) - 27 < 2) {
      return 0;
    }
    TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
  }
  return -1;
}

uint64_t TFSInfo::GetPhysicalSize(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0) {
    return -1;
  }
  if (*((unsigned __int8 *)this + 112) - 27 <= 1)
  {
    return TFSInfo::GetDataLogicalSize(this);
  }
  os_unfair_lock_lock(v2);
  int v6 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v6 & 0x20) != 0)
  {
    if (UseFileProviderFramework())
    {
      if ((TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E4F1CDC8], v10) & 0x40000000) != 0)
      {
        CFStringRef v11 = TFSInfo::GetFPItem(this);

        if (v11) {
          return 0;
        }
      }
    }
    int v12 = (os_unfair_lock_s *)((char *)this + 96);
    os_unfair_lock_lock((os_unfair_lock_t)this + 24);
    char v13 = (os_unfair_lock_s *)*((void *)this + 10);
    if (v13)
    {
      TFSInfoOverflow::FolderSizeRecord(v13, (uint64_t)v14);
      if (v16) {
        uint64_t v5 = v15;
      }
      else {
        uint64_t v5 = -1;
      }
    }
    else
    {
      uint64_t v5 = -1;
    }
    os_unfair_lock_unlock(v12);
    return v5;
  }
  CFURLRef v8 = (const __CFURL *)*((void *)this + 1);
  CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1D768];
  return (uint64_t)TCFURLInfo::GetNumericalProperty(v8, v9, v7);
}

void sub_1D34C285C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetResourcePhysicalSize(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0) {
    return -1;
  }
  if (*((unsigned __int8 *)this + 112) - 27 > 1)
  {
    TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
    return -1;
  }
  return TFSInfo::GetResourceLogicalSize(this);
}

uint64_t TFSInfo::GetDataPhysicalSize(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0) {
    return -1;
  }
  if (*((unsigned __int8 *)this + 112) - 27 > 1)
  {
    TCFURLInfo::CopyPropertyValues(*((void *)this + 1));
    return -1;
  }
  return TFSInfo::GetDataLogicalSize(this);
}

uint64_t TFSInfo::GetLabel(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x2000000) != 0) {
    return 0;
  }
  TFSInfo::GetFinderInfo(this);
  return (v4 >> 1) & 7;
}

CFIndex TFSInfo::SetModeDetails(TFSInfo *this, mode_t a2)
{
  if (!*((void *)this + 1)) {
    return 4294959238;
  }
  unsigned int v4 = (__CFFileSecurity *)TFSInfo::CopyPermissions(this);
  CFFileSecurityRef fileSec = v4;
  if (v4 && (mode_t mode = 0, CFFileSecurityGetMode(v4, &mode), mode != a2) && CFFileSecuritySetMode(fileSec, a2)) {
    CFIndex v5 = TFSInfo::SetProperty(this, (const __CFString *)*MEMORY[0x1E4F1D638], (const __CFString *)fileSec);
  }
  else {
    CFIndex v5 = 0;
  }
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)&fileSec);
  return v5;
}

void sub_1D34C2B78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<ISIcon * {__strong}>(uint64_t a1, id *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      unsigned int v4 = *(id **)a1;
      return TPropertyValue::SetAs<ISIcon * {__strong}>(v4, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TPropertyReference::SetAs<IFSymbol * {__strong}>(uint64_t a1, id *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      unsigned int v4 = *(id **)a1;
      return TPropertyValue::SetAs<IFSymbol * {__strong}>(v4, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

BOOL TFSInfo::FetchFlatFileVersion(uint64_t a1, TString *a2)
{
  unsigned int v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  CFURLRef v5 = *(const __CFURL **)(a1 + 16);
  CFURLRef v17 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    CFDictionaryRef v6 = CFBundleCopyInfoDictionaryForURL(v17);
    CFDictionaryRef theDict = v6;
    BOOL v7 = v6 != 0;
    if (v6)
    {
      Value = (TString *)CFDictionaryGetValue(v6, @"CFBundleShortVersionString");
      CFStringRef v9 = Value;
      if (Value)
      {
        CFTypeID v10 = CFGetTypeID(Value);
        if (v10 == CFStringGetTypeID())
        {
          v15.fString.uint64_t fRef = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          TString::SetStringRefAsImmutable(&v15, v9);
          if (&v15 != a2) {
            TString::SetStringRefAsImmutable(a2, (TString *)v15.fString.fRef);
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        }
      }
      CFStringRef v11 = (TString *)CFDictionaryGetValue(theDict, @"CFBundleGetInfoString");
      int v12 = v11;
      if (v11)
      {
        CFTypeID v13 = CFGetTypeID(v11);
        if (v13 == CFStringGetTypeID())
        {
          v15.fString.uint64_t fRef = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          TString::SetStringRefAsImmutable(&v15, v12);
          if (&a2[1] != &v15) {
            TString::SetStringRefAsImmutable(a2 + 1, (TString *)v15.fString.fRef);
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        }
      }
    }
    TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&theDict);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    BOOL v7 = 0;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v17);
  return v7;
}

void sub_1D34C30BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFURLRef v5 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)va1);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::FetchPlistVersion(uint64_t a1, TString *a2)
{
  unsigned int v4 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  CFURLRef v5 = *(const void **)(a1 + 16);
  uint64_t v20 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    Unique = (__CFBundle *)_CFBundleCreateUnique();
    CFBundleRef bundle = Unique;
    BOOL v7 = Unique != 0;
    if (Unique)
    {
      ValueForInfoDictionaryKey = (TString *)CFBundleGetValueForInfoDictionaryKey(Unique, @"CFBundleShortVersionString");
      CFStringRef v9 = ValueForInfoDictionaryKey;
      if (ValueForInfoDictionaryKey)
      {
        CFTypeID v10 = CFGetTypeID(ValueForInfoDictionaryKey);
        if (v10 == CFStringGetTypeID())
        {
          v18.fString.uint64_t fRef = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          TString::SetStringRefAsImmutable(&v18, v9);
          if (&v18 != a2) {
            TString::SetStringRefAsImmutable(a2, (TString *)v18.fString.fRef);
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
        }
      }
      CFStringRef v11 = (TString *)CFBundleGetValueForInfoDictionaryKey(bundle, @"CFBundleGetInfoString");
      int v12 = v11;
      if (v11)
      {
        CFTypeID v13 = CFGetTypeID(v11);
        if (v13 == CFStringGetTypeID())
        {
          v18.fString.uint64_t fRef = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          TString::SetStringRefAsImmutable(&v18, v12);
          if (&a2[1] != &v18) {
            TString::SetStringRefAsImmutable(a2 + 1, (TString *)v18.fString.fRef);
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
        }
      }
      CFTypeRef v14 = (TString *)CFBundleGetValueForInfoDictionaryKey(bundle, @"NSHumanReadableCopyright");
      TString v15 = v14;
      if (v14)
      {
        CFTypeID v16 = CFGetTypeID(v14);
        if (v16 == CFStringGetTypeID())
        {
          v18.fString.uint64_t fRef = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          TString::SetStringRefAsImmutable(&v18, v15);
          if (&a2[3] != &v18) {
            TString::SetStringRefAsImmutable(a2 + 3, (TString *)v18.fString.fRef);
          }
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
        }
      }
    }
    TAutoRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TAutoRef((const void **)&bundle);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    BOOL v7 = 0;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v20);
  return v7;
}

void sub_1D34C3300(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  int v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  CFURLRef v5 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TAutoRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TAutoRef((const void **)va1);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va2);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsFramework(TFSInfo *this)
{
  if (TFSInfo::IsFramework(void)const::once != -1) {
    dispatch_once(&TFSInfo::IsFramework(void)const::once, &__block_literal_global_106);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v2 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if ((v2 & 0x20) == 0) {
    return 0;
  }
  TFSInfo::Name(this, &v5);
  BOOL v3 = TString::EndsWith(&v5, (const TString *)TFSInfo::IsFramework(void)const::kFrameworkExtension);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v5.fString.fRef);
  return v3;
}

void sub_1D34C3414(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void ___ZNK7TFSInfo11IsFrameworkEv_block_invoke()
{
}

void sub_1D34C3474(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

const void *TFSInfo::SFNodeFromSFBrowser(TFSInfo *a1, uint64_t a2, int a3)
{
  uint64_t v27 = 0;
  if ((a1 - 31) < 2)
  {
    CFTypeRef cf = TFSInfo::CopyNetworkNearbyBrowserRef(a1);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&v27, cf);
LABEL_5:
    TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef(&cf);
    goto LABEL_6;
  }
  if (a1 == 33)
  {
    CFTypeRef cf = TFSInfo::CopyAirDropBrowserRef(a1);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&v27, cf);
    goto LABEL_5;
  }
LABEL_6:
  TString v5 = 0;
  if (a2 && v27)
  {
    uint64_t RootNode = (const void *)SFBrowserGetRootNode();
    CFPropertyListRef v26 = RootNode;
    if (RootNode)
    {
      CFRetain(RootNode);
      unint64_t v7 = (unint64_t)v26;
    }
    else
    {
      unint64_t v7 = 0;
    }
    BOOL v25 = 0;
    int v8 = TFSInfo::BrowserOpenNode(v27, v7, 0, 0, &v25);
    CFStringRef v9 = (const void *)SFBrowserCopyNodeForURL();
    TString v5 = v9;
    CFTypeID v24 = v9;
    if (a3 && !v9)
    {
      unsigned int v10 = 0;
      do
      {
        usleep(0x186A0u);
        TString v5 = (const void *)SFBrowserCopyNodeForURL();
        CFTypeID v24 = v5;
        if (v5) {
          break;
        }
      }
      while (v10++ < 0x31);
    }
    if (!v8)
    {
      int v12 = dispatch_get_global_queue(0, 0);
      dispatch_source_t v13 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v12);

      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 3321888768;
      handler[2] = ___ZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLb_block_invoke;
      handler[3] = &__block_descriptor_56_ea8_32c72_ZTSKZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLbE3__0_e5_v8__0l;
      CFTypeRef cf = v27;
      if (v27) {
        CFRetain(v27);
      }
      CFTypeRef v18 = v26;
      if (v26) {
        CFRetain(v26);
      }
      CFTypeRef v14 = v13;
      uint64_t v19 = v14;
      CFTypeRef v21 = cf;
      if (cf) {
        CFRetain(cf);
      }
      CFTypeRef v22 = v18;
      if (v18) {
        CFRetain(v18);
      }
      CFStringRef v23 = v19;
      dispatch_source_set_event_handler(v14, handler);

      TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(&v18);
      TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&cf);
      dispatch_time_t v15 = dispatch_time(0, 20000000000);
      dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0);
      dispatch_resume(v14);

      TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(&v22);
      TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&v21);

      TString v5 = v24;
    }
    CFTypeID v24 = 0;
    TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TAutoRef(&v24);
    TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(&v26);
  }
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)&v27);
  return v5;
}

void sub_1D34C3730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v10);
  TFSInfo::SFNodeFromSFBrowser(FSInfoVirtualType,__CFURL const*,BOOL)::$_0::~$_0((uint64_t)&a9);

  TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TAutoRef((const void **)(v11 - 64));
  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)(v11 - 48));
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)(v11 - 40));
  _Unwind_Resume(a1);
}

const void *TFSInfo::CopyNetworkNearbyBrowserRef(TFSInfo *this)
{
  uint64_t v1 = (os_unfair_lock_s *)TFSInfo::NetworkLock(this);
  os_unfair_lock_lock(v1);
  int v2 = RetainCF<__CFString const*>((const void **)&TFSInfo::gNetworkNearbyBrowserRef);
  os_unfair_lock_unlock(v1);
  return v2;
}

void sub_1D34C3808(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void *TFSInfo::CopyAirDropBrowserRef(TFSInfo *this)
{
  uint64_t v1 = (os_unfair_lock_s *)TFSInfo::NetworkLock(this);
  os_unfair_lock_lock(v1);
  int v2 = RetainCF<__CFString const*>((const void **)&TFSInfo::gAirDropBrowserRef);
  os_unfair_lock_unlock(v1);
  return v2;
}

void sub_1D34C3860(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::BrowserOpenNode(TFSInfo *a1, unint64_t a2, uint64_t a3, uint64_t a4, BOOL *a5)
{
  *a5 = 0;
  int v8 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v8);
  unsigned int v10 = (uint64_t **)TFSInfo::OpenBrowserMap(v9);
  v14[0] = (unint64_t)a1;
  v14[1] = a2;
  dispatch_time_t v15 = v14;
  uint64_t v11 = std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__emplace_unique_key_args<std::pair<__SFBrowser *,__SFNode *>,std::piecewise_construct_t const&,std::tuple<std::pair<__SFBrowser *,__SFNode *>&&>,std::tuple<>>(v10, v14, (uint64_t)&std::piecewise_construct, (_OWORD **)&v15);
  int v12 = *((_DWORD *)v11 + 12);
  *((_DWORD *)v11 + 12) = v12 + 1;
  *a5 = v12 == 0;
  os_unfair_lock_unlock(v8);
  if (*a5) {
    return SFBrowserOpenNode();
  }
  else {
    return 0;
  }
}

void sub_1D34C3938(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void ___ZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLb_block_invoke(uint64_t a1)
{
  BOOL v3 = 0;
  TFSInfo::BrowserCloseNode(*(TFSInfo **)(a1 + 32), *(void *)(a1 + 40), &v3);
  int v2 = *(NSObject **)(a1 + 48);
  dispatch_source_cancel(v2);
}

id __copy_helper_block_ea8_32c72_ZTSKZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLbE3__0(void *a1, uint64_t a2)
{
  unsigned int v4 = *(const void **)(a2 + 32);
  a1[4] = v4;
  if (v4) {
    CFRetain(v4);
  }
  TString v5 = *(const void **)(a2 + 40);
  a1[5] = v5;
  if (v5) {
    CFRetain(v5);
  }
  id result = *(id *)(a2 + 48);
  a1[6] = result;
  return result;
}

void sub_1D34C39FC(_Unwind_Exception *a1)
{
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **__destroy_helper_block_ea8_32c72_ZTSKZN7TFSInfo19SFNodeFromSFBrowserE17FSInfoVirtualTypePK7__CFURLbE3__0(uint64_t a1)
{
  int v2 = (const void **)(a1 + 32);

  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)(a1 + 40));
  return TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v2);
}

const void **TFSInfo::SFNodeFromSFBrowser(FSInfoVirtualType,__CFURL const*,BOOL)::$_0::~$_0(uint64_t a1)
{
  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)(a1 + 8));
  return TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)a1);
}

uint64_t TFSInfo::BrowserCloseNode(TFSInfo *a1, unint64_t a2, BOOL *a3)
{
  *a3 = 0;
  CFDictionaryRef v6 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v6);
  uint64_t v8 = TFSInfo::OpenBrowserMap(v7);
  v12[0] = (unint64_t)a1;
  v12[1] = a2;
  CFStringRef v9 = std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::find<std::pair<__SFBrowser *,__SFNode *>>(v8, v12);
  if ((void *)(v8 + 8) != v9)
  {
    int v10 = *((_DWORD *)v9 + 12) - 1;
    *((_DWORD *)v9 + 12) = v10;
    *a3 = v10 == 0;
  }
  os_unfair_lock_unlock(v6);
  if (*a3) {
    return SFBrowserCloseNode();
  }
  else {
    return 0;
  }
}

void sub_1D34C3B44(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL TFSInfo::IsBrowserOpen(TFSInfo *a1)
{
  int v2 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v2);
  uint64_t v4 = TFSInfo::OpenBrowserMap(v3);
  v7[0] = (unint64_t)a1;
  v7[1] = SFBrowserGetRootNode();
  BOOL v5 = v4 + 8 != (void)std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::find<std::pair<__SFBrowser *,__SFNode *>>(v4, v7);
  os_unfair_lock_unlock(v2);
  return v5;
}

void sub_1D34C3BD0(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void *TFSInfo::SFNodeFromURL(uint64_t a1, int a2, char *a3)
{
  char v6 = 31;
  id result = TFSInfo::SFNodeFromSFBrowser((TFSInfo *)0x1F, a1, a2);
  if (result) {
    goto LABEL_2;
  }
  if (IsRunningInFinder()) {
    return 0;
  }
  char v6 = 33;
  id result = TFSInfo::SFNodeFromSFBrowser((TFSInfo *)0x21, a1, a2);
  if (result) {
LABEL_2:
  }
    *a3 = v6;
  return result;
}

uint64_t TFSInfo::SetAliasIsContainer(TFSInfo *this, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unsigned int v6 = *(_DWORD *)((char *)this + 115);
  BOOL v5 = (char *)this + 115;
  unint64_t v7 = v6 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  uint64_t v8 = (v7 >> 17) & 1;
  int v9 = 0x20000;
  if (!a2) {
    int v9 = 0;
  }
  unint64_t v10 = v7 & 0xFFFFFFFFFFFDFFFFLL;
  *(_DWORD *)BOOL v5 = v10 | v9;
  *((_WORD *)v5 + 2) = WORD2(v10);
  os_unfair_lock_unlock(v4);
  return v8;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  return result;
}

const void **__Block_byref_object_dispose_(uint64_t a1)
{
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)(a1 + 48));
}

void ___ZNK7TFSInfo24FollowAliasOrSymlinkDeepE18NodeRequestOptionsRNSt3__110shared_ptrIS_EEi_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 40)) {
    uint64_t v4 = (const void *)MEMORY[0x1D9435EE0](0, v3, 0);
  }
  else {
    uint64_t v4 = 0;
  }
  BOOL v5 = v4;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 48), v4);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef(&v5);
}

void sub_1D34C3D64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFIndex TFSInfo::CopyBookmarkDataTo(TFSInfo *this, const __CFData **a2)
{
  uint64_t v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  BOOL v5 = (const void *)*((void *)this + 2);
  unint64_t v10 = v5;
  if (v5)
  {
    CFRetain(v5);
    os_unfair_lock_unlock(v4);
    int v9 = 0;
    *a2 = (const __CFData *)MEMORY[0x1D9435ED0](0, v5, 536871424, 0, v5, &v9);
    if (v9) {
      CFIndex v7 = TCFURLInfo::TranslateCFError(v9, v6);
    }
    else {
      CFIndex v7 = 0;
    }
    TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v9);
  }
  else
  {
    os_unfair_lock_unlock(v4);
    CFIndex v7 = 4294959238;
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v10);
  return v7;
}

void sub_1D34C3E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<short>(uint64_t a1, __int16 *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      uint64_t result = 0;
      **(_WORD **)a1 = *a2;
      break;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      goto LABEL_49;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      uint64_t result = 0;
      **(void **)a1 = *a2;
      break;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      BOOL v5 = *(_WORD **)a1;
      uint64_t result = TPropertyValue::SetAs<short>((uint64_t)v5, a2);
      break;
    case 20:
      if (v2 == 20) {
        goto LABEL_43;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      goto LABEL_49;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      goto LABEL_49;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_49:
      uint64_t result = 0;
      **(_DWORD **)a1 = *a2;
      break;
    default:
LABEL_43:
      uint64_t result = 4294959246;
      break;
  }
  return result;
}

id TFSInfo::ApproximateUTType(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  id v3 = (__CFString *)*((void *)this + 2);
  CFStringRef theString = v3;
  if (v3) {
    CFRetain(v3);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v4 = TCFURLInfo::ObjectProperty((TCFURLInfo *)v3, (const __CFString *)*MEMORY[0x1E4F1C538], 0);
  BOOL v5 = static_objc_cast<NSString,objc_object * {__strong}>(v4);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&theString);
  if (!v5)
  {
    TFSInfo::ActualSuffix(this, (TString *)&theString);
    os_unfair_lock_lock(v2);
    char v6 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock(v2);
    os_unfair_lock_lock(v2);
    int v7 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock(v2);
    if (CFStringGetLength(theString))
    {
      if ((v7 & 2) != 0) {
        uint64_t v8 = (void *)MEMORY[0x1E4F44468];
      }
      else {
        uint64_t v8 = (void *)MEMORY[0x1E4F44378];
      }
      id v9 = [MEMORY[0x1E4F442D8] typeWithFilenameExtension:theString conformingToType:*v8];
    }
    else
    {
      BOOL v5 = 0;
      if ((v6 & 0x20) == 0 || (v7 & 2) != 0) {
        goto LABEL_13;
      }
      id v9 = (id)*MEMORY[0x1E4F443C8];
    }
    BOOL v5 = v9;
LABEL_13:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
  }
  return v5;
}

void sub_1D34C41D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void std::make_unique[abi:ne180100]<TVersionData>()
{
}

void sub_1D34C42B0(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  MEMORY[0x1D9436740](v1, 0x60C40902580DDLL);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::GetOldLocation(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v3 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock(v2);
  if ((v3 & 0x100) != 0 || !TFSInfo::HasBeenInited(this)) {
    return 0xFFFFFFFFLL;
  }
  TFSInfo::GetFinderInfo(this);
  if ((v4 & 0xFFFFFFFF0000) != 0) {
    return (v4 >> 16);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

unint64_t TFSInfo::GetOldIconOrigin(TFSInfo *this)
{
  unint64_t result = TFSInfo::HasBeenInited(this);
  if (result)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    int v3 = *(_DWORD *)((char *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    if ((v3 & 0x20) != 0) {
      return TFSInfo::GetExtendedFinderInfo(this);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t TFSInfo::GetOldViewStyle(TFSInfo *this)
{
  if (TFSInfo::HasBeenInited(this)
    && (os_unfair_lock_lock((os_unfair_lock_t)this + 25),
        int v2 = *(_DWORD *)((char *)this + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25),
        (v2 & 0x20) != 0))
  {
    TFSInfo::GetExtendedFinderInfo(this);
    __int16 v5 = v4;
    TFSInfo::GetFinderInfo(this);
    if ((v5 & 0x800) != 0) {
      __int16 v7 = 4;
    }
    else {
      __int16 v7 = 5;
    }
    if ((v5 & 0x2000) == 0) {
      __int16 v7 = 3;
    }
    if ((v6 & 0x40) != 0) {
      __int16 v8 = 2;
    }
    else {
      __int16 v8 = v7;
    }
    if ((v6 & 0xE00) != 0) {
      return 1;
    }
    else {
      return v8;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t TPropertyReference::SetAs<long long>(uint64_t a1, void *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 2:
      if (v2 != 2) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 3:
      if (v2 != 3) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 4:
      if (v2 != 4) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 5:
      if (v2 != 5) {
        goto LABEL_50;
      }
      uint64_t result = 0;
      **(void **)a1 = *a2;
      break;
    case 6:
      if (v2 != 6) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 7:
      if (v2 != 7) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 8:
      if (v2 != 8) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 9:
      if (v2 != 9) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 10:
      if (v2 != 10) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 11:
      if (v2 != 11) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 12:
      if (v2 != 12) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 13:
      if (v2 != 13) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 14:
      if (v2 != 14) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 15:
      if (v2 != 15) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 16:
      if (v2 != 16) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 17:
      if (v2 != 17) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 18:
      if (v2 != 18) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 19:
      if (v2 != 19) {
        goto LABEL_50;
      }
      __int16 v5 = *(void **)a1;
      uint64_t result = TPropertyValue::SetAs<long long>((uint64_t)v5, a2);
      break;
    case 20:
      if (v2 != 20) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 21:
      if (v2 != 21) {
        goto LABEL_50;
      }
      goto LABEL_49;
    case 22:
      if (v2 == 22) {
        goto LABEL_47;
      }
      goto LABEL_50;
    case 23:
      if (v2 != 23) {
LABEL_50:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_49:
      uint64_t result = 0;
      **(_DWORD **)a1 = *a2;
      break;
    default:
LABEL_47:
      uint64_t result = 4294959246;
      break;
  }
  return result;
}

unint64_t TFSInfo::GetFlatItemDirEntryCount(TFSInfo *this, int a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (IsEnhancedAPFSEnabled()
    && (__int16 v5 = (TCFURLInfo *)*((void *)this + 1)) != 0
    && (TCFURLInfo::GetNumberProperty(v5, (const __CFString *)*MEMORY[0x1E4F1D5A8], v4),
        __int16 v6 = objc_claimAutoreleasedReturnValue(),
        (__int16 v7 = v6) != 0))
  {
    uint64_t v8 = [v6 unsignedLongLongValue];
    unsigned __int8 v9 = v8;
    if (v8 == 65533)
    {
      unint64_t v10 = LogObj(5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v11 = (NSURL *)*((id *)this + 1);
        int v12 = SanitizedURL(v11);
        buf.char st_dev = 138543362;
        *(void *)&buf.st_mode_t mode = v12;
        _os_log_impl(&dword_1D343E000, v10, OS_LOG_TYPE_DEBUG, "Unknown child item count found for %{public}@", (uint8_t *)&buf, 0xCu);
      }
      unsigned __int8 v9 = 0;
      unint64_t v13 = 0;
    }
    else
    {
      unint64_t v13 = v8 & 0xFFFFFFFFFFFFFF00;
    }
  }
  else if (a2 {
         && (CFTypeRef v14 = (void *)*((void *)this + 1)) != 0
  }
         && (dispatch_time_t v15 = (const char *)[v14 fileSystemRepresentation]) != 0
         && !stat(v15, &buf)
         && (unsigned __int16)(buf.st_nlink + 1) > 2u)
  {
    unsigned __int8 v9 = LOBYTE(buf.st_nlink) - 2;
    unint64_t v13 = (buf.st_nlink + 4294967294) & 0xFFFFFF00;
  }
  else
  {
    CFTypeID v16 = LogObj(4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      CFURLRef v17 = (void *)*((void *)this + 1);
      if (v17)
      {
        uint64_t v18 = SanitizedURL((NSURL *)v17);
      }
      else
      {
        TFSInfo::Name(this, &v21);
        uint64_t v18 = SanitizedStr(&v21);
      }
      uint64_t v19 = (void *)v18;
      buf.char st_dev = 138543362;
      *(void *)&buf.st_mode_t mode = v18;
      _os_log_impl(&dword_1D343E000, v16, OS_LOG_TYPE_ERROR, "Failed to get item count for dataless directory: %{public}@", (uint8_t *)&buf, 0xCu);

      if (v17) {
      else
      }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
    }

    unsigned __int8 v9 = 0;
    unint64_t v13 = 0;
  }
  return v13 & 0xFFFFFFFFFFFFFF00 | v9;
}

void sub_1D34C48C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t TFSInfo::GetFlatItemCount(TFSInfo *this, int a2, const __CFString *a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 112) == 28)
  {
    CFStringRef v4 = TFSInfo::GetFPItem(this);
    __int16 v5 = [v4 childItemCount];

    if (v5)
    {
      uint64_t v6 = [v5 integerValue];

      return v6;
    }
    CFTypeID v16 = LogObj(4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      CFURLRef v17 = TFSInfo::GetFPItem(this);
      *(_DWORD *)stat buf = 138543362;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl(&dword_1D343E000, v16, OS_LOG_TYPE_ERROR, "Failed to get item count for FPv2 directory: %{public}@", buf, 0xCu);
    }
    return -2;
  }
  if ((TCFURLInfo::GetNumericalProperty(*((const __CFURL **)this + 1), (const __CFString *)*MEMORY[0x1E4F1CDC8], a3) & 0x40000000) != 0)
  {
    unint64_t v10 = TFSInfo::GetFPItem(this);
    uint64_t v11 = v10;
    if (!v10) {
      goto LABEL_43;
    }
    int v12 = [v10 providerDomainID];
    *(void *)stat buf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)buf, v12);

    BOOL v13 = IsICloudDriveDomainID((TString *)buf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);

    if (!v13)
    {
LABEL_43:

      uint64_t v31 = LogObj(4);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        char v32 = (NSURL *)*((id *)this + 1);
        uint64_t v33 = SanitizedURL(v32);
        uint64_t v34 = TFSInfo::GetFPItem(this);
        *(_DWORD *)stat buf = 138543618;
        *(void *)&uint8_t buf[4] = v33;
        __int16 v45 = 2114;
        unint64_t v46 = v34;
        _os_log_impl(&dword_1D343E000, v31, OS_LOG_TYPE_ERROR, "Failed to get item count for dataless directory: %{public}@, fpItem: %{public}@", buf, 0x16u);
      }
      return -2;
    }
    FlatItemDirEntryCFIndex Count = TFSInfo::GetFlatItemDirEntryCount(this, 1);
    if (v15) {
      uint64_t v6 = FlatItemDirEntryCount;
    }
    else {
      uint64_t v6 = -2;
    }
  }
  else if ((a2 & 1) != 0 || (unint64_t v8 = TFSInfo::GetFlatItemDirEntryCount(this, 0), !v9))
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    uint64_t v18 = (const void *)*((void *)this + 2);
    *(void *)stat buf = v18;
    if (v18)
    {
      CFRetain(v18);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      uint64_t v19 = (__CFString *)(id)*MEMORY[0x1E4F1D618];
      v43[0] = v19;
      uint64_t v20 = (__CFString *)(id)*MEMORY[0x1E4F1D690];
      v43[1] = v20;
      TString v21 = (__CFString *)(id)*MEMORY[0x1E4F1D738];
      void v43[2] = v21;
      uint64_t v38 = [MEMORY[0x1E4F1C978] arrayWithObjects:v43 count:3];

      uint64_t v42 = MEMORY[0x1D9435F70](*MEMORY[0x1E4F1CF80], *(void *)buf, 0, v38);
      uint64_t v6 = 0;
      if (v42)
      {
        if (*MEMORY[0x1E4F1D620]) {
          CFTypeRef v22 = (__CFString *)*MEMORY[0x1E4F1D620];
        }
        else {
          CFTypeRef v22 = &stru_1F2ABD380;
        }
        uint64_t v23 = (__CFString *)*MEMORY[0x1E4F1D610];
        if (!*MEMORY[0x1E4F1D610]) {
          uint64_t v23 = &stru_1F2ABD380;
        }
        CFTypeRef cf2 = v23;
        CFTypeID v24 = (__CFString *)*MEMORY[0x1E4F1D628];
        if (!*MEMORY[0x1E4F1D628]) {
          CFTypeID v24 = &stru_1F2ABD380;
        }
        BOOL v36 = v24;
        do
        {
          unint64_t v41 = 0;
          uint64_t v25 = MEMORY[0x1D9435F80](v42, &v41, 0);
          if (v25 == 1)
          {
            CFPropertyListRef v26 = TCFURLInfo::StringProperty(v41, v21, (TString *)&cf1);
            PropertyStoreName = TCFURLInfo::GetPropertyStoreName((TCFURLInfo *)v26);
            if (!CFEqual(cf1, (CFTypeRef)*PropertyStoreName)
              && (operator==((void **)&cf1, @".localized") & 1) == 0)
            {
              if (operator==((void **)&cf1, @"Inbox")
                && (unsigned int v28 = v41, v29 = IsAppInbox((NSURL *)v28), v28, v29))
              {
                MEMORY[0x1D9435F90](v42);
              }
              else
              {
                TCFURLInfo::StringProperty(v41, v19, (TString *)&v39);
                if (CFEqual(v39, v22) || CFEqual(v39, cf2) || CFEqual(v39, v36))
                {
                  if (a2) {
                    v6 += TCFURLInfo::GetBooleanProperty(v41, v20, v30) ^ 1;
                  }
                  else {
                    ++v6;
                  }
                }
                TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v39);
              }
            }
            TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
          }
        }
        while (v25 != 2);
      }
      TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)&v42);
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
      uint64_t v6 = 0;
    }
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)buf);
  }
  else
  {
    return v8;
  }
  return v6;
}

void sub_1D34C4DF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, ...)
{
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  __int16 v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  __int16 v7 = va_arg(va2, const void *);
  uint64_t v9 = va_arg(va2, void);
  va_copy(va3, va2);
  unint64_t v10 = va_arg(va3, const void *);
  uint64_t v12 = va_arg(va3, void);
  uint64_t v13 = va_arg(va3, void);
  uint64_t v14 = va_arg(va3, void);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef((const void **)va2);

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va3);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<NSPersonNameComponents * {__strong}>(uint64_t a1, id *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      CFStringRef v4 = *(id **)a1;
      return TPropertyValue::SetAs<NSPersonNameComponents * {__strong}>(v4, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TPropertyReference::SetAs<__CFArray const*>(uint64_t a1, CFTypeRef *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(*(CFTypeRef **)a1, *a2);
      return 0;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      CFStringRef v4 = *(CFTypeRef **)a1;
      return TPropertyValue::SetAs<__CFArray const*>((uint64_t)v4, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

void TFSInfo::FolderStats(TFSInfo *this@<X0>, unsigned char *a2@<X8>)
{
  CFStringRef v4 = (os_unfair_lock_s *)((char *)this + 96);
  os_unfair_lock_lock((os_unfair_lock_t)this + 24);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  int v5 = *(_DWORD *)((char *)this + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  if ((v5 & 0x10000000) != 0
    && *((void *)this + 10)
    && (os_unfair_lock_lock((os_unfair_lock_t)this + 25),
        int v6 = *(_DWORD *)((char *)this + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25),
        (v6 & 0x20) != 0))
  {
    TFSInfoOverflow::FolderSizeRecord(*((os_unfair_lock_s **)this + 10), (uint64_t)a2);
  }
  else
  {
    *a2 = 0;
    a2[32] = 0;
  }
  os_unfair_lock_unlock(v4);
}

void sub_1D34C536C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSInfoOverflow::FolderSizeRecord(os_unfair_lock_s *this@<X0>, uint64_t a2@<X8>)
{
  CFStringRef v4 = this + 18;
  os_unfair_lock_lock(this + 18);
  int v5 = *(_OWORD **)&this[10]._os_unfair_lock_opaque;
  if (v5)
  {
    long long v6 = v5[1];
    *(_OWORD *)a2 = *v5;
    *(_OWORD *)(a2 + 16) = v6;
    LOBYTE(v5) = 1;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + ++**(_DWORD **)(result + 32) = (_BYTE)v5;
  os_unfair_lock_unlock(v4);
}

const void **TFSInfo::SynchronizeVersionsForce(TString **a1, uint64_t *a2, uint64_t **a3)
{
  CFTypeRef cf1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  CFTypeRef v19 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  CFTypeRef v18 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  CFURLRef v17 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  os_unfair_lock_lock((os_unfair_lock_t)a1 + 24);
  long long v6 = *a1;
  if (!*a1) {
    std::make_unique[abi:ne180100]<TVersionData>();
  }
  CFTypeRef cf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v6->fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&cf1, &cf);
  CFRetain(&stru_1F2ABD380);
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = &stru_1F2ABD380;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  __int16 v7 = *a1;
  CFTypeRef cf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v7[1].fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v19, &cf);
  CFRetain(&stru_1F2ABD380);
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = &stru_1F2ABD380;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  unint64_t v8 = *a1;
  CFTypeRef cf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v8[2].fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(&v18, &cf);
  CFRetain(&stru_1F2ABD380);
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = &stru_1F2ABD380;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  uint64_t v9 = *a1;
  CFTypeRef cf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf, (TString *)v9[3].fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v17, &cf);
  CFRetain(&stru_1F2ABD380);
  if (cf) {
    CFRelease(cf);
  }
  CFTypeRef cf = &stru_1F2ABD380;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  os_unfair_lock_unlock((os_unfair_lock_t)a1 + 24);
  CFTypeRef cf = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  int ShortVersion = TFSInfo::GetShortVersion(*a2, &cf);
  if (!ShortVersion && !CFEqual(cf1, cf))
  {
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 24);
    if (*a1 != (TString *)&cf) {
      TString::SetStringRefAsImmutable(*a1, (TString *)cf);
    }
    unsigned int v15 = 1936225906;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v15, &v15);
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 24);
  }
  if (!TFSInfo::GetLongVersion(*a2, (TString *)&cf) && !CFEqual(v19, cf))
  {
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 24);
    uint64_t v11 = *a1 + 1;
    if (v11 != (TString *)&cf) {
      TString::SetStringRefAsImmutable(v11, (TString *)cf);
    }
    unsigned int v15 = 1986359923;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v15, &v15);
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 24);
  }
  if (!TFSInfo::GetSystemVersion(*a2, (TString *)&cf) && !CFEqual(v18, cf))
  {
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 24);
    uint64_t v12 = *a1 + 2;
    if (v12 != (TString *)&cf) {
      TString::SetStringRefAsImmutable(v12, (TString *)cf);
    }
    unsigned int v15 = 1937340018;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v15, &v15);
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 24);
  }
  if (!TFSInfo::GetCopyrightString(*a2, (TString *)&cf) && !CFEqual(v17, cf))
  {
    os_unfair_lock_lock((os_unfair_lock_t)a1 + 24);
    uint64_t v13 = *a1 + 3;
    if (v13 != (TString *)&cf) {
      TString::SetStringRefAsImmutable(v13, (TString *)cf);
    }
    unsigned int v15 = 1668313715;
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(a3, &v15, &v15);
    os_unfair_lock_unlock((os_unfair_lock_t)a1 + 24);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v17);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v18);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v19);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
}

void sub_1D34C57DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, const void *a12, const void *a13, const void *a14)
{
  os_unfair_lock_unlock(v14);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a13);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a14);
  _Unwind_Resume(a1);
}

char *CopyACLToText(__CFFileSecurity *a1)
{
  if (!a1) {
    return 0;
  }
  acl_t accessControlList = 0;
  if (CFFileSecurityCopyAccessControlList(a1, &accessControlList))
  {
    ssize_t v3 = 0;
    uint64_t v1 = acl_to_text(accessControlList, &v3);
  }
  else
  {
    uint64_t v1 = 0;
  }
  TACLRef<_acl *>::~TACLRef((void **)&accessControlList);
  return v1;
}

void sub_1D34C5910(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TACLRef<_acl *>::~TACLRef((void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::RefreshUTTypeProperty(TFSInfo *this, __CFString *a2)
{
  if (!*((void *)this + 1)) {
    return 0;
  }
  ssize_t v3 = a2;
  CFStringRef v4 = (const __CFString *)*MEMORY[0x1E4F1C538];
  if ([(__CFString *)v3 isEqualToString:*MEMORY[0x1E4F1C538]])
  {

LABEL_6:
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    __int16 v7 = (__CFString *)*((void *)this + 2);
    v13.fString.uint64_t fRef = v7;
    if (v7) {
      CFRetain(v7);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    unint64_t v8 = TCFURLInfo::ObjectProperty((TCFURLInfo *)v7, v4, (const __CFString *)1);
    static_objc_cast<NSString,objc_object * {__strong}>(v8);
    uint64_t v9 = (UTType *)objc_claimAutoreleasedReturnValue();

    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v13.fString.fRef);
    uint64_t v5 = TFSInfo::SetUTType(this, v9, 0);

    return v5;
  }
  int v6 = [(__CFString *)v3 isEqualToString:*MEMORY[0x1E4F1D778]];

  if (v6) {
    goto LABEL_6;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v10 = (void *)*((void *)this + 2);
  uint64_t v12 = v10;
  if (v10) {
    CFRetain(v10);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
  TCFURLInfo::StringProperty((TCFURLInfo *)v10, v3, &v13);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v12);
  uint64_t v5 = TFSInfo::SetLocalizedTypeDescription(this, &v13, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
  return v5;
}

void sub_1D34C5A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<__CFString const*>(uint64_t a1, CFTypeRef *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_47;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_47;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_47;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_47;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_47;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_47;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_47;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_47;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_47;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_47;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_47;
      }
      ssize_t v3 = *(TString **)a1;
      CFStringRef v4 = (TString *)*a2;
      if ((TString *)v3->fString.fRef != v4) {
        TString::SetStringRefAsImmutable(v3, v4);
      }
      return 0;
    case 12:
      if (v2 != 12) {
        goto LABEL_47;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(*(CFTypeRef **)a1, *a2);
      return 0;
    case 13:
      if (v2 != 13) {
        goto LABEL_47;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_47;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_47;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_47;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_47;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_47;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_47;
      }
      int v6 = *(TString **)a1;
      return TPropertyValue::SetAs<__CFString const*>(v6, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_47;
    case 21:
      if (v2 != 21) {
        goto LABEL_47;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_47;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_47:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TPropertyReference::SetAs<UTType * {__strong}>(uint64_t a1, id *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      CFStringRef v4 = *(id **)a1;
      return TPropertyValue::SetAs<UTType * {__strong}>(v4, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TFSInfo::GetIndex(TFSInfo *this)
{
  return 0xFFFFFFFFLL;
}

void NetworkRefreshCallback(TFSInfo *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 a6)
{
  ConnectionState = (TNode *)SFNodeGetConnectionState();
  int v10 = (int)ConnectionState;
  if (TNode::IsContextOpen(ConnectionState))
  {
    TNode::GetNWNode(a6, a2, (TNodePtr *)&v40);
    if (TNodeFromFINode(v40))
    {
LABEL_11:
      uint64_t v12 = TNodeFromFINode(v40);
      if (!a1 || !v12) {
        goto LABEL_31;
      }
      uint64_t v13 = TNodeFromFINode(v40);
      uint64_t v14 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v13);
      os_unfair_lock_lock(v14);
      unsigned int v15 = *(std::__shared_weak_count **)(v13 + 24);
      if (v15)
      {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(v14);
        std::__shared_weak_count::__release_shared[abi:ne180100](v15);
      }
      else
      {
        os_unfair_lock_unlock(v14);
      }
      uint64_t v16 = TNodeFromFINode(v40);
      CFURLRef v17 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v16);
      os_unfair_lock_lock(v17);
      CFTypeRef v18 = *(std::__shared_weak_count **)(v16 + 24);
      if (v18)
      {
        char v19 = 1;
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(v17);
        int v20 = MEMORY[0x38];
        std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        if (v10 == v20)
        {
LABEL_24:
          CFTypeID v24 = (TNode *)TNodeFromFINode(v40);
          if (TNode::ClearInitialPopulationDeferred(v24)) {
            unsigned int v26 = 20971520;
          }
          else {
            unsigned int v26 = 0x1000000;
          }
          if ((TGlobalNodes::IsNetworkNode((TGlobalNodes *)0x6D74726D, &v40, v25) & 1) != 0
            || SFBrowserGetRootNode() != a2)
          {
            uint64_t v27 = TNodeFromFINode(v40);
            TNode::HandleSync(v27, v26);
            if (v19)
            {
LABEL_31:

              return;
            }
LABEL_30:
            unsigned int v28 = (const TNode *)TNodeFromFINode(v40);
            TNode::SendNotification(v28, 2, (id *)&v40, 1853121395, 0);
            goto LABEL_31;
          }
          TNode::GetNetworkNode((TNode *)0x6E74776B, (void **)&v39);
          TNode::GetNetworkNode((TNode *)0x6E747362, (void **)&v38);
          uint64_t v29 = TNodeFromFINode(v40);
          if (v29 == TNodeFromFINode(v39) || (uint64_t v30 = TNodeFromFINode(v40), v30 == TNodeFromFINode(v38)))
          {
            char v32 = (TNode *)TNodeFromFINode(v39);
            int v33 = atomic_load((unsigned int *)TNode::GetNotifierList(v32));
            if (v33 >= 1)
            {
              uint64_t v34 = TNodeFromFINode(v39);
              TNode::HandleSync(v34, v26);
            }
            int v35 = (TNode *)TNodeFromFINode(v38);
            int v36 = atomic_load((unsigned int *)TNode::GetNotifierList(v35));
            if (v36 < 1)
            {
LABEL_41:

              if (v19) {
                goto LABEL_31;
              }
              goto LABEL_30;
            }
            uint64_t v31 = &v38;
          }
          else
          {
            uint64_t v31 = &v40;
          }
          uint64_t v37 = TNodeFromFINode(*v31);
          TNode::HandleSync(v37, v26);
          goto LABEL_41;
        }
      }
      else
      {
        os_unfair_lock_unlock(v17);
        if (v10 == MEMORY[0x38])
        {
          char v19 = 1;
          goto LABEL_24;
        }
      }
      uint64_t v21 = TNodeFromFINode(v40);
      CFTypeRef v22 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v21);
      os_unfair_lock_lock(v22);
      uint64_t v23 = *(std::__shared_weak_count **)(v21 + 24);
      if (v23)
      {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(v22);
        MEMORY[0x38] = v10;
        std::__shared_weak_count::__release_shared[abi:ne180100](v23);
        char v19 = 0;
      }
      else
      {
        os_unfair_lock_unlock(v22);
        char v19 = 0;
        MEMORY[0x38] = v10;
      }
      goto LABEL_24;
    }
    int v11 = TFSInfo::BrowserType(a1);
    switch(v11)
    {
      case 31:
        TGlobalNodes::NetworkNearbyNode(&v39);
        break;
      case 32:
        TGlobalNodes::NetworkSidebarNode(&v39);
        break;
      case 33:
        TGlobalNodes::AirDropNode(&v39);
        break;
      default:
LABEL_10:
        TNode::AddNWNode(a6, a2, &v40);
        goto LABEL_11;
    }
    TNodePtr::operator=((void **)&v40, (void **)&v39);

    goto LABEL_10;
  }
}

void sub_1D34C6214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::BrowserType(TFSInfo *a1)
{
  int v2 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v2);
  if ((TFSInfo *)TFSInfo::gAirDropBrowserRef == a1) {
    unsigned int v3 = 33;
  }
  else {
    unsigned int v3 = 0;
  }
  if ((TFSInfo *)TFSInfo::gNetworkNearbyBrowserRef == a1) {
    uint64_t v4 = 31;
  }
  else {
    uint64_t v4 = v3;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

CFTypeRef TFSInfo::CreateSFBrowser(int a1)
{
  CFTypeRef cf = 0;
  if ((a1 - 31) >= 2)
  {
    if (a1 != 33) {
      abort();
    }
    CFTypeRef cf = CreateSFBrowser(33);
    uint64_t v1 = (const void *)TFSInfo::SetAirDropBrowserRef((TFSInfo *)cf);
  }
  else
  {
    CFTypeRef cf = CreateSFBrowser(31);
    uint64_t v1 = (const void *)TFSInfo::SetNetworkNearbyBrowserRef((TFSInfo *)cf);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(&cf, v1);
  CFTypeRef v2 = cf;
  CFTypeRef cf = 0;
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&cf);
  return v2;
}

void sub_1D34C6394(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

CFTypeRef CreateSFBrowser(int a1)
{
  SFBrowserLock();
  os_unfair_lock_lock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  if ((a1 - 31) >= 3) {
    abort();
  }
  uint64_t v2 = qword_1D350AFC8[(char)(a1 - 31)];
  SFBrowsers();
  unsigned int v3 = *(const void **)(SFBrowsers(void)::browsers[0] + 8 * v2);
  CFTypeRef cf = v3;
  if (v3)
  {
    CFRetain(v3);
    CFTypeRef v4 = cf;
  }
  else
  {
    CFTypeRef cf = (CFTypeRef)SFBrowserCreate();
    if (cf)
    {
      SFBrowserSetClient();
      uint64_t v5 = TFSVolumeInfo::GetDedicatedGCDQueue(a1);
      SFBrowserSetDispatchQueue();

      CFTypeRef v6 = cf;
    }
    else
    {
      CFTypeRef v6 = 0;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(SFBrowsers(void)::browsers[0] + 8 * v2), v6);
    CFTypeRef v4 = cf;
  }
  CFTypeRef cf = 0;
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&cf);
  os_unfair_lock_unlock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  return v4;
}

void sub_1D34C64F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)va);
  os_unfair_lock_unlock((os_unfair_lock_t)&SFBrowserLock(void)::lock);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetNetworkNearbyBrowserRef(TFSInfo *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v2);
  uint64_t v3 = TFSInfo::gNetworkNearbyBrowserRef;
  if (!TFSInfo::gNetworkNearbyBrowserRef)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&TFSInfo::gNetworkNearbyBrowserRef, a1);
    uint64_t v3 = TFSInfo::gNetworkNearbyBrowserRef;
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1D34C6594(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetAirDropBrowserRef(TFSInfo *a1)
{
  uint64_t v2 = (os_unfair_lock_s *)TFSInfo::NetworkLock(a1);
  os_unfair_lock_lock(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&TFSInfo::gAirDropBrowserRef, a1);
  uint64_t v3 = TFSInfo::gAirDropBrowserRef;
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1D34C65F8(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const void *TFSInfo::CopySFBrowserRef(TFSInfo *this)
{
  BOOL IsContextOpen = TNode::IsContextOpen((TNode *)this);
  if (!IsContextOpen) {
    return 0;
  }
  int v3 = *((unsigned __int8 *)this + 112);
  if (v3 != 33)
  {
    if (v3 == 32 || v3 == 31)
    {
      return TFSInfo::CopyNetworkNearbyBrowserRef((TFSInfo *)IsContextOpen);
    }
    return 0;
  }
  return TFSInfo::CopyAirDropBrowserRef((TFSInfo *)IsContextOpen);
}

void ___ZNK7TFSInfo16GetAliasInfoFromERbS0_P7TStringS2__block_invoke()
{
}

void sub_1D34C66DC(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x60C4044C4A2DFLL);
  _Unwind_Resume(a1);
}

uint64_t TFSInfo::SetAliasIsBurnFolder(TFSInfo *this, int a2)
{
  CFTypeRef v4 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unsigned int v6 = *(_DWORD *)((char *)this + 115);
  uint64_t v5 = (char *)this + 115;
  unint64_t v7 = v6 | ((unint64_t)*((unsigned __int16 *)v5 + 2) << 32);
  uint64_t v8 = (v7 >> 19) & 1;
  int v9 = 0x80000;
  if (!a2) {
    int v9 = 0;
  }
  unint64_t v10 = v7 & 0xFFFFFFFFFFF7FFFFLL;
  *(_DWORD *)uint64_t v5 = v10 | v9;
  *((_WORD *)v5 + 2) = WORD2(v10);
  os_unfair_lock_unlock(v4);
  return v8;
}

uint64_t TPropertyReference::SetAs<SYDocumentAttributes * {__strong}>(uint64_t a1, id *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      objc_storeStrong(*(id **)a1, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      CFTypeRef v4 = *(id **)a1;
      return TPropertyValue::SetAs<SYDocumentAttributes * {__strong}>(v4, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

void TFSInfo::SetTemporaryOriginatorInfo(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v10 = v4;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    uint64_t v5 = *(void *)(a1 + 80);
    if (!v5)
    {
      TFSInfo::GetOrCreateOverflow((TFSInfo *)a1);
      uint64_t v5 = *(void *)(a1 + 80);
      if (!v5) {
        goto LABEL_16;
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 72));
    int v6 = *(unsigned __int8 *)(v5 + 76);
    if (v6 == 3)
    {
      int v6 = 2;
      *(unsigned char *)(v5 + 76) = 2;
      *(void *)uint64_t v5 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 72));
    if (v6 == 2)
    {
      if (!*(void *)v5) {
        goto LABEL_15;
      }
      goto LABEL_16;
    }
    uint64_t v7 = *(void *)(a1 + 80);
    os_unfair_lock_lock((os_unfair_lock_t)(v7 + 72));
    int v8 = *(unsigned __int8 *)(v7 + 76);
    if (v8 == 2)
    {
      TFSInfoOverflow::MigrateToType(v7, 1);
      int v8 = *(unsigned __int8 *)(v7 + 76);
    }
    else if (v8 == 3)
    {
      *(unsigned char *)(v7 + 76) = 1;
      *(void *)(v7 + ++**(_DWORD **)(result + 32) = 0;
      *(_OWORD *)uint64_t v7 = 0u;
      *(_OWORD *)(v7 + 16) = 0u;
      *(_DWORD *)(v7 + ++**(_DWORD **)(result + 32) = 0x80000000;
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72));
LABEL_14:
      uint64_t v9 = *(void *)(v7 + 16);
      uint64_t v5 = v7 + 16;
      if (!v9) {
LABEL_15:
      }
        objc_storeStrong((id *)v5, a2);
LABEL_16:
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
      id v4 = v10;
      goto LABEL_17;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 72));
    if (v8 != 1) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
LABEL_17:
}

void sub_1D34C6B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  os_unfair_lock_unlock(v10);

  _Unwind_Resume(a1);
}

uint64_t TFSInfo::CanHaveOriginatorInfo(TFSInfo *this)
{
  if (!ReturnToSenderEnabled()) {
    return 0;
  }
  int v2 = TFSInfo::OriginatorInfo(this);

  if (v2) {
    return 1;
  }
  if (*((unsigned char *)this + 112)) {
    return 0;
  }
  id location = 0;
  TFSInfo::GetUTType(this, &location, 128, &v9);
  id v5 = location;
  if (v5)
  {
    SYDocumentWorkflowsClass Class = (void *)getSYDocumentWorkflowsClass();
    uint64_t v7 = [v5 identifier];
    uint64_t v3 = [SYDocumentWorkflowsClass isSupportedContentType:v7];
  }
  else
  {
    int v8 = (os_unfair_lock_s *)((char *)this + 100);
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    uint64_t v3 = (*(_DWORD *)((char *)this + 115) & 0x40) == 0;
    os_unfair_lock_unlock(v8);
  }

  return v3;
}

void sub_1D34C6C44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const void **TFSInfo::dCPath@<X0>(TFSInfo *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  if (*((unsigned char *)this + 112)
    || (os_unfair_lock_lock((os_unfair_lock_t)this + 25),
        unint64_t v6 = *(unsigned int *)((char *)this + 115) | ((unint64_t)*(unsigned __int16 *)((char *)this + 119) << 32),
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25),
        (v6 & 0x100000000) != 0)
    || (os_unfair_lock_lock((os_unfair_lock_t)this + 25),
        int v7 = *(_DWORD *)((char *)this + 115),
        os_unfair_lock_unlock((os_unfair_lock_t)this + 25),
        (v7 & 0x100) != 0))
  {
    if (a2) {
      TFSInfo::DisplayName(this, &v13);
    }
    else {
      TFSInfo::GetDisplayNameWhileLocked(this, &v13);
    }
    TString::Str(&v13, a3);
    return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 25);
    CFStringRef v8 = (const __CFString *)*((void *)this + 2);
    CFStringRef theString = v8;
    if (v8) {
      CFRetain(v8);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 25);
    char v9 = (__CFString *)CFURLCopyFileSystemPath((CFURLRef)v8, kCFURLPOSIXPathStyle);
    v13.fString.uint64_t fRef = v9;
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&theString);
    CFStringRef theString = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&theString, (TString *)v9);
    if (CFStringGetLength(theString))
    {
      TString::Str((TString *)&theString, a3);
    }
    else
    {
      if (a2) {
        TFSInfo::Name(this, &v11);
      }
      else {
        TFSInfo::GetNameWhileLocked(this, &v11);
      }
      TString::Str(&v11, a3);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v11.fString.fRef);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    return TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)&v13.fString.fRef);
  }
}

void sub_1D34C6E00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, const void *);
  va_copy(va2, va1);
  id v5 = va_arg(va2, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TAutoRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TAutoRef((const void **)va2);
  _Unwind_Resume(a1);
}

uint64_t TFSIterator::TFSIterator(uint64_t a1, CFTypeRef cf, CFTypeRef a3, int a4, char a5)
{
  *(void *)a1 = cf;
  if (cf) {
    CFRetain(cf);
  }
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 2TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 4) = a3;
  *(void *)(a1 + 16) = 0;
  if (a3) {
    CFRetain(a3);
  }
  *(_DWORD *)(a1 + ++**(_DWORD **)(result + 32) = a4;
  *(unsigned char *)(a1 + 36) = a5;
  *(unsigned char *)(a1 + 37) = 1;
  char v9 = [*(id *)a1 path];
  CFTypeRef cf1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf1, v9);

  {
    TString::TString((TString *)&TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternal, "/private/var/mobile/Library/LiveFiles", 0x25uLL);
  }
  {
    TString::operator+((const __CFString **)&TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternal, (const __CFString *)"/", &TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternalPrefix);
  }
  if (CFEqual(cf1, (CFTypeRef)TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternal)) {
    BOOL v10 = 0;
  }
  else {
    BOOL v10 = !TString::BeginsWith((TString *)&cf1, &TFSIterator::TFSIterator(__CFURL const*,__CFArray const*,LSProperties,BOOL)::iosExternalPrefix);
  }
  *(unsigned char *)(a1 + 37) = v10;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return a1;
}

void sub_1D34C7010(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(v4);
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(v3);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(v2);
  _Unwind_Resume(a1);
}

TString *TString::operator+@<X0>(const __CFString **a1@<X0>, const __CFString *a2@<X1>, TString *a3@<X8>)
{
  CFStringRef v5 = *a1;
  a3->fString.uint64_t fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  MutableCFStringRef Copy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v5);
  if (a3->fString.fRef) {
    CFRelease(a3->fString.fRef);
  }
  a3->fString.uint64_t fRef = MutableCopy;
  return TString::Append(a3, a2);
}

void sub_1D34C710C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

const void **TFSIterator::Reset(const void **this)
{
  if (*this)
  {
    uint64_t v1 = this;
    int v2 = (const void *)MEMORY[0x1D9435F70](0, *this, this[2], this[3]);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(v1 + 1, v2);
    return TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef(&v2);
  }
  return this;
}

void sub_1D34C717C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TAutoRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TFSIterator::First(uint64_t a1, uint64_t a2)
{
  TFSIterator::Reset((const void **)a1);
  if (!*(void *)(a1 + 8)) {
    return 4294965879;
  }
  return TFSIterator::Next(a1, a2);
}

uint64_t TFSIterator::NextRaw(uint64_t a1, uint64_t *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = 0;
  CFURLRef v17 = 0;
  uint64_t v4 = MEMORY[0x1D9435F80](*(void *)(a1 + 8), &v17, &v16);
  if (v4 == 1)
  {
    int v10 = *(unsigned __int8 *)(a1 + 37);
    if (IsAppInbox(v17)) {
      goto LABEL_14;
    }
    int v11 = TFSInfo::initialize(*a2, (const __CFURL *)v17, *(_DWORD *)(a1 + 32), 1, v10 != 0, 1, 0);
    if (v11)
    {
      if (!*(unsigned char *)(a1 + 36) || TCFURLInfo::VolumeIsAll((TCFURLInfo *)v17, (const __CFURL *)0x10000)) {
        goto LABEL_14;
      }
      int v7 = LogObj(4);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        NodeEventRefFromNodeEvent((id *)&v17);
        uint64_t v12 = (NSURL *)objc_claimAutoreleasedReturnValue();
        TString v13 = SanitizedURL(v12);
        *(_DWORD *)stat buf = 138543618;
        char v19 = v13;
        __int16 v20 = 1024;
        int v21 = v11;
        _os_log_impl(&dword_1D343E000, v7, OS_LOG_TYPE_INFO, "TFSIterator initialize failed, skipping %{public}@, status = %d", buf, 0x12u);
      }
      goto LABEL_13;
    }
LABEL_16:
    uint64_t v14 = 0;
    goto LABEL_17;
  }
  if (v4 != 3)
  {
    uint64_t v14 = 4294965879;
    goto LABEL_17;
  }
  int v6 = TCFURLInfo::TranslateCFError(v16, v5);
  if (!v6) {
    goto LABEL_16;
  }
  if (*(unsigned char *)(a1 + 36))
  {
    int v7 = LogObj(4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      CFStringRef v8 = v17;
      char v9 = SanitizedURL(v8);
      *(_DWORD *)stat buf = 138543618;
      char v19 = v9;
      __int16 v20 = 1024;
      int v21 = v6;
      _os_log_impl(&dword_1D343E000, v7, OS_LOG_TYPE_INFO, "kCFURLEnumeratorError for %{public}@, status = %d", buf, 0x12u);
    }
LABEL_13:
  }
LABEL_14:
  uint64_t v14 = 4294959234;
LABEL_17:
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v16);
  return v14;
}

void sub_1D34C73FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<unsigned int>(uint64_t a1, _DWORD *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_47;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_47;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_47;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_47;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_47;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 7:
      if (v2 != 7) {
        goto LABEL_47;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_47;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_47;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_47;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_47;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_47;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_47;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_47;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_47;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_47;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_47;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_47;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_47;
      }
      uint64_t v4 = *(_DWORD **)a1;
      return TPropertyValue::SetAs<unsigned int>(v4, a2);
    case 20:
      if (v2 != 20) {
        goto LABEL_47;
      }
LABEL_43:
      uint64_t result = 0;
      **(_DWORD **)a1 = *a2;
      return result;
    case 21:
      if (v2 == 21) {
        return 4294959246;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_47;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_47:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

uint64_t TPropertyReference::SetAs<int>(uint64_t a1, _DWORD *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      goto LABEL_49;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      uint64_t result = 0;
      **(void **)a1 = (int)*a2;
      break;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      goto LABEL_43;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      CFStringRef v5 = *(void **)a1;
      uint64_t result = TPropertyValue::SetAs<int>(v5, a2);
      break;
    case 20:
      if (v2 == 20) {
        goto LABEL_43;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      goto LABEL_49;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      goto LABEL_49;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_49:
      uint64_t result = 0;
      **(_DWORD **)a1 = *a2;
      break;
    default:
LABEL_43:
      uint64_t result = 4294959246;
      break;
  }
  return result;
}

uint64_t TPropertyReference::SetAs<Point>(uint64_t a1, _DWORD *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_45;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_45;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_45;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_45;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_45;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_45;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_45;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_45;
      }
      uint64_t result = 0;
      **(_DWORD **)a1 = *a2;
      return result;
    case 9:
      if (v2 != 9) {
        goto LABEL_45;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_45;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_45;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_45;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_45;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_45;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_45;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_45;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_45;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_45;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_45;
      }
      CFStringRef v5 = *(_DWORD **)a1;
      return TPropertyValue::SetAs<Point>(v5, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_45;
    case 21:
      if (v2 != 21) {
        goto LABEL_45;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_45;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_45:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}